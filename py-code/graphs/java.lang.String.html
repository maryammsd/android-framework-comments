<html>
    <head>
        <meta charset="utf-8">
        
            <script src="lib/bindings/utils.js"></script>
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/dist/vis-network.min.css" integrity="sha512-WgxfT5LWjfszlPHXRmBWHkV2eceiWTOBvrKCNbdgDYTHrT2AeLCGbF4sZlZw3UMN3WtL0tGUoIAKsu8mllg/XA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
            <script src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/vis-network.min.js" integrity="sha512-LnvoEWDFrqGHlHmDD2101OrLcbsfkrzoSpvtSQtxK3RMnRV0eOkhhBN2dXHKRrUU8p2DGRTk35n4O8nWSVe1mQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
            
        
<center>
<h1></h1>
</center>

<!-- <link rel="stylesheet" href="../node_modules/vis/dist/vis.min.css" type="text/css" />
<script type="text/javascript" src="../node_modules/vis/dist/vis.js"> </script>-->
        <link
          href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css"
          rel="stylesheet"
          integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6"
          crossorigin="anonymous"
        />
        <script
          src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js"
          integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf"
          crossorigin="anonymous"
        ></script>


        <center>
          <h1></h1>
        </center>
        <style type="text/css">

             #mynetwork {
                 width: 100%;
                 height: 600px;
                 background-color: #ffffff;
                 border: 1px solid lightgray;
                 position: relative;
                 float: left;
             }

             
             #loadingBar {
                 position:absolute;
                 top:0px;
                 left:0px;
                 width: 100%;
                 height: 600px;
                 background-color:rgba(200,200,200,0.8);
                 -webkit-transition: all 0.5s ease;
                 -moz-transition: all 0.5s ease;
                 -ms-transition: all 0.5s ease;
                 -o-transition: all 0.5s ease;
                 transition: all 0.5s ease;
                 opacity:1;
             }

             #bar {
                 position:absolute;
                 top:0px;
                 left:0px;
                 width:20px;
                 height:20px;
                 margin:auto auto auto auto;
                 border-radius:11px;
                 border:2px solid rgba(30,30,30,0.05);
                 background: rgb(0, 173, 246); /* Old browsers */
                 box-shadow: 2px 0px 4px rgba(0,0,0,0.4);
             }

             #border {
                 position:absolute;
                 top:10px;
                 left:10px;
                 width:500px;
                 height:23px;
                 margin:auto auto auto auto;
                 box-shadow: 0px 0px 4px rgba(0,0,0,0.2);
                 border-radius:10px;
             }

             #text {
                 position:absolute;
                 top:8px;
                 left:530px;
                 width:30px;
                 height:50px;
                 margin:auto auto auto auto;
                 font-size:22px;
                 color: #000000;
             }

             div.outerBorder {
                 position:relative;
                 top:400px;
                 width:600px;
                 height:44px;
                 margin:auto auto auto auto;
                 border:8px solid rgba(0,0,0,0.1);
                 background: rgb(252,252,252); /* Old browsers */
                 background: -moz-linear-gradient(top,  rgba(252,252,252,1) 0%, rgba(237,237,237,1) 100%); /* FF3.6+ */
                 background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,rgba(252,252,252,1)), color-stop(100%,rgba(237,237,237,1))); /* Chrome,Safari4+ */
                 background: -webkit-linear-gradient(top,  rgba(252,252,252,1) 0%,rgba(237,237,237,1) 100%); /* Chrome10+,Safari5.1+ */
                 background: -o-linear-gradient(top,  rgba(252,252,252,1) 0%,rgba(237,237,237,1) 100%); /* Opera 11.10+ */
                 background: -ms-linear-gradient(top,  rgba(252,252,252,1) 0%,rgba(237,237,237,1) 100%); /* IE10+ */
                 background: linear-gradient(to bottom,  rgba(252,252,252,1) 0%,rgba(237,237,237,1) 100%); /* W3C */
                 filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#fcfcfc', endColorstr='#ededed',GradientType=0 ); /* IE6-9 */
                 border-radius:72px;
                 box-shadow: 0px 0px 10px rgba(0,0,0,0.2);
             }
             

             

             
             /* position absolute is important and the container has to be relative or absolute as well. */
          div.popup {
                 position:absolute;
                 top:0px;
                 left:0px;
                 display:none;
                 background-color:#f5f4ed;
                 -moz-border-radius: 3px;
                 -webkit-border-radius: 3px;
                 border-radius: 3px;
                 border: 1px solid #808074;
                 box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);
          }

          /* hide the original tooltip */
          .vis-tooltip {
            display:none;
          }
             
        </style>
    </head>


    <body>
        <div class="card" style="width: 100%">
            
            
            <div id="mynetwork" class="card-body"></div>
        </div>

        
            <div id="loadingBar">
              <div class="outerBorder">
                <div id="text">0%</div>
                <div id="border">
                  <div id="bar"></div>
                </div>
              </div>
            </div>
        
        

        <script type="text/javascript">

              // initialize global variables.
              var edges;
              var nodes;
              var allNodes;
              var allEdges;
              var nodeColors;
              var originalNodes;
              var network;
              var container;
              var options, data;
              var filter = {
                  item : '',
                  property : '',
                  value : []
              };

              

              

              // This method is responsible for drawing the graph, returns the drawn network
              function drawGraph() {
                  var container = document.getElementById('mynetwork');

                  

                  // parsing and collecting nodes and edges from the python
                  nodes = new vis.DataSet([{"color": "#97c2fc", "id": "java.lang.String", "label": "java.lang.String", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public int length()", "label": "public int length()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the length of the erroneous input described by this\\n     * object\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * @return  The length of the erroneous input, a positive integer\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          If this object does not describe an error condition, that is,\\n     *          if the {@link #isError() isError} does not return {@code true}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isEmpty()", "label": "public boolean isEmpty()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if, and only if, {@link #length()} is {@code 0}.\\n     *\\n     * @return {@code true} if {@link #length()} is {@code 0}, otherwise\\n     * {@code false}\\n     *\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "length()", "label": "length()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public native char charAt(int index)", "label": "public native char charAt(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public char charAt(int index) {\\n        if (isLatin1()) {\\n            return StringLatin1.charAt(value, index);\\n        } else {\\n            return StringUTF16.charAt(value, index);\\n        }\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public int codePointAt(int index)", "label": "public int codePointAt(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the character (Unicode code point) at the specified\\n     * index. The index refers to {@code char} values\\n     * (Unicode code units) and ranges from {@code 0} to\\n     * {@link #length()}{@code  - 1}.\\n     *\\n     * \u003cp\u003e If the {@code char} value specified at the given index\\n     * is in the high-surrogate range, the following index is less\\n     * than the length of this {@code String}, and the\\n     * {@code char} value at the following index is in the\\n     * low-surrogate range, then the supplementary code point\\n     * corresponding to this surrogate pair is returned. Otherwise,\\n     * the {@code char} value at the given index is returned.\\n     *\\n     * @param      index the index to the {@code char} values\\n     * @return     the code point value of the character at the\\n     *             {@code index}\\n     * @exception  IndexOutOfBoundsException  if the {@code index}\\n     *             argument is negative or not less than the length of this\\n     *             string.\\n     * @since      1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int codePointBefore(int index)", "label": "public int codePointBefore(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the character (Unicode code point) before the specified\\n     * index. The index refers to {@code char} values\\n     * (Unicode code units) and ranges from {@code 1} to {@link\\n     * CharSequence#length() length}.\\n     *\\n     * \u003cp\u003e If the {@code char} value at {@code (index - 1)}\\n     * is in the low-surrogate range, {@code (index - 2)} is not\\n     * negative, and the {@code char} value at {@code (index -\\n     * 2)} is in the high-surrogate range, then the\\n     * supplementary code point value of the surrogate pair is\\n     * returned. If the {@code char} value at {@code index -\\n     * 1} is an unpaired low-surrogate or a high-surrogate, the\\n     * surrogate value is returned.\\n     *\\n     * @param     index the index following the code point that should be returned\\n     * @return    the Unicode code point value before the given index.\\n     * @exception IndexOutOfBoundsException if the {@code index}\\n     *            argument is less than 1 or greater than the length\\n     *            of this string.\\n     * @since     1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.lang.CharSequence", "label": "java.lang.CharSequence", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": " int length()", "label": " int length()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the length of this character sequence.  The length is the number\\n     * of 16-bit {@code char}s in the sequence.\\n     *\\n     * @return  the number of {@code char}s in this sequence\\n     \u0027}"}, {"color": "#97c2fc", "id": " char charAt(int index)", "label": " char charAt(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the {@code char} value at the specified index.  An index ranges from zero\\n     * to {@code length() - 1}.  The first {@code char} value of the sequence is at\\n     * index zero, the next at index one, and so on, as for array\\n     * indexing.\\n     *\\n     * \u003cp\u003eIf the {@code char} value specified by the index is a\\n     * \u003ca href=\"{@docRoot}/java.base/java/lang/Character.html#unicode\"\u003esurrogate\u003c/a\u003e, the surrogate\\n     * value is returned.\\n     *\\n     * @param   index   the index of the {@code char} value to be returned\\n     *\\n     * @return  the specified {@code char} value\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          if the {@code index} argument is negative or not less than\\n     *          {@code length()}\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean isEmpty()", "label": " boolean isEmpty()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if this character sequence is empty.\\n     *\\n     * @implSpec\\n     * The default implementation returns the result of calling {@code length() == 0}.\\n     *\\n     * @return {@code true} if {@link #length()} is {@code 0}, otherwise\\n     * {@code false}\\n     *\\n     * @since 15\\n     \u0027}"}, {"color": "#97c2fc", "id": " CharSequence subSequence(int start, int end)", "label": " CharSequence subSequence(int start, int end)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code CharSequence} that is a subsequence of this sequence.\\n     * The subsequence starts with the {@code char} value at the specified index and\\n     * ends with the {@code char} value at index {@code end - 1}.  The length\\n     * (in {@code char}s) of the\\n     * returned sequence is {@code end - start}, so if {@code start == end}\\n     * then an empty sequence is returned.\\n     *\\n     * @param   start   the start index, inclusive\\n     * @param   end     the end index, exclusive\\n     *\\n     * @return  the specified subsequence\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          if {@code start} or {@code end} are negative,\\n     *          if {@code end} is greater than {@code length()},\\n     *          or if {@code start} is greater than {@code end}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String toString()", "label": "public String toString()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * This object (which is already a string!) is itself returned.\\n     *\\n     * @return  the string itself.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public IntStream chars()", "label": "public IntStream chars()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream of {@code int} zero-extending the {@code char} values\\n     * from this sequence.  Any char which maps to a \u003ca\\n     * href=\"{@docRoot}/java.base/java/lang/Character.html#unicode\"\u003esurrogate code\\n     * point\u003c/a\u003e is passed through uninterpreted.\\n     *\\n     * @return an IntStream of char values from this sequence\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public IntStream codePoints()", "label": "public IntStream codePoints()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream of code point values from this sequence.  Any surrogate\\n     * pairs encountered in the sequence are combined as if by {@linkplain\\n     * Character#toCodePoint Character.toCodePoint} and the result is passed\\n     * to the stream. Any other code units, including ordinary BMP characters,\\n     * unpaired surrogates, and undefined code units, are zero-extended to\\n     * {@code int} values which are then passed to the stream.\\n     *\\n     * @return an IntStream of Unicode code points from this sequence\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int compare(CharSequence cs1, CharSequence cs2)", "label": "public static int compare(CharSequence cs1, CharSequence cs2)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code CharSequence} instances lexicographically. Returns a\\n     * negative value, zero, or a positive value if the first sequence is lexicographically\\n     * less than, equal to, or greater than the second, respectively.\\n     *\\n     * \u003cp\u003e\\n     * The lexicographical ordering of {@code CharSequence} is defined as follows.\\n     * Consider a {@code CharSequence} \u003ci\u003ecs\u003c/i\u003e of length \u003ci\u003elen\u003c/i\u003e to be a\\n     * sequence of char values, \u003ci\u003ecs[0]\u003c/i\u003e to \u003ci\u003ecs[len-1]\u003c/i\u003e. Suppose \u003ci\u003ek\u003c/i\u003e\\n     * is the lowest index at which the corresponding char values from each sequence\\n     * differ. The lexicographic ordering of the sequences is determined by a numeric\\n     * comparison of the char values \u003ci\u003ecs1[k]\u003c/i\u003e with \u003ci\u003ecs2[k]\u003c/i\u003e. If there is\\n     * no such index \u003ci\u003ek\u003c/i\u003e, the shorter sequence is considered lexicographically\\n     * less than the other. If the sequences have the same length, the sequences are\\n     * considered lexicographically equal.\\n     *\\n     *\\n     * @param cs1 the first {@code CharSequence}\\n     * @param cs2 the second {@code CharSequence}\\n     *\\n     * @return  the value {@code 0} if the two {@code CharSequence} are equal;\\n     *          a negative integer if the first {@code CharSequence}\\n     *          is lexicographically less than the second; or a\\n     *          positive integer if the first {@code CharSequence} is\\n     *          lexicographically greater than the second.\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int codePointCount(int beginIndex, int endIndex)", "label": "public int codePointCount(int beginIndex, int endIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the number of Unicode code points in the specified text\\n     * range of this {@code String}. The text range begins at the\\n     * specified {@code beginIndex} and extends to the\\n     * {@code char} at index {@code endIndex - 1}. Thus the\\n     * length (in {@code char}s) of the text range is\\n     * {@code endIndex-beginIndex}. Unpaired surrogates within\\n     * the text range count as one code point each.\\n     *\\n     * @param beginIndex the index to the first {@code char} of\\n     * the text range.\\n     * @param endIndex the index after the last {@code char} of\\n     * the text range.\\n     * @return the number of Unicode code points in the specified text\\n     * range\\n     * @exception IndexOutOfBoundsException if the\\n     * {@code beginIndex} is negative, or {@code endIndex}\\n     * is larger than the length of this {@code String}, or\\n     * {@code beginIndex} is larger than {@code endIndex}.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int offsetByCodePoints(int index, int codePointOffset)", "label": "public int offsetByCodePoints(int index, int codePointOffset)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index within this {@code String} that is\\n     * offset from the given {@code index} by\\n     * {@code codePointOffset} code points. Unpaired surrogates\\n     * within the text range given by {@code index} and\\n     * {@code codePointOffset} count as one code point each.\\n     *\\n     * @param index the index to be offset\\n     * @param codePointOffset the offset in code points\\n     * @return the index within this {@code String}\\n     * @exception IndexOutOfBoundsException if {@code index}\\n     *   is negative or larger then the length of this\\n     *   {@code String}, or if {@code codePointOffset} is positive\\n     *   and the substring starting with {@code index} has fewer\\n     *   than {@code codePointOffset} code points,\\n     *   or if {@code codePointOffset} is negative and the substring\\n     *   before {@code index} has fewer than the absolute value\\n     *   of {@code codePointOffset} code points.\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": " void getChars(char[] dst, int dstBegin)", "label": " void getChars(char[] dst, int dstBegin)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Copy characters from this string into dst starting at dstBegin.\\n     * This method doesn\u0027t perform any range checking.\\n     \"}"}, {"color": "#97c2fc", "id": "public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)", "label": "public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies characters from this string into the destination character\\n     * array.\\n     * \u003cp\u003e\\n     * The first character to be copied is at index {@code srcBegin};\\n     * the last character to be copied is at index {@code srcEnd-1}\\n     * (thus the total number of characters to be copied is\\n     * {@code srcEnd-srcBegin}). The characters are copied into the\\n     * subarray of {@code dst} starting at index {@code dstBegin}\\n     * and ending at index:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     *     dstBegin + (srcEnd-srcBegin) - 1\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @param      srcBegin   index of the first character in the string\\n     *                        to copy.\\n     * @param      srcEnd     index after the last character in the string\\n     *                        to copy.\\n     * @param      dst        the destination array.\\n     * @param      dstBegin   the start offset in the destination array.\\n     * @exception IndexOutOfBoundsException If any of the following\\n     *            is true:\\n     *            \u003cul\u003e\u003cli\u003e{@code srcBegin} is negative.\\n     *            \u003cli\u003e{@code srcBegin} is greater than {@code srcEnd}\\n     *            \u003cli\u003e{@code srcEnd} is greater than the length of this\\n     *                string\\n     *            \u003cli\u003e{@code dstBegin} is negative\\n     *            \u003cli\u003e{@code dstBegin+(srcEnd-srcBegin)} is larger than\\n     *                {@code dst.length}\u003c/ul\u003e\\n     \u0027}"}, {"color": "#97c2fc", "id": " native void getCharsNoCheck(int start, int end, char[] buffer, int index)", "label": " native void getCharsNoCheck(int start, int end, char[] buffer, int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * getChars without bounds checks, for use by other classes\\n     * within the java.lang package only.  The caller is responsible for\\n     * ensuring that start \u003e= 0 \u0026\u0026 start \u003c= end \u0026\u0026 end \u003c= count.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public byte[] getBytes(String charsetName) throws UnsupportedEncodingException", "label": "public byte[] getBytes(String charsetName) throws UnsupportedEncodingException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Encodes this {@code String} into a sequence of bytes using the named\\n     * charset, storing the result into a new byte array.\\n     *\\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\\n     * the given charset is unspecified.  The {@link\\n     * java.nio.charset.CharsetEncoder} class should be used when more control\\n     * over the encoding process is required.\\n     *\\n     * @param  charsetName\\n     *         The name of a supported {@linkplain java.nio.charset.Charset\\n     *         charset}\\n     *\\n     * @return  The resultant byte array\\n     *\\n     * @throws  UnsupportedEncodingException\\n     *          If the named charset is not supported\\n     *\\n     * @since  1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.nio.charset.CharsetEncoder", "label": "java.nio.charset.CharsetEncoder", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public final Charset charset()", "label": "public final Charset charset()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the charset that created this encoder.\\n     *\\n     * @return  This encoder\u0027s charset\\n     \"}"}, {"color": "#97c2fc", "id": "public final byte[] replacement()", "label": "public final byte[] replacement()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns this encoder\u0027s replacement value.\\n     *\\n     * @return  This encoder\u0027s current replacement,\\n     *          which is never {@code null} and is never empty\\n     \"}"}, {"color": "#97c2fc", "id": "public final CharsetEncoder replaceWith(byte[] newReplacement)", "label": "public final CharsetEncoder replaceWith(byte[] newReplacement)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Changes this encoder\u0027s replacement value.\\n     *\\n     * \u003cp\u003e This method invokes the {@link #implReplaceWith implReplaceWith}\\n     * method, passing the new replacement, after checking that the new\\n     * replacement is acceptable.  \u003c/p\u003e\\n     *\\n     * @param  newReplacement  The new replacement; must not be\\n     *         {@code null}, must have non-zero length,\\n\\n\\n\\n\\n\\n     *         must not be longer than the value returned by the\\n     *         {@link #maxBytesPerChar() maxBytesPerChar} method, and\\n     *         must be {@link #isLegalReplacement legal}\\n\\n     *\\n     * @return  This encoder\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the preconditions on the parameter do not hold\\n     \"}"}, {"color": "#97c2fc", "id": "implReplaceWith", "label": "implReplaceWith", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "maxBytesPerChar()", "label": "maxBytesPerChar()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "isLegalReplacement", "label": "isLegalReplacement", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "protected void implReplaceWith(byte[] newReplacement)", "label": "protected void implReplaceWith(byte[] newReplacement)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reports a change to this encoder\u0027s replacement value.\\n     *\\n     * \u003cp\u003e The default implementation of this method does nothing.  This method\\n     * should be overridden by encoders that require notification of changes to\\n     * the replacement.  \u003c/p\u003e\\n     *\\n     * @param  newReplacement    The replacement value\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean isLegalReplacement(byte[] repl)", "label": "public boolean isLegalReplacement(byte[] repl)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Tells whether or not the given byte array is a legal replacement value\\n     * for this encoder.\\n     *\\n     * \u003cp\u003e A replacement is legal if, and only if, it is a legal sequence of\\n     * bytes in this encoder\u0027s charset; that is, it must be possible to decode\\n     * the replacement into one or more sixteen-bit Unicode characters.\\n     *\\n     * \u003cp\u003e The default implementation of this method is not very efficient; it\\n     * should generally be overridden to improve performance.  \u003c/p\u003e\\n     *\\n     * @param  repl  The byte array to be tested\\n     *\\n     * @return  {@code true} if, and only if, the given byte array\\n     *          is a legal replacement value for this encoder\\n     \"}"}, {"color": "#97c2fc", "id": "public CodingErrorAction malformedInputAction()", "label": "public CodingErrorAction malformedInputAction()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns this encoder\u0027s current action for malformed-input errors.\\n     *\\n     * @return The current malformed-input action, which is never {@code null}\\n     \"}"}, {"color": "#97c2fc", "id": "public final CharsetEncoder onMalformedInput(CodingErrorAction newAction)", "label": "public final CharsetEncoder onMalformedInput(CodingErrorAction newAction)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Changes this encoder\u0027s action for malformed-input errors.\\n     *\\n     * \u003cp\u003e This method invokes the {@link #implOnMalformedInput\\n     * implOnMalformedInput} method, passing the new action.  \u003c/p\u003e\\n     *\\n     * @param  newAction  The new action; must not be {@code null}\\n     *\\n     * @return  This encoder\\n     *\\n     * @throws IllegalArgumentException\\n     *         If the precondition on the parameter does not hold\\n     \"}"}, {"color": "#97c2fc", "id": "implOnMalformedInputimplOnMalformedInput", "label": "implOnMalformedInputimplOnMalformedInput", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "protected void implOnMalformedInput(CodingErrorAction newAction)", "label": "protected void implOnMalformedInput(CodingErrorAction newAction)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reports a change to this encoder\u0027s malformed-input action.\\n     *\\n     * \u003cp\u003e The default implementation of this method does nothing.  This method\\n     * should be overridden by encoders that require notification of changes to\\n     * the malformed-input action.  \u003c/p\u003e\\n     *\\n     * @param  newAction  The new action\\n     \"}"}, {"color": "#97c2fc", "id": "public CodingErrorAction unmappableCharacterAction()", "label": "public CodingErrorAction unmappableCharacterAction()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns this encoder\u0027s current action for unmappable-character errors.\\n     *\\n     * @return The current unmappable-character action, which is never\\n     *         {@code null}\\n     \"}"}, {"color": "#97c2fc", "id": "public final CharsetEncoder onUnmappableCharacter(CodingErrorAction newAction)", "label": "public final CharsetEncoder onUnmappableCharacter(CodingErrorAction newAction)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Changes this encoder\u0027s action for unmappable-character errors.\\n     *\\n     * \u003cp\u003e This method invokes the {@link #implOnUnmappableCharacter\\n     * implOnUnmappableCharacter} method, passing the new action.  \u003c/p\u003e\\n     *\\n     * @param  newAction  The new action; must not be {@code null}\\n     *\\n     * @return  This encoder\\n     *\\n     * @throws IllegalArgumentException\\n     *         If the precondition on the parameter does not hold\\n     \"}"}, {"color": "#97c2fc", "id": "implOnUnmappableCharacterimplOnUnmappableCharacter", "label": "implOnUnmappableCharacterimplOnUnmappableCharacter", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "protected void implOnUnmappableCharacter(CodingErrorAction newAction)", "label": "protected void implOnUnmappableCharacter(CodingErrorAction newAction)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reports a change to this encoder\u0027s unmappable-character action.\\n     *\\n     * \u003cp\u003e The default implementation of this method does nothing.  This method\\n     * should be overridden by encoders that require notification of changes to\\n     * the unmappable-character action.  \u003c/p\u003e\\n     *\\n     * @param  newAction  The new action\\n     \"}"}, {"color": "#97c2fc", "id": "public final float averageBytesPerChar()", "label": "public final float averageBytesPerChar()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the average number of bytes that will be produced for each\\n     * character of input.  This heuristic value may be used to estimate the size\\n     * of the output buffer required for a given input sequence.\\n     *\\n     * @return  The average number of bytes produced\\n     *          per character of input\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final float maxBytesPerChar()", "label": "public final float maxBytesPerChar()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the maximum number of bytes that will be produced for each\\n     * character of input.  This value may be used to compute the worst-case size\\n     * of the output buffer required for a given input sequence. This value\\n     * accounts for any necessary content-independent prefix or suffix\\n\\n     * bytes, such as byte-order marks.\\n\\n\\n\\n\\n     *\\n     * @return  The maximum number of bytes that will be produced per\\n     *          character of input\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final CoderResult encode(CharBuffer in, ByteBuffer out, boolean endOfInput)", "label": "public final CoderResult encode(CharBuffer in, ByteBuffer out, boolean endOfInput)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Encodes as many characters as possible from the given input buffer,\\n     * writing the results to the given output buffer.\\n     *\\n     * \u003cp\u003e The buffers are read from, and written to, starting at their current\\n     * positions.  At most {@link Buffer#remaining in.remaining()} characters\\n     * will be read and at most {@link Buffer#remaining out.remaining()}\\n     * bytes will be written.  The buffers\\\u0027 positions will be advanced to\\n     * reflect the characters read and the bytes written, but their marks and\\n     * limits will not be modified.\\n     *\\n     * \u003cp\u003e In addition to reading characters from the input buffer and writing\\n     * bytes to the output buffer, this method returns a {@link CoderResult}\\n     * object to describe its reason for termination:\\n     *\\n     * \u003cul\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e {@link CoderResult#UNDERFLOW} indicates that as much of the\\n     *   input buffer as possible has been encoded.  If there is no further\\n     *   input then the invoker can proceed to the next step of the\\n     *   \u003ca href=\"#steps\"\u003eencoding operation\u003c/a\u003e.  Otherwise this method\\n     *   should be invoked again with further input.  \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e {@link CoderResult#OVERFLOW} indicates that there is\\n     *   insufficient space in the output buffer to encode any more characters.\\n     *   This method should be invoked again with an output buffer that has\\n     *   more {@linkplain Buffer#remaining remaining} bytes. This is\\n     *   typically done by draining any encoded bytes from the output\\n     *   buffer.  \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e A {@linkplain CoderResult#malformedForLength\\n     *   malformed-input} result indicates that a malformed-input\\n     *   error has been detected.  The malformed characters begin at the input\\n     *   buffer\\\u0027s (possibly incremented) position; the number of malformed\\n     *   characters may be determined by invoking the result object\\\u0027s {@link\\n     *   CoderResult#length() length} method.  This case applies only if the\\n     *   {@linkplain #onMalformedInput malformed action} of this encoder\\n     *   is {@link CodingErrorAction#REPORT}; otherwise the malformed input\\n     *   will be ignored or replaced, as requested.  \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e An {@linkplain CoderResult#unmappableForLength\\n     *   unmappable-character} result indicates that an\\n     *   unmappable-character error has been detected.  The characters that\\n     *   encode the unmappable character begin at the input buffer\\\u0027s (possibly\\n     *   incremented) position; the number of such characters may be determined\\n     *   by invoking the result object\\\u0027s {@link CoderResult#length() length}\\n     *   method.  This case applies only if the {@linkplain #onUnmappableCharacter\\n     *   unmappable action} of this encoder is {@link\\n     *   CodingErrorAction#REPORT}; otherwise the unmappable character will be\\n     *   ignored or replaced, as requested.  \u003c/p\u003e\u003c/li\u003e\\n     *\\n     * \u003c/ul\u003e\\n     *\\n     * In any case, if this method is to be reinvoked in the same encoding\\n     * operation then care should be taken to preserve any characters remaining\\n     * in the input buffer so that they are available to the next invocation.\\n     *\\n     * \u003cp\u003e The {@code endOfInput} parameter advises this method as to whether\\n     * the invoker can provide further input beyond that contained in the given\\n     * input buffer.  If there is a possibility of providing additional input\\n     * then the invoker should pass {@code false} for this parameter; if there\\n     * is no possibility of providing further input then the invoker should\\n     * pass {@code true}.  It is not erroneous, and in fact it is quite\\n     * common, to pass {@code false} in one invocation and later discover that\\n     * no further input was actually available.  It is critical, however, that\\n     * the final invocation of this method in a sequence of invocations always\\n     * pass {@code true} so that any remaining unencoded input will be treated\\n     * as being malformed.\\n     *\\n     * \u003cp\u003e This method works by invoking the {@link #encodeLoop encodeLoop}\\n     * method, interpreting its results, handling error conditions, and\\n     * reinvoking it as necessary.  \u003c/p\u003e\\n     *\\n     *\\n     * @param  in\\n     *         The input character buffer\\n     *\\n     * @param  out\\n     *         The output byte buffer\\n     *\\n     * @param  endOfInput\\n     *         {@code true} if, and only if, the invoker can provide no\\n     *         additional input characters beyond those in the given buffer\\n     *\\n     * @return  A coder-result object describing the reason for termination\\n     *\\n     * @throws  IllegalStateException\\n     *          If an encoding operation is already in progress and the previous\\n     *          step was an invocation neither of the {@link #reset reset}\\n     *          method, nor of this method with a value of {@code false} for\\n     *          the {@code endOfInput} parameter, nor of this method with a\\n     *          value of {@code true} for the {@code endOfInput} parameter\\n     *          but a return value indicating an incomplete encoding operation\\n     *\\n     * @throws  CoderMalfunctionError\\n     *          If an invocation of the encodeLoop method threw\\n     *          an unexpected exception\\n     *\\n     * @throws  NullPointerException if input or output buffer is null\\n     \u0027}"}, {"color": "#97c2fc", "id": "OVERFLOW", "label": "OVERFLOW", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.charset.CoderResult", "label": "java.nio.charset.CoderResult", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public boolean isUnderflow()", "label": "public boolean isUnderflow()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this object describes an underflow condition.\\n     *\\n     * @return  {@code true} if, and only if, this object denotes underflow\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isOverflow()", "label": "public boolean isOverflow()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this object describes an overflow condition.\\n     *\\n     * @return  {@code true} if, and only if, this object denotes overflow\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isError()", "label": "public boolean isError()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this object describes an error condition.\\n     *\\n     * @return  {@code true} if, and only if, this object denotes either a\\n     *          malformed-input error or an unmappable-character error\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isMalformed()", "label": "public boolean isMalformed()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this object describes a malformed-input error.\\n     *\\n     * @return  {@code true} if, and only if, this object denotes a\\n     *          malformed-input error\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isUnmappable()", "label": "public boolean isUnmappable()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this object describes an unmappable-character\\n     * error.\\n     *\\n     * @return  {@code true} if, and only if, this object denotes an\\n     *          unmappable-character error\\n     \u0027}"}, {"color": "#97c2fc", "id": "isError()", "label": "isError()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static CoderResult malformedForLength(int length)", "label": "public static CoderResult malformedForLength(int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Static factory method that returns the unique object describing a\\n     * malformed-input error of the given length.\\n     *\\n     * @param   length\\n     *          The given length\\n     *\\n     * @return  The requested coder-result object\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static CoderResult unmappableForLength(int length)", "label": "public static CoderResult unmappableForLength(int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Static factory method that returns the unique result object describing\\n     * an unmappable-character error of the given length.\\n     *\\n     * @param   length\\n     *          The given length\\n     *\\n     * @return  The requested coder-result object\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void throwException() throws CharacterCodingException", "label": "public void throwException() throws CharacterCodingException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Throws an exception appropriate to the result described by this object.\\n     *\\n     * @throws  BufferUnderflowException\\n     *          If this object is {@link #UNDERFLOW}\\n     *\\n     * @throws  BufferOverflowException\\n     *          If this object is {@link #OVERFLOW}\\n     *\\n     * @throws  MalformedInputException\\n     *          If this object represents a malformed-input error; the\\n     *          exception\u0027s length value will be that of this object\\n     *\\n     * @throws  UnmappableCharacterException\\n     *          If this object represents an unmappable-character error; the\\n     *          exceptions length value will be that of this object\\n     \"}"}, {"color": "#97c2fc", "id": "UNDERFLOW", "label": "UNDERFLOW", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "reset", "label": "reset", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "REPORT", "label": "REPORT", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.charset.CodingErrorAction", "label": "java.nio.charset.CodingErrorAction", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "encodeLoop", "label": "encodeLoop", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "remaining", "label": "remaining", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.Buffer", "label": "java.nio.Buffer", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": " static IllegalArgumentException createSameBufferException()", "label": " static IllegalArgumentException createSameBufferException()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@code IllegalArgumentException} indicating that the source\\n     * and target are the same {@code Buffer}.  Intended for use in\\n     * {@code put(src)} when the parameter is the {@code Buffer} on which the\\n     * method is being invoked.\\n     *\\n     * @return  IllegalArgumentException\\n     *          With a message indicating equal source and target buffers\\n     \u0027}"}, {"color": "#97c2fc", "id": " static IllegalArgumentException createCapacityException(int capacity)", "label": " static IllegalArgumentException createCapacityException(int capacity)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Verify that the capacity is nonnegative.\\n     *\\n     * @param  capacity\\n     *         The new buffer\u0027s capacity, in $type$s\\n     *\\n     * @throws IllegalArgumentException\\n     *         If the {@code capacity} is a negative integer\\n     \"}"}, {"color": "#97c2fc", "id": "public final int capacity()", "label": "public final int capacity()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns this buffer\u0027s capacity.\\n     *\\n     * @return  The capacity of this buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public final int position()", "label": "public final int position()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns this buffer\u0027s position.\\n     *\\n     * @return  The position of this buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public Buffer position(int newPosition)", "label": "public Buffer position(int newPosition)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-changed: Un-final the method until confirmation of causing no app compat.\u0027}"}, {"color": "#97c2fc", "id": "private IllegalArgumentException createPositionException(int newPosition)", "label": "private IllegalArgumentException createPositionException(int newPosition)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Verify that {@code 0 \u003c newPosition \u003c= limit}\\n     *\\n     * @param newPosition\\n     *        The new position value\\n     *\\n     * @throws IllegalArgumentException\\n     *         If the specified position is out of bounds.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final int limit()", "label": "public final int limit()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns this buffer\u0027s limit.\\n     *\\n     * @return  The limit of this buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public Buffer limit(int newLimit)", "label": "public Buffer limit(int newLimit)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-changed: Un-final the method until confirmation of causing no app compat.\u0027}"}, {"color": "#97c2fc", "id": "private IllegalArgumentException createLimitException(int newLimit)", "label": "private IllegalArgumentException createLimitException(int newLimit)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Verify that {@code 0 \u003c newLimit \u003c= capacity}\\n     *\\n     * @param newLimit\\n     *        The new limit value\\n     *\\n     * @throws IllegalArgumentException\\n     *         If the specified limit is out of bounds.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Buffer mark()", "label": "public Buffer mark()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-changed: Un-final the method until confirmation of causing no app compat.\u0027}"}, {"color": "#97c2fc", "id": "public Buffer reset()", "label": "public Buffer reset()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-changed: Un-final the method until confirmation of causing no app compat.\u0027}"}, {"color": "#97c2fc", "id": "public Buffer clear()", "label": "public Buffer clear()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-changed: Un-final the method until confirmation of causing no app compat.\u0027}"}, {"color": "#97c2fc", "id": "public Buffer flip()", "label": "public Buffer flip()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-changed: Un-final the method until confirmation of causing no app compat.\u0027}"}, {"color": "#97c2fc", "id": "compact", "label": "compact", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.ByteBuffer", "label": "java.nio.ByteBuffer", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public static ByteBuffer allocateDirect(int capacity)", "label": "public static ByteBuffer allocateDirect(int capacity)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Allocates a new direct byte buffer.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s position will be zero, its limit will be its\\n     * capacity, its mark will be undefined, each of its elements will be\\n     * initialized to zero, and its byte order will be\\n     * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.  Whether or not it has a\\n     * {@link #hasArray backing array} is unspecified.\\n     *\\n     * @param  capacity\\n     *         The new buffer\u0027s capacity, in bytes\\n     *\\n     * @return  The new byte buffer\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the {@code capacity} is a negative integer\\n     \"}"}, {"color": "#97c2fc", "id": "BIG_ENDIAN", "label": "BIG_ENDIAN", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.ByteOrder", "label": "java.nio.ByteOrder", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public static ByteOrder nativeOrder()", "label": "public static ByteOrder nativeOrder()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Retrieves the native byte order of the underlying platform.\\n     *\\n     * \u003cp\u003e This method is defined so that performance-sensitive Java code can\\n     * allocate direct buffers with the same byte order as the hardware.\\n     * Native code libraries are often more efficient when such buffers are\\n     * used.  \u003c/p\u003e\\n     *\\n     * @return  The native byte order of the hardware upon which this Java\\n     *          virtual machine is running\\n     \u0027}"}, {"color": "#97c2fc", "id": "LITTLE_ENDIAN", "label": "LITTLE_ENDIAN", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "hasArray", "label": "hasArray", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static ByteBuffer allocate(int capacity)", "label": "public static ByteBuffer allocate(int capacity)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Allocates a new byte buffer.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s position will be zero, its limit will be its\\n     * capacity, its mark will be undefined, each of its elements will be\\n     * initialized to zero, and its byte order will be\\n\\n     * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.\\n\\n\\n\\n\\n     * It will have a {@link #array backing array}, and its\\n     * {@link #arrayOffset array offset} will be zero.\\n     *\\n     * @param  capacity\\n     *         The new buffer\u0027s capacity, in bytes\\n     *\\n     * @return  The new byte buffer\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the {@code capacity} is a negative integer\\n     \"}"}, {"color": "#97c2fc", "id": "array", "label": "array", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "arrayOffset", "label": "arrayOffset", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static ByteBuffer wrap(byte[] array, int offset, int length)", "label": "public static ByteBuffer wrap(byte[] array, int offset, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Wraps a byte array into a buffer.\\n     *\\n     * \u003cp\u003e The new buffer will be backed by the given byte array;\\n     * that is, modifications to the buffer will cause the array to be modified\\n     * and vice versa.  The new buffer\u0027s capacity will be\\n     * {@code array.length}, its position will be {@code offset}, its limit\\n     * will be {@code offset + length}, its mark will be undefined, and its\\n     * byte order will be\\n\\n     * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.\\n\\n\\n\\n\\n     * Its {@link #array backing array} will be the given array, and\\n     * its {@link #arrayOffset array offset} will be zero.  \u003c/p\u003e\\n     *\\n     * @param  array\\n     *         The array that will back the new buffer\\n     *\\n     * @param  offset\\n     *         The offset of the subarray to be used; must be non-negative and\\n     *         no larger than {@code array.length}.  The new buffer\u0027s position\\n     *         will be set to this value.\\n     *\\n     * @param  length\\n     *         The length of the subarray to be used;\\n     *         must be non-negative and no larger than\\n     *         {@code array.length - offset}.\\n     *         The new buffer\u0027s limit will be set to {@code offset + length}.\\n     *\\n     * @return  The new byte buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If the preconditions on the {@code offset} and {@code length}\\n     *          parameters do not hold\\n     \"}"}, {"color": "#97c2fc", "id": "public static ByteBuffer wrap(byte[] array)", "label": "public static ByteBuffer wrap(byte[] array)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Wraps a byte array into a buffer.\\n     *\\n     * \u003cp\u003e The new buffer will be backed by the given byte array;\\n     * that is, modifications to the buffer will cause the array to be modified\\n     * and vice versa.  The new buffer\u0027s capacity and limit will be\\n     * {@code array.length}, its position will be zero, its mark will be\\n     * undefined, and its byte order will be\\n\\n     * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.\\n\\n\\n\\n\\n     * Its {@link #array backing array} will be the given array, and its\\n     * {@link #arrayOffset array offset} will be zero.  \u003c/p\u003e\\n     *\\n     * @param  array\\n     *         The array that will back this buffer\\n     *\\n     * @return  The new byte buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer slice()", "label": "public abstract ByteBuffer slice()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a new byte buffer whose content is a shared subsequence of\\n     * this buffer\u0027s content.\\n     *\\n     * \u003cp\u003e The content of the new buffer will start at this buffer\u0027s current\\n     * position.  Changes to this buffer\u0027s content will be visible in the new\\n     * buffer, and vice versa; the two buffers\u0027 position, limit, and mark\\n     * values will be independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s position will be zero, its capacity and its limit\\n     * will be the number of bytes remaining in this buffer, its mark will be\\n     * undefined, and its byte order will be\\n\\n     * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.\\n\\n\\n\\n     * The new buffer will be direct if, and only if, this buffer is direct, and\\n     * it will be read-only if, and only if, this buffer is read-only.  \u003c/p\u003e\\n     *\\n     * @return  The new byte buffer\\n\\n     *\\n     * @see #alignedSlice(int)\\n\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer slice(int index, int length)", "label": "public abstract ByteBuffer slice(int index, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a new byte buffer whose content is a shared subsequence of\\n     * this buffer\u0027s content.\\n     *\\n     * \u003cp\u003e The content of the new buffer will start at position {@code index}\\n     * in this buffer, and will contain {@code length} elements. Changes to\\n     * this buffer\u0027s content will be visible in the new buffer, and vice versa;\\n     * the two buffers\u0027 position, limit, and mark values will be independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s position will be zero, its capacity and its limit\\n     * will be {@code length}, its mark will be undefined, and its byte order\\n     * will be\\n\\n     * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.\\n\\n\\n\\n     * The new buffer will be direct if, and only if, this buffer is direct,\\n     * and it will be read-only if, and only if, this buffer is read-only. \u003c/p\u003e\\n     *\\n     * @param   index\\n     *          The position in this buffer at which the content of the new\\n     *          buffer will start; must be non-negative and no larger than\\n     *          {@link #limit() limit()}\\n     *\\n     * @param   length\\n     *          The number of elements the new buffer will contain; must be\\n     *          non-negative and no larger than {@code limit() - index}\\n     *\\n     * @return  The new buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative or greater than {@code limit()},\\n     *          {@code length} is negative, or {@code length \u003e limit() - index}\\n     *\\n     * @since 13\\n     \"}"}, {"color": "#97c2fc", "id": "limit()", "label": "limit()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer duplicate()", "label": "public abstract ByteBuffer duplicate()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a new byte buffer that shares this buffer\u0027s content.\\n     *\\n     * \u003cp\u003e The content of the new buffer will be that of this buffer.  Changes\\n     * to this buffer\u0027s content will be visible in the new buffer, and vice\\n     * versa; the two buffers\u0027 position, limit, and mark values will be\\n     * independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s capacity, limit, position,\\n\\n     * and mark values will be identical to those of this buffer, and its byte\\n     * order will be {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.\\n\\n\\n\\n     * The new buffer will be direct if, and only if, this buffer is direct, and\\n     * it will be read-only if, and only if, this buffer is read-only.  \u003c/p\u003e\\n     *\\n     * @return  The new byte buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer asReadOnlyBuffer()", "label": "public abstract ByteBuffer asReadOnlyBuffer()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a new, read-only byte buffer that shares this buffer\u0027s\\n     * content.\\n     *\\n     * \u003cp\u003e The content of the new buffer will be that of this buffer.  Changes\\n     * to this buffer\u0027s content will be visible in the new buffer; the new\\n     * buffer itself, however, will be read-only and will not allow the shared\\n     * content to be modified.  The two buffers\u0027 position, limit, and mark\\n     * values will be independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s capacity, limit, position,\\n\\n     * and mark values will be identical to those of this buffer, and its byte\\n     * order will be {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.\\n\\n\\n\\n     *\\n     * \u003cp\u003e If this buffer is itself read-only then this method behaves in\\n     * exactly the same way as the {@link #duplicate duplicate} method.  \u003c/p\u003e\\n     *\\n     * @return  The new, read-only byte buffer\\n     \"}"}, {"color": "#97c2fc", "id": "duplicate", "label": "duplicate", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract byte get()", "label": "public abstract byte get()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Relative \u003ci\u003eget\u003c/i\u003e method.  Reads the byte at this buffer\u0027s\\n     * current position, and then increments the position.\\n     *\\n     * @return  The byte at the buffer\u0027s current position\\n     *\\n     * @throws  BufferUnderflowException\\n     *          If the buffer\u0027s current position is not smaller than its limit\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer put(byte b)", "label": "public abstract ByteBuffer put(byte b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Relative \u003ci\u003eput\u003c/i\u003e method\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes the given byte into this buffer at the current\\n     * position, and then increments the position. \u003c/p\u003e\\n     *\\n     * @param  b\\n     *         The byte to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  BufferOverflowException\\n     *          If this buffer\u0027s current position is not smaller than its limit\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract byte get(int index)", "label": "public abstract byte get(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eget\u003c/i\u003e method.  Reads the byte at the given\\n     * index.\\n     *\\n     * @param  index\\n     *         The index from which the byte will be read\\n     *\\n     * @return  The byte at the given index\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer put(int index, byte b)", "label": "public abstract ByteBuffer put(int index, byte b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eput\u003c/i\u003e method\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes the given byte into this buffer at the given\\n     * index. \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index at which the byte will be written\\n     *\\n     * @param  b\\n     *         The byte value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \"}"}, {"color": "#97c2fc", "id": "public ByteBuffer get(byte[] dst, int offset, int length)", "label": "public ByteBuffer get(byte[] dst, int offset, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Relative bulk \u003ci\u003eget\u003c/i\u003e method.\\n     *\\n     * \u003cp\u003e This method transfers bytes from this buffer into the given\\n     * destination array.  If there are fewer bytes remaining in the\\n     * buffer than are required to satisfy the request, that is, if\\n     * {@code length}\u0026nbsp;{@code \u003e}\u0026nbsp;{@code remaining()}, then no\\n     * bytes are transferred and a {@link BufferUnderflowException} is\\n     * thrown.\\n     *\\n     * \u003cp\u003e Otherwise, this method copies {@code length} bytes from this\\n     * buffer into the given array, starting at the current position of this\\n     * buffer and at the given offset in the array.  The position of this\\n     * buffer is then incremented by {@code length}.\\n     *\\n     * \u003cp\u003e In other words, an invocation of this method of the form\\n     * \u003ccode\u003esrc.get(dst,\u0026nbsp;off,\u0026nbsp;len)\u003c/code\u003e has exactly the same effect as\\n     * the loop\\n     *\\n     * \u003cpre\u003e{@code\\n     *     for (int i = off; i \u003c off + len; i++)\\n     *         dst[i] = src.get();\\n     * }\u003c/pre\u003e\\n     *\\n     * except that it first checks that there are sufficient bytes in\\n     * this buffer and it is potentially much more efficient.\\n     *\\n     * @param  dst\\n     *         The array into which bytes are to be written\\n     *\\n     * @param  offset\\n     *         The offset within the array of the first byte to be\\n     *         written; must be non-negative and no larger than\\n     *         {@code dst.length}\\n     *\\n     * @param  length\\n     *         The maximum number of bytes to be written to the given\\n     *         array; must be non-negative and no larger than\\n     *         {@code dst.length - offset}\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  BufferUnderflowException\\n     *          If there are fewer than {@code length} bytes\\n     *          remaining in this buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If the preconditions on the {@code offset} and {@code length}\\n     *          parameters do not hold\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.nio.BufferUnderflowException", "label": "java.nio.BufferUnderflowException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public ByteBuffer get(byte[] dst)", "label": "public ByteBuffer get(byte[] dst)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Relative bulk \u003ci\u003eget\u003c/i\u003e method.\\n     *\\n     * \u003cp\u003e This method transfers bytes from this buffer into the given\\n     * destination array.  An invocation of this method of the form\\n     * {@code src.get(a)} behaves in exactly the same way as the invocation\\n     *\\n     * \u003cpre\u003e\\n     *     src.get(a, 0, a.length) \u003c/pre\u003e\\n     *\\n     * @param   dst\\n     *          The destination array\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  BufferUnderflowException\\n     *          If there are fewer than {@code length} bytes\\n     *          remaining in this buffer\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ByteBuffer get(int index, byte[] dst, int offset, int length)", "label": "public ByteBuffer get(int index, byte[] dst, int offset, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Absolute bulk \u003ci\u003eget\u003c/i\u003e method.\\n     *\\n     * \u003cp\u003e This method transfers {@code length} bytes from this\\n     * buffer into the given array, starting at the given index in this\\n     * buffer and at the given offset in the array.  The position of this\\n     * buffer is unchanged.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form\\n     * \u003ccode\u003esrc.get(index,\u0026nbsp;dst,\u0026nbsp;offset,\u0026nbsp;length)\u003c/code\u003e\\n     * has exactly the same effect as the following loop except that it first\\n     * checks the consistency of the supplied parameters and it is potentially\\n     * much more efficient:\\n     *\\n     * \u003cpre\u003e{@code\\n     *     for (int i = offset, j = index; i \u003c offset + length; i++, j++)\\n     *         dst[i] = src.get(j);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param  index\\n     *         The index in this buffer from which the first byte will be\\n     *         read; must be non-negative and less than {@code limit()}\\n     *\\n     * @param  dst\\n     *         The destination array\\n     *\\n     * @param  offset\\n     *         The offset within the array of the first byte to be\\n     *         written; must be non-negative and less than\\n     *         {@code dst.length}\\n     *\\n     * @param  length\\n     *         The number of bytes to be written to the given array;\\n     *         must be non-negative and no larger than the smaller of\\n     *         {@code limit() - index} and {@code dst.length - offset}\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If the preconditions on the {@code index}, {@code offset}, and\\n     *          {@code length} parameters do not hold\\n     *\\n     * @since 13\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ByteBuffer get(int index, byte[] dst)", "label": "public ByteBuffer get(int index, byte[] dst)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Absolute bulk \u003ci\u003eget\u003c/i\u003e method.\\n     *\\n     * \u003cp\u003e This method transfers bytes from this buffer into the given\\n     * destination array.  The position of this buffer is unchanged.  An\\n     * invocation of this method of the form\\n     * \u003ccode\u003esrc.get(index,\u0026nbsp;dst)\u003c/code\u003e behaves in exactly the same\\n     * way as the invocation:\\n     *\\n     * \u003cpre\u003e\\n     *     src.get(index, dst, 0, dst.length) \u003c/pre\u003e\\n     *\\n     * @param  index\\n     *         The index in this buffer from which the first byte will be\\n     *         read; must be non-negative and less than {@code limit()}\\n     *\\n     * @param  dst\\n     *         The destination array\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative, not smaller than {@code limit()},\\n     *          or {@code limit() - index \u003c dst.length}\\n     *\\n     * @since 13\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ByteBuffer put(ByteBuffer src)", "label": "public ByteBuffer put(ByteBuffer src)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Relative bulk \u003ci\u003eput\u003c/i\u003e method\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e This method transfers the bytes remaining in the given source\\n     * buffer into this buffer.  If there are more bytes remaining in the\\n     * source buffer than in this buffer, that is, if\\n     * {@code src.remaining()}\u0026nbsp;{@code \u003e}\u0026nbsp;{@code remaining()},\\n     * then no bytes are transferred and a {@link\\n     * BufferOverflowException} is thrown.\\n     *\\n     * \u003cp\u003e Otherwise, this method copies\\n     * \u003ci\u003en\u003c/i\u003e\u0026nbsp;=\u0026nbsp;{@code src.remaining()} bytes from the given\\n     * buffer into this buffer, starting at each buffer\u0027s current position.\\n     * The positions of both buffers are then incremented by \u003ci\u003en\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e In other words, an invocation of this method of the form\\n     * {@code dst.put(src)} has exactly the same effect as the loop\\n     *\\n     * \u003cpre\u003e\\n     *     while (src.hasRemaining())\\n     *         dst.put(src.get()); \u003c/pre\u003e\\n     *\\n     * except that it first checks that there is sufficient space in this\\n     * buffer and it is potentially much more efficient.  If this buffer and\\n     * the source buffer share the same backing array or memory, then the\\n     * result will be as if the source elements were first copied to an\\n     * intermediate location before being written into this buffer.\\n     *\\n     * @param  src\\n     *         The source buffer from which bytes are to be read;\\n     *         must not be this buffer\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  BufferOverflowException\\n     *          If there is insufficient space in this buffer\\n     *          for the remaining bytes in the source buffer\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the source buffer is this buffer\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \"}"}, {"color": "#97c2fc", "id": "java.nio.BufferOverflowException", "label": "java.nio.BufferOverflowException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public ByteBuffer put(int index, ByteBuffer src, int offset, int length)", "label": "public ByteBuffer put(int index, ByteBuffer src, int offset, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Absolute bulk \u003ci\u003eput\u003c/i\u003e method\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e This method transfers {@code length} bytes into this buffer from\\n     * the given source buffer, starting at the given {@code offset} in the\\n     * source buffer and the given {@code index} in this buffer. The positions\\n     * of both buffers are unchanged.\\n     *\\n     * \u003cp\u003e In other words, an invocation of this method of the form\\n     * \u003ccode\u003edst.put(index,\u0026nbsp;src,\u0026nbsp;offset,\u0026nbsp;length)\u003c/code\u003e\\n     * has exactly the same effect as the loop\\n     *\\n     * \u003cpre\u003e{@code\\n     * for (int i = offset, j = index; i \u003c offset + length; i++, j++)\\n     *     dst.put(j, src.get(i));\\n     * }\u003c/pre\u003e\\n     *\\n     * except that it first checks the consistency of the supplied parameters\\n     * and it is potentially much more efficient.  If this buffer and\\n     * the source buffer share the same backing array or memory, then the\\n     * result will be as if the source elements were first copied to an\\n     * intermediate location before being written into this buffer.\\n     *\\n     * @param index\\n     *        The index in this buffer at which the first byte will be\\n     *        written; must be non-negative and less than {@code limit()}\\n     *\\n     * @param src\\n     *        The buffer from which bytes are to be read\\n     *\\n     * @param offset\\n     *        The index within the source buffer of the first byte to be\\n     *        read; must be non-negative and less than {@code src.limit()}\\n     *\\n     * @param length\\n     *        The number of bytes to be read from the given buffer;\\n     *        must be non-negative and no larger than the smaller of\\n     *        {@code limit() - index} and {@code src.limit() - offset}\\n     *\\n     * @return This buffer\\n     *\\n     * @throws IndexOutOfBoundsException\\n     *         If the preconditions on the {@code index}, {@code offset}, and\\n     *         {@code length} parameters do not hold\\n     *\\n     * @throws ReadOnlyBufferException\\n     *         If this buffer is read-only\\n     *\\n     * @since 16\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ByteBuffer put(byte[] src, int offset, int length)", "label": "public ByteBuffer put(byte[] src, int offset, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Relative bulk \u003ci\u003eput\u003c/i\u003e method\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e This method transfers bytes into this buffer from the given\\n     * source array.  If there are more bytes to be copied from the array\\n     * than remain in this buffer, that is, if\\n     * {@code length}\u0026nbsp;{@code \u003e}\u0026nbsp;{@code remaining()}, then no\\n     * bytes are transferred and a {@link BufferOverflowException} is\\n     * thrown.\\n     *\\n     * \u003cp\u003e Otherwise, this method copies {@code length} bytes from the\\n     * given array into this buffer, starting at the given offset in the array\\n     * and at the current position of this buffer.  The position of this buffer\\n     * is then incremented by {@code length}.\\n     *\\n     * \u003cp\u003e In other words, an invocation of this method of the form\\n     * \u003ccode\u003edst.put(src,\u0026nbsp;off,\u0026nbsp;len)\u003c/code\u003e has exactly the same effect as\\n     * the loop\\n     *\\n     * \u003cpre\u003e{@code\\n     *     for (int i = off; i \u003c off + len; i++)\\n     *         dst.put(src[i]);\\n     * }\u003c/pre\u003e\\n     *\\n     * except that it first checks that there is sufficient space in this\\n     * buffer and it is potentially much more efficient.\\n     *\\n     * @param  src\\n     *         The array from which bytes are to be read\\n     *\\n     * @param  offset\\n     *         The offset within the array of the first byte to be read;\\n     *         must be non-negative and no larger than {@code src.length}\\n     *\\n     * @param  length\\n     *         The number of bytes to be read from the given array;\\n     *         must be non-negative and no larger than\\n     *         {@code src.length - offset}\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  BufferOverflowException\\n     *          If there is insufficient space in this buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If the preconditions on the {@code offset} and {@code length}\\n     *          parameters do not hold\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final ByteBuffer put(byte[] src)", "label": "public final ByteBuffer put(byte[] src)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Relative bulk \u003ci\u003eput\u003c/i\u003e method\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e This method transfers the entire content of the given source\\n     * byte array into this buffer.  An invocation of this method of the\\n     * form {@code dst.put(a)} behaves in exactly the same way as the\\n     * invocation\\n     *\\n     * \u003cpre\u003e\\n     *     dst.put(a, 0, a.length) \u003c/pre\u003e\\n     *\\n     * @param   src\\n     *          The source array\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  BufferOverflowException\\n     *          If there is insufficient space in this buffer\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ByteBuffer put(int index, byte[] src, int offset, int length)", "label": "public ByteBuffer put(int index, byte[] src, int offset, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Absolute bulk \u003ci\u003eput\u003c/i\u003e method\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e This method transfers {@code length} bytes from the given\\n     * array, starting at the given offset in the array and at the given index\\n     * in this buffer.  The position of this buffer is unchanged.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form\\n     * \u003ccode\u003edst.put(index,\u0026nbsp;src,\u0026nbsp;offset,\u0026nbsp;length)\u003c/code\u003e\\n     * has exactly the same effect as the following loop except that it first\\n     * checks the consistency of the supplied parameters and it is potentially\\n     * much more efficient:\\n     *\\n     * \u003cpre\u003e{@code\\n     *     for (int i = offset, j = index; i \u003c offset + length; i++, j++)\\n     *         dst.put(j, src[i]);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param  index\\n     *         The index in this buffer at which the first byte will be\\n     *         written; must be non-negative and less than {@code limit()}\\n     *\\n     * @param  src\\n     *         The array from which bytes are to be read\\n     *\\n     * @param  offset\\n     *         The offset within the array of the first byte to be read;\\n     *         must be non-negative and less than {@code src.length}\\n     *\\n     * @param  length\\n     *         The number of bytes to be read from the given array;\\n     *         must be non-negative and no larger than the smaller of\\n     *         {@code limit() - index} and {@code src.length - offset}\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If the preconditions on the {@code index}, {@code offset}, and\\n     *          {@code length} parameters do not hold\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     *\\n     * @since 13\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ByteBuffer put(int index, byte[] src)", "label": "public ByteBuffer put(int index, byte[] src)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Absolute bulk \u003ci\u003eput\u003c/i\u003e method\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e This method copies bytes into this buffer from the given source\\n     * array.  The position of this buffer is unchanged.  An invocation of this\\n     * method of the form \u003ccode\u003edst.put(index,\u0026nbsp;src)\u003c/code\u003e\\n     * behaves in exactly the same way as the invocation:\\n     *\\n     * \u003cpre\u003e\\n     *     dst.put(index, src, 0, src.length); \u003c/pre\u003e\\n     *\\n     * @param  index\\n     *         The index in this buffer at which the first byte will be\\n     *         written; must be non-negative and less than {@code limit()}\\n     *\\n     * @param  src\\n     *         The array from which bytes are to be read\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative, not smaller than {@code limit()},\\n     *          or {@code limit() - index \u003c src.length}\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     *\\n     * @since 13\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final boolean hasArray()", "label": "public final boolean hasArray()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this buffer is backed by an accessible byte\\n     * array.\\n     *\\n     * \u003cp\u003e If this method returns {@code true} then the {@link #array() array}\\n     * and {@link #arrayOffset() arrayOffset} methods may safely be invoked.\\n     * \u003c/p\u003e\\n     *\\n     * @return  {@code true} if, and only if, this buffer\\n     *          is backed by an array and is not read-only\\n     \u0027}"}, {"color": "#97c2fc", "id": "array()", "label": "array()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "arrayOffset()", "label": "arrayOffset()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public final byte[] array()", "label": "public final byte[] array()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the byte array that backs this\\n     * buffer\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Modifications to this buffer\u0027s content will cause the returned\\n     * array\u0027s content to be modified, and vice versa.\\n     *\\n     * \u003cp\u003e Invoke the {@link #hasArray hasArray} method before invoking this\\n     * method in order to ensure that this buffer has an accessible backing\\n     * array.  \u003c/p\u003e\\n     *\\n     * @return  The array that backs this buffer\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is backed by an array but is read-only\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          If this buffer is not backed by an accessible array\\n     \"}"}, {"color": "#97c2fc", "id": "public final int arrayOffset()", "label": "public final int arrayOffset()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the offset within this buffer\u0027s backing array of the first\\n     * element of the buffer\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e If this buffer is backed by an array then buffer position \u003ci\u003ep\u003c/i\u003e\\n     * corresponds to array index \u003ci\u003ep\u003c/i\u003e\u0026nbsp;+\u0026nbsp;{@code arrayOffset()}.\\n     *\\n     * \u003cp\u003e Invoke the {@link #hasArray hasArray} method before invoking this\\n     * method in order to ensure that this buffer has an accessible backing\\n     * array.  \u003c/p\u003e\\n     *\\n     * @return  The offset within this buffer\u0027s array\\n     *          of the first element of the buffer\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is backed by an array but is read-only\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          If this buffer is not backed by an accessible array\\n     \"}"}, {"color": "#97c2fc", "id": "public Buffer rewind()", "label": "public Buffer rewind()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Rewinds this buffer.  The position is set to zero and the mark is\\n     * discarded.\\n     *\\n     * \u003cp\u003e Invoke this method before a sequence of channel-write or \u003ci\u003eget\u003c/i\u003e\\n     * operations, assuming that the limit has already been set\\n     * appropriately.  For example:\\n     *\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * out.write(buf);    // Write remaining data\\n     * buf.rewind();      // Rewind buffer\\n     * buf.get(array);    // Copy data into array\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @return  This buffer\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer compact()", "label": "public abstract ByteBuffer compact()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Compacts this buffer\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e The bytes between the buffer\u0027s current position and its limit,\\n     * if any, are copied to the beginning of the buffer.  That is, the\\n     * byte at index \u003ci\u003ep\u003c/i\u003e\u0026nbsp;=\u0026nbsp;{@code position()} is copied\\n     * to index zero, the byte at index \u003ci\u003ep\u003c/i\u003e\u0026nbsp;+\u0026nbsp;1 is copied\\n     * to index one, and so forth until the byte at index\\n     * {@code limit()}\u0026nbsp;-\u0026nbsp;1 is copied to index\\n     * \u003ci\u003en\u003c/i\u003e\u0026nbsp;=\u0026nbsp;{@code limit()}\u0026nbsp;-\u0026nbsp;{@code 1}\u0026nbsp;-\u0026nbsp;\u003ci\u003ep\u003c/i\u003e.\\n     * The buffer\u0027s position is then set to \u003ci\u003en+1\u003c/i\u003e and its limit is set to\\n     * its capacity.  The mark, if defined, is discarded.\\n     *\\n     * \u003cp\u003e The buffer\u0027s position is set to the number of bytes copied,\\n     * rather than to zero, so that an invocation of this method can be\\n     * followed immediately by an invocation of another relative \u003ci\u003eput\u003c/i\u003e\\n     * method. \u003c/p\u003e\\n     *\\n\\n     *\\n     * \u003cp\u003e Invoke this method after writing data from a buffer in case the\\n     * write was incomplete.  The following loop, for example, copies bytes\\n     * from one channel to another via the buffer {@code buf}:\\n     *\\n     * \u003cblockquote\u003e\u003cpre\u003e{@code\\n     *   buf.clear();          // Prepare buffer for use\\n     *   while (in.read(buf) \u003e= 0 || buf.position != 0) {\\n     *       buf.flip();\\n     *       out.write(buf);\\n     *       buf.compact();    // In case of partial write\\n     *   }\\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract boolean isDirect()", "label": "public abstract boolean isDirect()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this buffer is\\n     * \u003ca href=\"ByteBuffer.html#direct\"\u003e\u003ci\u003edirect\u003c/i\u003e\u003c/a\u003e.\\n     *\\n     * @return  {@code true} if, and only if, this buffer is direct\\n     *\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int hashCode()", "label": "public int hashCode()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a hash code for this {@code Character}; equal to the result\\n     * of invoking {@code charValue()}.\\n     *\\n     * @return a hash code value for this {@code Character}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean equals(Object ob)", "label": "public boolean equals(Object ob)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this buffer is equal to another object.\\n     *\\n     * \u003cp\u003e Two byte buffers are equal if, and only if,\\n     *\\n     * \u003col\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e They have the same element type,  \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e They have the same number of remaining elements, and\\n     *   \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e The two sequences of remaining elements, considered\\n     *   independently of their starting positions, are pointwise equal.\\n\\n\\n\\n\\n\\n\\n\\n     *   \u003c/p\u003e\u003c/li\u003e\\n     *\\n     * \u003c/ol\u003e\\n     *\\n     * \u003cp\u003e A byte buffer is not equal to any other type of object.  \u003c/p\u003e\\n     *\\n     * @param  ob  The object to which this buffer is to be compared\\n     *\\n     * @return  {@code true} if, and only if, this buffer is equal to the\\n     *           given object\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int compareTo(ByteBuffer that)", "label": "public int compareTo(ByteBuffer that)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares this buffer to another.\\n     *\\n     * \u003cp\u003e Two byte buffers are compared by comparing their sequences of\\n     * remaining elements lexicographically, without regard to the starting\\n     * position of each sequence within its corresponding buffer.\\n\\n\\n\\n\\n\\n\\n\\n\\n     * Pairs of {@code byte} elements are compared as if by invoking\\n     * {@link Byte#compare(byte,byte)}.\\n\\n     *\\n     * \u003cp\u003e A byte buffer is not comparable to any other type of object.\\n     *\\n     * @return  A negative integer, zero, or a positive integer as this buffer\\n     *          is less than, equal to, or greater than the given buffer\\n     \u0027}"}, {"color": "#97c2fc", "id": "compare(byte", "label": "compare(byte", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public int mismatch(ByteBuffer that)", "label": "public int mismatch(ByteBuffer that)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Finds and returns the relative index of the first mismatch between this\\n     * buffer and a given buffer.  The index is relative to the\\n     * {@link #position() position} of each buffer and will be in the range of\\n     * 0 (inclusive) up to the smaller of the {@link #remaining() remaining}\\n     * elements in each buffer (exclusive).\\n     *\\n     * \u003cp\u003e If the two buffers share a common prefix then the returned index is\\n     * the length of the common prefix and it follows that there is a mismatch\\n     * between the two buffers at that index within the respective buffers.\\n     * If one buffer is a proper prefix of the other then the returned index is\\n     * the smaller of the remaining elements in each buffer, and it follows that\\n     * the index is only valid for the buffer with the larger number of\\n     * remaining elements.\\n     * Otherwise, there is no mismatch.\\n     *\\n     * @param  that\\n     *         The byte buffer to be tested for a mismatch with this buffer\\n     *\\n     * @return  The relative index of the first mismatch between this and the\\n     *          given buffer, otherwise -1 if no mismatch.\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "position()", "label": "position()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "remaining()", "label": "remaining()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public final ByteOrder order()", "label": "public final ByteOrder order()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Retrieves this buffer\u0027s byte order.\\n     *\\n     * \u003cp\u003e The byte order is used when reading or writing multibyte values, and\\n     * when creating buffers that are views of this byte buffer.  The order of\\n     * a newly-created byte buffer is always {@link ByteOrder#BIG_ENDIAN\\n     * BIG_ENDIAN}.  \u003c/p\u003e\\n     *\\n     * @return  This buffer\u0027s byte order\\n     \"}"}, {"color": "#97c2fc", "id": "public final ByteBuffer order(ByteOrder bo)", "label": "public final ByteBuffer order(ByteOrder bo)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Modifies this buffer\u0027s byte order.\\n     *\\n     * @param  bo\\n     *         The new byte order,\\n     *         either {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}\\n     *         or {@link ByteOrder#LITTLE_ENDIAN LITTLE_ENDIAN}\\n     *\\n     * @return  This buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public final int alignmentOffset(int index, int unitSize)", "label": "public final int alignmentOffset(int index, int unitSize)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the memory address, pointing to the byte at the given index,\\n     * modulo the given unit size.\\n     *\\n     * \u003cp\u003e The return value is non-negative in the range of {@code 0}\\n     * (inclusive) up to {@code unitSize} (exclusive), with zero indicating\\n     * that the address of the byte at the index is aligned for the unit size,\\n     * and a positive value that the address is misaligned for the unit size.\\n     * If the address of the byte at the index is misaligned, the return value\\n     * represents how much the index should be adjusted to locate a byte at an\\n     * aligned address.  Specifically, the index should either be decremented by\\n     * the return value if the latter is not greater than {@code index}, or be\\n     * incremented by the unit size minus the return value.  Therefore given\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * int value = alignmentOffset(index, unitSize)\u003c/pre\u003e\u003c/blockquote\u003e\\n     * then the identities\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * alignmentOffset(index - value, unitSize) == 0, value \u0026le; index\u003c/pre\u003e\u003c/blockquote\u003e\\n     * and\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * alignmentOffset(index + (unitSize - value), unitSize) == 0\u003c/pre\u003e\u003c/blockquote\u003e\\n     * must hold.\\n     *\\n     * @apiNote\\n     * This method may be utilized to determine if unit size bytes from an\\n     * index can be accessed atomically, if supported by the native platform.\\n     *\\n     * @implNote\\n     * This implementation throws {@code UnsupportedOperationException} for\\n     * non-direct buffers when the given unit size is greater than {@code 8}.\\n     *\\n     * @param  index\\n     *         The index to query for alignment offset, must be non-negative, no\\n     *         upper bounds check is performed\\n     *\\n     * @param  unitSize\\n     *         The unit size in bytes, must be a power of {@code 2}\\n     *\\n     * @return  The indexed byte\u0027s memory address modulo the unit size\\n     *\\n     * @throws IllegalArgumentException\\n     *         If the index is negative or the unit size is not a power of\\n     *         {@code 2}\\n     *\\n     * @throws UnsupportedOperationException\\n     *         If the native platform does not guarantee stable alignment offset\\n     *         values for the given unit size when managing the memory regions\\n     *         of buffers of the same kind as this buffer (direct or\\n     *         non-direct).  For example, if garbage collection would result\\n     *         in the moving of a memory region covered by a non-direct buffer\\n     *         from one location to another and both locations have different\\n     *         alignment characteristics.\\n     *\\n     * @see #alignedSlice(int)\\n     * @since 9\\n     \"}"}, {"color": "#97c2fc", "id": "public final ByteBuffer alignedSlice(int unitSize)", "label": "public final ByteBuffer alignedSlice(int unitSize)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a new byte buffer whose content is a shared and aligned\\n     * subsequence of this buffer\u0027s content.\\n     *\\n     * \u003cp\u003e The content of the new buffer will start at this buffer\u0027s current\\n     * position rounded up to the index of the nearest aligned byte for the\\n     * given unit size, and end at this buffer\u0027s limit rounded down to the index\\n     * of the nearest aligned byte for the given unit size.\\n     * If rounding results in out-of-bound values then the new buffer\u0027s capacity\\n     * and limit will be zero.  If rounding is within bounds the following\\n     * expressions will be true for a new buffer {@code nb} and unit size\\n     * {@code unitSize}:\\n     * \u003cpre\u003e{@code\\n     * nb.alignmentOffset(0, unitSize) == 0\\n     * nb.alignmentOffset(nb.limit(), unitSize) == 0\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003e Changes to this buffer\u0027s content will be visible in the new\\n     * buffer, and vice versa; the two buffers\u0027 position, limit, and mark\\n     * values will be independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s position will be zero, its capacity and its limit\\n     * will be the number of bytes remaining in this buffer or fewer subject to\\n     * alignment, its mark will be undefined, and its byte order will be\\n     * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.\\n     *\\n     * The new buffer will be direct if, and only if, this buffer is direct, and\\n     * it will be read-only if, and only if, this buffer is read-only.  \u003c/p\u003e\\n     *\\n     * @apiNote\\n     * This method may be utilized to create a new buffer where unit size bytes\\n     * from index, that is a multiple of the unit size, may be accessed\\n     * atomically, if supported by the native platform.\\n     *\\n     * @implNote\\n     * This implementation throws {@code UnsupportedOperationException} for\\n     * non-direct buffers when the given unit size is greater than {@code 8}.\\n     *\\n     * @param  unitSize\\n     *         The unit size in bytes, must be a power of {@code 2}\\n     *\\n     * @return  The new byte buffer\\n     *\\n     * @throws IllegalArgumentException\\n     *         If the unit size not a power of {@code 2}\\n     *\\n     * @throws UnsupportedOperationException\\n     *         If the native platform does not guarantee stable aligned slices\\n     *         for the given unit size when managing the memory regions\\n     *         of buffers of the same kind as this buffer (direct or\\n     *         non-direct).  For example, if garbage collection would result\\n     *         in the moving of a memory region covered by a non-direct buffer\\n     *         from one location to another and both locations have different\\n     *         alignment characteristics.\\n     *\\n     * @see #alignmentOffset(int, int)\\n     * @see #slice()\\n     * @since 9\\n     \"}"}, {"color": "#97c2fc", "id": " abstract byte _get(int i)", "label": " abstract byte _get(int i)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 package-private\u0027}"}, {"color": "#97c2fc", "id": " abstract void _put(int i, byte b)", "label": " abstract void _put(int i, byte b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 package-private\u0027}"}, {"color": "#97c2fc", "id": "public abstract char getChar()", "label": "public abstract char getChar()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Relative \u003ci\u003eget\u003c/i\u003e method for reading a char value.\\n     *\\n     * \u003cp\u003e Reads the next two bytes at this buffer\u0027s current position,\\n     * composing them into a char value according to the current byte order,\\n     * and then increments the position by two.  \u003c/p\u003e\\n     *\\n     * @return  The char value at the buffer\u0027s current position\\n     *\\n     * @throws  BufferUnderflowException\\n     *          If there are fewer than two bytes\\n     *          remaining in this buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer putChar(char value)", "label": "public abstract ByteBuffer putChar(char value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Relative \u003ci\u003eput\u003c/i\u003e method for writing a char\\n     * value\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes two bytes containing the given char value, in the\\n     * current byte order, into this buffer at the current position, and then\\n     * increments the position by two.  \u003c/p\u003e\\n     *\\n     * @param  value\\n     *         The char value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  BufferOverflowException\\n     *          If there are fewer than two bytes\\n     *          remaining in this buffer\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract char getChar(int index)", "label": "public abstract char getChar(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eget\u003c/i\u003e method for reading a char value.\\n     *\\n     * \u003cp\u003e Reads two bytes at the given index, composing them into a\\n     * char value according to the current byte order.  \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index from which the bytes will be read\\n     *\\n     * @return  The char value at the given index\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit,\\n     *          minus one\\n     \"}"}, {"color": "#97c2fc", "id": " abstract char getCharUnchecked(int index)", "label": " abstract char getCharUnchecked(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: {get,put}*Unchecked() accessors.\u0027}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer putChar(int index, char value)", "label": "public abstract ByteBuffer putChar(int index, char value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eput\u003c/i\u003e method for writing a char\\n     * value\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes two bytes containing the given char value, in the\\n     * current byte order, into this buffer at the given index.  \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index at which the bytes will be written\\n     *\\n     * @param  value\\n     *         The char value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit,\\n     *          minus one\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \"}"}, {"color": "#97c2fc", "id": " abstract void putCharUnchecked(int index, char value)", "label": " abstract void putCharUnchecked(int index, char value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: {get,put}*Unchecked() accessors.\u0027}"}, {"color": "#97c2fc", "id": "public abstract CharBuffer asCharBuffer()", "label": "public abstract CharBuffer asCharBuffer()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a view of this byte buffer as a char buffer.\\n     *\\n     * \u003cp\u003e The content of the new buffer will start at this buffer\u0027s current\\n     * position.  Changes to this buffer\u0027s content will be visible in the new\\n     * buffer, and vice versa; the two buffers\u0027 position, limit, and mark\\n     * values will be independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s position will be zero, its capacity and its limit\\n     * will be the number of bytes remaining in this buffer divided by\\n     * two, its mark will be undefined, and its byte order will be that\\n     * of the byte buffer at the moment the view is created.  The new buffer\\n     * will be direct if, and only if, this buffer is direct, and it will be\\n     * read-only if, and only if, this buffer is read-only.  \u003c/p\u003e\\n     *\\n     * @return  A new char buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract short getShort()", "label": "public abstract short getShort()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Relative \u003ci\u003eget\u003c/i\u003e method for reading a short value.\\n     *\\n     * \u003cp\u003e Reads the next two bytes at this buffer\u0027s current position,\\n     * composing them into a short value according to the current byte order,\\n     * and then increments the position by two.  \u003c/p\u003e\\n     *\\n     * @return  The short value at the buffer\u0027s current position\\n     *\\n     * @throws  BufferUnderflowException\\n     *          If there are fewer than two bytes\\n     *          remaining in this buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer putShort(short value)", "label": "public abstract ByteBuffer putShort(short value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Relative \u003ci\u003eput\u003c/i\u003e method for writing a short\\n     * value\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes two bytes containing the given short value, in the\\n     * current byte order, into this buffer at the current position, and then\\n     * increments the position by two.  \u003c/p\u003e\\n     *\\n     * @param  value\\n     *         The short value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  BufferOverflowException\\n     *          If there are fewer than two bytes\\n     *          remaining in this buffer\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract short getShort(int index)", "label": "public abstract short getShort(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eget\u003c/i\u003e method for reading a short value.\\n     *\\n     * \u003cp\u003e Reads two bytes at the given index, composing them into a\\n     * short value according to the current byte order.  \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index from which the bytes will be read\\n     *\\n     * @return  The short value at the given index\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit,\\n     *          minus one\\n     \"}"}, {"color": "#97c2fc", "id": " abstract short getShortUnchecked(int index)", "label": " abstract short getShortUnchecked(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: {get,put}*Unchecked() accessors.\u0027}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer putShort(int index, short value)", "label": "public abstract ByteBuffer putShort(int index, short value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eput\u003c/i\u003e method for writing a short\\n     * value\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes two bytes containing the given short value, in the\\n     * current byte order, into this buffer at the given index.  \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index at which the bytes will be written\\n     *\\n     * @param  value\\n     *         The short value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit,\\n     *          minus one\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \"}"}, {"color": "#97c2fc", "id": " abstract void putShortUnchecked(int index, short value)", "label": " abstract void putShortUnchecked(int index, short value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: {get,put}*Unchecked() accessors.\u0027}"}, {"color": "#97c2fc", "id": "public abstract ShortBuffer asShortBuffer()", "label": "public abstract ShortBuffer asShortBuffer()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a view of this byte buffer as a short buffer.\\n     *\\n     * \u003cp\u003e The content of the new buffer will start at this buffer\u0027s current\\n     * position.  Changes to this buffer\u0027s content will be visible in the new\\n     * buffer, and vice versa; the two buffers\u0027 position, limit, and mark\\n     * values will be independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s position will be zero, its capacity and its limit\\n     * will be the number of bytes remaining in this buffer divided by\\n     * two, its mark will be undefined, and its byte order will be that\\n     * of the byte buffer at the moment the view is created.  The new buffer\\n     * will be direct if, and only if, this buffer is direct, and it will be\\n     * read-only if, and only if, this buffer is read-only.  \u003c/p\u003e\\n     *\\n     * @return  A new short buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract int getInt()", "label": "public abstract int getInt()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Relative \u003ci\u003eget\u003c/i\u003e method for reading an int value.\\n     *\\n     * \u003cp\u003e Reads the next four bytes at this buffer\u0027s current position,\\n     * composing them into an int value according to the current byte order,\\n     * and then increments the position by four.  \u003c/p\u003e\\n     *\\n     * @return  The int value at the buffer\u0027s current position\\n     *\\n     * @throws  BufferUnderflowException\\n     *          If there are fewer than four bytes\\n     *          remaining in this buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer putInt(int value)", "label": "public abstract ByteBuffer putInt(int value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Relative \u003ci\u003eput\u003c/i\u003e method for writing an int\\n     * value\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes four bytes containing the given int value, in the\\n     * current byte order, into this buffer at the current position, and then\\n     * increments the position by four.  \u003c/p\u003e\\n     *\\n     * @param  value\\n     *         The int value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  BufferOverflowException\\n     *          If there are fewer than four bytes\\n     *          remaining in this buffer\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract int getInt(int index)", "label": "public abstract int getInt(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eget\u003c/i\u003e method for reading an int value.\\n     *\\n     * \u003cp\u003e Reads four bytes at the given index, composing them into a\\n     * int value according to the current byte order.  \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index from which the bytes will be read\\n     *\\n     * @return  The int value at the given index\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit,\\n     *          minus three\\n     \"}"}, {"color": "#97c2fc", "id": " abstract int getIntUnchecked(int index)", "label": " abstract int getIntUnchecked(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: {get,put}*Unchecked() accessors.\u0027}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer putInt(int index, int value)", "label": "public abstract ByteBuffer putInt(int index, int value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eput\u003c/i\u003e method for writing an int\\n     * value\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes four bytes containing the given int value, in the\\n     * current byte order, into this buffer at the given index.  \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index at which the bytes will be written\\n     *\\n     * @param  value\\n     *         The int value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit,\\n     *          minus three\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \"}"}, {"color": "#97c2fc", "id": " abstract void putIntUnchecked(int index, int value)", "label": " abstract void putIntUnchecked(int index, int value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: {get,put}*Unchecked() accessors.\u0027}"}, {"color": "#97c2fc", "id": "public abstract IntBuffer asIntBuffer()", "label": "public abstract IntBuffer asIntBuffer()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a view of this byte buffer as an int buffer.\\n     *\\n     * \u003cp\u003e The content of the new buffer will start at this buffer\u0027s current\\n     * position.  Changes to this buffer\u0027s content will be visible in the new\\n     * buffer, and vice versa; the two buffers\u0027 position, limit, and mark\\n     * values will be independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s position will be zero, its capacity and its limit\\n     * will be the number of bytes remaining in this buffer divided by\\n     * four, its mark will be undefined, and its byte order will be that\\n     * of the byte buffer at the moment the view is created.  The new buffer\\n     * will be direct if, and only if, this buffer is direct, and it will be\\n     * read-only if, and only if, this buffer is read-only.  \u003c/p\u003e\\n     *\\n     * @return  A new int buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract long getLong()", "label": "public abstract long getLong()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Relative \u003ci\u003eget\u003c/i\u003e method for reading a long value.\\n     *\\n     * \u003cp\u003e Reads the next eight bytes at this buffer\u0027s current position,\\n     * composing them into a long value according to the current byte order,\\n     * and then increments the position by eight.  \u003c/p\u003e\\n     *\\n     * @return  The long value at the buffer\u0027s current position\\n     *\\n     * @throws  BufferUnderflowException\\n     *          If there are fewer than eight bytes\\n     *          remaining in this buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer putLong(long value)", "label": "public abstract ByteBuffer putLong(long value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Relative \u003ci\u003eput\u003c/i\u003e method for writing a long\\n     * value\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes eight bytes containing the given long value, in the\\n     * current byte order, into this buffer at the current position, and then\\n     * increments the position by eight.  \u003c/p\u003e\\n     *\\n     * @param  value\\n     *         The long value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  BufferOverflowException\\n     *          If there are fewer than eight bytes\\n     *          remaining in this buffer\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract long getLong(int index)", "label": "public abstract long getLong(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eget\u003c/i\u003e method for reading a long value.\\n     *\\n     * \u003cp\u003e Reads eight bytes at the given index, composing them into a\\n     * long value according to the current byte order.  \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index from which the bytes will be read\\n     *\\n     * @return  The long value at the given index\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit,\\n     *          minus seven\\n     \"}"}, {"color": "#97c2fc", "id": " abstract long getLongUnchecked(int index)", "label": " abstract long getLongUnchecked(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: {get,put}*Unchecked() accessors.\u0027}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer putLong(int index, long value)", "label": "public abstract ByteBuffer putLong(int index, long value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eput\u003c/i\u003e method for writing a long\\n     * value\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes eight bytes containing the given long value, in the\\n     * current byte order, into this buffer at the given index.  \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index at which the bytes will be written\\n     *\\n     * @param  value\\n     *         The long value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit,\\n     *          minus seven\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \"}"}, {"color": "#97c2fc", "id": " abstract void putLongUnchecked(int index, long value)", "label": " abstract void putLongUnchecked(int index, long value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: {get,put}*Unchecked() accessors.\u0027}"}, {"color": "#97c2fc", "id": "public abstract LongBuffer asLongBuffer()", "label": "public abstract LongBuffer asLongBuffer()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a view of this byte buffer as a long buffer.\\n     *\\n     * \u003cp\u003e The content of the new buffer will start at this buffer\u0027s current\\n     * position.  Changes to this buffer\u0027s content will be visible in the new\\n     * buffer, and vice versa; the two buffers\u0027 position, limit, and mark\\n     * values will be independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s position will be zero, its capacity and its limit\\n     * will be the number of bytes remaining in this buffer divided by\\n     * eight, its mark will be undefined, and its byte order will be that\\n     * of the byte buffer at the moment the view is created.  The new buffer\\n     * will be direct if, and only if, this buffer is direct, and it will be\\n     * read-only if, and only if, this buffer is read-only.  \u003c/p\u003e\\n     *\\n     * @return  A new long buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract float getFloat()", "label": "public abstract float getFloat()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Relative \u003ci\u003eget\u003c/i\u003e method for reading a float value.\\n     *\\n     * \u003cp\u003e Reads the next four bytes at this buffer\u0027s current position,\\n     * composing them into a float value according to the current byte order,\\n     * and then increments the position by four.  \u003c/p\u003e\\n     *\\n     * @return  The float value at the buffer\u0027s current position\\n     *\\n     * @throws  BufferUnderflowException\\n     *          If there are fewer than four bytes\\n     *          remaining in this buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer putFloat(float value)", "label": "public abstract ByteBuffer putFloat(float value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Relative \u003ci\u003eput\u003c/i\u003e method for writing a float\\n     * value\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes four bytes containing the given float value, in the\\n     * current byte order, into this buffer at the current position, and then\\n     * increments the position by four.  \u003c/p\u003e\\n     *\\n     * @param  value\\n     *         The float value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  BufferOverflowException\\n     *          If there are fewer than four bytes\\n     *          remaining in this buffer\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract float getFloat(int index)", "label": "public abstract float getFloat(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eget\u003c/i\u003e method for reading a float value.\\n     *\\n     * \u003cp\u003e Reads four bytes at the given index, composing them into a\\n     * float value according to the current byte order.  \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index from which the bytes will be read\\n     *\\n     * @return  The float value at the given index\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit,\\n     *          minus three\\n     \"}"}, {"color": "#97c2fc", "id": " abstract float getFloatUnchecked(int index)", "label": " abstract float getFloatUnchecked(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: {get,put}*Unchecked() accessors.\u0027}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer putFloat(int index, float value)", "label": "public abstract ByteBuffer putFloat(int index, float value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eput\u003c/i\u003e method for writing a float\\n     * value\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes four bytes containing the given float value, in the\\n     * current byte order, into this buffer at the given index.  \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index at which the bytes will be written\\n     *\\n     * @param  value\\n     *         The float value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit,\\n     *          minus three\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \"}"}, {"color": "#97c2fc", "id": " abstract void putFloatUnchecked(int index, float value)", "label": " abstract void putFloatUnchecked(int index, float value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: {get,put}*Unchecked() accessors.\u0027}"}, {"color": "#97c2fc", "id": "public abstract FloatBuffer asFloatBuffer()", "label": "public abstract FloatBuffer asFloatBuffer()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a view of this byte buffer as a float buffer.\\n     *\\n     * \u003cp\u003e The content of the new buffer will start at this buffer\u0027s current\\n     * position.  Changes to this buffer\u0027s content will be visible in the new\\n     * buffer, and vice versa; the two buffers\u0027 position, limit, and mark\\n     * values will be independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s position will be zero, its capacity and its limit\\n     * will be the number of bytes remaining in this buffer divided by\\n     * four, its mark will be undefined, and its byte order will be that\\n     * of the byte buffer at the moment the view is created.  The new buffer\\n     * will be direct if, and only if, this buffer is direct, and it will be\\n     * read-only if, and only if, this buffer is read-only.  \u003c/p\u003e\\n     *\\n     * @return  A new float buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract double getDouble()", "label": "public abstract double getDouble()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Relative \u003ci\u003eget\u003c/i\u003e method for reading a double value.\\n     *\\n     * \u003cp\u003e Reads the next eight bytes at this buffer\u0027s current position,\\n     * composing them into a double value according to the current byte order,\\n     * and then increments the position by eight.  \u003c/p\u003e\\n     *\\n     * @return  The double value at the buffer\u0027s current position\\n     *\\n     * @throws  BufferUnderflowException\\n     *          If there are fewer than eight bytes\\n     *          remaining in this buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer putDouble(double value)", "label": "public abstract ByteBuffer putDouble(double value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Relative \u003ci\u003eput\u003c/i\u003e method for writing a double\\n     * value\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes eight bytes containing the given double value, in the\\n     * current byte order, into this buffer at the current position, and then\\n     * increments the position by eight.  \u003c/p\u003e\\n     *\\n     * @param  value\\n     *         The double value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  BufferOverflowException\\n     *          If there are fewer than eight bytes\\n     *          remaining in this buffer\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract double getDouble(int index)", "label": "public abstract double getDouble(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eget\u003c/i\u003e method for reading a double value.\\n     *\\n     * \u003cp\u003e Reads eight bytes at the given index, composing them into a\\n     * double value according to the current byte order.  \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index from which the bytes will be read\\n     *\\n     * @return  The double value at the given index\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit,\\n     *          minus seven\\n     \"}"}, {"color": "#97c2fc", "id": " abstract double getDoubleUnchecked(int index)", "label": " abstract double getDoubleUnchecked(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: {get,put}*Unchecked() accessors.\u0027}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer putDouble(int index, double value)", "label": "public abstract ByteBuffer putDouble(int index, double value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eput\u003c/i\u003e method for writing a double\\n     * value\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes eight bytes containing the given double value, in the\\n     * current byte order, into this buffer at the given index.  \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index at which the bytes will be written\\n     *\\n     * @param  value\\n     *         The double value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit,\\n     *          minus seven\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \"}"}, {"color": "#97c2fc", "id": " abstract void putDoubleUnchecked(int index, double value)", "label": " abstract void putDoubleUnchecked(int index, double value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: {get,put}*Unchecked() accessors.\u0027}"}, {"color": "#97c2fc", "id": "public abstract DoubleBuffer asDoubleBuffer()", "label": "public abstract DoubleBuffer asDoubleBuffer()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a view of this byte buffer as a double buffer.\\n     *\\n     * \u003cp\u003e The content of the new buffer will start at this buffer\u0027s current\\n     * position.  Changes to this buffer\u0027s content will be visible in the new\\n     * buffer, and vice versa; the two buffers\u0027 position, limit, and mark\\n     * values will be independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s position will be zero, its capacity and its limit\\n     * will be the number of bytes remaining in this buffer divided by\\n     * eight, its mark will be undefined, and its byte order will be that\\n     * of the byte buffer at the moment the view is created.  The new buffer\\n     * will be direct if, and only if, this buffer is direct, and it will be\\n     * read-only if, and only if, this buffer is read-only.  \u003c/p\u003e\\n     *\\n     * @return  A new double buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public final int remaining()", "label": "public final int remaining()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the number of elements between the current position and the\\n     * limit.\\n     *\\n     * @return  The number of elements remaining in this buffer\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final boolean hasRemaining()", "label": "public final boolean hasRemaining()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether there are any elements between the current position and\\n     * the limit.\\n     *\\n     * @return  {@code true} if, and only if, there is at least one element\\n     *          remaining in this buffer\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract boolean isReadOnly()", "label": "public abstract boolean isReadOnly()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this buffer is read-only.\\n     *\\n     * @return  {@code true} if, and only if, this buffer is read-only\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract boolean hasArray()", "label": "public abstract boolean hasArray()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this buffer is backed by an accessible\\n     * array.\\n     *\\n     * \u003cp\u003e If this method returns {@code true} then the {@link #array() array}\\n     * and {@link #arrayOffset() arrayOffset} methods may safely be invoked.\\n     * \u003c/p\u003e\\n     *\\n     * @return  {@code true} if, and only if, this buffer\\n     *          is backed by an array and is not read-only\\n     *\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract Object array()", "label": "public abstract Object array()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the array that backs this\\n     * buffer\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e This method is intended to allow array-backed buffers to be\\n     * passed to native code more efficiently. Concrete subclasses\\n     * provide more strongly-typed return values for this method.\\n     *\\n     * \u003cp\u003e Modifications to this buffer\u0027s content will cause the returned\\n     * array\u0027s content to be modified, and vice versa.\\n     *\\n     * \u003cp\u003e Invoke the {@link #hasArray hasArray} method before invoking this\\n     * method in order to ensure that this buffer has an accessible backing\\n     * array.  \u003c/p\u003e\\n     *\\n     * @return  The array that backs this buffer\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is backed by an array but is read-only\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          If this buffer is not backed by an accessible array\\n     *\\n     * @since 1.6\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract int arrayOffset()", "label": "public abstract int arrayOffset()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the offset within this buffer\u0027s backing array of the first\\n     * element of the buffer\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e If this buffer is backed by an array then buffer position \u003ci\u003ep\u003c/i\u003e\\n     * corresponds to array index \u003ci\u003ep\u003c/i\u003e\u0026nbsp;+\u0026nbsp;{@code arrayOffset()}.\\n     *\\n     * \u003cp\u003e Invoke the {@link #hasArray hasArray} method before invoking this\\n     * method in order to ensure that this buffer has an accessible backing\\n     * array.  \u003c/p\u003e\\n     *\\n     * @return  The offset within this buffer\u0027s array\\n     *          of the first element of the buffer\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is backed by an array but is read-only\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          If this buffer is not backed by an accessible array\\n     *\\n     * @since 1.6\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract Buffer slice()", "label": "public abstract Buffer slice()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a new buffer whose content is a shared subsequence of\\n     * this buffer\u0027s content.\\n     *\\n     * \u003cp\u003e The content of the new buffer will start at this buffer\u0027s current\\n     * position.  Changes to this buffer\u0027s content will be visible in the new\\n     * buffer, and vice versa; the two buffers\u0027 position, limit, and mark\\n     * values will be independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s position will be zero, its capacity and its limit\\n     * will be the number of elements remaining in this buffer, its mark will be\\n     * undefined. The new buffer will be direct if, and only if, this buffer is\\n     * direct, and it will be read-only if, and only if, this buffer is\\n     * read-only.  \u003c/p\u003e\\n     *\\n     * @return  The new buffer\\n     *\\n     * @since 9\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract Buffer slice(int index, int length)", "label": "public abstract Buffer slice(int index, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a new buffer whose content is a shared subsequence of\\n     * this buffer\u0027s content.\\n     *\\n     * \u003cp\u003e The content of the new buffer will start at position {@code index}\\n     * in this buffer, and will contain {@code length} elements. Changes to\\n     * this buffer\u0027s content will be visible in the new buffer, and vice versa;\\n     * the two buffers\u0027 position, limit, and mark values will be independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s position will be zero, its capacity and its limit\\n     * will be {@code length}, its mark will be undefined. The new buffer will\\n     * be direct if, and only if, this buffer is direct, and it will be\\n     * read-only if, and only if, this buffer is read-only.  \u003c/p\u003e\\n     *\\n     * @param   index\\n     *          The position in this buffer at which the content of the new\\n     *          buffer will start; must be non-negative and no larger than\\n     *          {@link #limit() limit()}\\n     *\\n     * @param   length\\n     *          The number of elements the new buffer will contain; must be\\n     *          non-negative and no larger than {@code limit() - index}\\n     *\\n     * @return  The new buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative or greater than {@code limit()},\\n     *          {@code length} is negative, or {@code length \u003e limit() - index}\\n     *\\n     * @since 13\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract Buffer duplicate()", "label": "public abstract Buffer duplicate()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a new buffer that shares this buffer\u0027s content.\\n     *\\n     * \u003cp\u003e The content of the new buffer will be that of this buffer.  Changes\\n     * to this buffer\u0027s content will be visible in the new buffer, and vice\\n     * versa; the two buffers\u0027 position, limit, and mark values will be\\n     * independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s capacity, limit, position and mark values will be\\n     * identical to those of this buffer. The new buffer will be direct if, and\\n     * only if, this buffer is direct, and it will be read-only if, and only if,\\n     * this buffer is read-only.  \u003c/p\u003e\\n     *\\n     * @return  The new buffer\\n     *\\n     * @since 9\\n     \"}"}, {"color": "#97c2fc", "id": " abstract Object base()", "label": " abstract Object base()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     *\\n     * @return the base reference, paired with the address\\n     * field, which in combination can be used for unsafe access into a heap\\n     * buffer or direct byte buffer (and views of).\\n     \u0027}"}, {"color": "#97c2fc", "id": " final int nextGetIndex()", "label": " final int nextGetIndex()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Checks the current position against the limit, throwing a {@link\\n     * BufferUnderflowException} if it is not smaller than the limit, and then\\n     * increments the position.\\n     *\\n     * @return  The current position value, before it is incremented\\n     \u0027}"}, {"color": "#97c2fc", "id": " final int nextPutIndex()", "label": " final int nextPutIndex()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Checks the current position against the limit, throwing a {@link\\n     * BufferOverflowException} if it is not smaller than the limit, and then\\n     * increments the position.\\n     *\\n     * @return  The current position value, before it is incremented\\n     \u0027}"}, {"color": "#97c2fc", "id": " final int checkIndex(int i)", "label": " final int checkIndex(int i)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Checks the given index against the limit, throwing an {@link\\n     * IndexOutOfBoundsException} if it is not smaller than the limit\\n     * or is smaller than zero.\\n     \u0027}"}, {"color": "#97c2fc", "id": "IndexOutOfBoundsException", "label": "IndexOutOfBoundsException", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public final CoderResult flush(ByteBuffer out)", "label": "public final CoderResult flush(ByteBuffer out)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Flushes this encoder.\\n     *\\n     * \u003cp\u003e Some encoders maintain internal state and may need to write some\\n     * final bytes to the output buffer once the overall input sequence has\\n     * been read.\\n     *\\n     * \u003cp\u003e Any additional output is written to the output buffer beginning at\\n     * its current position.  At most {@link Buffer#remaining out.remaining()}\\n     * bytes will be written.  The buffer\\\u0027s position will be advanced\\n     * appropriately, but its mark and limit will not be modified.\\n     *\\n     * \u003cp\u003e If this method completes successfully then it returns {@link\\n     * CoderResult#UNDERFLOW}.  If there is insufficient room in the output\\n     * buffer then it returns {@link CoderResult#OVERFLOW}.  If this happens\\n     * then this method must be invoked again, with an output buffer that has\\n     * more room, in order to complete the current \u003ca href=\"#steps\"\u003eencoding\\n     * operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003e If this encoder has already been flushed then invoking this method\\n     * has no effect.\\n     *\\n     * \u003cp\u003e This method invokes the {@link #implFlush implFlush} method to\\n     * perform the actual flushing operation.  \u003c/p\u003e\\n     *\\n     * @param  out\\n     *         The output byte buffer\\n     *\\n     * @return  A coder-result object, either {@link CoderResult#UNDERFLOW} or\\n     *          {@link CoderResult#OVERFLOW}\\n     *\\n     * @throws  IllegalStateException\\n     *          If the previous step of the current encoding operation was an\\n     *          invocation neither of the {@link #flush flush} method nor of\\n     *          the three-argument {@link\\n     *          #encode(CharBuffer,ByteBuffer,boolean) encode} method\\n     *          with a value of {@code true} for the {@code endOfInput}\\n     *          parameter\\n     \u0027}"}, {"color": "#97c2fc", "id": "encode(CharBuffer", "label": "encode(CharBuffer", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "flush", "label": "flush", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "implFlush", "label": "implFlush", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "protected CoderResult implFlush(ByteBuffer out)", "label": "protected CoderResult implFlush(ByteBuffer out)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Flushes this encoder.\\n     *\\n     * \u003cp\u003e The default implementation of this method does nothing, and always\\n     * returns {@link CoderResult#UNDERFLOW}.  This method should be overridden\\n     * by encoders that may need to write final bytes to the output buffer\\n     * once the entire input sequence has been read. \u003c/p\u003e\\n     *\\n     * @param  out\\n     *         The output byte buffer\\n     *\\n     * @return  A coder-result object, either {@link CoderResult#UNDERFLOW} or\\n     *          {@link CoderResult#OVERFLOW}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final CharsetEncoder reset()", "label": "public final CharsetEncoder reset()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Resets this encoder, clearing any internal state.\\n     *\\n     * \u003cp\u003e This method resets charset-independent state and also invokes the\\n     * {@link #implReset() implReset} method in order to perform any\\n     * charset-specific reset actions.  \u003c/p\u003e\\n     *\\n     * @return  This encoder\\n     *\\n     \u0027}"}, {"color": "#97c2fc", "id": "implReset()", "label": "implReset()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "protected void implReset()", "label": "protected void implReset()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Resets this encoder, clearing any charset-specific internal state.\\n     *\\n     * \u003cp\u003e The default implementation of this method does nothing.  This method\\n     * should be overridden by encoders that maintain internal state.  \u003c/p\u003e\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected abstract CoderResult encodeLoop(CharBuffer in, ByteBuffer out)", "label": "protected abstract CoderResult encodeLoop(CharBuffer in, ByteBuffer out)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Encodes one or more characters into one or more bytes.\\n     *\\n     * \u003cp\u003e This method encapsulates the basic encoding loop, encoding as many\\n     * characters as possible until it either runs out of input, runs out of room\\n     * in the output buffer, or encounters an encoding error.  This method is\\n     * invoked by the {@link #encode encode} method, which handles result\\n     * interpretation and error recovery.\\n     *\\n     * \u003cp\u003e The buffers are read from, and written to, starting at their current\\n     * positions.  At most {@link Buffer#remaining in.remaining()} characters\\n     * will be read, and at most {@link Buffer#remaining out.remaining()}\\n     * bytes will be written.  The buffers\u0027 positions will be advanced to\\n     * reflect the characters read and the bytes written, but their marks and\\n     * limits will not be modified.\\n     *\\n     * \u003cp\u003e This method returns a {@link CoderResult} object to describe its\\n     * reason for termination, in the same manner as the {@link #encode encode}\\n     * method.  Most implementations of this method will handle encoding errors\\n     * by returning an appropriate result object for interpretation by the\\n     * {@link #encode encode} method.  An optimized implementation may instead\\n     * examine the relevant error action and implement that action itself.\\n     *\\n     * \u003cp\u003e An implementation of this method may perform arbitrary lookahead by\\n     * returning {@link CoderResult#UNDERFLOW} until it receives sufficient\\n     * input.  \u003c/p\u003e\\n     *\\n     * @param  in\\n     *         The input character buffer\\n     *\\n     * @param  out\\n     *         The output byte buffer\\n     *\\n     * @return  A coder-result object describing the reason for termination\\n     \"}"}, {"color": "#97c2fc", "id": "encode", "label": "encode", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public final ByteBuffer encode(CharBuffer in) throws CharacterCodingException", "label": "public final ByteBuffer encode(CharBuffer in) throws CharacterCodingException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Convenience method that encodes the remaining content of a single input\\n     * character buffer into a newly-allocated byte buffer.\\n     *\\n     * \u003cp\u003e This method implements an entire \u003ca href=\"#steps\"\u003eencoding\\n     * operation\u003c/a\u003e; that is, it resets this encoder, then it encodes the\\n     * characters in the given character buffer, and finally it flushes this\\n     * encoder.  This method should therefore not be invoked if an encoding\\n     * operation is already in progress.  \u003c/p\u003e\\n     *\\n     * @param  in\\n     *         The input character buffer\\n     *\\n     * @return A newly-allocated byte buffer containing the result of the\\n     *         encoding operation.  The buffer\\\u0027s position will be zero and its\\n     *         limit will follow the last byte written.\\n     *\\n     * @throws  IllegalStateException\\n     *          If an encoding operation is already in progress\\n     *\\n     * @throws  MalformedInputException\\n     *          If the character sequence starting at the input buffer\\\u0027s current\\n     *          position is not a legal sixteen-bit Unicode sequence and the current malformed-input action\\n     *          is {@link CodingErrorAction#REPORT}\\n     *\\n     * @throws  UnmappableCharacterException\\n     *          If the character sequence starting at the input buffer\\\u0027s current\\n     *          position cannot be mapped to an equivalent byte sequence and\\n     *          the current unmappable-character action is {@link\\n     *          CodingErrorAction#REPORT}\\n     *\\n     * @throws  CoderMalfunctionError\\n     *          If an invocation of the encodeLoop method threw\\n     *          an unexpected exception\\n     *\\n     * @throws  NullPointerException if input buffer is null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean canEncode(char c)", "label": "public boolean canEncode(char c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this encoder can encode the given character.\\n     *\\n     * \u003cp\u003e This method returns {@code false} if the given character is a\\n     * surrogate character; such characters can be interpreted only when they\\n     * are members of a pair consisting of a high surrogate followed by a low\\n     * surrogate.  The {@link #canEncode(java.lang.CharSequence)\\n     * canEncode(CharSequence)} method may be used to test whether or not a\\n     * character sequence can be encoded.\\n     *\\n     * \u003cp\u003e This method may modify this encoder\\\u0027s state; it should therefore not\\n     * be invoked if an \u003ca href=\"#steps\"\u003eencoding operation\u003c/a\u003e is already in\\n     * progress.\\n     *\\n     * \u003cp\u003e The default implementation of this method is not very efficient; it\\n     * should generally be overridden to improve performance.  \u003c/p\u003e\\n     *\\n     * @param   c\\n     *          The given character\\n     *\\n     * @return  {@code true} if, and only if, this encoder can encode\\n     *          the given character\\n     *\\n     * @throws  IllegalStateException\\n     *          If an encoding operation is already in progress\\n     \u0027}"}, {"color": "#97c2fc", "id": "canEncode(java.lang.CharSequence)", "label": "canEncode(java.lang.CharSequence)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public boolean canEncode(CharSequence cs)", "label": "public boolean canEncode(CharSequence cs)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this encoder can encode the given character\\n     * sequence.\\n     *\\n     * \u003cp\u003e If this method returns {@code false} for a particular character\\n     * sequence then more information about why the sequence cannot be encoded\\n     * may be obtained by performing a full \u003ca href=\"#steps\"\u003eencoding\\n     * operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003e This method may modify this encoder\\\u0027s state; it should therefore not\\n     * be invoked if an encoding operation is already in progress.\\n     *\\n     * \u003cp\u003e The default implementation of this method is not very efficient; it\\n     * should generally be overridden to improve performance.  \u003c/p\u003e\\n     *\\n     * @param   cs\\n     *          The given character sequence\\n     *\\n     * @return  {@code true} if, and only if, this encoder can encode\\n     *          the given character without throwing any exceptions and without\\n     *          performing any replacements\\n     *\\n     * @throws  IllegalStateException\\n     *          If an encoding operation is already in progress\\n     \u0027}"}, {"color": "#97c2fc", "id": "public byte[] getBytes(Charset charset)", "label": "public byte[] getBytes(Charset charset)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Encodes this {@code String} into a sequence of bytes using the given\\n     * {@linkplain java.nio.charset.Charset charset}, storing the result into a\\n     * new byte array.\\n     *\\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\\n     * sequences with this charset\u0027s default replacement byte array.  The\\n     * {@link java.nio.charset.CharsetEncoder} class should be used when more\\n     * control over the encoding process is required.\\n     *\\n     * @param  charset\\n     *         The {@linkplain java.nio.charset.Charset} to be used to encode\\n     *         the {@code String}\\n     *\\n     * @return  The resultant byte array\\n     *\\n     * @since  1.6\\n     \"}"}, {"color": "#97c2fc", "id": "public byte[] getBytes()", "label": "public byte[] getBytes()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Encodes this {@code String} into a sequence of bytes using the\\n     * platform\u0027s default charset, storing the result into a new byte array.\\n     *\\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\\n     * the default charset is unspecified.  The {@link\\n     * java.nio.charset.CharsetEncoder} class should be used when more control\\n     * over the encoding process is required.\\n     *\\n     * @return  The resultant byte array\\n     *\\n     * @since      1.1\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean equals(Object anObject)", "label": "public boolean equals(Object anObject)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares this string to the specified object.  The result is {@code\\n     * true} if and only if the argument is not {@code null} and is a {@code\\n     * String} object that represents the same sequence of characters as this\\n     * object.\\n     *\\n     * \u003cp\u003eFor finer-grained String comparison, refer to\\n     * {@link java.text.Collator}.\\n     *\\n     * @param  anObject\\n     *         The object to compare this {@code String} against\\n     *\\n     * @return  {@code true} if the given object represents a {@code String}\\n     *          equivalent to this string, {@code false} otherwise\\n     *\\n     * @see  #compareTo(String)\\n     * @see  #equalsIgnoreCase(String)\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.text.Collator", "label": "java.text.Collator", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public static synchronized Collator getInstance()", "label": "public static synchronized Collator getInstance()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets the Collator for the current default locale.\\n     * The default locale is determined by java.util.Locale.getDefault.\\n     * @return the Collator for the default locale.(for example, en_US)\\n     * @see java.util.Locale#getDefault\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collator getInstance(Locale desiredLocale)", "label": "public static Collator getInstance(Locale desiredLocale)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets the Collator for the desired locale.\\n     * @param desiredLocale the desired locale.\\n     * @return the Collator for the desired locale.\\n     * @see java.util.Locale\\n     * @see java.util.ResourceBundle\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract int compare(String source, String target)", "label": "public abstract int compare(String source, String target)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares the source string to the target string according to the\\n     * collation rules for this Collator.  Returns an integer less than,\\n     * equal to or greater than zero depending on whether the source String is\\n     * less than, equal to or greater than the target string.  See the Collator\\n     * class description for an example of use.\\n     * \u003cp\u003e\\n     * For a one time comparison, this method has the best performance. If a\\n     * given String will be involved in multiple comparisons, CollationKey.compareTo\\n     * has the best performance. See the Collator class description for an example\\n     * using CollationKeys.\\n     * @param source the source string.\\n     * @param target the target string.\\n     * @return Returns an integer value. Value is less than zero if source is less than\\n     * target, value is zero if source and target are equal, value is greater than zero\\n     * if source is greater than target.\\n     * @see java.text.CollationKey\\n     * @see java.text.Collator#getCollationKey\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int compare(Object o1, Object o2)", "label": "public int compare(Object o1, Object o2)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares its two arguments for order.  Returns a negative integer,\\n     * zero, or a positive integer as the first argument is less than, equal\\n     * to, or greater than the second.\\n     * \u003cp\u003e\\n     * This implementation merely returns\\n     *  {@code  compare((String)o1, (String)o2) }.\\n     *\\n     * @return a negative integer, zero, or a positive integer as the\\n     *         first argument is less than, equal to, or greater than the\\n     *         second.\\n     * @throws    ClassCastException the arguments cannot be cast to Strings.\\n     * @see java.util.Comparator\\n     * @since   1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract CollationKey getCollationKey(String source)", "label": "public abstract CollationKey getCollationKey(String source)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Transforms the String into a series of bits that can be compared bitwise\\n     * to other CollationKeys. CollationKeys provide better performance than\\n     * Collator.compare when Strings are involved in multiple comparisons.\\n     * See the Collator class description for an example using CollationKeys.\\n     * @param source the string to be transformed into a collation key.\\n     * @return the CollationKey for the given String based on this Collator\u0027s collation\\n     * rules. If the source String is null, a null CollationKey is returned.\\n     * @see java.text.CollationKey\\n     * @see java.text.Collator#compare\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean equals(String source, String target)", "label": "public boolean equals(String source, String target)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Convenience method for comparing the equality of two strings based on\\n     * this Collator\u0027s collation rules.\\n     * @param source the source string to be compared with.\\n     * @param target the target string to be compared with.\\n     * @return true if the strings are equal according to the collation\\n     * rules.  false, otherwise.\\n     * @see java.text.Collator#compare\\n     \"}"}, {"color": "#97c2fc", "id": "public synchronized int getStrength()", "label": "public synchronized int getStrength()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns this Collator\u0027s strength property.  The strength property determines\\n     * the minimum level of difference considered significant during comparison.\\n     * See the Collator class description for an example of use.\\n     * @return this Collator\u0027s current strength property.\\n     * @see java.text.Collator#setStrength\\n     * @see java.text.Collator#PRIMARY\\n     * @see java.text.Collator#SECONDARY\\n     * @see java.text.Collator#TERTIARY\\n     * @see java.text.Collator#IDENTICAL\\n     \"}"}, {"color": "#97c2fc", "id": "public synchronized void setStrength(int newStrength)", "label": "public synchronized void setStrength(int newStrength)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Sets this Collator\u0027s strength property.  The strength property determines\\n     * the minimum level of difference considered significant during comparison.\\n     * See the Collator class description for an example of use.\\n     * @param newStrength  the new strength value.\\n     * @see java.text.Collator#getStrength\\n     * @see java.text.Collator#PRIMARY\\n     * @see java.text.Collator#SECONDARY\\n     * @see java.text.Collator#TERTIARY\\n     * @see java.text.Collator#IDENTICAL\\n     * @throws     IllegalArgumentException If the new strength value is not one of\\n     * PRIMARY, SECONDARY, TERTIARY or IDENTICAL.\\n     \"}"}, {"color": "#97c2fc", "id": "public synchronized int getDecomposition()", "label": "public synchronized int getDecomposition()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the decomposition mode of this Collator. Decomposition mode\\n     * determines how Unicode composed characters are handled. Adjusting\\n     * decomposition mode allows the user to select between faster and more\\n     * complete collation behavior.\\n     * \u003cp\u003eThe three values for decomposition mode are:\\n     * \u003cUL\u003e\\n     * \u003cLI\u003eNO_DECOMPOSITION,\\n     * \u003cLI\u003eCANONICAL_DECOMPOSITION\\n     * \u003cLI\u003eFULL_DECOMPOSITION.\\n     * \u003c/UL\u003e\\n     * See the documentation for these three constants for a description\\n     * of their meaning.\\n     * @return the decomposition mode\\n     * @see java.text.Collator#setDecomposition\\n     * @see java.text.Collator#NO_DECOMPOSITION\\n     * @see java.text.Collator#CANONICAL_DECOMPOSITION\\n     * @see java.text.Collator#FULL_DECOMPOSITION\\n     \u0027}"}, {"color": "#97c2fc", "id": "public synchronized void setDecomposition(int decompositionMode)", "label": "public synchronized void setDecomposition(int decompositionMode)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Set the decomposition mode of this Collator. See getDecomposition\\n     * for a description of decomposition mode.\\n     * @param decompositionMode  the new decomposition mode.\\n     * @see java.text.Collator#getDecomposition\\n     * @see java.text.Collator#NO_DECOMPOSITION\\n     * @see java.text.Collator#CANONICAL_DECOMPOSITION\\n     * @see java.text.Collator#FULL_DECOMPOSITION\\n     * @throws    IllegalArgumentException If the given value is not a valid decomposition\\n     * mode.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static synchronized Locale[] getAvailableLocales()", "label": "public static synchronized Locale[] getAvailableLocales()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an array of all locales for which the\\n     * {@code getInstance} methods of this class can return\\n     * localized instances.\\n     *\\n     * @return An array of locales for which localized\\n     *         {@code Collator} instances are available.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private int decompositionMode_Java_ICU(int mode)", "label": "private int decompositionMode_Java_ICU(int mode)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: conversion method for decompositionMode constants.\u0027}"}, {"color": "#97c2fc", "id": "public Object clone()", "label": "public Object clone()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a new collator with the same decomposition mode and\\n     * strength value as this collator.\\n     *\\n     * @return a shallow copy of this collator.\\n     * @see java.lang.Cloneable\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean equals(Object that)", "label": "public boolean equals(Object that)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares the equality of two Collators.\\n     * @param that the Collator to be compared with this.\\n     * @return true if this Collator is the same as that Collator;\\n     * false otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract int hashCode()", "label": "public abstract int hashCode()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Generates the hash code for this Collator.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean contentEquals(StringBuffer sb)", "label": "public boolean contentEquals(StringBuffer sb)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares this string to the specified {@code StringBuffer}.  The result\\n     * is {@code true} if and only if this {@code String} represents the same\\n     * sequence of characters as the specified {@code StringBuffer}. This method\\n     * synchronizes on the {@code StringBuffer}.\\n     *\\n     * \u003cp\u003eFor finer-grained String comparison, refer to\\n     * {@link java.text.Collator}.\\n     *\\n     * @param  sb\\n     *         The {@code StringBuffer} to compare this {@code String} against\\n     *\\n     * @return  {@code true} if this {@code String} represents the same\\n     *          sequence of characters as the specified {@code StringBuffer},\\n     *          {@code false} otherwise\\n     *\\n     * @since  1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean contentEquals(CharSequence cs)", "label": "public boolean contentEquals(CharSequence cs)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares this string to the specified {@code CharSequence}.  The\\n     * result is {@code true} if and only if this {@code String} represents the\\n     * same sequence of char values as the specified sequence. Note that if the\\n     * {@code CharSequence} is a {@code StringBuffer} then the method\\n     * synchronizes on it.\\n     *\\n     * \u003cp\u003eFor finer-grained String comparison, refer to\\n     * {@link java.text.Collator}.\\n     *\\n     * @param  cs\\n     *         The sequence to compare this {@code String} against\\n     *\\n     * @return  {@code true} if this {@code String} represents the same\\n     *          sequence of char values as the specified sequence, {@code\\n     *          false} otherwise\\n     *\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean equalsIgnoreCase(String anotherString)", "label": "public boolean equalsIgnoreCase(String anotherString)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares this {@code String} to another {@code String}, ignoring case\\n     * considerations.  Two strings are considered equal ignoring case if they\\n     * are of the same length and corresponding characters in the two strings\\n     * are equal ignoring case.\\n     *\\n     * \u003cp\u003e Two characters {@code c1} and {@code c2} are considered the same\\n     * ignoring case if at least one of the following is true:\\n     * \u003cul\u003e\\n     *   \u003cli\u003e The two characters are the same (as compared by the\\n     *        {@code ==} operator)\\n     *   \u003cli\u003e Calling {@code Character.toLowerCase(Character.toUpperCase(char))}\\n     *        on each character produces the same result\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account, and\\n     * will result in unsatisfactory results for certain locales.  The\\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\\n     *\\n     * @param  anotherString\\n     *         The {@code String} to compare this {@code String} against\\n     *\\n     * @return  {@code true} if the argument is not {@code null} and it\\n     *          represents an equivalent {@code String} ignoring case; {@code\\n     *          false} otherwise\\n     *\\n     * @see  #equals(Object)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public native int compareTo(String anotherString)", "label": "public native int compareTo(String anotherString)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public int compareTo(String anotherString) {\\n        byte v1[] = value;\\n        byte v2[] = anotherString.value;\\n        if (coder() == anotherString.coder()) {\\n            return isLatin1() ? StringLatin1.compareTo(v1, v2)\\n                              : StringUTF16.compareTo(v1, v2);\\n        }\\n        return isLatin1() ? StringLatin1.compareToUTF16(v1, v2)\\n                          : StringUTF16.compareToLatin1(v1, v2);\\n     }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public int compareToIgnoreCase(String str)", "label": "public int compareToIgnoreCase(String str)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two strings lexicographically, ignoring case\\n     * differences. This method returns an integer whose sign is that of\\n     * calling {@code compareTo} with normalized versions of the strings\\n     * where case differences have been eliminated by calling\\n     * {@code Character.toLowerCase(Character.toUpperCase(character))} on\\n     * each character.\\n     * \u003cp\u003e\\n     * Note that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\\n     * and will result in an unsatisfactory ordering for certain locales.\\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\\n     *\\n     * @param   str   the {@code String} to be compared.\\n     * @return  a negative integer, zero, or a positive integer as the\\n     *          specified String is greater than, equal to, or less\\n     *          than this String, ignoring case considerations.\\n     * @see     java.text.Collator\\n     * @since   1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean regionMatches(int toffset, String other, int ooffset, int len)", "label": "public boolean regionMatches(int toffset, String other, int ooffset, int len)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests if two string regions are equal.\\n     * \u003cp\u003e\\n     * A substring of this {@code String} object is compared to a substring\\n     * of the argument other. The result is true if these substrings\\n     * represent identical character sequences. The substring of this\\n     * {@code String} object to be compared begins at index {@code toffset}\\n     * and has length {@code len}. The substring of other to be compared\\n     * begins at index {@code ooffset} and has length {@code len}. The\\n     * result is {@code false} if and only if at least one of the following\\n     * is true:\\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is negative.\\n     * \u003cli\u003e{@code ooffset} is negative.\\n     * \u003cli\u003e{@code toffset+len} is greater than the length of this\\n     * {@code String} object.\\n     * \u003cli\u003e{@code ooffset+len} is greater than the length of the other\\n     * argument.\\n     * \u003cli\u003eThere is some nonnegative integer \u003ci\u003ek\u003c/i\u003e less than {@code len}\\n     * such that:\\n     * {@code this.charAt(toffset + }\u003ci\u003ek\u003c/i\u003e{@code ) != other.charAt(ooffset + }\\n     * \u003ci\u003ek\u003c/i\u003e{@code )}\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account.  The\\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\\n     *\\n     * @param   toffset   the starting offset of the subregion in this string.\\n     * @param   other     the string argument.\\n     * @param   ooffset   the starting offset of the subregion in the string\\n     *                    argument.\\n     * @param   len       the number of characters to compare.\\n     * @return  {@code true} if the specified subregion of this string\\n     *          exactly matches the specified subregion of the string argument;\\n     *          {@code false} otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)", "label": "public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests if two string regions are equal.\\n     * \u003cp\u003e\\n     * A substring of this {@code String} object is compared to a substring\\n     * of the argument {@code other}. The result is {@code true} if these\\n     * substrings represent character sequences that are the same, ignoring\\n     * case if and only if {@code ignoreCase} is true. The substring of\\n     * this {@code String} object to be compared begins at index\\n     * {@code toffset} and has length {@code len}. The substring of\\n     * {@code other} to be compared begins at index {@code ooffset} and\\n     * has length {@code len}. The result is {@code false} if and only if\\n     * at least one of the following is true:\\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is negative.\\n     * \u003cli\u003e{@code ooffset} is negative.\\n     * \u003cli\u003e{@code toffset+len} is greater than the length of this\\n     * {@code String} object.\\n     * \u003cli\u003e{@code ooffset+len} is greater than the length of the other\\n     * argument.\\n     * \u003cli\u003e{@code ignoreCase} is {@code false} and there is some nonnegative\\n     * integer \u003ci\u003ek\u003c/i\u003e less than {@code len} such that:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * this.charAt(toffset+k) != other.charAt(ooffset+k)\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * \u003cli\u003e{@code ignoreCase} is {@code true} and there is some nonnegative\\n     * integer \u003ci\u003ek\u003c/i\u003e less than {@code len} such that:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * Character.toLowerCase(Character.toUpperCase(this.charAt(toffset+k))) !=\\n     Character.toLowerCase(Character.toUpperCase(other.charAt(ooffset+k)))\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\\n     * and will result in unsatisfactory results for certain locales when\\n     * {@code ignoreCase} is {@code true}.  The {@link java.text.Collator} class\\n     * provides locale-sensitive comparison.\\n     *\\n     * @param   ignoreCase   if {@code true}, ignore case when comparing\\n     *                       characters.\\n     * @param   toffset      the starting offset of the subregion in this\\n     *                       string.\\n     * @param   other        the string argument.\\n     * @param   ooffset      the starting offset of the subregion in the string\\n     *                       argument.\\n     * @param   len          the number of characters to compare.\\n     * @return  {@code true} if the specified subregion of this string\\n     *          matches the specified subregion of the string argument;\\n     *          {@code false} otherwise. Whether the matching is exact\\n     *          or case insensitive depends on the {@code ignoreCase}\\n     *          argument.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean startsWith(String prefix, int toffset)", "label": "public boolean startsWith(String prefix, int toffset)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests if the substring of this string beginning at the\\n     * specified index starts with the specified prefix.\\n     *\\n     * @param   prefix    the prefix.\\n     * @param   toffset   where to begin looking in this string.\\n     * @return  {@code true} if the character sequence represented by the\\n     *          argument is a prefix of the substring of this object starting\\n     *          at index {@code toffset}; {@code false} otherwise.\\n     *          The result is {@code false} if {@code toffset} is\\n     *          negative or greater than the length of this\\n     *          {@code String} object; otherwise the result is the same\\n     *          as the result of the expression\\n     *          \u003cpre\u003e\\n     *          this.substring(toffset).startsWith(prefix)\\n     *          \u003c/pre\u003e\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean startsWith(String prefix)", "label": "public boolean startsWith(String prefix)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests if this string starts with the specified prefix.\\n     *\\n     * @param   prefix   the prefix.\\n     * @return  {@code true} if the character sequence represented by the\\n     *          argument is a prefix of the character sequence represented by\\n     *          this string; {@code false} otherwise.\\n     *          Note also that {@code true} will be returned if the\\n     *          argument is an empty string or is equal to this\\n     *          {@code String} object as determined by the\\n     *          {@link #equals(Object)} method.\\n     * @since   1.0\\n     \u0027}"}, {"color": "#97c2fc", "id": "equals(Object)", "label": "equals(Object)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public boolean endsWith(String suffix)", "label": "public boolean endsWith(String suffix)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests if this string ends with the specified suffix.\\n     *\\n     * @param   suffix   the suffix.\\n     * @return  {@code true} if the character sequence represented by the\\n     *          argument is a suffix of the character sequence represented by\\n     *          this object; {@code false} otherwise. Note that the\\n     *          result will be {@code true} if the argument is the\\n     *          empty string or is equal to this {@code String} object\\n     *          as determined by the {@link #equals(Object)} method.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int indexOf(int ch)", "label": "public int indexOf(int ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index within this string of the first occurrence of\\n     * the specified character. If a character with value\\n     * {@code ch} occurs in the character sequence represented by\\n     * this {@code String} object, then the index (in Unicode\\n     * code units) of the first such occurrence is returned. For\\n     * values of {@code ch} in the range from 0 to 0xFFFF\\n     * (inclusive), this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) == ch\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * is true. For other values of {@code ch}, it is the\\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) == ch\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * is true. In either case, if no such character occurs in this\\n     * string, then {@code -1} is returned.\\n     *\\n     * @param   ch   a character (Unicode code point).\\n     * @return  the index of the first occurrence of the character in the\\n     *          character sequence represented by this object, or\\n     *          {@code -1} if the character does not occur.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int indexOf(int ch, int fromIndex)", "label": "public int indexOf(int ch, int fromIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index within this string of the first occurrence of the\\n     * specified character, starting the search at the specified index.\\n     * \u003cp\u003e\\n     * If a character with value {@code ch} occurs in the\\n     * character sequence represented by this {@code String}\\n     * object at an index no smaller than {@code fromIndex}, then\\n     * the index of the first such occurrence is returned. For values\\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) == ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;= fromIndex)\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * is true. For other values of {@code ch}, it is the\\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) == ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;= fromIndex)\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * is true. In either case, if no such character occurs in this\\n     * string at or after position {@code fromIndex}, then\\n     * {@code -1} is returned.\\n     *\\n     * \u003cp\u003e\\n     * There is no restriction on the value of {@code fromIndex}. If it\\n     * is negative, it has the same effect as if it were zero: this entire\\n     * string may be searched. If it is greater than the length of this\\n     * string, it has the same effect as if it were equal to the length of\\n     * this string: {@code -1} is returned.\\n     *\\n     * \u003cp\u003eAll indices are specified in {@code char} values\\n     * (Unicode code units).\\n     *\\n     * @param   ch          a character (Unicode code point).\\n     * @param   fromIndex   the index to start the search from.\\n     * @return  the index of the first occurrence of the character in the\\n     *          character sequence represented by this object that is greater\\n     *          than or equal to {@code fromIndex}, or {@code -1}\\n     *          if the character does not occur.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private int indexOfSupplementary(int ch, int fromIndex)", "label": "private int indexOfSupplementary(int ch, int fromIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Handles (rare) calls of indexOf with a supplementary character.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int lastIndexOf(int ch)", "label": "public int lastIndexOf(int ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index within this string of the last occurrence of\\n     * the specified character. For values of {@code ch} in the\\n     * range from 0 to 0xFFFF (inclusive), the index (in Unicode code\\n     * units) returned is the largest value \u003ci\u003ek\u003c/i\u003e such that:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) == ch\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * is true. For other values of {@code ch}, it is the\\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) == ch\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * is true.  In either case, if no such character occurs in this\\n     * string, then {@code -1} is returned.  The\\n     * {@code String} is searched backwards starting at the last\\n     * character.\\n     *\\n     * @param   ch   a character (Unicode code point).\\n     * @return  the index of the last occurrence of the character in the\\n     *          character sequence represented by this object, or\\n     *          {@code -1} if the character does not occur.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int lastIndexOf(int ch, int fromIndex)", "label": "public int lastIndexOf(int ch, int fromIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index within this string of the last occurrence of\\n     * the specified character, searching backward starting at the\\n     * specified index. For values of {@code ch} in the range\\n     * from 0 to 0xFFFF (inclusive), the index returned is the largest\\n     * value \u003ci\u003ek\u003c/i\u003e such that:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) == ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;= fromIndex)\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * is true. For other values of {@code ch}, it is the\\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) == ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;= fromIndex)\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * is true. In either case, if no such character occurs in this\\n     * string at or before position {@code fromIndex}, then\\n     * {@code -1} is returned.\\n     *\\n     * \u003cp\u003eAll indices are specified in {@code char} values\\n     * (Unicode code units).\\n     *\\n     * @param   ch          a character (Unicode code point).\\n     * @param   fromIndex   the index to start the search from. There is no\\n     *          restriction on the value of {@code fromIndex}. If it is\\n     *          greater than or equal to the length of this string, it has\\n     *          the same effect as if it were equal to one less than the\\n     *          length of this string: this entire string may be searched.\\n     *          If it is negative, it has the same effect as if it were -1:\\n     *          -1 is returned.\\n     * @return  the index of the last occurrence of the character in the\\n     *          character sequence represented by this object that is less\\n     *          than or equal to {@code fromIndex}, or {@code -1}\\n     *          if the character does not occur before that point.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private int lastIndexOfSupplementary(int ch, int fromIndex)", "label": "private int lastIndexOfSupplementary(int ch, int fromIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Handles (rare) calls of lastIndexOf with a supplementary character.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int indexOf(String str)", "label": "public int indexOf(String str)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index within this string of the first occurrence of the\\n     * specified substring.\\n     *\\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\\n     * \u003cpre\u003e{@code\\n     * this.startsWith(str, k)\\n     * }\u003c/pre\u003e\\n     * If no such value of {@code k} exists, then {@code -1} is returned.\\n     *\\n     * @param   str   the substring to search for.\\n     * @return  the index of the first occurrence of the specified substring,\\n     *          or {@code -1} if there is no such occurrence.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int indexOf(String str, int fromIndex)", "label": "public int indexOf(String str, int fromIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index within this string of the first occurrence of the\\n     * specified substring, starting at the specified index.\\n     *\\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\\n     * \u003cpre\u003e{@code\\n     *     k \u003e= Math.min(fromIndex, this.length()) \u0026\u0026\\n     *                   this.startsWith(str, k)\\n     * }\u003c/pre\u003e\\n     * If no such value of {@code k} exists, then {@code -1} is returned.\\n     *\\n     * @param   str         the substring to search for.\\n     * @param   fromIndex   the index from which to start the search.\\n     * @return  the index of the first occurrence of the specified substring,\\n     *          starting at the specified index,\\n     *          or {@code -1} if there is no such occurrence.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static int indexOf(String source, String target, int fromIndex)", "label": "private static int indexOf(String source, String target, int fromIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The source is the string being searched, and the target is the string being searched for.\\n     *\\n     * @param   source       the characters being searched.\\n     * @param   target       the characters being searched for.\\n     * @param   fromIndex    the index to begin searching from.\\n     \u0027}"}, {"color": "#97c2fc", "id": " static int indexOf(byte[] src, byte srcCoder, int srcCount, String tgtStr, int fromIndex)", "label": " static int indexOf(byte[] src, byte srcCoder, int srcCount, String tgtStr, int fromIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Code shared by String and AbstractStringBuilder to do searches. The\\n     * source is the character array being searched, and the target\\n     * is the string being searched for.\\n     *\\n     * @param   src       the characters being searched.\\n     * @param   srcCoder  the coder of the source string.\\n     * @param   srcCount  length of the source string.\\n     * @param   tgtStr    the characters being searched for.\\n     * @param   fromIndex the index to begin searching from.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int lastIndexOf(String str)", "label": "public int lastIndexOf(String str)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index within this string of the last occurrence of the\\n     * specified substring.  The last occurrence of the empty string \"\"\\n     * is considered to occur at the index value {@code this.length()}.\\n     *\\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\\n     * \u003cpre\u003e{@code\\n     * this.startsWith(str, k)\\n     * }\u003c/pre\u003e\\n     * If no such value of {@code k} exists, then {@code -1} is returned.\\n     *\\n     * @param   str   the substring to search for.\\n     * @return  the index of the last occurrence of the specified substring,\\n     *          or {@code -1} if there is no such occurrence.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int lastIndexOf(String str, int fromIndex)", "label": "public int lastIndexOf(String str, int fromIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index within this string of the last occurrence of the\\n     * specified substring, searching backward starting at the specified index.\\n     *\\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\\n     * \u003cpre\u003e{@code\\n     *     k \u003c= Math.min(fromIndex, this.length()) \u0026\u0026\\n     *                   this.startsWith(str, k)\\n     * }\u003c/pre\u003e\\n     * If no such value of {@code k} exists, then {@code -1} is returned.\\n     *\\n     * @param   str         the substring to search for.\\n     * @param   fromIndex   the index to start the search from.\\n     * @return  the index of the last occurrence of the specified substring,\\n     *          searching backward from the specified index,\\n     *          or {@code -1} if there is no such occurrence.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static int lastIndexOf(String source, String target, int fromIndex)", "label": "private static int lastIndexOf(String source, String target, int fromIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The source is the string being searched, and the target is the string being searched for.\\n     *\\n     * @param   source       the characters being searched.\\n     * @param   target       the characters being searched for.\\n     * @param   fromIndex    the index to begin searching from.\\n     \u0027}"}, {"color": "#97c2fc", "id": " static int lastIndexOf(byte[] src, byte srcCoder, int srcCount, String tgtStr, int fromIndex)", "label": " static int lastIndexOf(byte[] src, byte srcCoder, int srcCount, String tgtStr, int fromIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Code shared by String and AbstractStringBuilder to do searches. The\\n     * source is the character array being searched, and the target\\n     * is the string being searched for.\\n     *\\n     * @param   src         the characters being searched.\\n     * @param   srcCoder    coder handles the mapping between bytes/chars\\n     * @param   srcCount    count of the source string.\\n     * @param   tgtStr      the characters being searched for.\\n     * @param   fromIndex   the index to begin searching from.\\n     \u0027}"}, {"color": "#97c2fc", "id": " static int lastIndexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex)", "label": " static int lastIndexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Code shared by String and StringBuffer to do searches. The\\n     * source is the character array being searched, and the target\\n     * is the string being searched for.\\n     *\\n     * @param   source       the characters being searched.\\n     * @param   sourceOffset offset of the source string.\\n     * @param   sourceCount  count of the source string.\\n     * @param   target       the characters being searched for.\\n     * @param   targetOffset offset of the target string.\\n     * @param   targetCount  count of the target string.\\n     * @param   fromIndex    the index to begin searching from.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String substring(int beginIndex)", "label": "public String substring(int beginIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string that is a substring of this string. The\\n     * substring begins with the character at the specified index and\\n     * extends to the end of this string. \u003cp\u003e\\n     * Examples:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * \"unhappy\".substring(2) returns \"happy\"\\n     * \"Harbison\".substring(3) returns \"bison\"\\n     * \"emptiness\".substring(9) returns \"\" (an empty string)\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @param      beginIndex   the beginning index, inclusive.\\n     * @return     the specified substring.\\n     * @exception  IndexOutOfBoundsException  if\\n     *             {@code beginIndex} is negative or larger than the\\n     *             length of this {@code String} object.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String substring(int beginIndex, int endIndex)", "label": "public String substring(int beginIndex, int endIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string that is a substring of this string. The\\n     * substring begins at the specified {@code beginIndex} and\\n     * extends to the character at index {@code endIndex - 1}.\\n     * Thus the length of the substring is {@code endIndex-beginIndex}.\\n     * \u003cp\u003e\\n     * Examples:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * \"hamburger\".substring(4, 8) returns \"urge\"\\n     * \"smiles\".substring(1, 5) returns \"mile\"\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @param      beginIndex   the beginning index, inclusive.\\n     * @param      endIndex     the ending index, exclusive.\\n     * @return     the specified substring.\\n     * @exception  IndexOutOfBoundsException  if the\\n     *             {@code beginIndex} is negative, or\\n     *             {@code endIndex} is larger than the length of\\n     *             this {@code String} object, or\\n     *             {@code beginIndex} is larger than\\n     *             {@code endIndex}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private native String fastSubstring(int start, int length)", "label": "private native String fastSubstring(int start, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: Native method to access char storage managed by runtime.\u0027}"}, {"color": "#97c2fc", "id": "public CharSequence subSequence(int beginIndex, int endIndex)", "label": "public CharSequence subSequence(int beginIndex, int endIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a character sequence that is a subsequence of this sequence.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form\\n     *\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * str.subSequence(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * behaves in exactly the same way as the invocation\\n     *\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * str.substring(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @apiNote\\n     * This method is defined so that the {@code String} class can implement\\n     * the {@link CharSequence} interface.\\n     *\\n     * @param   beginIndex   the begin index, inclusive.\\n     * @param   endIndex     the end index, exclusive.\\n     * @return  the specified subsequence.\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          if {@code beginIndex} or {@code endIndex} is negative,\\n     *          if {@code endIndex} is greater than {@code length()},\\n     *          or if {@code beginIndex} is greater than {@code endIndex}\\n     *\\n     * @since 1.4\\n     * @spec JSR-51\\n     \u0027}"}, {"color": "#97c2fc", "id": "public native String concat(String str)", "label": "public native String concat(String str)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public String concat(String str) {\\n        if (str.isEmpty()) {\\n            return this;\\n        }\\n        if (coder() == str.coder()) {\\n            byte[] val = this.value;\\n            byte[] oval = str.value;\\n            int len = val.length + oval.length;\\n            byte[] buf = Arrays.copyOf(val, len);\\n            System.arraycopy(oval, 0, buf, val.length, oval.length);\\n            return new String(buf, coder);\\n        }\\n        int len = length();\\n        int olen = str.length();\\n        byte[] buf = StringUTF16.newBytesFor(len + olen);\\n        getBytes(buf, 0, UTF16);\\n        str.getBytes(buf, len, UTF16);\\n        return new String(buf, UTF16);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public String replace(char oldChar, char newChar)", "label": "public String replace(char oldChar, char newChar)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string resulting from replacing all occurrences of\\n     * {@code oldChar} in this string with {@code newChar}.\\n     * \u003cp\u003e\\n     * If the character {@code oldChar} does not occur in the\\n     * character sequence represented by this {@code String} object,\\n     * then a reference to this {@code String} object is returned.\\n     * Otherwise, a {@code String} object is returned that\\n     * represents a character sequence identical to the character sequence\\n     * represented by this {@code String} object, except that every\\n     * occurrence of {@code oldChar} is replaced by an occurrence\\n     * of {@code newChar}.\\n     * \u003cp\u003e\\n     * Examples:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * \"mesquite in your cellar\".replace(\\\u0027e\\\u0027, \\\u0027o\\\u0027)\\n     *         returns \"mosquito in your collar\"\\n     * \"the war of baronets\".replace(\\\u0027r\\\u0027, \\\u0027y\\\u0027)\\n     *         returns \"the way of bayonets\"\\n     * \"sparring with a purple porpoise\".replace(\\\u0027p\\\u0027, \\\u0027t\\\u0027)\\n     *         returns \"starring with a turtle tortoise\"\\n     * \"JonL\".replace(\\\u0027q\\\u0027, \\\u0027x\\\u0027) returns \"JonL\" (no change)\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @param   oldChar   the old character.\\n     * @param   newChar   the new character.\\n     * @return  a string derived from this string by replacing every\\n     *          occurrence of {@code oldChar} with {@code newChar}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private native String doReplace(char oldChar, char newChar)", "label": "private native String doReplace(char oldChar, char newChar)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Implementation of replace(char oldChar, char newChar) called when we found a match.\u0027}"}, {"color": "#97c2fc", "id": "public boolean matches(String regex)", "label": "public boolean matches(String regex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this string matches the given \u003ca\\n     * href=\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form\\n     * \u003ci\u003estr\u003c/i\u003e{@code .matches(}\u003ci\u003eregex\u003c/i\u003e{@code )} yields exactly the\\n     * same result as the expression\\n     *\\n     * \u003cblockquote\u003e\\n     * {@link java.util.regex.Pattern}.{@link java.util.regex.Pattern#matches(String,CharSequence)\\n     * matches(\u003ci\u003eregex\u003c/i\u003e, \u003ci\u003estr\u003c/i\u003e)}\\n     * \u003c/blockquote\u003e\\n     *\\n     * @param   regex\\n     *          the regular expression to which this string is to be matched\\n     *\\n     * @return  {@code true} if, and only if, this string matches the\\n     *          given regular expression\\n     *\\n     * @throws  PatternSyntaxException\\n     *          if the regular expression\\\u0027s syntax is invalid\\n     *\\n     * @see java.util.regex.Pattern\\n     *\\n     * @since 1.4\\n     * @spec JSR-51\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.util.regex.Pattern", "label": "java.util.regex.Pattern", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public static Pattern compile(String regex)", "label": "public static Pattern compile(String regex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Compiles the given regular expression into a pattern.\\n     *\\n     * @param  regex\\n     *         The expression to be compiled\\n     * @return the given regular expression compiled into a pattern\\n     * @throws  PatternSyntaxException\\n     *          If the expression\u0027s syntax is invalid\\n     \"}"}, {"color": "#97c2fc", "id": "public static Pattern compile(String regex, int flags)", "label": "public static Pattern compile(String regex, int flags)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Compiles the given regular expression into a pattern with the given\\n     * flags.\\n     *\\n     * @param  regex\\n     *         The expression to be compiled\\n     *\\n     * @param  flags\\n     *         Match flags, a bit mask that may include\\n     *         {@link #CASE_INSENSITIVE}, {@link #MULTILINE}, {@link #DOTALL},\\n     *         {@link #UNICODE_CASE}, {@link #UNIX_LINES}, {@link #LITERAL},\\n     *         and {@link #COMMENTS}\\n     *\\n     * @return the given regular expression compiled into a pattern with the given flags\\n     * @throws  IllegalArgumentException\\n     *          If bit values other than those corresponding to the defined\\n     *          match flags are set in {@code flags}\\n     *\\n     * @throws  PatternSyntaxException\\n     *          If the expression\u0027s syntax is invalid\\n     \"}"}, {"color": "#97c2fc", "id": "UNIX_LINES", "label": "UNIX_LINES", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "MULTILINE", "label": "MULTILINE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "LITERAL", "label": "LITERAL", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "CASE_INSENSITIVE", "label": "CASE_INSENSITIVE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "UNICODE_CASE", "label": "UNICODE_CASE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "DOTALL", "label": "DOTALL", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "COMMENTS", "label": "COMMENTS", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public String pattern()", "label": "public String pattern()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the regular expression from which this pattern was compiled.\\n     *\\n     * @return  The source of this pattern\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Matcher matcher(CharSequence input)", "label": "public Matcher matcher(CharSequence input)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a matcher that will match the given input against this pattern.\\n     *\\n     * @param  input\\n     *         The character sequence to be matched\\n     *\\n     * @return  A new matcher for this pattern\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int flags()", "label": "public int flags()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns this pattern\u0027s match flags.\\n     *\\n     * @return  The match flags specified when this pattern was compiled\\n     \"}"}, {"color": "#97c2fc", "id": "public static boolean matches(String regex, CharSequence input)", "label": "public static boolean matches(String regex, CharSequence input)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Compiles the given regular expression and attempts to match the given\\n     * input against it.\\n     *\\n     * \u003cp\u003e An invocation of this convenience method of the form\\n     *\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * Pattern.matches(regex, input);\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * behaves in exactly the same way as the expression\\n     *\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * Pattern.compile(regex).matcher(input).matches()\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * \u003cp\u003e If a pattern is to be used multiple times, compiling it once and reusing\\n     * it will be more efficient than invoking this method each time.  \u003c/p\u003e\\n     *\\n     * @param  regex\\n     *         The expression to be compiled\\n     *\\n     * @param  input\\n     *         The character sequence to be matched\\n     * @return whether or not the regular expression matches on the input\\n     * @throws  PatternSyntaxException\\n     *          If the expression\u0027s syntax is invalid\\n     \"}"}, {"color": "#97c2fc", "id": "public String[] split(CharSequence input, int limit)", "label": "public String[] split(CharSequence input, int limit)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Splits the given input sequence around matches of this pattern.\\n     *\\n     * \u003cp\u003e The array returned by this method contains each substring of the\\n     * input sequence that is terminated by another subsequence that matches\\n     * this pattern or is terminated by the end of the input sequence.  The\\n     * substrings in the array are in the order in which they occur in the\\n     * input. If this pattern does not match any subsequence of the input then\\n     * the resulting array has just one element, namely the input sequence in\\n     * string form.\\n     *\\n     * \u003cp\u003e When there is a positive-width match at the beginning of the input\\n     * sequence then an empty leading substring is included at the beginning\\n     * of the resulting array. A zero-width match at the beginning however\\n     * can only produce such an empty leading substring for apps running on or\\n     * targeting API versions \u003c= 28.\\n     *\\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\\n     * pattern is applied and therefore affects the length of the resulting\\n     * array.\\n     * \u003cul\u003e\\n     *    \u003cli\u003e\u003cp\u003e\\n     *    If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\\\u0027s length will be\\n     *    no greater than \u003ci\u003elimit\u003c/i\u003e, and the array\\\u0027s last entry will contain\\n     *    all input beyond the last matched delimiter.\u003c/p\u003e\u003c/li\u003e\\n     *\\n     *    \u003cli\u003e\u003cp\u003e\\n     *    If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\\n     *    many times as possible, the array can have any length, and trailing\\n     *    empty strings will be discarded.\u003c/p\u003e\u003c/li\u003e\\n     *\\n     *    \u003cli\u003e\u003cp\u003e\\n     *    If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\\n     *    as many times as possible and the array can have any length.\u003c/p\u003e\u003c/li\u003e\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003e The input {@code \"boo:and:foo\"}, for example, yields the following\\n     * results with these parameters:\\n     *\\n     * \u003ctable class=\"plain\" style=\"margin-left:2em;\"\u003e\\n     * \u003ccaption style=\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\\n     * \u003cthead\u003e\\n     * \u003ctr\u003e\\n     *     \u003cth scope=\"col\"\u003eRegex\u003c/th\u003e\\n     *     \u003cth scope=\"col\"\u003eLimit\u003c/th\u003e\\n     *     \u003cth scope=\"col\"\u003eResult\u003c/th\u003e\\n     * \u003c/tr\u003e\\n     * \u003c/thead\u003e\\n     * \u003ctbody\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\" rowspan=\"3\" style=\"font-weight:normal\"\u003e:\u003c/th\u003e\\n     *     \u003cth scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"boo\", \"and:foo\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003c!-- : --\u003e\\n     *     \u003cth scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003c!-- : --\u003e\\n     *     \u003cth scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\" rowspan=\"3\" style=\"font-weight:normal\"\u003eo\u003c/th\u003e\\n     *     \u003cth scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003c!-- o --\u003e\\n     *     \u003cth scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003c!-- o --\u003e\\n     *     \u003cth scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003c/tbody\u003e\\n     * \u003c/table\u003e\\n     *\\n     * @param  input\\n     *         The character sequence to be split\\n     *\\n     * @param  limit\\n     *         The result threshold, as described above\\n     *\\n     * @return  The array of strings computed by splitting the input\\n     *          around matches of this pattern\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String[] split(CharSequence input)", "label": "public String[] split(CharSequence input)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Splits the given input sequence around matches of this pattern.\\n     *\\n     * \u003cp\u003e This method works as if by invoking the two-argument {@link\\n     * #split(java.lang.CharSequence, int) split} method with the given input\\n     * sequence and a limit argument of zero.  Trailing empty strings are\\n     * therefore not included in the resulting array. \u003c/p\u003e\\n     *\\n     * \u003cp\u003e The input {@code \"boo:and:foo\"}, for example, yields the following\\n     * results with these expressions:\\n     *\\n     * \u003ctable class=\"plain\" style=\"margin-left:2em\"\u003e\\n     * \u003ccaption style=\"display:none\"\u003eSplit examples showing regex and result\u003c/caption\u003e\\n     * \u003cthead\u003e\\n     * \u003ctr\u003e\\n     *  \u003cth scope=\"col\"\u003eRegex\u003c/th\u003e\\n     *  \u003cth scope=\"col\"\u003eResult\u003c/th\u003e\\n     * \u003c/tr\u003e\\n     * \u003c/thead\u003e\\n     * \u003ctbody\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\" style=\"text-weight:normal\"\u003e:\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\" style=\"text-weight:normal\"\u003eo\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003c/tbody\u003e\\n     * \u003c/table\u003e\\n     *\\n     *\\n     * @param  input\\n     *         The character sequence to be split\\n     *\\n     * @return  The array of strings computed by splitting the input\\n     *          around matches of this pattern\\n     \u0027}"}, {"color": "#97c2fc", "id": "split(java.lang.CharSequence", "label": "split(java.lang.CharSequence", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static String quote(String s)", "label": "public static String quote(String s)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a literal pattern {@code String} for the specified\\n     * {@code String}.\\n     *\\n     * \u003cp\u003eThis method produces a {@code String} that can be used to\\n     * create a {@code Pattern} that would match the string\\n     * {@code s} as if it were a literal pattern.\u003c/p\u003e Metacharacters\\n     * or escape sequences in the input sequence will be given no special\\n     * meaning.\\n     *\\n     * @param  s The string to be literalized\\n     * @return  A literal string replacement\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException", "label": "private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Recompile the Pattern instance from a stream.  The original pattern\\n     * string is read in and the object tree is recompiled from it.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void compile() throws PatternSyntaxException", "label": "private void compile() throws PatternSyntaxException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Use native implementation instead of \u003e 3000 lines of helper methods.\u0027}"}, {"color": "#97c2fc", "id": "public Predicate\u003cString\u003e asPredicate()", "label": "public Predicate\u003cString\u003e asPredicate()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a predicate that tests if this pattern is found in a given input\\n     * string.\\n     *\\n     * @apiNote\\n     * This method creates a predicate that behaves as if it creates a matcher\\n     * from the input sequence and then calls {@code find}, for example a\\n     * predicate of the form:\\n     * \u003cpre\u003e{@code\\n     *   s -\u003e matcher(s).find();\\n     * }\u003c/pre\u003e\\n     *\\n     * @return  The predicate which can be used for finding a match on a\\n     *          subsequence of a string\\n     * @since   1.8\\n     * @see     Matcher#find\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Predicate\u003cString\u003e asMatchPredicate()", "label": "public Predicate\u003cString\u003e asMatchPredicate()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a predicate that tests if this pattern matches a given input string.\\n     *\\n     * @apiNote\\n     * This method creates a predicate that behaves as if it creates a matcher\\n     * from the input sequence and then calls {@code matches}, for example a\\n     * predicate of the form:\\n     * \u003cpre\u003e{@code\\n     *   s -\u003e matcher(s).matches();\\n     * }\u003c/pre\u003e\\n     *\\n     * @return  The predicate which can be used for matching an input string\\n     *          against this pattern.\\n     * @since   11\\n     * @see     Matcher#matches\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Stream\u003cString\u003e splitAsStream(final CharSequence input)", "label": "public Stream\u003cString\u003e splitAsStream(final CharSequence input)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a stream from the given input sequence around matches of this\\n     * pattern.\\n     *\\n     * \u003cp\u003e The stream returned by this method contains each substring of the\\n     * input sequence that is terminated by another subsequence that matches\\n     * this pattern or is terminated by the end of the input sequence.  The\\n     * substrings in the stream are in the order in which they occur in the\\n     * input. Trailing empty strings will be discarded and not encountered in\\n     * the stream.\\n     *\\n     * \u003cp\u003e If this pattern does not match any subsequence of the input then\\n     * the resulting stream has just one element, namely the input sequence in\\n     * string form.\\n     *\\n     * \u003cp\u003e When there is a positive-width match at the beginning of the input\\n     * sequence then an empty leading substring is included at the beginning\\n     * of the stream. A zero-width match at the beginning however never produces\\n     * such empty leading substring.\\n     *\\n     * \u003cp\u003e If the input sequence is mutable, it must remain constant during the\\n     * execution of the terminal stream operation.  Otherwise, the result of the\\n     * terminal stream operation is undefined.\\n     *\\n     * @param   input\\n     *          The character sequence to be split\\n     *\\n     * @return  The stream of strings computed by splitting the input\\n     *          around matches of this pattern\\n     * @see     #split(CharSequence)\\n     * @since   1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean contains(CharSequence s)", "label": "public boolean contains(CharSequence s)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns true if and only if this string contains the specified\\n     * sequence of char values.\\n     *\\n     * @param s the sequence to search for\\n     * @return true if this string contains {@code s}, false otherwise\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String replaceFirst(String regex, String replacement)", "label": "public String replaceFirst(String regex, String replacement)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Replaces the first substring of this string that matches the given \u003ca\\n     * href=\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\\n     * given replacement.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form\\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceFirst(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\\n     * yields exactly the same result as the expression\\n     *\\n     * \u003cblockquote\u003e\\n     * \u003ccode\u003e\\n     * {@link java.util.regex.Pattern}.{@link\\n     * java.util.regex.Pattern#compile compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\\n     * java.util.regex.Matcher#replaceFirst replaceFirst}(\u003ci\u003erepl\u003c/i\u003e)\\n     * \u003c/code\u003e\\n     * \u003c/blockquote\u003e\\n     *\\n     *\u003cp\u003e\\n     * Note that backslashes ({@code \\\\}) and dollar signs ({@code $}) in the\\n     * replacement string may cause the results to be different than if it were\\n     * being treated as a literal replacement string; see\\n     * {@link java.util.regex.Matcher#replaceFirst}.\\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\\n     * meaning of these characters, if desired.\\n     *\\n     * @param   regex\\n     *          the regular expression to which this string is to be matched\\n     * @param   replacement\\n     *          the string to be substituted for the first match\\n     *\\n     * @return  The resulting {@code String}\\n     *\\n     * @throws  PatternSyntaxException\\n     *          if the regular expression\\\u0027s syntax is invalid\\n     *\\n     * @see java.util.regex.Pattern\\n     *\\n     * @since 1.4\\n     * @spec JSR-51\\n     \u0027}"}, {"color": "#97c2fc", "id": "replaceFirst", "label": "replaceFirst", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.util.regex.Matcher", "label": "java.util.regex.Matcher", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public Pattern pattern()", "label": "public Pattern pattern()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the pattern that is interpreted by this matcher.\\n     *\\n     * @return  The pattern for which this matcher was created\\n     \u0027}"}, {"color": "#97c2fc", "id": "public MatchResult toMatchResult()", "label": "public MatchResult toMatchResult()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the match state of this matcher as a {@link MatchResult}.\\n     * The result is unaffected by subsequent operations performed upon this\\n     * matcher.\\n     *\\n     * @return  a {@code MatchResult} with the state of this matcher\\n     * @throws IllegalStateException if no match is found.\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.util.regex.MatchResult", "label": "java.util.regex.MatchResult", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * The result of a match operation.\\n *\\n * \u003cp\u003eThis interface contains query methods used to determine the\\n * results of a match against a regular expression. The match boundaries,\\n * groups and group boundaries can be seen but not modified through\\n * a {@code MatchResult}.\\n *\\n * @author  Michael McCloskey\\n * @see Matcher\\n * @since 1.5\\n \u0027}"}, {"color": "#97c2fc", "id": "public int start()", "label": "public int start()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the start index of the previous match.\\n     *\\n     * @return  The index of the first character matched\\n     *\\n     * @throws  IllegalStateException\\n     *          If no match has yet been attempted,\\n     *          or if the previous match operation failed\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int start(int group)", "label": "public int start(int group)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the start index of the subsequence captured by the given group\\n     * during the previous match operation.\\n     *\\n     * \u003cp\u003e \u003ca href=\"Pattern.html#cg\"\u003eCapturing groups\u003c/a\u003e are indexed from left\\n     * to right, starting at one.  Group zero denotes the entire pattern, so\\n     * the expression \u003ci\u003em.\u003c/i\u003e{@code start(0)} is equivalent to\\n     * \u003ci\u003em.\u003c/i\u003e{@code start()}.  \u003c/p\u003e\\n     *\\n     * @param  group\\n     *         The index of a capturing group in this matcher\\\u0027s pattern\\n     *\\n     * @return  The index of the first character captured by the group,\\n     *          or {@code -1} if the match was successful but the group\\n     *          itself did not match anything\\n     *\\n     * @throws  IllegalStateException\\n     *          If no match has yet been attempted,\\n     *          or if the previous match operation failed\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If there is no capturing group in the pattern\\n     *          with the given index\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int end()", "label": "public int end()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the offset after the last character matched.\\n     *\\n     * @return  The offset after the last character matched\\n     *\\n     * @throws  IllegalStateException\\n     *          If no match has yet been attempted,\\n     *          or if the previous match operation failed\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int end(int group)", "label": "public int end(int group)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the offset after the last character of the subsequence\\n     * captured by the given group during the previous match operation.\\n     *\\n     * \u003cp\u003e \u003ca href=\"Pattern.html#cg\"\u003eCapturing groups\u003c/a\u003e are indexed from left\\n     * to right, starting at one.  Group zero denotes the entire pattern, so\\n     * the expression \u003ci\u003em.\u003c/i\u003e{@code end(0)} is equivalent to\\n     * \u003ci\u003em.\u003c/i\u003e{@code end()}.  \u003c/p\u003e\\n     *\\n     * @param  group\\n     *         The index of a capturing group in this matcher\\\u0027s pattern\\n     *\\n     * @return  The offset after the last character captured by the group,\\n     *          or {@code -1} if the match was successful\\n     *          but the group itself did not match anything\\n     *\\n     * @throws  IllegalStateException\\n     *          If no match has yet been attempted,\\n     *          or if the previous match operation failed\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If there is no capturing group in the pattern\\n     *          with the given index\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String group()", "label": "public String group()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the input subsequence matched by the previous match.\\n     *\\n     * \u003cp\u003e For a matcher \u003ci\u003em\u003c/i\u003e with input sequence \u003ci\u003es\u003c/i\u003e,\\n     * the expressions \u003ci\u003em.\u003c/i\u003e{@code group()} and\\n     * \u003ci\u003es.\u003c/i\u003e{@code substring(}\u003ci\u003em.\u003c/i\u003e{@code start(),}\u0026nbsp;\u003ci\u003em.\u003c/i\u003e\\n     * {@code end())} are equivalent.  \u003c/p\u003e\\n     *\\n     * \u003cp\u003e Note that some patterns, for example {@code a*}, match the empty\\n     * string.  This method will return the empty string when the pattern\\n     * successfully matches the empty string in the input.  \u003c/p\u003e\\n     *\\n     * @return The (possibly empty) subsequence matched by the previous match,\\n     *         in string form\\n     *\\n     * @throws  IllegalStateException\\n     *          If no match has yet been attempted,\\n     *          or if the previous match operation failed\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String group(int group)", "label": "public String group(int group)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the input subsequence captured by the given group during the\\n     * previous match operation.\\n     *\\n     * \u003cp\u003e For a matcher \u003ci\u003em\u003c/i\u003e, input sequence \u003ci\u003es\u003c/i\u003e, and group index\\n     * \u003ci\u003eg\u003c/i\u003e, the expressions \u003ci\u003em.\u003c/i\u003e{@code group(}\u003ci\u003eg\u003c/i\u003e{@code )} and\\n     * \u003ci\u003es.\u003c/i\u003e{@code substring(}\u003ci\u003em.\u003c/i\u003e{@code start(}\u003ci\u003eg\u003c/i\u003e{@code\\n     * ),}\u0026nbsp;\u003ci\u003em.\u003c/i\u003e{@code end(}\u003ci\u003eg\u003c/i\u003e{@code ))}\\n     * are equivalent.  \u003c/p\u003e\\n     *\\n     * \u003cp\u003e \u003ca href=\"Pattern.html#cg\"\u003eCapturing groups\u003c/a\u003e are indexed from left\\n     * to right, starting at one.  Group zero denotes the entire pattern, so\\n     * the expression {@code m.group(0)} is equivalent to {@code m.group()}.\\n     * \u003c/p\u003e\\n     *\\n     * \u003cp\u003e If the match was successful but the group specified failed to match\\n     * any part of the input sequence, then {@code null} is returned. Note\\n     * that some groups, for example {@code (a*)}, match the empty string.\\n     * This method will return the empty string when such a group successfully\\n     * matches the empty string in the input.  \u003c/p\u003e\\n     *\\n     * @param  group\\n     *         The index of a capturing group in this matcher\\\u0027s pattern\\n     *\\n     * @return  The (possibly empty) subsequence captured by the group\\n     *          during the previous match, or {@code null} if the group\\n     *          failed to match part of the input\\n     *\\n     * @throws  IllegalStateException\\n     *          If no match has yet been attempted,\\n     *          or if the previous match operation failed\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If there is no capturing group in the pattern\\n     *          with the given index\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int groupCount()", "label": "public int groupCount()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the number of capturing groups in this matcher\u0027s pattern.\\n     *\\n     * \u003cp\u003e Group zero denotes the entire pattern by convention. It is not\\n     * included in this count.\\n     *\\n     * \u003cp\u003e Any non-negative integer smaller than or equal to the value\\n     * returned by this method is guaranteed to be a valid group index for\\n     * this matcher.  \u003c/p\u003e\\n     *\\n     * @return The number of capturing groups in this matcher\u0027s pattern\\n     \"}"}, {"color": "#97c2fc", "id": "public Matcher usePattern(Pattern newPattern)", "label": "public Matcher usePattern(Pattern newPattern)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Changes the {@code Pattern} that this {@code Matcher} uses to\\n     * find matches with.\\n     *\\n     * \u003cp\u003e This method causes this matcher to lose information\\n     * about the groups of the last match that occurred. The\\n     * matcher\u0027s position in the input is maintained and its\\n     * last append position is unaffected.\u003c/p\u003e\\n     *\\n     * @param  newPattern\\n     *         The new pattern used by this matcher\\n     * @return  This matcher\\n     * @throws  IllegalArgumentException\\n     *          If newPattern is {@code null}\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": "public Matcher reset()", "label": "public Matcher reset()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Resets this matcher.\\n     *\\n     * \u003cp\u003e Resetting a matcher discards all of its explicit state information\\n     * and sets its append position to zero. The matcher\u0027s region is set to the\\n     * default region, which is its entire character sequence. The anchoring\\n     * and transparency of this matcher\u0027s region boundaries are unaffected.\\n     *\\n     * @return  This matcher\\n     \"}"}, {"color": "#97c2fc", "id": "public Matcher reset(CharSequence input)", "label": "public Matcher reset(CharSequence input)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Resets this matcher with a new input sequence.\\n     *\\n     * \u003cp\u003e Resetting a matcher discards all of its explicit state information\\n     * and sets its append position to zero.  The matcher\u0027s region is set to\\n     * the default region, which is its entire character sequence.  The\\n     * anchoring and transparency of this matcher\u0027s region boundaries are\\n     * unaffected.\\n     *\\n     * @param  input\\n     *         The new input character sequence\\n     *\\n     * @return  This matcher\\n     \"}"}, {"color": "#97c2fc", "id": "public int start(String name)", "label": "public int start(String name)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the start index of the subsequence captured by the given\\n     * \u003ca href=\"Pattern.html#groupname\"\u003enamed-capturing group\u003c/a\u003e during the\\n     * previous match operation.\\n     *\\n     * @param  name\\n     *         The name of a named-capturing group in this matcher\\\u0027s pattern\\n     *\\n     * @return  The index of the first character captured by the group,\\n     *          or {@code -1} if the match was successful but the group\\n     *          itself did not match anything\\n     *\\n     * @throws  IllegalStateException\\n     *          If no match has yet been attempted,\\n     *          or if the previous match operation failed\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If there is no capturing group in the pattern\\n     *          with the given name\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int end(String name)", "label": "public int end(String name)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the offset after the last character of the subsequence\\n     * captured by the given \u003ca href=\"Pattern.html#groupname\"\u003enamed-capturing\\n     * group\u003c/a\u003e during the previous match operation.\\n     *\\n     * @param  name\\n     *         The name of a named-capturing group in this matcher\\\u0027s pattern\\n     *\\n     * @return  The offset after the last character captured by the group,\\n     *          or {@code -1} if the match was successful\\n     *          but the group itself did not match anything\\n     *\\n     * @throws  IllegalStateException\\n     *          If no match has yet been attempted,\\n     *          or if the previous match operation failed\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If there is no capturing group in the pattern\\n     *          with the given name\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String group(String name)", "label": "public String group(String name)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the input subsequence captured by the given\\n     * \u003ca href=\"Pattern.html#groupname\"\u003enamed-capturing group\u003c/a\u003e during the\\n     * previous match operation.\\n     *\\n     * \u003cp\u003e If the match was successful but the group specified failed to match\\n     * any part of the input sequence, then {@code null} is returned. Note\\n     * that some groups, for example {@code (a*)}, match the empty string.\\n     * This method will return the empty string when such a group successfully\\n     * matches the empty string in the input.  \u003c/p\u003e\\n     *\\n     * @param  name\\n     *         The name of a named-capturing group in this matcher\\\u0027s pattern\\n     *\\n     * @return  The (possibly empty) subsequence captured by the named group\\n     *          during the previous match, or {@code null} if the group\\n     *          failed to match part of the input\\n     *\\n     * @throws  IllegalStateException\\n     *          If no match has yet been attempted,\\n     *          or if the previous match operation failed\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If there is no capturing group in the pattern\\n     *          with the given name\\n     * @since 1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean matches()", "label": "public boolean matches()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Attempts to match the entire region against the pattern.\\n     *\\n     * \u003cp\u003e If the match succeeds then more information can be obtained via the\\n     * {@code start}, {@code end}, and {@code group} methods.  \u003c/p\u003e\\n     *\\n     * @return  {@code true} if, and only if, the entire region sequence\\n     *          matches this matcher\u0027s pattern\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean find()", "label": "public boolean find()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Attempts to find the next subsequence of the input sequence that matches\\n     * the pattern.\\n     *\\n     * \u003cp\u003e This method starts at the beginning of this matcher\u0027s region, or, if\\n     * a previous invocation of the method was successful and the matcher has\\n     * not since been reset, at the first character not matched by the previous\\n     * match.\\n     *\\n     * \u003cp\u003e If the match succeeds then more information can be obtained via the\\n     * {@code start}, {@code end}, and {@code group} methods.  \u003c/p\u003e\\n     *\\n     * @return  {@code true} if, and only if, a subsequence of the input\\n     *          sequence matches this matcher\u0027s pattern\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean find(int start)", "label": "public boolean find(int start)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Resets this matcher and then attempts to find the next subsequence of\\n     * the input sequence that matches the pattern, starting at the specified\\n     * index.\\n     *\\n     * \u003cp\u003e If the match succeeds then more information can be obtained via the\\n     * {@code start}, {@code end}, and {@code group} methods, and subsequent\\n     * invocations of the {@link #find()} method will start at the first\\n     * character not matched by this match.  \u003c/p\u003e\\n     *\\n     * @param start the index to start searching for a match\\n     * @throws  IndexOutOfBoundsException\\n     *          If start is less than zero or if start is greater than the\\n     *          length of the input sequence.\\n     *\\n     * @return  {@code true} if, and only if, a subsequence of the input\\n     *          sequence starting at the given index matches this matcher\u0027s\\n     *          pattern\\n     \"}"}, {"color": "#97c2fc", "id": "find()", "label": "find()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public boolean lookingAt()", "label": "public boolean lookingAt()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Attempts to match the input sequence, starting at the beginning of the\\n     * region, against the pattern.\\n     *\\n     * \u003cp\u003e Like the {@link #matches matches} method, this method always starts\\n     * at the beginning of the region; unlike that method, it does not\\n     * require that the entire region be matched.\\n     *\\n     * \u003cp\u003e If the match succeeds then more information can be obtained via the\\n     * {@code start}, {@code end}, and {@code group} methods.  \u003c/p\u003e\\n     *\\n     * @return  {@code true} if, and only if, a prefix of the input\\n     *          sequence matches this matcher\u0027s pattern\\n     \"}"}, {"color": "#97c2fc", "id": "matches", "label": "matches", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static String quoteReplacement(String s)", "label": "public static String quoteReplacement(String s)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a literal replacement {@code String} for the specified\\n     * {@code String}.\\n     *\\n     * This method produces a {@code String} that will work\\n     * as a literal replacement {@code s} in the\\n     * {@code appendReplacement} method of the {@link Matcher} class.\\n     * The {@code String} produced will match the sequence of characters\\n     * in {@code s} treated as a literal sequence. Slashes (\u0027\\\\\u0027) and\\n     * dollar signs (\u0027$\u0027) will be given no special meaning.\\n     *\\n     * @param  s The string to be literalized\\n     * @return  A literal string replacement\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": "public Matcher appendReplacement(StringBuffer sb, String replacement)", "label": "public Matcher appendReplacement(StringBuffer sb, String replacement)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Implements a non-terminal append-and-replace step.\\n     *\\n     * \u003cp\u003e This method performs the following actions: \u003c/p\u003e\\n     *\\n     * \u003col\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e It reads characters from the input sequence, starting at the\\n     *   append position, and appends them to the given string buffer.  It\\n     *   stops after reading the last character preceding the previous match,\\n     *   that is, the character at index {@link\\n     *   #start()}\u0026nbsp;{@code -}\u0026nbsp;{@code 1}.  \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e It appends the given replacement string to the string buffer.\\n     *   \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e It sets the append position of this matcher to the index of\\n     *   the last character matched, plus one, that is, to {@link #end()}.\\n     *   \u003c/p\u003e\u003c/li\u003e\\n     *\\n     * \u003c/ol\u003e\\n     *\\n     * \u003cp\u003e The replacement string may contain references to subsequences\\n     * captured during the previous match: Each occurrence of\\n     * \u003ccode\u003e${\u003c/code\u003e\u003ci\u003ename\u003c/i\u003e\u003ccode\u003e}\u003c/code\u003e or {@code $}\u003ci\u003eg\u003c/i\u003e\\n     * will be replaced by the result of evaluating the corresponding\\n     * {@link #group(String) group(name)} or {@link #group(int) group(g)}\\n     * respectively. For {@code $}\u003ci\u003eg\u003c/i\u003e,\\n     * the first number after the {@code $} is always treated as part of\\n     * the group reference. Subsequent numbers are incorporated into g if\\n     * they would form a legal group reference. Only the numerals \\\u00270\\\u0027\\n     * through \\\u00279\\\u0027 are considered as potential components of the group\\n     * reference. If the second group matched the string {@code \"foo\"}, for\\n     * example, then passing the replacement string {@code \"$2bar\"} would\\n     * cause {@code \"foobar\"} to be appended to the string buffer. A dollar\\n     * sign ({@code $}) may be included as a literal in the replacement\\n     * string by preceding it with a backslash ({@code \\\\$}).\\n     *\\n     * \u003cp\u003e Note that backslashes ({@code \\\\}) and dollar signs ({@code $}) in\\n     * the replacement string may cause the results to be different than if it\\n     * were being treated as a literal replacement string. Dollar signs may be\\n     * treated as references to captured subsequences as described above, and\\n     * backslashes are used to escape literal characters in the replacement\\n     * string.\\n     *\\n     * \u003cp\u003e This method is intended to be used in a loop together with the\\n     * {@link #appendTail(StringBuffer) appendTail} and {@link #find() find}\\n     * methods.  The following code, for example, writes {@code one dog two dogs\\n     * in the yard} to the standard-output stream: \u003c/p\u003e\\n     *\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * Pattern p = Pattern.compile(\"cat\");\\n     * Matcher m = p.matcher(\"one cat two cats in the yard\");\\n     * StringBuffer sb = new StringBuffer();\\n     * while (m.find()) {\\n     *     m.appendReplacement(sb, \"dog\");\\n     * }\\n     * m.appendTail(sb);\\n     * System.out.println(sb.toString());\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @param  sb\\n     *         The target string buffer\\n     *\\n     * @param  replacement\\n     *         The replacement string\\n     *\\n     * @return  This matcher\\n     *\\n     * @throws  IllegalStateException\\n     *          If no match has yet been attempted,\\n     *          or if the previous match operation failed\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the replacement string refers to a named-capturing\\n     *          group that does not exist in the pattern\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If the replacement string refers to a capturing group\\n     *          that does not exist in the pattern\\n     \u0027}"}, {"color": "#97c2fc", "id": "group(String)", "label": "group(String)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "start()", "label": "start()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "end()", "label": "end()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "appendTail(StringBuffer)", "label": "appendTail(StringBuffer)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "group(int)", "label": "group(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public Matcher appendReplacement(StringBuilder sb, String replacement)", "label": "public Matcher appendReplacement(StringBuilder sb, String replacement)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Implements a non-terminal append-and-replace step.\\n     *\\n     * \u003cp\u003e This method performs the following actions: \u003c/p\u003e\\n     *\\n     * \u003col\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e It reads characters from the input sequence, starting at the\\n     *   append position, and appends them to the given string builder.  It\\n     *   stops after reading the last character preceding the previous match,\\n     *   that is, the character at index {@link\\n     *   #start()}\u0026nbsp;{@code -}\u0026nbsp;{@code 1}.  \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e It appends the given replacement string to the string builder.\\n     *   \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e It sets the append position of this matcher to the index of\\n     *   the last character matched, plus one, that is, to {@link #end()}.\\n     *   \u003c/p\u003e\u003c/li\u003e\\n     *\\n     * \u003c/ol\u003e\\n     *\\n     * \u003cp\u003e The replacement string may contain references to subsequences\\n     * captured during the previous match: Each occurrence of\\n     * {@code $}\u003ci\u003eg\u003c/i\u003e will be replaced by the result of\\n     * evaluating {@link #group(int) group}{@code (}\u003ci\u003eg\u003c/i\u003e{@code )}.\\n     * The first number after the {@code $} is always treated as part of\\n     * the group reference. Subsequent numbers are incorporated into g if\\n     * they would form a legal group reference. Only the numerals \\\u00270\\\u0027\\n     * through \\\u00279\\\u0027 are considered as potential components of the group\\n     * reference. If the second group matched the string {@code \"foo\"}, for\\n     * example, then passing the replacement string {@code \"$2bar\"} would\\n     * cause {@code \"foobar\"} to be appended to the string builder. A dollar\\n     * sign ({@code $}) may be included as a literal in the replacement\\n     * string by preceding it with a backslash ({@code \\\\$}).\\n     *\\n     * \u003cp\u003e Note that backslashes ({@code \\\\}) and dollar signs ({@code $}) in\\n     * the replacement string may cause the results to be different than if it\\n     * were being treated as a literal replacement string. Dollar signs may be\\n     * treated as references to captured subsequences as described above, and\\n     * backslashes are used to escape literal characters in the replacement\\n     * string.\\n     *\\n     * \u003cp\u003e This method is intended to be used in a loop together with the\\n     * {@link #appendTail(StringBuilder) appendTail} and\\n     * {@link #find() find} methods. The following code, for example, writes\\n     * {@code one dog two dogs in the yard} to the standard-output stream: \u003c/p\u003e\\n     *\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * Pattern p = Pattern.compile(\"cat\");\\n     * Matcher m = p.matcher(\"one cat two cats in the yard\");\\n     * StringBuilder sb = new StringBuilder();\\n     * while (m.find()) {\\n     *     m.appendReplacement(sb, \"dog\");\\n     * }\\n     * m.appendTail(sb);\\n     * System.out.println(sb.toString());\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @param  sb\\n     *         The target string builder\\n     * @param  replacement\\n     *         The replacement string\\n     * @return  This matcher\\n     *\\n     * @throws  IllegalStateException\\n     *          If no match has yet been attempted,\\n     *          or if the previous match operation failed\\n     * @throws  IllegalArgumentException\\n     *          If the replacement string refers to a named-capturing\\n     *          group that does not exist in the pattern\\n     * @throws  IndexOutOfBoundsException\\n     *          If the replacement string refers to a capturing group\\n     *          that does not exist in the pattern\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "appendTail(StringBuilder)", "label": "appendTail(StringBuilder)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public StringBuffer appendTail(StringBuffer sb)", "label": "public StringBuffer appendTail(StringBuffer sb)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Implements a terminal append-and-replace step.\\n     *\\n     * \u003cp\u003e This method reads characters from the input sequence, starting at\\n     * the append position, and appends them to the given string buffer.  It is\\n     * intended to be invoked after one or more invocations of the {@link\\n     * #appendReplacement(StringBuffer, String) appendReplacement} method in\\n     * order to copy the remainder of the input sequence.  \u003c/p\u003e\\n     *\\n     * @param  sb\\n     *         The target string buffer\\n     *\\n     * @return  The target string buffer\\n     \u0027}"}, {"color": "#97c2fc", "id": "appendReplacement(StringBuffer", "label": "appendReplacement(StringBuffer", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public StringBuilder appendTail(StringBuilder sb)", "label": "public StringBuilder appendTail(StringBuilder sb)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Implements a terminal append-and-replace step.\\n     *\\n     * \u003cp\u003e This method reads characters from the input sequence, starting at\\n     * the append position, and appends them to the given string builder.  It is\\n     * intended to be invoked after one or more invocations of the {@link\\n     * #appendReplacement(StringBuilder, String)\\n     * appendReplacement} method in order to copy the remainder of the input\\n     * sequence.  \u003c/p\u003e\\n     *\\n     * @param  sb\\n     *         The target string builder\\n     *\\n     * @return  The target string builder\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "appendReplacement(StringBuilder", "label": "appendReplacement(StringBuilder", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public String replaceAll(String replacement)", "label": "public String replaceAll(String replacement)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Replaces every subsequence of the input sequence that matches the\\n     * pattern with the given replacement string.\\n     *\\n     * \u003cp\u003e This method first resets this matcher.  It then scans the input\\n     * sequence looking for matches of the pattern.  Characters that are not\\n     * part of any match are appended directly to the result string; each match\\n     * is replaced in the result by the replacement string.  The replacement\\n     * string may contain references to captured subsequences as in the {@link\\n     * #appendReplacement appendReplacement} method.\\n     *\\n     * \u003cp\u003e Note that backslashes ({@code \\\\}) and dollar signs ({@code $}) in\\n     * the replacement string may cause the results to be different than if it\\n     * were being treated as a literal replacement string. Dollar signs may be\\n     * treated as references to captured subsequences as described above, and\\n     * backslashes are used to escape literal characters in the replacement\\n     * string.\\n     *\\n     * \u003cp\u003e Given the regular expression {@code a*b}, the input\\n     * {@code \"aabfooaabfooabfoob\"}, and the replacement string\\n     * {@code \"-\"}, an invocation of this method on a matcher for that\\n     * expression would yield the string {@code \"-foo-foo-foo-\"}.\\n     *\\n     * \u003cp\u003e Invoking this method changes this matcher\\\u0027s state.  If the matcher\\n     * is to be used in further matching operations then it should first be\\n     * reset.  \u003c/p\u003e\\n     *\\n     * @param  replacement\\n     *         The replacement string\\n     *\\n     * @return  The string constructed by replacing each matching subsequence\\n     *          by the replacement string, substituting captured subsequences\\n     *          as needed\\n     \u0027}"}, {"color": "#97c2fc", "id": "appendReplacement", "label": "appendReplacement", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public String replaceAll(Function\u003cMatchResult, String\u003e replacer)", "label": "public String replaceAll(Function\u003cMatchResult, String\u003e replacer)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Replaces every subsequence of the input sequence that matches the\\n     * pattern with the result of applying the given replacer function to the\\n     * match result of this matcher corresponding to that subsequence.\\n     * Exceptions thrown by the function are relayed to the caller.\\n     *\\n     * \u003cp\u003e This method first resets this matcher.  It then scans the input\\n     * sequence looking for matches of the pattern.  Characters that are not\\n     * part of any match are appended directly to the result string; each match\\n     * is replaced in the result by the applying the replacer function that\\n     * returns a replacement string.  Each replacement string may contain\\n     * references to captured subsequences as in the {@link #appendReplacement\\n     * appendReplacement} method.\\n     *\\n     * \u003cp\u003e Note that backslashes ({@code \\\\}) and dollar signs ({@code $}) in\\n     * a replacement string may cause the results to be different than if it\\n     * were being treated as a literal replacement string. Dollar signs may be\\n     * treated as references to captured subsequences as described above, and\\n     * backslashes are used to escape literal characters in the replacement\\n     * string.\\n     *\\n     * \u003cp\u003e Given the regular expression {@code dog}, the input\\n     * {@code \"zzzdogzzzdogzzz\"}, and the function\\n     * {@code mr -\u003e mr.group().toUpperCase()}, an invocation of this method on\\n     * a matcher for that expression would yield the string\\n     * {@code \"zzzDOGzzzDOGzzz\"}.\\n     *\\n     * \u003cp\u003e Invoking this method changes this matcher\\\u0027s state.  If the matcher\\n     * is to be used in further matching operations then it should first be\\n     * reset.  \u003c/p\u003e\\n     *\\n     * \u003cp\u003e The replacer function should not modify this matcher\\\u0027s state during\\n     * replacement.  This method will, on a best-effort basis, throw a\\n     * {@link java.util.ConcurrentModificationException} if such modification is\\n     * detected.\\n     *\\n     * \u003cp\u003e The state of each match result passed to the replacer function is\\n     * guaranteed to be constant only for the duration of the replacer function\\n     * call and only if the replacer function does not modify this matcher\\\u0027s\\n     * state.\\n     *\\n     * @implNote\\n     * This implementation applies the replacer function to this matcher, which\\n     * is an instance of {@code MatchResult}.\\n     *\\n     * @param  replacer\\n     *         The function to be applied to the match result of this matcher\\n     *         that returns a replacement string.\\n     * @return  The string constructed by replacing each matching subsequence\\n     *          with the result of applying the replacer function to that\\n     *          matched subsequence, substituting captured subsequences as\\n     *          needed.\\n     * @throws NullPointerException if the replacer function is null\\n     * @throws ConcurrentModificationException if it is detected, on a\\n     *         best-effort basis, that the replacer function modified this\\n     *         matcher\\\u0027s state\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "appendReplacementappendReplacement", "label": "appendReplacementappendReplacement", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.util.ConcurrentModificationException", "label": "java.util.ConcurrentModificationException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * This exception may be thrown by methods that have detected concurrent\\n * modification of an object when such modification is not permissible.\\n * \u003cp\u003e\\n * For example, it is not generally permissible for one thread to modify a Collection\\n * while another thread is iterating over it.  In general, the results of the\\n * iteration are undefined under these circumstances.  Some Iterator\\n * implementations (including those of all the general purpose collection implementations\\n * provided by the JRE) may choose to throw this exception if this behavior is\\n * detected.  Iterators that do this are known as \u003ci\u003efail-fast\u003c/i\u003e iterators,\\n * as they fail quickly and cleanly, rather that risking arbitrary,\\n * non-deterministic behavior at an undetermined time in the future.\\n * \u003cp\u003e\\n * Note that this exception does not always indicate that an object has\\n * been concurrently modified by a \u003ci\u003edifferent\u003c/i\u003e thread.  If a single\\n * thread issues a sequence of method invocations that violates the\\n * contract of an object, the object may throw this exception.  For\\n * example, if a thread modifies a collection directly while it is\\n * iterating over the collection with a fail-fast iterator, the iterator\\n * will throw this exception.\\n *\\n * \u003cp\u003eNote that fail-fast behavior cannot be guaranteed as it is, generally\\n * speaking, impossible to make any hard guarantees in the presence of\\n * unsynchronized concurrent modification.  Fail-fast operations\\n * throw {@code ConcurrentModificationException} on a best-effort basis.\\n * Therefore, it would be wrong to write a program that depended on this\\n * exception for its correctness: \u003ci\u003e{@code ConcurrentModificationException}\\n * should be used only to detect bugs.\u003c/i\u003e\\n *\\n * @author  Josh Bloch\\n * @see     Collection\\n * @see     Iterator\\n * @see     Spliterator\\n * @see     ListIterator\\n * @see     Vector\\n * @see     LinkedList\\n * @see     HashSet\\n * @see     Hashtable\\n * @see     TreeMap\\n * @see     AbstractList\\n * @since   1.2\\n \u0027}"}, {"color": "#97c2fc", "id": "public Stream\u003cMatchResult\u003e results()", "label": "public Stream\u003cMatchResult\u003e results()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a stream of match results for each subsequence of the input\\n     * sequence that matches the pattern.  The match results occur in the\\n     * same order as the matching subsequences in the input sequence.\\n     *\\n     * \u003cp\u003e Each match result is produced as if by {@link #toMatchResult()}.\\n     *\\n     * \u003cp\u003e This method does not reset this matcher.  Matching starts on\\n     * initiation of the terminal stream operation either at the beginning of\\n     * this matcher\u0027s region, or, if the matcher has not since been reset, at\\n     * the first character not matched by a previous match.\\n     *\\n     * \u003cp\u003e If the matcher is to be used for further matching operations after\\n     * the terminal stream operation completes then it should be first reset.\\n     *\\n     * \u003cp\u003e This matcher\u0027s state should not be modified during execution of the\\n     * returned stream\u0027s pipeline.  The returned stream\u0027s source\\n     * {@code Spliterator} is \u003cem\u003efail-fast\u003c/em\u003e and will, on a best-effort\\n     * basis, throw a {@link java.util.ConcurrentModificationException} if such\\n     * modification is detected.\\n     *\\n     * @return a sequential stream of match results.\\n     * @since 9\\n     \"}"}, {"color": "#97c2fc", "id": "toMatchResult()", "label": "toMatchResult()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public String replaceFirst(String replacement)", "label": "public String replaceFirst(String replacement)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Replaces the first subsequence of the input sequence that matches the\\n     * pattern with the given replacement string.\\n     *\\n     * \u003cp\u003e This method first resets this matcher.  It then scans the input\\n     * sequence looking for a match of the pattern.  Characters that are not\\n     * part of the match are appended directly to the result string; the match\\n     * is replaced in the result by the replacement string.  The replacement\\n     * string may contain references to captured subsequences as in the {@link\\n     * #appendReplacement appendReplacement} method.\\n     *\\n     * \u003cp\u003eNote that backslashes ({@code \\\\}) and dollar signs ({@code $}) in\\n     * the replacement string may cause the results to be different than if it\\n     * were being treated as a literal replacement string. Dollar signs may be\\n     * treated as references to captured subsequences as described above, and\\n     * backslashes are used to escape literal characters in the replacement\\n     * string.\\n     *\\n     * \u003cp\u003e Given the regular expression {@code dog}, the input\\n     * {@code \"zzzdogzzzdogzzz\"}, and the replacement string\\n     * {@code \"cat\"}, an invocation of this method on a matcher for that\\n     * expression would yield the string {@code \"zzzcatzzzdogzzz\"}.  \u003c/p\u003e\\n     *\\n     * \u003cp\u003e Invoking this method changes this matcher\\\u0027s state.  If the matcher\\n     * is to be used in further matching operations then it should first be\\n     * reset.  \u003c/p\u003e\\n     *\\n     * @param  replacement\\n     *         The replacement string\\n     * @return  The string constructed by replacing the first matching\\n     *          subsequence by the replacement string, substituting captured\\n     *          subsequences as needed\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String replaceFirst(Function\u003cMatchResult, String\u003e replacer)", "label": "public String replaceFirst(Function\u003cMatchResult, String\u003e replacer)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Replaces the first subsequence of the input sequence that matches the\\n     * pattern with the result of applying the given replacer function to the\\n     * match result of this matcher corresponding to that subsequence.\\n     * Exceptions thrown by the replace function are relayed to the caller.\\n     *\\n     * \u003cp\u003e This method first resets this matcher.  It then scans the input\\n     * sequence looking for a match of the pattern.  Characters that are not\\n     * part of the match are appended directly to the result string; the match\\n     * is replaced in the result by the applying the replacer function that\\n     * returns a replacement string.  The replacement string may contain\\n     * references to captured subsequences as in the {@link #appendReplacement\\n     * appendReplacement} method.\\n     *\\n     * \u003cp\u003eNote that backslashes ({@code \\\\}) and dollar signs ({@code $}) in\\n     * the replacement string may cause the results to be different than if it\\n     * were being treated as a literal replacement string. Dollar signs may be\\n     * treated as references to captured subsequences as described above, and\\n     * backslashes are used to escape literal characters in the replacement\\n     * string.\\n     *\\n     * \u003cp\u003e Given the regular expression {@code dog}, the input\\n     * {@code \"zzzdogzzzdogzzz\"}, and the function\\n     * {@code mr -\u003e mr.group().toUpperCase()}, an invocation of this method on\\n     * a matcher for that expression would yield the string\\n     * {@code \"zzzDOGzzzdogzzz\"}.\\n     *\\n     * \u003cp\u003e Invoking this method changes this matcher\\\u0027s state.  If the matcher\\n     * is to be used in further matching operations then it should first be\\n     * reset.\\n     *\\n     * \u003cp\u003e The replacer function should not modify this matcher\\\u0027s state during\\n     * replacement.  This method will, on a best-effort basis, throw a\\n     * {@link java.util.ConcurrentModificationException} if such modification is\\n     * detected.\\n     *\\n     * \u003cp\u003e The state of the match result passed to the replacer function is\\n     * guaranteed to be constant only for the duration of the replacer function\\n     * call and only if the replacer function does not modify this matcher\\\u0027s\\n     * state.\\n     *\\n     * @implNote\\n     * This implementation applies the replacer function to this matcher, which\\n     * is an instance of {@code MatchResult}.\\n     *\\n     * @param  replacer\\n     *         The function to be applied to the match result of this matcher\\n     *         that returns a replacement string.\\n     * @return  The string constructed by replacing the first matching\\n     *          subsequence with the result of applying the replacer function to\\n     *          the matched subsequence, substituting captured subsequences as\\n     *          needed.\\n     * @throws NullPointerException if the replacer function is null\\n     * @throws ConcurrentModificationException if it is detected, on a\\n     *         best-effort basis, that the replacer function modified this\\n     *         matcher\\\u0027s state\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Matcher region(int start, int end)", "label": "public Matcher region(int start, int end)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Sets the limits of this matcher\u0027s region. The region is the part of the\\n     * input sequence that will be searched to find a match. Invoking this\\n     * method resets the matcher, and then sets the region to start at the\\n     * index specified by the {@code start} parameter and end at the\\n     * index specified by the {@code end} parameter.\\n     *\\n     * \u003cp\u003eDepending on the transparency and anchoring being used (see\\n     * {@link #useTransparentBounds(boolean) useTransparentBounds} and\\n     * {@link #useAnchoringBounds(boolean) useAnchoringBounds}), certain\\n     * constructs such as anchors may behave differently at or around the\\n     * boundaries of the region.\\n     *\\n     * @param  start\\n     *         The index to start searching at (inclusive)\\n     * @param  end\\n     *         The index to end searching at (exclusive)\\n     * @throws  IndexOutOfBoundsException\\n     *          If start or end is less than zero, if\\n     *          start is greater than the length of the input sequence, if\\n     *          end is greater than the length of the input sequence, or if\\n     *          start is greater than end.\\n     * @return  this matcher\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": "useTransparentBounds(boolean)", "label": "useTransparentBounds(boolean)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "useAnchoringBounds(boolean)", "label": "useAnchoringBounds(boolean)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public int regionStart()", "label": "public int regionStart()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reports the start index of this matcher\u0027s region. The\\n     * searches this matcher conducts are limited to finding matches\\n     * within {@link #regionStart() regionStart} (inclusive) and\\n     * {@link #regionEnd() regionEnd} (exclusive).\\n     *\\n     * @return  The starting point of this matcher\u0027s region\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": "regionEnd()", "label": "regionEnd()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "regionStart()", "label": "regionStart()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public int regionEnd()", "label": "public int regionEnd()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reports the end index (exclusive) of this matcher\u0027s region.\\n     * The searches this matcher conducts are limited to finding matches\\n     * within {@link #regionStart() regionStart} (inclusive) and\\n     * {@link #regionEnd() regionEnd} (exclusive).\\n     *\\n     * @return  the ending point of this matcher\u0027s region\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean hasTransparentBounds()", "label": "public boolean hasTransparentBounds()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Queries the transparency of region bounds for this matcher.\\n     *\\n     * \u003cp\u003e This method returns {@code true} if this matcher uses\\n     * \u003ci\u003etransparent\u003c/i\u003e bounds, {@code false} if it uses \u003ci\u003eopaque\u003c/i\u003e\\n     * bounds.\\n     *\\n     * \u003cp\u003e See {@link #useTransparentBounds(boolean) useTransparentBounds} for a\\n     * description of transparent and opaque bounds.\\n     *\\n     * \u003cp\u003e By default, a matcher uses opaque region boundaries.\\n     *\\n     * @return {@code true} iff this matcher is using transparent bounds,\\n     *         {@code false} otherwise.\\n     * @see java.util.regex.Matcher#useTransparentBounds(boolean)\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Matcher useTransparentBounds(boolean b)", "label": "public Matcher useTransparentBounds(boolean b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Sets the transparency of region bounds for this matcher.\\n     *\\n     * \u003cp\u003e Invoking this method with an argument of {@code true} will set this\\n     * matcher to use \u003ci\u003etransparent\u003c/i\u003e bounds. If the boolean\\n     * argument is {@code false}, then \u003ci\u003eopaque\u003c/i\u003e bounds will be used.\\n     *\\n     * \u003cp\u003e Using transparent bounds, the boundaries of this\\n     * matcher\u0027s region are transparent to lookahead, lookbehind,\\n     * and boundary matching constructs. Those constructs can see beyond the\\n     * boundaries of the region to see if a match is appropriate.\\n     *\\n     * \u003cp\u003e Using opaque bounds, the boundaries of this matcher\u0027s\\n     * region are opaque to lookahead, lookbehind, and boundary matching\\n     * constructs that may try to see beyond them. Those constructs cannot\\n     * look past the boundaries so they will fail to match anything outside\\n     * of the region.\\n     *\\n     * \u003cp\u003e By default, a matcher uses opaque bounds.\\n     *\\n     * @param  b a boolean indicating whether to use opaque or transparent\\n     *         regions\\n     * @return this matcher\\n     * @see java.util.regex.Matcher#hasTransparentBounds\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean hasAnchoringBounds()", "label": "public boolean hasAnchoringBounds()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Queries the anchoring of region bounds for this matcher.\\n     *\\n     * \u003cp\u003e This method returns {@code true} if this matcher uses\\n     * \u003ci\u003eanchoring\u003c/i\u003e bounds, {@code false} otherwise.\\n     *\\n     * \u003cp\u003e See {@link #useAnchoringBounds(boolean) useAnchoringBounds} for a\\n     * description of anchoring bounds.\\n     *\\n     * \u003cp\u003e By default, a matcher uses anchoring region boundaries.\\n     *\\n     * @return {@code true} iff this matcher is using anchoring bounds,\\n     *         {@code false} otherwise.\\n     * @see java.util.regex.Matcher#useAnchoringBounds(boolean)\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Matcher useAnchoringBounds(boolean b)", "label": "public Matcher useAnchoringBounds(boolean b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Sets the anchoring of region bounds for this matcher.\\n     *\\n     * \u003cp\u003e Invoking this method with an argument of {@code true} will set this\\n     * matcher to use \u003ci\u003eanchoring\u003c/i\u003e bounds. If the boolean\\n     * argument is {@code false}, then \u003ci\u003enon-anchoring\u003c/i\u003e bounds will be\\n     * used.\\n     *\\n     * \u003cp\u003e Using anchoring bounds, the boundaries of this\\n     * matcher\u0027s region match anchors such as ^ and $.\\n     *\\n     * \u003cp\u003e Without anchoring bounds, the boundaries of this\\n     * matcher\u0027s region will not match anchors such as ^ and $.\\n     *\\n     * \u003cp\u003e By default, a matcher uses anchoring region boundaries.\\n     *\\n     * @param  b a boolean indicating whether or not to use anchoring bounds.\\n     * @return this matcher\\n     * @see java.util.regex.Matcher#hasAnchoringBounds\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean hitEnd()", "label": "public boolean hitEnd()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * \u003cp\u003eReturns true if the end of input was hit by the search engine in\\n     * the last match operation performed by this matcher.\\n     *\\n     * \u003cp\u003eWhen this method returns true, then it is possible that more input\\n     * would have changed the result of the last search.\\n     *\\n     * @return  true iff the end of input was hit in the last match; false\\n     *          otherwise\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean requireEnd()", "label": "public boolean requireEnd()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * \u003cp\u003eReturns true if more input could change a positive match into a\\n     * negative one.\\n     *\\n     * \u003cp\u003eIf this method returns true, and a match was found, then more\\n     * input could cause the match to be lost. If this method returns false\\n     * and a match was found, then more input might change the match but the\\n     * match won\u0027t be lost. If a match was not found, then requireEnd has no\\n     * meaning.\\n     *\\n     * @return  true iff more input could change a positive match into a\\n     *          negative one.\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": " int getTextLength()", "label": " int getTextLength()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the end index of the text.\\n     *\\n     * @return the index after the last character in the text\\n     \u0027}"}, {"color": "#97c2fc", "id": " CharSequence getSubSequence(int beginIndex, int endIndex)", "label": " CharSequence getSubSequence(int beginIndex, int endIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Generates a String from this matcher\u0027s input in the specified range.\\n     *\\n     * @param  beginIndex   the beginning index, inclusive\\n     * @param  endIndex     the ending index, exclusive\\n     * @return A String generated from this matcher\u0027s input\\n     \"}"}, {"color": "#97c2fc", "id": "private Matcher reset(CharSequence input, int start, int end)", "label": "private Matcher reset(CharSequence input, int start, int end)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Resets the Matcher. A new input sequence and a new region can be\\n     * specified. Results of a previous find get lost. The next attempt to find\\n     * an occurrence of the Pattern in the string will start at the beginning of\\n     * the region. This is the internal version of reset() to which the several\\n     * public versions delegate.\\n     *\\n     * @param input\\n     *            the input sequence.\\n     * @param start\\n     *            the start of the region.\\n     * @param end\\n     *            the end of the region.\\n     *\\n     * @return the matcher itself.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void ensureMatch()", "label": "private void ensureMatch()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Makes sure that a successful match has been made. Is invoked internally\\n     * from various places in the class.\\n     *\\n     * @throws IllegalStateException\\n     *             if no successful match has been made.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String replaceAll(String regex, String replacement)", "label": "public String replaceAll(String regex, String replacement)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Replaces each substring of this string that matches the given \u003ca\\n     * href=\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\\n     * given replacement.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form\\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceAll(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\\n     * yields exactly the same result as the expression\\n     *\\n     * \u003cblockquote\u003e\\n     * \u003ccode\u003e\\n     * {@link java.util.regex.Pattern}.{@link\\n     * java.util.regex.Pattern#compile compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\\n     * java.util.regex.Matcher#replaceAll replaceAll}(\u003ci\u003erepl\u003c/i\u003e)\\n     * \u003c/code\u003e\\n     * \u003c/blockquote\u003e\\n     *\\n     *\u003cp\u003e\\n     * Note that backslashes ({@code \\\\}) and dollar signs ({@code $}) in the\\n     * replacement string may cause the results to be different than if it were\\n     * being treated as a literal replacement string; see\\n     * {@link java.util.regex.Matcher#replaceAll Matcher.replaceAll}.\\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\\n     * meaning of these characters, if desired.\\n     *\\n     * @param   regex\\n     *          the regular expression to which this string is to be matched\\n     * @param   replacement\\n     *          the string to be substituted for each match\\n     *\\n     * @return  The resulting {@code String}\\n     *\\n     * @throws  PatternSyntaxException\\n     *          if the regular expression\\\u0027s syntax is invalid\\n     *\\n     * @see java.util.regex.Pattern\\n     *\\n     * @since 1.4\\n     * @spec JSR-51\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String replace(CharSequence target, CharSequence replacement)", "label": "public String replace(CharSequence target, CharSequence replacement)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Replaces each substring of this string that matches the literal target\\n     * sequence with the specified literal replacement sequence. The\\n     * replacement proceeds from the beginning of the string to the end, for\\n     * example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in\\n     * \"ba\" rather than \"ab\".\\n     *\\n     * @param  target The sequence of char values to be replaced\\n     * @param  replacement The replacement sequence of char values\\n     * @return  The resulting string\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String[] split(String regex, int limit)", "label": "public String[] split(String regex, int limit)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Splits this string around matches of the given\\n     * \u003ca href=\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\\n     *\\n     * \u003cp\u003e The array returned by this method contains each substring of this\\n     * string that is terminated by another substring that matches the given\\n     * expression or is terminated by the end of the string.  The substrings in\\n     * the array are in the order in which they occur in this string.  If the\\n     * expression does not match any part of the input then the resulting array\\n     * has just one element, namely this string.\\n     *\\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\\n     * string then an empty leading substring is included at the beginning\\n     * of the resulting array. A zero-width match at the beginning however\\n     * never produces such empty leading substring.\\n     *\\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\\n     * pattern is applied and therefore affects the length of the resulting\\n     * array.\\n     * \u003cul\u003e\\n     *    \u003cli\u003e\u003cp\u003e\\n     *    If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\\\u0027s length will be\\n     *    no greater than \u003ci\u003elimit\u003c/i\u003e, and the array\\\u0027s last entry will contain\\n     *    all input beyond the last matched delimiter.\u003c/p\u003e\u003c/li\u003e\\n     *\\n     *    \u003cli\u003e\u003cp\u003e\\n     *    If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\\n     *    many times as possible, the array can have any length, and trailing\\n     *    empty strings will be discarded.\u003c/p\u003e\u003c/li\u003e\\n     *\\n     *    \u003cli\u003e\u003cp\u003e\\n     *    If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\\n     *    as many times as possible and the array can have any length.\u003c/p\u003e\u003c/li\u003e\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the\\n     * following results with these parameters:\\n     *\\n     * \u003cblockquote\u003e\u003ctable class=\"plain\"\u003e\\n     * \u003ccaption style=\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\\n     * \u003cthead\u003e\\n     * \u003ctr\u003e\\n     *     \u003cth scope=\"col\"\u003eRegex\u003c/th\u003e\\n     *     \u003cth scope=\"col\"\u003eLimit\u003c/th\u003e\\n     *     \u003cth scope=\"col\"\u003eResult\u003c/th\u003e\\n     * \u003c/tr\u003e\\n     * \u003c/thead\u003e\\n     * \u003ctbody\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\" rowspan=\"3\" style=\"font-weight:normal\"\u003e:\u003c/th\u003e\\n     *     \u003cth scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"boo\", \"and:foo\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003c!-- : --\u003e\\n     *     \u003cth scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003c!-- : --\u003e\\n     *     \u003cth scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\" rowspan=\"3\" style=\"font-weight:normal\"\u003eo\u003c/th\u003e\\n     *     \u003cth scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003c!-- o --\u003e\\n     *     \u003cth scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003c!-- o --\u003e\\n     *     \u003cth scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003c/tbody\u003e\\n     * \u003c/table\u003e\u003c/blockquote\u003e\\n     *\\n     * \u003cp\u003e An invocation of this method of the form\\n     * \u003ci\u003estr.\u003c/i\u003e{@code split(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\\n     * yields the same result as the expression\\n     *\\n     * \u003cblockquote\u003e\\n     * \u003ccode\u003e\\n     * {@link java.util.regex.Pattern}.{@link\\n     * java.util.regex.Pattern#compile compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\\n     * java.util.regex.Pattern#split(java.lang.CharSequence,int) split}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\\n     * \u003c/code\u003e\\n     * \u003c/blockquote\u003e\\n     *\\n     *\\n     * @param  regex\\n     *         the delimiting regular expression\\n     *\\n     * @param  limit\\n     *         the result threshold, as described above\\n     *\\n     * @return  the array of strings computed by splitting this string\\n     *          around matches of the given regular expression\\n     *\\n     * @throws  PatternSyntaxException\\n     *          if the regular expression\\\u0027s syntax is invalid\\n     *\\n     * @see java.util.regex.Pattern\\n     *\\n     * @since 1.4\\n     * @spec JSR-51\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String[] split(String regex)", "label": "public String[] split(String regex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Splits this string around matches of the given \u003ca\\n     * href=\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\\n     *\\n     * \u003cp\u003e This method works as if by invoking the two-argument {@link\\n     * #split(String, int) split} method with the given expression and a limit\\n     * argument of zero.  Trailing empty strings are therefore not included in\\n     * the resulting array.\\n     *\\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the following\\n     * results with these expressions:\\n     *\\n     * \u003cblockquote\u003e\u003ctable class=\"plain\"\u003e\\n     * \u003ccaption style=\"display:none\"\u003eSplit examples showing regex and result\u003c/caption\u003e\\n     * \u003cthead\u003e\\n     * \u003ctr\u003e\\n     *  \u003cth scope=\"col\"\u003eRegex\u003c/th\u003e\\n     *  \u003cth scope=\"col\"\u003eResult\u003c/th\u003e\\n     * \u003c/tr\u003e\\n     * \u003c/thead\u003e\\n     * \u003ctbody\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\" style=\"text-weight:normal\"\u003e:\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\" style=\"text-weight:normal\"\u003eo\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003c/tbody\u003e\\n     * \u003c/table\u003e\u003c/blockquote\u003e\\n     *\\n     *\\n     * @param  regex\\n     *         the delimiting regular expression\\n     *\\n     * @return  the array of strings computed by splitting this string\\n     *          around matches of the given regular expression\\n     *\\n     * @throws  PatternSyntaxException\\n     *          if the regular expression\\\u0027s syntax is invalid\\n     *\\n     * @see java.util.regex.Pattern\\n     *\\n     * @since 1.4\\n     * @spec JSR-51\\n     \u0027}"}, {"color": "#97c2fc", "id": "split(String", "label": "split(String", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static String join(CharSequence delimiter, CharSequence... elements)", "label": "public static String join(CharSequence delimiter, CharSequence... elements)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a new String composed of copies of the\\n     * {@code CharSequence elements} joined together with a copy of\\n     * the specified {@code delimiter}.\\n     *\\n     * \u003cblockquote\u003eFor example,\\n     * \u003cpre\u003e{@code\\n     *     String message = String.join(\"-\", \"Java\", \"is\", \"cool\");\\n     *     // message returned is: \"Java-is-cool\"\\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * Note that if an element is null, then {@code \"null\"} is added.\\n     *\\n     * @param  delimiter the delimiter that separates each element\\n     * @param  elements the elements to join together.\\n     *\\n     * @return a new {@code String} that is composed of the {@code elements}\\n     *         separated by the {@code delimiter}\\n     *\\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\\n     *         is {@code null}\\n     *\\n     * @see java.util.StringJoiner\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements)", "label": "public static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a new {@code String} composed of copies of the\\n     * {@code CharSequence elements} joined together with a copy of the\\n     * specified {@code delimiter}.\\n     *\\n     * \u003cblockquote\u003eFor example,\\n     * \u003cpre\u003e{@code\\n     *     List\u003cString\u003e strings = List.of(\"Java\", \"is\", \"cool\");\\n     *     String message = String.join(\" \", strings);\\n     *     //message returned is: \"Java is cool\"\\n     *\\n     *     Set\u003cString\u003e strings =\\n     *         new LinkedHashSet\u003c\u003e(List.of(\"Java\", \"is\", \"very\", \"cool\"));\\n     *     String message = String.join(\"-\", strings);\\n     *     //message returned is: \"Java-is-very-cool\"\\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * Note that if an individual element is {@code null}, then {@code \"null\"} is added.\\n     *\\n     * @param  delimiter a sequence of characters that is used to separate each\\n     *         of the {@code elements} in the resulting {@code String}\\n     * @param  elements an {@code Iterable} that will have its {@code elements}\\n     *         joined together.\\n     *\\n     * @return a new {@code String} that is composed from the {@code elements}\\n     *         argument\\n     *\\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\\n     *         is {@code null}\\n     *\\n     * @see    #join(CharSequence,CharSequence...)\\n     * @see    java.util.StringJoiner\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String toLowerCase(Locale locale)", "label": "public String toLowerCase(Locale locale)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Converts all of the characters in this {@code String} to lower\\n     * case using the rules of the given {@code Locale}.  Case mapping is based\\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\\n     * class. Since case mappings are not always 1:1 char mappings, the resulting\\n     * {@code String} may be a different length than the original {@code String}.\\n     * \u003cp\u003e\\n     * Examples of lowercase  mappings are in the following table:\\n     * \u003ctable class=\"plain\"\u003e\\n     * \u003ccaption style=\"display:none\"\u003eLowercase mapping examples showing language code of locale, upper case, lower case, and description\u003c/caption\u003e\\n     * \u003cthead\u003e\\n     * \u003ctr\u003e\\n     *   \u003cth scope=\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\\n     *   \u003cth scope=\"col\"\u003eUpper Case\u003c/th\u003e\\n     *   \u003cth scope=\"col\"\u003eLower Case\u003c/th\u003e\\n     *   \u003cth scope=\"col\"\u003eDescription\u003c/th\u003e\\n     * \u003c/tr\u003e\\n     * \u003c/thead\u003e\\n     * \u003ctbody\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\\n     *   \u003cth scope=\"row\" style=\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0130\u003c/th\u003e\\n     *   \u003ctd\u003e\u0026#92;u0069\u003c/td\u003e\\n     *   \u003ctd\u003ecapital letter I with dot above -\u0026gt; small letter i\u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\\n     *   \u003cth scope=\"row\" style=\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0049\u003c/th\u003e\\n     *   \u003ctd\u003e\u0026#92;u0131\u003c/td\u003e\\n     *   \u003ctd\u003ecapital letter I -\u0026gt; small letter dotless i \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e(all)\u003c/td\u003e\\n     *   \u003cth scope=\"row\" style=\"font-weight:normal; text-align:left\"\u003eFrench Fries\u003c/th\u003e\\n     *   \u003ctd\u003efrench fries\u003c/td\u003e\\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e(all)\u003c/td\u003e\\n     *   \u003cth scope=\"row\" style=\"font-weight:normal; text-align:left\"\u003e\\n     *       \u0026Iota;\u0026Chi;\u0026Theta;\u0026Upsilon;\u0026Sigma;\u003c/th\u003e\\n     *   \u003ctd\u003e\u0026iota;\u0026chi;\u0026theta;\u0026upsilon;\u0026sigma;\u003c/td\u003e\\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003c/tbody\u003e\\n     * \u003c/table\u003e\\n     *\\n     * @param locale use the case transformation rules for this locale\\n     * @return the {@code String}, converted to lowercase.\\n     * @see     java.lang.String#toLowerCase()\\n     * @see     java.lang.String#toUpperCase()\\n     * @see     java.lang.String#toUpperCase(Locale)\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.lang.Character", "label": "java.lang.Character", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * The {@code Character} class wraps a value of the primitive\\n * type {@code char} in an object. An object of class\\n * {@code Character} contains a single field whose type is\\n * {@code char}.\\n * \u003cp\u003e\\n * In addition, this class provides several methods for determining\\n * a character\\\u0027s category (lowercase letter, digit, etc.) and for converting\\n * characters from uppercase to lowercase and vice versa.\\n * \u003cp\u003e\\n * Character information is based on the Unicode Standard\\n * \u003cp\u003e\\n * The methods and data of class {@code Character} are defined by\\n * the information in the \u003ci\u003eUnicodeData\u003c/i\u003e file that is part of the\\n * Unicode Character Database maintained by the Unicode\\n * Consortium. This file specifies various properties including name\\n * and general category for every defined Unicode code point or\\n * character range.\\n * \u003cp\u003e\\n * The file and its description are available from the Unicode Consortium at:\\n * \u003cul\u003e\\n * \u003cli\u003e\u003ca href=\"http://www.unicode.org\"\u003ehttp://www.unicode.org\u003c/a\u003e\\n * \u003c/ul\u003e\\n *\\n * \u003ch2\u003e\u003ca id=\"conformance\"\u003eUnicode Conformance\u003c/a\u003e\u003c/h2\u003e\\n * \u003cp\u003e\\n * The fields and methods of class {@code Character} are defined in terms\\n * of character information from the Unicode Standard, specifically the\\n * \u003ci\u003eUnicodeData\u003c/i\u003e file that is part of the Unicode Character Database.\\n * This file specifies properties including name and category for every\\n * assigned Unicode code point or character range. The file is available\\n * from the Unicode Consortium at\\n * \u003ca href=\"http://www.unicode.org\"\u003ehttp://www.unicode.org\u003c/a\u003e.\\n * \u003cp\u003e\\n * Character information is based on the Unicode Standard, version 13.0.\\n * \u003cp\u003e\\n * The Java platform has supported different versions of the Unicode\\n * Standard over time. Upgrades to newer versions of the Unicode Standard\\n * occurred in the following Java releases, each indicating the new version:\\n * \u003ctable class=\"striped\"\u003e\\n * \u003ccaption style=\"display:none\"\u003eShows Java releases and supported Unicode versions\u003c/caption\u003e\\n * \u003cthead\u003e\\n * \u003ctr\u003e\u003cth scope=\"col\"\u003eJava release\u003c/th\u003e\\n *     \u003cth scope=\"col\"\u003eUnicode version\u003c/th\u003e\u003c/tr\u003e\\n * \u003c/thead\u003e\\n * \u003ctbody\u003e\\n * \u003ctr\u003e\u003ctd\u003eJava SE 15\u003c/td\u003e\\n *     \u003ctd\u003eUnicode 13.0\u003c/td\u003e\u003c/tr\u003e\\n * \u003ctr\u003e\u003ctd\u003eJava SE 13\u003c/td\u003e\\n *     \u003ctd\u003eUnicode 12.1\u003c/td\u003e\u003c/tr\u003e\\n * \u003ctr\u003e\u003ctd\u003eJava SE 12\u003c/td\u003e\\n *     \u003ctd\u003eUnicode 11.0\u003c/td\u003e\u003c/tr\u003e\\n * \u003ctr\u003e\u003ctd\u003eJava SE 11\u003c/td\u003e\\n *     \u003ctd\u003eUnicode 10.0\u003c/td\u003e\u003c/tr\u003e\\n * \u003ctr\u003e\u003ctd\u003eJava SE 9\u003c/td\u003e\\n *     \u003ctd\u003eUnicode 8.0\u003c/td\u003e\u003c/tr\u003e\\n * \u003ctr\u003e\u003ctd\u003eJava SE 8\u003c/td\u003e\\n *     \u003ctd\u003eUnicode 6.2\u003c/td\u003e\u003c/tr\u003e\\n * \u003ctr\u003e\u003ctd\u003eJava SE 7\u003c/td\u003e\\n *     \u003ctd\u003eUnicode 6.0\u003c/td\u003e\u003c/tr\u003e\\n * \u003ctr\u003e\u003ctd\u003eJava SE 5.0\u003c/td\u003e\\n *     \u003ctd\u003eUnicode 4.0\u003c/td\u003e\u003c/tr\u003e\\n * \u003ctr\u003e\u003ctd\u003eJava SE 1.4\u003c/td\u003e\\n *     \u003ctd\u003eUnicode 3.0\u003c/td\u003e\u003c/tr\u003e\\n * \u003ctr\u003e\u003ctd\u003eJDK 1.1\u003c/td\u003e\\n *     \u003ctd\u003eUnicode 2.0\u003c/td\u003e\u003c/tr\u003e\\n * \u003ctr\u003e\u003ctd\u003eJDK 1.0.2\u003c/td\u003e\\n *     \u003ctd\u003eUnicode 1.1.5\u003c/td\u003e\u003c/tr\u003e\\n * \u003c/tbody\u003e\\n * \u003c/table\u003e\\n * Variations from these base Unicode versions, such as recognized appendixes,\\n * are documented elsewhere.\\n * \u003ch2\u003e\u003ca id=\"unicode\"\u003eUnicode Character Representations\u003c/a\u003e\u003c/h2\u003e\\n *\\n * \u003cp\u003eThe {@code char} data type (and therefore the value that a\\n * {@code Character} object encapsulates) are based on the\\n * original Unicode specification, which defined characters as\\n * fixed-width 16-bit entities. The Unicode Standard has since been\\n * changed to allow for characters whose representation requires more\\n * than 16 bits.  The range of legal \u003cem\u003ecode point\u003c/em\u003es is now\\n * U+0000 to U+10FFFF, known as \u003cem\u003eUnicode scalar value\u003c/em\u003e.\\n * (Refer to the \u003ca\\n * href=\"http://www.unicode.org/reports/tr27/#notation\"\u003e\u003ci\u003e\\n * definition\u003c/i\u003e\u003c/a\u003e of the U+\u003ci\u003en\u003c/i\u003e notation in the Unicode\\n * Standard.)\\n *\\n * \u003cp\u003e\u003ca id=\"BMP\"\u003eThe set of characters from U+0000 to U+FFFF\u003c/a\u003e is\\n * sometimes referred to as the \u003cem\u003eBasic Multilingual Plane (BMP)\u003c/em\u003e.\\n * \u003ca id=\"supplementary\"\u003eCharacters\u003c/a\u003e whose code points are greater\\n * than U+FFFF are called \u003cem\u003esupplementary character\u003c/em\u003es.  The Java\\n * platform uses the UTF-16 representation in {@code char} arrays and\\n * in the {@code String} and {@code StringBuffer} classes. In\\n * this representation, supplementary characters are represented as a pair\\n * of {@code char} values, the first from the \u003cem\u003ehigh-surrogates\u003c/em\u003e\\n * range, (\u0026#92;uD800-\u0026#92;uDBFF), the second from the\\n * \u003cem\u003elow-surrogates\u003c/em\u003e range (\u0026#92;uDC00-\u0026#92;uDFFF).\\n *\\n * \u003cp\u003eA {@code char} value, therefore, represents Basic\\n * Multilingual Plane (BMP) code points, including the surrogate\\n * code points, or code units of the UTF-16 encoding. An\\n * {@code int} value represents all Unicode code points,\\n * including supplementary code points. The lower (least significant)\\n * 21 bits of {@code int} are used to represent Unicode code\\n * points and the upper (most significant) 11 bits must be zero.\\n * Unless otherwise specified, the behavior with respect to\\n * supplementary characters and surrogate {@code char} values is\\n * as follows:\\n *\\n * \u003cul\u003e\\n * \u003cli\u003eThe methods that only accept a {@code char} value cannot support\\n * supplementary characters. They treat {@code char} values from the\\n * surrogate ranges as undefined characters. For example,\\n * {@code Character.isLetter(\\\u0027\\\\u005CuD840\\\u0027)} returns {@code false}, even though\\n * this specific value if followed by any low-surrogate value in a string\\n * would represent a letter.\\n *\\n * \u003cli\u003eThe methods that accept an {@code int} value support all\\n * Unicode characters, including supplementary characters. For\\n * example, {@code Character.isLetter(0x2F81A)} returns\\n * {@code true} because the code point value represents a letter\\n * (a CJK ideograph).\\n * \u003c/ul\u003e\\n *\\n * \u003cp\u003eIn the Java SE API documentation, \u003cem\u003eUnicode code point\u003c/em\u003e is\\n * used for character values in the range between U+0000 and U+10FFFF,\\n * and \u003cem\u003eUnicode code unit\u003c/em\u003e is used for 16-bit\\n * {@code char} values that are code units of the \u003cem\u003eUTF-16\u003c/em\u003e\\n * encoding. For more information on Unicode terminology, refer to the\\n * \u003ca href=\"http://www.unicode.org/glossary/\"\u003eUnicode Glossary\u003c/a\u003e.\\n *\\n * \u003c!-- Android-removed: paragraph on ValueBased\\n * \u003cp\u003eThis is a \u003ca href=\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\\n * class; programmers should treat instances that are\\n * {@linkplain #equals(Object) equal} as interchangeable and should not\\n * use instances for synchronization, or unpredictable behavior may\\n * occur. For example, in a future release, synchronization may fail.\\n * --\u003e\\n *\\n * @author  Lee Boynton\\n * @author  Guy Steele\\n * @author  Akira Tanaka\\n * @author  Martin Buchholz\\n * @author  Ulf Zibis\\n * @since   1.0\\n \u0027}"}, {"color": "#97c2fc", "id": "public static Character valueOf(char c)", "label": "public static Character valueOf(char c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a {@code Character} instance representing the specified\\n     * {@code char} value.\\n     * If a new {@code Character} instance is not required, this method\\n     * should generally be used in preference to the constructor\\n     * {@link #Character(char)}, as this method is likely to yield\\n     * significantly better space and time performance by caching\\n     * frequently requested values.\\n     *\\n     * This method will always cache values in the range {@code\\n     * \u0027\\\\u005Cu0000\u0027} to {@code \u0027\\\\u005Cu007F\u0027}, inclusive, and may\\n     * cache other values outside of this range.\\n     *\\n     * @param  c a char value.\\n     * @return a {@code Character} instance representing {@code c}.\\n     * @since  1.5\\n     \"}"}, {"color": "#97c2fc", "id": "Character(char)", "label": "Character(char)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public char charValue()", "label": "public char charValue()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value of this {@code Character} object.\\n     * @return  the primitive {@code char} value represented by\\n     *          this object.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int hashCode(char value)", "label": "public static int hashCode(char value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a hash code for a {@code char} value; compatible with\\n     * {@code Character.hashCode()}.\\n     *\\n     * @since 1.8\\n     *\\n     * @param value The {@code char} for which to return a hash code.\\n     * @return a hash code value for a {@code char} value.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean equals(Object obj)", "label": "public boolean equals(Object obj)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares this object against the specified object.\\n     * The result is {@code true} if and only if the argument is not\\n     * {@code null} and is a {@code Character} object that\\n     * represents the same {@code char} value as this object.\\n     *\\n     * @param   obj   the object to compare with.\\n     * @return  {@code true} if the objects are the same;\\n     *          {@code false} otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String toString(char c)", "label": "public static String toString(char c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code String} object representing the\\n     * specified {@code char}.  The result is a string of length\\n     * 1 consisting solely of the specified {@code char}.\\n     *\\n     * @param c the {@code char} to be converted\\n     * @return the string representation of the specified {@code char}\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String toString(int codePoint)", "label": "public static String toString(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code String} object representing the\\n     * specified character (Unicode code point).  The result is a string of\\n     * length 1 or 2, consisting solely of the specified {@code codePoint}.\\n     *\\n     * @param codePoint the {@code codePoint} to be converted\\n     * @return the string representation of the specified {@code codePoint}\\n     * @throws IllegalArgumentException if the specified\\n     *      {@code codePoint} is not a {@linkplain #isValidCodePoint\\n     *      valid Unicode code point}.\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isValidCodePoint(int codePoint)", "label": "public static boolean isValidCodePoint(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines whether the specified code point is a valid\\n     * \u003ca href=\"http://www.unicode.org/glossary/#code_point\"\u003e\\n     * Unicode code point value\u003c/a\u003e.\\n     *\\n     * @param  codePoint the Unicode code point to be tested\\n     * @return {@code true} if the specified code point value is between\\n     *         {@link #MIN_CODE_POINT} and\\n     *         {@link #MAX_CODE_POINT} inclusive;\\n     *         {@code false} otherwise.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "MIN_CODE_POINT", "label": "MIN_CODE_POINT", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "MAX_CODE_POINT", "label": "MAX_CODE_POINT", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isBmpCodePoint(int codePoint)", "label": "public static boolean isBmpCodePoint(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines whether the specified character (Unicode code point)\\n     * is in the \u003ca href=\"#BMP\"\u003eBasic Multilingual Plane (BMP)\u003c/a\u003e.\\n     * Such code points can be represented using a single {@code char}.\\n     *\\n     * @param  codePoint the character (Unicode code point) to be to\\n     * @return {@code true} if the specified code point is between\\n     *         {@link #MIN_VALUE} and {@link #MAX_VALUE} inclusive;\\n     *         {@code false} otherwise.\\n     * @since  1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "MIN_VALUE", "label": "MIN_VALUE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "MAX_VALUE", "label": "MAX_VALUE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isSupplementaryCodePoint(int codePoint)", "label": "public static boolean isSupplementaryCodePoint(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines whether the specified character (Unicode code point)\\n     * is in the \u003ca href=\"#supplementary\"\u003esupplementary character\u003c/a\u003e range.\\n     *\\n     * @param  codePoint the character (Unicode code point) to be tested\\n     * @return {@code true} if the specified code point is between\\n     *         {@link #MIN_SUPPLEMENTARY_CODE_POINT} and\\n     *         {@link #MAX_CODE_POINT} inclusive;\\n     *         {@code false} otherwise.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "MIN_SUPPLEMENTARY_CODE_POINT", "label": "MIN_SUPPLEMENTARY_CODE_POINT", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isHighSurrogate(char ch)", "label": "public static boolean isHighSurrogate(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the given {@code char} value is a\\n     * \u003ca href=\"http://www.unicode.org/glossary/#high_surrogate_code_unit\"\u003e\\n     * Unicode high-surrogate code unit\u003c/a\u003e\\n     * (also known as \u003ci\u003eleading-surrogate code unit\u003c/i\u003e).\\n     *\\n     * \u003cp\u003eSuch values do not represent characters by themselves,\\n     * but are used in the representation of\\n     * \u003ca href=\"#supplementary\"\u003esupplementary characters\u003c/a\u003e\\n     * in the UTF-16 encoding.\\n     *\\n     * @param  ch the {@code char} value to be tested.\\n     * @return {@code true} if the {@code char} value is between\\n     *         {@link #MIN_HIGH_SURROGATE} and\\n     *         {@link #MAX_HIGH_SURROGATE} inclusive;\\n     *         {@code false} otherwise.\\n     * @see    Character#isLowSurrogate(char)\\n     * @see    Character.UnicodeBlock#of(int)\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "MIN_HIGH_SURROGATE", "label": "MIN_HIGH_SURROGATE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "MAX_HIGH_SURROGATE", "label": "MAX_HIGH_SURROGATE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isLowSurrogate(char ch)", "label": "public static boolean isLowSurrogate(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the given {@code char} value is a\\n     * \u003ca href=\"http://www.unicode.org/glossary/#low_surrogate_code_unit\"\u003e\\n     * Unicode low-surrogate code unit\u003c/a\u003e\\n     * (also known as \u003ci\u003etrailing-surrogate code unit\u003c/i\u003e).\\n     *\\n     * \u003cp\u003eSuch values do not represent characters by themselves,\\n     * but are used in the representation of\\n     * \u003ca href=\"#supplementary\"\u003esupplementary characters\u003c/a\u003e\\n     * in the UTF-16 encoding.\\n     *\\n     * @param  ch the {@code char} value to be tested.\\n     * @return {@code true} if the {@code char} value is between\\n     *         {@link #MIN_LOW_SURROGATE} and\\n     *         {@link #MAX_LOW_SURROGATE} inclusive;\\n     *         {@code false} otherwise.\\n     * @see    Character#isHighSurrogate(char)\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "MAX_LOW_SURROGATE", "label": "MAX_LOW_SURROGATE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "MIN_LOW_SURROGATE", "label": "MIN_LOW_SURROGATE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isSurrogate(char ch)", "label": "public static boolean isSurrogate(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the given {@code char} value is a Unicode\\n     * \u003ci\u003esurrogate code unit\u003c/i\u003e.\\n     *\\n     * \u003cp\u003eSuch values do not represent characters by themselves,\\n     * but are used in the representation of\\n     * \u003ca href=\"#supplementary\"\u003esupplementary characters\u003c/a\u003e\\n     * in the UTF-16 encoding.\\n     *\\n     * \u003cp\u003eA char value is a surrogate code unit if and only if it is either\\n     * a {@linkplain #isLowSurrogate(char) low-surrogate code unit} or\\n     * a {@linkplain #isHighSurrogate(char) high-surrogate code unit}.\\n     *\\n     * @param  ch the {@code char} value to be tested.\\n     * @return {@code true} if the {@code char} value is between\\n     *         {@link #MIN_SURROGATE} and\\n     *         {@link #MAX_SURROGATE} inclusive;\\n     *         {@code false} otherwise.\\n     * @since  1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "MIN_SURROGATE", "label": "MIN_SURROGATE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "MAX_SURROGATE", "label": "MAX_SURROGATE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isSurrogatePair(char high, char low)", "label": "public static boolean isSurrogatePair(char high, char low)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines whether the specified pair of {@code char}\\n     * values is a valid\\n     * \u003ca href=\"http://www.unicode.org/glossary/#surrogate_pair\"\u003e\\n     * Unicode surrogate pair\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eThis method is equivalent to the expression:\\n     * \u003cblockquote\u003e\u003cpre\u003e{@code\\n     * isHighSurrogate(high) \u0026\u0026 isLowSurrogate(low)\\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @param  high the high-surrogate code value to be tested\\n     * @param  low the low-surrogate code value to be tested\\n     * @return {@code true} if the specified high and\\n     * low-surrogate code values represent a valid surrogate pair;\\n     * {@code false} otherwise.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int charCount(int codePoint)", "label": "public static int charCount(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Determines the number of {@code char} values needed to\\n     * represent the specified character (Unicode code point). If the\\n     * specified character is equal to or greater than 0x10000, then\\n     * the method returns 2. Otherwise, the method returns 1.\\n     *\\n     * \u003cp\u003eThis method doesn\u0027t validate the specified character to be a\\n     * valid Unicode code point. The caller must validate the\\n     * character value using {@link #isValidCodePoint(int) isValidCodePoint}\\n     * if necessary.\\n     *\\n     * @param   codePoint the character (Unicode code point) to be tested.\\n     * @return  2 if the character is a valid supplementary character; 1 otherwise.\\n     * @see     Character#isSupplementaryCodePoint(int)\\n     * @since   1.5\\n     \"}"}, {"color": "#97c2fc", "id": "isValidCodePoint(int)", "label": "isValidCodePoint(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int toCodePoint(char high, char low)", "label": "public static int toCodePoint(char high, char low)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Converts the specified surrogate pair to its supplementary code\\n     * point value. This method does not validate the specified\\n     * surrogate pair. The caller must validate it using {@link\\n     * #isSurrogatePair(char, char) isSurrogatePair} if necessary.\\n     *\\n     * @param  high the high-surrogate code unit\\n     * @param  low the low-surrogate code unit\\n     * @return the supplementary code point composed from the\\n     *         specified surrogate pair.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "isSurrogatePair(char", "label": "isSurrogatePair(char", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int codePointAt(CharSequence seq, int index)", "label": "public static int codePointAt(CharSequence seq, int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the code point at the given index of the\\n     * {@code CharSequence}. If the {@code char} value at\\n     * the given index in the {@code CharSequence} is in the\\n     * high-surrogate range, the following index is less than the\\n     * length of the {@code CharSequence}, and the\\n     * {@code char} value at the following index is in the\\n     * low-surrogate range, then the supplementary code point\\n     * corresponding to this surrogate pair is returned. Otherwise,\\n     * the {@code char} value at the given index is returned.\\n     *\\n     * @param seq a sequence of {@code char} values (Unicode code\\n     * units)\\n     * @param index the index to the {@code char} values (Unicode\\n     * code units) in {@code seq} to be converted\\n     * @return the Unicode code point at the given index\\n     * @throws NullPointerException if {@code seq} is null.\\n     * @throws IndexOutOfBoundsException if the value\\n     * {@code index} is negative or not less than\\n     * {@link CharSequence#length() seq.length()}.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int codePointAt(char[] a, int index)", "label": "public static int codePointAt(char[] a, int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the code point at the given index of the\\n     * {@code char} array. If the {@code char} value at\\n     * the given index in the {@code char} array is in the\\n     * high-surrogate range, the following index is less than the\\n     * length of the {@code char} array, and the\\n     * {@code char} value at the following index is in the\\n     * low-surrogate range, then the supplementary code point\\n     * corresponding to this surrogate pair is returned. Otherwise,\\n     * the {@code char} value at the given index is returned.\\n     *\\n     * @param a the {@code char} array\\n     * @param index the index to the {@code char} values (Unicode\\n     * code units) in the {@code char} array to be converted\\n     * @return the Unicode code point at the given index\\n     * @throws NullPointerException if {@code a} is null.\\n     * @throws IndexOutOfBoundsException if the value\\n     * {@code index} is negative or not less than\\n     * the length of the {@code char} array.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int codePointAt(char[] a, int index, int limit)", "label": "public static int codePointAt(char[] a, int index, int limit)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the code point at the given index of the\\n     * {@code char} array, where only array elements with\\n     * {@code index} less than {@code limit} can be used. If\\n     * the {@code char} value at the given index in the\\n     * {@code char} array is in the high-surrogate range, the\\n     * following index is less than the {@code limit}, and the\\n     * {@code char} value at the following index is in the\\n     * low-surrogate range, then the supplementary code point\\n     * corresponding to this surrogate pair is returned. Otherwise,\\n     * the {@code char} value at the given index is returned.\\n     *\\n     * @param a the {@code char} array\\n     * @param index the index to the {@code char} values (Unicode\\n     * code units) in the {@code char} array to be converted\\n     * @param limit the index after the last array element that\\n     * can be used in the {@code char} array\\n     * @return the Unicode code point at the given index\\n     * @throws NullPointerException if {@code a} is null.\\n     * @throws IndexOutOfBoundsException if the {@code index}\\n     * argument is negative or not less than the {@code limit}\\n     * argument, or if the {@code limit} argument is negative or\\n     * greater than the length of the {@code char} array.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": " static int codePointAtImpl(char[] a, int index, int limit)", "label": " static int codePointAtImpl(char[] a, int index, int limit)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 throws ArrayIndexOutOfBoundsException if index out of bounds\u0027}"}, {"color": "#97c2fc", "id": "public static int codePointBefore(CharSequence seq, int index)", "label": "public static int codePointBefore(CharSequence seq, int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the code point preceding the given index of the\\n     * {@code CharSequence}. If the {@code char} value at\\n     * {@code (index - 1)} in the {@code CharSequence} is in\\n     * the low-surrogate range, {@code (index - 2)} is not\\n     * negative, and the {@code char} value at {@code (index - 2)}\\n     * in the {@code CharSequence} is in the\\n     * high-surrogate range, then the supplementary code point\\n     * corresponding to this surrogate pair is returned. Otherwise,\\n     * the {@code char} value at {@code (index - 1)} is\\n     * returned.\\n     *\\n     * @param seq the {@code CharSequence} instance\\n     * @param index the index following the code point that should be returned\\n     * @return the Unicode code point value before the given index.\\n     * @throws NullPointerException if {@code seq} is null.\\n     * @throws IndexOutOfBoundsException if the {@code index}\\n     * argument is less than 1 or greater than {@link\\n     * CharSequence#length() seq.length()}.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int codePointBefore(char[] a, int index)", "label": "public static int codePointBefore(char[] a, int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the code point preceding the given index of the\\n     * {@code char} array. If the {@code char} value at\\n     * {@code (index - 1)} in the {@code char} array is in\\n     * the low-surrogate range, {@code (index - 2)} is not\\n     * negative, and the {@code char} value at {@code (index - 2)}\\n     * in the {@code char} array is in the\\n     * high-surrogate range, then the supplementary code point\\n     * corresponding to this surrogate pair is returned. Otherwise,\\n     * the {@code char} value at {@code (index - 1)} is\\n     * returned.\\n     *\\n     * @param a the {@code char} array\\n     * @param index the index following the code point that should be returned\\n     * @return the Unicode code point value before the given index.\\n     * @throws NullPointerException if {@code a} is null.\\n     * @throws IndexOutOfBoundsException if the {@code index}\\n     * argument is less than 1 or greater than the length of the\\n     * {@code char} array\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int codePointBefore(char[] a, int index, int start)", "label": "public static int codePointBefore(char[] a, int index, int start)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the code point preceding the given index of the\\n     * {@code char} array, where only array elements with\\n     * {@code index} greater than or equal to {@code start}\\n     * can be used. If the {@code char} value at {@code (index - 1)}\\n     * in the {@code char} array is in the\\n     * low-surrogate range, {@code (index - 2)} is not less than\\n     * {@code start}, and the {@code char} value at\\n     * {@code (index - 2)} in the {@code char} array is in\\n     * the high-surrogate range, then the supplementary code point\\n     * corresponding to this surrogate pair is returned. Otherwise,\\n     * the {@code char} value at {@code (index - 1)} is\\n     * returned.\\n     *\\n     * @param a the {@code char} array\\n     * @param index the index following the code point that should be returned\\n     * @param start the index of the first array element in the\\n     * {@code char} array\\n     * @return the Unicode code point value before the given index.\\n     * @throws NullPointerException if {@code a} is null.\\n     * @throws IndexOutOfBoundsException if the {@code index}\\n     * argument is not greater than the {@code start} argument or\\n     * is greater than the length of the {@code char} array, or\\n     * if the {@code start} argument is negative or not less than\\n     * the length of the {@code char} array.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": " static int codePointBeforeImpl(char[] a, int index, int start)", "label": " static int codePointBeforeImpl(char[] a, int index, int start)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 throws ArrayIndexOutOfBoundsException if index-1 out of bounds\u0027}"}, {"color": "#97c2fc", "id": "public static char highSurrogate(int codePoint)", "label": "public static char highSurrogate(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the leading surrogate (a\\n     * \u003ca href=\"http://www.unicode.org/glossary/#high_surrogate_code_unit\"\u003e\\n     * high surrogate code unit\u003c/a\u003e) of the\\n     * \u003ca href=\"http://www.unicode.org/glossary/#surrogate_pair\"\u003e\\n     * surrogate pair\u003c/a\u003e\\n     * representing the specified supplementary character (Unicode\\n     * code point) in the UTF-16 encoding.  If the specified character\\n     * is not a\\n     * \u003ca href=\"Character.html#supplementary\"\u003esupplementary character\u003c/a\u003e,\\n     * an unspecified {@code char} is returned.\\n     *\\n     * \u003cp\u003eIf\\n     * {@link #isSupplementaryCodePoint isSupplementaryCodePoint(x)}\\n     * is {@code true}, then\\n     * {@link #isHighSurrogate isHighSurrogate}{@code (highSurrogate(x))} and\\n     * {@link #toCodePoint toCodePoint}{@code (highSurrogate(x), }{@link #lowSurrogate lowSurrogate}{@code (x)) == x}\\n     * are also always {@code true}.\\n     *\\n     * @param   codePoint a supplementary character (Unicode code point)\\n     * @return  the leading surrogate code unit used to represent the\\n     *          character in the UTF-16 encoding\\n     * @since   1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "isSupplementaryCodePoint", "label": "isSupplementaryCodePoint", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "toCodePoint", "label": "toCodePoint", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "lowSurrogate", "label": "lowSurrogate", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "isHighSurrogate", "label": "isHighSurrogate", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static char lowSurrogate(int codePoint)", "label": "public static char lowSurrogate(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the trailing surrogate (a\\n     * \u003ca href=\"http://www.unicode.org/glossary/#low_surrogate_code_unit\"\u003e\\n     * low surrogate code unit\u003c/a\u003e) of the\\n     * \u003ca href=\"http://www.unicode.org/glossary/#surrogate_pair\"\u003e\\n     * surrogate pair\u003c/a\u003e\\n     * representing the specified supplementary character (Unicode\\n     * code point) in the UTF-16 encoding.  If the specified character\\n     * is not a\\n     * \u003ca href=\"Character.html#supplementary\"\u003esupplementary character\u003c/a\u003e,\\n     * an unspecified {@code char} is returned.\\n     *\\n     * \u003cp\u003eIf\\n     * {@link #isSupplementaryCodePoint isSupplementaryCodePoint(x)}\\n     * is {@code true}, then\\n     * {@link #isLowSurrogate isLowSurrogate}{@code (lowSurrogate(x))} and\\n     * {@link #toCodePoint toCodePoint}{@code (}{@link #highSurrogate highSurrogate}{@code (x), lowSurrogate(x)) == x}\\n     * are also always {@code true}.\\n     *\\n     * @param   codePoint a supplementary character (Unicode code point)\\n     * @return  the trailing surrogate code unit used to represent the\\n     *          character in the UTF-16 encoding\\n     * @since   1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "isLowSurrogate", "label": "isLowSurrogate", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "highSurrogate", "label": "highSurrogate", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int toChars(int codePoint, char[] dst, int dstIndex)", "label": "public static int toChars(int codePoint, char[] dst, int dstIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Converts the specified character (Unicode code point) to its\\n     * UTF-16 representation. If the specified code point is a BMP\\n     * (Basic Multilingual Plane or Plane 0) value, the same value is\\n     * stored in {@code dst[dstIndex]}, and 1 is returned. If the\\n     * specified code point is a supplementary character, its\\n     * surrogate values are stored in {@code dst[dstIndex]}\\n     * (high-surrogate) and {@code dst[dstIndex+1]}\\n     * (low-surrogate), and 2 is returned.\\n     *\\n     * @param  codePoint the character (Unicode code point) to be converted.\\n     * @param  dst an array of {@code char} in which the\\n     * {@code codePoint}\u0027s UTF-16 value is stored.\\n     * @param dstIndex the start index into the {@code dst}\\n     * array where the converted value is stored.\\n     * @return 1 if the code point is a BMP code point, 2 if the\\n     * code point is a supplementary code point.\\n     * @throws IllegalArgumentException if the specified\\n     * {@code codePoint} is not a valid Unicode code point.\\n     * @throws NullPointerException if the specified {@code dst} is null.\\n     * @throws IndexOutOfBoundsException if {@code dstIndex}\\n     * is negative or not less than {@code dst.length}, or if\\n     * {@code dst} at {@code dstIndex} doesn\u0027t have enough\\n     * array element(s) to store the resulting {@code char}\\n     * value(s). (If {@code dstIndex} is equal to\\n     * {@code dst.length-1} and the specified\\n     * {@code codePoint} is a supplementary character, the\\n     * high-surrogate value is not stored in\\n     * {@code dst[dstIndex]}.)\\n     * @since  1.5\\n     \"}"}, {"color": "#97c2fc", "id": "public static char[] toChars(int codePoint)", "label": "public static char[] toChars(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Converts the specified character (Unicode code point) to its\\n     * UTF-16 representation stored in a {@code char} array. If\\n     * the specified code point is a BMP (Basic Multilingual Plane or\\n     * Plane 0) value, the resulting {@code char} array has\\n     * the same value as {@code codePoint}. If the specified code\\n     * point is a supplementary code point, the resulting\\n     * {@code char} array has the corresponding surrogate pair.\\n     *\\n     * @param  codePoint a Unicode code point\\n     * @return a {@code char} array having\\n     *         {@code codePoint}\u0027s UTF-16 representation.\\n     * @throws IllegalArgumentException if the specified\\n     * {@code codePoint} is not a valid Unicode code point.\\n     * @since  1.5\\n     \"}"}, {"color": "#97c2fc", "id": "public static int codePointCount(CharSequence seq, int beginIndex, int endIndex)", "label": "public static int codePointCount(CharSequence seq, int beginIndex, int endIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the number of Unicode code points in the text range of\\n     * the specified char sequence. The text range begins at the\\n     * specified {@code beginIndex} and extends to the\\n     * {@code char} at index {@code endIndex - 1}. Thus the\\n     * length (in {@code char}s) of the text range is\\n     * {@code endIndex-beginIndex}. Unpaired surrogates within\\n     * the text range count as one code point each.\\n     *\\n     * @param seq the char sequence\\n     * @param beginIndex the index to the first {@code char} of\\n     * the text range.\\n     * @param endIndex the index after the last {@code char} of\\n     * the text range.\\n     * @return the number of Unicode code points in the specified text\\n     * range\\n     * @throws NullPointerException if {@code seq} is null.\\n     * @throws IndexOutOfBoundsException if the\\n     * {@code beginIndex} is negative, or {@code endIndex}\\n     * is larger than the length of the given sequence, or\\n     * {@code beginIndex} is larger than {@code endIndex}.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int codePointCount(char[] a, int offset, int count)", "label": "public static int codePointCount(char[] a, int offset, int count)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the number of Unicode code points in a subarray of the\\n     * {@code char} array argument. The {@code offset}\\n     * argument is the index of the first {@code char} of the\\n     * subarray and the {@code count} argument specifies the\\n     * length of the subarray in {@code char}s. Unpaired\\n     * surrogates within the subarray count as one code point each.\\n     *\\n     * @param a the {@code char} array\\n     * @param offset the index of the first {@code char} in the\\n     * given {@code char} array\\n     * @param count the length of the subarray in {@code char}s\\n     * @return the number of Unicode code points in the specified subarray\\n     * @throws NullPointerException if {@code a} is null.\\n     * @throws IndexOutOfBoundsException if {@code offset} or\\n     * {@code count} is negative, or if {@code offset +\\n     * count} is larger than the length of the given array.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int offsetByCodePoints(CharSequence seq, int index, int codePointOffset)", "label": "public static int offsetByCodePoints(CharSequence seq, int index, int codePointOffset)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index within the given char sequence that is offset\\n     * from the given {@code index} by {@code codePointOffset}\\n     * code points. Unpaired surrogates within the text range given by\\n     * {@code index} and {@code codePointOffset} count as\\n     * one code point each.\\n     *\\n     * @param seq the char sequence\\n     * @param index the index to be offset\\n     * @param codePointOffset the offset in code points\\n     * @return the index within the char sequence\\n     * @throws NullPointerException if {@code seq} is null.\\n     * @throws IndexOutOfBoundsException if {@code index}\\n     *   is negative or larger then the length of the char sequence,\\n     *   or if {@code codePointOffset} is positive and the\\n     *   subsequence starting with {@code index} has fewer than\\n     *   {@code codePointOffset} code points, or if\\n     *   {@code codePointOffset} is negative and the subsequence\\n     *   before {@code index} has fewer than the absolute value\\n     *   of {@code codePointOffset} code points.\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int offsetByCodePoints(char[] a, int start, int count, int index, int codePointOffset)", "label": "public static int offsetByCodePoints(char[] a, int start, int count, int index, int codePointOffset)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index within the given {@code char} subarray\\n     * that is offset from the given {@code index} by\\n     * {@code codePointOffset} code points. The\\n     * {@code start} and {@code count} arguments specify a\\n     * subarray of the {@code char} array. Unpaired surrogates\\n     * within the text range given by {@code index} and\\n     * {@code codePointOffset} count as one code point each.\\n     *\\n     * @param a the {@code char} array\\n     * @param start the index of the first {@code char} of the\\n     * subarray\\n     * @param count the length of the subarray in {@code char}s\\n     * @param index the index to be offset\\n     * @param codePointOffset the offset in code points\\n     * @return the index within the subarray\\n     * @throws NullPointerException if {@code a} is null.\\n     * @throws IndexOutOfBoundsException\\n     *   if {@code start} or {@code count} is negative,\\n     *   or if {@code start + count} is larger than the length of\\n     *   the given array,\\n     *   or if {@code index} is less than {@code start} or\\n     *   larger then {@code start + count},\\n     *   or if {@code codePointOffset} is positive and the text range\\n     *   starting with {@code index} and ending with {@code start + count - 1}\\n     *   has fewer than {@code codePointOffset} code\\n     *   points,\\n     *   or if {@code codePointOffset} is negative and the text range\\n     *   starting with {@code start} and ending with {@code index - 1}\\n     *   has fewer than the absolute value of\\n     *   {@code codePointOffset} code points.\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isLowerCase(char ch)", "label": "public static boolean isLowerCase(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character is a lowercase character.\\n     * \u003cp\u003e\\n     * A character is lowercase if its general category type, provided\\n     * by {@code Character.getType(ch)}, is\\n     * {@code LOWERCASE_LETTER}, or it has contributory property\\n     * Other_Lowercase as defined by the Unicode Standard.\\n     * \u003cp\u003e\\n     * The following are examples of lowercase characters:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * a b c d e f g h i j k l m n o p q r s t u v w x y z\\n     * \\\u0027\u0026#92;u00DF\\\u0027 \\\u0027\u0026#92;u00E0\\\u0027 \\\u0027\u0026#92;u00E1\\\u0027 \\\u0027\u0026#92;u00E2\\\u0027 \\\u0027\u0026#92;u00E3\\\u0027 \\\u0027\u0026#92;u00E4\\\u0027 \\\u0027\u0026#92;u00E5\\\u0027 \\\u0027\u0026#92;u00E6\\\u0027\\n     * \\\u0027\u0026#92;u00E7\\\u0027 \\\u0027\u0026#92;u00E8\\\u0027 \\\u0027\u0026#92;u00E9\\\u0027 \\\u0027\u0026#92;u00EA\\\u0027 \\\u0027\u0026#92;u00EB\\\u0027 \\\u0027\u0026#92;u00EC\\\u0027 \\\u0027\u0026#92;u00ED\\\u0027 \\\u0027\u0026#92;u00EE\\\u0027\\n     * \\\u0027\u0026#92;u00EF\\\u0027 \\\u0027\u0026#92;u00F0\\\u0027 \\\u0027\u0026#92;u00F1\\\u0027 \\\u0027\u0026#92;u00F2\\\u0027 \\\u0027\u0026#92;u00F3\\\u0027 \\\u0027\u0026#92;u00F4\\\u0027 \\\u0027\u0026#92;u00F5\\\u0027 \\\u0027\u0026#92;u00F6\\\u0027\\n     * \\\u0027\u0026#92;u00F8\\\u0027 \\\u0027\u0026#92;u00F9\\\u0027 \\\u0027\u0026#92;u00FA\\\u0027 \\\u0027\u0026#92;u00FB\\\u0027 \\\u0027\u0026#92;u00FC\\\u0027 \\\u0027\u0026#92;u00FD\\\u0027 \\\u0027\u0026#92;u00FE\\\u0027 \\\u0027\u0026#92;u00FF\\\u0027\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * \u003cp\u003e Many other Unicode characters are lowercase too.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isLowerCase(int)} method.\\n     *\\n     * @param   ch   the character to be tested.\\n     * @return  {@code true} if the character is lowercase;\\n     *          {@code false} otherwise.\\n     * @see     Character#isLowerCase(char)\\n     * @see     Character#isTitleCase(char)\\n     * @see     Character#toLowerCase(char)\\n     * @see     Character#getType(char)\\n     \u0027}"}, {"color": "#97c2fc", "id": "isLowerCase(int)", "label": "isLowerCase(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isLowerCase(int codePoint)", "label": "public static boolean isLowerCase(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isLowerCase(int codePoint) {\\n        return CharacterData.of(codePoint).isLowerCase(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isUpperCase(char ch)", "label": "public static boolean isUpperCase(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character is an uppercase character.\\n     * \u003cp\u003e\\n     * A character is uppercase if its general category type, provided by\\n     * {@code Character.getType(ch)}, is {@code UPPERCASE_LETTER}.\\n     * or it has contributory property Other_Uppercase as defined by the Unicode Standard.\\n     * \u003cp\u003e\\n     * The following are examples of uppercase characters:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\\n     * \\\u0027\u0026#92;u00C0\\\u0027 \\\u0027\u0026#92;u00C1\\\u0027 \\\u0027\u0026#92;u00C2\\\u0027 \\\u0027\u0026#92;u00C3\\\u0027 \\\u0027\u0026#92;u00C4\\\u0027 \\\u0027\u0026#92;u00C5\\\u0027 \\\u0027\u0026#92;u00C6\\\u0027 \\\u0027\u0026#92;u00C7\\\u0027\\n     * \\\u0027\u0026#92;u00C8\\\u0027 \\\u0027\u0026#92;u00C9\\\u0027 \\\u0027\u0026#92;u00CA\\\u0027 \\\u0027\u0026#92;u00CB\\\u0027 \\\u0027\u0026#92;u00CC\\\u0027 \\\u0027\u0026#92;u00CD\\\u0027 \\\u0027\u0026#92;u00CE\\\u0027 \\\u0027\u0026#92;u00CF\\\u0027\\n     * \\\u0027\u0026#92;u00D0\\\u0027 \\\u0027\u0026#92;u00D1\\\u0027 \\\u0027\u0026#92;u00D2\\\u0027 \\\u0027\u0026#92;u00D3\\\u0027 \\\u0027\u0026#92;u00D4\\\u0027 \\\u0027\u0026#92;u00D5\\\u0027 \\\u0027\u0026#92;u00D6\\\u0027 \\\u0027\u0026#92;u00D8\\\u0027\\n     * \\\u0027\u0026#92;u00D9\\\u0027 \\\u0027\u0026#92;u00DA\\\u0027 \\\u0027\u0026#92;u00DB\\\u0027 \\\u0027\u0026#92;u00DC\\\u0027 \\\u0027\u0026#92;u00DD\\\u0027 \\\u0027\u0026#92;u00DE\\\u0027\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * \u003cp\u003e Many other Unicode characters are uppercase too.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isUpperCase(int)} method.\\n     *\\n     * @param   ch   the character to be tested.\\n     * @return  {@code true} if the character is uppercase;\\n     *          {@code false} otherwise.\\n     * @see     Character#isLowerCase(char)\\n     * @see     Character#isTitleCase(char)\\n     * @see     Character#toUpperCase(char)\\n     * @see     Character#getType(char)\\n     * @since   1.0\\n     \u0027}"}, {"color": "#97c2fc", "id": "isUpperCase(int)", "label": "isUpperCase(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isUpperCase(int codePoint)", "label": "public static boolean isUpperCase(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isUpperCase(int codePoint) {\\n        return CharacterData.of(codePoint).isUpperCase(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isTitleCase(char ch)", "label": "public static boolean isTitleCase(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character is a titlecase character.\\n     * \u003cp\u003e\\n     * A character is a titlecase character if its general\\n     * category type, provided by {@code Character.getType(ch)},\\n     * is {@code TITLECASE_LETTER}.\\n     * \u003cp\u003e\\n     * Some characters look like pairs of Latin letters. For example, there\\n     * is an uppercase letter that looks like \"LJ\" and has a corresponding\\n     * lowercase letter that looks like \"lj\". A third form, which looks like \"Lj\",\\n     * is the appropriate form to use when rendering a word in lowercase\\n     * with initial capitals, as for a book title.\\n     * \u003cp\u003e\\n     * These are some of the Unicode characters for which this method returns\\n     * {@code true}:\\n     * \u003cul\u003e\\n     * \u003cli\u003e{@code LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON}\\n     * \u003cli\u003e{@code LATIN CAPITAL LETTER L WITH SMALL LETTER J}\\n     * \u003cli\u003e{@code LATIN CAPITAL LETTER N WITH SMALL LETTER J}\\n     * \u003cli\u003e{@code LATIN CAPITAL LETTER D WITH SMALL LETTER Z}\\n     * \u003c/ul\u003e\\n     * \u003cp\u003e Many other Unicode characters are titlecase too.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isTitleCase(int)} method.\\n     *\\n     * @param   ch   the character to be tested.\\n     * @return  {@code true} if the character is titlecase;\\n     *          {@code false} otherwise.\\n     * @see     Character#isLowerCase(char)\\n     * @see     Character#isUpperCase(char)\\n     * @see     Character#toTitleCase(char)\\n     * @see     Character#getType(char)\\n     * @since   1.0.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "isTitleCase(int)", "label": "isTitleCase(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isTitleCase(int codePoint)", "label": "public static boolean isTitleCase(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isTitleCase(int codePoint) {\\n        return getType(codePoint) == Character.TITLECASE_LETTER;\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isDigit(char ch)", "label": "public static boolean isDigit(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character is a digit.\\n     * \u003cp\u003e\\n     * A character is a digit if its general category type, provided\\n     * by {@code Character.getType(ch)}, is\\n     * {@code DECIMAL_DIGIT_NUMBER}.\\n     * \u003cp\u003e\\n     * Some Unicode character ranges that contain digits:\\n     * \u003cul\u003e\\n     * \u003cli\u003e{@code \\\u0027\\\\u005Cu0030\\\u0027} through {@code \\\u0027\\\\u005Cu0039\\\u0027},\\n     *     ISO-LATIN-1 digits ({@code \\\u00270\\\u0027} through {@code \\\u00279\\\u0027})\\n     * \u003cli\u003e{@code \\\u0027\\\\u005Cu0660\\\u0027} through {@code \\\u0027\\\\u005Cu0669\\\u0027},\\n     *     Arabic-Indic digits\\n     * \u003cli\u003e{@code \\\u0027\\\\u005Cu06F0\\\u0027} through {@code \\\u0027\\\\u005Cu06F9\\\u0027},\\n     *     Extended Arabic-Indic digits\\n     * \u003cli\u003e{@code \\\u0027\\\\u005Cu0966\\\u0027} through {@code \\\u0027\\\\u005Cu096F\\\u0027},\\n     *     Devanagari digits\\n     * \u003cli\u003e{@code \\\u0027\\\\u005CuFF10\\\u0027} through {@code \\\u0027\\\\u005CuFF19\\\u0027},\\n     *     Fullwidth digits\\n     * \u003c/ul\u003e\\n     *\\n     * Many other character ranges contain digits as well.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isDigit(int)} method.\\n     *\\n     * @param   ch   the character to be tested.\\n     * @return  {@code true} if the character is a digit;\\n     *          {@code false} otherwise.\\n     * @see     Character#digit(char, int)\\n     * @see     Character#forDigit(int, int)\\n     * @see     Character#getType(char)\\n     \u0027}"}, {"color": "#97c2fc", "id": "isDigit(int)", "label": "isDigit(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isDigit(int codePoint)", "label": "public static boolean isDigit(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isDigit(int codePoint) {\\n        return CharacterData.of(codePoint).isDigit(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isDefined(char ch)", "label": "public static boolean isDefined(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if a character is defined in Unicode.\\n     * \u003cp\u003e\\n     * A character is defined if at least one of the following is true:\\n     * \u003cul\u003e\\n     * \u003cli\u003eIt has an entry in the UnicodeData file.\\n     * \u003cli\u003eIt has a value in a range defined by the UnicodeData file.\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isDefined(int)} method.\\n     *\\n     * @param   ch   the character to be tested\\n     * @return  {@code true} if the character has a defined meaning\\n     *          in Unicode; {@code false} otherwise.\\n     * @see     Character#isDigit(char)\\n     * @see     Character#isLetter(char)\\n     * @see     Character#isLetterOrDigit(char)\\n     * @see     Character#isLowerCase(char)\\n     * @see     Character#isTitleCase(char)\\n     * @see     Character#isUpperCase(char)\\n     * @since   1.0.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "isDefined(int)", "label": "isDefined(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isDefined(int codePoint)", "label": "public static boolean isDefined(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isDefined(int codePoint) {\\n        return getType(codePoint) != Character.UNASSIGNED;\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isLetter(char ch)", "label": "public static boolean isLetter(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character is a letter.\\n     * \u003cp\u003e\\n     * A character is considered to be a letter if its general\\n     * category type, provided by {@code Character.getType(ch)},\\n     * is any of the following:\\n     * \u003cul\u003e\\n     * \u003cli\u003e {@code UPPERCASE_LETTER}\\n     * \u003cli\u003e {@code LOWERCASE_LETTER}\\n     * \u003cli\u003e {@code TITLECASE_LETTER}\\n     * \u003cli\u003e {@code MODIFIER_LETTER}\\n     * \u003cli\u003e {@code OTHER_LETTER}\\n     * \u003c/ul\u003e\\n     *\\n     * Not all letters have case. Many characters are\\n     * letters but are neither uppercase nor lowercase nor titlecase.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isLetter(int)} method.\\n     *\\n     * @param   ch   the character to be tested.\\n     * @return  {@code true} if the character is a letter;\\n     *          {@code false} otherwise.\\n     * @see     Character#isDigit(char)\\n     * @see     Character#isJavaIdentifierStart(char)\\n     * @see     Character#isJavaLetter(char)\\n     * @see     Character#isJavaLetterOrDigit(char)\\n     * @see     Character#isLetterOrDigit(char)\\n     * @see     Character#isLowerCase(char)\\n     * @see     Character#isTitleCase(char)\\n     * @see     Character#isUnicodeIdentifierStart(char)\\n     * @see     Character#isUpperCase(char)\\n     \u0027}"}, {"color": "#97c2fc", "id": "isLetter(int)", "label": "isLetter(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isLetter(int codePoint)", "label": "public static boolean isLetter(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isLetter(int codePoint) {\\n        return ((((1 \u003c\u003c Character.UPPERCASE_LETTER) |\\n            (1 \u003c\u003c Character.LOWERCASE_LETTER) |\\n            (1 \u003c\u003c Character.TITLECASE_LETTER) |\\n            (1 \u003c\u003c Character.MODIFIER_LETTER) |\\n            (1 \u003c\u003c Character.OTHER_LETTER)) \u003e\u003e getType(codePoint)) \u0026 1)\\n            != 0;\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isLetterOrDigit(char ch)", "label": "public static boolean isLetterOrDigit(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character is a letter or digit.\\n     * \u003cp\u003e\\n     * A character is considered to be a letter or digit if either\\n     * {@code Character.isLetter(char ch)} or\\n     * {@code Character.isDigit(char ch)} returns\\n     * {@code true} for the character.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isLetterOrDigit(int)} method.\\n     *\\n     * @param   ch   the character to be tested.\\n     * @return  {@code true} if the character is a letter or digit;\\n     *          {@code false} otherwise.\\n     * @see     Character#isDigit(char)\\n     * @see     Character#isJavaIdentifierPart(char)\\n     * @see     Character#isJavaLetter(char)\\n     * @see     Character#isJavaLetterOrDigit(char)\\n     * @see     Character#isLetter(char)\\n     * @see     Character#isUnicodeIdentifierPart(char)\\n     * @since   1.0.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "isLetterOrDigit(int)", "label": "isLetterOrDigit(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isLetterOrDigit(int codePoint)", "label": "public static boolean isLetterOrDigit(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isLetterOrDigit(int codePoint) {\\n        return ((((1 \u003c\u003c Character.UPPERCASE_LETTER) |\\n            (1 \u003c\u003c Character.LOWERCASE_LETTER) |\\n            (1 \u003c\u003c Character.TITLECASE_LETTER) |\\n            (1 \u003c\u003c Character.MODIFIER_LETTER) |\\n            (1 \u003c\u003c Character.OTHER_LETTER) |\\n            (1 \u003c\u003c Character.DECIMAL_DIGIT_NUMBER)) \u003e\u003e getType(codePoint)) \u0026 1)\\n            != 0;\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isAlphabetic(int codePoint)", "label": "public static boolean isAlphabetic(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isAlphabetic(int codePoint) {\\n        return (((((1 \u003c\u003c Character.UPPERCASE_LETTER) |\\n            (1 \u003c\u003c Character.LOWERCASE_LETTER) |\\n            (1 \u003c\u003c Character.TITLECASE_LETTER) |\\n            (1 \u003c\u003c Character.MODIFIER_LETTER) |\\n            (1 \u003c\u003c Character.OTHER_LETTER) |\\n            (1 \u003c\u003c Character.LETTER_NUMBER)) \u003e\u003e getType(codePoint)) \u0026 1) != 0) ||\\n            CharacterData.of(codePoint).isOtherAlphabetic(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isIdeographic(int codePoint)", "label": "public static boolean isIdeographic(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isIdeographic(int codePoint) {\\n        return CharacterData.of(codePoint).isIdeographic(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isJavaIdentifierStart(char ch)", "label": "public static boolean isJavaIdentifierStart(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character is\\n     * permissible as the first character in a Java identifier.\\n     * \u003cp\u003e\\n     * A character may start a Java identifier if and only if\\n     * one of the following conditions is true:\\n     * \u003cul\u003e\\n     * \u003cli\u003e {@link #isLetter(char) isLetter(ch)} returns {@code true}\\n     * \u003cli\u003e {@link #getType(char) getType(ch)} returns {@code LETTER_NUMBER}\\n     * \u003cli\u003e {@code ch} is a currency symbol (such as {@code \\\u0027$\\\u0027})\\n     * \u003cli\u003e {@code ch} is a connecting punctuation character (such as {@code \\\u0027_\\\u0027}).\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isJavaIdentifierStart(int)} method.\\n     *\\n     * @param   ch the character to be tested.\\n     * @return  {@code true} if the character may start a Java identifier;\\n     *          {@code false} otherwise.\\n     * @see     Character#isJavaIdentifierPart(char)\\n     * @see     Character#isLetter(char)\\n     * @see     Character#isUnicodeIdentifierStart(char)\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "isLetter(char)", "label": "isLetter(char)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "getType(char)", "label": "getType(char)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "isJavaIdentifierStart(int)", "label": "isJavaIdentifierStart(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isJavaIdentifierStart(int codePoint)", "label": "public static boolean isJavaIdentifierStart(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isJavaIdentifierStart(int codePoint) {\\n        return CharacterData.of(codePoint).isJavaIdentifierStart(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isJavaIdentifierPart(char ch)", "label": "public static boolean isJavaIdentifierPart(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character may be part of a Java\\n     * identifier as other than the first character.\\n     * \u003cp\u003e\\n     * A character may be part of a Java identifier if any of the following\\n     * conditions are true:\\n     * \u003cul\u003e\\n     * \u003cli\u003e  it is a letter\\n     * \u003cli\u003e  it is a currency symbol (such as {@code \\\u0027$\\\u0027})\\n     * \u003cli\u003e  it is a connecting punctuation character (such as {@code \\\u0027_\\\u0027})\\n     * \u003cli\u003e  it is a digit\\n     * \u003cli\u003e  it is a numeric letter (such as a Roman numeral character)\\n     * \u003cli\u003e  it is a combining mark\\n     * \u003cli\u003e  it is a non-spacing mark\\n     * \u003cli\u003e {@code isIdentifierIgnorable} returns\\n     * {@code true} for the character\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isJavaIdentifierPart(int)} method.\\n     *\\n     * @param   ch      the character to be tested.\\n     * @return {@code true} if the character may be part of a\\n     *          Java identifier; {@code false} otherwise.\\n     * @see     Character#isIdentifierIgnorable(char)\\n     * @see     Character#isJavaIdentifierStart(char)\\n     * @see     Character#isLetterOrDigit(char)\\n     * @see     Character#isUnicodeIdentifierPart(char)\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "isJavaIdentifierPart(int)", "label": "isJavaIdentifierPart(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isJavaIdentifierPart(int codePoint)", "label": "public static boolean isJavaIdentifierPart(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isJavaIdentifierPart(int codePoint) {\\n        return CharacterData.of(codePoint).isJavaIdentifierPart(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isUnicodeIdentifierStart(char ch)", "label": "public static boolean isUnicodeIdentifierStart(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character is permissible as the\\n     * first character in a Unicode identifier.\\n     * \u003cp\u003e\\n     * A character may start a Unicode identifier if and only if\\n     * one of the following conditions is true:\\n     * \u003cul\u003e\\n     * \u003cli\u003e {@link #isLetter(char) isLetter(ch)} returns {@code true}\\n     * \u003cli\u003e {@link #getType(char) getType(ch)} returns\\n     *      {@code LETTER_NUMBER}.\\n     * \u003cli\u003e it is an \u003ca href=\"http://www.unicode.org/reports/tr44/#Other_ID_Start\"\u003e\\n     *      {@code Other_ID_Start}\u003c/a\u003e character.\\n     * \u003c/ul\u003e\\n     * \u003cp\u003e\\n     * This method conforms to \u003ca href=\"https://unicode.org/reports/tr31/#R1\"\u003e\\n     * UAX31-R1: Default Identifiers\u003c/a\u003e requirement of the Unicode Standard,\\n     * with the following profile of UAX31:\\n     * \u003cpre\u003e\\n     * Start := ID_Start + \\\u0027VERTICAL TILDE\\\u0027 (U+2E2F)\\n     * \u003c/pre\u003e\\n     * {@code \\\u0027VERTICAL TILDE\\\u0027} is added to {@code Start} for backward\\n     * compatibility.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isUnicodeIdentifierStart(int)} method.\\n     *\\n     * @param   ch      the character to be tested.\\n     * @return  {@code true} if the character may start a Unicode\\n     *          identifier; {@code false} otherwise.\\n     * @see     Character#isJavaIdentifierStart(char)\\n     * @see     Character#isLetter(char)\\n     * @see     Character#isUnicodeIdentifierPart(char)\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "isUnicodeIdentifierStart(int)", "label": "isUnicodeIdentifierStart(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isUnicodeIdentifierStart(int codePoint)", "label": "public static boolean isUnicodeIdentifierStart(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isUnicodeIdentifierStart(int codePoint) {\\n        return CharacterData.of(codePoint).isUnicodeIdentifierStart(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isUnicodeIdentifierPart(char ch)", "label": "public static boolean isUnicodeIdentifierPart(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character may be part of a Unicode\\n     * identifier as other than the first character.\\n     * \u003cp\u003e\\n     * A character may be part of a Unicode identifier if and only if\\n     * one of the following statements is true:\\n     * \u003cul\u003e\\n     * \u003cli\u003e  it is a letter\\n     * \u003cli\u003e  it is a connecting punctuation character (such as {@code \\\u0027_\\\u0027})\\n     * \u003cli\u003e  it is a digit\\n     * \u003cli\u003e  it is a numeric letter (such as a Roman numeral character)\\n     * \u003cli\u003e  it is a combining mark\\n     * \u003cli\u003e  it is a non-spacing mark\\n     * \u003cli\u003e {@code isIdentifierIgnorable} returns\\n     * {@code true} for this character.\\n     * \u003cli\u003e it is an \u003ca href=\"http://www.unicode.org/reports/tr44/#Other_ID_Start\"\u003e\\n     *      {@code Other_ID_Start}\u003c/a\u003e character.\\n     * \u003cli\u003e it is an \u003ca href=\"http://www.unicode.org/reports/tr44/#Other_ID_Continue\"\u003e\\n     *      {@code Other_ID_Continue}\u003c/a\u003e character.\\n     * \u003c/ul\u003e\\n     * \u003cp\u003e\\n     * This method conforms to \u003ca href=\"https://unicode.org/reports/tr31/#R1\"\u003e\\n     * UAX31-R1: Default Identifiers\u003c/a\u003e requirement of the Unicode Standard,\\n     * with the following profile of UAX31:\\n     * \u003cpre\u003e\\n     * Continue := Start + ID_Continue + ignorable\\n     * Medial := empty\\n     * ignorable := isIdentifierIgnorable(char) returns true for the character\\n     * \u003c/pre\u003e\\n     * {@code ignorable} is added to {@code Continue} for backward\\n     * compatibility.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isUnicodeIdentifierPart(int)} method.\\n     *\\n     * @param   ch      the character to be tested.\\n     * @return  {@code true} if the character may be part of a\\n     *          Unicode identifier; {@code false} otherwise.\\n     * @see     Character#isIdentifierIgnorable(char)\\n     * @see     Character#isJavaIdentifierPart(char)\\n     * @see     Character#isLetterOrDigit(char)\\n     * @see     Character#isUnicodeIdentifierStart(char)\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "isUnicodeIdentifierPart(int)", "label": "isUnicodeIdentifierPart(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isUnicodeIdentifierPart(int codePoint)", "label": "public static boolean isUnicodeIdentifierPart(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isUnicodeIdentifierPart(int codePoint) {\\n        return CharacterData.of(codePoint).isUnicodeIdentifierPart(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isIdentifierIgnorable(char ch)", "label": "public static boolean isIdentifierIgnorable(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character should be regarded as\\n     * an ignorable character in a Java identifier or a Unicode identifier.\\n     * \u003cp\u003e\\n     * The following Unicode characters are ignorable in a Java identifier\\n     * or a Unicode identifier:\\n     * \u003cul\u003e\\n     * \u003cli\u003eISO control characters that are not whitespace\\n     * \u003cul\u003e\\n     * \u003cli\u003e{@code \\\u0027\\\\u005Cu0000\\\u0027} through {@code \\\u0027\\\\u005Cu0008\\\u0027}\\n     * \u003cli\u003e{@code \\\u0027\\\\u005Cu000E\\\u0027} through {@code \\\u0027\\\\u005Cu001B\\\u0027}\\n     * \u003cli\u003e{@code \\\u0027\\\\u005Cu007F\\\u0027} through {@code \\\u0027\\\\u005Cu009F\\\u0027}\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cli\u003eall characters that have the {@code FORMAT} general\\n     * category value\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isIdentifierIgnorable(int)} method.\\n     *\\n     * @param   ch      the character to be tested.\\n     * @return  {@code true} if the character is an ignorable control\\n     *          character that may be part of a Java or Unicode identifier;\\n     *           {@code false} otherwise.\\n     * @see     Character#isJavaIdentifierPart(char)\\n     * @see     Character#isUnicodeIdentifierPart(char)\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "isIdentifierIgnorable(int)", "label": "isIdentifierIgnorable(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isIdentifierIgnorable(int codePoint)", "label": "public static boolean isIdentifierIgnorable(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isIdentifierIgnorable(int codePoint) {\\n        return CharacterData.of(codePoint).isIdentifierIgnorable(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static char toLowerCase(char ch)", "label": "public static char toLowerCase(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Converts the character argument to lowercase using case\\n     * mapping information from the UnicodeData file.\\n     * \u003cp\u003e\\n     * Note that\\n     * {@code Character.isLowerCase(Character.toLowerCase(ch))}\\n     * does not always return {@code true} for some ranges of\\n     * characters, particularly those that are symbols or ideographs.\\n     *\\n     * \u003cp\u003eIn general, {@link String#toLowerCase()} should be used to map\\n     * characters to lowercase. {@code String} case mapping methods\\n     * have several benefits over {@code Character} case mapping methods.\\n     * {@code String} case mapping methods can perform locale-sensitive\\n     * mappings, context-sensitive mappings, and 1:M character mappings, whereas\\n     * the {@code Character} case mapping methods cannot.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #toLowerCase(int)} method.\\n     *\\n     * @param   ch   the character to be converted.\\n     * @return  the lowercase equivalent of the character, if any;\\n     *          otherwise, the character itself.\\n     * @see     Character#isLowerCase(char)\\n     * @see     String#toLowerCase()\\n     \u0027}"}, {"color": "#97c2fc", "id": "toLowerCase(int)", "label": "toLowerCase(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int toLowerCase(int codePoint)", "label": "public static int toLowerCase(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static int toLowerCase(int codePoint) {\\n        return CharacterData.of(codePoint).toLowerCase(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static char toUpperCase(char ch)", "label": "public static char toUpperCase(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Converts the character argument to uppercase using case mapping\\n     * information from the UnicodeData file.\\n     * \u003cp\u003e\\n     * Note that\\n     * {@code Character.isUpperCase(Character.toUpperCase(ch))}\\n     * does not always return {@code true} for some ranges of\\n     * characters, particularly those that are symbols or ideographs.\\n     *\\n     * \u003cp\u003eIn general, {@link String#toUpperCase()} should be used to map\\n     * characters to uppercase. {@code String} case mapping methods\\n     * have several benefits over {@code Character} case mapping methods.\\n     * {@code String} case mapping methods can perform locale-sensitive\\n     * mappings, context-sensitive mappings, and 1:M character mappings, whereas\\n     * the {@code Character} case mapping methods cannot.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #toUpperCase(int)} method.\\n     *\\n     * @param   ch   the character to be converted.\\n     * @return  the uppercase equivalent of the character, if any;\\n     *          otherwise, the character itself.\\n     * @see     Character#isUpperCase(char)\\n     * @see     String#toUpperCase()\\n     \u0027}"}, {"color": "#97c2fc", "id": "toUpperCase(int)", "label": "toUpperCase(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int toUpperCase(int codePoint)", "label": "public static int toUpperCase(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static int toUpperCase(int codePoint) {\\n        return CharacterData.of(codePoint).toUpperCase(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static char toTitleCase(char ch)", "label": "public static char toTitleCase(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Converts the character argument to titlecase using case mapping\\n     * information from the UnicodeData file. If a character has no\\n     * explicit titlecase mapping and is not itself a titlecase char\\n     * according to UnicodeData, then the uppercase mapping is\\n     * returned as an equivalent titlecase mapping. If the\\n     * {@code char} argument is already a titlecase\\n     * {@code char}, the same {@code char} value will be\\n     * returned.\\n     * \u003cp\u003e\\n     * Note that\\n     * {@code Character.isTitleCase(Character.toTitleCase(ch))}\\n     * does not always return {@code true} for some ranges of\\n     * characters.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #toTitleCase(int)} method.\\n     *\\n     * @param   ch   the character to be converted.\\n     * @return  the titlecase equivalent of the character, if any;\\n     *          otherwise, the character itself.\\n     * @see     Character#isTitleCase(char)\\n     * @see     Character#toLowerCase(char)\\n     * @see     Character#toUpperCase(char)\\n     * @since   1.0.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "toTitleCase(int)", "label": "toTitleCase(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int toTitleCase(int codePoint)", "label": "public static int toTitleCase(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static int toTitleCase(int codePoint) {\\n        return CharacterData.of(codePoint).toTitleCase(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static int digit(char ch, int radix)", "label": "public static int digit(char ch, int radix)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the numeric value of the character {@code ch} in the\\n     * specified radix.\\n     * \u003cp\u003e\\n     * If the radix is not in the range {@code MIN_RADIX} \u0026le;\\n     * {@code radix} \u0026le; {@code MAX_RADIX} or if the\\n     * value of {@code ch} is not a valid digit in the specified\\n     * radix, {@code -1} is returned. A character is a valid digit\\n     * if at least one of the following is true:\\n     * \u003cul\u003e\\n     * \u003cli\u003eThe method {@code isDigit} is {@code true} of the character\\n     *     and the Unicode decimal digit value of the character (or its\\n     *     single-character decomposition) is less than the specified radix.\\n     *     In this case the decimal digit value is returned.\\n     * \u003cli\u003eThe character is one of the uppercase Latin letters\\n     *     {@code \\\u0027A\\\u0027} through {@code \\\u0027Z\\\u0027} and its code is less than\\n     *     {@code radix + \\\u0027A\\\u0027 - 10}.\\n     *     In this case, {@code ch - \\\u0027A\\\u0027 + 10}\\n     *     is returned.\\n     * \u003cli\u003eThe character is one of the lowercase Latin letters\\n     *     {@code \\\u0027a\\\u0027} through {@code \\\u0027z\\\u0027} and its code is less than\\n     *     {@code radix + \\\u0027a\\\u0027 - 10}.\\n     *     In this case, {@code ch - \\\u0027a\\\u0027 + 10}\\n     *     is returned.\\n     * \u003cli\u003eThe character is one of the fullwidth uppercase Latin letters A\\n     *     ({@code \\\u0027\\\\u005CuFF21\\\u0027}) through Z ({@code \\\u0027\\\\u005CuFF3A\\\u0027})\\n     *     and its code is less than\\n     *     {@code radix + \\\u0027\\\\u005CuFF21\\\u0027 - 10}.\\n     *     In this case, {@code ch - \\\u0027\\\\u005CuFF21\\\u0027 + 10}\\n     *     is returned.\\n     * \u003cli\u003eThe character is one of the fullwidth lowercase Latin letters a\\n     *     ({@code \\\u0027\\\\u005CuFF41\\\u0027}) through z ({@code \\\u0027\\\\u005CuFF5A\\\u0027})\\n     *     and its code is less than\\n     *     {@code radix + \\\u0027\\\\u005CuFF41\\\u0027 - 10}.\\n     *     In this case, {@code ch - \\\u0027\\\\u005CuFF41\\\u0027 + 10}\\n     *     is returned.\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #digit(int, int)} method.\\n     *\\n     * @param   ch      the character to be converted.\\n     * @param   radix   the radix.\\n     * @return  the numeric value represented by the character in the\\n     *          specified radix.\\n     * @see     Character#forDigit(int, int)\\n     * @see     Character#isDigit(char)\\n     \u0027}"}, {"color": "#97c2fc", "id": "digit(int", "label": "digit(int", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int digit(int codePoint, int radix)", "label": "public static int digit(int codePoint, int radix)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static int digit(int codePoint, int radix) {\\n        return CharacterData.of(codePoint).digit(codePoint, radix);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static int getNumericValue(char ch)", "label": "public static int getNumericValue(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the {@code int} value that the specified Unicode\\n     * character represents. For example, the character\\n     * {@code \\\u0027\\\\u005Cu216C\\\u0027} (the roman numeral fifty) will return\\n     * an int with a value of 50.\\n     * \u003cp\u003e\\n     * The letters A-Z in their uppercase ({@code \\\u0027\\\\u005Cu0041\\\u0027} through\\n     * {@code \\\u0027\\\\u005Cu005A\\\u0027}), lowercase\\n     * ({@code \\\u0027\\\\u005Cu0061\\\u0027} through {@code \\\u0027\\\\u005Cu007A\\\u0027}), and\\n     * full width variant ({@code \\\u0027\\\\u005CuFF21\\\u0027} through\\n     * {@code \\\u0027\\\\u005CuFF3A\\\u0027} and {@code \\\u0027\\\\u005CuFF41\\\u0027} through\\n     * {@code \\\u0027\\\\u005CuFF5A\\\u0027}) forms have numeric values from 10\\n     * through 35. This is independent of the Unicode specification,\\n     * which does not assign numeric values to these {@code char}\\n     * values.\\n     * \u003cp\u003e\\n     * If the character does not have a numeric value, then -1 is returned.\\n     * If the character has a numeric value that cannot be represented as a\\n     * nonnegative integer (for example, a fractional value), then -2\\n     * is returned.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #getNumericValue(int)} method.\\n     *\\n     * @param   ch      the character to be converted.\\n     * @return  the numeric value of the character, as a nonnegative {@code int}\\n     *          value; -2 if the character has a numeric value but the value\\n     *          can not be represented as a nonnegative {@code int} value;\\n     *          -1 if the character has no numeric value.\\n     * @see     Character#forDigit(int, int)\\n     * @see     Character#isDigit(char)\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "getNumericValue(int)", "label": "getNumericValue(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int getNumericValue(int codePoint)", "label": "public static int getNumericValue(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static int getNumericValue(int codePoint) {\\n        return CharacterData.of(codePoint).getNumericValue(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isSpaceChar(char ch)", "label": "public static boolean isSpaceChar(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character is a Unicode space character.\\n     * A character is considered to be a space character if and only if\\n     * it is specified to be a space character by the Unicode Standard. This\\n     * method returns true if the character\\\u0027s general category type is any of\\n     * the following:\\n     * \u003cul\u003e\\n     * \u003cli\u003e {@code SPACE_SEPARATOR}\\n     * \u003cli\u003e {@code LINE_SEPARATOR}\\n     * \u003cli\u003e {@code PARAGRAPH_SEPARATOR}\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isSpaceChar(int)} method.\\n     *\\n     * @param   ch      the character to be tested.\\n     * @return  {@code true} if the character is a space character;\\n     *          {@code false} otherwise.\\n     * @see     Character#isWhitespace(char)\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "isSpaceChar(int)", "label": "isSpaceChar(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isSpaceChar(int codePoint)", "label": "public static boolean isSpaceChar(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isSpaceChar(int codePoint) {\\n        return ((((1 \u003c\u003c Character.SPACE_SEPARATOR) |\\n                  (1 \u003c\u003c Character.LINE_SEPARATOR) |\\n                  (1 \u003c\u003c Character.PARAGRAPH_SEPARATOR)) \u003e\u003e getType(codePoint)) \u0026 1)\\n            != 0;\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isWhitespace(char ch)", "label": "public static boolean isWhitespace(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character is white space according to Java.\\n     * A character is a Java whitespace character if and only if it satisfies\\n     * one of the following criteria:\\n     * \u003cul\u003e\\n     * \u003cli\u003e It is a Unicode space character ({@code SPACE_SEPARATOR},\\n     *      {@code LINE_SEPARATOR}, or {@code PARAGRAPH_SEPARATOR})\\n     *      but is not also a non-breaking space ({@code \\\u0027\\\\u005Cu00A0\\\u0027},\\n     *      {@code \\\u0027\\\\u005Cu2007\\\u0027}, {@code \\\u0027\\\\u005Cu202F\\\u0027}).\\n     * \u003cli\u003e It is {@code \\\u0027\\\\u005Ct\\\u0027}, U+0009 HORIZONTAL TABULATION.\\n     * \u003cli\u003e It is {@code \\\u0027\\\\u005Cn\\\u0027}, U+000A LINE FEED.\\n     * \u003cli\u003e It is {@code \\\u0027\\\\u005Cu000B\\\u0027}, U+000B VERTICAL TABULATION.\\n     * \u003cli\u003e It is {@code \\\u0027\\\\u005Cf\\\u0027}, U+000C FORM FEED.\\n     * \u003cli\u003e It is {@code \\\u0027\\\\u005Cr\\\u0027}, U+000D CARRIAGE RETURN.\\n     * \u003cli\u003e It is {@code \\\u0027\\\\u005Cu001C\\\u0027}, U+001C FILE SEPARATOR.\\n     * \u003cli\u003e It is {@code \\\u0027\\\\u005Cu001D\\\u0027}, U+001D GROUP SEPARATOR.\\n     * \u003cli\u003e It is {@code \\\u0027\\\\u005Cu001E\\\u0027}, U+001E RECORD SEPARATOR.\\n     * \u003cli\u003e It is {@code \\\u0027\\\\u005Cu001F\\\u0027}, U+001F UNIT SEPARATOR.\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isWhitespace(int)} method.\\n     *\\n     * @param   ch the character to be tested.\\n     * @return  {@code true} if the character is a Java whitespace\\n     *          character; {@code false} otherwise.\\n     * @see     Character#isSpaceChar(char)\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "isWhitespace(int)", "label": "isWhitespace(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isWhitespace(int codePoint)", "label": "public static boolean isWhitespace(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isWhitespace(int codePoint) {\\n        return CharacterData.of(codePoint).isWhitespace(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isISOControl(char ch)", "label": "public static boolean isISOControl(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character is an ISO control\\n     * character.  A character is considered to be an ISO control\\n     * character if its code is in the range {@code \\\u0027\\\\u005Cu0000\\\u0027}\\n     * through {@code \\\u0027\\\\u005Cu001F\\\u0027} or in the range\\n     * {@code \\\u0027\\\\u005Cu007F\\\u0027} through {@code \\\u0027\\\\u005Cu009F\\\u0027}.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isISOControl(int)} method.\\n     *\\n     * @param   ch      the character to be tested.\\n     * @return  {@code true} if the character is an ISO control character;\\n     *          {@code false} otherwise.\\n     *\\n     * @see     Character#isSpaceChar(char)\\n     * @see     Character#isWhitespace(char)\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "isISOControl(int)", "label": "isISOControl(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isISOControl(int codePoint)", "label": "public static boolean isISOControl(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Determines if the referenced character (Unicode code point) is an ISO control\\n     * character.  A character is considered to be an ISO control\\n     * character if its code is in the range {@code \u0027\\\\u005Cu0000\u0027}\\n     * through {@code \u0027\\\\u005Cu001F\u0027} or in the range\\n     * {@code \u0027\\\\u005Cu007F\u0027} through {@code \u0027\\\\u005Cu009F\u0027}.\\n     *\\n     * @param   codePoint the character (Unicode code point) to be tested.\\n     * @return  {@code true} if the character is an ISO control character;\\n     *          {@code false} otherwise.\\n     * @see     Character#isSpaceChar(int)\\n     * @see     Character#isWhitespace(int)\\n     * @since   1.5\\n     \"}"}, {"color": "#97c2fc", "id": "public static int getType(char ch)", "label": "public static int getType(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a value indicating a character\\\u0027s general category.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #getType(int)} method.\\n     *\\n     * @param   ch      the character to be tested.\\n     * @return  a value of type {@code int} representing the\\n     *          character\\\u0027s general category.\\n     * @see     Character#COMBINING_SPACING_MARK\\n     * @see     Character#CONNECTOR_PUNCTUATION\\n     * @see     Character#CONTROL\\n     * @see     Character#CURRENCY_SYMBOL\\n     * @see     Character#DASH_PUNCTUATION\\n     * @see     Character#DECIMAL_DIGIT_NUMBER\\n     * @see     Character#ENCLOSING_MARK\\n     * @see     Character#END_PUNCTUATION\\n     * @see     Character#FINAL_QUOTE_PUNCTUATION\\n     * @see     Character#FORMAT\\n     * @see     Character#INITIAL_QUOTE_PUNCTUATION\\n     * @see     Character#LETTER_NUMBER\\n     * @see     Character#LINE_SEPARATOR\\n     * @see     Character#LOWERCASE_LETTER\\n     * @see     Character#MATH_SYMBOL\\n     * @see     Character#MODIFIER_LETTER\\n     * @see     Character#MODIFIER_SYMBOL\\n     * @see     Character#NON_SPACING_MARK\\n     * @see     Character#OTHER_LETTER\\n     * @see     Character#OTHER_NUMBER\\n     * @see     Character#OTHER_PUNCTUATION\\n     * @see     Character#OTHER_SYMBOL\\n     * @see     Character#PARAGRAPH_SEPARATOR\\n     * @see     Character#PRIVATE_USE\\n     * @see     Character#SPACE_SEPARATOR\\n     * @see     Character#START_PUNCTUATION\\n     * @see     Character#SURROGATE\\n     * @see     Character#TITLECASE_LETTER\\n     * @see     Character#UNASSIGNED\\n     * @see     Character#UPPERCASE_LETTER\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "getType(int)", "label": "getType(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int getType(int codePoint)", "label": "public static int getType(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static int getType(int codePoint) {\\n        return CharacterData.of(codePoint).getType(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static char forDigit(int digit, int radix)", "label": "public static char forDigit(int digit, int radix)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Determines the character representation for a specific digit in\\n     * the specified radix. If the value of {@code radix} is not a\\n     * valid radix, or the value of {@code digit} is not a valid\\n     * digit in the specified radix, the null character\\n     * ({@code \u0027\\\\u005Cu0000\u0027}) is returned.\\n     * \u003cp\u003e\\n     * The {@code radix} argument is valid if it is greater than or\\n     * equal to {@code MIN_RADIX} and less than or equal to\\n     * {@code MAX_RADIX}. The {@code digit} argument is valid if\\n     * {@code 0 \u003c= digit \u003c radix}.\\n     * \u003cp\u003e\\n     * If the digit is less than 10, then\\n     * {@code \u00270\u0027 + digit} is returned. Otherwise, the value\\n     * {@code \u0027a\u0027 + digit - 10} is returned.\\n     *\\n     * @param   digit   the number to convert to a character.\\n     * @param   radix   the radix.\\n     * @return  the {@code char} representation of the specified digit\\n     *          in the specified radix.\\n     * @see     Character#MIN_RADIX\\n     * @see     Character#MAX_RADIX\\n     * @see     Character#digit(char, int)\\n     \"}"}, {"color": "#97c2fc", "id": "public static byte getDirectionality(char ch)", "label": "public static byte getDirectionality(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the Unicode directionality property for the given\\n     * character.  Character directionality is used to calculate the\\n     * visual ordering of text. The directionality value of undefined\\n     * {@code char} values is {@code DIRECTIONALITY_UNDEFINED}.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #getDirectionality(int)} method.\\n     *\\n     * @param  ch {@code char} for which the directionality property\\n     *            is requested.\\n     * @return the directionality property of the {@code char} value.\\n     *\\n     * @see Character#DIRECTIONALITY_UNDEFINED\\n     * @see Character#DIRECTIONALITY_LEFT_TO_RIGHT\\n     * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT\\n     * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC\\n     * @see Character#DIRECTIONALITY_EUROPEAN_NUMBER\\n     * @see Character#DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR\\n     * @see Character#DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR\\n     * @see Character#DIRECTIONALITY_ARABIC_NUMBER\\n     * @see Character#DIRECTIONALITY_COMMON_NUMBER_SEPARATOR\\n     * @see Character#DIRECTIONALITY_NONSPACING_MARK\\n     * @see Character#DIRECTIONALITY_BOUNDARY_NEUTRAL\\n     * @see Character#DIRECTIONALITY_PARAGRAPH_SEPARATOR\\n     * @see Character#DIRECTIONALITY_SEGMENT_SEPARATOR\\n     * @see Character#DIRECTIONALITY_WHITESPACE\\n     * @see Character#DIRECTIONALITY_OTHER_NEUTRALS\\n     * @see Character#DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING\\n     * @see Character#DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE\\n     * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING\\n     * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE\\n     * @see Character#DIRECTIONALITY_POP_DIRECTIONAL_FORMAT\\n     * @see Character#DIRECTIONALITY_LEFT_TO_RIGHT_ISOLATE\\n     * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT_ISOLATE\\n     * @see Character#DIRECTIONALITY_FIRST_STRONG_ISOLATE\\n     * @see Character#DIRECTIONALITY_POP_DIRECTIONAL_ISOLATE\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "getDirectionality(int)", "label": "getDirectionality(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static byte getDirectionality(int codePoint)", "label": "public static byte getDirectionality(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static byte getDirectionality(int codePoint) {\\n        return CharacterData.of(codePoint).getDirectionality(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isMirrored(char ch)", "label": "public static boolean isMirrored(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines whether the character is mirrored according to the\\n     * Unicode specification.  Mirrored characters should have their\\n     * glyphs horizontally mirrored when displayed in text that is\\n     * right-to-left.  For example, {@code \\\u0027\\\\u005Cu0028\\\u0027} LEFT\\n     * PARENTHESIS is semantically defined to be an \u003ci\u003eopening\\n     * parenthesis\u003c/i\u003e.  This will appear as a \"(\" in text that is\\n     * left-to-right but as a \")\" in text that is right-to-left.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isMirrored(int)} method.\\n     *\\n     * @param  ch {@code char} for which the mirrored property is requested\\n     * @return {@code true} if the char is mirrored, {@code false}\\n     *         if the {@code char} is not mirrored or is not defined.\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "isMirrored(int)", "label": "isMirrored(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isMirrored(int codePoint)", "label": "public static boolean isMirrored(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isMirrored(int codePoint) {\\n        return CharacterData.of(codePoint).isMirrored(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public int compareTo(Character anotherCharacter)", "label": "public int compareTo(Character anotherCharacter)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code Character} objects numerically.\\n     *\\n     * @param   anotherCharacter   the {@code Character} to be compared.\\n     * @return  the value {@code 0} if the argument {@code Character}\\n     *          is equal to this {@code Character}; a value less than\\n     *          {@code 0} if this {@code Character} is numerically less\\n     *          than the {@code Character} argument; and a value greater than\\n     *          {@code 0} if this {@code Character} is numerically greater\\n     *          than the {@code Character} argument (unsigned comparison).\\n     *          Note that this is strictly a numerical comparison; it is not\\n     *          locale-dependent.\\n     * @since   1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int compare(char x, char y)", "label": "public static int compare(char x, char y)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code char} values numerically.\\n     * The value returned is identical to what would be returned by:\\n     * \u003cpre\u003e\\n     *    Character.valueOf(x).compareTo(Character.valueOf(y))\\n     * \u003c/pre\u003e\\n     *\\n     * @param  x the first {@code char} to compare\\n     * @param  y the second {@code char} to compare\\n     * @return the value {@code 0} if {@code x == y};\\n     *         a value less than {@code 0} if {@code x \u003c y}; and\\n     *         a value greater than {@code 0} if {@code x \u003e y}\\n     * @since 1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static char reverseBytes(char ch)", "label": "public static char reverseBytes(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value obtained by reversing the order of the bytes in the\\n     * specified {@code char} value.\\n     *\\n     * @param ch The {@code char} of which to reverse the byte order.\\n     * @return the value obtained by reversing (or, equivalently, swapping)\\n     *     the bytes in the specified {@code char} value.\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String getName(int codePoint)", "label": "public static String getName(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the Unicode name of the specified character\\n     * {@code codePoint}, or null if the code point is\\n     * {@link #UNASSIGNED unassigned}.\\n     * \u003cp\u003e\\n     * Note: if the specified character is not assigned a name by\\n     * the \u003ci\u003eUnicodeData\u003c/i\u003e file (part of the Unicode Character\\n     * Database maintained by the Unicode Consortium), the returned\\n     * name is the same as the result of expression:\\n     *\\n     * \u003cblockquote\u003e{@code\\n     *     Character.UnicodeBlock.of(codePoint).toString().replace(\\\u0027_\\\u0027, \\\u0027 \\\u0027)\\n     *     + \" \"\\n     *     + Integer.toHexString(codePoint).toUpperCase(Locale.ROOT);\\n     *\\n     * }\u003c/blockquote\u003e\\n     *\\n     * @param  codePoint the character (Unicode code point)\\n     *\\n     * @return the Unicode name of the specified character, or null if\\n     *         the code point is unassigned.\\n     *\\n     * @throws IllegalArgumentException if the specified\\n     *            {@code codePoint} is not a valid Unicode\\n     *            code point.\\n     *\\n     * @since 1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "UNASSIGNED", "label": "UNASSIGNED", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int codePointOf(String name)", "label": "public static int codePointOf(String name)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the code point value of the Unicode character specified by\\n     * the given Unicode character name.\\n     * \u003cp\u003e\\n     * Note: if a character is not assigned a name by the \u003ci\u003eUnicodeData\u003c/i\u003e\\n     * file (part of the Unicode Character Database maintained by the Unicode\\n     * Consortium), its name is defined as the result of expression:\\n     *\\n     * \u003cblockquote\u003e{@code\\n     *     Character.UnicodeBlock.of(codePoint).toString().replace(\\\u0027_\\\u0027, \\\u0027 \\\u0027)\\n     *     + \" \"\\n     *     + Integer.toHexString(codePoint).toUpperCase(Locale.ROOT);\\n     *\\n     * }\u003c/blockquote\u003e\\n     * \u003cp\u003e\\n     * The {@code name} matching is case insensitive, with any leading and\\n     * trailing whitespace character removed.\\n     *\\n     * @param  name the Unicode character name\\n     *\\n     * @return the code point value of the character specified by its name.\\n     *\\n     * @throws IllegalArgumentException if the specified {@code name}\\n     *         is not a valid Unicode character name.\\n     * @throws NullPointerException if {@code name} is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static native String getNameImpl(int codePoint)", "label": "private static native String getNameImpl(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Implement getNameImpl() and codePointOfImpl() natively.\u0027}"}, {"color": "#97c2fc", "id": "public String toLowerCase()", "label": "public String toLowerCase()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Converts all of the characters in this {@code String} to lower\\n     * case using the rules of the default locale. This is equivalent to calling\\n     * {@code toLowerCase(Locale.getDefault())}.\\n     * \u003cp\u003e\\n     * \u003cb\u003eNote:\u003c/b\u003e This method is locale sensitive, and may produce unexpected\\n     * results if used for strings that are intended to be interpreted locale\\n     * independently.\\n     * Examples are programming language identifiers, protocol keys, and HTML\\n     * tags.\\n     * For instance, {@code \"TITLE\".toLowerCase()} in a Turkish locale\\n     * returns {@code \"t\\\\u005Cu0131tle\"}, where \\\u0027\\\\u005Cu0131\\\u0027 is the\\n     * LATIN SMALL LETTER DOTLESS I character.\\n     * To obtain correct results for locale insensitive strings, use\\n     * {@code toLowerCase(Locale.ROOT)}.\\n     *\\n     * @return  the {@code String}, converted to lowercase.\\n     * @see     java.lang.String#toLowerCase(Locale)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String toUpperCase(Locale locale)", "label": "public String toUpperCase(Locale locale)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Converts all of the characters in this {@code String} to upper\\n     * case using the rules of the given {@code Locale}. Case mapping is based\\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\\n     * class. Since case mappings are not always 1:1 char mappings, the resulting\\n     * {@code String} may be a different length than the original {@code String}.\\n     * \u003cp\u003e\\n     * Examples of locale-sensitive and 1:M case mappings are in the following table.\\n     *\\n     * \u003ctable class=\"plain\"\u003e\\n     * \u003ccaption style=\"display:none\"\u003eExamples of locale-sensitive and 1:M case mappings. Shows Language code of locale, lower case, upper case, and description.\u003c/caption\u003e\\n     * \u003cthead\u003e\\n     * \u003ctr\u003e\\n     *   \u003cth scope=\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\\n     *   \u003cth scope=\"col\"\u003eLower Case\u003c/th\u003e\\n     *   \u003cth scope=\"col\"\u003eUpper Case\u003c/th\u003e\\n     *   \u003cth scope=\"col\"\u003eDescription\u003c/th\u003e\\n     * \u003c/tr\u003e\\n     * \u003c/thead\u003e\\n     * \u003ctbody\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\\n     *   \u003cth scope=\"row\" style=\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0069\u003c/th\u003e\\n     *   \u003ctd\u003e\u0026#92;u0130\u003c/td\u003e\\n     *   \u003ctd\u003esmall letter i -\u0026gt; capital letter I with dot above\u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\\n     *   \u003cth scope=\"row\" style=\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0131\u003c/th\u003e\\n     *   \u003ctd\u003e\u0026#92;u0049\u003c/td\u003e\\n     *   \u003ctd\u003esmall letter dotless i -\u0026gt; capital letter I\u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e(all)\u003c/td\u003e\\n     *   \u003cth scope=\"row\" style=\"font-weight:normal; text-align:left\"\u003e\u0026#92;u00df\u003c/th\u003e\\n     *   \u003ctd\u003e\u0026#92;u0053 \u0026#92;u0053\u003c/td\u003e\\n     *   \u003ctd\u003esmall letter sharp s -\u0026gt; two letters: SS\u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e(all)\u003c/td\u003e\\n     *   \u003cth scope=\"row\" style=\"font-weight:normal; text-align:left\"\u003eFahrvergn\u0026uuml;gen\u003c/th\u003e\\n     *   \u003ctd\u003eFAHRVERGN\u0026Uuml;GEN\u003c/td\u003e\\n     *   \u003ctd\u003e\u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003c/tbody\u003e\\n     * \u003c/table\u003e\\n     * @param locale use the case transformation rules for this locale\\n     * @return the {@code String}, converted to uppercase.\\n     * @see     java.lang.String#toUpperCase()\\n     * @see     java.lang.String#toLowerCase()\\n     * @see     java.lang.String#toLowerCase(Locale)\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String toUpperCase()", "label": "public String toUpperCase()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Converts all of the characters in this {@code String} to upper\\n     * case using the rules of the default locale. This method is equivalent to\\n     * {@code toUpperCase(Locale.getDefault())}.\\n     * \u003cp\u003e\\n     * \u003cb\u003eNote:\u003c/b\u003e This method is locale sensitive, and may produce unexpected\\n     * results if used for strings that are intended to be interpreted locale\\n     * independently.\\n     * Examples are programming language identifiers, protocol keys, and HTML\\n     * tags.\\n     * For instance, {@code \"title\".toUpperCase()} in a Turkish locale\\n     * returns {@code \"T\\\\u005Cu0130TLE\"}, where \\\u0027\\\\u005Cu0130\\\u0027 is the\\n     * LATIN CAPITAL LETTER I WITH DOT ABOVE character.\\n     * To obtain correct results for locale insensitive strings, use\\n     * {@code toUpperCase(Locale.ROOT)}.\\n     *\\n     * @return  the {@code String}, converted to uppercase.\\n     * @see     java.lang.String#toUpperCase(Locale)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String trim()", "label": "public String trim()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a string whose value is this string, with all leading\\n     * and trailing space removed, where space is defined\\n     * as any character whose codepoint is less than or equal to\\n     * {@code \u0027U+0020\u0027} (the space character).\\n     * \u003cp\u003e\\n     * If this {@code String} object represents an empty character\\n     * sequence, or the first and last characters of character sequence\\n     * represented by this {@code String} object both have codes\\n     * that are not space (as defined above), then a\\n     * reference to this {@code String} object is returned.\\n     * \u003cp\u003e\\n     * Otherwise, if all characters in this string are space (as\\n     * defined above), then a  {@code String} object representing an\\n     * empty string is returned.\\n     * \u003cp\u003e\\n     * Otherwise, let \u003ci\u003ek\u003c/i\u003e be the index of the first character in the\\n     * string whose code is not a space (as defined above) and let\\n     * \u003ci\u003em\u003c/i\u003e be the index of the last character in the string whose code\\n     * is not a space (as defined above). A {@code String}\\n     * object is returned, representing the substring of this string that\\n     * begins with the character at index \u003ci\u003ek\u003c/i\u003e and ends with the\\n     * character at index \u003ci\u003em\u003c/i\u003e-that is, the result of\\n     * {@code this.substring(k, m + 1)}.\\n     * \u003cp\u003e\\n     * This method may be used to trim space (as defined above) from\\n     * the beginning and end of a string.\\n     *\\n     * @return  a string whose value is this string, with all leading\\n     *          and trailing space removed, or this string if it\\n     *          has no leading or trailing space.\\n     \"}"}, {"color": "#97c2fc", "id": "public String strip()", "label": "public String strip()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string whose value is this string, with all leading\\n     * and trailing {@link Character#isWhitespace(int) white space}\\n     * removed.\\n     * \u003cp\u003e\\n     * If this {@code String} object represents an empty string,\\n     * or if all code points in this string are\\n     * {@link Character#isWhitespace(int) white space}, then an empty string\\n     * is returned.\\n     * \u003cp\u003e\\n     * Otherwise, returns a substring of this string beginning with the first\\n     * code point that is not a {@link Character#isWhitespace(int) white space}\\n     * up to and including the last code point that is not a\\n     * {@link Character#isWhitespace(int) white space}.\\n     * \u003cp\u003e\\n     * This method may be used to strip\\n     * {@link Character#isWhitespace(int) white space} from\\n     * the beginning and end of a string.\\n     *\\n     * @return  a string whose value is this string, with all leading\\n     *          and trailing white space removed\\n     *\\n     * @see Character#isWhitespace(int)\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String stripLeading()", "label": "public String stripLeading()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string whose value is this string, with all leading\\n     * {@link Character#isWhitespace(int) white space} removed.\\n     * \u003cp\u003e\\n     * If this {@code String} object represents an empty string,\\n     * or if all code points in this string are\\n     * {@link Character#isWhitespace(int) white space}, then an empty string\\n     * is returned.\\n     * \u003cp\u003e\\n     * Otherwise, returns a substring of this string beginning with the first\\n     * code point that is not a {@link Character#isWhitespace(int) white space}\\n     * up to to and including the last code point of this string.\\n     * \u003cp\u003e\\n     * This method may be used to trim\\n     * {@link Character#isWhitespace(int) white space} from\\n     * the beginning of a string.\\n     *\\n     * @return  a string whose value is this string, with all leading white\\n     *          space removed\\n     *\\n     * @see Character#isWhitespace(int)\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String stripTrailing()", "label": "public String stripTrailing()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string whose value is this string, with all trailing\\n     * {@link Character#isWhitespace(int) white space} removed.\\n     * \u003cp\u003e\\n     * If this {@code String} object represents an empty string,\\n     * or if all characters in this string are\\n     * {@link Character#isWhitespace(int) white space}, then an empty string\\n     * is returned.\\n     * \u003cp\u003e\\n     * Otherwise, returns a substring of this string beginning with the first\\n     * code point of this string up to and including the last code point\\n     * that is not a {@link Character#isWhitespace(int) white space}.\\n     * \u003cp\u003e\\n     * This method may be used to trim\\n     * {@link Character#isWhitespace(int) white space} from\\n     * the end of a string.\\n     *\\n     * @return  a string whose value is this string, with all trailing white\\n     *          space removed\\n     *\\n     * @see Character#isWhitespace(int)\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isBlank()", "label": "public boolean isBlank()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if the string is empty or contains only\\n     * {@link Character#isWhitespace(int) white space} codepoints,\\n     * otherwise {@code false}.\\n     *\\n     * @return {@code true} if the string is empty or contains only\\n     *         {@link Character#isWhitespace(int) white space} codepoints,\\n     *         otherwise {@code false}\\n     *\\n     * @see Character#isWhitespace(int)\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Stream\u003cString\u003e lines()", "label": "public Stream\u003cString\u003e lines()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream of lines extracted from this string,\\n     * separated by line terminators.\\n     * \u003cp\u003e\\n     * A \u003ci\u003eline terminator\u003c/i\u003e is one of the following:\\n     * a line feed character {@code \"\\\\n\"} (U+000A),\\n     * a carriage return character {@code \"\\\\r\"} (U+000D),\\n     * or a carriage return followed immediately by a line feed\\n     * {@code \"\\\\r\\\\n\"} (U+000D U+000A).\\n     * \u003cp\u003e\\n     * A \u003ci\u003eline\u003c/i\u003e is either a sequence of zero or more characters\\n     * followed by a line terminator, or it is a sequence of one or\\n     * more characters followed by the end of the string. A\\n     * line does not include the line terminator.\\n     * \u003cp\u003e\\n     * The stream returned by this method contains the lines from\\n     * this string in the order in which they occur.\\n     *\\n     * @apiNote This definition of \u003ci\u003eline\u003c/i\u003e implies that an empty\\n     *          string has zero lines and that there is no empty line\\n     *          following a line terminator at the end of a string.\\n     *\\n     * @implNote This method provides better performance than\\n     *           split(\"\\\\R\") by supplying elements lazily and\\n     *           by faster search of new line terminators.\\n     *\\n     * @return  the stream of lines extracted from this string\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String indent(int n)", "label": "public String indent(int n)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Adjusts the indentation of each line of this string based on the value of\\n     * {@code n}, and normalizes line termination characters.\\n     * \u003cp\u003e\\n     * This string is conceptually separated into lines using\\n     * {@link String#lines()}. Each line is then adjusted as described below\\n     * and then suffixed with a line feed {@code \"\\\\n\"} (U+000A). The resulting\\n     * lines are then concatenated and returned.\\n     * \u003cp\u003e\\n     * If {@code n \u003e 0} then {@code n} spaces (U+0020) are inserted at the\\n     * beginning of each line.\\n     * \u003cp\u003e\\n     * If {@code n \u003c 0} then up to {@code n}\\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed\\n     * from the beginning of each line. If a given line does not contain\\n     * sufficient white space then all leading\\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed.\\n     * Each white space character is treated as a single character. In\\n     * particular, the tab character {@code \"\\\\t\"} (U+0009) is considered a\\n     * single character; it is not expanded.\\n     * \u003cp\u003e\\n     * If {@code n == 0} then the line remains unchanged. However, line\\n     * terminators are still normalized.\\n     *\\n     * @param n  number of leading\\n     *           {@linkplain Character#isWhitespace(int) white space characters}\\n     *           to add or remove\\n     *\\n     * @return string with indentation adjusted and line endings normalized\\n     *\\n     * @see String#lines()\\n     * @see String#isBlank()\\n     * @see Character#isWhitespace(int)\\n     *\\n     * @since 12\\n     \u0027}"}, {"color": "#97c2fc", "id": "lines()", "label": "lines()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public String stripIndent()", "label": "public String stripIndent()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string whose value is this string, with incidental\\n     * {@linkplain Character#isWhitespace(int) white space} removed from\\n     * the beginning and end of every line.\\n     * \u003cp\u003e\\n     * Incidental {@linkplain Character#isWhitespace(int) white space}\\n     * is often present in a text block to align the content with the opening\\n     * delimiter. For example, in the following code, dots represent incidental\\n     * {@linkplain Character#isWhitespace(int) white space}:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * String html = \"\"\"\\n     * ..............\u0026lt;html\u0026gt;\\n     * ..............    \u0026lt;body\u0026gt;\\n     * ..............        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\\n     * ..............    \u0026lt;/body\u0026gt;\\n     * ..............\u0026lt;/html\u0026gt;\\n     * ..............\"\"\";\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * This method treats the incidental\\n     * {@linkplain Character#isWhitespace(int) white space} as indentation to be\\n     * stripped, producing a string that preserves the relative indentation of\\n     * the content. Using | to visualize the start of each line of the string:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * |\u0026lt;html\u0026gt;\\n     * |    \u0026lt;body\u0026gt;\\n     * |        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\\n     * |    \u0026lt;/body\u0026gt;\\n     * |\u0026lt;/html\u0026gt;\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * First, the individual lines of this string are extracted. A \u003ci\u003eline\u003c/i\u003e\\n     * is a sequence of zero or more characters followed by either a line\\n     * terminator or the end of the string.\\n     * If the string has at least one line terminator, the last line consists\\n     * of the characters between the last terminator and the end of the string.\\n     * Otherwise, if the string has no terminators, the last line is the start\\n     * of the string to the end of the string, in other words, the entire\\n     * string.\\n     * A line does not include the line terminator.\\n     * \u003cp\u003e\\n     * Then, the \u003ci\u003eminimum indentation\u003c/i\u003e (min) is determined as follows:\\n     * \u003cul\u003e\\n     *   \u003cli\u003e\u003cp\u003eFor each non-blank line (as defined by {@link String#isBlank()}),\\n     *   the leading {@linkplain Character#isWhitespace(int) white space}\\n     *   characters are counted.\u003c/p\u003e\\n     *   \u003c/li\u003e\\n     *   \u003cli\u003e\u003cp\u003eThe leading {@linkplain Character#isWhitespace(int) white space}\\n     *   characters on the last line are also counted even if\\n     *   {@linkplain String#isBlank() blank}.\u003c/p\u003e\\n     *   \u003c/li\u003e\\n     * \u003c/ul\u003e\\n     * \u003cp\u003eThe \u003ci\u003emin\u003c/i\u003e value is the smallest of these counts.\\n     * \u003cp\u003e\\n     * For each {@linkplain String#isBlank() non-blank} line, \u003ci\u003emin\u003c/i\u003e leading\\n     * {@linkplain Character#isWhitespace(int) white space} characters are\\n     * removed, and any trailing {@linkplain Character#isWhitespace(int) white\\n     * space} characters are removed. {@linkplain String#isBlank() Blank} lines\\n     * are replaced with the empty string.\\n     *\\n     * \u003cp\u003e\\n     * Finally, the lines are joined into a new string, using the LF character\\n     * {@code \"\\\\n\"} (U+000A) to separate lines.\\n     *\\n     * @apiNote\\n     * This method\\\u0027s primary purpose is to shift a block of lines as far as\\n     * possible to the left, while preserving relative indentation. Lines\\n     * that were indented the least will thus have no leading\\n     * {@linkplain Character#isWhitespace(int) white space}.\\n     * The result will have the same number of line terminators as this string.\\n     * If this string ends with a line terminator then the result will end\\n     * with a line terminator.\\n     *\\n     * @implSpec\\n     * This method treats all {@linkplain Character#isWhitespace(int) white space}\\n     * characters as having equal width. As long as the indentation on every\\n     * line is consistently composed of the same character sequences, then the\\n     * result will be as described above.\\n     *\\n     * @return string with incidental indentation removed and line\\n     *         terminators normalized\\n     *\\n     * @see String#lines()\\n     * @see String#isBlank()\\n     * @see String#indent(int)\\n     * @see Character#isWhitespace(int)\\n     *\\n     * @since 15\\n     *\\n     \u0027}"}, {"color": "#97c2fc", "id": "isBlank()", "label": "isBlank()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public String translateEscapes()", "label": "public String translateEscapes()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string whose value is this string, with escape sequences\\n     * translated as if in a string literal.\\n     * \u003cp\u003e\\n     * Escape sequences are translated as follows;\\n     * \u003ctable class=\"striped\"\u003e\\n     *   \u003ccaption style=\"display:none\"\u003eTranslation\u003c/caption\u003e\\n     *   \u003cthead\u003e\\n     *   \u003ctr\u003e\\n     *     \u003cth scope=\"col\"\u003eEscape\u003c/th\u003e\\n     *     \u003cth scope=\"col\"\u003eName\u003c/th\u003e\\n     *     \u003cth scope=\"col\"\u003eTranslation\u003c/th\u003e\\n     *   \u003c/tr\u003e\\n     *   \u003c/thead\u003e\\n     *   \u003ctbody\u003e\\n     *   \u003ctr\u003e\\n     *     \u003cth scope=\"row\"\u003e{@code \\\\u005Cb}\u003c/th\u003e\\n     *     \u003ctd\u003ebackspace\u003c/td\u003e\\n     *     \u003ctd\u003e{@code U+0008}\u003c/td\u003e\\n     *   \u003c/tr\u003e\\n     *   \u003ctr\u003e\\n     *     \u003cth scope=\"row\"\u003e{@code \\\\u005Ct}\u003c/th\u003e\\n     *     \u003ctd\u003ehorizontal tab\u003c/td\u003e\\n     *     \u003ctd\u003e{@code U+0009}\u003c/td\u003e\\n     *   \u003c/tr\u003e\\n     *   \u003ctr\u003e\\n     *     \u003cth scope=\"row\"\u003e{@code \\\\u005Cn}\u003c/th\u003e\\n     *     \u003ctd\u003eline feed\u003c/td\u003e\\n     *     \u003ctd\u003e{@code U+000A}\u003c/td\u003e\\n     *   \u003c/tr\u003e\\n     *   \u003ctr\u003e\\n     *     \u003cth scope=\"row\"\u003e{@code \\\\u005Cf}\u003c/th\u003e\\n     *     \u003ctd\u003eform feed\u003c/td\u003e\\n     *     \u003ctd\u003e{@code U+000C}\u003c/td\u003e\\n     *   \u003c/tr\u003e\\n     *   \u003ctr\u003e\\n     *     \u003cth scope=\"row\"\u003e{@code \\\\u005Cr}\u003c/th\u003e\\n     *     \u003ctd\u003ecarriage return\u003c/td\u003e\\n     *     \u003ctd\u003e{@code U+000D}\u003c/td\u003e\\n     *   \u003c/tr\u003e\\n     *   \u003ctr\u003e\\n     *     \u003cth scope=\"row\"\u003e{@code \\\\u005Cs}\u003c/th\u003e\\n     *     \u003ctd\u003espace\u003c/td\u003e\\n     *     \u003ctd\u003e{@code U+0020}\u003c/td\u003e\\n     *   \u003c/tr\u003e\\n     *   \u003ctr\u003e\\n     *     \u003cth scope=\"row\"\u003e{@code \\\\u005C\"}\u003c/th\u003e\\n     *     \u003ctd\u003edouble quote\u003c/td\u003e\\n     *     \u003ctd\u003e{@code U+0022}\u003c/td\u003e\\n     *   \u003c/tr\u003e\\n     *   \u003ctr\u003e\\n     *     \u003cth scope=\"row\"\u003e{@code \\\\u005C\\\u0027}\u003c/th\u003e\\n     *     \u003ctd\u003esingle quote\u003c/td\u003e\\n     *     \u003ctd\u003e{@code U+0027}\u003c/td\u003e\\n     *   \u003c/tr\u003e\\n     *   \u003ctr\u003e\\n     *     \u003cth scope=\"row\"\u003e{@code \\\\u005C\\\\u005C}\u003c/th\u003e\\n     *     \u003ctd\u003ebackslash\u003c/td\u003e\\n     *     \u003ctd\u003e{@code U+005C}\u003c/td\u003e\\n     *   \u003c/tr\u003e\\n     *   \u003ctr\u003e\\n     *     \u003cth scope=\"row\"\u003e{@code \\\\u005C0 - \\\\u005C377}\u003c/th\u003e\\n     *     \u003ctd\u003eoctal escape\u003c/td\u003e\\n     *     \u003ctd\u003ecode point equivalents\u003c/td\u003e\\n     *   \u003c/tr\u003e\\n     *   \u003ctr\u003e\\n     *     \u003cth scope=\"row\"\u003e{@code \\\\u005C\u003cline-terminator\u003e}\u003c/th\u003e\\n     *     \u003ctd\u003econtinuation\u003c/td\u003e\\n     *     \u003ctd\u003ediscard\u003c/td\u003e\\n     *   \u003c/tr\u003e\\n     *   \u003c/tbody\u003e\\n     * \u003c/table\u003e\\n     *\\n     * @implNote\\n     * This method does \u003cem\u003enot\u003c/em\u003e translate Unicode escapes such as \"{@code \\\\u005cu2022}\".\\n     * Unicode escapes are translated by the Java compiler when reading input characters and\\n     * are not part of the string literal specification.\\n     *\\n     * @throws IllegalArgumentException when an escape sequence is malformed.\\n     *\\n     * @return String with escape sequences translated.\\n     *\\n     * @jls 3.10.7 Escape Sequences\\n     *\\n     * @since 15\\n     \u0027}"}, {"color": "#97c2fc", "id": "public R transform(Function\u003c? super String, ? extends R\u003e f)", "label": "public R transform(Function\u003c? super String, ? extends R\u003e f)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * This method allows the application of a function to {@code this}\\n     * string. The function should expect a single String argument\\n     * and produce an {@code R} result.\\n     * \u003cp\u003e\\n     * Any exception thrown by {@code f.apply()} will be propagated to the\\n     * caller.\\n     *\\n     * @param f    a function to apply\\n     *\\n     * @param \u003cR\u003e  the type of the result\\n     *\\n     * @return     the result of applying the function to this string\\n     *\\n     * @see java.util.function.Function\\n     *\\n     * @since 12\\n     \u0027}"}, {"color": "#97c2fc", "id": "public native char[] toCharArray()", "label": "public native char[] toCharArray()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public char[] toCharArray() {\\n        return isLatin1() ? StringLatin1.toChars(value)\\n                          : StringUTF16.toChars(value);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static String format(String format, Object... args)", "label": "public static String format(String format, Object... args)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a formatted string using the specified format string and\\n     * arguments.\\n     *\\n     * \u003cp\u003e The locale always used is the one returned by {@link\\n     * java.util.Locale#getDefault(java.util.Locale.Category)\\n     * Locale.getDefault(Locale.Category)} with\\n     * {@link java.util.Locale.Category#FORMAT FORMAT} category specified.\\n     *\\n     * @param  format\\n     *         A \u003ca href=\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\\n     *\\n     * @param  args\\n     *         Arguments referenced by the format specifiers in the format\\n     *         string.  If there are more arguments than format specifiers, the\\n     *         extra arguments are ignored.  The number of arguments is\\n     *         variable and may be zero.  The maximum number of arguments is\\n     *         limited by the maximum dimension of a Java array as defined by\\n     *         \u003ccite\u003eThe Java\u0026trade; Virtual Machine Specification\u003c/cite\u003e.\\n     *         The behaviour on a\\n     *         {@code null} argument depends on the \u003ca\\n     *         href=\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\\n     *\\n     * @throws  java.util.IllegalFormatException\\n     *          If a format string contains an illegal syntax, a format\\n     *          specifier that is incompatible with the given arguments,\\n     *          insufficient arguments given the format string, or other\\n     *          illegal conditions.  For specification of all possible\\n     *          formatting errors, see the \u003ca\\n     *          href=\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\\n     *          formatter class specification.\\n     *\\n     * @return  A formatted string\\n     *\\n     * @see  java.util.Formatter\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "getDefault(java.util.Locale.Category)", "label": "getDefault(java.util.Locale.Category)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "FORMAT", "label": "FORMAT", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static String format(Locale l, String format, Object... args)", "label": "public static String format(Locale l, String format, Object... args)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a formatted string using the specified locale, format string,\\n     * and arguments.\\n     *\\n     * @param  l\\n     *         The {@linkplain java.util.Locale locale} to apply during\\n     *         formatting.  If {@code l} is {@code null} then no localization\\n     *         is applied.\\n     *\\n     * @param  format\\n     *         A \u003ca href=\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\\n     *\\n     * @param  args\\n     *         Arguments referenced by the format specifiers in the format\\n     *         string.  If there are more arguments than format specifiers, the\\n     *         extra arguments are ignored.  The number of arguments is\\n     *         variable and may be zero.  The maximum number of arguments is\\n     *         limited by the maximum dimension of a Java array as defined by\\n     *         \u003ccite\u003eThe Java\u0026trade; Virtual Machine Specification\u003c/cite\u003e.\\n     *         The behaviour on a\\n     *         {@code null} argument depends on the\\n     *         \u003ca href=\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\\n     *\\n     * @throws  java.util.IllegalFormatException\\n     *          If a format string contains an illegal syntax, a format\\n     *          specifier that is incompatible with the given arguments,\\n     *          insufficient arguments given the format string, or other\\n     *          illegal conditions.  For specification of all possible\\n     *          formatting errors, see the \u003ca\\n     *          href=\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\\n     *          formatter class specification\\n     *\\n     * @return  A formatted string\\n     *\\n     * @see  java.util.Formatter\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String formatted(Object... args)", "label": "public String formatted(Object... args)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Formats using this string as the format string, and the supplied\\n     * arguments.\\n     *\\n     * @implSpec This method is equivalent to {@code String.format(this, args)}.\\n     *\\n     * @param  args\\n     *         Arguments referenced by the format specifiers in this string.\\n     *\\n     * @return  A formatted string\\n     *\\n     * @see  java.lang.String#format(String,Object...)\\n     * @see  java.util.Formatter\\n     *\\n     * @since 15\\n     *\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String valueOf(Object obj)", "label": "public static String valueOf(Object obj)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the string representation of the {@code Object} argument.\\n     *\\n     * @param   obj   an {@code Object}.\\n     * @return  if the argument is {@code null}, then a string equal to\\n     *          {@code \"null\"}; otherwise, the value of\\n     *          {@code obj.toString()} is returned.\\n     * @see     java.lang.Object#toString()\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String valueOf(char[] data)", "label": "public static String valueOf(char[] data)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the string representation of the {@code char} array\\n     * argument. The contents of the character array are copied; subsequent\\n     * modification of the character array does not affect the returned\\n     * string.\\n     *\\n     * @param   data     the character array.\\n     * @return  a {@code String} that contains the characters of the\\n     *          character array.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String valueOf(char[] data, int offset, int count)", "label": "public static String valueOf(char[] data, int offset, int count)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the string representation of a specific subarray of the\\n     * {@code char} array argument.\\n     * \u003cp\u003e\\n     * The {@code offset} argument is the index of the first\\n     * character of the subarray. The {@code count} argument\\n     * specifies the length of the subarray. The contents of the subarray\\n     * are copied; subsequent modification of the character array does not\\n     * affect the returned string.\\n     *\\n     * @param   data     the character array.\\n     * @param   offset   initial offset of the subarray.\\n     * @param   count    length of the subarray.\\n     * @return  a {@code String} that contains the characters of the\\n     *          specified subarray of the character array.\\n     * @exception IndexOutOfBoundsException if {@code offset} is\\n     *          negative, or {@code count} is negative, or\\n     *          {@code offset+count} is larger than\\n     *          {@code data.length}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String copyValueOf(char[] data, int offset, int count)", "label": "public static String copyValueOf(char[] data, int offset, int count)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Equivalent to {@link #valueOf(char[], int, int)}.\\n     *\\n     * @param   data     the character array.\\n     * @param   offset   initial offset of the subarray.\\n     * @param   count    length of the subarray.\\n     * @return  a {@code String} that contains the characters of the\\n     *          specified subarray of the character array.\\n     * @exception IndexOutOfBoundsException if {@code offset} is\\n     *          negative, or {@code count} is negative, or\\n     *          {@code offset+count} is larger than\\n     *          {@code data.length}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "valueOf(char", "label": "valueOf(char", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static String copyValueOf(char[] data)", "label": "public static String copyValueOf(char[] data)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Equivalent to {@link #valueOf(char[])}.\\n     *\\n     * @param   data   the character array.\\n     * @return  a {@code String} that contains the characters of the\\n     *          character array.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String valueOf(boolean b)", "label": "public static String valueOf(boolean b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the string representation of the {@code boolean} argument.\\n     *\\n     * @param   b   a {@code boolean}.\\n     * @return  if the argument is {@code true}, a string equal to\\n     *          {@code \"true\"} is returned; otherwise, a string equal to\\n     *          {@code \"false\"} is returned.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String valueOf(char c)", "label": "public static String valueOf(char c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the string representation of the {@code char}\\n     * argument.\\n     *\\n     * @param   c   a {@code char}.\\n     * @return  a string of length {@code 1} containing\\n     *          as its single character the argument {@code c}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String valueOf(int i)", "label": "public static String valueOf(int i)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the string representation of the {@code int} argument.\\n     * \u003cp\u003e\\n     * The representation is exactly the one returned by the\\n     * {@code Integer.toString} method of one argument.\\n     *\\n     * @param   i   an {@code int}.\\n     * @return  a string representation of the {@code int} argument.\\n     * @see     java.lang.Integer#toString(int, int)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String valueOf(long l)", "label": "public static String valueOf(long l)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the string representation of the {@code long} argument.\\n     * \u003cp\u003e\\n     * The representation is exactly the one returned by the\\n     * {@code Long.toString} method of one argument.\\n     *\\n     * @param   l   a {@code long}.\\n     * @return  a string representation of the {@code long} argument.\\n     * @see     java.lang.Long#toString(long)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String valueOf(float f)", "label": "public static String valueOf(float f)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the string representation of the {@code float} argument.\\n     * \u003cp\u003e\\n     * The representation is exactly the one returned by the\\n     * {@code Float.toString} method of one argument.\\n     *\\n     * @param   f   a {@code float}.\\n     * @return  a string representation of the {@code float} argument.\\n     * @see     java.lang.Float#toString(float)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String valueOf(double d)", "label": "public static String valueOf(double d)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the string representation of the {@code double} argument.\\n     * \u003cp\u003e\\n     * The representation is exactly the one returned by the\\n     * {@code Double.toString} method of one argument.\\n     *\\n     * @param   d   a {@code double}.\\n     * @return  a  string representation of the {@code double} argument.\\n     * @see     java.lang.Double#toString(double)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public native String intern()", "label": "public native String intern()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-added: Annotate native method as @FastNative.\u0027}"}, {"color": "#97c2fc", "id": "public String repeat(int count)", "label": "public String repeat(int count)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string whose value is the concatenation of this\\n     * string repeated {@code count} times.\\n     * \u003cp\u003e\\n     * If this string is empty or count is zero then the empty\\n     * string is returned.\\n     *\\n     * @param   count number of times to repeat\\n     *\\n     * @return  A string composed of this string repeated\\n     *          {@code count} times or the empty string if this\\n     *          string is empty or count is zero\\n     *\\n     * @throws  IllegalArgumentException if the {@code count} is\\n     *          negative.\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": " void getBytes(byte[] dst, int dstBegin, byte coder)", "label": " void getBytes(byte[] dst, int dstBegin, byte coder)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Copy character bytes from this string into dst starting at dstBegin.\\n     * This method doesn\u0027t perform any range checking.\\n     *\\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\\n     * coders are different, and dst is big enough (range check)\\n     *\\n     * @param dstBegin  the char index, not offset of byte[]\\n     * @param coder     the coder of dst[]\\n     \"}"}, {"color": "#97c2fc", "id": "private native void fillBytesLatin1(byte[] dst, int byteIndex)", "label": "private native void fillBytesLatin1(byte[] dst, int byteIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Fill the underlying characters into the byte buffer. No range check.\\n     * The caller should guarantee that dst is big enough for this operation.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private native void fillBytesUTF16(byte[] dst, int byteIndex)", "label": "private native void fillBytesUTF16(byte[] dst, int byteIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Fill the underlying characters into the byte buffer. No range check.\\n     * The caller should guarantee that dst is big enough for this operation.\\n     \u0027}"}, {"color": "#97c2fc", "id": " byte coder()", "label": " byte coder()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Android note: It returns UTF16 if the string has any 0x00 char.\\n     * See the difference between {@link StringLatin1#canEncode(int)} and\\n     * art::mirror::String::IsASCII(uint16_t) in string.h.\\n     \u0027}"}, {"color": "#97c2fc", "id": "canEncode(int)", "label": "canEncode(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.lang.StringLatin1", "label": "java.lang.StringLatin1", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public static int compareToUTF16(byte[] value, byte[] other, int len1, int len2)", "label": "public static int compareToUTF16(byte[] value, byte[] other, int len1, int len2)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Checks the boundary and then compares the byte arrays.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void inflate(byte[] src, int srcOff, char[] dst, int dstOff, int len)", "label": "public static void inflate(byte[] src, int srcOff, char[] dst, int dstOff, int len)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 inflatedCopy byte[] -\u003e char[]\u0027}"}, {"color": "#97c2fc", "id": "public static void inflate(byte[] src, int srcOff, byte[] dst, int dstOff, int len)", "label": "public static void inflate(byte[] src, int srcOff, byte[] dst, int dstOff, int len)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 inflatedCopy byte[] -\u003e byte[]\u0027}"}, {"color": "#97c2fc", "id": " static void checkIndex(int index, int length)", "label": " static void checkIndex(int index, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * StringIndexOutOfBoundsException  if {@code index} is\\n     * negative or greater than or equal to {@code length}.\\n     \u0027}"}, {"color": "#97c2fc", "id": " static void checkOffset(int offset, int length)", "label": " static void checkOffset(int offset, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * StringIndexOutOfBoundsException  if {@code offset}\\n     * is negative or greater than {@code length}.\\n     \u0027}"}, {"color": "#97c2fc", "id": " static void checkBoundsOffCount(int offset, int count, int length)", "label": " static void checkBoundsOffCount(int offset, int count, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Check {@code offset}, {@code count} against {@code 0} and {@code length}\\n     * bounds.\\n     *\\n     * @throws  StringIndexOutOfBoundsException\\n     *          If {@code offset} is negative, {@code count} is negative,\\n     *          or {@code offset} is greater than {@code length - count}\\n     \u0027}"}, {"color": "#97c2fc", "id": " static String valueOfCodePoint(int codePoint)", "label": " static String valueOfCodePoint(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the string representation of the {@code codePoint}\\n     * argument.\\n     *\\n     * @param   codePoint a {@code codePoint}.\\n     * @return  a string of length {@code 1} or {@code 2} containing\\n     *          as its single character the argument {@code codePoint}.\\n     * @throws IllegalArgumentException if the specified\\n     *          {@code codePoint} is not a {@linkplain Character#isValidCodePoint\\n     *          valid Unicode code point}.\\n     \u0027}"}, {"color": "#97c2fc", "id": " static void checkBoundsBeginEnd(int begin, int end, int length)", "label": " static void checkBoundsBeginEnd(int begin, int end, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Check {@code begin}, {@code end} against {@code 0} and {@code length}\\n     * bounds.\\n     *\\n     * @throws  StringIndexOutOfBoundsException\\n     *          If {@code begin} is negative, {@code begin} is greater than\\n     *          {@code end}, or {@code end} is greater than {@code length}.\\n     \u0027}"}]);
                  edges = new vis.DataSet([{"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int length()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isEmpty()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public native char charAt(int index)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int codePointAt(int index)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int codePointBefore(int index)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int codePointCount(int beginIndex, int endIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int offsetByCodePoints(int index, int codePointOffset)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void getChars(char[] dst, int dstBegin)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " native void getCharsNoCheck(int start, int end, char[] buffer, int index)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public byte[] getBytes(String charsetName) throws UnsupportedEncodingException"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public byte[] getBytes(Charset charset)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public byte[] getBytes()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean equals(Object anObject)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean contentEquals(StringBuffer sb)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean contentEquals(CharSequence cs)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean equalsIgnoreCase(String anotherString)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public native int compareTo(String anotherString)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int compareToIgnoreCase(String str)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean regionMatches(int toffset, String other, int ooffset, int len)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean startsWith(String prefix, int toffset)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean startsWith(String prefix)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean endsWith(String suffix)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int hashCode()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int indexOf(int ch)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int indexOf(int ch, int fromIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int indexOfSupplementary(int ch, int fromIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int lastIndexOf(int ch)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int lastIndexOf(int ch, int fromIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int lastIndexOfSupplementary(int ch, int fromIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int indexOf(String str)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int indexOf(String str, int fromIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static int indexOf(String source, String target, int fromIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static int indexOf(byte[] src, byte srcCoder, int srcCount, String tgtStr, int fromIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int lastIndexOf(String str)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int lastIndexOf(String str, int fromIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static int lastIndexOf(String source, String target, int fromIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static int lastIndexOf(byte[] src, byte srcCoder, int srcCount, String tgtStr, int fromIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static int lastIndexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String substring(int beginIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String substring(int beginIndex, int endIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private native String fastSubstring(int start, int length)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CharSequence subSequence(int beginIndex, int endIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public native String concat(String str)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String replace(char oldChar, char newChar)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private native String doReplace(char oldChar, char newChar)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean matches(String regex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean contains(CharSequence s)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String replaceFirst(String regex, String replacement)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String replaceAll(String regex, String replacement)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String replace(CharSequence target, CharSequence replacement)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String[] split(String regex, int limit)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String[] split(String regex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String join(CharSequence delimiter, CharSequence... elements)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toLowerCase(Locale locale)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toLowerCase()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toUpperCase(Locale locale)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toUpperCase()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String trim()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String strip()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String stripLeading()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String stripTrailing()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isBlank()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Stream\u003cString\u003e lines()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String indent(int n)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String stripIndent()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String translateEscapes()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public R transform(Function\u003c? super String, ? extends R\u003e f)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public IntStream chars()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public IntStream codePoints()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public native char[] toCharArray()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String format(String format, Object... args)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String format(Locale l, String format, Object... args)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String formatted(Object... args)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String valueOf(Object obj)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String valueOf(char[] data)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String valueOf(char[] data, int offset, int count)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String copyValueOf(char[] data, int offset, int count)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String copyValueOf(char[] data)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String valueOf(boolean b)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String valueOf(char c)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String valueOf(int i)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String valueOf(long l)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String valueOf(float f)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String valueOf(double d)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public native String intern()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String repeat(int count)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void getBytes(byte[] dst, int dstBegin, byte coder)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private native void fillBytesLatin1(byte[] dst, int byteIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private native void fillBytesUTF16(byte[] dst, int byteIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " byte coder()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static void checkIndex(int index, int length)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static void checkOffset(int offset, int length)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static void checkBoundsOffCount(int offset, int count, int length)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static String valueOfCodePoint(int codePoint)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static void checkBoundsBeginEnd(int begin, int end, int length)"}, {"arrows": "to", "from": "public int length()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isError()"}, {"arrows": "to", "from": "public boolean isEmpty()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "length()"}, {"arrows": "to", "from": "public int codePointAt(int index)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "length()"}, {"arrows": "to", "from": "public int codePointBefore(int index)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "length()"}, {"arrows": "to", "from": "java.lang.CharSequence", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int length()"}, {"arrows": "to", "from": "java.lang.CharSequence", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " char charAt(int index)"}, {"arrows": "to", "from": "java.lang.CharSequence", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean isEmpty()"}, {"arrows": "to", "from": "java.lang.CharSequence", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " CharSequence subSequence(int start, int end)"}, {"arrows": "to", "from": "java.lang.CharSequence", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.lang.CharSequence", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public IntStream chars()"}, {"arrows": "to", "from": "java.lang.CharSequence", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public IntStream codePoints()"}, {"arrows": "to", "from": "java.lang.CharSequence", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(CharSequence cs1, CharSequence cs2)"}, {"arrows": "to", "from": " boolean isEmpty()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "length()"}, {"arrows": "to", "from": "public String toString()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "LITTLE_ENDIAN"}, {"arrows": "to", "from": "public String toString()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "BIG_ENDIAN"}, {"arrows": "to", "from": "public byte[] getBytes(String charsetName) throws UnsupportedEncodingException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.charset.CharsetEncoder"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final Charset charset()"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final byte[] replacement()"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final CharsetEncoder replaceWith(byte[] newReplacement)"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void implReplaceWith(byte[] newReplacement)"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isLegalReplacement(byte[] repl)"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CodingErrorAction malformedInputAction()"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final CharsetEncoder onMalformedInput(CodingErrorAction newAction)"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void implOnMalformedInput(CodingErrorAction newAction)"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CodingErrorAction unmappableCharacterAction()"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final CharsetEncoder onUnmappableCharacter(CodingErrorAction newAction)"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void implOnUnmappableCharacter(CodingErrorAction newAction)"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final float averageBytesPerChar()"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final float maxBytesPerChar()"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final CoderResult encode(CharBuffer in, ByteBuffer out, boolean endOfInput)"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final CoderResult flush(ByteBuffer out)"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected CoderResult implFlush(ByteBuffer out)"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final CharsetEncoder reset()"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void implReset()"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected abstract CoderResult encodeLoop(CharBuffer in, ByteBuffer out)"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final ByteBuffer encode(CharBuffer in) throws CharacterCodingException"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean canEncode(char c)"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean canEncode(CharSequence cs)"}, {"arrows": "to", "from": "public final CharsetEncoder replaceWith(byte[] newReplacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "implReplaceWith"}, {"arrows": "to", "from": "public final CharsetEncoder replaceWith(byte[] newReplacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "maxBytesPerChar()"}, {"arrows": "to", "from": "public final CharsetEncoder replaceWith(byte[] newReplacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isLegalReplacement"}, {"arrows": "to", "from": "public final CharsetEncoder onMalformedInput(CodingErrorAction newAction)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "implOnMalformedInputimplOnMalformedInput"}, {"arrows": "to", "from": "public final CharsetEncoder onUnmappableCharacter(CodingErrorAction newAction)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "implOnUnmappableCharacterimplOnUnmappableCharacter"}, {"arrows": "to", "from": "public final CoderResult encode(CharBuffer in, ByteBuffer out, boolean endOfInput)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "OVERFLOW"}, {"arrows": "to", "from": "public final CoderResult encode(CharBuffer in, ByteBuffer out, boolean endOfInput)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.charset.CoderResult"}, {"arrows": "to", "from": "public final CoderResult encode(CharBuffer in, ByteBuffer out, boolean endOfInput)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "reset"}, {"arrows": "to", "from": "public final CoderResult encode(CharBuffer in, ByteBuffer out, boolean endOfInput)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "REPORT"}, {"arrows": "to", "from": "public final CoderResult encode(CharBuffer in, ByteBuffer out, boolean endOfInput)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "encodeLoop"}, {"arrows": "to", "from": "public final CoderResult encode(CharBuffer in, ByteBuffer out, boolean endOfInput)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNDERFLOW"}, {"arrows": "to", "from": "public final CoderResult encode(CharBuffer in, ByteBuffer out, boolean endOfInput)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "remaining"}, {"arrows": "to", "from": "public final CoderResult encode(CharBuffer in, ByteBuffer out, boolean endOfInput)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "length()"}, {"arrows": "to", "from": "java.nio.charset.CoderResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.nio.charset.CoderResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isUnderflow()"}, {"arrows": "to", "from": "java.nio.charset.CoderResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isOverflow()"}, {"arrows": "to", "from": "java.nio.charset.CoderResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isError()"}, {"arrows": "to", "from": "java.nio.charset.CoderResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isMalformed()"}, {"arrows": "to", "from": "java.nio.charset.CoderResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isUnmappable()"}, {"arrows": "to", "from": "java.nio.charset.CoderResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int length()"}, {"arrows": "to", "from": "java.nio.charset.CoderResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static CoderResult malformedForLength(int length)"}, {"arrows": "to", "from": "java.nio.charset.CoderResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static CoderResult unmappableForLength(int length)"}, {"arrows": "to", "from": "java.nio.charset.CoderResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void throwException() throws CharacterCodingException"}, {"arrows": "to", "from": "public void throwException() throws CharacterCodingException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "OVERFLOW"}, {"arrows": "to", "from": "public void throwException() throws CharacterCodingException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNDERFLOW"}, {"arrows": "to", "from": "java.nio.charset.CodingErrorAction", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static IllegalArgumentException createSameBufferException()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static IllegalArgumentException createCapacityException(int capacity)"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final int capacity()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final int position()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer position(int newPosition)"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private IllegalArgumentException createPositionException(int newPosition)"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final int limit()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer limit(int newLimit)"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private IllegalArgumentException createLimitException(int newLimit)"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer mark()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer reset()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer clear()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer flip()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer rewind()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final int remaining()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final boolean hasRemaining()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract boolean isReadOnly()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract boolean hasArray()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract Object array()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int arrayOffset()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract boolean isDirect()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract Buffer slice()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract Buffer slice(int index, int length)"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract Buffer duplicate()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract Object base()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final int nextGetIndex()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final int nextPutIndex()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final int checkIndex(int i)"}, {"arrows": "to", "from": "public Buffer flip()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compact"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static ByteBuffer allocateDirect(int capacity)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static ByteBuffer allocate(int capacity)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static ByteBuffer wrap(byte[] array, int offset, int length)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static ByteBuffer wrap(byte[] array)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer slice()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer slice(int index, int length)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer duplicate()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer asReadOnlyBuffer()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract byte get()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer put(byte b)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract byte get(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer put(int index, byte b)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ByteBuffer get(byte[] dst, int offset, int length)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ByteBuffer get(byte[] dst)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ByteBuffer get(int index, byte[] dst, int offset, int length)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ByteBuffer get(int index, byte[] dst)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ByteBuffer put(ByteBuffer src)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ByteBuffer put(int index, ByteBuffer src, int offset, int length)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ByteBuffer put(byte[] src, int offset, int length)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final ByteBuffer put(byte[] src)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ByteBuffer put(int index, byte[] src, int offset, int length)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ByteBuffer put(int index, byte[] src)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final boolean hasArray()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final byte[] array()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final int arrayOffset()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer position(int newPosition)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer limit(int newLimit)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer mark()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer reset()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer clear()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer flip()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer rewind()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer compact()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract boolean isDirect()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int hashCode()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean equals(Object ob)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int compareTo(ByteBuffer that)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int mismatch(ByteBuffer that)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final ByteOrder order()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final ByteBuffer order(ByteOrder bo)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final int alignmentOffset(int index, int unitSize)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final ByteBuffer alignedSlice(int unitSize)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract byte _get(int i)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract void _put(int i, byte b)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract char getChar()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer putChar(char value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract char getChar(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract char getCharUnchecked(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer putChar(int index, char value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract void putCharUnchecked(int index, char value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract CharBuffer asCharBuffer()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract short getShort()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer putShort(short value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract short getShort(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract short getShortUnchecked(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer putShort(int index, short value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract void putShortUnchecked(int index, short value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ShortBuffer asShortBuffer()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int getInt()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer putInt(int value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int getInt(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract int getIntUnchecked(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer putInt(int index, int value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract void putIntUnchecked(int index, int value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract IntBuffer asIntBuffer()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract long getLong()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer putLong(long value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract long getLong(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract long getLongUnchecked(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer putLong(int index, long value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract void putLongUnchecked(int index, long value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract LongBuffer asLongBuffer()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract float getFloat()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer putFloat(float value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract float getFloat(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract float getFloatUnchecked(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer putFloat(int index, float value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract void putFloatUnchecked(int index, float value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract FloatBuffer asFloatBuffer()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract double getDouble()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer putDouble(double value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract double getDouble(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract double getDoubleUnchecked(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer putDouble(int index, double value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract void putDoubleUnchecked(int index, double value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract DoubleBuffer asDoubleBuffer()"}, {"arrows": "to", "from": "public static ByteBuffer allocateDirect(int capacity)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "BIG_ENDIAN"}, {"arrows": "to", "from": "public static ByteBuffer allocateDirect(int capacity)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasArray"}, {"arrows": "to", "from": "java.nio.ByteOrder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static ByteOrder nativeOrder()"}, {"arrows": "to", "from": "java.nio.ByteOrder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "public static ByteBuffer allocate(int capacity)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "array"}, {"arrows": "to", "from": "public static ByteBuffer allocate(int capacity)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "arrayOffset"}, {"arrows": "to", "from": "public static ByteBuffer allocate(int capacity)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "BIG_ENDIAN"}, {"arrows": "to", "from": "public static ByteBuffer wrap(byte[] array, int offset, int length)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "array"}, {"arrows": "to", "from": "public static ByteBuffer wrap(byte[] array, int offset, int length)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "arrayOffset"}, {"arrows": "to", "from": "public static ByteBuffer wrap(byte[] array, int offset, int length)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "BIG_ENDIAN"}, {"arrows": "to", "from": "public static ByteBuffer wrap(byte[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "array"}, {"arrows": "to", "from": "public static ByteBuffer wrap(byte[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "arrayOffset"}, {"arrows": "to", "from": "public static ByteBuffer wrap(byte[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "BIG_ENDIAN"}, {"arrows": "to", "from": "public abstract ByteBuffer slice()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "BIG_ENDIAN"}, {"arrows": "to", "from": "public abstract ByteBuffer slice(int index, int length)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "limit()"}, {"arrows": "to", "from": "public abstract ByteBuffer slice(int index, int length)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "BIG_ENDIAN"}, {"arrows": "to", "from": "public abstract ByteBuffer duplicate()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "BIG_ENDIAN"}, {"arrows": "to", "from": "public abstract ByteBuffer asReadOnlyBuffer()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "duplicate"}, {"arrows": "to", "from": "public abstract ByteBuffer asReadOnlyBuffer()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "BIG_ENDIAN"}, {"arrows": "to", "from": "public ByteBuffer get(byte[] dst, int offset, int length)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.BufferUnderflowException"}, {"arrows": "to", "from": "public ByteBuffer put(ByteBuffer src)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.BufferOverflowException"}, {"arrows": "to", "from": "public ByteBuffer put(byte[] src, int offset, int length)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.BufferOverflowException"}, {"arrows": "to", "from": "public final boolean hasArray()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "array()"}, {"arrows": "to", "from": "public final boolean hasArray()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "arrayOffset()"}, {"arrows": "to", "from": "public final byte[] array()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasArray"}, {"arrows": "to", "from": "public final int arrayOffset()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasArray"}, {"arrows": "to", "from": "public int compareTo(ByteBuffer that)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compare(byte"}, {"arrows": "to", "from": "public int mismatch(ByteBuffer that)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "position()"}, {"arrows": "to", "from": "public int mismatch(ByteBuffer that)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "remaining()"}, {"arrows": "to", "from": "public final ByteOrder order()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.ByteOrder"}, {"arrows": "to", "from": "public final ByteBuffer order(ByteOrder bo)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "BIG_ENDIAN"}, {"arrows": "to", "from": "public final ByteBuffer order(ByteOrder bo)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "LITTLE_ENDIAN"}, {"arrows": "to", "from": "public final ByteBuffer alignedSlice(int unitSize)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "BIG_ENDIAN"}, {"arrows": "to", "from": "public abstract boolean hasArray()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "array()"}, {"arrows": "to", "from": "public abstract boolean hasArray()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "arrayOffset()"}, {"arrows": "to", "from": "public abstract Object array()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasArray"}, {"arrows": "to", "from": "public abstract int arrayOffset()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasArray"}, {"arrows": "to", "from": "public abstract Buffer slice(int index, int length)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "limit()"}, {"arrows": "to", "from": " final int nextGetIndex()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.BufferUnderflowException"}, {"arrows": "to", "from": " final int nextPutIndex()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.BufferOverflowException"}, {"arrows": "to", "from": " final int checkIndex(int i)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "IndexOutOfBoundsException"}, {"arrows": "to", "from": "public final CoderResult flush(ByteBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "OVERFLOW"}, {"arrows": "to", "from": "public final CoderResult flush(ByteBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "encode(CharBuffer"}, {"arrows": "to", "from": "public final CoderResult flush(ByteBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "flush"}, {"arrows": "to", "from": "public final CoderResult flush(ByteBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNDERFLOW"}, {"arrows": "to", "from": "public final CoderResult flush(ByteBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "remaining"}, {"arrows": "to", "from": "public final CoderResult flush(ByteBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "implFlush"}, {"arrows": "to", "from": "protected CoderResult implFlush(ByteBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "OVERFLOW"}, {"arrows": "to", "from": "protected CoderResult implFlush(ByteBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNDERFLOW"}, {"arrows": "to", "from": "public final CharsetEncoder reset()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "implReset()"}, {"arrows": "to", "from": "protected abstract CoderResult encodeLoop(CharBuffer in, ByteBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.charset.CoderResult"}, {"arrows": "to", "from": "protected abstract CoderResult encodeLoop(CharBuffer in, ByteBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "encode"}, {"arrows": "to", "from": "protected abstract CoderResult encodeLoop(CharBuffer in, ByteBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNDERFLOW"}, {"arrows": "to", "from": "protected abstract CoderResult encodeLoop(CharBuffer in, ByteBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "remaining"}, {"arrows": "to", "from": "public final ByteBuffer encode(CharBuffer in) throws CharacterCodingException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "REPORT"}, {"arrows": "to", "from": "public boolean canEncode(char c)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "canEncode(java.lang.CharSequence)"}, {"arrows": "to", "from": "public byte[] getBytes(Charset charset)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.charset.CharsetEncoder"}, {"arrows": "to", "from": "public byte[] getBytes()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.charset.CharsetEncoder"}, {"arrows": "to", "from": "public boolean equals(Object anObject)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.text.Collator"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static synchronized Collator getInstance()"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collator getInstance(Locale desiredLocale)"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int compare(String source, String target)"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int compare(Object o1, Object o2)"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract CollationKey getCollationKey(String source)"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean equals(String source, String target)"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized int getStrength()"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized void setStrength(int newStrength)"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized int getDecomposition()"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized void setDecomposition(int decompositionMode)"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static synchronized Locale[] getAvailableLocales()"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int decompositionMode_Java_ICU(int mode)"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Object clone()"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean equals(Object that)"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int hashCode()"}, {"arrows": "to", "from": "public boolean contentEquals(StringBuffer sb)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.text.Collator"}, {"arrows": "to", "from": "public boolean contentEquals(CharSequence cs)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.text.Collator"}, {"arrows": "to", "from": "public boolean equalsIgnoreCase(String anotherString)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.text.Collator"}, {"arrows": "to", "from": "public int compareToIgnoreCase(String str)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.text.Collator"}, {"arrows": "to", "from": "public boolean regionMatches(int toffset, String other, int ooffset, int len)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.text.Collator"}, {"arrows": "to", "from": "public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.text.Collator"}, {"arrows": "to", "from": "public boolean startsWith(String prefix)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(Object)"}, {"arrows": "to", "from": "public boolean endsWith(String suffix)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(Object)"}, {"arrows": "to", "from": "public CharSequence subSequence(int beginIndex, int endIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.CharSequence"}, {"arrows": "to", "from": "public boolean matches(String regex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.regex.Pattern"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Pattern compile(String regex)"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Pattern compile(String regex, int flags)"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String pattern()"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Matcher matcher(CharSequence input)"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int flags()"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean matches(String regex, CharSequence input)"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String[] split(CharSequence input, int limit)"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String[] split(CharSequence input)"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String quote(String s)"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void compile() throws PatternSyntaxException"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Predicate\u003cString\u003e asPredicate()"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Predicate\u003cString\u003e asMatchPredicate()"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Stream\u003cString\u003e splitAsStream(final CharSequence input)"}, {"arrows": "to", "from": "public static Pattern compile(String regex, int flags)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNIX_LINES"}, {"arrows": "to", "from": "public static Pattern compile(String regex, int flags)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MULTILINE"}, {"arrows": "to", "from": "public static Pattern compile(String regex, int flags)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "LITERAL"}, {"arrows": "to", "from": "public static Pattern compile(String regex, int flags)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CASE_INSENSITIVE"}, {"arrows": "to", "from": "public static Pattern compile(String regex, int flags)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNICODE_CASE"}, {"arrows": "to", "from": "public static Pattern compile(String regex, int flags)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "DOTALL"}, {"arrows": "to", "from": "public static Pattern compile(String regex, int flags)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "COMMENTS"}, {"arrows": "to", "from": "public String[] split(CharSequence input)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "split(java.lang.CharSequence"}, {"arrows": "to", "from": "public String replaceFirst(String regex, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "replaceFirst"}, {"arrows": "to", "from": "public String replaceFirst(String regex, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.regex.Pattern"}, {"arrows": "to", "from": "public String replaceFirst(String regex, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.regex.Matcher"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Pattern pattern()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public MatchResult toMatchResult()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Matcher usePattern(Pattern newPattern)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Matcher reset()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Matcher reset(CharSequence input)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int start()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int start(int group)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int start(String name)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int end()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int end(int group)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int end(String name)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String group()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String group(int group)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String group(String name)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int groupCount()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean matches()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean find()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean find(int start)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean lookingAt()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String quoteReplacement(String s)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Matcher appendReplacement(StringBuffer sb, String replacement)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Matcher appendReplacement(StringBuilder sb, String replacement)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public StringBuffer appendTail(StringBuffer sb)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public StringBuilder appendTail(StringBuilder sb)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String replaceAll(String replacement)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String replaceAll(Function\u003cMatchResult, String\u003e replacer)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Stream\u003cMatchResult\u003e results()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String replaceFirst(String replacement)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String replaceFirst(Function\u003cMatchResult, String\u003e replacer)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Matcher region(int start, int end)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int regionStart()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int regionEnd()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean hasTransparentBounds()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Matcher useTransparentBounds(boolean b)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean hasAnchoringBounds()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Matcher useAnchoringBounds(boolean b)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean hitEnd()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean requireEnd()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int getTextLength()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " CharSequence getSubSequence(int beginIndex, int endIndex)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private Matcher reset(CharSequence input, int start, int end)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void ensureMatch()"}, {"arrows": "to", "from": "public MatchResult toMatchResult()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.regex.MatchResult"}, {"arrows": "to", "from": "java.util.regex.MatchResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int start()"}, {"arrows": "to", "from": "java.util.regex.MatchResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int start(int group)"}, {"arrows": "to", "from": "java.util.regex.MatchResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int end()"}, {"arrows": "to", "from": "java.util.regex.MatchResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int end(int group)"}, {"arrows": "to", "from": "java.util.regex.MatchResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String group()"}, {"arrows": "to", "from": "java.util.regex.MatchResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String group(int group)"}, {"arrows": "to", "from": "java.util.regex.MatchResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int groupCount()"}, {"arrows": "to", "from": "public boolean find(int start)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "find()"}, {"arrows": "to", "from": "public boolean lookingAt()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "matches"}, {"arrows": "to", "from": "public static String quoteReplacement(String s)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.regex.Matcher"}, {"arrows": "to", "from": "public Matcher appendReplacement(StringBuffer sb, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "group(String)"}, {"arrows": "to", "from": "public Matcher appendReplacement(StringBuffer sb, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "start()"}, {"arrows": "to", "from": "public Matcher appendReplacement(StringBuffer sb, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "end()"}, {"arrows": "to", "from": "public Matcher appendReplacement(StringBuffer sb, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "appendTail(StringBuffer)"}, {"arrows": "to", "from": "public Matcher appendReplacement(StringBuffer sb, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "find()"}, {"arrows": "to", "from": "public Matcher appendReplacement(StringBuffer sb, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "group(int)"}, {"arrows": "to", "from": "public Matcher appendReplacement(StringBuilder sb, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "start()"}, {"arrows": "to", "from": "public Matcher appendReplacement(StringBuilder sb, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "end()"}, {"arrows": "to", "from": "public Matcher appendReplacement(StringBuilder sb, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "appendTail(StringBuilder)"}, {"arrows": "to", "from": "public Matcher appendReplacement(StringBuilder sb, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "find()"}, {"arrows": "to", "from": "public Matcher appendReplacement(StringBuilder sb, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "group(int)"}, {"arrows": "to", "from": "public StringBuffer appendTail(StringBuffer sb)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "appendReplacement(StringBuffer"}, {"arrows": "to", "from": "public StringBuilder appendTail(StringBuilder sb)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "appendReplacement(StringBuilder"}, {"arrows": "to", "from": "public String replaceAll(String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "appendReplacement"}, {"arrows": "to", "from": "public String replaceAll(Function\u003cMatchResult, String\u003e replacer)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "appendReplacementappendReplacement"}, {"arrows": "to", "from": "public String replaceAll(Function\u003cMatchResult, String\u003e replacer)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.ConcurrentModificationException"}, {"arrows": "to", "from": "public Stream\u003cMatchResult\u003e results()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.ConcurrentModificationException"}, {"arrows": "to", "from": "public Stream\u003cMatchResult\u003e results()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toMatchResult()"}, {"arrows": "to", "from": "public String replaceFirst(String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "appendReplacement"}, {"arrows": "to", "from": "public String replaceFirst(Function\u003cMatchResult, String\u003e replacer)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "appendReplacementappendReplacement"}, {"arrows": "to", "from": "public String replaceFirst(Function\u003cMatchResult, String\u003e replacer)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.ConcurrentModificationException"}, {"arrows": "to", "from": "public Matcher region(int start, int end)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "useTransparentBounds(boolean)"}, {"arrows": "to", "from": "public Matcher region(int start, int end)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "useAnchoringBounds(boolean)"}, {"arrows": "to", "from": "public int regionStart()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "regionEnd()"}, {"arrows": "to", "from": "public int regionStart()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "regionStart()"}, {"arrows": "to", "from": "public int regionEnd()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "regionEnd()"}, {"arrows": "to", "from": "public int regionEnd()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "regionStart()"}, {"arrows": "to", "from": "public boolean hasTransparentBounds()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "useTransparentBounds(boolean)"}, {"arrows": "to", "from": "public boolean hasAnchoringBounds()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "useAnchoringBounds(boolean)"}, {"arrows": "to", "from": "public String replaceAll(String regex, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.regex.Pattern"}, {"arrows": "to", "from": "public String replaceAll(String regex, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.regex.Matcher"}, {"arrows": "to", "from": "public String[] split(String regex, int limit)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.regex.Pattern"}, {"arrows": "to", "from": "public String[] split(String regex, int limit)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "split(java.lang.CharSequence"}, {"arrows": "to", "from": "public String[] split(String regex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "split(String"}, {"arrows": "to", "from": "public String toLowerCase(Locale locale)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.Character"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Character valueOf(char c)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public char charValue()"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int hashCode()"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int hashCode(char value)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean equals(Object obj)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String toString(char c)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String toString(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isValidCodePoint(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isBmpCodePoint(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isSupplementaryCodePoint(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isHighSurrogate(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isLowSurrogate(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isSurrogate(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isSurrogatePair(char high, char low)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int charCount(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int toCodePoint(char high, char low)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int codePointAt(CharSequence seq, int index)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int codePointAt(char[] a, int index)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int codePointAt(char[] a, int index, int limit)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static int codePointAtImpl(char[] a, int index, int limit)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int codePointBefore(CharSequence seq, int index)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int codePointBefore(char[] a, int index)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int codePointBefore(char[] a, int index, int start)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static int codePointBeforeImpl(char[] a, int index, int start)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static char highSurrogate(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static char lowSurrogate(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int toChars(int codePoint, char[] dst, int dstIndex)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static char[] toChars(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int codePointCount(CharSequence seq, int beginIndex, int endIndex)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int codePointCount(char[] a, int offset, int count)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int offsetByCodePoints(CharSequence seq, int index, int codePointOffset)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int offsetByCodePoints(char[] a, int start, int count, int index, int codePointOffset)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isLowerCase(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isLowerCase(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isUpperCase(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isUpperCase(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isTitleCase(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isTitleCase(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isDigit(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isDigit(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isDefined(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isDefined(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isLetter(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isLetter(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isLetterOrDigit(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isLetterOrDigit(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isAlphabetic(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isIdeographic(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isJavaIdentifierStart(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isJavaIdentifierStart(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isJavaIdentifierPart(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isJavaIdentifierPart(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isUnicodeIdentifierStart(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isUnicodeIdentifierStart(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isUnicodeIdentifierPart(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isUnicodeIdentifierPart(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isIdentifierIgnorable(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isIdentifierIgnorable(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static char toLowerCase(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int toLowerCase(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static char toUpperCase(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int toUpperCase(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static char toTitleCase(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int toTitleCase(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int digit(char ch, int radix)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int digit(int codePoint, int radix)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int getNumericValue(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int getNumericValue(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isSpaceChar(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isSpaceChar(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isWhitespace(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isWhitespace(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isISOControl(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isISOControl(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int getType(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int getType(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static char forDigit(int digit, int radix)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static byte getDirectionality(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static byte getDirectionality(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isMirrored(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isMirrored(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int compareTo(Character anotherCharacter)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(char x, char y)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static char reverseBytes(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String getName(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int codePointOf(String name)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static native String getNameImpl(int codePoint)"}, {"arrows": "to", "from": "public static Character valueOf(char c)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Character(char)"}, {"arrows": "to", "from": "public static boolean isValidCodePoint(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MIN_CODE_POINT"}, {"arrows": "to", "from": "public static boolean isValidCodePoint(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MAX_CODE_POINT"}, {"arrows": "to", "from": "public static boolean isBmpCodePoint(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MIN_VALUE"}, {"arrows": "to", "from": "public static boolean isBmpCodePoint(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MAX_VALUE"}, {"arrows": "to", "from": "public static boolean isSupplementaryCodePoint(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MIN_SUPPLEMENTARY_CODE_POINT"}, {"arrows": "to", "from": "public static boolean isSupplementaryCodePoint(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MAX_CODE_POINT"}, {"arrows": "to", "from": "public static boolean isHighSurrogate(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MIN_HIGH_SURROGATE"}, {"arrows": "to", "from": "public static boolean isHighSurrogate(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MAX_HIGH_SURROGATE"}, {"arrows": "to", "from": "public static boolean isLowSurrogate(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MAX_LOW_SURROGATE"}, {"arrows": "to", "from": "public static boolean isLowSurrogate(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MIN_LOW_SURROGATE"}, {"arrows": "to", "from": "public static boolean isSurrogate(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MIN_SURROGATE"}, {"arrows": "to", "from": "public static boolean isSurrogate(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MAX_SURROGATE"}, {"arrows": "to", "from": "public static int charCount(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isValidCodePoint(int)"}, {"arrows": "to", "from": "public static int toCodePoint(char high, char low)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isSurrogatePair(char"}, {"arrows": "to", "from": "public static int codePointAt(CharSequence seq, int index)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "length()"}, {"arrows": "to", "from": "public static int codePointBefore(CharSequence seq, int index)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "length()"}, {"arrows": "to", "from": "public static char highSurrogate(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isSupplementaryCodePoint"}, {"arrows": "to", "from": "public static char highSurrogate(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toCodePoint"}, {"arrows": "to", "from": "public static char highSurrogate(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "lowSurrogate"}, {"arrows": "to", "from": "public static char highSurrogate(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isHighSurrogate"}, {"arrows": "to", "from": "public static char lowSurrogate(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isLowSurrogate"}, {"arrows": "to", "from": "public static char lowSurrogate(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isSupplementaryCodePoint"}, {"arrows": "to", "from": "public static char lowSurrogate(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toCodePoint"}, {"arrows": "to", "from": "public static char lowSurrogate(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "highSurrogate"}, {"arrows": "to", "from": "public static boolean isLowerCase(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isLowerCase(int)"}, {"arrows": "to", "from": "public static boolean isUpperCase(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isUpperCase(int)"}, {"arrows": "to", "from": "public static boolean isTitleCase(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isTitleCase(int)"}, {"arrows": "to", "from": "public static boolean isDigit(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isDigit(int)"}, {"arrows": "to", "from": "public static boolean isDefined(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isDefined(int)"}, {"arrows": "to", "from": "public static boolean isLetter(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isLetter(int)"}, {"arrows": "to", "from": "public static boolean isLetterOrDigit(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isLetterOrDigit(int)"}, {"arrows": "to", "from": "public static boolean isJavaIdentifierStart(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isLetter(char)"}, {"arrows": "to", "from": "public static boolean isJavaIdentifierStart(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getType(char)"}, {"arrows": "to", "from": "public static boolean isJavaIdentifierStart(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isJavaIdentifierStart(int)"}, {"arrows": "to", "from": "public static boolean isJavaIdentifierPart(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isJavaIdentifierPart(int)"}, {"arrows": "to", "from": "public static boolean isUnicodeIdentifierStart(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isLetter(char)"}, {"arrows": "to", "from": "public static boolean isUnicodeIdentifierStart(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getType(char)"}, {"arrows": "to", "from": "public static boolean isUnicodeIdentifierStart(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isUnicodeIdentifierStart(int)"}, {"arrows": "to", "from": "public static boolean isUnicodeIdentifierPart(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isUnicodeIdentifierPart(int)"}, {"arrows": "to", "from": "public static boolean isIdentifierIgnorable(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isIdentifierIgnorable(int)"}, {"arrows": "to", "from": "public static char toLowerCase(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.String"}, {"arrows": "to", "from": "public static char toLowerCase(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toLowerCase(int)"}, {"arrows": "to", "from": "public static char toUpperCase(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toUpperCase(int)"}, {"arrows": "to", "from": "public static char toUpperCase(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.String"}, {"arrows": "to", "from": "public static char toTitleCase(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toTitleCase(int)"}, {"arrows": "to", "from": "public static int digit(char ch, int radix)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "digit(int"}, {"arrows": "to", "from": "public static int getNumericValue(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getNumericValue(int)"}, {"arrows": "to", "from": "public static boolean isSpaceChar(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isSpaceChar(int)"}, {"arrows": "to", "from": "public static boolean isWhitespace(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isWhitespace(int)"}, {"arrows": "to", "from": "public static boolean isISOControl(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isISOControl(int)"}, {"arrows": "to", "from": "public static int getType(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getType(int)"}, {"arrows": "to", "from": "public static byte getDirectionality(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDirectionality(int)"}, {"arrows": "to", "from": "public static boolean isMirrored(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isMirrored(int)"}, {"arrows": "to", "from": "public static String getName(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNASSIGNED"}, {"arrows": "to", "from": "public String toUpperCase(Locale locale)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.Character"}, {"arrows": "to", "from": "public String strip()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isWhitespace(int)"}, {"arrows": "to", "from": "public String stripLeading()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isWhitespace(int)"}, {"arrows": "to", "from": "public String stripTrailing()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isWhitespace(int)"}, {"arrows": "to", "from": "public boolean isBlank()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isWhitespace(int)"}, {"arrows": "to", "from": "public String indent(int n)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "lines()"}, {"arrows": "to", "from": "public String stripIndent()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isBlank()"}, {"arrows": "to", "from": "public static String format(String format, Object... args)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault(java.util.Locale.Category)"}, {"arrows": "to", "from": "public static String format(String format, Object... args)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FORMAT"}, {"arrows": "to", "from": "public static String copyValueOf(char[] data, int offset, int count)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "valueOf(char"}, {"arrows": "to", "from": "public static String copyValueOf(char[] data)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "valueOf(char"}, {"arrows": "to", "from": " byte coder()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "canEncode(int)"}, {"arrows": "to", "from": "java.lang.StringLatin1", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compareToUTF16(byte[] value, byte[] other, int len1, int len2)"}, {"arrows": "to", "from": "java.lang.StringLatin1", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void inflate(byte[] src, int srcOff, char[] dst, int dstOff, int len)"}, {"arrows": "to", "from": "java.lang.StringLatin1", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void inflate(byte[] src, int srcOff, byte[] dst, int dstOff, int len)"}]);

                  nodeColors = {};
                  allNodes = nodes.get({ returnType: "Object" });
                  for (nodeId in allNodes) {
                    nodeColors[nodeId] = allNodes[nodeId].color;
                  }
                  allEdges = edges.get({ returnType: "Object" });
                  // adding nodes and edges to the graph
                  data = {nodes: nodes, edges: edges};

                  var options = {
    "configure": {
        "enabled": false
    },
    "edges": {
        "color": {
            "inherit": true
        },
        "smooth": {
            "enabled": true,
            "type": "dynamic"
        }
    },
    "interaction": {
        "dragNodes": true,
        "hideEdgesOnDrag": false,
        "hideNodesOnDrag": false
    },
    "physics": {
        "enabled": true,
        "stabilization": {
            "enabled": true,
            "fit": true,
            "iterations": 1000,
            "onlyDynamicEdges": false,
            "updateInterval": 50
        }
    }
};

                  


                  

                  network = new vis.Network(container, data, options);

                  

                  

                  
                  // make a custom popup
                      var popup = document.createElement("div");
                      popup.className = 'popup';
                      popupTimeout = null;
                      popup.addEventListener('mouseover', function () {
                          console.log(popup)
                          if (popupTimeout !== null) {
                              clearTimeout(popupTimeout);
                              popupTimeout = null;
                          }
                      });
                      popup.addEventListener('mouseout', function () {
                          if (popupTimeout === null) {
                              hidePopup();
                          }
                      });
                      container.appendChild(popup);


                      // use the popup event to show
                      network.on("showPopup", function (params) {
                          showPopup(params);
                      });

                      // use the hide event to hide it
                      network.on("hidePopup", function (params) {
                          hidePopup();
                      });

                      // hiding the popup through css
                      function hidePopup() {
                          popupTimeout = setTimeout(function () { popup.style.display = 'none'; }, 500);
                      }

                      // showing the popup
                      function showPopup(nodeId) {
                          // get the data from the vis.DataSet
                          var nodeData = nodes.get([nodeId]);
                          popup.innerHTML = nodeData[0].title;

                          // get the position of the node
                          var posCanvas = network.getPositions([nodeId])[nodeId];

                          // get the bounding box of the node
                          var boundingBox = network.getBoundingBox(nodeId);

                          //position tooltip:
                          posCanvas.x = posCanvas.x + 0.5 * (boundingBox.right - boundingBox.left);

                          // convert coordinates to the DOM space
                          var posDOM = network.canvasToDOM(posCanvas);

                          // Give it an offset
                          posDOM.x += 10;
                          posDOM.y -= 20;

                          // show and place the tooltip.
                          popup.style.display = 'block';
                          popup.style.top = posDOM.y + 'px';
                          popup.style.left = posDOM.x + 'px';
                      }
                  


                  
                      network.on("stabilizationProgress", function(params) {
                          document.getElementById('loadingBar').removeAttribute("style");
                          var maxWidth = 496;
                          var minWidth = 20;
                          var widthFactor = params.iterations/params.total;
                          var width = Math.max(minWidth,maxWidth * widthFactor);
                          document.getElementById('bar').style.width = width + 'px';
                          document.getElementById('text').innerHTML = Math.round(widthFactor*100) + '%';
                      });
                      network.once("stabilizationIterationsDone", function() {
                          document.getElementById('text').innerHTML = '100%';
                          document.getElementById('bar').style.width = '496px';
                          document.getElementById('loadingBar').style.opacity = 0;
                          // really clean the dom element
                          setTimeout(function () {document.getElementById('loadingBar').style.display = 'none';}, 500);
                      });
                  

                  return network;

              }
              drawGraph();
        </script>
    </body>
</html>