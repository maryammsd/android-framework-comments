<html>
    <head>
        <meta charset="utf-8">
        
            <script src="lib/bindings/utils.js"></script>
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/dist/vis-network.min.css" integrity="sha512-WgxfT5LWjfszlPHXRmBWHkV2eceiWTOBvrKCNbdgDYTHrT2AeLCGbF4sZlZw3UMN3WtL0tGUoIAKsu8mllg/XA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
            <script src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/vis-network.min.js" integrity="sha512-LnvoEWDFrqGHlHmDD2101OrLcbsfkrzoSpvtSQtxK3RMnRV0eOkhhBN2dXHKRrUU8p2DGRTk35n4O8nWSVe1mQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
            
        
<center>
<h1></h1>
</center>

<!-- <link rel="stylesheet" href="../node_modules/vis/dist/vis.min.css" type="text/css" />
<script type="text/javascript" src="../node_modules/vis/dist/vis.js"> </script>-->
        <link
          href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css"
          rel="stylesheet"
          integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6"
          crossorigin="anonymous"
        />
        <script
          src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js"
          integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf"
          crossorigin="anonymous"
        ></script>


        <center>
          <h1></h1>
        </center>
        <style type="text/css">

             #mynetwork {
                 width: 100%;
                 height: 600px;
                 background-color: #ffffff;
                 border: 1px solid lightgray;
                 position: relative;
                 float: left;
             }

             
             #loadingBar {
                 position:absolute;
                 top:0px;
                 left:0px;
                 width: 100%;
                 height: 600px;
                 background-color:rgba(200,200,200,0.8);
                 -webkit-transition: all 0.5s ease;
                 -moz-transition: all 0.5s ease;
                 -ms-transition: all 0.5s ease;
                 -o-transition: all 0.5s ease;
                 transition: all 0.5s ease;
                 opacity:1;
             }

             #bar {
                 position:absolute;
                 top:0px;
                 left:0px;
                 width:20px;
                 height:20px;
                 margin:auto auto auto auto;
                 border-radius:11px;
                 border:2px solid rgba(30,30,30,0.05);
                 background: rgb(0, 173, 246); /* Old browsers */
                 box-shadow: 2px 0px 4px rgba(0,0,0,0.4);
             }

             #border {
                 position:absolute;
                 top:10px;
                 left:10px;
                 width:500px;
                 height:23px;
                 margin:auto auto auto auto;
                 box-shadow: 0px 0px 4px rgba(0,0,0,0.2);
                 border-radius:10px;
             }

             #text {
                 position:absolute;
                 top:8px;
                 left:530px;
                 width:30px;
                 height:50px;
                 margin:auto auto auto auto;
                 font-size:22px;
                 color: #000000;
             }

             div.outerBorder {
                 position:relative;
                 top:400px;
                 width:600px;
                 height:44px;
                 margin:auto auto auto auto;
                 border:8px solid rgba(0,0,0,0.1);
                 background: rgb(252,252,252); /* Old browsers */
                 background: -moz-linear-gradient(top,  rgba(252,252,252,1) 0%, rgba(237,237,237,1) 100%); /* FF3.6+ */
                 background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,rgba(252,252,252,1)), color-stop(100%,rgba(237,237,237,1))); /* Chrome,Safari4+ */
                 background: -webkit-linear-gradient(top,  rgba(252,252,252,1) 0%,rgba(237,237,237,1) 100%); /* Chrome10+,Safari5.1+ */
                 background: -o-linear-gradient(top,  rgba(252,252,252,1) 0%,rgba(237,237,237,1) 100%); /* Opera 11.10+ */
                 background: -ms-linear-gradient(top,  rgba(252,252,252,1) 0%,rgba(237,237,237,1) 100%); /* IE10+ */
                 background: linear-gradient(to bottom,  rgba(252,252,252,1) 0%,rgba(237,237,237,1) 100%); /* W3C */
                 filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#fcfcfc', endColorstr='#ededed',GradientType=0 ); /* IE6-9 */
                 border-radius:72px;
                 box-shadow: 0px 0px 10px rgba(0,0,0,0.2);
             }
             

             

             
             /* position absolute is important and the container has to be relative or absolute as well. */
          div.popup {
                 position:absolute;
                 top:0px;
                 left:0px;
                 display:none;
                 background-color:#f5f4ed;
                 -moz-border-radius: 3px;
                 -webkit-border-radius: 3px;
                 border-radius: 3px;
                 border: 1px solid #808074;
                 box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);
          }

          /* hide the original tooltip */
          .vis-tooltip {
            display:none;
          }
             
        </style>
    </head>


    <body>
        <div class="card" style="width: 100%">
            
            
            <div id="mynetwork" class="card-body"></div>
        </div>

        
            <div id="loadingBar">
              <div class="outerBorder">
                <div id="text">0%</div>
                <div id="border">
                  <div id="bar"></div>
                </div>
              </div>
            </div>
        
        

        <script type="text/javascript">

              // initialize global variables.
              var edges;
              var nodes;
              var allNodes;
              var allEdges;
              var nodeColors;
              var originalNodes;
              var network;
              var container;
              var options, data;
              var filter = {
                  item : '',
                  property : '',
                  value : []
              };

              

              

              // This method is responsible for drawing the graph, returns the drawn network
              function drawGraph() {
                  var container = document.getElementById('mynetwork');

                  

                  // parsing and collecting nodes and edges from the python
                  nodes = new vis.DataSet([{"color": "#97c2fc", "id": "java.util.Map", "label": "java.util.Map", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * An object that maps keys to values.  A map cannot contain duplicate keys;\\n * each key can map to at most one value.\\n *\\n * \u003cp\u003eThis interface takes the place of the {@code Dictionary} class, which\\n * was a totally abstract class rather than an interface.\\n *\\n * \u003cp\u003eThe {@code Map} interface provides three \u003ci\u003ecollection views\u003c/i\u003e, which\\n * allow a map\\\u0027s contents to be viewed as a set of keys, collection of values,\\n * or set of key-value mappings.  The \u003ci\u003eorder\u003c/i\u003e of a map is defined as\\n * the order in which the iterators on the map\\\u0027s collection views return their\\n * elements.  Some map implementations, like the {@code TreeMap} class, make\\n * specific guarantees as to their order; others, like the {@code HashMap}\\n * class, do not.\\n *\\n * \u003cp\u003eNote: great care must be exercised if mutable objects are used as map\\n * keys.  The behavior of a map is not specified if the value of an object is\\n * changed in a manner that affects {@code equals} comparisons while the\\n * object is a key in the map.  A special case of this prohibition is that it\\n * is not permissible for a map to contain itself as a key.  While it is\\n * permissible for a map to contain itself as a value, extreme caution is\\n * advised: the {@code equals} and {@code hashCode} methods are no longer\\n * well defined on such a map.\\n *\\n * \u003cp\u003eAll general-purpose map implementation classes should provide two\\n * \"standard\" constructors: a void (no arguments) constructor which creates an\\n * empty map, and a constructor with a single argument of type {@code Map},\\n * which creates a new map with the same key-value mappings as its argument.\\n * In effect, the latter constructor allows the user to copy any map,\\n * producing an equivalent map of the desired class.  There is no way to\\n * enforce this recommendation (as interfaces cannot contain constructors) but\\n * all of the general-purpose map implementations in the JDK comply.\\n *\\n * \u003cp\u003eThe \"destructive\" methods contained in this interface, that is, the\\n * methods that modify the map on which they operate, are specified to throw\\n * {@code UnsupportedOperationException} if this map does not support the\\n * operation.  If this is the case, these methods may, but are not required\\n * to, throw an {@code UnsupportedOperationException} if the invocation would\\n * have no effect on the map.  For example, invoking the {@link #putAll(Map)}\\n * method on an unmodifiable map may, but is not required to, throw the\\n * exception if the map whose mappings are to be \"superimposed\" is empty.\\n *\\n * \u003cp\u003eSome map implementations have restrictions on the keys and values they\\n * may contain.  For example, some implementations prohibit null keys and\\n * values, and some have restrictions on the types of their keys.  Attempting\\n * to insert an ineligible key or value throws an unchecked exception,\\n * typically {@code NullPointerException} or {@code ClassCastException}.\\n * Attempting to query the presence of an ineligible key or value may throw an\\n * exception, or it may simply return false; some implementations will exhibit\\n * the former behavior and some will exhibit the latter.  More generally,\\n * attempting an operation on an ineligible key or value whose completion\\n * would not result in the insertion of an ineligible element into the map may\\n * throw an exception or it may succeed, at the option of the implementation.\\n * Such exceptions are marked as \"optional\" in the specification for this\\n * interface.\\n *\\n * \u003cp\u003eMany methods in Collections Framework interfaces are defined\\n * in terms of the {@link Object#equals(Object) equals} method.  For\\n * example, the specification for the {@link #containsKey(Object)\\n * containsKey(Object key)} method says: \"returns {@code true} if and\\n * only if this map contains a mapping for a key {@code k} such that\\n * {@code (key==null ? k==null : key.equals(k))}.\" This specification should\\n * \u003ci\u003enot\u003c/i\u003e be construed to imply that invoking {@code Map.containsKey}\\n * with a non-null argument {@code key} will cause {@code key.equals(k)} to\\n * be invoked for any key {@code k}.  Implementations are free to\\n * implement optimizations whereby the {@code equals} invocation is avoided,\\n * for example, by first comparing the hash codes of the two keys.  (The\\n * {@link Object#hashCode()} specification guarantees that two objects with\\n * unequal hash codes cannot be equal.)  More generally, implementations of\\n * the various Collections Framework interfaces are free to take advantage of\\n * the specified behavior of underlying {@link Object} methods wherever the\\n * implementor deems it appropriate.\\n *\\n * \u003cp\u003eSome map operations which perform recursive traversal of the map may fail\\n * with an exception for self-referential instances where the map directly or\\n * indirectly contains itself. This includes the {@code clone()},\\n * {@code equals()}, {@code hashCode()} and {@code toString()} methods.\\n * Implementations may optionally handle the self-referential scenario, however\\n * most current implementations do not do so.\\n *\\n * \u003ch2\u003e\u003ca id=\"unmodifiable\"\u003eUnmodifiable Maps\u003c/a\u003e\u003c/h2\u003e\\n * \u003cp\u003eThe {@link Map#of() Map.of},\\n * {@link Map#ofEntries(Map.Entry...) Map.ofEntries}, and\\n * {@link Map#copyOf Map.copyOf}\\n * static factory methods provide a convenient way to create unmodifiable maps.\\n * The {@code Map}\\n * instances created by these methods have the following characteristics:\\n *\\n * \u003cul\u003e\\n * \u003cli\u003eThey are \u003ca href=\"Collection.html#unmodifiable\"\u003e\u003ci\u003eunmodifiable\u003c/i\u003e\u003c/a\u003e. Keys and values\\n * cannot be added, removed, or updated. Calling any mutator method on the Map\\n * will always cause {@code UnsupportedOperationException} to be thrown.\\n * However, if the contained keys or values are themselves mutable, this may cause the\\n * Map to behave inconsistently or its contents to appear to change.\\n * \u003cli\u003eThey disallow {@code null} keys and values. Attempts to create them with\\n * {@code null} keys or values result in {@code NullPointerException}.\\n * \u003cli\u003eThey are serializable if all keys and values are serializable.\\n * \u003cli\u003eThey reject duplicate keys at creation time. Duplicate keys\\n * passed to a static factory method result in {@code IllegalArgumentException}.\\n * \u003cli\u003eThe iteration order of mappings is unspecified and is subject to change.\\n * \u003cli\u003eThey are \u003ca href=\"../lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e.\\n * Programmers should treat instances that are {@linkplain #equals(Object) equal}\\n * as interchangeable and should not use them for synchronization, or\\n * unpredictable behavior may occur. For example, in a future release,\\n * synchronization may fail. Callers should make no assumptions\\n * about the identity of the returned instances. Factories are free to\\n * create new instances or reuse existing ones.\\n * \u003cli\u003eThey are serialized as specified on the\\n * \u003ca href=\"{@docRoot}/serialized-form.html#java.util.CollSer\"\u003eSerialized Form\u003c/a\u003e\\n * page.\\n * \u003c/ul\u003e\\n *\\n * \u003cp\u003eThis interface is a member of the\\n * \u003ca href=\"{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework\"\u003e\\n * Java Collections Framework\u003c/a\u003e.\\n *\\n * @param \u003cK\u003e the type of keys maintained by this map\\n * @param \u003cV\u003e the type of mapped values\\n *\\n * @author  Josh Bloch\\n * @see HashMap\\n * @see TreeMap\\n * @see Hashtable\\n * @see SortedMap\\n * @see Collection\\n * @see Set\\n * @since 1.2\\n \u0027}"}, {"color": "#97c2fc", "id": " int size()", "label": " int size()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the number of elements in this list.  If this list contains\\n     * more than {@code Integer.MAX_VALUE} elements, returns\\n     * {@code Integer.MAX_VALUE}.\\n     *\\n     * @return the number of elements in this list\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean isEmpty()", "label": " boolean isEmpty()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if this character sequence is empty.\\n     *\\n     * @implSpec\\n     * The default implementation returns the result of calling {@code length() == 0}.\\n     *\\n     * @return {@code true} if {@link #length()} is {@code 0}, otherwise\\n     * {@code false}\\n     *\\n     * @since 15\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean containsKey(Object key)", "label": " boolean containsKey(Object key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if this map contains a mapping for the specified\\n     * key.  More formally, returns {@code true} if and only if\\n     * this map contains a mapping for a key {@code k} such that\\n     * {@code Objects.equals(key, k)}.  (There can be\\n     * at most one such mapping.)\\n     *\\n     * @param key key whose presence in this map is to be tested\\n     * @return {@code true} if this map contains a mapping for the specified\\n     *         key\\n     * @throws ClassCastException if the key is of an inappropriate type for\\n     *         this map\\n     * (\u003ca href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     * @throws NullPointerException if the specified key is null and this map\\n     *         does not permit null keys\\n     * (\u003ca href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean containsValue(Object value)", "label": " boolean containsValue(Object value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if this map maps one or more keys to the\\n     * specified value.  More formally, returns {@code true} if and only if\\n     * this map contains at least one mapping to a value {@code v} such that\\n     * {@code Objects.equals(value, v)}.  This operation\\n     * will probably require time linear in the map size for most\\n     * implementations of the {@code Map} interface.\\n     *\\n     * @param value value whose presence in this map is to be tested\\n     * @return {@code true} if this map maps one or more keys to the\\n     *         specified value\\n     * @throws ClassCastException if the value is of an inappropriate type for\\n     *         this map\\n     * (\u003ca href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     * @throws NullPointerException if the specified value is null and this\\n     *         map does not permit null values\\n     * (\u003ca href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     \u0027}"}, {"color": "#97c2fc", "id": " V get(Object key)", "label": " V get(Object key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value to which the specified key is mapped,\\n     * or {@code null} if this map contains no mapping for the key.\\n     *\\n     * \u003cp\u003eMore formally, if this map contains a mapping from a key\\n     * {@code k} to a value {@code v} such that\\n     * {@code Objects.equals(key, k)},\\n     * then this method returns {@code v}; otherwise\\n     * it returns {@code null}.  (There can be at most one such mapping.)\\n     *\\n     * \u003cp\u003eIf this map permits null values, then a return value of\\n     * {@code null} does not \u003ci\u003enecessarily\u003c/i\u003e indicate that the map\\n     * contains no mapping for the key; it\\\u0027s also possible that the map\\n     * explicitly maps the key to {@code null}.  The {@link #containsKey\\n     * containsKey} operation may be used to distinguish these two cases.\\n     *\\n     * @param key the key whose associated value is to be returned\\n     * @return the value to which the specified key is mapped, or\\n     *         {@code null} if this map contains no mapping for the key\\n     * @throws ClassCastException if the key is of an inappropriate type for\\n     *         this map\\n     * (\u003ca href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     * @throws NullPointerException if the specified key is null and this map\\n     *         does not permit null keys\\n     * (\u003ca href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     \u0027}"}, {"color": "#97c2fc", "id": "containsKeycontainsKey", "label": "containsKeycontainsKey", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " V put(K key, V value)", "label": " V put(K key, V value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Associates the specified value with the specified key in this map\\n     * (optional operation).  If the map previously contained a mapping for\\n     * the key, the old value is replaced by the specified value.  (A map\\n     * {@code m} is said to contain a mapping for a key {@code k} if and only\\n     * if {@link #containsKey(Object) m.containsKey(k)} would return\\n     * {@code true}.)\\n     *\\n     * @param key key with which the specified value is to be associated\\n     * @param value value to be associated with the specified key\\n     * @return the previous value associated with {@code key}, or\\n     *         {@code null} if there was no mapping for {@code key}.\\n     *         (A {@code null} return can also indicate that the map\\n     *         previously associated {@code null} with {@code key},\\n     *         if the implementation supports {@code null} values.)\\n     * @throws UnsupportedOperationException if the {@code put} operation\\n     *         is not supported by this map\\n     * @throws ClassCastException if the class of the specified key or value\\n     *         prevents it from being stored in this map\\n     * @throws NullPointerException if the specified key or value is null\\n     *         and this map does not permit null keys or values\\n     * @throws IllegalArgumentException if some property of the specified key\\n     *         or value prevents it from being stored in this map\\n     \u0027}"}, {"color": "#97c2fc", "id": "containsKey(Object)", "label": "containsKey(Object)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " V remove(Object key)", "label": " V remove(Object key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Removes the mapping for a key from this map if it is present\\n     * (optional operation).   More formally, if this map contains a mapping\\n     * from key {@code k} to value {@code v} such that\\n     * {@code Objects.equals(key, k)}, that mapping\\n     * is removed.  (The map can contain at most one such mapping.)\\n     *\\n     * \u003cp\u003eReturns the value to which this map previously associated the key,\\n     * or {@code null} if the map contained no mapping for the key.\\n     *\\n     * \u003cp\u003eIf this map permits null values, then a return value of\\n     * {@code null} does not \u003ci\u003enecessarily\u003c/i\u003e indicate that the map\\n     * contained no mapping for the key; it\\\u0027s also possible that the map\\n     * explicitly mapped the key to {@code null}.\\n     *\\n     * \u003cp\u003eThe map will not contain a mapping for the specified key once the\\n     * call returns.\\n     *\\n     * @param key key whose mapping is to be removed from the map\\n     * @return the previous value associated with {@code key}, or\\n     *         {@code null} if there was no mapping for {@code key}.\\n     * @throws UnsupportedOperationException if the {@code remove} operation\\n     *         is not supported by this map\\n     * @throws ClassCastException if the key is of an inappropriate type for\\n     *         this map\\n     * (\u003ca href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     * @throws NullPointerException if the specified key is null and this\\n     *         map does not permit null keys\\n     * (\u003ca href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     \u0027}"}, {"color": "#97c2fc", "id": " void putAll(Map\u003c? extends K, ? extends V\u003e m)", "label": " void putAll(Map\u003c? extends K, ? extends V\u003e m)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies all of the mappings from the specified map to this map\\n     * (optional operation).  The effect of this call is equivalent to that\\n     * of calling {@link #put(Object,Object) put(k, v)} on this map once\\n     * for each mapping from key {@code k} to value {@code v} in the\\n     * specified map.  The behavior of this operation is undefined if the\\n     * specified map is modified while the operation is in progress.\\n     *\\n     * @param m mappings to be stored in this map\\n     * @throws UnsupportedOperationException if the {@code putAll} operation\\n     *         is not supported by this map\\n     * @throws ClassCastException if the class of a key or value in the\\n     *         specified map prevents it from being stored in this map\\n     * @throws NullPointerException if the specified map is null, or if\\n     *         this map does not permit null keys or values, and the\\n     *         specified map contains null keys or values\\n     * @throws IllegalArgumentException if some property of a key or value in\\n     *         the specified map prevents it from being stored in this map\\n     \u0027}"}, {"color": "#97c2fc", "id": "put(Object", "label": "put(Object", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " void clear()", "label": " void clear()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Removes all of the elements from this set (optional operation).\\n     * The set will be empty after this call returns.\\n     *\\n     * @throws UnsupportedOperationException if the {@code clear} method\\n     *         is not supported by this set\\n     \u0027}"}, {"color": "#97c2fc", "id": " Set\u003cK\u003e keySet()", "label": " Set\u003cK\u003e keySet()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a {@link Set} view of the keys contained in this map.\\n     * The set is backed by the map, so changes to the map are\\n     * reflected in the set, and vice-versa.  If the map is modified\\n     * while an iteration over the set is in progress (except through\\n     * the iterator\u0027s own {@code remove} operation), the results of\\n     * the iteration are undefined.  The set supports element removal,\\n     * which removes the corresponding mapping from the map, via the\\n     * {@code Iterator.remove}, {@code Set.remove},\\n     * {@code removeAll}, {@code retainAll}, and {@code clear}\\n     * operations.  It does not support the {@code add} or {@code addAll}\\n     * operations.\\n     *\\n     * @return a set view of the keys contained in this map\\n     \"}"}, {"color": "#97c2fc", "id": "java.util.Set", "label": "java.util.Set", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": " boolean contains(Object o)", "label": " boolean contains(Object o)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if this list contains the specified element.\\n     * More formally, returns {@code true} if and only if this list contains\\n     * at least one element {@code e} such that\\n     * {@code Objects.equals(o, e)}.\\n     *\\n     * @param o element whose presence in this list is to be tested\\n     * @return {@code true} if this list contains the specified element\\n     * @throws ClassCastException if the type of the specified element\\n     *         is incompatible with this list\\n     * (\u003ca href=\"Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     * @throws NullPointerException if the specified element is null and this\\n     *         list does not permit null elements\\n     * (\u003ca href=\"Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     \u0027}"}, {"color": "#97c2fc", "id": " Iterator\u003cE\u003e iterator()", "label": " Iterator\u003cE\u003e iterator()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an iterator over the elements in this list in proper sequence.\\n     *\\n     * @return an iterator over the elements in this list in proper sequence\\n     \u0027}"}, {"color": "#97c2fc", "id": " Object[] toArray()", "label": " Object[] toArray()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an array containing the elements of this stream.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @return an array, whose {@linkplain Class#getComponentType runtime component\\n     * type} is {@code Object}, containing the elements of this stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " T[] toArray(T[] a)", "label": " T[] toArray(T[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an array containing all of the elements in this list in\\n     * proper sequence (from first to last element); the runtime type of\\n     * the returned array is that of the specified array.  If the list fits\\n     * in the specified array, it is returned therein.  Otherwise, a new\\n     * array is allocated with the runtime type of the specified array and\\n     * the size of this list.\\n     *\\n     * \u003cp\u003eIf the list fits in the specified array with room to spare (i.e.,\\n     * the array has more elements than the list), the element in the array\\n     * immediately following the end of the list is set to {@code null}.\\n     * (This is useful in determining the length of the list \u003ci\u003eonly\u003c/i\u003e if\\n     * the caller knows that the list does not contain any null elements.)\\n     *\\n     * \u003cp\u003eLike the {@link #toArray()} method, this method acts as bridge between\\n     * array-based and collection-based APIs.  Further, this method allows\\n     * precise control over the runtime type of the output array, and may,\\n     * under certain circumstances, be used to save allocation costs.\\n     *\\n     * \u003cp\u003eSuppose {@code x} is a list known to contain only strings.\\n     * The following code can be used to dump the list into a newly\\n     * allocated array of {@code String}:\\n     *\\n     * \u003cpre\u003e{@code\\n     *     String[] y = x.toArray(new String[0]);\\n     * }\u003c/pre\u003e\\n     *\\n     * Note that {@code toArray(new Object[0])} is identical in function to\\n     * {@code toArray()}.\\n     *\\n     * @param a the array into which the elements of this list are to\\n     *          be stored, if it is big enough; otherwise, a new array of the\\n     *          same runtime type is allocated for this purpose.\\n     * @return an array containing the elements of this list\\n     * @throws ArrayStoreException if the runtime type of the specified array\\n     *         is not a supertype of the runtime type of every element in\\n     *         this list\\n     * @throws NullPointerException if the specified array is null\\n     \u0027}"}, {"color": "#97c2fc", "id": "toArray()", "label": "toArray()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " boolean add(E e)", "label": " boolean add(E e)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Appends the specified element to the end of this list (optional\\n     * operation).\\n     *\\n     * \u003cp\u003eLists that support this operation may place limitations on what\\n     * elements may be added to this list.  In particular, some\\n     * lists will refuse to add null elements, and others will impose\\n     * restrictions on the type of elements that may be added.  List\\n     * classes should clearly specify in their documentation any restrictions\\n     * on what elements may be added.\\n     *\\n     * @param e element to be appended to this list\\n     * @return {@code true} (as specified by {@link Collection#add})\\n     * @throws UnsupportedOperationException if the {@code add} operation\\n     *         is not supported by this list\\n     * @throws ClassCastException if the class of the specified element\\n     *         prevents it from being added to this list\\n     * @throws NullPointerException if the specified element is null and this\\n     *         list does not permit null elements\\n     * @throws IllegalArgumentException if some property of this element\\n     *         prevents it from being added to this list\\n     \u0027}"}, {"color": "#97c2fc", "id": "add", "label": "add", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.util.Collection", "label": "java.util.Collection", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "toArray(IntFunction)", "label": "toArray(IntFunction)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "toArray(Object", "label": "toArray(Object", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " T[] toArray(IntFunction\u003cT[]\u003e generator)", "label": " T[] toArray(IntFunction\u003cT[]\u003e generator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an array containing all of the elements in this collection,\\n     * using the provided {@code generator} function to allocate the returned array.\\n     *\\n     * \u003cp\u003eIf this collection makes any guarantees as to what order its elements\\n     * are returned by its iterator, this method must return the elements in\\n     * the same order.\\n     *\\n     * @apiNote\\n     * This method acts as a bridge between array-based and collection-based APIs.\\n     * It allows creation of an array of a particular runtime type. Use\\n     * {@link #toArray()} to create an array whose runtime type is {@code Object[]},\\n     * or use {@link #toArray(Object[]) toArray(T[])} to reuse an existing array.\\n     *\\n     * \u003cp\u003eSuppose {@code x} is a collection known to contain only strings.\\n     * The following code can be used to dump the collection into a newly\\n     * allocated array of {@code String}:\\n     *\\n     * \u003cpre\u003e\\n     *     String[] y = x.toArray(String[]::new);\u003c/pre\u003e\\n     *\\n     * @implSpec\\n     * The default implementation calls the generator function with zero\\n     * and then passes the resulting array to {@link #toArray(Object[]) toArray(T[])}.\\n     *\\n     * @param \u003cT\u003e the component type of the array to contain the collection\\n     * @param generator a function which produces a new array of the desired\\n     *                  type and the provided length\\n     * @return an array containing all of the elements in this collection\\n     * @throws ArrayStoreException if the runtime type of any element in this\\n     *         collection is not assignable to the {@linkplain Class#getComponentType\\n     *         runtime component type} of the generated array\\n     * @throws NullPointerException if the generator function is null\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean remove(Object o)", "label": " boolean remove(Object o)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Removes the specified element from this set if it is present\\n     * (optional operation).  More formally, removes an element {@code e}\\n     * such that\\n     * {@code Objects.equals(o, e)}, if\\n     * this set contains such an element.  Returns {@code true} if this set\\n     * contained the element (or equivalently, if this set changed as a\\n     * result of the call).  (This set will not contain the element once the\\n     * call returns.)\\n     *\\n     * @param o object to be removed from this set, if present\\n     * @return {@code true} if this set contained the specified element\\n     * @throws ClassCastException if the type of the specified element\\n     *         is incompatible with this set\\n     * (\u003ca href=\"Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     * @throws NullPointerException if the specified element is null and this\\n     *         set does not permit null elements\\n     * (\u003ca href=\"Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     * @throws UnsupportedOperationException if the {@code remove} operation\\n     *         is not supported by this set\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean containsAll(Collection\u003c?\u003e c)", "label": " boolean containsAll(Collection\u003c?\u003e c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if this set contains all of the elements of the\\n     * specified collection.  If the specified collection is also a set, this\\n     * method returns {@code true} if it is a \u003ci\u003esubset\u003c/i\u003e of this set.\\n     *\\n     * @param  c collection to be checked for containment in this set\\n     * @return {@code true} if this set contains all of the elements of the\\n     *         specified collection\\n     * @throws ClassCastException if the types of one or more elements\\n     *         in the specified collection are incompatible with this\\n     *         set\\n     * (\u003ca href=\"Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     * @throws NullPointerException if the specified collection contains one\\n     *         or more null elements and this set does not permit null\\n     *         elements\\n     * (\u003ca href=\"Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e),\\n     *         or if the specified collection is null\\n     * @see    #contains(Object)\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean addAll(Collection\u003c? extends E\u003e c)", "label": " boolean addAll(Collection\u003c? extends E\u003e c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Adds all of the elements in the specified collection to this set if\\n     * they\u0027re not already present (optional operation).  If the specified\\n     * collection is also a set, the {@code addAll} operation effectively\\n     * modifies this set so that its value is the \u003ci\u003eunion\u003c/i\u003e of the two\\n     * sets.  The behavior of this operation is undefined if the specified\\n     * collection is modified while the operation is in progress.\\n     *\\n     * @param  c collection containing elements to be added to this set\\n     * @return {@code true} if this set changed as a result of the call\\n     *\\n     * @throws UnsupportedOperationException if the {@code addAll} operation\\n     *         is not supported by this set\\n     * @throws ClassCastException if the class of an element of the\\n     *         specified collection prevents it from being added to this set\\n     * @throws NullPointerException if the specified collection contains one\\n     *         or more null elements and this set does not permit null\\n     *         elements, or if the specified collection is null\\n     * @throws IllegalArgumentException if some property of an element of the\\n     *         specified collection prevents it from being added to this set\\n     * @see #add(Object)\\n     \"}"}, {"color": "#97c2fc", "id": " boolean removeAll(Collection\u003c?\u003e c)", "label": " boolean removeAll(Collection\u003c?\u003e c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Removes from this set all of its elements that are contained in the\\n     * specified collection (optional operation).  If the specified\\n     * collection is also a set, this operation effectively modifies this\\n     * set so that its value is the \u003ci\u003easymmetric set difference\u003c/i\u003e of\\n     * the two sets.\\n     *\\n     * @param  c collection containing elements to be removed from this set\\n     * @return {@code true} if this set changed as a result of the call\\n     * @throws UnsupportedOperationException if the {@code removeAll} operation\\n     *         is not supported by this set\\n     * @throws ClassCastException if the class of an element of this set\\n     *         is incompatible with the specified collection\\n     * (\u003ca href=\"Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     * @throws NullPointerException if this set contains a null element and the\\n     *         specified collection does not permit null elements\\n     *         (\u003ca href=\"Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e),\\n     *         or if the specified collection is null\\n     * @see #remove(Object)\\n     * @see #contains(Object)\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean removeIf(Predicate\u003c? super E\u003e filter)", "label": " boolean removeIf(Predicate\u003c? super E\u003e filter)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Removes all of the elements of this collection that satisfy the given\\n     * predicate.  Errors or runtime exceptions thrown during iteration or by\\n     * the predicate are relayed to the caller.\\n     *\\n     * @implSpec\\n     * The default implementation traverses all elements of the collection using\\n     * its {@link #iterator}.  Each matching element is removed using\\n     * {@link Iterator#remove()}.  If the collection\u0027s iterator does not\\n     * support removal then an {@code UnsupportedOperationException} will be\\n     * thrown on the first matching element.\\n     *\\n     * @param filter a predicate which returns {@code true} for elements to be\\n     *        removed\\n     * @return {@code true} if any elements were removed\\n     * @throws NullPointerException if the specified filter is null\\n     * @throws UnsupportedOperationException if elements cannot be removed\\n     *         from this collection.  Implementations may throw this exception if a\\n     *         matching element cannot be removed or if, in general, removal is not\\n     *         supported.\\n     * @since 1.8\\n     \"}"}, {"color": "#97c2fc", "id": "iterator", "label": "iterator", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "remove()", "label": "remove()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.util.Iterator", "label": "java.util.Iterator", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * An iterator over a collection.  {@code Iterator} takes the place of\\n * {@link Enumeration} in the Java Collections Framework.  Iterators\\n * differ from enumerations in two ways:\\n *\\n * \u003cul\u003e\\n *      \u003cli\u003e Iterators allow the caller to remove elements from the\\n *           underlying collection during the iteration with well-defined\\n *           semantics.\\n *      \u003cli\u003e Method names have been improved.\\n * \u003c/ul\u003e\\n *\\n * \u003cp\u003eThis interface is a member of the\\n * \u003ca href=\"{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework\"\u003e\\n * Java Collections Framework\u003c/a\u003e.\\n *\\n * @apiNote\\n * An {@link Enumeration} can be converted into an {@code Iterator} by\\n * using the {@link Enumeration#asIterator} method.\\n *\\n * @param \u003cE\u003e the type of elements returned by this iterator\\n *\\n * @author  Josh Bloch\\n * @see Collection\\n * @see ListIterator\\n * @see Iterable\\n * @since 1.2\\n \u0027}"}, {"color": "#97c2fc", "id": " boolean hasNext()", "label": " boolean hasNext()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if this list iterator has more elements when\\n     * traversing the list in the forward direction. (In other words,\\n     * returns {@code true} if {@link #next} would return an element rather\\n     * than throwing an exception.)\\n     *\\n     * @return {@code true} if the list iterator has more elements when\\n     *         traversing the list in the forward direction\\n     \u0027}"}, {"color": "#97c2fc", "id": "next", "label": "next", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " E next()", "label": " E next()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the next element in the list and advances the cursor position.\\n     * This method may be called repeatedly to iterate through the list,\\n     * or intermixed with calls to {@link #previous} to go back and forth.\\n     * (Note that alternating calls to {@code next} and {@code previous}\\n     * will return the same element repeatedly.)\\n     *\\n     * @return the next element in the list\\n     * @throws NoSuchElementException if the iteration has no next element\\n     \u0027}"}, {"color": "#97c2fc", "id": " void remove()", "label": " void remove()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Removes from the list the last element that was returned by {@link\\n     * #next} or {@link #previous} (optional operation).  This call can\\n     * only be made once per call to {@code next} or {@code previous}.\\n     * It can be made only if {@link #add} has not been\\n     * called after the last call to {@code next} or {@code previous}.\\n     *\\n     * @throws UnsupportedOperationException if the {@code remove}\\n     *         operation is not supported by this list iterator\\n     * @throws IllegalStateException if neither {@code next} nor\\n     *         {@code previous} have been called, or {@code remove} or\\n     *         {@code add} have been called after the last call to\\n     *         {@code next} or {@code previous}\\n     \u0027}"}, {"color": "#97c2fc", "id": "forEachRemaining", "label": "forEachRemaining", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "UnsupportedOperationException", "label": "UnsupportedOperationException", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": " void forEachRemaining(Consumer\u003c? super E\u003e action)", "label": " void forEachRemaining(Consumer\u003c? super E\u003e action)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs the given action for each remaining element until all elements\\n     * have been processed or the action throws an exception.  Actions are\\n     * performed in the order of iteration, if that order is specified.\\n     * Exceptions thrown by the action are relayed to the caller.\\n     * \u003cp\u003e\\n     * The behavior of an iterator is unspecified if the action modifies the\\n     * collection in any way (even by calling the {@link #remove remove} method\\n     * or other mutator methods of {@code Iterator} subtypes),\\n     * unless an overriding class has specified a concurrent modification policy.\\n     * \u003cp\u003e\\n     * Subsequent behavior of an iterator is unspecified if the action throws an\\n     * exception.\\n     *\\n     * @implSpec\\n     * \u003cp\u003eThe default implementation behaves as if:\\n     * \u003cpre\u003e{@code\\n     *     while (hasNext())\\n     *         action.accept(next());\\n     * }\u003c/pre\u003e\\n     *\\n     * @param action The action to be performed for each element\\n     * @throws NullPointerException if the specified action is null\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "remove", "label": "remove", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " boolean retainAll(Collection\u003c?\u003e c)", "label": " boolean retainAll(Collection\u003c?\u003e c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Retains only the elements in this set that are contained in the\\n     * specified collection (optional operation).  In other words, removes\\n     * from this set all of its elements that are not contained in the\\n     * specified collection.  If the specified collection is also a set, this\\n     * operation effectively modifies this set so that its value is the\\n     * \u003ci\u003eintersection\u003c/i\u003e of the two sets.\\n     *\\n     * @param  c collection containing elements to be retained in this set\\n     * @return {@code true} if this set changed as a result of the call\\n     * @throws UnsupportedOperationException if the {@code retainAll} operation\\n     *         is not supported by this set\\n     * @throws ClassCastException if the class of an element of this set\\n     *         is incompatible with the specified collection\\n     * (\u003ca href=\"Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     * @throws NullPointerException if this set contains a null element and the\\n     *         specified collection does not permit null elements\\n     *         (\u003ca href=\"Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e),\\n     *         or if the specified collection is null\\n     * @see #remove(Object)\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean equals(Object o)", "label": " boolean equals(Object o)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares the specified object with this map for equality.  Returns\\n     * {@code true} if the given object is also a map and the two maps\\n     * represent the same mappings.  More formally, two maps {@code m1} and\\n     * {@code m2} represent the same mappings if\\n     * {@code m1.entrySet().equals(m2.entrySet())}.  This ensures that the\\n     * {@code equals} method works properly across different implementations\\n     * of the {@code Map} interface.\\n     *\\n     * @param o object to be compared for equality with this map\\n     * @return {@code true} if the specified object is equal to this map\\n     \u0027}"}, {"color": "#97c2fc", "id": " int hashCode()", "label": " int hashCode()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the hash code value for this map.  The hash code of a map is\\n     * defined to be the sum of the hash codes of each entry in the map\u0027s\\n     * {@code entrySet()} view.  This ensures that {@code m1.equals(m2)}\\n     * implies that {@code m1.hashCode()==m2.hashCode()} for any two maps\\n     * {@code m1} and {@code m2}, as required by the general contract of\\n     * {@link Object#hashCode}.\\n     *\\n     * @return the hash code value for this map\\n     * @see Map.Entry#hashCode()\\n     * @see Object#equals(Object)\\n     * @see #equals(Object)\\n     \"}"}, {"color": "#97c2fc", "id": " Spliterator\u003cE\u003e spliterator()", "label": " Spliterator\u003cE\u003e spliterator()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a {@code Spliterator} over the elements in this set.\\n     *\\n     * \u003cp\u003eThe {@code Spliterator} reports {@link Spliterator#DISTINCT}.\\n     * Implementations should document the reporting of additional\\n     * characteristic values.\\n     *\\n     * @implSpec\\n     * The default implementation creates a\\n     * \u003cem\u003e\u003ca href=\"Spliterator.html#binding\"\u003elate-binding\u003c/a\u003e\u003c/em\u003e spliterator\\n     * from the set\\\u0027s {@code Iterator}.  The spliterator inherits the\\n     * \u003cem\u003efail-fast\u003c/em\u003e properties of the set\\\u0027s iterator.\\n     * \u003cp\u003e\\n     * The created {@code Spliterator} additionally reports\\n     * {@link Spliterator#SIZED}.\\n     *\\n     * @implNote\\n     * The created {@code Spliterator} additionally reports\\n     * {@link Spliterator#SUBSIZED}.\\n     *\\n     * @return a {@code Spliterator} over the elements in this set\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "SIZED", "label": "SIZED", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.util.Spliterator", "label": "java.util.Spliterator", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * An object for traversing and partitioning elements of a source.  The source\\n * of elements covered by a Spliterator could be, for example, an array, a\\n * {@link Collection}, an IO channel, or a generator function.\\n *\\n * \u003cp\u003eA Spliterator may traverse elements individually ({@link\\n * #tryAdvance tryAdvance()}) or sequentially in bulk\\n * ({@link #forEachRemaining forEachRemaining()}).\\n *\\n * \u003cp\u003eA Spliterator may also partition off some of its elements (using\\n * {@link #trySplit}) as another Spliterator, to be used in\\n * possibly-parallel operations.  Operations using a Spliterator that\\n * cannot split, or does so in a highly imbalanced or inefficient\\n * manner, are unlikely to benefit from parallelism.  Traversal\\n * and splitting exhaust elements; each Spliterator is useful for only a single\\n * bulk computation.\\n *\\n * \u003cp\u003eA Spliterator also reports a set of {@link #characteristics()} of its\\n * structure, source, and elements from among {@link #ORDERED},\\n * {@link #DISTINCT}, {@link #SORTED}, {@link #SIZED}, {@link #NONNULL},\\n * {@link #IMMUTABLE}, {@link #CONCURRENT}, and {@link #SUBSIZED}. These may\\n * be employed by Spliterator clients to control, specialize or simplify\\n * computation.  For example, a Spliterator for a {@link Collection} would\\n * report {@code SIZED}, a Spliterator for a {@link Set} would report\\n * {@code DISTINCT}, and a Spliterator for a {@link SortedSet} would also\\n * report {@code SORTED}.  Characteristics are reported as a simple unioned bit\\n * set.\\n *\\n * Some characteristics additionally constrain method behavior; for example if\\n * {@code ORDERED}, traversal methods must conform to their documented ordering.\\n * New characteristics may be defined in the future, so implementors should not\\n * assign meanings to unlisted values.\\n *\\n * \u003cp\u003e\u003ca id=\"binding\"\u003eA Spliterator that does not report {@code IMMUTABLE} or\\n * {@code CONCURRENT} is expected to have a documented policy concerning:\\n * when the spliterator \u003cem\u003ebinds\u003c/em\u003e to the element source; and detection of\\n * structural interference of the element source detected after binding.\u003c/a\u003e  A\\n * \u003cem\u003elate-binding\u003c/em\u003e Spliterator binds to the source of elements at the\\n * point of first traversal, first split, or first query for estimated size,\\n * rather than at the time the Spliterator is created.  A Spliterator that is\\n * not \u003cem\u003elate-binding\u003c/em\u003e binds to the source of elements at the point of\\n * construction or first invocation of any method.  Modifications made to the\\n * source prior to binding are reflected when the Spliterator is traversed.\\n * After binding a Spliterator should, on a best-effort basis, throw\\n * {@link ConcurrentModificationException} if structural interference is\\n * detected.  Spliterators that do this are called \u003cem\u003efail-fast\u003c/em\u003e.  The\\n * bulk traversal method ({@link #forEachRemaining forEachRemaining()}) of a\\n * Spliterator may optimize traversal and check for structural interference\\n * after all elements have been traversed, rather than checking per-element and\\n * failing immediately.\\n *\\n * \u003cp\u003eSpliterators can provide an estimate of the number of remaining elements\\n * via the {@link #estimateSize} method.  Ideally, as reflected in characteristic\\n * {@link #SIZED}, this value corresponds exactly to the number of elements\\n * that would be encountered in a successful traversal.  However, even when not\\n * exactly known, an estimated value may still be useful to operations\\n * being performed on the source, such as helping to determine whether it is\\n * preferable to split further or traverse the remaining elements sequentially.\\n *\\n * \u003cp\u003eDespite their obvious utility in parallel algorithms, spliterators are not\\n * expected to be thread-safe; instead, implementations of parallel algorithms\\n * using spliterators should ensure that the spliterator is only used by one\\n * thread at a time.  This is generally easy to attain via \u003cem\u003eserial\\n * thread-confinement\u003c/em\u003e, which often is a natural consequence of typical\\n * parallel algorithms that work by recursive decomposition.  A thread calling\\n * {@link #trySplit()} may hand over the returned Spliterator to another thread,\\n * which in turn may traverse or further split that Spliterator.  The behaviour\\n * of splitting and traversal is undefined if two or more threads operate\\n * concurrently on the same spliterator.  If the original thread hands a\\n * spliterator off to another thread for processing, it is best if that handoff\\n * occurs before any elements are consumed with {@link #tryAdvance(Consumer)\\n * tryAdvance()}, as certain guarantees (such as the accuracy of\\n * {@link #estimateSize()} for {@code SIZED} spliterators) are only valid before\\n * traversal has begun.\\n *\\n * \u003cp\u003ePrimitive subtype specializations of {@code Spliterator} are provided for\\n * {@link OfInt int}, {@link OfLong long}, and {@link OfDouble double} values.\\n * The subtype default implementations of\\n * {@link Spliterator#tryAdvance(java.util.function.Consumer)}\\n * and {@link Spliterator#forEachRemaining(java.util.function.Consumer)} box\\n * primitive values to instances of their corresponding wrapper class.  Such\\n * boxing may undermine any performance advantages gained by using the primitive\\n * specializations.  To avoid boxing, the corresponding primitive-based methods\\n * should be used.  For example,\\n * {@link Spliterator.OfInt#tryAdvance(java.util.function.IntConsumer)}\\n * and {@link Spliterator.OfInt#forEachRemaining(java.util.function.IntConsumer)}\\n * should be used in preference to\\n * {@link Spliterator.OfInt#tryAdvance(java.util.function.Consumer)} and\\n * {@link Spliterator.OfInt#forEachRemaining(java.util.function.Consumer)}.\\n * Traversal of primitive values using boxing-based methods\\n * {@link #tryAdvance tryAdvance()} and\\n * {@link #forEachRemaining(java.util.function.Consumer) forEachRemaining()}\\n * does not affect the order in which the values, transformed to boxed values,\\n * are encountered.\\n *\\n * @apiNote\\n * \u003cp\u003eSpliterators, like {@code Iterator}s, are for traversing the elements of\\n * a source.  The {@code Spliterator} API was designed to support efficient\\n * parallel traversal in addition to sequential traversal, by supporting\\n * decomposition as well as single-element iteration.  In addition, the\\n * protocol for accessing elements via a Spliterator is designed to impose\\n * smaller per-element overhead than {@code Iterator}, and to avoid the inherent\\n * race involved in having separate methods for {@code hasNext()} and\\n * {@code next()}.\\n *\\n * \u003cp\u003eFor mutable sources, arbitrary and non-deterministic behavior may occur if\\n * the source is structurally interfered with (elements added, replaced, or\\n * removed) between the time that the Spliterator binds to its data source and\\n * the end of traversal.  For example, such interference will produce arbitrary,\\n * non-deterministic results when using the {@code java.util.stream} framework.\\n *\\n * \u003cp\u003eStructural interference of a source can be managed in the following ways\\n * (in approximate order of decreasing desirability):\\n * \u003cul\u003e\\n * \u003cli\u003eThe source cannot be structurally interfered with.\\n * \u003cbr\u003eFor example, an instance of\\n * {@link java.util.concurrent.CopyOnWriteArrayList} is an immutable source.\\n * A Spliterator created from the source reports a characteristic of\\n * {@code IMMUTABLE}.\u003c/li\u003e\\n * \u003cli\u003eThe source manages concurrent modifications.\\n * \u003cbr\u003eFor example, a key set of a {@link java.util.concurrent.ConcurrentHashMap}\\n * is a concurrent source.  A Spliterator created from the source reports a\\n * characteristic of {@code CONCURRENT}.\u003c/li\u003e\\n * \u003cli\u003eThe mutable source provides a late-binding and fail-fast Spliterator.\\n * \u003cbr\u003eLate binding narrows the window during which interference can affect\\n * the calculation; fail-fast detects, on a best-effort basis, that structural\\n * interference has occurred after traversal has commenced and throws\\n * {@link ConcurrentModificationException}.  For example, {@link ArrayList},\\n * and many other non-concurrent {@code Collection} classes in the JDK, provide\\n * a late-binding, fail-fast spliterator.\u003c/li\u003e\\n * \u003cli\u003eThe mutable source provides a non-late-binding but fail-fast Spliterator.\\n * \u003cbr\u003eThe source increases the likelihood of throwing\\n * {@code ConcurrentModificationException} since the window of potential\\n * interference is larger.\u003c/li\u003e\\n * \u003cli\u003eThe mutable source provides a late-binding and non-fail-fast Spliterator.\\n * \u003cbr\u003eThe source risks arbitrary, non-deterministic behavior after traversal\\n * has commenced since interference is not detected.\\n * \u003c/li\u003e\\n * \u003cli\u003eThe mutable source provides a non-late-binding and non-fail-fast\\n * Spliterator.\\n * \u003cbr\u003eThe source increases the risk of arbitrary, non-deterministic behavior\\n * since non-detected interference may occur after construction.\\n * \u003c/li\u003e\\n * \u003c/ul\u003e\\n *\\n * \u003cp\u003e\u003cb\u003eExample.\u003c/b\u003e Here is a class (not a very useful one, except\\n * for illustration) that maintains an array in which the actual data\\n * are held in even locations, and unrelated tag data are held in odd\\n * locations. Its Spliterator ignores the tags.\\n *\\n * \u003cpre\u003e {@code\\n * class TaggedArray\u003cT\u003e {\\n *   private final Object[] elements; // immutable after construction\\n *   TaggedArray(T[] data, Object[] tags) {\\n *     int size = data.length;\\n *     if (tags.length != size) throw new IllegalArgumentException();\\n *     this.elements = new Object[2 * size];\\n *     for (int i = 0, j = 0; i \u003c size; ++i) {\\n *       elements[j++] = data[i];\\n *       elements[j++] = tags[i];\\n *     }\\n *   }\\n *\\n *   public Spliterator\u003cT\u003e spliterator() {\\n *     return new TaggedArraySpliterator\u003c\u003e(elements, 0, elements.length);\\n *   }\\n *\\n *   static class TaggedArraySpliterator\u003cT\u003e implements Spliterator\u003cT\u003e {\\n *     private final Object[] array;\\n *     private int origin; // current index, advanced on split or traversal\\n *     private final int fence; // one past the greatest index\\n *\\n *     TaggedArraySpliterator(Object[] array, int origin, int fence) {\\n *       this.array = array; this.origin = origin; this.fence = fence;\\n *     }\\n *\\n *     public void forEachRemaining(Consumer\u003c? super T\u003e action) {\\n *       for (; origin \u003c fence; origin += 2)\\n *         action.accept((T) array[origin]);\\n *     }\\n *\\n *     public boolean tryAdvance(Consumer\u003c? super T\u003e action) {\\n *       if (origin \u003c fence) {\\n *         action.accept((T) array[origin]);\\n *         origin += 2;\\n *         return true;\\n *       }\\n *       else // cannot advance\\n *         return false;\\n *     }\\n *\\n *     public Spliterator\u003cT\u003e trySplit() {\\n *       int lo = origin; // divide range in half\\n *       int mid = ((lo + fence) \u003e\u003e\u003e 1) \u0026 ~1; // force midpoint to be even\\n *       if (lo \u003c mid) { // split out left half\\n *         origin = mid; // reset this Spliterator\\\u0027s origin\\n *         return new TaggedArraySpliterator\u003c\u003e(array, lo, mid);\\n *       }\\n *       else       // too small to split\\n *         return null;\\n *     }\\n *\\n *     public long estimateSize() {\\n *       return (long)((fence - origin) / 2);\\n *     }\\n *\\n *     public int characteristics() {\\n *       return ORDERED | SIZED | IMMUTABLE | SUBSIZED;\\n *     }\\n *   }\\n * }}\u003c/pre\u003e\\n *\\n * \u003cp\u003eAs an example how a parallel computation framework, such as the\\n * {@code java.util.stream} package, would use Spliterator in a parallel\\n * computation, here is one way to implement an associated parallel forEach,\\n * that illustrates the primary usage idiom of splitting off subtasks until\\n * the estimated amount of work is small enough to perform\\n * sequentially. Here we assume that the order of processing across\\n * subtasks doesn\\\u0027t matter; different (forked) tasks may further split\\n * and process elements concurrently in undetermined order.  This\\n * example uses a {@link java.util.concurrent.CountedCompleter};\\n * similar usages apply to other parallel task constructions.\\n *\\n * \u003cpre\u003e{@code\\n * static \u003cT\u003e void parEach(TaggedArray\u003cT\u003e a, Consumer\u003cT\u003e action) {\\n *   Spliterator\u003cT\u003e s = a.spliterator();\\n *   long targetBatchSize = s.estimateSize() / (ForkJoinPool.getCommonPoolParallelism() * 8);\\n *   new ParEach(null, s, action, targetBatchSize).invoke();\\n * }\\n *\\n * static class ParEach\u003cT\u003e extends CountedCompleter\u003cVoid\u003e {\\n *   final Spliterator\u003cT\u003e spliterator;\\n *   final Consumer\u003cT\u003e action;\\n *   final long targetBatchSize;\\n *\\n *   ParEach(ParEach\u003cT\u003e parent, Spliterator\u003cT\u003e spliterator,\\n *           Consumer\u003cT\u003e action, long targetBatchSize) {\\n *     super(parent);\\n *     this.spliterator = spliterator; this.action = action;\\n *     this.targetBatchSize = targetBatchSize;\\n *   }\\n *\\n *   public void compute() {\\n *     Spliterator\u003cT\u003e sub;\\n *     while (spliterator.estimateSize() \u003e targetBatchSize \u0026\u0026\\n *            (sub = spliterator.trySplit()) != null) {\\n *       addToPendingCount(1);\\n *       new ParEach\u003c\u003e(this, sub, action, targetBatchSize).fork();\\n *     }\\n *     spliterator.forEachRemaining(action);\\n *     propagateCompletion();\\n *   }\\n * }}\u003c/pre\u003e\\n *\\n * @implNote\\n * If the boolean system property {@systemProperty org.openjdk.java.util.stream.tripwire}\\n * is set to {@code true} then diagnostic warnings are reported if boxing of\\n * primitive values occur when operating on primitive subtype specializations.\\n *\\n * @param \u003cT\u003e the type of elements returned by this Spliterator\\n *\\n * @see Collection\\n * @since 1.8\\n \u0027}"}, {"color": "#97c2fc", "id": " boolean tryAdvance(Consumer\u003c? super T\u003e action)", "label": " boolean tryAdvance(Consumer\u003c? super T\u003e action)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * If a remaining element exists, performs the given action on it,\\n     * returning {@code true}; else returns {@code false}.  If this\\n     * Spliterator is {@link #ORDERED} the action is performed on the\\n     * next element in encounter order.  Exceptions thrown by the\\n     * action are relayed to the caller.\\n     * \u003cp\u003e\\n     * Subsequent behavior of a spliterator is unspecified if the action throws\\n     * an exception.\\n     *\\n     * @param action The action\\n     * @return {@code false} if no remaining elements existed\\n     * upon entry to this method, else {@code true}.\\n     * @throws NullPointerException if the specified action is null\\n     \u0027}"}, {"color": "#97c2fc", "id": "ORDERED", "label": "ORDERED", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " void forEachRemaining(Consumer\u003c? super T\u003e action)", "label": " void forEachRemaining(Consumer\u003c? super T\u003e action)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs the given action for each remaining element, sequentially in\\n     * the current thread, until all elements have been processed or the action\\n     * throws an exception.  If this Spliterator is {@link #ORDERED}, actions\\n     * are performed in encounter order.  Exceptions thrown by the action\\n     * are relayed to the caller.\\n     * \u003cp\u003e\\n     * Subsequent behavior of a spliterator is unspecified if the action throws\\n     * an exception.\\n     *\\n     * @implSpec\\n     * The default implementation repeatedly invokes {@link #tryAdvance} until\\n     * it returns {@code false}.  It should be overridden whenever possible.\\n     *\\n     * @param action The action\\n     * @throws NullPointerException if the specified action is null\\n     \u0027}"}, {"color": "#97c2fc", "id": "tryAdvance", "label": "tryAdvance", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " Spliterator\u003cT\u003e trySplit()", "label": " Spliterator\u003cT\u003e trySplit()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * If this spliterator can be partitioned, returns a Spliterator\\n     * covering elements, that will, upon return from this method, not\\n     * be covered by this Spliterator.\\n     *\\n     * \u003cp\u003eIf this Spliterator is {@link #ORDERED}, the returned Spliterator\\n     * must cover a strict prefix of the elements.\\n     *\\n     * \u003cp\u003eUnless this Spliterator covers an infinite number of elements,\\n     * repeated calls to {@code trySplit()} must eventually return {@code null}.\\n     * Upon non-null return:\\n     * \u003cul\u003e\\n     * \u003cli\u003ethe value reported for {@code estimateSize()} before splitting,\\n     * must, after splitting, be greater than or equal to {@code estimateSize()}\\n     * for this and the returned Spliterator; and\u003c/li\u003e\\n     * \u003cli\u003eif this Spliterator is {@code SUBSIZED}, then {@code estimateSize()}\\n     * for this spliterator before splitting must be equal to the sum of\\n     * {@code estimateSize()} for this and the returned Spliterator after\\n     * splitting.\u003c/li\u003e\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003eThis method may return {@code null} for any reason,\\n     * including emptiness, inability to split after traversal has\\n     * commenced, data structure constraints, and efficiency\\n     * considerations.\\n     *\\n     * @apiNote\\n     * An ideal {@code trySplit} method efficiently (without\\n     * traversal) divides its elements exactly in half, allowing\\n     * balanced parallel computation.  Many departures from this ideal\\n     * remain highly effective; for example, only approximately\\n     * splitting an approximately balanced tree, or for a tree in\\n     * which leaf nodes may contain either one or two elements,\\n     * failing to further split these nodes.  However, large\\n     * deviations in balance and/or overly inefficient {@code\\n     * trySplit} mechanics typically result in poor parallel\\n     * performance.\\n     *\\n     * @return a {@code Spliterator} covering some portion of the\\n     * elements, or {@code null} if this spliterator cannot be split\\n     \u0027}"}, {"color": "#97c2fc", "id": " long estimateSize()", "label": " long estimateSize()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an estimate of the number of elements that would be\\n     * encountered by a {@link #forEachRemaining} traversal, or returns {@link\\n     * Long#MAX_VALUE} if infinite, unknown, or too expensive to compute.\\n     *\\n     * \u003cp\u003eIf this Spliterator is {@link #SIZED} and has not yet been partially\\n     * traversed or split, or this Spliterator is {@link #SUBSIZED} and has\\n     * not yet been partially traversed, this estimate must be an accurate\\n     * count of elements that would be encountered by a complete traversal.\\n     * Otherwise, this estimate may be arbitrarily inaccurate, but must decrease\\n     * as specified across invocations of {@link #trySplit}.\\n     *\\n     * @apiNote\\n     * Even an inexact estimate is often useful and inexpensive to compute.\\n     * For example, a sub-spliterator of an approximately balanced binary tree\\n     * may return a value that estimates the number of elements to be half of\\n     * that of its parent; if the root Spliterator does not maintain an\\n     * accurate count, it could estimate size to be the power of two\\n     * corresponding to its maximum depth.\\n     *\\n     * @return the estimated size, or {@code Long.MAX_VALUE} if infinite,\\n     *         unknown, or too expensive to compute.\\n     \u0027}"}, {"color": "#97c2fc", "id": "MAX_VALUE", "label": "MAX_VALUE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "SUBSIZED", "label": "SUBSIZED", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "trySplit", "label": "trySplit", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " long getExactSizeIfKnown()", "label": " long getExactSizeIfKnown()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Convenience method that returns {@link #estimateSize()} if this\\n     * Spliterator is {@link #SIZED}, else {@code -1}.\\n     * @implSpec\\n     * The default implementation returns the result of {@code estimateSize()}\\n     * if the Spliterator reports a characteristic of {@code SIZED}, and\\n     * {@code -1} otherwise.\\n     *\\n     * @return the exact size, if known, else {@code -1}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "estimateSize()", "label": "estimateSize()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " int characteristics()", "label": " int characteristics()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a set of characteristics of this Spliterator and its\\n     * elements. The result is represented as ORed values from {@link\\n     * #ORDERED}, {@link #DISTINCT}, {@link #SORTED}, {@link #SIZED},\\n     * {@link #NONNULL}, {@link #IMMUTABLE}, {@link #CONCURRENT},\\n     * {@link #SUBSIZED}.  Repeated calls to {@code characteristics()} on\\n     * a given spliterator, prior to or in-between calls to {@code trySplit},\\n     * should always return the same result.\\n     *\\n     * \u003cp\u003eIf a Spliterator reports an inconsistent set of\\n     * characteristics (either those returned from a single invocation\\n     * or across multiple invocations), no guarantees can be made\\n     * about any computation using this Spliterator.\\n     *\\n     * @apiNote The characteristics of a given spliterator before splitting\\n     * may differ from the characteristics after splitting.  For specific\\n     * examples see the characteristic values {@link #SIZED}, {@link #SUBSIZED}\\n     * and {@link #CONCURRENT}.\\n     *\\n     * @return a representation of characteristics\\n     \u0027}"}, {"color": "#97c2fc", "id": "CONCURRENT", "label": "CONCURRENT", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "DISTINCT", "label": "DISTINCT", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "SORTED", "label": "SORTED", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "NONNULL", "label": "NONNULL", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "IMMUTABLE", "label": "IMMUTABLE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " boolean hasCharacteristics(int characteristics)", "label": " boolean hasCharacteristics(int characteristics)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns {@code true} if this Spliterator\u0027s {@link\\n     * #characteristics} contain all of the given characteristics.\\n     *\\n     * @implSpec\\n     * The default implementation returns true if the corresponding bits\\n     * of the given characteristics are set.\\n     *\\n     * @param characteristics the characteristics to check for\\n     * @return {@code true} if all the specified characteristics are present,\\n     * else {@code false}\\n     \"}"}, {"color": "#97c2fc", "id": "characteristics", "label": "characteristics", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " Comparator\u003c? super T\u003e getComparator()", "label": " Comparator\u003c? super T\u003e getComparator()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * If this Spliterator\u0027s source is {@link #SORTED} by a {@link Comparator},\\n     * returns that {@code Comparator}. If the source is {@code SORTED} in\\n     * {@linkplain Comparable natural order}, returns {@code null}.  Otherwise,\\n     * if the source is not {@code SORTED}, throws {@link IllegalStateException}.\\n     *\\n     * @implSpec\\n     * The default implementation always throws {@link IllegalStateException}.\\n     *\\n     * @return a Comparator, or {@code null} if the elements are sorted in the\\n     * natural order.\\n     * @throws IllegalStateException if the spliterator does not report\\n     *         a characteristic of {@code SORTED}.\\n     \"}"}, {"color": "#97c2fc", "id": "IllegalStateException", "label": "IllegalStateException", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "java.util.Comparator", "label": "java.util.Comparator", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * A comparison function, which imposes a \u003ci\u003etotal ordering\u003c/i\u003e on\\n * some collection of objects.  Comparators can be passed to a sort\\n * method (such as {@link Collections#sort(List,Comparator)\\n * Collections.sort} or {@link Arrays#sort(Object[],Comparator)\\n * Arrays.sort}) to allow precise control over the sort order.\\n * Comparators can also be used to control the order of certain data\\n * structures (such as {@linkplain SortedSet sorted sets} or\\n * {@linkplain SortedMap sorted maps}), or to provide an ordering for\\n * collections of objects that don\\\u0027t have a {@linkplain Comparable\\n * natural ordering}.\u003cp\u003e\\n *\\n * The ordering imposed by a comparator {@code c} on a set of elements\\n * {@code S} is said to be \u003ci\u003econsistent with equals\u003c/i\u003e if and only if\\n * {@code c.compare(e1, e2)==0} has the same boolean value as\\n * {@code e1.equals(e2)} for every {@code e1} and {@code e2} in\\n * {@code S}.\u003cp\u003e\\n *\\n * Caution should be exercised when using a comparator capable of imposing an\\n * ordering inconsistent with equals to order a sorted set (or sorted map).\\n * Suppose a sorted set (or sorted map) with an explicit comparator {@code c}\\n * is used with elements (or keys) drawn from a set {@code S}.  If the\\n * ordering imposed by {@code c} on {@code S} is inconsistent with equals,\\n * the sorted set (or sorted map) will behave \"strangely.\"  In particular the\\n * sorted set (or sorted map) will violate the general contract for set (or\\n * map), which is defined in terms of {@code equals}.\u003cp\u003e\\n *\\n * For example, suppose one adds two elements {@code a} and {@code b} such that\\n * {@code (a.equals(b) \u0026\u0026 c.compare(a, b) != 0)}\\n * to an empty {@code TreeSet} with comparator {@code c}.\\n * The second {@code add} operation will return\\n * true (and the size of the tree set will increase) because {@code a} and\\n * {@code b} are not equivalent from the tree set\\\u0027s perspective, even though\\n * this is contrary to the specification of the\\n * {@link Set#add Set.add} method.\u003cp\u003e\\n *\\n * Note: It is generally a good idea for comparators to also implement\\n * {@code java.io.Serializable}, as they may be used as ordering methods in\\n * serializable data structures (like {@link TreeSet}, {@link TreeMap}).  In\\n * order for the data structure to serialize successfully, the comparator (if\\n * provided) must implement {@code Serializable}.\u003cp\u003e\\n *\\n * For the mathematically inclined, the \u003ci\u003erelation\u003c/i\u003e that defines the\\n * \u003ci\u003eimposed ordering\u003c/i\u003e that a given comparator {@code c} imposes on a\\n * given set of objects {@code S} is:\u003cpre\u003e\\n *       {(x, y) such that c.compare(x, y) \u0026lt;= 0}.\\n * \u003c/pre\u003e The \u003ci\u003equotient\u003c/i\u003e for this total order is:\u003cpre\u003e\\n *       {(x, y) such that c.compare(x, y) == 0}.\\n * \u003c/pre\u003e\\n *\\n * It follows immediately from the contract for {@code compare} that the\\n * quotient is an \u003ci\u003eequivalence relation\u003c/i\u003e on {@code S}, and that the\\n * imposed ordering is a \u003ci\u003etotal order\u003c/i\u003e on {@code S}.  When we say that\\n * the ordering imposed by {@code c} on {@code S} is \u003ci\u003econsistent with\\n * equals\u003c/i\u003e, we mean that the quotient for the ordering is the equivalence\\n * relation defined by the objects\\\u0027 {@link Object#equals(Object)\\n * equals(Object)} method(s):\u003cpre\u003e\\n *     {(x, y) such that x.equals(y)}. \u003c/pre\u003e\\n *\\n * In other words, when the imposed ordering is consistent with\\n * equals, the equivalence classes defined by the equivalence relation\\n * of the {@code equals} method and the equivalence classes defined by\\n * the quotient of the {@code compare} method are the same.\\n\\n * \u003cp\u003eUnlike {@code Comparable}, a comparator may optionally permit\\n * comparison of null arguments, while maintaining the requirements for\\n * an equivalence relation.\\n *\\n * \u003cp\u003eThis interface is a member of the\\n * \u003ca href=\"{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework\"\u003e\\n * Java Collections Framework\u003c/a\u003e.\\n *\\n * @param \u003cT\u003e the type of objects that may be compared by this comparator\\n *\\n * @author  Josh Bloch\\n * @author  Neal Gafter\\n * @see Comparable\\n * @see java.io.Serializable\\n * @since 1.2\\n \u0027}"}, {"color": "#97c2fc", "id": " int compare(T o1, T o2)", "label": " int compare(T o1, T o2)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares its two arguments for order.  Returns a negative integer,\\n     * zero, or a positive integer as the first argument is less than, equal\\n     * to, or greater than the second.\u003cp\u003e\\n     *\\n     * The implementor must ensure that {@link Integer#signum\\n     * signum}{@code (compare(x, y)) == -signum(compare(y, x))} for\\n     * all {@code x} and {@code y}.  (This implies that {@code\\n     * compare(x, y)} must throw an exception if and only if {@code\\n     * compare(y, x)} throws an exception.)\u003cp\u003e\\n     *\\n     * The implementor must also ensure that the relation is transitive:\\n     * {@code ((compare(x, y)\u003e0) \u0026\u0026 (compare(y, z)\u003e0))} implies\\n     * {@code compare(x, z)\u003e0}.\u003cp\u003e\\n     *\\n     * Finally, the implementor must ensure that {@code compare(x,\\n     * y)==0} implies that {@code signum(compare(x,\\n     * z))==signum(compare(y, z))} for all {@code z}.\\n     *\\n     * @apiNote\\n     * It is generally the case, but \u003ci\u003enot\u003c/i\u003e strictly required that\\n     * {@code (compare(x, y)==0) == (x.equals(y))}.  Generally speaking,\\n     * any comparator that violates this condition should clearly indicate\\n     * this fact.  The recommended language is \"Note: this comparator\\n     * imposes orderings that are inconsistent with equals.\"\\n     *\\n     * @param o1 the first object to be compared.\\n     * @param o2 the second object to be compared.\\n     * @return a negative integer, zero, or a positive integer as the\\n     *         first argument is less than, equal to, or greater than the\\n     *         second.\\n     * @throws NullPointerException if an argument is null and this\\n     *         comparator does not permit null arguments\\n     * @throws ClassCastException if the arguments\\\u0027 types prevent them from\\n     *         being compared by this comparator.\\n     \u0027}"}, {"color": "#97c2fc", "id": "signumsignum", "label": "signumsignum", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " boolean equals(Object obj)", "label": " boolean equals(Object obj)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Indicates whether some other object is \u0026quot;equal to\u0026quot;\\n     * this comparator.  This method must obey the general contract of\\n     * {@link Object#equals(Object)}.  Additionally, this method can\\n     * return {@code true} \u003ci\u003eonly\u003c/i\u003e if the specified object is also\\n     * a comparator and it imposes the same ordering as this\\n     * comparator.  Thus, {@code comp1.equals(comp2)} implies that\\n     * {@link Integer#signum signum}{@code (comp1.compare(o1,\\n     * o2))==signum(comp2.compare(o1, o2))} for every object reference\\n     * {@code o1} and {@code o2}.\u003cp\u003e\\n     *\\n     * Note that it is \u003ci\u003ealways\u003c/i\u003e safe \u003ci\u003enot\u003c/i\u003e to override\\n     * {@code Object.equals(Object)}.  However, overriding this method may,\\n     * in some cases, improve performance by allowing programs to determine\\n     * that two distinct comparators impose the same order.\\n     *\\n     * @param   obj   the reference object with which to compare.\\n     * @return  {@code true} only if the specified object is also\\n     *          a comparator and it imposes the same ordering as this\\n     *          comparator.\\n     * @see Object#equals(Object)\\n     * @see Object#hashCode()\\n     \u0027}"}, {"color": "#97c2fc", "id": "equals(Object)", "label": "equals(Object)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "signum", "label": "signum", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " Comparator\u003cT\u003e reversed()", "label": " Comparator\u003cT\u003e reversed()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a comparator that imposes the reverse ordering of this\\n     * comparator.\\n     *\\n     * @return a comparator that imposes the reverse ordering of this\\n     *         comparator.\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": " Comparator\u003cT\u003e thenComparing(Comparator\u003c? super T\u003e other)", "label": " Comparator\u003cT\u003e thenComparing(Comparator\u003c? super T\u003e other)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a lexicographic-order comparator with another comparator.\\n     * If this {@code Comparator} considers two elements equal, i.e.\\n     * {@code compare(a, b) == 0}, {@code other} is used to determine the order.\\n     *\\n     * \u003cp\u003eThe returned comparator is serializable if the specified comparator\\n     * is also serializable.\\n     *\\n     * @apiNote\\n     * For example, to sort a collection of {@code String} based on the length\\n     * and then case-insensitive natural ordering, the comparator can be\\n     * composed using following code,\\n     *\\n     * \u003cpre\u003e{@code\\n     *     Comparator\u003cString\u003e cmp = Comparator.comparingInt(String::length)\\n     *             .thenComparing(String.CASE_INSENSITIVE_ORDER);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param  other the other comparator to be used when this comparator\\n     *         compares two objects that are equal.\\n     * @return a lexicographic-order comparator composed of this and then the\\n     *         other comparator\\n     * @throws NullPointerException if the argument is null.\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": " Comparator\u003cT\u003e thenComparing(Function\u003c? super T, ? extends U\u003e keyExtractor, Comparator\u003c? super U\u003e keyComparator)", "label": " Comparator\u003cT\u003e thenComparing(Function\u003c? super T, ? extends U\u003e keyExtractor, Comparator\u003c? super U\u003e keyComparator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a lexicographic-order comparator with a function that\\n     * extracts a key to be compared with the given {@code Comparator}.\\n     *\\n     * @implSpec This default implementation behaves as if {@code\\n     *           thenComparing(comparing(keyExtractor, cmp))}.\\n     *\\n     * @param  \u003cU\u003e  the type of the sort key\\n     * @param  keyExtractor the function used to extract the sort key\\n     * @param  keyComparator the {@code Comparator} used to compare the sort key\\n     * @return a lexicographic-order comparator composed of this comparator\\n     *         and then comparing on the key extracted by the keyExtractor function\\n     * @throws NullPointerException if either argument is null.\\n     * @see #comparing(Function, Comparator)\\n     * @see #thenComparing(Comparator)\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": " Comparator\u003cT\u003e thenComparing(Function\u003c? super T, ? extends U\u003e keyExtractor)", "label": " Comparator\u003cT\u003e thenComparing(Function\u003c? super T, ? extends U\u003e keyExtractor)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a lexicographic-order comparator with a function that\\n     * extracts a {@code Comparable} sort key.\\n     *\\n     * @implSpec This default implementation behaves as if {@code\\n     *           thenComparing(comparing(keyExtractor))}.\\n     *\\n     * @param  \u003cU\u003e  the type of the {@link Comparable} sort key\\n     * @param  keyExtractor the function used to extract the {@link\\n     *         Comparable} sort key\\n     * @return a lexicographic-order comparator composed of this and then the\\n     *         {@link Comparable} sort key.\\n     * @throws NullPointerException if the argument is null.\\n     * @see #comparing(Function)\\n     * @see #thenComparing(Comparator)\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "Comparable", "label": "Comparable", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": " Comparator\u003cT\u003e thenComparingInt(ToIntFunction\u003c? super T\u003e keyExtractor)", "label": " Comparator\u003cT\u003e thenComparingInt(ToIntFunction\u003c? super T\u003e keyExtractor)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a lexicographic-order comparator with a function that\\n     * extracts an {@code int} sort key.\\n     *\\n     * @implSpec This default implementation behaves as if {@code\\n     *           thenComparing(comparingInt(keyExtractor))}.\\n     *\\n     * @param  keyExtractor the function used to extract the integer sort key\\n     * @return a lexicographic-order comparator composed of this and then the\\n     *         {@code int} sort key\\n     * @throws NullPointerException if the argument is null.\\n     * @see #comparingInt(ToIntFunction)\\n     * @see #thenComparing(Comparator)\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": " Comparator\u003cT\u003e thenComparingLong(ToLongFunction\u003c? super T\u003e keyExtractor)", "label": " Comparator\u003cT\u003e thenComparingLong(ToLongFunction\u003c? super T\u003e keyExtractor)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a lexicographic-order comparator with a function that\\n     * extracts a {@code long} sort key.\\n     *\\n     * @implSpec This default implementation behaves as if {@code\\n     *           thenComparing(comparingLong(keyExtractor))}.\\n     *\\n     * @param  keyExtractor the function used to extract the long sort key\\n     * @return a lexicographic-order comparator composed of this and then the\\n     *         {@code long} sort key\\n     * @throws NullPointerException if the argument is null.\\n     * @see #comparingLong(ToLongFunction)\\n     * @see #thenComparing(Comparator)\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": " Comparator\u003cT\u003e thenComparingDouble(ToDoubleFunction\u003c? super T\u003e keyExtractor)", "label": " Comparator\u003cT\u003e thenComparingDouble(ToDoubleFunction\u003c? super T\u003e keyExtractor)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a lexicographic-order comparator with a function that\\n     * extracts a {@code double} sort key.\\n     *\\n     * @implSpec This default implementation behaves as if {@code\\n     *           thenComparing(comparingDouble(keyExtractor))}.\\n     *\\n     * @param  keyExtractor the function used to extract the double sort key\\n     * @return a lexicographic-order comparator composed of this and then the\\n     *         {@code double} sort key\\n     * @throws NullPointerException if the argument is null.\\n     * @see #comparingDouble(ToDoubleFunction)\\n     * @see #thenComparing(Comparator)\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Comparator\u003cT\u003e reverseOrder()", "label": "public static Comparator\u003cT\u003e reverseOrder()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a comparator that imposes the reverse of the \u003cem\u003enatural\\n     * ordering\u003c/em\u003e.\\n     *\\n     * \u003cp\u003eThe returned comparator is serializable and throws {@link\\n     * NullPointerException} when comparing {@code null}.\\n     *\\n     * @param  \u003cT\u003e the {@link Comparable} type of element to be compared\\n     * @return a comparator that imposes the reverse of the \u003ci\u003enatural\\n     *         ordering\u003c/i\u003e on {@code Comparable} objects.\\n     * @see Comparable\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "NullPointerException", "label": "NullPointerException", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public static Comparator\u003cT\u003e naturalOrder()", "label": "public static Comparator\u003cT\u003e naturalOrder()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a comparator that compares {@link Comparable} objects in natural\\n     * order.\\n     *\\n     * \u003cp\u003eThe returned comparator is serializable and throws {@link\\n     * NullPointerException} when comparing {@code null}.\\n     *\\n     * @param  \u003cT\u003e the {@link Comparable} type of element to be compared\\n     * @return a comparator that imposes the \u003ci\u003enatural ordering\u003c/i\u003e on {@code\\n     *         Comparable} objects.\\n     * @see Comparable\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Comparator\u003cT\u003e nullsFirst(Comparator\u003c? super T\u003e comparator)", "label": "public static Comparator\u003cT\u003e nullsFirst(Comparator\u003c? super T\u003e comparator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a null-friendly comparator that considers {@code null} to be\\n     * less than non-null. When both are {@code null}, they are considered\\n     * equal. If both are non-null, the specified {@code Comparator} is used\\n     * to determine the order. If the specified comparator is {@code null},\\n     * then the returned comparator considers all non-null values to be equal.\\n     *\\n     * \u003cp\u003eThe returned comparator is serializable if the specified comparator\\n     * is serializable.\\n     *\\n     * @param  \u003cT\u003e the type of the elements to be compared\\n     * @param  comparator a {@code Comparator} for comparing non-null values\\n     * @return a comparator that considers {@code null} to be less than\\n     *         non-null, and compares non-null objects with the supplied\\n     *         {@code Comparator}.\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Comparator\u003cT\u003e nullsLast(Comparator\u003c? super T\u003e comparator)", "label": "public static Comparator\u003cT\u003e nullsLast(Comparator\u003c? super T\u003e comparator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a null-friendly comparator that considers {@code null} to be\\n     * greater than non-null. When both are {@code null}, they are considered\\n     * equal. If both are non-null, the specified {@code Comparator} is used\\n     * to determine the order. If the specified comparator is {@code null},\\n     * then the returned comparator considers all non-null values to be equal.\\n     *\\n     * \u003cp\u003eThe returned comparator is serializable if the specified comparator\\n     * is serializable.\\n     *\\n     * @param  \u003cT\u003e the type of the elements to be compared\\n     * @param  comparator a {@code Comparator} for comparing non-null values\\n     * @return a comparator that considers {@code null} to be greater than\\n     *         non-null, and compares non-null objects with the supplied\\n     *         {@code Comparator}.\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Comparator\u003cT\u003e comparing(Function\u003c? super T, ? extends U\u003e keyExtractor, Comparator\u003c? super U\u003e keyComparator)", "label": "public static Comparator\u003cT\u003e comparing(Function\u003c? super T, ? extends U\u003e keyExtractor, Comparator\u003c? super U\u003e keyComparator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Accepts a function that extracts a sort key from a type {@code T}, and\\n     * returns a {@code Comparator\u003cT\u003e} that compares by that sort key using\\n     * the specified {@link Comparator}.\\n     *\\n     * \u003cp\u003eThe returned comparator is serializable if the specified function\\n     * and comparator are both serializable.\\n     *\\n     * @apiNote\\n     * For example, to obtain a {@code Comparator} that compares {@code\\n     * Person} objects by their last name ignoring case differences,\\n     *\\n     * \u003cpre\u003e{@code\\n     *     Comparator\u003cPerson\u003e cmp = Comparator.comparing(\\n     *             Person::getLastName,\\n     *             String.CASE_INSENSITIVE_ORDER);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param  \u003cT\u003e the type of element to be compared\\n     * @param  \u003cU\u003e the type of the sort key\\n     * @param  keyExtractor the function used to extract the sort key\\n     * @param  keyComparator the {@code Comparator} used to compare the sort key\\n     * @return a comparator that compares by an extracted key using the\\n     *         specified {@code Comparator}\\n     * @throws NullPointerException if either argument is null\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Comparator\u003cT\u003e comparing(Function\u003c? super T, ? extends U\u003e keyExtractor)", "label": "public static Comparator\u003cT\u003e comparing(Function\u003c? super T, ? extends U\u003e keyExtractor)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Accepts a function that extracts a {@link java.lang.Comparable\\n     * Comparable} sort key from a type {@code T}, and returns a {@code\\n     * Comparator\u003cT\u003e} that compares by that sort key.\\n     *\\n     * \u003cp\u003eThe returned comparator is serializable if the specified function\\n     * is also serializable.\\n     *\\n     * @apiNote\\n     * For example, to obtain a {@code Comparator} that compares {@code\\n     * Person} objects by their last name,\\n     *\\n     * \u003cpre\u003e{@code\\n     *     Comparator\u003cPerson\u003e byLastName = Comparator.comparing(Person::getLastName);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param  \u003cT\u003e the type of element to be compared\\n     * @param  \u003cU\u003e the type of the {@code Comparable} sort key\\n     * @param  keyExtractor the function used to extract the {@link\\n     *         Comparable} sort key\\n     * @return a comparator that compares by an extracted key\\n     * @throws NullPointerException if the argument is null\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.lang.ComparableComparable", "label": "java.lang.ComparableComparable", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public static Comparator\u003cT\u003e comparingInt(ToIntFunction\u003c? super T\u003e keyExtractor)", "label": "public static Comparator\u003cT\u003e comparingInt(ToIntFunction\u003c? super T\u003e keyExtractor)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Accepts a function that extracts an {@code int} sort key from a type\\n     * {@code T}, and returns a {@code Comparator\u003cT\u003e} that compares by that\\n     * sort key.\\n     *\\n     * \u003cp\u003eThe returned comparator is serializable if the specified function\\n     * is also serializable.\\n     *\\n     * @param  \u003cT\u003e the type of element to be compared\\n     * @param  keyExtractor the function used to extract the integer sort key\\n     * @return a comparator that compares by an extracted key\\n     * @see #comparing(Function)\\n     * @throws NullPointerException if the argument is null\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Comparator\u003cT\u003e comparingLong(ToLongFunction\u003c? super T\u003e keyExtractor)", "label": "public static Comparator\u003cT\u003e comparingLong(ToLongFunction\u003c? super T\u003e keyExtractor)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Accepts a function that extracts a {@code long} sort key from a type\\n     * {@code T}, and returns a {@code Comparator\u003cT\u003e} that compares by that\\n     * sort key.\\n     *\\n     * \u003cp\u003eThe returned comparator is serializable if the specified function is\\n     * also serializable.\\n     *\\n     * @param  \u003cT\u003e the type of element to be compared\\n     * @param  keyExtractor the function used to extract the long sort key\\n     * @return a comparator that compares by an extracted key\\n     * @see #comparing(Function)\\n     * @throws NullPointerException if the argument is null\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Comparator\u003cT\u003e comparingDouble(ToDoubleFunction\u003c? super T\u003e keyExtractor)", "label": "public static Comparator\u003cT\u003e comparingDouble(ToDoubleFunction\u003c? super T\u003e keyExtractor)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Accepts a function that extracts a {@code double} sort key from a type\\n     * {@code T}, and returns a {@code Comparator\u003cT\u003e} that compares by that\\n     * sort key.\\n     *\\n     * \u003cp\u003eThe returned comparator is serializable if the specified function\\n     * is also serializable.\\n     *\\n     * @param  \u003cT\u003e the type of element to be compared\\n     * @param  keyExtractor the function used to extract the double sort key\\n     * @return a comparator that compares by an extracted key\\n     * @see #comparing(Function)\\n     * @throws NullPointerException if the argument is null\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "emptySpliterator()", "label": "emptySpliterator()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.util.Spliterators", "label": "java.util.Spliterators", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Static classes and methods for operating on or creating instances of\\n * {@link Spliterator} and its primitive specializations\\n * {@link Spliterator.OfInt}, {@link Spliterator.OfLong}, and\\n * {@link Spliterator.OfDouble}.\\n *\\n * @see Spliterator\\n * @since 1.8\\n \u0027}"}, {"color": "#97c2fc", "id": "public static Spliterator\u003cT\u003e emptySpliterator()", "label": "public static Spliterator\u003cT\u003e emptySpliterator()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates an empty {@code Spliterator}\\n     *\\n     * \u003cp\u003eThe empty spliterator reports {@link Spliterator#SIZED} and\\n     * {@link Spliterator#SUBSIZED}.  Calls to\\n     * {@link java.util.Spliterator#trySplit()} always return {@code null}.\\n     *\\n     * @param \u003cT\u003e Type of elements\\n     * @return An empty spliterator\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Spliterator.OfInt emptyIntSpliterator()", "label": "public static Spliterator.OfInt emptyIntSpliterator()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates an empty {@code Spliterator.OfInt}\\n     *\\n     * \u003cp\u003eThe empty spliterator reports {@link Spliterator#SIZED} and\\n     * {@link Spliterator#SUBSIZED}.  Calls to\\n     * {@link java.util.Spliterator#trySplit()} always return {@code null}.\\n     *\\n     * @return An empty spliterator\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Spliterator.OfLong emptyLongSpliterator()", "label": "public static Spliterator.OfLong emptyLongSpliterator()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates an empty {@code Spliterator.OfLong}\\n     *\\n     * \u003cp\u003eThe empty spliterator reports {@link Spliterator#SIZED} and\\n     * {@link Spliterator#SUBSIZED}.  Calls to\\n     * {@link java.util.Spliterator#trySplit()} always return {@code null}.\\n     *\\n     * @return An empty spliterator\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Spliterator.OfDouble emptyDoubleSpliterator()", "label": "public static Spliterator.OfDouble emptyDoubleSpliterator()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates an empty {@code Spliterator.OfDouble}\\n     *\\n     * \u003cp\u003eThe empty spliterator reports {@link Spliterator#SIZED} and\\n     * {@link Spliterator#SUBSIZED}.  Calls to\\n     * {@link java.util.Spliterator#trySplit()} always return {@code null}.\\n     *\\n     * @return An empty spliterator\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Spliterator\u003cT\u003e spliterator(Object[] array, int additionalCharacteristics)", "label": "public static Spliterator\u003cT\u003e spliterator(Object[] array, int additionalCharacteristics)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a {@code Spliterator} covering the elements of a given array,\\n     * using a customized set of spliterator characteristics.\\n     *\\n     * \u003cp\u003eThis method is provided as an implementation convenience for\\n     * Spliterators which store portions of their elements in arrays, and need\\n     * fine control over Spliterator characteristics.  Most other situations in\\n     * which a Spliterator for an array is needed should use\\n     * {@link Arrays#spliterator(Object[])}.\\n     *\\n     * \u003cp\u003eThe returned spliterator always reports the characteristics\\n     * {@code SIZED} and {@code SUBSIZED}.  The caller may provide additional\\n     * characteristics for the spliterator to report; it is common to\\n     * additionally specify {@code IMMUTABLE} and {@code ORDERED}.\\n     *\\n     * @param \u003cT\u003e Type of elements\\n     * @param array The array, assumed to be unmodified during use\\n     * @param additionalCharacteristics Additional spliterator characteristics\\n     *        of this spliterator\u0027s source or elements beyond {@code SIZED} and\\n     *        {@code SUBSIZED} which are always reported\\n     * @return A spliterator for an array\\n     * @throws NullPointerException if the given array is {@code null}\\n     * @see Arrays#spliterator(Object[])\\n     \"}"}, {"color": "#97c2fc", "id": "spliterator(Object", "label": "spliterator(Object", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.util.Arrays", "label": "java.util.Arrays", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * This class contains various methods for manipulating arrays (such as\\n * sorting and searching). This class also contains a static factory\\n * that allows arrays to be viewed as lists.\\n *\\n * \u003cp\u003eThe methods in this class all throw a {@code NullPointerException},\\n * if the specified array reference is null, except where noted.\\n *\\n * \u003cp\u003eThe documentation for the methods contained in this class includes\\n * brief descriptions of the \u003ci\u003eimplementations\u003c/i\u003e. Such descriptions should\\n * be regarded as \u003ci\u003eimplementation notes\u003c/i\u003e, rather than parts of the\\n * \u003ci\u003especification\u003c/i\u003e. Implementors should feel free to substitute other\\n * algorithms, so long as the specification itself is adhered to. (For\\n * example, the algorithm used by {@code sort(Object[])} does not have to be\\n * a MergeSort, but it does have to be \u003ci\u003estable\u003c/i\u003e.)\\n *\\n * \u003cp\u003eThis class is a member of the\\n * \u003ca href=\"{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework\"\u003e\\n * Java Collections Framework\u003c/a\u003e.\\n *\\n * @author Josh Bloch\\n * @author Neal Gafter\\n * @author John Rose\\n * @since  1.2\\n \u0027}"}, {"color": "#97c2fc", "id": "public static void sort(int[] a)", "label": "public static void sort(int[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified array into ascending numerical order.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void sort(int[] a, int fromIndex, int toIndex)", "label": "public static void sort(int[] a, int fromIndex, int toIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified range of the array into ascending order. The range\\n     * to be sorted extends from the index {@code fromIndex}, inclusive, to\\n     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},\\n     * the range to be sorted is empty.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     * @param fromIndex the index of the first element, inclusive, to be sorted\\n     * @param toIndex the index of the last element, exclusive, to be sorted\\n     *\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *     if {@code fromIndex \u003c 0} or {@code toIndex \u003e a.length}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void sort(long[] a)", "label": "public static void sort(long[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified array into ascending numerical order.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void sort(long[] a, int fromIndex, int toIndex)", "label": "public static void sort(long[] a, int fromIndex, int toIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified range of the array into ascending order. The range\\n     * to be sorted extends from the index {@code fromIndex}, inclusive, to\\n     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},\\n     * the range to be sorted is empty.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     * @param fromIndex the index of the first element, inclusive, to be sorted\\n     * @param toIndex the index of the last element, exclusive, to be sorted\\n     *\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *     if {@code fromIndex \u003c 0} or {@code toIndex \u003e a.length}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void sort(short[] a)", "label": "public static void sort(short[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified array into ascending numerical order.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void sort(short[] a, int fromIndex, int toIndex)", "label": "public static void sort(short[] a, int fromIndex, int toIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified range of the array into ascending order. The range\\n     * to be sorted extends from the index {@code fromIndex}, inclusive, to\\n     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},\\n     * the range to be sorted is empty.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     * @param fromIndex the index of the first element, inclusive, to be sorted\\n     * @param toIndex the index of the last element, exclusive, to be sorted\\n     *\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *     if {@code fromIndex \u003c 0} or {@code toIndex \u003e a.length}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void sort(char[] a)", "label": "public static void sort(char[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified array into ascending numerical order.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void sort(char[] a, int fromIndex, int toIndex)", "label": "public static void sort(char[] a, int fromIndex, int toIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified range of the array into ascending order. The range\\n     * to be sorted extends from the index {@code fromIndex}, inclusive, to\\n     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},\\n     * the range to be sorted is empty.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     * @param fromIndex the index of the first element, inclusive, to be sorted\\n     * @param toIndex the index of the last element, exclusive, to be sorted\\n     *\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *     if {@code fromIndex \u003c 0} or {@code toIndex \u003e a.length}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void sort(byte[] a)", "label": "public static void sort(byte[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified array into ascending numerical order.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void sort(byte[] a, int fromIndex, int toIndex)", "label": "public static void sort(byte[] a, int fromIndex, int toIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified range of the array into ascending order. The range\\n     * to be sorted extends from the index {@code fromIndex}, inclusive, to\\n     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},\\n     * the range to be sorted is empty.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     * @param fromIndex the index of the first element, inclusive, to be sorted\\n     * @param toIndex the index of the last element, exclusive, to be sorted\\n     *\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *     if {@code fromIndex \u003c 0} or {@code toIndex \u003e a.length}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void sort(float[] a)", "label": "public static void sort(float[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified array into ascending numerical order.\\n     *\\n     * \u003cp\u003eThe {@code \u003c} relation does not provide a total order on all float\\n     * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}\\n     * value compares neither less than, greater than, nor equal to any value,\\n     * even itself. This method uses the total order imposed by the method\\n     * {@link Float#compareTo}: {@code -0.0f} is treated as less than value\\n     * {@code 0.0f} and {@code Float.NaN} is considered greater than any\\n     * other value and all {@code Float.NaN} values are considered equal.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     \u0027}"}, {"color": "#97c2fc", "id": "compareTo", "label": "compareTo", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static void sort(float[] a, int fromIndex, int toIndex)", "label": "public static void sort(float[] a, int fromIndex, int toIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified range of the array into ascending order. The range\\n     * to be sorted extends from the index {@code fromIndex}, inclusive, to\\n     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},\\n     * the range to be sorted is empty.\\n     *\\n     * \u003cp\u003eThe {@code \u003c} relation does not provide a total order on all float\\n     * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}\\n     * value compares neither less than, greater than, nor equal to any value,\\n     * even itself. This method uses the total order imposed by the method\\n     * {@link Float#compareTo}: {@code -0.0f} is treated as less than value\\n     * {@code 0.0f} and {@code Float.NaN} is considered greater than any\\n     * other value and all {@code Float.NaN} values are considered equal.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     * @param fromIndex the index of the first element, inclusive, to be sorted\\n     * @param toIndex the index of the last element, exclusive, to be sorted\\n     *\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *     if {@code fromIndex \u003c 0} or {@code toIndex \u003e a.length}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void sort(double[] a)", "label": "public static void sort(double[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified array into ascending numerical order.\\n     *\\n     * \u003cp\u003eThe {@code \u003c} relation does not provide a total order on all double\\n     * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}\\n     * value compares neither less than, greater than, nor equal to any value,\\n     * even itself. This method uses the total order imposed by the method\\n     * {@link Double#compareTo}: {@code -0.0d} is treated as less than value\\n     * {@code 0.0d} and {@code Double.NaN} is considered greater than any\\n     * other value and all {@code Double.NaN} values are considered equal.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void sort(double[] a, int fromIndex, int toIndex)", "label": "public static void sort(double[] a, int fromIndex, int toIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified range of the array into ascending order. The range\\n     * to be sorted extends from the index {@code fromIndex}, inclusive, to\\n     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},\\n     * the range to be sorted is empty.\\n     *\\n     * \u003cp\u003eThe {@code \u003c} relation does not provide a total order on all double\\n     * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}\\n     * value compares neither less than, greater than, nor equal to any value,\\n     * even itself. This method uses the total order imposed by the method\\n     * {@link Double#compareTo}: {@code -0.0d} is treated as less than value\\n     * {@code 0.0d} and {@code Double.NaN} is considered greater than any\\n     * other value and all {@code Double.NaN} values are considered equal.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     * @param fromIndex the index of the first element, inclusive, to be sorted\\n     * @param toIndex the index of the last element, exclusive, to be sorted\\n     *\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *     if {@code fromIndex \u003c 0} or {@code toIndex \u003e a.length}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void parallelSort(byte[] a)", "label": "public static void parallelSort(byte[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified array into ascending numerical order.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     *\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void parallelSort(byte[] a, int fromIndex, int toIndex)", "label": "public static void parallelSort(byte[] a, int fromIndex, int toIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified range of the array into ascending numerical order.\\n     * The range to be sorted extends from the index {@code fromIndex},\\n     * inclusive, to the index {@code toIndex}, exclusive. If\\n     * {@code fromIndex == toIndex}, the range to be sorted is empty.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     * @param fromIndex the index of the first element, inclusive, to be sorted\\n     * @param toIndex the index of the last element, exclusive, to be sorted\\n     *\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *     if {@code fromIndex \u003c 0} or {@code toIndex \u003e a.length}\\n     *\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void parallelSort(char[] a)", "label": "public static void parallelSort(char[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified array into ascending numerical order.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     *\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void parallelSort(char[] a, int fromIndex, int toIndex)", "label": "public static void parallelSort(char[] a, int fromIndex, int toIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified range of the array into ascending numerical order.\\n     * The range to be sorted extends from the index {@code fromIndex},\\n     * inclusive, to the index {@code toIndex}, exclusive. If\\n     * {@code fromIndex == toIndex}, the range to be sorted is empty.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     * @param fromIndex the index of the first element, inclusive, to be sorted\\n     * @param toIndex the index of the last element, exclusive, to be sorted\\n     *\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *     if {@code fromIndex \u003c 0} or {@code toIndex \u003e a.length}\\n     *\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void parallelSort(short[] a)", "label": "public static void parallelSort(short[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified array into ascending numerical order.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     *\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void parallelSort(short[] a, int fromIndex, int toIndex)", "label": "public static void parallelSort(short[] a, int fromIndex, int toIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified range of the array into ascending numerical order.\\n     * The range to be sorted extends from the index {@code fromIndex},\\n     * inclusive, to the index {@code toIndex}, exclusive. If\\n     * {@code fromIndex == toIndex}, the range to be sorted is empty.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     * @param fromIndex the index of the first element, inclusive, to be sorted\\n     * @param toIndex the index of the last element, exclusive, to be sorted\\n     *\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *     if {@code fromIndex \u003c 0} or {@code toIndex \u003e a.length}\\n     *\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void parallelSort(int[] a)", "label": "public static void parallelSort(int[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified array into ascending numerical order.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     *\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void parallelSort(int[] a, int fromIndex, int toIndex)", "label": "public static void parallelSort(int[] a, int fromIndex, int toIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified range of the array into ascending numerical order.\\n     * The range to be sorted extends from the index {@code fromIndex},\\n     * inclusive, to the index {@code toIndex}, exclusive. If\\n     * {@code fromIndex == toIndex}, the range to be sorted is empty.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     * @param fromIndex the index of the first element, inclusive, to be sorted\\n     * @param toIndex the index of the last element, exclusive, to be sorted\\n     *\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *     if {@code fromIndex \u003c 0} or {@code toIndex \u003e a.length}\\n     *\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void parallelSort(long[] a)", "label": "public static void parallelSort(long[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified array into ascending numerical order.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     *\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void parallelSort(long[] a, int fromIndex, int toIndex)", "label": "public static void parallelSort(long[] a, int fromIndex, int toIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified range of the array into ascending numerical order.\\n     * The range to be sorted extends from the index {@code fromIndex},\\n     * inclusive, to the index {@code toIndex}, exclusive. If\\n     * {@code fromIndex == toIndex}, the range to be sorted is empty.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     * @param fromIndex the index of the first element, inclusive, to be sorted\\n     * @param toIndex the index of the last element, exclusive, to be sorted\\n     *\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *     if {@code fromIndex \u003c 0} or {@code toIndex \u003e a.length}\\n     *\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void parallelSort(float[] a)", "label": "public static void parallelSort(float[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified array into ascending numerical order.\\n     *\\n     * \u003cp\u003eThe {@code \u003c} relation does not provide a total order on all float\\n     * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}\\n     * value compares neither less than, greater than, nor equal to any value,\\n     * even itself. This method uses the total order imposed by the method\\n     * {@link Float#compareTo}: {@code -0.0f} is treated as less than value\\n     * {@code 0.0f} and {@code Float.NaN} is considered greater than any\\n     * other value and all {@code Float.NaN} values are considered equal.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     *\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void parallelSort(float[] a, int fromIndex, int toIndex)", "label": "public static void parallelSort(float[] a, int fromIndex, int toIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified range of the array into ascending numerical order.\\n     * The range to be sorted extends from the index {@code fromIndex},\\n     * inclusive, to the index {@code toIndex}, exclusive. If\\n     * {@code fromIndex == toIndex}, the range to be sorted is empty.\\n     *\\n     * \u003cp\u003eThe {@code \u003c} relation does not provide a total order on all float\\n     * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}\\n     * value compares neither less than, greater than, nor equal to any value,\\n     * even itself. This method uses the total order imposed by the method\\n     * {@link Float#compareTo}: {@code -0.0f} is treated as less than value\\n     * {@code 0.0f} and {@code Float.NaN} is considered greater than any\\n     * other value and all {@code Float.NaN} values are considered equal.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     * @param fromIndex the index of the first element, inclusive, to be sorted\\n     * @param toIndex the index of the last element, exclusive, to be sorted\\n     *\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *     if {@code fromIndex \u003c 0} or {@code toIndex \u003e a.length}\\n     *\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void parallelSort(double[] a)", "label": "public static void parallelSort(double[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified array into ascending numerical order.\\n     *\\n     * \u003cp\u003eThe {@code \u003c} relation does not provide a total order on all double\\n     * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}\\n     * value compares neither less than, greater than, nor equal to any value,\\n     * even itself. This method uses the total order imposed by the method\\n     * {@link Double#compareTo}: {@code -0.0d} is treated as less than value\\n     * {@code 0.0d} and {@code Double.NaN} is considered greater than any\\n     * other value and all {@code Double.NaN} values are considered equal.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     *\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void parallelSort(double[] a, int fromIndex, int toIndex)", "label": "public static void parallelSort(double[] a, int fromIndex, int toIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified range of the array into ascending numerical order.\\n     * The range to be sorted extends from the index {@code fromIndex},\\n     * inclusive, to the index {@code toIndex}, exclusive. If\\n     * {@code fromIndex == toIndex}, the range to be sorted is empty.\\n     *\\n     * \u003cp\u003eThe {@code \u003c} relation does not provide a total order on all double\\n     * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}\\n     * value compares neither less than, greater than, nor equal to any value,\\n     * even itself. This method uses the total order imposed by the method\\n     * {@link Double#compareTo}: {@code -0.0d} is treated as less than value\\n     * {@code 0.0d} and {@code Double.NaN} is considered greater than any\\n     * other value and all {@code Double.NaN} values are considered equal.\\n     *\\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\\n     * offers O(n log(n)) performance on all data sets, and is typically\\n     * faster than traditional (one-pivot) Quicksort implementations.\\n     *\\n     * @param a the array to be sorted\\n     * @param fromIndex the index of the first element, inclusive, to be sorted\\n     * @param toIndex the index of the last element, exclusive, to be sorted\\n     *\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *     if {@code fromIndex \u003c 0} or {@code toIndex \u003e a.length}\\n     *\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": " static void rangeCheck(int arrayLength, int fromIndex, int toIndex)", "label": " static void rangeCheck(int arrayLength, int fromIndex, int toIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Checks that {@code fromIndex} and {@code toIndex} are in\\n     * the range and throws an exception if they aren\u0027t.\\n     \"}"}, {"color": "#97c2fc", "id": "public static void parallelSort(T[] a)", "label": "public static void parallelSort(T[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified array of objects into ascending order, according\\n     * to the {@linkplain Comparable natural ordering} of its elements.\\n     * All elements in the array must implement the {@link Comparable}\\n     * interface.  Furthermore, all elements in the array must be\\n     * \u003ci\u003emutually comparable\u003c/i\u003e (that is, {@code e1.compareTo(e2)} must\\n     * not throw a {@code ClassCastException} for any elements {@code e1}\\n     * and {@code e2} in the array).\\n     *\\n     * \u003cp\u003eThis sort is guaranteed to be \u003ci\u003estable\u003c/i\u003e:  equal elements will\\n     * not be reordered as a result of the sort.\\n     *\\n     * @implNote The sorting algorithm is a parallel sort-merge that breaks the\\n     * array into sub-arrays that are themselves sorted and then merged. When\\n     * the sub-array length reaches a minimum granularity, the sub-array is\\n     * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}\\n     * method. If the length of the specified array is less than the minimum\\n     * granularity, then it is sorted using the appropriate {@link\\n     * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a\\n     * working space no greater than the size of the original array. The\\n     * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to\\n     * execute any parallel tasks.\\n     *\\n     * @param \u003cT\u003e the class of the objects to be sorted\\n     * @param a the array to be sorted\\n     *\\n     * @throws ClassCastException if the array contains elements that are not\\n     *         \u003ci\u003emutually comparable\u003c/i\u003e (for example, strings and integers)\\n     * @throws IllegalArgumentException (optional) if the natural\\n     *         ordering of the array elements is found to violate the\\n     *         {@link Comparable} contract\\n     *\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "commonPool()", "label": "commonPool()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.util.concurrent.ForkJoinPool", "label": "java.util.concurrent.ForkJoinPool", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * An {@link ExecutorService} for running {@link ForkJoinTask}s.\\n * A {@code ForkJoinPool} provides the entry point for submissions\\n * from non-{@code ForkJoinTask} clients, as well as management and\\n * monitoring operations.\\n *\\n * \u003cp\u003eA {@code ForkJoinPool} differs from other kinds of {@link\\n * ExecutorService} mainly by virtue of employing\\n * \u003cem\u003ework-stealing\u003c/em\u003e: all threads in the pool attempt to find and\\n * execute tasks submitted to the pool and/or created by other active\\n * tasks (eventually blocking waiting for work if none exist). This\\n * enables efficient processing when most tasks spawn other subtasks\\n * (as do most {@code ForkJoinTask}s), as well as when many small\\n * tasks are submitted to the pool from external clients.  Especially\\n * when setting \u003cem\u003easyncMode\u003c/em\u003e to true in constructors, {@code\\n * ForkJoinPool}s may also be appropriate for use with event-style\\n * tasks that are never joined. All worker threads are initialized\\n * with {@link Thread#isDaemon} set {@code true}.\\n *\\n * \u003cp\u003eA static {@link #commonPool()} is available and appropriate for\\n * most applications. The common pool is used by any ForkJoinTask that\\n * is not explicitly submitted to a specified pool. Using the common\\n * pool normally reduces resource usage (its threads are slowly\\n * reclaimed during periods of non-use, and reinstated upon subsequent\\n * use).\\n *\\n * \u003cp\u003eFor applications that require separate or custom pools, a {@code\\n * ForkJoinPool} may be constructed with a given target parallelism\\n * level; by default, equal to the number of available processors.\\n * The pool attempts to maintain enough active (or available) threads\\n * by dynamically adding, suspending, or resuming internal worker\\n * threads, even if some tasks are stalled waiting to join others.\\n * However, no such adjustments are guaranteed in the face of blocked\\n * I/O or other unmanaged synchronization. The nested {@link\\n * ManagedBlocker} interface enables extension of the kinds of\\n * synchronization accommodated. The default policies may be\\n * overridden using a constructor with parameters corresponding to\\n * those documented in class {@link ThreadPoolExecutor}.\\n *\\n * \u003cp\u003eIn addition to execution and lifecycle control methods, this\\n * class provides status check methods (for example\\n * {@link #getStealCount}) that are intended to aid in developing,\\n * tuning, and monitoring fork/join applications. Also, method\\n * {@link #toString} returns indications of pool state in a\\n * convenient form for informal monitoring.\\n *\\n * \u003cp\u003eAs is the case with other ExecutorServices, there are three\\n * main task execution methods summarized in the following table.\\n * These are designed to be used primarily by clients not already\\n * engaged in fork/join computations in the current pool.  The main\\n * forms of these methods accept instances of {@code ForkJoinTask},\\n * but overloaded forms also allow mixed execution of plain {@code\\n * Runnable}- or {@code Callable}- based activities as well.  However,\\n * tasks that are already executing in a pool should normally instead\\n * use the within-computation forms listed in the table unless using\\n * async event-style tasks that are not usually joined, in which case\\n * there is little difference among choice of methods.\\n *\\n * \u003ctable class=\"plain\"\u003e\\n * \u003ccaption\u003eSummary of task execution methods\u003c/caption\u003e\\n *  \u003ctr\u003e\\n *    \u003ctd\u003e\u003c/td\u003e\\n *    \u003cth scope=\"col\"\u003e Call from non-fork/join clients\u003c/th\u003e\\n *    \u003cth scope=\"col\"\u003e Call from within fork/join computations\u003c/th\u003e\\n *  \u003c/tr\u003e\\n *  \u003ctr\u003e\\n *    \u003cth scope=\"row\" style=\"text-align:left\"\u003e Arrange async execution\u003c/th\u003e\\n *    \u003ctd\u003e {@link #execute(ForkJoinTask)}\u003c/td\u003e\\n *    \u003ctd\u003e {@link ForkJoinTask#fork}\u003c/td\u003e\\n *  \u003c/tr\u003e\\n *  \u003ctr\u003e\\n *    \u003cth scope=\"row\" style=\"text-align:left\"\u003e Await and obtain result\u003c/th\u003e\\n *    \u003ctd\u003e {@link #invoke(ForkJoinTask)}\u003c/td\u003e\\n *    \u003ctd\u003e {@link ForkJoinTask#invoke}\u003c/td\u003e\\n *  \u003c/tr\u003e\\n *  \u003ctr\u003e\\n *    \u003cth scope=\"row\" style=\"text-align:left\"\u003e Arrange exec and obtain Future\u003c/th\u003e\\n *    \u003ctd\u003e {@link #submit(ForkJoinTask)}\u003c/td\u003e\\n *    \u003ctd\u003e {@link ForkJoinTask#fork} (ForkJoinTasks \u003cem\u003eare\u003c/em\u003e Futures)\u003c/td\u003e\\n *  \u003c/tr\u003e\\n * \u003c/table\u003e\\n *\\n * \u003cp\u003eThe parameters used to construct the common pool may be controlled by\\n * setting the following {@linkplain System#getProperty system properties}:\\n * \u003cul\u003e\\n * \u003cli\u003e{@code java.util.concurrent.ForkJoinPool.common.parallelism}\\n * - the parallelism level, a non-negative integer\\n * \u003cli\u003e{@code java.util.concurrent.ForkJoinPool.common.threadFactory}\\n * - the class name of a {@link ForkJoinWorkerThreadFactory}.\\n * The {@linkplain ClassLoader#getSystemClassLoader() system class loader}\\n * is used to load this class.\\n * \u003cli\u003e{@code java.util.concurrent.ForkJoinPool.common.exceptionHandler}\\n * - the class name of a {@link UncaughtExceptionHandler}.\\n * The {@linkplain ClassLoader#getSystemClassLoader() system class loader}\\n * is used to load this class.\\n * \u003cli\u003e{@code java.util.concurrent.ForkJoinPool.common.maximumSpares}\\n * - the maximum number of allowed extra threads to maintain target\\n * parallelism (default 256).\\n * \u003c/ul\u003e\\n * If no thread factory is supplied via a system property, then the\\n * common pool uses a factory that uses the system class loader as the\\n * {@linkplain Thread#getContextClassLoader() thread context class loader}.\\n * In addition, if a {@link SecurityManager} is present, then\\n * the common pool uses a factory supplying threads that have no\\n * {@link Permissions} enabled.\\n *\\n * Upon any error in establishing these settings, default parameters\\n * are used. It is possible to disable or limit the use of threads in\\n * the common pool by setting the parallelism property to zero, and/or\\n * using a factory that may return {@code null}. However doing so may\\n * cause unjoined tasks to never be executed.\\n *\\n * \u003cp\u003e\u003cb\u003eImplementation notes:\u003c/b\u003e This implementation restricts the\\n * maximum number of running threads to 32767. Attempts to create\\n * pools with greater than the maximum number result in\\n * {@code IllegalArgumentException}.\\n *\\n * \u003cp\u003eThis implementation rejects submitted tasks (that is, by throwing\\n * {@link RejectedExecutionException}) only when the pool is shut down\\n * or internal resources have been exhausted.\\n *\\n * @since 1.7\\n * @author Doug Lea\\n \u0027}"}, {"color": "#97c2fc", "id": "private static void checkPermission()", "label": "private static void checkPermission()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * If there is a security manager, makes sure caller has\\n     * permission to modify threads.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private boolean createWorker()", "label": "private boolean createWorker()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tries to construct and start one worker. Assumes that total\\n     * count has already been incremented as a reservation.  Invokes\\n     * deregisterWorker on any failure.\\n     *\\n     * @return true if successful\\n     \u0027}"}, {"color": "#97c2fc", "id": " final String nextWorkerThreadName()", "label": " final String nextWorkerThreadName()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Provides a name for ForkJoinWorkerThread constructor.\\n     \u0027}"}, {"color": "#97c2fc", "id": " final void registerWorker(WorkQueue w)", "label": " final void registerWorker(WorkQueue w)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Finishes initializing and records owned queue.\\n     *\\n     * @param w caller\u0027s WorkQueue\\n     \"}"}, {"color": "#97c2fc", "id": " final void deregisterWorker(ForkJoinWorkerThread wt, Throwable ex)", "label": " final void deregisterWorker(ForkJoinWorkerThread wt, Throwable ex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Final callback from terminating worker, as well as upon failure\\n     * to construct or start a worker.  Removes record of worker from\\n     * array, and adjusts counts. If pool is shutting down, tries to\\n     * complete termination.\\n     *\\n     * @param wt the worker thread, or null if construction failed\\n     * @param ex the exception causing failure, or null if none\\n     \u0027}"}, {"color": "#97c2fc", "id": " final void signalWork()", "label": " final void signalWork()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tries to create or release a worker if too few are running.\\n     \u0027}"}, {"color": "#97c2fc", "id": " final void runWorker(WorkQueue w)", "label": " final void runWorker(WorkQueue w)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Top-level runloop for workers, called by ForkJoinWorkerThread.run.\\n     * See above for explanation.\\n     *\\n     * @param w caller\u0027s WorkQueue (may be null on failed initialization)\\n     \"}"}, {"color": "#97c2fc", "id": "private int scan(WorkQueue w, int prevSrc, int r)", "label": "private int scan(WorkQueue w, int prevSrc, int r)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Scans for and if found executes top-level tasks: Tries to poll\\n     * each queue starting at a random index with random stride,\\n     * returning source id or retry indicator if contended or\\n     * inconsistent.\\n     *\\n     * @param w caller\u0027s WorkQueue\\n     * @param prevSrc the previous queue stolen from in current phase, or 0\\n     * @param r random seed\\n     * @return id of queue if taken, negative if none found, prevSrc for retry\\n     \"}"}, {"color": "#97c2fc", "id": "private int awaitWork(WorkQueue w)", "label": "private int awaitWork(WorkQueue w)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Advances worker phase, pushes onto ctl stack, and awaits signal\\n     * or reports termination.\\n     *\\n     * @return negative if terminated, else 0\\n     \u0027}"}, {"color": "#97c2fc", "id": " final boolean canStop()", "label": " final boolean canStop()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns true if can start terminating if enabled, or already terminated\\n     \u0027}"}, {"color": "#97c2fc", "id": "private int tryCompensate(long c)", "label": "private int tryCompensate(long c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Tries to decrement counts (sometimes implicitly) and possibly\\n     * arrange for a compensating worker in preparation for\\n     * blocking. May fail due to interference, in which case -1 is\\n     * returned so caller may retry. A zero return value indicates\\n     * that the caller doesn\u0027t need to re-adjust counts when later\\n     * unblocked.\\n     *\\n     * @param c incoming ctl value\\n     * @return UNCOMPENSATE: block then adjust, 0: block, -1 : retry\\n     \"}"}, {"color": "#97c2fc", "id": " final void uncompensate()", "label": " final void uncompensate()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Readjusts RC count; called from ForkJoinTask after blocking.\\n     \u0027}"}, {"color": "#97c2fc", "id": " final int helpJoin(ForkJoinTask\u003c?\u003e task, WorkQueue w, boolean canHelp)", "label": " final int helpJoin(ForkJoinTask\u003c?\u003e task, WorkQueue w, boolean canHelp)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Helps if possible until the given task is done.  Scans other\\n     * queues for a task produced by one of w\u0027s stealers; returning\\n     * compensated blocking sentinel if none are found.\\n     *\\n     * @param task the task\\n     * @param w caller\u0027s WorkQueue\\n     * @param canHelp if false, compensate only\\n     * @return task status on exit, or UNCOMPENSATE for compensated blocking\\n     \"}"}, {"color": "#97c2fc", "id": " final int helpComplete(ForkJoinTask\u003c?\u003e task, WorkQueue w, boolean owned)", "label": " final int helpComplete(ForkJoinTask\u003c?\u003e task, WorkQueue w, boolean owned)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Extra helpJoin steps for CountedCompleters.  Scans for and runs\\n     * subtasks of the given root task, returning if none are found.\\n     *\\n     * @param task root of CountedCompleter computation\\n     * @param w caller\u0027s WorkQueue\\n     * @param owned true if owned by a ForkJoinWorkerThread\\n     * @return task status on exit\\n     \"}"}, {"color": "#97c2fc", "id": "private ForkJoinTask\u003c?\u003e pollScan(boolean submissionsOnly)", "label": "private ForkJoinTask\u003c?\u003e pollScan(boolean submissionsOnly)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Scans for and returns a polled task, if available.  Used only\\n     * for untracked polls. Begins scan at an index (scanRover)\\n     * advanced on each call, to avoid systematic unfairness.\\n     *\\n     * @param submissionsOnly if true, only scan submission queues\\n     \u0027}"}, {"color": "#97c2fc", "id": " final int helpQuiescePool(WorkQueue w, long nanos, boolean interruptible)", "label": " final int helpQuiescePool(WorkQueue w, long nanos, boolean interruptible)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Runs tasks until {@code isQuiescent()}. Rather than blocking\\n     * when tasks cannot be found, rescans until all others cannot\\n     * find tasks either.\\n     *\\n     * @param nanos max wait time (Long.MAX_VALUE if effectively untimed)\\n     * @param interruptible true if return on interrupt\\n     * @return positive if quiescent, negative if interrupted, else 0\\n     \u0027}"}, {"color": "#97c2fc", "id": " final int externalHelpQuiescePool(long nanos, boolean interruptible)", "label": " final int externalHelpQuiescePool(long nanos, boolean interruptible)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Helps quiesce from external caller until done, interrupted, or timeout\\n     *\\n     * @param nanos max wait time (Long.MAX_VALUE if effectively untimed)\\n     * @param interruptible true if return on interrupt\\n     * @return positive if quiescent, negative if interrupted, else 0\\n     \u0027}"}, {"color": "#97c2fc", "id": " final ForkJoinTask\u003c?\u003e nextTaskFor(WorkQueue w)", "label": " final ForkJoinTask\u003c?\u003e nextTaskFor(WorkQueue w)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets and removes a local or stolen task for the given worker.\\n     *\\n     * @return a task, if available\\n     \u0027}"}, {"color": "#97c2fc", "id": " final WorkQueue submissionQueue()", "label": " final WorkQueue submissionQueue()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Finds and locks a WorkQueue for an external submitter, or\\n     * returns null if shutdown or terminating.\\n     \u0027}"}, {"color": "#97c2fc", "id": " final void externalPush(ForkJoinTask\u003c?\u003e task)", "label": " final void externalPush(ForkJoinTask\u003c?\u003e task)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Adds the given task to an external submission queue, or throws\\n     * exception if shutdown or terminating.\\n     *\\n     * @param task the task. Caller must ensure non-null.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private ForkJoinTask\u003cT\u003e externalSubmit(ForkJoinTask\u003cT\u003e task)", "label": "private ForkJoinTask\u003cT\u003e externalSubmit(ForkJoinTask\u003cT\u003e task)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Pushes a possibly-external submission.\\n     \u0027}"}, {"color": "#97c2fc", "id": " static WorkQueue commonQueue()", "label": " static WorkQueue commonQueue()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns common pool queue for an external thread that has\\n     * possibly ever submitted a common pool task (nonzero probe), or\\n     * null if none.\\n     \u0027}"}, {"color": "#97c2fc", "id": " final WorkQueue externalQueue()", "label": " final WorkQueue externalQueue()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns queue for an external thread, if one exists\\n     \u0027}"}, {"color": "#97c2fc", "id": " static void helpAsyncBlocker(Executor e, ManagedBlocker blocker)", "label": " static void helpAsyncBlocker(Executor e, ManagedBlocker blocker)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * If the given executor is a ForkJoinPool, poll and execute\\n     * AsynchronousCompletionTasks from worker\u0027s queue until none are\\n     * available or blocker is released.\\n     \"}"}, {"color": "#97c2fc", "id": " static int getSurplusQueuedTaskCount()", "label": " static int getSurplusQueuedTaskCount()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a cheap heuristic guide for task partitioning when\\n     * programmers, frameworks, tools, or languages have little or no\\n     * idea about task granularity.  In essence, by offering this\\n     * method, we ask users only about tradeoffs in overhead vs\\n     * expected throughput and its variance, rather than how finely to\\n     * partition tasks.\\n     *\\n     * In a steady state strict (tree-structured) computation, each\\n     * thread makes available for stealing enough tasks for other\\n     * threads to remain active. Inductively, if all threads play by\\n     * the same rules, each thread should make available only a\\n     * constant number of tasks.\\n     *\\n     * The minimum useful constant is just 1. But using a value of 1\\n     * would require immediate replenishment upon each steal to\\n     * maintain enough tasks, which is infeasible.  Further,\\n     * partitionings/granularities of offered tasks should minimize\\n     * steal rates, which in general means that threads nearer the top\\n     * of computation tree should generate more than those nearer the\\n     * bottom. In perfect steady state, each thread is at\\n     * approximately the same level of computation tree. However,\\n     * producing extra tasks amortizes the uncertainty of progress and\\n     * diffusion assumptions.\\n     *\\n     * So, users will want to use values larger (but not much larger)\\n     * than 1 to both smooth over transient shortages and hedge\\n     * against uneven progress; as traded off against the cost of\\n     * extra task overhead. We leave the user to pick a threshold\\n     * value to compare with the results of this call to guide\\n     * decisions, but recommend values such as 3.\\n     *\\n     * When all threads are active, it is on average OK to estimate\\n     * surplus strictly locally. In steady-state, if one thread is\\n     * maintaining say 2 surplus tasks, then so are others. So we can\\n     * just use estimated queue length.  However, this strategy alone\\n     * leads to serious mis-estimates in some non-steady-state\\n     * conditions (ramp-up, ramp-down, other stalls). We can detect\\n     * many of these by further considering the number of \"idle\"\\n     * threads, that are known to have zero queued tasks, so\\n     * compensate by a factor of (#idle/#active) threads.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private boolean tryTerminate(boolean now, boolean enable)", "label": "private boolean tryTerminate(boolean now, boolean enable)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Possibly initiates and/or completes termination.\\n     *\\n     * @param now if true, unconditionally terminate, else only\\n     * if no work and no active workers\\n     * @param enable if true, terminate when next possible\\n     * @return true if terminating or terminated\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static Object newInstanceFromSystemProperty(String property) throws ReflectiveOperationException", "label": "private static Object newInstanceFromSystemProperty(String property) throws ReflectiveOperationException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 helper method for commonPool constructor\u0027}"}, {"color": "#97c2fc", "id": "public static ForkJoinPool commonPool()", "label": "public static ForkJoinPool commonPool()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the common pool instance. This pool is statically\\n     * constructed; its run state is unaffected by attempts to {@link\\n     * #shutdown} or {@link #shutdownNow}. However this pool and any\\n     * ongoing processing are automatically terminated upon program\\n     * {@link System#exit}.  Any program that relies on asynchronous\\n     * task processing to complete before program termination should\\n     * invoke {@code commonPool().}{@link #awaitQuiescence awaitQuiescence},\\n     * before exit.\\n     *\\n     * @return the common pool instance\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "shutdownNow", "label": "shutdownNow", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "shutdown", "label": "shutdown", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "awaitQuiescence", "label": "awaitQuiescence", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "exit", "label": "exit", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public T invoke(ForkJoinTask\u003cT\u003e task)", "label": "public T invoke(ForkJoinTask\u003cT\u003e task)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Performs the given task, returning its result upon completion.\\n     * If the computation encounters an unchecked Exception or Error,\\n     * it is rethrown as the outcome of this invocation.  Rethrown\\n     * exceptions behave in the same way as regular exceptions, but,\\n     * when possible, contain stack traces (as displayed for example\\n     * using {@code ex.printStackTrace()}) of both the current thread\\n     * as well as the thread actually encountering the exception;\\n     * minimally only the latter.\\n     *\\n     * @param task the task\\n     * @param \u003cT\u003e the type of the task\u0027s result\\n     * @return the task\u0027s result\\n     * @throws NullPointerException if the task is null\\n     * @throws RejectedExecutionException if the task cannot be\\n     *         scheduled for execution\\n     \"}"}, {"color": "#97c2fc", "id": "public void execute(ForkJoinTask\u003c?\u003e task)", "label": "public void execute(ForkJoinTask\u003c?\u003e task)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Arranges for (asynchronous) execution of the given task.\\n     *\\n     * @param task the task\\n     * @throws NullPointerException if the task is null\\n     * @throws RejectedExecutionException if the task cannot be\\n     *         scheduled for execution\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void execute(Runnable task)", "label": "public void execute(Runnable task)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @throws NullPointerException if the task is null\\n     * @throws RejectedExecutionException if the task cannot be\\n     *         scheduled for execution\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ForkJoinTask\u003cT\u003e submit(ForkJoinTask\u003cT\u003e task)", "label": "public ForkJoinTask\u003cT\u003e submit(ForkJoinTask\u003cT\u003e task)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Submits a ForkJoinTask for execution.\\n     *\\n     * @param task the task to submit\\n     * @param \u003cT\u003e the type of the task\u0027s result\\n     * @return the task\\n     * @throws NullPointerException if the task is null\\n     * @throws RejectedExecutionException if the task cannot be\\n     *         scheduled for execution\\n     \"}"}, {"color": "#97c2fc", "id": "public ForkJoinTask\u003cT\u003e submit(Callable\u003cT\u003e task)", "label": "public ForkJoinTask\u003cT\u003e submit(Callable\u003cT\u003e task)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @throws NullPointerException if the task is null\\n     * @throws RejectedExecutionException if the task cannot be\\n     *         scheduled for execution\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ForkJoinTask\u003cT\u003e submit(Runnable task, T result)", "label": "public ForkJoinTask\u003cT\u003e submit(Runnable task, T result)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @throws NullPointerException if the task is null\\n     * @throws RejectedExecutionException if the task cannot be\\n     *         scheduled for execution\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ForkJoinTask\u003c?\u003e submit(Runnable task)", "label": "public ForkJoinTask\u003c?\u003e submit(Runnable task)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @throws NullPointerException if the task is null\\n     * @throws RejectedExecutionException if the task cannot be\\n     *         scheduled for execution\\n     \u0027}"}, {"color": "#97c2fc", "id": "public List\u003cFuture\u003cT\u003e\u003e invokeAll(Collection\u003c? extends Callable\u003cT\u003e\u003e tasks)", "label": "public List\u003cFuture\u003cT\u003e\u003e invokeAll(Collection\u003c? extends Callable\u003cT\u003e\u003e tasks)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @throws NullPointerException       {@inheritDoc}\\n     * @throws RejectedExecutionException {@inheritDoc}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ForkJoinWorkerThreadFactory getFactory()", "label": "public ForkJoinWorkerThreadFactory getFactory()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the factory used for constructing new workers.\\n     *\\n     * @return the factory used for constructing new workers\\n     \u0027}"}, {"color": "#97c2fc", "id": "public UncaughtExceptionHandler getUncaughtExceptionHandler()", "label": "public UncaughtExceptionHandler getUncaughtExceptionHandler()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the handler invoked when this thread abruptly terminates\\n     * due to an uncaught exception. If this thread has not had an\\n     * uncaught exception handler explicitly set then this thread\u0027s\\n     * {@code ThreadGroup} object is returned, unless this thread\\n     * has terminated, in which case {@code null} is returned.\\n     * @since 1.5\\n     * @return the uncaught exception handler for this thread\\n     \"}"}, {"color": "#97c2fc", "id": "public int getParallelism()", "label": "public int getParallelism()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the targeted parallelism level of this pool.\\n     *\\n     * @return the targeted parallelism level of this pool\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int getCommonPoolParallelism()", "label": "public static int getCommonPoolParallelism()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the targeted parallelism level of the common pool.\\n     *\\n     * @return the targeted parallelism level of the common pool\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getPoolSize()", "label": "public int getPoolSize()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the number of worker threads that have started but not\\n     * yet terminated.  The result returned by this method may differ\\n     * from {@link #getParallelism} when threads are created to\\n     * maintain parallelism when others are cooperatively blocked.\\n     *\\n     * @return the number of worker threads\\n     \u0027}"}, {"color": "#97c2fc", "id": "getParallelism", "label": "getParallelism", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public boolean getAsyncMode()", "label": "public boolean getAsyncMode()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if this pool uses local first-in-first-out\\n     * scheduling mode for forked tasks that are never joined.\\n     *\\n     * @return {@code true} if this pool uses async mode\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getRunningThreadCount()", "label": "public int getRunningThreadCount()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an estimate of the number of worker threads that are\\n     * not blocked waiting to join tasks or for other managed\\n     * synchronization. This method may overestimate the\\n     * number of running threads.\\n     *\\n     * @return the number of worker threads\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getActiveThreadCount()", "label": "public int getActiveThreadCount()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an estimate of the number of threads that are currently\\n     * stealing or executing tasks. This method may overestimate the\\n     * number of active threads.\\n     *\\n     * @return the number of active threads\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isQuiescent()", "label": "public boolean isQuiescent()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if all worker threads are currently idle.\\n     * An idle worker is one that cannot obtain a task to execute\\n     * because none are available to steal from other threads, and\\n     * there are no pending submissions to the pool. This method is\\n     * conservative; it might not return {@code true} immediately upon\\n     * idleness of all threads, but will eventually become true if\\n     * threads remain inactive.\\n     *\\n     * @return {@code true} if all threads are currently idle\\n     \u0027}"}, {"color": "#97c2fc", "id": "public long getStealCount()", "label": "public long getStealCount()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an estimate of the total number of completed tasks that\\n     * were executed by a thread other than their submitter. The\\n     * reported value underestimates the actual total number of steals\\n     * when the pool is not quiescent. This value may be useful for\\n     * monitoring and tuning fork/join programs: in general, steal\\n     * counts should be high enough to keep threads busy, but low\\n     * enough to avoid overhead and contention across threads.\\n     *\\n     * @return the number of steals\\n     \u0027}"}, {"color": "#97c2fc", "id": "public long getQueuedTaskCount()", "label": "public long getQueuedTaskCount()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an estimate of the total number of tasks currently held\\n     * in queues by worker threads (but not including tasks submitted\\n     * to the pool that have not begun executing). This value is only\\n     * an approximation, obtained by iterating across all threads in\\n     * the pool. This method may be useful for tuning task\\n     * granularities.\\n     *\\n     * @return the number of queued tasks\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getQueuedSubmissionCount()", "label": "public int getQueuedSubmissionCount()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an estimate of the number of tasks submitted to this\\n     * pool that have not yet begun executing.  This method may take\\n     * time proportional to the number of submissions.\\n     *\\n     * @return the number of queued submissions\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean hasQueuedSubmissions()", "label": "public boolean hasQueuedSubmissions()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if there are any tasks submitted to this\\n     * pool that have not yet begun executing.\\n     *\\n     * @return {@code true} if there are any queued submissions\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected ForkJoinTask\u003c?\u003e pollSubmission()", "label": "protected ForkJoinTask\u003c?\u003e pollSubmission()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Removes and returns the next unexecuted submission if one is\\n     * available.  This method may be useful in extensions to this\\n     * class that re-assign work in systems with multiple pools.\\n     *\\n     * @return the next submission, or {@code null} if none\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected int drainTasksTo(Collection\u003c? super ForkJoinTask\u003c?\u003e\u003e c)", "label": "protected int drainTasksTo(Collection\u003c? super ForkJoinTask\u003c?\u003e\u003e c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Removes all available unexecuted submitted and forked tasks\\n     * from scheduling queues and adds them to the given collection,\\n     * without altering their execution status. These may include\\n     * artificially generated or wrapped tasks. This method is\\n     * designed to be invoked only when the pool is known to be\\n     * quiescent. Invocations at other times may not remove all\\n     * tasks. A failure encountered while attempting to add elements\\n     * to collection {@code c} may result in elements being in\\n     * neither, either or both collections when the associated\\n     * exception is thrown.  The behavior of this operation is\\n     * undefined if the specified collection is modified while the\\n     * operation is in progress.\\n     *\\n     * @param c the collection to transfer elements into\\n     * @return the number of elements transferred\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String toString()", "label": "public String toString()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string representation of this {@code Double} object.\\n     * The primitive {@code double} value represented by this\\n     * object is converted to a string exactly as if by the method\\n     * {@code toString} of one argument.\\n     *\\n     * @return  a {@code String} representation of this object.\\n     * @see java.lang.Double#toString(double)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void shutdown()", "label": "public void shutdown()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Possibly initiates an orderly shutdown in which previously\\n     * submitted tasks are executed, but no new tasks will be\\n     * accepted. Invocation has no effect on execution state if this\\n     * is the {@link #commonPool()}, and no additional effect if\\n     * already shut down.  Tasks that are in the process of being\\n     * submitted concurrently during the course of this method may or\\n     * may not be rejected.\\n     *\\n     * @throws SecurityException if a security manager exists and\\n     *         the caller is not permitted to modify threads\\n     *         because it does not hold {@link\\n     *         java.lang.RuntimePermission}{@code (\"modifyThread\")}\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.lang.RuntimePermission", "label": "java.lang.RuntimePermission", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public List\u003cRunnable\u003e shutdownNow()", "label": "public List\u003cRunnable\u003e shutdownNow()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Possibly attempts to cancel and/or stop all tasks, and reject\\n     * all subsequently submitted tasks.  Invocation has no effect on\\n     * execution state if this is the {@link #commonPool()}, and no\\n     * additional effect if already shut down. Otherwise, tasks that\\n     * are in the process of being submitted or executed concurrently\\n     * during the course of this method may or may not be\\n     * rejected. This method cancels both existing and unexecuted\\n     * tasks, in order to permit termination in the presence of task\\n     * dependencies. So the method always returns an empty list\\n     * (unlike the case for some other Executors).\\n     *\\n     * @return an empty list\\n     * @throws SecurityException if a security manager exists and\\n     *         the caller is not permitted to modify threads\\n     *         because it does not hold {@link\\n     *         java.lang.RuntimePermission}{@code (\"modifyThread\")}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isTerminated()", "label": "public boolean isTerminated()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if all tasks have completed following shut down.\\n     *\\n     * @return {@code true} if all tasks have completed following shut down\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isTerminating()", "label": "public boolean isTerminating()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if the process of termination has\\n     * commenced but not yet completed.  This method may be useful for\\n     * debugging. A return of {@code true} reported a sufficient\\n     * period after shutdown may indicate that submitted tasks have\\n     * ignored or suppressed interruption, or are waiting for I/O,\\n     * causing this executor not to properly terminate. (See the\\n     * advisory notes for class {@link ForkJoinTask} stating that\\n     * tasks should not normally entail blocking operations.  But if\\n     * they do, they must abort them on interrupt.)\\n     *\\n     * @return {@code true} if terminating but not yet terminated\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.util.concurrent.ForkJoinTask", "label": "java.util.concurrent.ForkJoinTask", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Abstract base class for tasks that run within a {@link ForkJoinPool}.\\n * A {@code ForkJoinTask} is a thread-like entity that is much\\n * lighter weight than a normal thread.  Huge numbers of tasks and\\n * subtasks may be hosted by a small number of actual threads in a\\n * ForkJoinPool, at the price of some usage limitations.\\n *\\n * \u003cp\u003eA \"main\" {@code ForkJoinTask} begins execution when it is\\n * explicitly submitted to a {@link ForkJoinPool}, or, if not already\\n * engaged in a ForkJoin computation, commenced in the {@link\\n * ForkJoinPool#commonPool()} via {@link #fork}, {@link #invoke}, or\\n * related methods.  Once started, it will usually in turn start other\\n * subtasks.  As indicated by the name of this class, many programs\\n * using {@code ForkJoinTask} employ only methods {@link #fork} and\\n * {@link #join}, or derivatives such as {@link\\n * #invokeAll(ForkJoinTask...) invokeAll}.  However, this class also\\n * provides a number of other methods that can come into play in\\n * advanced usages, as well as extension mechanics that allow support\\n * of new forms of fork/join processing.\\n *\\n * \u003cp\u003eA {@code ForkJoinTask} is a lightweight form of {@link Future}.\\n * The efficiency of {@code ForkJoinTask}s stems from a set of\\n * restrictions (that are only partially statically enforceable)\\n * reflecting their main use as computational tasks calculating pure\\n * functions or operating on purely isolated objects.  The primary\\n * coordination mechanisms are {@link #fork}, that arranges\\n * asynchronous execution, and {@link #join}, that doesn\\\u0027t proceed\\n * until the task\\\u0027s result has been computed.  Computations should\\n * ideally avoid {@code synchronized} methods or blocks, and should\\n * minimize other blocking synchronization apart from joining other\\n * tasks or using synchronizers such as Phasers that are advertised to\\n * cooperate with fork/join scheduling. Subdividable tasks should also\\n * not perform blocking I/O, and should ideally access variables that\\n * are completely independent of those accessed by other running\\n * tasks. These guidelines are loosely enforced by not permitting\\n * checked exceptions such as {@code IOExceptions} to be\\n * thrown. However, computations may still encounter unchecked\\n * exceptions, that are rethrown to callers attempting to join\\n * them. These exceptions may additionally include {@link\\n * RejectedExecutionException} stemming from internal resource\\n * exhaustion, such as failure to allocate internal task\\n * queues. Rethrown exceptions behave in the same way as regular\\n * exceptions, but, when possible, contain stack traces (as displayed\\n * for example using {@code ex.printStackTrace()}) of both the thread\\n * that initiated the computation as well as the thread actually\\n * encountering the exception; minimally only the latter.\\n *\\n * \u003cp\u003eIt is possible to define and use ForkJoinTasks that may block,\\n * but doing so requires three further considerations: (1) Completion\\n * of few if any \u003cem\u003eother\u003c/em\u003e tasks should be dependent on a task\\n * that blocks on external synchronization or I/O. Event-style async\\n * tasks that are never joined (for example, those subclassing {@link\\n * CountedCompleter}) often fall into this category.  (2) To minimize\\n * resource impact, tasks should be small; ideally performing only the\\n * (possibly) blocking action. (3) Unless the {@link\\n * ForkJoinPool.ManagedBlocker} API is used, or the number of possibly\\n * blocked tasks is known to be less than the pool\\\u0027s {@link\\n * ForkJoinPool#getParallelism} level, the pool cannot guarantee that\\n * enough threads will be available to ensure progress or good\\n * performance.\\n *\\n * \u003cp\u003eThe primary method for awaiting completion and extracting\\n * results of a task is {@link #join}, but there are several variants:\\n * The {@link Future#get} methods support interruptible and/or timed\\n * waits for completion and report results using {@code Future}\\n * conventions. Method {@link #invoke} is semantically\\n * equivalent to {@code fork(); join()} but always attempts to begin\\n * execution in the current thread. The \"\u003cem\u003equiet\u003c/em\u003e\" forms of\\n * these methods do not extract results or report exceptions. These\\n * may be useful when a set of tasks are being executed, and you need\\n * to delay processing of results or exceptions until all complete.\\n * Method {@code invokeAll} (available in multiple versions)\\n * performs the most common form of parallel invocation: forking a set\\n * of tasks and joining them all.\\n *\\n * \u003cp\u003eIn the most typical usages, a fork-join pair act like a call\\n * (fork) and return (join) from a parallel recursive function. As is\\n * the case with other forms of recursive calls, returns (joins)\\n * should be performed innermost-first. For example, {@code a.fork();\\n * b.fork(); b.join(); a.join();} is likely to be substantially more\\n * efficient than joining {@code a} before {@code b}.\\n *\\n * \u003cp\u003eThe execution status of tasks may be queried at several levels\\n * of detail: {@link #isDone} is true if a task completed in any way\\n * (including the case where a task was cancelled without executing);\\n * {@link #isCompletedNormally} is true if a task completed without\\n * cancellation or encountering an exception; {@link #isCancelled} is\\n * true if the task was cancelled (in which case {@link #getException}\\n * returns a {@link CancellationException}); and\\n * {@link #isCompletedAbnormally} is true if a task was either\\n * cancelled or encountered an exception, in which case {@link\\n * #getException} will return either the encountered exception or\\n * {@link CancellationException}.\\n *\\n * \u003cp\u003eThe ForkJoinTask class is not usually directly subclassed.\\n * Instead, you subclass one of the abstract classes that support a\\n * particular style of fork/join processing, typically {@link\\n * RecursiveAction} for most computations that do not return results,\\n * {@link RecursiveTask} for those that do, and {@link\\n * CountedCompleter} for those in which completed actions trigger\\n * other actions.  Normally, a concrete ForkJoinTask subclass declares\\n * fields comprising its parameters, established in a constructor, and\\n * then defines a {@code compute} method that somehow uses the control\\n * methods supplied by this base class.\\n *\\n * \u003cp\u003eMethod {@link #join} and its variants are appropriate for use\\n * only when completion dependencies are acyclic; that is, the\\n * parallel computation can be described as a directed acyclic graph\\n * (DAG). Otherwise, executions may encounter a form of deadlock as\\n * tasks cyclically wait for each other.  However, this framework\\n * supports other methods and techniques (for example the use of\\n * {@link Phaser}, {@link #helpQuiesce}, and {@link #complete}) that\\n * may be of use in constructing custom subclasses for problems that\\n * are not statically structured as DAGs. To support such usages, a\\n * ForkJoinTask may be atomically \u003cem\u003etagged\u003c/em\u003e with a {@code short}\\n * value using {@link #setForkJoinTaskTag} or {@link\\n * #compareAndSetForkJoinTaskTag} and checked using {@link\\n * #getForkJoinTaskTag}. The ForkJoinTask implementation does not use\\n * these {@code protected} methods or tags for any purpose, but they\\n * may be of use in the construction of specialized subclasses.  For\\n * example, parallel graph traversals can use the supplied methods to\\n * avoid revisiting nodes/tasks that have already been processed.\\n * (Method names for tagging are bulky in part to encourage definition\\n * of methods that reflect their usage patterns.)\\n *\\n * \u003cp\u003eMost base support methods are {@code final}, to prevent\\n * overriding of implementations that are intrinsically tied to the\\n * underlying lightweight task scheduling framework.  Developers\\n * creating new basic styles of fork/join processing should minimally\\n * implement {@code protected} methods {@link #exec}, {@link\\n * #setRawResult}, and {@link #getRawResult}, while also introducing\\n * an abstract computational method that can be implemented in its\\n * subclasses, possibly relying on other {@code protected} methods\\n * provided by this class.\\n *\\n * \u003cp\u003eForkJoinTasks should perform relatively small amounts of\\n * computation. Large tasks should be split into smaller subtasks,\\n * usually via recursive decomposition. As a very rough rule of thumb,\\n * a task should perform more than 100 and less than 10000 basic\\n * computational steps, and should avoid indefinite looping. If tasks\\n * are too big, then parallelism cannot improve throughput. If too\\n * small, then memory and internal task maintenance overhead may\\n * overwhelm processing.\\n *\\n * \u003cp\u003eThis class provides {@code adapt} methods for {@link Runnable}\\n * and {@link Callable}, that may be of use when mixing execution of\\n * {@code ForkJoinTasks} with other kinds of tasks. When all tasks are\\n * of this form, consider using a pool constructed in \u003cem\u003easyncMode\u003c/em\u003e.\\n *\\n * \u003cp\u003eForkJoinTasks are {@code Serializable}, which enables them to be\\n * used in extensions such as remote execution frameworks. It is\\n * sensible to serialize tasks only before or after, but not during,\\n * execution. Serialization is not relied on during execution itself.\\n *\\n * @since 1.7\\n * @author Doug Lea\\n \u0027}"}, {"color": "#97c2fc", "id": "private void signalWaiters()", "label": "private void signalWaiters()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Removes and unparks waiters \u0027}"}, {"color": "#97c2fc", "id": "private int setDone()", "label": "private int setDone()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets DONE status and wakes up threads waiting to join this task.\\n     * @return status on exit\\n     \u0027}"}, {"color": "#97c2fc", "id": "private int trySetCancelled()", "label": "private int trySetCancelled()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets ABNORMAL DONE status unless already done, and wakes up threads\\n     * waiting to join this task.\\n     * @return status on exit\\n     \u0027}"}, {"color": "#97c2fc", "id": " final int trySetThrown(Throwable ex)", "label": " final int trySetThrown(Throwable ex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Records exception and sets ABNORMAL THROWN DONE status unless\\n     * already done, and wakes up threads waiting to join this task.\\n     * If losing a race with setDone or trySetCancelled, the exception\\n     * may be recorded but not reported.\\n     *\\n     * @return status on exit\\n     \u0027}"}, {"color": "#97c2fc", "id": " int trySetException(Throwable ex)", "label": " int trySetException(Throwable ex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Records exception unless already done. Overridable in subclasses.\\n     *\\n     * @return status on exit\\n     \u0027}"}, {"color": "#97c2fc", "id": " final int doExec()", "label": " final int doExec()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Unless done, calls exec and records status if completed, but\\n     * doesn\u0027t wait for completion otherwise.\\n     *\\n     * @return status on exit from this method\\n     \"}"}, {"color": "#97c2fc", "id": "private int awaitDone(ForkJoinPool pool, boolean ran, boolean interruptible, boolean timed, long nanos)", "label": "private int awaitDone(ForkJoinPool pool, boolean ran, boolean interruptible, boolean timed, long nanos)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Helps and/or waits for completion from join, get, or invoke;\\n     * called from either internal or external threads.\\n     *\\n     * @param pool if nonnull, known submitted pool, else assumes current pool\\n     * @param ran true if task known to have been exec\u0027d\\n     * @param interruptible true if park interruptibly when external\\n     * @param timed true if use timed wait\\n     * @param nanos if timed, timeout value\\n     * @return ABNORMAL if interrupted, else status on exit\\n     \"}"}, {"color": "#97c2fc", "id": " static final void cancelIgnoringExceptions(Future\u003c?\u003e t)", "label": " static final void cancelIgnoringExceptions(Future\u003c?\u003e t)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Cancels, ignoring any exceptions thrown by cancel.  Cancel is\\n     * spec\u0027ed not to throw any exceptions, but if it does anyway, we\\n     * have no recourse, so guard against this case.\\n     \"}"}, {"color": "#97c2fc", "id": "private Throwable getThrowableException()", "label": "private Throwable getThrowableException()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a rethrowable exception for this task, if available.\\n     * To provide accurate stack traces, if the exception was not\\n     * thrown by the current thread, we try to create a new exception\\n     * of the same type as the one thrown, but with the recorded\\n     * exception as its cause. If there is no such constructor, we\\n     * instead try to use a no-arg constructor, followed by initCause,\\n     * to the same effect. If none of these apply, or any fail due to\\n     * other exceptions, we return the recorded exception, which is\\n     * still correct, although it may contain a misleading stack\\n     * trace.\\n     *\\n     * @return the exception, or null if none\\n     \u0027}"}, {"color": "#97c2fc", "id": "private Throwable getException(int s)", "label": "private Throwable getException(int s)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns exception associated with the given status, or null if none.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void reportException(int s)", "label": "private void reportException(int s)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Throws exception associated with the given status, or\\n     * CancellationException if none recorded.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void reportExecutionException(int s)", "label": "private void reportExecutionException(int s)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Throws exception for (timed or untimed) get, wrapping if\\n     * necessary in an ExecutionException.\\n     \u0027}"}, {"color": "#97c2fc", "id": " static void rethrow(Throwable ex)", "label": " static void rethrow(Throwable ex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * A version of \"sneaky throw\" to relay exceptions in other\\n     * contexts.\\n     \u0027}"}, {"color": "#97c2fc", "id": " static void uncheckedThrow(Throwable t) throws T", "label": " static void uncheckedThrow(Throwable t) throws T", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The sneaky part of sneaky throw, relying on generics\\n     * limitations to evade compiler complaints about rethrowing\\n     * unchecked exceptions. If argument null, throws\\n     * CancellationException.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final ForkJoinTask\u003cV\u003e fork()", "label": "public final ForkJoinTask\u003cV\u003e fork()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Arranges to asynchronously execute this task in the pool the\\n     * current task is running in, if applicable, or using the {@link\\n     * ForkJoinPool#commonPool()} if not {@link #inForkJoinPool}.  While\\n     * it is not necessarily enforced, it is a usage error to fork a\\n     * task more than once unless it has completed and been\\n     * reinitialized.  Subsequent modifications to the state of this\\n     * task or any data it operates on are not necessarily\\n     * consistently observable by any thread other than the one\\n     * executing it unless preceded by a call to {@link #join} or\\n     * related methods, or a call to {@link #isDone} returning {@code\\n     * true}.\\n     *\\n     * @return {@code this}, to simplify usage\\n     \u0027}"}, {"color": "#97c2fc", "id": "join", "label": "join", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "isDone", "label": "isDone", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "inForkJoinPool", "label": "inForkJoinPool", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public final V join()", "label": "public final V join()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the result of the computation when it\\n     * {@linkplain #isDone is done}.\\n     * This method differs from {@link #get()} in that abnormal\\n     * completion results in {@code RuntimeException} or {@code Error},\\n     * not {@code ExecutionException}, and that interrupts of the\\n     * calling thread do \u003cem\u003enot\u003c/em\u003e cause the method to abruptly\\n     * return by throwing {@code InterruptedException}.\\n     *\\n     * @return the computed result\\n     \u0027}"}, {"color": "#97c2fc", "id": "get()", "label": "get()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public final V invoke()", "label": "public final V invoke()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Commences performing this task, awaits its completion if\\n     * necessary, and returns its result, or throws an (unchecked)\\n     * {@code RuntimeException} or {@code Error} if the underlying\\n     * computation did so.\\n     *\\n     * @return the computed result\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void invokeAll(ForkJoinTask\u003c?\u003e t1, ForkJoinTask\u003c?\u003e t2)", "label": "public static void invokeAll(ForkJoinTask\u003c?\u003e t1, ForkJoinTask\u003c?\u003e t2)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Forks the given tasks, returning when {@code isDone} holds for\\n     * each task or an (unchecked) exception is encountered, in which\\n     * case the exception is rethrown. If more than one task\\n     * encounters an exception, then this method throws any one of\\n     * these exceptions. If any task encounters an exception, the\\n     * other may be cancelled. However, the execution status of\\n     * individual tasks is not guaranteed upon exceptional return. The\\n     * status of each task may be obtained using {@link\\n     * #getException()} and related methods to check if they have been\\n     * cancelled, completed normally or exceptionally, or left\\n     * unprocessed.\\n     *\\n     * @param t1 the first task\\n     * @param t2 the second task\\n     * @throws NullPointerException if any task is null\\n     \u0027}"}, {"color": "#97c2fc", "id": "getException()", "label": "getException()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static void invokeAll(ForkJoinTask\u003c?\u003e... tasks)", "label": "public static void invokeAll(ForkJoinTask\u003c?\u003e... tasks)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Forks the given tasks, returning when {@code isDone} holds for\\n     * each task or an (unchecked) exception is encountered, in which\\n     * case the exception is rethrown. If more than one task\\n     * encounters an exception, then this method throws any one of\\n     * these exceptions. If any task encounters an exception, others\\n     * may be cancelled. However, the execution status of individual\\n     * tasks is not guaranteed upon exceptional return. The status of\\n     * each task may be obtained using {@link #getException()} and\\n     * related methods to check if they have been cancelled, completed\\n     * normally or exceptionally, or left unprocessed.\\n     *\\n     * @param tasks the tasks\\n     * @throws NullPointerException if any task is null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collection\u003cT\u003e invokeAll(Collection\u003cT\u003e tasks)", "label": "public static Collection\u003cT\u003e invokeAll(Collection\u003cT\u003e tasks)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Forks all tasks in the specified collection, returning when\\n     * {@code isDone} holds for each task or an (unchecked) exception\\n     * is encountered, in which case the exception is rethrown. If\\n     * more than one task encounters an exception, then this method\\n     * throws any one of these exceptions. If any task encounters an\\n     * exception, others may be cancelled. However, the execution\\n     * status of individual tasks is not guaranteed upon exceptional\\n     * return. The status of each task may be obtained using {@link\\n     * #getException()} and related methods to check if they have been\\n     * cancelled, completed normally or exceptionally, or left\\n     * unprocessed.\\n     *\\n     * @param tasks the collection of tasks\\n     * @param \u003cT\u003e the type of the values returned from the tasks\\n     * @return the tasks argument, to simplify usage\\n     * @throws NullPointerException if tasks or any element are null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean cancel(boolean mayInterruptIfRunning)", "label": "public boolean cancel(boolean mayInterruptIfRunning)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Attempts to cancel execution of this task. This attempt will\\n     * fail if the task has already completed or could not be\\n     * cancelled for some other reason. If successful, and this task\\n     * has not started when {@code cancel} is called, execution of\\n     * this task is suppressed. After this method returns\\n     * successfully, unless there is an intervening call to {@link\\n     * #reinitialize}, subsequent calls to {@link #isCancelled},\\n     * {@link #isDone}, and {@code cancel} will return {@code true}\\n     * and calls to {@link #join} and related methods will result in\\n     * {@code CancellationException}.\\n     *\\n     * \u003cp\u003eThis method may be overridden in subclasses, but if so, must\\n     * still ensure that these properties hold. In particular, the\\n     * {@code cancel} method itself must not throw exceptions.\\n     *\\n     * \u003cp\u003eThis method is designed to be invoked by \u003cem\u003eother\u003c/em\u003e\\n     * tasks. To terminate the current task, you can just return or\\n     * throw an unchecked exception from its computation method, or\\n     * invoke {@link #completeExceptionally(Throwable)}.\\n     *\\n     * @param mayInterruptIfRunning this value has no effect in the\\n     * default implementation because interrupts are not used to\\n     * control cancellation.\\n     *\\n     * @return {@code true} if this task is now cancelled\\n     \u0027}"}, {"color": "#97c2fc", "id": "isCancelled", "label": "isCancelled", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "completeExceptionally(Throwable)", "label": "completeExceptionally(Throwable)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "reinitialize", "label": "reinitialize", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public final boolean isCompletedAbnormally()", "label": "public final boolean isCompletedAbnormally()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if this task threw an exception or was cancelled.\\n     *\\n     * @return {@code true} if this task threw an exception or was cancelled\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final boolean isCompletedNormally()", "label": "public final boolean isCompletedNormally()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if this task completed without throwing an\\n     * exception and was not cancelled.\\n     *\\n     * @return {@code true} if this task completed without throwing an\\n     * exception and was not cancelled\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final Throwable getException()", "label": "public final Throwable getException()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the exception thrown by the base computation, or a\\n     * {@code CancellationException} if cancelled, or {@code null} if\\n     * none or if the method has not yet completed.\\n     *\\n     * @return the exception, or {@code null} if none\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void completeExceptionally(Throwable ex)", "label": "public void completeExceptionally(Throwable ex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Completes this task abnormally, and if not already aborted or\\n     * cancelled, causes it to throw the given exception upon\\n     * {@code join} and related operations. This method may be used\\n     * to induce exceptions in asynchronous tasks, or to force\\n     * completion of tasks that would not otherwise complete.  Its use\\n     * in other situations is discouraged.  This method is\\n     * overridable, but overridden versions must invoke {@code super}\\n     * implementation to maintain guarantees.\\n     *\\n     * @param ex the exception to throw. If this exception is not a\\n     * {@code RuntimeException} or {@code Error}, the actual exception\\n     * thrown will be a {@code RuntimeException} with cause {@code ex}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void complete(V value)", "label": "public void complete(V value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Completes this task, and if not already aborted or cancelled,\\n     * returning the given value as the result of subsequent\\n     * invocations of {@code join} and related operations. This method\\n     * may be used to provide results for asynchronous tasks, or to\\n     * provide alternative handling for tasks that would not otherwise\\n     * complete normally. Its use in other situations is\\n     * discouraged. This method is overridable, but overridden\\n     * versions must invoke {@code super} implementation to maintain\\n     * guarantees.\\n     *\\n     * @param value the result value for this task\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final void quietlyComplete()", "label": "public final void quietlyComplete()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Completes this task normally without setting a value. The most\\n     * recent value established by {@link #setRawResult} (or {@code\\n     * null} by default) will be returned as the result of subsequent\\n     * invocations of {@code join} and related operations.\\n     *\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "setRawResult", "label": "setRawResult", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public final V get() throws InterruptedException, ExecutionException", "label": "public final V get() throws InterruptedException, ExecutionException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Waits if necessary for the computation to complete, and then\\n     * retrieves its result.\\n     *\\n     * @return the computed result\\n     * @throws CancellationException if the computation was cancelled\\n     * @throws ExecutionException if the computation threw an\\n     * exception\\n     * @throws InterruptedException if the current thread is not a\\n     * member of a ForkJoinPool and was interrupted while waiting\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException", "label": "public final V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Waits if necessary for at most the given time for the computation\\n     * to complete, and then retrieves its result, if available.\\n     *\\n     * @param timeout the maximum time to wait\\n     * @param unit the time unit of the timeout argument\\n     * @return the computed result\\n     * @throws CancellationException if the computation was cancelled\\n     * @throws ExecutionException if the computation threw an\\n     * exception\\n     * @throws InterruptedException if the current thread is not a\\n     * member of a ForkJoinPool and was interrupted while waiting\\n     * @throws TimeoutException if the wait timed out\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final void quietlyJoin()", "label": "public final void quietlyJoin()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Joins this task, without returning its result or throwing its\\n     * exception. This method may be useful when processing\\n     * collections of tasks when some have been cancelled or otherwise\\n     * known to have aborted.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final void quietlyInvoke()", "label": "public final void quietlyInvoke()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Commences performing this task and awaits its completion if\\n     * necessary, without returning its result or throwing its\\n     * exception.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void helpQuiesce()", "label": "public static void helpQuiesce()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Possibly executes tasks until the pool hosting the current task\\n     * {@linkplain ForkJoinPool#isQuiescent is quiescent}.  This\\n     * method may be of use in designs in which many tasks are forked,\\n     * but none are explicitly joined, instead executing them until\\n     * all are processed.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void reinitialize()", "label": "public void reinitialize()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Resets the internal bookkeeping state of this task, allowing a\\n     * subsequent {@code fork}. This method allows repeated reuse of\\n     * this task, but only if reuse occurs when this task has either\\n     * never been forked, or has been forked, then completed and all\\n     * outstanding joins of this task have also completed. Effects\\n     * under any other usage conditions are not guaranteed.\\n     * This method may be useful when executing\\n     * pre-constructed trees of subtasks in loops.\\n     *\\n     * \u003cp\u003eUpon completion of this method, {@code isDone()} reports\\n     * {@code false}, and {@code getException()} reports {@code\\n     * null}. However, the value returned by {@code getRawResult} is\\n     * unaffected. To clear this value, you can invoke {@code\\n     * setRawResult(null)}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static ForkJoinPool getPool()", "label": "public static ForkJoinPool getPool()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the pool hosting the current thread, or {@code null}\\n     * if the current thread is executing outside of any ForkJoinPool.\\n     *\\n     * \u003cp\u003eThis method returns {@code null} if and only if {@link\\n     * #inForkJoinPool} returns {@code false}.\\n     *\\n     * @return the pool, or {@code null} if none\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean inForkJoinPool()", "label": "public static boolean inForkJoinPool()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if the current thread is a {@link\\n     * ForkJoinWorkerThread} executing as a ForkJoinPool computation.\\n     *\\n     * @return {@code true} if the current thread is a {@link\\n     * ForkJoinWorkerThread} executing as a ForkJoinPool computation,\\n     * or {@code false} otherwise\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.util.concurrent.ForkJoinWorkerThread", "label": "java.util.concurrent.ForkJoinWorkerThread", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * A thread managed by a {@link ForkJoinPool}, which executes\\n * {@link ForkJoinTask}s.\\n * This class is subclassable solely for the sake of adding\\n * functionality -- there are no overridable methods dealing with\\n * scheduling or execution.  However, you can override initialization\\n * and termination methods surrounding the main task processing loop.\\n * If you do create such a subclass, you will also need to supply a\\n * custom {@link ForkJoinPool.ForkJoinWorkerThreadFactory} to\\n * {@linkplain ForkJoinPool#ForkJoinPool(int, ForkJoinWorkerThreadFactory,\\n * UncaughtExceptionHandler, boolean, int, int, int, Predicate, long, TimeUnit)\\n * use it} in a {@code ForkJoinPool}.\\n *\\n * @since 1.7\\n * @author Doug Lea\\n \u0027}"}, {"color": "#97c2fc", "id": "public ForkJoinPool getPool()", "label": "public ForkJoinPool getPool()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the pool hosting this thread.\\n     *\\n     * @return the pool\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getPoolIndex()", "label": "public int getPoolIndex()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the unique index number of this thread in its pool.\\n     * The returned value ranges from zero to the maximum number of\\n     * threads (minus one) that may exist in the pool, and does not\\n     * change during the lifetime of the thread.  This method may be\\n     * useful for applications that track status or collect results\\n     * per-worker-thread rather than per-task.\\n     *\\n     * @return the index number\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected void onStart()", "label": "protected void onStart()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Initializes internal state after construction but before\\n     * processing any tasks. If you override this method, you must\\n     * invoke {@code super.onStart()} at the beginning of the method.\\n     * Initialization requires care: Most fields must have legal\\n     * default values, to ensure that attempted accesses from other\\n     * threads work correctly even before this thread starts\\n     * processing tasks.\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected void onTermination(Throwable exception)", "label": "protected void onTermination(Throwable exception)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs cleanup associated with termination of this worker\\n     * thread.  If you override this method, you must invoke\\n     * {@code super.onTermination} at the end of the overridden method.\\n     *\\n     * @param exception the exception causing this thread to abort due\\n     * to an unrecoverable error, or {@code null} if completed normally\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void run()", "label": "public void run()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * If this thread was constructed using a separate\\n     * {@code Runnable} run object, then that\\n     * {@code Runnable} object\u0027s {@code run} method is called;\\n     * otherwise, this method does nothing and returns.\\n     * \u003cp\u003e\\n     * Subclasses of {@code Thread} should override this method.\\n     *\\n     * @see     #start()\\n     * @see     #stop()\\n     * @see     #Thread(ThreadGroup, Runnable, String)\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean tryUnfork()", "label": "public boolean tryUnfork()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tries to unschedule this task for execution. This method will\\n     * typically (but is not guaranteed to) succeed if this task is\\n     * the most recently forked task by the current thread, and has\\n     * not commenced executing in another thread.  This method may be\\n     * useful when arranging alternative local processing of tasks\\n     * that could have been, but were not, stolen.\\n     *\\n     * @return {@code true} if unforked\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int getQueuedTaskCount()", "label": "public static int getQueuedTaskCount()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an estimate of the number of tasks that have been\\n     * forked by the current worker thread but not yet executed. This\\n     * value may be useful for heuristic decisions about whether to\\n     * fork other tasks.\\n     *\\n     * @return the number of tasks\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int getSurplusQueuedTaskCount()", "label": "public static int getSurplusQueuedTaskCount()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an estimate of how many more locally queued tasks are\\n     * held by the current worker thread than there are other worker\\n     * threads that might steal them, or zero if this thread is not\\n     * operating in a ForkJoinPool. This value may be useful for\\n     * heuristic decisions about whether to fork other tasks. In many\\n     * usages of ForkJoinTasks, at steady state, each worker should\\n     * aim to maintain a small constant surplus (for example, 3) of\\n     * tasks, and to process computations locally if this threshold is\\n     * exceeded.\\n     *\\n     * @return the surplus number of tasks, which may be negative\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract V getRawResult()", "label": "public abstract V getRawResult()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the result that would be returned by {@link #join}, even\\n     * if this task completed abnormally, or {@code null} if this task\\n     * is not known to have been completed.  This method is designed\\n     * to aid debugging, as well as to support extensions. Its use in\\n     * any other context is discouraged.\\n     *\\n     * @return the result, or {@code null} if not completed\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected abstract void setRawResult(V value)", "label": "protected abstract void setRawResult(V value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Forces the given value to be returned as a result.  This method\\n     * is designed to support extensions, and should not in general be\\n     * called otherwise.\\n     *\\n     * @param value the value\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected abstract boolean exec()", "label": "protected abstract boolean exec()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Immediately performs the base action of this task and returns\\n     * true if, upon return from this method, this task is guaranteed\\n     * to have completed. This method may return false otherwise, to\\n     * indicate that this task is not necessarily complete (or is not\\n     * known to be complete), for example in asynchronous actions that\\n     * require explicit invocations of completion methods. This method\\n     * may also throw an (unchecked) exception to indicate abnormal\\n     * exit. This method is designed to support extensions, and should\\n     * not in general be called otherwise.\\n     *\\n     * @return {@code true} if this task is known to have completed normally\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected static ForkJoinTask\u003c?\u003e peekNextLocalTask()", "label": "protected static ForkJoinTask\u003c?\u003e peekNextLocalTask()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns, but does not unschedule or execute, a task queued by\\n     * the current thread but not yet executed, if one is immediately\\n     * available. There is no guarantee that this task will actually\\n     * be polled or executed next. Conversely, this method may return\\n     * null even if a task exists but cannot be accessed without\\n     * contention with other threads.  This method is designed\\n     * primarily to support extensions, and is unlikely to be useful\\n     * otherwise.\\n     *\\n     * @return the next task, or {@code null} if none are available\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected static ForkJoinTask\u003c?\u003e pollNextLocalTask()", "label": "protected static ForkJoinTask\u003c?\u003e pollNextLocalTask()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Unschedules and returns, without executing, the next task\\n     * queued by the current thread but not yet executed, if the\\n     * current thread is operating in a ForkJoinPool.  This method is\\n     * designed primarily to support extensions, and is unlikely to be\\n     * useful otherwise.\\n     *\\n     * @return the next task, or {@code null} if none are available\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected static ForkJoinTask\u003c?\u003e pollTask()", "label": "protected static ForkJoinTask\u003c?\u003e pollTask()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * If the current thread is operating in a ForkJoinPool,\\n     * unschedules and returns, without executing, the next task\\n     * queued by the current thread but not yet executed, if one is\\n     * available, or if not available, a task that was forked by some\\n     * other thread, if available. Availability may be transient, so a\\n     * {@code null} result does not necessarily imply quiescence of\\n     * the pool this task is operating in.  This method is designed\\n     * primarily to support extensions, and is unlikely to be useful\\n     * otherwise.\\n     *\\n     * @return a task, or {@code null} if none are available\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final short getForkJoinTaskTag()", "label": "public final short getForkJoinTaskTag()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the tag for this task.\\n     *\\n     * @return the tag for this task\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final short setForkJoinTaskTag(short newValue)", "label": "public final short setForkJoinTaskTag(short newValue)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Atomically sets the tag value for this task and returns the old value.\\n     *\\n     * @param newValue the new tag value\\n     * @return the previous value of the tag\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final boolean compareAndSetForkJoinTaskTag(short expect, short update)", "label": "public final boolean compareAndSetForkJoinTaskTag(short expect, short update)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Atomically conditionally sets the tag value for this task.\\n     * Among other applications, tags can be used as visit markers\\n     * in tasks operating on graphs, as in methods that check: {@code\\n     * if (task.compareAndSetForkJoinTaskTag((short)0, (short)1))}\\n     * before processing, otherwise exiting because the node has\\n     * already been visited.\\n     *\\n     * @param expect the expected tag value\\n     * @param update the new tag value\\n     * @return {@code true} if successful; i.e., the current value was\\n     * equal to {@code expect} and was changed to {@code update}.\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static ForkJoinTask\u003c?\u003e adapt(Runnable runnable)", "label": "public static ForkJoinTask\u003c?\u003e adapt(Runnable runnable)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a new {@code ForkJoinTask} that performs the {@code run}\\n     * method of the given {@code Runnable} as its action, and returns\\n     * a null result upon {@link #join}.\\n     *\\n     * @param runnable the runnable action\\n     * @return the task\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static ForkJoinTask\u003cT\u003e adapt(Runnable runnable, T result)", "label": "public static ForkJoinTask\u003cT\u003e adapt(Runnable runnable, T result)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a new {@code ForkJoinTask} that performs the {@code run}\\n     * method of the given {@code Runnable} as its action, and returns\\n     * the given result upon {@link #join}.\\n     *\\n     * @param runnable the runnable action\\n     * @param result the result upon completion\\n     * @param \u003cT\u003e the type of the result\\n     * @return the task\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static ForkJoinTask\u003cT\u003e adapt(Callable\u003c? extends T\u003e callable)", "label": "public static ForkJoinTask\u003cT\u003e adapt(Callable\u003c? extends T\u003e callable)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a new {@code ForkJoinTask} that performs the {@code call}\\n     * method of the given {@code Callable} as its action, and returns\\n     * its result upon {@link #join}, translating any checked exceptions\\n     * encountered into {@code RuntimeException}.\\n     *\\n     * @param callable the callable action\\n     * @param \u003cT\u003e the type of the callable\u0027s result\\n     * @return the task\\n     \"}"}, {"color": "#97c2fc", "id": "private static ForkJoinTask\u003cT\u003e adaptInterruptible(Callable\u003c? extends T\u003e callable)", "label": "private static ForkJoinTask\u003cT\u003e adaptInterruptible(Callable\u003c? extends T\u003e callable)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 TODO: public \u0027}"}, {"color": "#97c2fc", "id": "private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException", "label": "private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Saves this task to a stream (that is, serializes it).\\n     *\\n     * @param s the stream\\n     * @throws java.io.IOException if an I/O error occurs\\n     * @serialData the current run status and the exception thrown\\n     * during execution, or {@code null} if none\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException", "label": "private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Recompile the Pattern instance from a stream.  The original pattern\\n     * string is read in and the object tree is recompiled from it.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isShutdown()", "label": "public boolean isShutdown()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if this pool has been shut down.\\n     *\\n     * @return {@code true} if this pool has been shut down\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException", "label": "public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Blocks until all tasks have completed execution after a\\n     * shutdown request, or the timeout occurs, or the current thread\\n     * is interrupted, whichever happens first. Because the {@link\\n     * #commonPool()} never terminates until program shutdown, when\\n     * applied to the common pool, this method is equivalent to {@link\\n     * #awaitQuiescence(long, TimeUnit)} but always returns {@code false}.\\n     *\\n     * @param timeout the maximum time to wait\\n     * @param unit the time unit of the timeout argument\\n     * @return {@code true} if this executor terminated and\\n     *         {@code false} if the timeout elapsed before termination\\n     * @throws InterruptedException if interrupted while waiting\\n     \u0027}"}, {"color": "#97c2fc", "id": "awaitQuiescence(long", "label": "awaitQuiescence(long", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public boolean awaitQuiescence(long timeout, TimeUnit unit)", "label": "public boolean awaitQuiescence(long timeout, TimeUnit unit)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * If called by a ForkJoinTask operating in this pool, equivalent\\n     * in effect to {@link ForkJoinTask#helpQuiesce}. Otherwise,\\n     * waits and/or attempts to assist performing tasks until this\\n     * pool {@link #isQuiescent} or the indicated timeout elapses.\\n     *\\n     * @param timeout the maximum time to wait\\n     * @param unit the time unit of the timeout argument\\n     * @return {@code true} if quiescent; {@code false} if the\\n     * timeout elapsed.\\n     \u0027}"}, {"color": "#97c2fc", "id": "isQuiescent", "label": "isQuiescent", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static void managedBlock(ManagedBlocker blocker) throws InterruptedException", "label": "public static void managedBlock(ManagedBlocker blocker) throws InterruptedException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Runs the given possibly blocking task.  When {@linkplain\\n     * ForkJoinTask#inForkJoinPool() running in a ForkJoinPool}, this\\n     * method possibly arranges for a spare thread to be activated if\\n     * necessary to ensure sufficient parallelism while the current\\n     * thread is blocked in {@link ManagedBlocker#block blocker.block()}.\\n     *\\n     * \u003cp\u003eThis method repeatedly calls {@code blocker.isReleasable()} and\\n     * {@code blocker.block()} until either method returns {@code true}.\\n     * Every call to {@code blocker.block()} is preceded by a call to\\n     * {@code blocker.isReleasable()} that returned {@code false}.\\n     *\\n     * \u003cp\u003eIf not running in a ForkJoinPool, this method is\\n     * behaviorally equivalent to\\n     * \u003cpre\u003e {@code\\n     * while (!blocker.isReleasable())\\n     *   if (blocker.block())\\n     *     break;}\u003c/pre\u003e\\n     *\\n     * If running in a ForkJoinPool, the pool may first be expanded to\\n     * ensure sufficient parallelism available during the call to\\n     * {@code blocker.block()}.\\n     *\\n     * @param blocker the blocker task\\n     * @throws InterruptedException if {@code blocker.block()} did so\\n     \u0027}"}, {"color": "#97c2fc", "id": "block", "label": "block", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "private void compensatedBlock(ManagedBlocker blocker) throws InterruptedException", "label": "private void compensatedBlock(ManagedBlocker blocker) throws InterruptedException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 ManagedBlock for ForkJoinWorkerThreads \u0027}"}, {"color": "#97c2fc", "id": "private static void unmanagedBlock(ManagedBlocker blocker) throws InterruptedException", "label": "private static void unmanagedBlock(ManagedBlocker blocker) throws InterruptedException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 ManagedBlock for external threads \u0027}"}, {"color": "#97c2fc", "id": "sort(Object", "label": "sort(Object", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static void parallelSort(T[] a, int fromIndex, int toIndex)", "label": "public static void parallelSort(T[] a, int fromIndex, int toIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified range of the specified array of objects into\\n     * ascending order, according to the\\n     * {@linkplain Comparable natural ordering} of its\\n     * elements.  The range to be sorted extends from index\\n     * {@code fromIndex}, inclusive, to index {@code toIndex}, exclusive.\\n     * (If {@code fromIndex==toIndex}, the range to be sorted is empty.)  All\\n     * elements in this range must implement the {@link Comparable}\\n     * interface.  Furthermore, all elements in this range must be \u003ci\u003emutually\\n     * comparable\u003c/i\u003e (that is, {@code e1.compareTo(e2)} must not throw a\\n     * {@code ClassCastException} for any elements {@code e1} and\\n     * {@code e2} in the array).\\n     *\\n     * \u003cp\u003eThis sort is guaranteed to be \u003ci\u003estable\u003c/i\u003e:  equal elements will\\n     * not be reordered as a result of the sort.\\n     *\\n     * @implNote The sorting algorithm is a parallel sort-merge that breaks the\\n     * array into sub-arrays that are themselves sorted and then merged. When\\n     * the sub-array length reaches a minimum granularity, the sub-array is\\n     * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}\\n     * method. If the length of the specified array is less than the minimum\\n     * granularity, then it is sorted using the appropriate {@link\\n     * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a working\\n     * space no greater than the size of the specified range of the original\\n     * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is\\n     * used to execute any parallel tasks.\\n     *\\n     * @param \u003cT\u003e the class of the objects to be sorted\\n     * @param a the array to be sorted\\n     * @param fromIndex the index of the first element (inclusive) to be\\n     *        sorted\\n     * @param toIndex the index of the last element (exclusive) to be sorted\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex} or\\n     *         (optional) if the natural ordering of the array elements is\\n     *         found to violate the {@link Comparable} contract\\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex \u003c 0} or\\n     *         {@code toIndex \u003e a.length}\\n     * @throws ClassCastException if the array contains elements that are\\n     *         not \u003ci\u003emutually comparable\u003c/i\u003e (for example, strings and\\n     *         integers).\\n     *\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void parallelSort(T[] a, Comparator\u003c? super T\u003e cmp)", "label": "public static void parallelSort(T[] a, Comparator\u003c? super T\u003e cmp)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Sorts the specified array of objects according to the order induced by\\n     * the specified comparator.  All elements in the array must be\\n     * \u003ci\u003emutually comparable\u003c/i\u003e by the specified comparator (that is,\\n     * {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}\\n     * for any elements {@code e1} and {@code e2} in the array).\\n     *\\n     * \u003cp\u003eThis sort is guaranteed to be \u003ci\u003estable\u003c/i\u003e:  equal elements will\\n     * not be reordered as a result of the sort.\\n     *\\n     * @implNote The sorting algorithm is a parallel sort-merge that breaks the\\n     * array into sub-arrays that are themselves sorted and then merged. When\\n     * the sub-array length reaches a minimum granularity, the sub-array is\\n     * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}\\n     * method. If the length of the specified array is less than the minimum\\n     * granularity, then it is sorted using the appropriate {@link\\n     * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a\\n     * working space no greater than the size of the original array. The\\n     * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to\\n     * execute any parallel tasks.\\n     *\\n     * @param \u003cT\u003e the class of the objects to be sorted\\n     * @param a the array to be sorted\\n     * @param cmp the comparator to determine the order of the array.  A\\n     *        {@code null} value indicates that the elements\u0027\\n     *        {@linkplain Comparable natural ordering} should be used.\\n     * @throws ClassCastException if the array contains elements that are\\n     *         not \u003ci\u003emutually comparable\u003c/i\u003e using the specified comparator\\n     * @throws IllegalArgumentException (optional) if the comparator is\\n     *         found to violate the {@link java.util.Comparator} contract\\n     *\\n     * @since 1.8\\n     \"}"}, {"color": "#97c2fc", "id": "public static void parallelSort(T[] a, int fromIndex, int toIndex, Comparator\u003c? super T\u003e cmp)", "label": "public static void parallelSort(T[] a, int fromIndex, int toIndex, Comparator\u003c? super T\u003e cmp)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Sorts the specified range of the specified array of objects according\\n     * to the order induced by the specified comparator.  The range to be\\n     * sorted extends from index {@code fromIndex}, inclusive, to index\\n     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\\n     * range to be sorted is empty.)  All elements in the range must be\\n     * \u003ci\u003emutually comparable\u003c/i\u003e by the specified comparator (that is,\\n     * {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}\\n     * for any elements {@code e1} and {@code e2} in the range).\\n     *\\n     * \u003cp\u003eThis sort is guaranteed to be \u003ci\u003estable\u003c/i\u003e:  equal elements will\\n     * not be reordered as a result of the sort.\\n     *\\n     * @implNote The sorting algorithm is a parallel sort-merge that breaks the\\n     * array into sub-arrays that are themselves sorted and then merged. When\\n     * the sub-array length reaches a minimum granularity, the sub-array is\\n     * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}\\n     * method. If the length of the specified array is less than the minimum\\n     * granularity, then it is sorted using the appropriate {@link\\n     * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a working\\n     * space no greater than the size of the specified range of the original\\n     * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is\\n     * used to execute any parallel tasks.\\n     *\\n     * @param \u003cT\u003e the class of the objects to be sorted\\n     * @param a the array to be sorted\\n     * @param fromIndex the index of the first element (inclusive) to be\\n     *        sorted\\n     * @param toIndex the index of the last element (exclusive) to be sorted\\n     * @param cmp the comparator to determine the order of the array.  A\\n     *        {@code null} value indicates that the elements\u0027\\n     *        {@linkplain Comparable natural ordering} should be used.\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex} or\\n     *         (optional) if the natural ordering of the array elements is\\n     *         found to violate the {@link Comparable} contract\\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex \u003c 0} or\\n     *         {@code toIndex \u003e a.length}\\n     * @throws ClassCastException if the array contains elements that are\\n     *         not \u003ci\u003emutually comparable\u003c/i\u003e (for example, strings and\\n     *         integers).\\n     *\\n     * @since 1.8\\n     \"}"}, {"color": "#97c2fc", "id": "public static void sort(Object[] a)", "label": "public static void sort(Object[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified array of objects into ascending order, according\\n     * to the {@linkplain Comparable natural ordering} of its elements.\\n     * All elements in the array must implement the {@link Comparable}\\n     * interface.  Furthermore, all elements in the array must be\\n     * \u003ci\u003emutually comparable\u003c/i\u003e (that is, {@code e1.compareTo(e2)} must\\n     * not throw a {@code ClassCastException} for any elements {@code e1}\\n     * and {@code e2} in the array).\\n     *\\n     * \u003cp\u003eThis sort is guaranteed to be \u003ci\u003estable\u003c/i\u003e:  equal elements will\\n     * not be reordered as a result of the sort.\\n     *\\n     * \u003cp\u003eImplementation note: This implementation is a stable, adaptive,\\n     * iterative mergesort that requires far fewer than n lg(n) comparisons\\n     * when the input array is partially sorted, while offering the\\n     * performance of a traditional mergesort when the input array is\\n     * randomly ordered.  If the input array is nearly sorted, the\\n     * implementation requires approximately n comparisons.  Temporary\\n     * storage requirements vary from a small constant for nearly sorted\\n     * input arrays to n/2 object references for randomly ordered input\\n     * arrays.\\n     *\\n     * \u003cp\u003eThe implementation takes equal advantage of ascending and\\n     * descending order in its input array, and can take advantage of\\n     * ascending and descending order in different parts of the same\\n     * input array.  It is well-suited to merging two or more sorted arrays:\\n     * simply concatenate the arrays and sort the resulting array.\\n     *\\n     * \u003cp\u003eThe implementation was adapted from Tim Peters\\\u0027s list sort for Python\\n     * (\u003ca href=\"http://svn.python.org/projects/python/trunk/Objects/listsort.txt\"\u003e\\n     * TimSort\u003c/a\u003e).  It uses techniques from Peter McIlroy\\\u0027s \"Optimistic\\n     * Sorting and Information Theoretic Complexity\", in Proceedings of the\\n     * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,\\n     * January 1993.\\n     *\\n     * @param a the array to be sorted\\n     * @throws ClassCastException if the array contains elements that are not\\n     *         \u003ci\u003emutually comparable\u003c/i\u003e (for example, strings and integers)\\n     * @throws IllegalArgumentException (optional) if the natural\\n     *         ordering of the array elements is found to violate the\\n     *         {@link Comparable} contract\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void sort(Object[] a, int fromIndex, int toIndex)", "label": "public static void sort(Object[] a, int fromIndex, int toIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified range of the specified array of objects into\\n     * ascending order, according to the\\n     * {@linkplain Comparable natural ordering} of its\\n     * elements.  The range to be sorted extends from index\\n     * {@code fromIndex}, inclusive, to index {@code toIndex}, exclusive.\\n     * (If {@code fromIndex==toIndex}, the range to be sorted is empty.)  All\\n     * elements in this range must implement the {@link Comparable}\\n     * interface.  Furthermore, all elements in this range must be \u003ci\u003emutually\\n     * comparable\u003c/i\u003e (that is, {@code e1.compareTo(e2)} must not throw a\\n     * {@code ClassCastException} for any elements {@code e1} and\\n     * {@code e2} in the array).\\n     *\\n     * \u003cp\u003eThis sort is guaranteed to be \u003ci\u003estable\u003c/i\u003e:  equal elements will\\n     * not be reordered as a result of the sort.\\n     *\\n     * \u003cp\u003eImplementation note: This implementation is a stable, adaptive,\\n     * iterative mergesort that requires far fewer than n lg(n) comparisons\\n     * when the input array is partially sorted, while offering the\\n     * performance of a traditional mergesort when the input array is\\n     * randomly ordered.  If the input array is nearly sorted, the\\n     * implementation requires approximately n comparisons.  Temporary\\n     * storage requirements vary from a small constant for nearly sorted\\n     * input arrays to n/2 object references for randomly ordered input\\n     * arrays.\\n     *\\n     * \u003cp\u003eThe implementation takes equal advantage of ascending and\\n     * descending order in its input array, and can take advantage of\\n     * ascending and descending order in different parts of the same\\n     * input array.  It is well-suited to merging two or more sorted arrays:\\n     * simply concatenate the arrays and sort the resulting array.\\n     *\\n     * \u003cp\u003eThe implementation was adapted from Tim Peters\\\u0027s list sort for Python\\n     * (\u003ca href=\"http://svn.python.org/projects/python/trunk/Objects/listsort.txt\"\u003e\\n     * TimSort\u003c/a\u003e).  It uses techniques from Peter McIlroy\\\u0027s \"Optimistic\\n     * Sorting and Information Theoretic Complexity\", in Proceedings of the\\n     * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,\\n     * January 1993.\\n     *\\n     * @param a the array to be sorted\\n     * @param fromIndex the index of the first element (inclusive) to be\\n     *        sorted\\n     * @param toIndex the index of the last element (exclusive) to be sorted\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex} or\\n     *         (optional) if the natural ordering of the array elements is\\n     *         found to violate the {@link Comparable} contract\\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex \u003c 0} or\\n     *         {@code toIndex \u003e a.length}\\n     * @throws ClassCastException if the array contains elements that are\\n     *         not \u003ci\u003emutually comparable\u003c/i\u003e (for example, strings and\\n     *         integers).\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static void mergeSort(Object[] src, Object[] dest, int low, int high, int off)", "label": "private static void mergeSort(Object[] src, Object[] dest, int low, int high, int off)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Src is the source array that starts at index 0\\n     * Dest is the (possibly larger) array destination with a possible offset\\n     * low is the index in dest to start sorting\\n     * high is the end index in dest to end sorting\\n     * off is the offset to generate corresponding low, high in src\\n     * To be removed in a future release.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static void swap(Object[] x, int a, int b)", "label": "private static void swap(Object[] x, int a, int b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Swaps x[a] with x[b].\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void sort(T[] a, Comparator\u003c? super T\u003e c)", "label": "public static void sort(T[] a, Comparator\u003c? super T\u003e c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified array of objects according to the order induced by\\n     * the specified comparator.  All elements in the array must be\\n     * \u003ci\u003emutually comparable\u003c/i\u003e by the specified comparator (that is,\\n     * {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}\\n     * for any elements {@code e1} and {@code e2} in the array).\\n     *\\n     * \u003cp\u003eThis sort is guaranteed to be \u003ci\u003estable\u003c/i\u003e:  equal elements will\\n     * not be reordered as a result of the sort.\\n     *\\n     * \u003cp\u003eImplementation note: This implementation is a stable, adaptive,\\n     * iterative mergesort that requires far fewer than n lg(n) comparisons\\n     * when the input array is partially sorted, while offering the\\n     * performance of a traditional mergesort when the input array is\\n     * randomly ordered.  If the input array is nearly sorted, the\\n     * implementation requires approximately n comparisons.  Temporary\\n     * storage requirements vary from a small constant for nearly sorted\\n     * input arrays to n/2 object references for randomly ordered input\\n     * arrays.\\n     *\\n     * \u003cp\u003eThe implementation takes equal advantage of ascending and\\n     * descending order in its input array, and can take advantage of\\n     * ascending and descending order in different parts of the same\\n     * input array.  It is well-suited to merging two or more sorted arrays:\\n     * simply concatenate the arrays and sort the resulting array.\\n     *\\n     * \u003cp\u003eThe implementation was adapted from Tim Peters\\\u0027s list sort for Python\\n     * (\u003ca href=\"http://svn.python.org/projects/python/trunk/Objects/listsort.txt\"\u003e\\n     * TimSort\u003c/a\u003e).  It uses techniques from Peter McIlroy\\\u0027s \"Optimistic\\n     * Sorting and Information Theoretic Complexity\", in Proceedings of the\\n     * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,\\n     * January 1993.\\n     *\\n     * @param \u003cT\u003e the class of the objects to be sorted\\n     * @param a the array to be sorted\\n     * @param c the comparator to determine the order of the array.  A\\n     *        {@code null} value indicates that the elements\\\u0027\\n     *        {@linkplain Comparable natural ordering} should be used.\\n     * @throws ClassCastException if the array contains elements that are\\n     *         not \u003ci\u003emutually comparable\u003c/i\u003e using the specified comparator\\n     * @throws IllegalArgumentException (optional) if the comparator is\\n     *         found to violate the {@link Comparator} contract\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void sort(T[] a, int fromIndex, int toIndex, Comparator\u003c? super T\u003e c)", "label": "public static void sort(T[] a, int fromIndex, int toIndex, Comparator\u003c? super T\u003e c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts the specified range of the specified array of objects according\\n     * to the order induced by the specified comparator.  The range to be\\n     * sorted extends from index {@code fromIndex}, inclusive, to index\\n     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\\n     * range to be sorted is empty.)  All elements in the range must be\\n     * \u003ci\u003emutually comparable\u003c/i\u003e by the specified comparator (that is,\\n     * {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}\\n     * for any elements {@code e1} and {@code e2} in the range).\\n     *\\n     * \u003cp\u003eThis sort is guaranteed to be \u003ci\u003estable\u003c/i\u003e:  equal elements will\\n     * not be reordered as a result of the sort.\\n     *\\n     * \u003cp\u003eImplementation note: This implementation is a stable, adaptive,\\n     * iterative mergesort that requires far fewer than n lg(n) comparisons\\n     * when the input array is partially sorted, while offering the\\n     * performance of a traditional mergesort when the input array is\\n     * randomly ordered.  If the input array is nearly sorted, the\\n     * implementation requires approximately n comparisons.  Temporary\\n     * storage requirements vary from a small constant for nearly sorted\\n     * input arrays to n/2 object references for randomly ordered input\\n     * arrays.\\n     *\\n     * \u003cp\u003eThe implementation takes equal advantage of ascending and\\n     * descending order in its input array, and can take advantage of\\n     * ascending and descending order in different parts of the same\\n     * input array.  It is well-suited to merging two or more sorted arrays:\\n     * simply concatenate the arrays and sort the resulting array.\\n     *\\n     * \u003cp\u003eThe implementation was adapted from Tim Peters\\\u0027s list sort for Python\\n     * (\u003ca href=\"http://svn.python.org/projects/python/trunk/Objects/listsort.txt\"\u003e\\n     * TimSort\u003c/a\u003e).  It uses techniques from Peter McIlroy\\\u0027s \"Optimistic\\n     * Sorting and Information Theoretic Complexity\", in Proceedings of the\\n     * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,\\n     * January 1993.\\n     *\\n     * @param \u003cT\u003e the class of the objects to be sorted\\n     * @param a the array to be sorted\\n     * @param fromIndex the index of the first element (inclusive) to be\\n     *        sorted\\n     * @param toIndex the index of the last element (exclusive) to be sorted\\n     * @param c the comparator to determine the order of the array.  A\\n     *        {@code null} value indicates that the elements\\\u0027\\n     *        {@linkplain Comparable natural ordering} should be used.\\n     * @throws ClassCastException if the array contains elements that are not\\n     *         \u003ci\u003emutually comparable\u003c/i\u003e using the specified comparator.\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex} or\\n     *         (optional) if the comparator is found to violate the\\n     *         {@link Comparator} contract\\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex \u003c 0} or\\n     *         {@code toIndex \u003e a.length}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void parallelPrefix(T[] array, BinaryOperator\u003cT\u003e op)", "label": "public static void parallelPrefix(T[] array, BinaryOperator\u003cT\u003e op)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Cumulates, in parallel, each element of the given array in place,\\n     * using the supplied function. For example if the array initially\\n     * holds {@code [2, 1, 0, 3]} and the operation performs addition,\\n     * then upon return the array holds {@code [2, 3, 3, 6]}.\\n     * Parallel prefix computation is usually more efficient than\\n     * sequential loops for large arrays.\\n     *\\n     * @param \u003cT\u003e the class of the objects in the array\\n     * @param array the array, which is modified in-place by this method\\n     * @param op a side-effect-free, associative function to perform the\\n     * cumulation\\n     * @throws NullPointerException if the specified array or function is null\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void parallelPrefix(T[] array, int fromIndex, int toIndex, BinaryOperator\u003cT\u003e op)", "label": "public static void parallelPrefix(T[] array, int fromIndex, int toIndex, BinaryOperator\u003cT\u003e op)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs {@link #parallelPrefix(Object[], BinaryOperator)}\\n     * for the given subrange of the array.\\n     *\\n     * @param \u003cT\u003e the class of the objects in the array\\n     * @param array the array\\n     * @param fromIndex the index of the first element, inclusive\\n     * @param toIndex the index of the last element, exclusive\\n     * @param op a side-effect-free, associative function to perform the\\n     * cumulation\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *     if {@code fromIndex \u003c 0} or {@code toIndex \u003e array.length}\\n     * @throws NullPointerException if the specified array or function is null\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "parallelPrefix(Object", "label": "parallelPrefix(Object", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static void parallelPrefix(long[] array, LongBinaryOperator op)", "label": "public static void parallelPrefix(long[] array, LongBinaryOperator op)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Cumulates, in parallel, each element of the given array in place,\\n     * using the supplied function. For example if the array initially\\n     * holds {@code [2, 1, 0, 3]} and the operation performs addition,\\n     * then upon return the array holds {@code [2, 3, 3, 6]}.\\n     * Parallel prefix computation is usually more efficient than\\n     * sequential loops for large arrays.\\n     *\\n     * @param array the array, which is modified in-place by this method\\n     * @param op a side-effect-free, associative function to perform the\\n     * cumulation\\n     * @throws NullPointerException if the specified array or function is null\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void parallelPrefix(long[] array, int fromIndex, int toIndex, LongBinaryOperator op)", "label": "public static void parallelPrefix(long[] array, int fromIndex, int toIndex, LongBinaryOperator op)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs {@link #parallelPrefix(long[], LongBinaryOperator)}\\n     * for the given subrange of the array.\\n     *\\n     * @param array the array\\n     * @param fromIndex the index of the first element, inclusive\\n     * @param toIndex the index of the last element, exclusive\\n     * @param op a side-effect-free, associative function to perform the\\n     * cumulation\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *     if {@code fromIndex \u003c 0} or {@code toIndex \u003e array.length}\\n     * @throws NullPointerException if the specified array or function is null\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "parallelPrefix(long", "label": "parallelPrefix(long", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static void parallelPrefix(double[] array, DoubleBinaryOperator op)", "label": "public static void parallelPrefix(double[] array, DoubleBinaryOperator op)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Cumulates, in parallel, each element of the given array in place,\\n     * using the supplied function. For example if the array initially\\n     * holds {@code [2.0, 1.0, 0.0, 3.0]} and the operation performs addition,\\n     * then upon return the array holds {@code [2.0, 3.0, 3.0, 6.0]}.\\n     * Parallel prefix computation is usually more efficient than\\n     * sequential loops for large arrays.\\n     *\\n     * \u003cp\u003e Because floating-point operations may not be strictly associative,\\n     * the returned result may not be identical to the value that would be\\n     * obtained if the operation was performed sequentially.\\n     *\\n     * @param array the array, which is modified in-place by this method\\n     * @param op a side-effect-free function to perform the cumulation\\n     * @throws NullPointerException if the specified array or function is null\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void parallelPrefix(double[] array, int fromIndex, int toIndex, DoubleBinaryOperator op)", "label": "public static void parallelPrefix(double[] array, int fromIndex, int toIndex, DoubleBinaryOperator op)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs {@link #parallelPrefix(double[], DoubleBinaryOperator)}\\n     * for the given subrange of the array.\\n     *\\n     * @param array the array\\n     * @param fromIndex the index of the first element, inclusive\\n     * @param toIndex the index of the last element, exclusive\\n     * @param op a side-effect-free, associative function to perform the\\n     * cumulation\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *     if {@code fromIndex \u003c 0} or {@code toIndex \u003e array.length}\\n     * @throws NullPointerException if the specified array or function is null\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "parallelPrefix(double", "label": "parallelPrefix(double", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static void parallelPrefix(int[] array, IntBinaryOperator op)", "label": "public static void parallelPrefix(int[] array, IntBinaryOperator op)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Cumulates, in parallel, each element of the given array in place,\\n     * using the supplied function. For example if the array initially\\n     * holds {@code [2, 1, 0, 3]} and the operation performs addition,\\n     * then upon return the array holds {@code [2, 3, 3, 6]}.\\n     * Parallel prefix computation is usually more efficient than\\n     * sequential loops for large arrays.\\n     *\\n     * @param array the array, which is modified in-place by this method\\n     * @param op a side-effect-free, associative function to perform the\\n     * cumulation\\n     * @throws NullPointerException if the specified array or function is null\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void parallelPrefix(int[] array, int fromIndex, int toIndex, IntBinaryOperator op)", "label": "public static void parallelPrefix(int[] array, int fromIndex, int toIndex, IntBinaryOperator op)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs {@link #parallelPrefix(int[], IntBinaryOperator)}\\n     * for the given subrange of the array.\\n     *\\n     * @param array the array\\n     * @param fromIndex the index of the first element, inclusive\\n     * @param toIndex the index of the last element, exclusive\\n     * @param op a side-effect-free, associative function to perform the\\n     * cumulation\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *     if {@code fromIndex \u003c 0} or {@code toIndex \u003e array.length}\\n     * @throws NullPointerException if the specified array or function is null\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "parallelPrefix(int", "label": "parallelPrefix(int", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int binarySearch(long[] a, long key)", "label": "public static int binarySearch(long[] a, long key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Searches the specified array of longs for the specified value using the\\n     * binary search algorithm.  The array must be sorted (as\\n     * by the {@link #sort(long[])} method) prior to making this call.  If it\\n     * is not sorted, the results are undefined.  If the array contains\\n     * multiple elements with the specified value, there is no guarantee which\\n     * one will be found.\\n     *\\n     * @param a the array to be searched\\n     * @param key the value to be searched for\\n     * @return index of the search key, if it is contained in the array;\\n     *         otherwise, \u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e.  The\\n     *         \u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the\\n     *         key would be inserted into the array: the index of the first\\n     *         element greater than the key, or {@code a.length} if all\\n     *         elements in the array are less than the specified key.  Note\\n     *         that this guarantees that the return value will be \u0026gt;= 0 if\\n     *         and only if the key is found.\\n     \u0027}"}, {"color": "#97c2fc", "id": "sort(long", "label": "sort(long", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int binarySearch(long[] a, int fromIndex, int toIndex, long key)", "label": "public static int binarySearch(long[] a, int fromIndex, int toIndex, long key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Searches a range of\\n     * the specified array of longs for the specified value using the\\n     * binary search algorithm.\\n     * The range must be sorted (as\\n     * by the {@link #sort(long[], int, int)} method)\\n     * prior to making this call.  If it\\n     * is not sorted, the results are undefined.  If the range contains\\n     * multiple elements with the specified value, there is no guarantee which\\n     * one will be found.\\n     *\\n     * @param a the array to be searched\\n     * @param fromIndex the index of the first element (inclusive) to be\\n     *          searched\\n     * @param toIndex the index of the last element (exclusive) to be searched\\n     * @param key the value to be searched for\\n     * @return index of the search key, if it is contained in the array\\n     *         within the specified range;\\n     *         otherwise, \u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e.  The\\n     *         \u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the\\n     *         key would be inserted into the array: the index of the first\\n     *         element in the range greater than the key,\\n     *         or {@code toIndex} if all\\n     *         elements in the range are less than the specified key.  Note\\n     *         that this guarantees that the return value will be \u0026gt;= 0 if\\n     *         and only if the key is found.\\n     * @throws IllegalArgumentException\\n     *         if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code fromIndex \u003c 0 or toIndex \u003e a.length}\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static int binarySearch0(long[] a, int fromIndex, int toIndex, long key)", "label": "private static int binarySearch0(long[] a, int fromIndex, int toIndex, long key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Like public version, but without range checks.\u0027}"}, {"color": "#97c2fc", "id": "public static int binarySearch(int[] a, int key)", "label": "public static int binarySearch(int[] a, int key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Searches the specified array of ints for the specified value using the\\n     * binary search algorithm.  The array must be sorted (as\\n     * by the {@link #sort(int[])} method) prior to making this call.  If it\\n     * is not sorted, the results are undefined.  If the array contains\\n     * multiple elements with the specified value, there is no guarantee which\\n     * one will be found.\\n     *\\n     * @param a the array to be searched\\n     * @param key the value to be searched for\\n     * @return index of the search key, if it is contained in the array;\\n     *         otherwise, \u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e.  The\\n     *         \u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the\\n     *         key would be inserted into the array: the index of the first\\n     *         element greater than the key, or {@code a.length} if all\\n     *         elements in the array are less than the specified key.  Note\\n     *         that this guarantees that the return value will be \u0026gt;= 0 if\\n     *         and only if the key is found.\\n     \u0027}"}, {"color": "#97c2fc", "id": "sort(int", "label": "sort(int", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int binarySearch(int[] a, int fromIndex, int toIndex, int key)", "label": "public static int binarySearch(int[] a, int fromIndex, int toIndex, int key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Searches a range of\\n     * the specified array of ints for the specified value using the\\n     * binary search algorithm.\\n     * The range must be sorted (as\\n     * by the {@link #sort(int[], int, int)} method)\\n     * prior to making this call.  If it\\n     * is not sorted, the results are undefined.  If the range contains\\n     * multiple elements with the specified value, there is no guarantee which\\n     * one will be found.\\n     *\\n     * @param a the array to be searched\\n     * @param fromIndex the index of the first element (inclusive) to be\\n     *          searched\\n     * @param toIndex the index of the last element (exclusive) to be searched\\n     * @param key the value to be searched for\\n     * @return index of the search key, if it is contained in the array\\n     *         within the specified range;\\n     *         otherwise, \u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e.  The\\n     *         \u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the\\n     *         key would be inserted into the array: the index of the first\\n     *         element in the range greater than the key,\\n     *         or {@code toIndex} if all\\n     *         elements in the range are less than the specified key.  Note\\n     *         that this guarantees that the return value will be \u0026gt;= 0 if\\n     *         and only if the key is found.\\n     * @throws IllegalArgumentException\\n     *         if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code fromIndex \u003c 0 or toIndex \u003e a.length}\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static int binarySearch0(int[] a, int fromIndex, int toIndex, int key)", "label": "private static int binarySearch0(int[] a, int fromIndex, int toIndex, int key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Like public version, but without range checks.\u0027}"}, {"color": "#97c2fc", "id": "public static int binarySearch(short[] a, short key)", "label": "public static int binarySearch(short[] a, short key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Searches the specified array of shorts for the specified value using\\n     * the binary search algorithm.  The array must be sorted\\n     * (as by the {@link #sort(short[])} method) prior to making this call.  If\\n     * it is not sorted, the results are undefined.  If the array contains\\n     * multiple elements with the specified value, there is no guarantee which\\n     * one will be found.\\n     *\\n     * @param a the array to be searched\\n     * @param key the value to be searched for\\n     * @return index of the search key, if it is contained in the array;\\n     *         otherwise, \u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e.  The\\n     *         \u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the\\n     *         key would be inserted into the array: the index of the first\\n     *         element greater than the key, or {@code a.length} if all\\n     *         elements in the array are less than the specified key.  Note\\n     *         that this guarantees that the return value will be \u0026gt;= 0 if\\n     *         and only if the key is found.\\n     \u0027}"}, {"color": "#97c2fc", "id": "sort(short", "label": "sort(short", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int binarySearch(short[] a, int fromIndex, int toIndex, short key)", "label": "public static int binarySearch(short[] a, int fromIndex, int toIndex, short key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Searches a range of\\n     * the specified array of shorts for the specified value using\\n     * the binary search algorithm.\\n     * The range must be sorted\\n     * (as by the {@link #sort(short[], int, int)} method)\\n     * prior to making this call.  If\\n     * it is not sorted, the results are undefined.  If the range contains\\n     * multiple elements with the specified value, there is no guarantee which\\n     * one will be found.\\n     *\\n     * @param a the array to be searched\\n     * @param fromIndex the index of the first element (inclusive) to be\\n     *          searched\\n     * @param toIndex the index of the last element (exclusive) to be searched\\n     * @param key the value to be searched for\\n     * @return index of the search key, if it is contained in the array\\n     *         within the specified range;\\n     *         otherwise, \u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e.  The\\n     *         \u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the\\n     *         key would be inserted into the array: the index of the first\\n     *         element in the range greater than the key,\\n     *         or {@code toIndex} if all\\n     *         elements in the range are less than the specified key.  Note\\n     *         that this guarantees that the return value will be \u0026gt;= 0 if\\n     *         and only if the key is found.\\n     * @throws IllegalArgumentException\\n     *         if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code fromIndex \u003c 0 or toIndex \u003e a.length}\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static int binarySearch0(short[] a, int fromIndex, int toIndex, short key)", "label": "private static int binarySearch0(short[] a, int fromIndex, int toIndex, short key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Like public version, but without range checks.\u0027}"}, {"color": "#97c2fc", "id": "public static int binarySearch(char[] a, char key)", "label": "public static int binarySearch(char[] a, char key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Searches the specified array of chars for the specified value using the\\n     * binary search algorithm.  The array must be sorted (as\\n     * by the {@link #sort(char[])} method) prior to making this call.  If it\\n     * is not sorted, the results are undefined.  If the array contains\\n     * multiple elements with the specified value, there is no guarantee which\\n     * one will be found.\\n     *\\n     * @param a the array to be searched\\n     * @param key the value to be searched for\\n     * @return index of the search key, if it is contained in the array;\\n     *         otherwise, \u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e.  The\\n     *         \u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the\\n     *         key would be inserted into the array: the index of the first\\n     *         element greater than the key, or {@code a.length} if all\\n     *         elements in the array are less than the specified key.  Note\\n     *         that this guarantees that the return value will be \u0026gt;= 0 if\\n     *         and only if the key is found.\\n     \u0027}"}, {"color": "#97c2fc", "id": "sort(char", "label": "sort(char", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int binarySearch(char[] a, int fromIndex, int toIndex, char key)", "label": "public static int binarySearch(char[] a, int fromIndex, int toIndex, char key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Searches a range of\\n     * the specified array of chars for the specified value using the\\n     * binary search algorithm.\\n     * The range must be sorted (as\\n     * by the {@link #sort(char[], int, int)} method)\\n     * prior to making this call.  If it\\n     * is not sorted, the results are undefined.  If the range contains\\n     * multiple elements with the specified value, there is no guarantee which\\n     * one will be found.\\n     *\\n     * @param a the array to be searched\\n     * @param fromIndex the index of the first element (inclusive) to be\\n     *          searched\\n     * @param toIndex the index of the last element (exclusive) to be searched\\n     * @param key the value to be searched for\\n     * @return index of the search key, if it is contained in the array\\n     *         within the specified range;\\n     *         otherwise, \u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e.  The\\n     *         \u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the\\n     *         key would be inserted into the array: the index of the first\\n     *         element in the range greater than the key,\\n     *         or {@code toIndex} if all\\n     *         elements in the range are less than the specified key.  Note\\n     *         that this guarantees that the return value will be \u0026gt;= 0 if\\n     *         and only if the key is found.\\n     * @throws IllegalArgumentException\\n     *         if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code fromIndex \u003c 0 or toIndex \u003e a.length}\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static int binarySearch0(char[] a, int fromIndex, int toIndex, char key)", "label": "private static int binarySearch0(char[] a, int fromIndex, int toIndex, char key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Like public version, but without range checks.\u0027}"}, {"color": "#97c2fc", "id": "public static int binarySearch(byte[] a, byte key)", "label": "public static int binarySearch(byte[] a, byte key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Searches the specified array of bytes for the specified value using the\\n     * binary search algorithm.  The array must be sorted (as\\n     * by the {@link #sort(byte[])} method) prior to making this call.  If it\\n     * is not sorted, the results are undefined.  If the array contains\\n     * multiple elements with the specified value, there is no guarantee which\\n     * one will be found.\\n     *\\n     * @param a the array to be searched\\n     * @param key the value to be searched for\\n     * @return index of the search key, if it is contained in the array;\\n     *         otherwise, \u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e.  The\\n     *         \u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the\\n     *         key would be inserted into the array: the index of the first\\n     *         element greater than the key, or {@code a.length} if all\\n     *         elements in the array are less than the specified key.  Note\\n     *         that this guarantees that the return value will be \u0026gt;= 0 if\\n     *         and only if the key is found.\\n     \u0027}"}, {"color": "#97c2fc", "id": "sort(byte", "label": "sort(byte", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int binarySearch(byte[] a, int fromIndex, int toIndex, byte key)", "label": "public static int binarySearch(byte[] a, int fromIndex, int toIndex, byte key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Searches a range of\\n     * the specified array of bytes for the specified value using the\\n     * binary search algorithm.\\n     * The range must be sorted (as\\n     * by the {@link #sort(byte[], int, int)} method)\\n     * prior to making this call.  If it\\n     * is not sorted, the results are undefined.  If the range contains\\n     * multiple elements with the specified value, there is no guarantee which\\n     * one will be found.\\n     *\\n     * @param a the array to be searched\\n     * @param fromIndex the index of the first element (inclusive) to be\\n     *          searched\\n     * @param toIndex the index of the last element (exclusive) to be searched\\n     * @param key the value to be searched for\\n     * @return index of the search key, if it is contained in the array\\n     *         within the specified range;\\n     *         otherwise, \u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e.  The\\n     *         \u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the\\n     *         key would be inserted into the array: the index of the first\\n     *         element in the range greater than the key,\\n     *         or {@code toIndex} if all\\n     *         elements in the range are less than the specified key.  Note\\n     *         that this guarantees that the return value will be \u0026gt;= 0 if\\n     *         and only if the key is found.\\n     * @throws IllegalArgumentException\\n     *         if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code fromIndex \u003c 0 or toIndex \u003e a.length}\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static int binarySearch0(byte[] a, int fromIndex, int toIndex, byte key)", "label": "private static int binarySearch0(byte[] a, int fromIndex, int toIndex, byte key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Like public version, but without range checks.\u0027}"}, {"color": "#97c2fc", "id": "public static int binarySearch(double[] a, double key)", "label": "public static int binarySearch(double[] a, double key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Searches the specified array of doubles for the specified value using\\n     * the binary search algorithm.  The array must be sorted\\n     * (as by the {@link #sort(double[])} method) prior to making this call.\\n     * If it is not sorted, the results are undefined.  If the array contains\\n     * multiple elements with the specified value, there is no guarantee which\\n     * one will be found.  This method considers all NaN values to be\\n     * equivalent and equal.\\n     *\\n     * @param a the array to be searched\\n     * @param key the value to be searched for\\n     * @return index of the search key, if it is contained in the array;\\n     *         otherwise, \u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e.  The\\n     *         \u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the\\n     *         key would be inserted into the array: the index of the first\\n     *         element greater than the key, or {@code a.length} if all\\n     *         elements in the array are less than the specified key.  Note\\n     *         that this guarantees that the return value will be \u0026gt;= 0 if\\n     *         and only if the key is found.\\n     \u0027}"}, {"color": "#97c2fc", "id": "sort(double", "label": "sort(double", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int binarySearch(double[] a, int fromIndex, int toIndex, double key)", "label": "public static int binarySearch(double[] a, int fromIndex, int toIndex, double key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Searches a range of\\n     * the specified array of doubles for the specified value using\\n     * the binary search algorithm.\\n     * The range must be sorted\\n     * (as by the {@link #sort(double[], int, int)} method)\\n     * prior to making this call.\\n     * If it is not sorted, the results are undefined.  If the range contains\\n     * multiple elements with the specified value, there is no guarantee which\\n     * one will be found.  This method considers all NaN values to be\\n     * equivalent and equal.\\n     *\\n     * @param a the array to be searched\\n     * @param fromIndex the index of the first element (inclusive) to be\\n     *          searched\\n     * @param toIndex the index of the last element (exclusive) to be searched\\n     * @param key the value to be searched for\\n     * @return index of the search key, if it is contained in the array\\n     *         within the specified range;\\n     *         otherwise, \u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e.  The\\n     *         \u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the\\n     *         key would be inserted into the array: the index of the first\\n     *         element in the range greater than the key,\\n     *         or {@code toIndex} if all\\n     *         elements in the range are less than the specified key.  Note\\n     *         that this guarantees that the return value will be \u0026gt;= 0 if\\n     *         and only if the key is found.\\n     * @throws IllegalArgumentException\\n     *         if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code fromIndex \u003c 0 or toIndex \u003e a.length}\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static int binarySearch0(double[] a, int fromIndex, int toIndex, double key)", "label": "private static int binarySearch0(double[] a, int fromIndex, int toIndex, double key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Like public version, but without range checks.\u0027}"}, {"color": "#97c2fc", "id": "public static int binarySearch(float[] a, float key)", "label": "public static int binarySearch(float[] a, float key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Searches the specified array of floats for the specified value using\\n     * the binary search algorithm. The array must be sorted\\n     * (as by the {@link #sort(float[])} method) prior to making this call. If\\n     * it is not sorted, the results are undefined. If the array contains\\n     * multiple elements with the specified value, there is no guarantee which\\n     * one will be found. This method considers all NaN values to be\\n     * equivalent and equal.\\n     *\\n     * @param a the array to be searched\\n     * @param key the value to be searched for\\n     * @return index of the search key, if it is contained in the array;\\n     *         otherwise, \u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e. The\\n     *         \u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the\\n     *         key would be inserted into the array: the index of the first\\n     *         element greater than the key, or {@code a.length} if all\\n     *         elements in the array are less than the specified key. Note\\n     *         that this guarantees that the return value will be \u0026gt;= 0 if\\n     *         and only if the key is found.\\n     \u0027}"}, {"color": "#97c2fc", "id": "sort(float", "label": "sort(float", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int binarySearch(float[] a, int fromIndex, int toIndex, float key)", "label": "public static int binarySearch(float[] a, int fromIndex, int toIndex, float key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Searches a range of\\n     * the specified array of floats for the specified value using\\n     * the binary search algorithm.\\n     * The range must be sorted\\n     * (as by the {@link #sort(float[], int, int)} method)\\n     * prior to making this call. If\\n     * it is not sorted, the results are undefined. If the range contains\\n     * multiple elements with the specified value, there is no guarantee which\\n     * one will be found. This method considers all NaN values to be\\n     * equivalent and equal.\\n     *\\n     * @param a the array to be searched\\n     * @param fromIndex the index of the first element (inclusive) to be\\n     *          searched\\n     * @param toIndex the index of the last element (exclusive) to be searched\\n     * @param key the value to be searched for\\n     * @return index of the search key, if it is contained in the array\\n     *         within the specified range;\\n     *         otherwise, \u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e. The\\n     *         \u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the\\n     *         key would be inserted into the array: the index of the first\\n     *         element in the range greater than the key,\\n     *         or {@code toIndex} if all\\n     *         elements in the range are less than the specified key. Note\\n     *         that this guarantees that the return value will be \u0026gt;= 0 if\\n     *         and only if the key is found.\\n     * @throws IllegalArgumentException\\n     *         if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code fromIndex \u003c 0 or toIndex \u003e a.length}\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static int binarySearch0(float[] a, int fromIndex, int toIndex, float key)", "label": "private static int binarySearch0(float[] a, int fromIndex, int toIndex, float key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Like public version, but without range checks.\u0027}"}, {"color": "#97c2fc", "id": "public static int binarySearch(Object[] a, Object key)", "label": "public static int binarySearch(Object[] a, Object key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Searches the specified array for the specified object using the binary\\n     * search algorithm. The array must be sorted into ascending order\\n     * according to the\\n     * {@linkplain Comparable natural ordering}\\n     * of its elements (as by the\\n     * {@link #sort(Object[])} method) prior to making this call.\\n     * If it is not sorted, the results are undefined.\\n     * (If the array contains elements that are not mutually comparable (for\\n     * example, strings and integers), it \u003ci\u003ecannot\u003c/i\u003e be sorted according\\n     * to the natural ordering of its elements, hence results are undefined.)\\n     * If the array contains multiple\\n     * elements equal to the specified object, there is no guarantee which\\n     * one will be found.\\n     *\\n     * @param a the array to be searched\\n     * @param key the value to be searched for\\n     * @return index of the search key, if it is contained in the array;\\n     *         otherwise, \u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e.  The\\n     *         \u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the\\n     *         key would be inserted into the array: the index of the first\\n     *         element greater than the key, or {@code a.length} if all\\n     *         elements in the array are less than the specified key.  Note\\n     *         that this guarantees that the return value will be \u0026gt;= 0 if\\n     *         and only if the key is found.\\n     * @throws ClassCastException if the search key is not comparable to the\\n     *         elements of the array.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int binarySearch(Object[] a, int fromIndex, int toIndex, Object key)", "label": "public static int binarySearch(Object[] a, int fromIndex, int toIndex, Object key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Searches a range of\\n     * the specified array for the specified object using the binary\\n     * search algorithm.\\n     * The range must be sorted into ascending order\\n     * according to the\\n     * {@linkplain Comparable natural ordering}\\n     * of its elements (as by the\\n     * {@link #sort(Object[], int, int)} method) prior to making this\\n     * call.  If it is not sorted, the results are undefined.\\n     * (If the range contains elements that are not mutually comparable (for\\n     * example, strings and integers), it \u003ci\u003ecannot\u003c/i\u003e be sorted according\\n     * to the natural ordering of its elements, hence results are undefined.)\\n     * If the range contains multiple\\n     * elements equal to the specified object, there is no guarantee which\\n     * one will be found.\\n     *\\n     * @param a the array to be searched\\n     * @param fromIndex the index of the first element (inclusive) to be\\n     *          searched\\n     * @param toIndex the index of the last element (exclusive) to be searched\\n     * @param key the value to be searched for\\n     * @return index of the search key, if it is contained in the array\\n     *         within the specified range;\\n     *         otherwise, \u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e.  The\\n     *         \u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the\\n     *         key would be inserted into the array: the index of the first\\n     *         element in the range greater than the key,\\n     *         or {@code toIndex} if all\\n     *         elements in the range are less than the specified key.  Note\\n     *         that this guarantees that the return value will be \u0026gt;= 0 if\\n     *         and only if the key is found.\\n     * @throws ClassCastException if the search key is not comparable to the\\n     *         elements of the array within the specified range.\\n     * @throws IllegalArgumentException\\n     *         if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code fromIndex \u003c 0 or toIndex \u003e a.length}\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static int binarySearch0(Object[] a, int fromIndex, int toIndex, Object key)", "label": "private static int binarySearch0(Object[] a, int fromIndex, int toIndex, Object key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Like public version, but without range checks.\u0027}"}, {"color": "#97c2fc", "id": "public static int binarySearch(T[] a, T key, Comparator\u003c? super T\u003e c)", "label": "public static int binarySearch(T[] a, T key, Comparator\u003c? super T\u003e c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Searches the specified array for the specified object using the binary\\n     * search algorithm.  The array must be sorted into ascending order\\n     * according to the specified comparator (as by the\\n     * {@link #sort(Object[], Comparator) sort(T[], Comparator)}\\n     * method) prior to making this call.  If it is\\n     * not sorted, the results are undefined.\\n     * If the array contains multiple\\n     * elements equal to the specified object, there is no guarantee which one\\n     * will be found.\\n     *\\n     * @param \u003cT\u003e the class of the objects in the array\\n     * @param a the array to be searched\\n     * @param key the value to be searched for\\n     * @param c the comparator by which the array is ordered.  A\\n     *        {@code null} value indicates that the elements\u0027\\n     *        {@linkplain Comparable natural ordering} should be used.\\n     * @return index of the search key, if it is contained in the array;\\n     *         otherwise, \u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e.  The\\n     *         \u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the\\n     *         key would be inserted into the array: the index of the first\\n     *         element greater than the key, or {@code a.length} if all\\n     *         elements in the array are less than the specified key.  Note\\n     *         that this guarantees that the return value will be \u0026gt;= 0 if\\n     *         and only if the key is found.\\n     * @throws ClassCastException if the array contains elements that are not\\n     *         \u003ci\u003emutually comparable\u003c/i\u003e using the specified comparator,\\n     *         or the search key is not comparable to the\\n     *         elements of the array using this comparator.\\n     \"}"}, {"color": "#97c2fc", "id": "public static int binarySearch(T[] a, int fromIndex, int toIndex, T key, Comparator\u003c? super T\u003e c)", "label": "public static int binarySearch(T[] a, int fromIndex, int toIndex, T key, Comparator\u003c? super T\u003e c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Searches a range of\\n     * the specified array for the specified object using the binary\\n     * search algorithm.\\n     * The range must be sorted into ascending order\\n     * according to the specified comparator (as by the\\n     * {@link #sort(Object[], int, int, Comparator)\\n     * sort(T[], int, int, Comparator)}\\n     * method) prior to making this call.\\n     * If it is not sorted, the results are undefined.\\n     * If the range contains multiple elements equal to the specified object,\\n     * there is no guarantee which one will be found.\\n     *\\n     * @param \u003cT\u003e the class of the objects in the array\\n     * @param a the array to be searched\\n     * @param fromIndex the index of the first element (inclusive) to be\\n     *          searched\\n     * @param toIndex the index of the last element (exclusive) to be searched\\n     * @param key the value to be searched for\\n     * @param c the comparator by which the array is ordered.  A\\n     *        {@code null} value indicates that the elements\u0027\\n     *        {@linkplain Comparable natural ordering} should be used.\\n     * @return index of the search key, if it is contained in the array\\n     *         within the specified range;\\n     *         otherwise, \u003ccode\u003e(-(\u003ci\u003einsertion point\u003c/i\u003e) - 1)\u003c/code\u003e.  The\\n     *         \u003ci\u003einsertion point\u003c/i\u003e is defined as the point at which the\\n     *         key would be inserted into the array: the index of the first\\n     *         element in the range greater than the key,\\n     *         or {@code toIndex} if all\\n     *         elements in the range are less than the specified key.  Note\\n     *         that this guarantees that the return value will be \u0026gt;= 0 if\\n     *         and only if the key is found.\\n     * @throws ClassCastException if the range contains elements that are not\\n     *         \u003ci\u003emutually comparable\u003c/i\u003e using the specified comparator,\\n     *         or the search key is not comparable to the\\n     *         elements in the range using this comparator.\\n     * @throws IllegalArgumentException\\n     *         if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code fromIndex \u003c 0 or toIndex \u003e a.length}\\n     * @since 1.6\\n     \"}"}, {"color": "#97c2fc", "id": "private static int binarySearch0(T[] a, int fromIndex, int toIndex, T key, Comparator\u003c? super T\u003e c)", "label": "private static int binarySearch0(T[] a, int fromIndex, int toIndex, T key, Comparator\u003c? super T\u003e c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Like public version, but without range checks.\u0027}"}, {"color": "#97c2fc", "id": "public static boolean equals(long[] a, long[] a2)", "label": "public static boolean equals(long[] a, long[] a2)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if the two specified arrays of longs are\\n     * \u003ci\u003eequal\u003c/i\u003e to one another.  Two arrays are considered equal if both\\n     * arrays contain the same number of elements, and all corresponding pairs\\n     * of elements in the two arrays are equal.  In other words, two arrays\\n     * are equal if they contain the same elements in the same order.  Also,\\n     * two array references are considered equal if both are {@code null}.\\n     *\\n     * @param a one array to be tested for equality\\n     * @param a2 the other array to be tested for equality\\n     * @return {@code true} if the two arrays are equal\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean equals(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)", "label": "public static boolean equals(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns true if the two specified arrays of longs, over the specified\\n     * ranges, are \u003ci\u003eequal\u003c/i\u003e to one another.\\n     *\\n     * \u003cp\u003eTwo arrays are considered equal if the number of elements covered by\\n     * each range is the same, and all corresponding pairs of elements over the\\n     * specified ranges in the two arrays are equal.  In other words, two arrays\\n     * are equal if they contain, over the specified ranges, the same elements\\n     * in the same order.\\n     *\\n     * @param a the first array to be tested for equality\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be tested\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be tested\\n     * @param b the second array to be tested for equality\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be tested\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be tested\\n     * @return {@code true} if the two arrays, over the specified ranges, are\\n     *         equal\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean equals(int[] a, int[] a2)", "label": "public static boolean equals(int[] a, int[] a2)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if the two specified arrays of ints are\\n     * \u003ci\u003eequal\u003c/i\u003e to one another.  Two arrays are considered equal if both\\n     * arrays contain the same number of elements, and all corresponding pairs\\n     * of elements in the two arrays are equal.  In other words, two arrays\\n     * are equal if they contain the same elements in the same order.  Also,\\n     * two array references are considered equal if both are {@code null}.\\n     *\\n     * @param a one array to be tested for equality\\n     * @param a2 the other array to be tested for equality\\n     * @return {@code true} if the two arrays are equal\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean equals(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)", "label": "public static boolean equals(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns true if the two specified arrays of ints, over the specified\\n     * ranges, are \u003ci\u003eequal\u003c/i\u003e to one another.\\n     *\\n     * \u003cp\u003eTwo arrays are considered equal if the number of elements covered by\\n     * each range is the same, and all corresponding pairs of elements over the\\n     * specified ranges in the two arrays are equal.  In other words, two arrays\\n     * are equal if they contain, over the specified ranges, the same elements\\n     * in the same order.\\n     *\\n     * @param a the first array to be tested for equality\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be tested\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be tested\\n     * @param b the second array to be tested for equality\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be tested\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be tested\\n     * @return {@code true} if the two arrays, over the specified ranges, are\\n     *         equal\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean equals(short[] a, short[] a2)", "label": "public static boolean equals(short[] a, short[] a2)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if the two specified arrays of shorts are\\n     * \u003ci\u003eequal\u003c/i\u003e to one another.  Two arrays are considered equal if both\\n     * arrays contain the same number of elements, and all corresponding pairs\\n     * of elements in the two arrays are equal.  In other words, two arrays\\n     * are equal if they contain the same elements in the same order.  Also,\\n     * two array references are considered equal if both are {@code null}.\\n     *\\n     * @param a one array to be tested for equality\\n     * @param a2 the other array to be tested for equality\\n     * @return {@code true} if the two arrays are equal\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean equals(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)", "label": "public static boolean equals(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns true if the two specified arrays of shorts, over the specified\\n     * ranges, are \u003ci\u003eequal\u003c/i\u003e to one another.\\n     *\\n     * \u003cp\u003eTwo arrays are considered equal if the number of elements covered by\\n     * each range is the same, and all corresponding pairs of elements over the\\n     * specified ranges in the two arrays are equal.  In other words, two arrays\\n     * are equal if they contain, over the specified ranges, the same elements\\n     * in the same order.\\n     *\\n     * @param a the first array to be tested for equality\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be tested\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be tested\\n     * @param b the second array to be tested for equality\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be tested\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be tested\\n     * @return {@code true} if the two arrays, over the specified ranges, are\\n     *         equal\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean equals(char[] a, char[] a2)", "label": "public static boolean equals(char[] a, char[] a2)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if the two specified arrays of chars are\\n     * \u003ci\u003eequal\u003c/i\u003e to one another.  Two arrays are considered equal if both\\n     * arrays contain the same number of elements, and all corresponding pairs\\n     * of elements in the two arrays are equal.  In other words, two arrays\\n     * are equal if they contain the same elements in the same order.  Also,\\n     * two array references are considered equal if both are {@code null}.\\n     *\\n     * @param a one array to be tested for equality\\n     * @param a2 the other array to be tested for equality\\n     * @return {@code true} if the two arrays are equal\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean equals(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex)", "label": "public static boolean equals(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns true if the two specified arrays of chars, over the specified\\n     * ranges, are \u003ci\u003eequal\u003c/i\u003e to one another.\\n     *\\n     * \u003cp\u003eTwo arrays are considered equal if the number of elements covered by\\n     * each range is the same, and all corresponding pairs of elements over the\\n     * specified ranges in the two arrays are equal.  In other words, two arrays\\n     * are equal if they contain, over the specified ranges, the same elements\\n     * in the same order.\\n     *\\n     * @param a the first array to be tested for equality\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be tested\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be tested\\n     * @param b the second array to be tested for equality\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be tested\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be tested\\n     * @return {@code true} if the two arrays, over the specified ranges, are\\n     *         equal\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean equals(byte[] a, byte[] a2)", "label": "public static boolean equals(byte[] a, byte[] a2)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if the two specified arrays of bytes are\\n     * \u003ci\u003eequal\u003c/i\u003e to one another.  Two arrays are considered equal if both\\n     * arrays contain the same number of elements, and all corresponding pairs\\n     * of elements in the two arrays are equal.  In other words, two arrays\\n     * are equal if they contain the same elements in the same order.  Also,\\n     * two array references are considered equal if both are {@code null}.\\n     *\\n     * @param a one array to be tested for equality\\n     * @param a2 the other array to be tested for equality\\n     * @return {@code true} if the two arrays are equal\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean equals(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)", "label": "public static boolean equals(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns true if the two specified arrays of bytes, over the specified\\n     * ranges, are \u003ci\u003eequal\u003c/i\u003e to one another.\\n     *\\n     * \u003cp\u003eTwo arrays are considered equal if the number of elements covered by\\n     * each range is the same, and all corresponding pairs of elements over the\\n     * specified ranges in the two arrays are equal.  In other words, two arrays\\n     * are equal if they contain, over the specified ranges, the same elements\\n     * in the same order.\\n     *\\n     * @param a the first array to be tested for equality\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be tested\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be tested\\n     * @param b the second array to be tested for equality\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be tested\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be tested\\n     * @return {@code true} if the two arrays, over the specified ranges, are\\n     *         equal\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean equals(boolean[] a, boolean[] a2)", "label": "public static boolean equals(boolean[] a, boolean[] a2)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if the two specified arrays of booleans are\\n     * \u003ci\u003eequal\u003c/i\u003e to one another.  Two arrays are considered equal if both\\n     * arrays contain the same number of elements, and all corresponding pairs\\n     * of elements in the two arrays are equal.  In other words, two arrays\\n     * are equal if they contain the same elements in the same order.  Also,\\n     * two array references are considered equal if both are {@code null}.\\n     *\\n     * @param a one array to be tested for equality\\n     * @param a2 the other array to be tested for equality\\n     * @return {@code true} if the two arrays are equal\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean equals(boolean[] a, int aFromIndex, int aToIndex, boolean[] b, int bFromIndex, int bToIndex)", "label": "public static boolean equals(boolean[] a, int aFromIndex, int aToIndex, boolean[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns true if the two specified arrays of booleans, over the specified\\n     * ranges, are \u003ci\u003eequal\u003c/i\u003e to one another.\\n     *\\n     * \u003cp\u003eTwo arrays are considered equal if the number of elements covered by\\n     * each range is the same, and all corresponding pairs of elements over the\\n     * specified ranges in the two arrays are equal.  In other words, two arrays\\n     * are equal if they contain, over the specified ranges, the same elements\\n     * in the same order.\\n     *\\n     * @param a the first array to be tested for equality\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be tested\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be tested\\n     * @param b the second array to be tested for equality\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be tested\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be tested\\n     * @return {@code true} if the two arrays, over the specified ranges, are\\n     *         equal\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean equals(double[] a, double[] a2)", "label": "public static boolean equals(double[] a, double[] a2)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if the two specified arrays of doubles are\\n     * \u003ci\u003eequal\u003c/i\u003e to one another.  Two arrays are considered equal if both\\n     * arrays contain the same number of elements, and all corresponding pairs\\n     * of elements in the two arrays are equal.  In other words, two arrays\\n     * are equal if they contain the same elements in the same order.  Also,\\n     * two array references are considered equal if both are {@code null}.\\n     *\\n     * Two doubles {@code d1} and {@code d2} are considered equal if:\\n     * \u003cpre\u003e    {@code new Double(d1).equals(new Double(d2))}\u003c/pre\u003e\\n     * (Unlike the {@code ==} operator, this method considers\\n     * {@code NaN} equal to itself, and 0.0d unequal to -0.0d.)\\n     *\\n     * @param a one array to be tested for equality\\n     * @param a2 the other array to be tested for equality\\n     * @return {@code true} if the two arrays are equal\\n     * @see Double#equals(Object)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean equals(double[] a, int aFromIndex, int aToIndex, double[] b, int bFromIndex, int bToIndex)", "label": "public static boolean equals(double[] a, int aFromIndex, int aToIndex, double[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns true if the two specified arrays of doubles, over the specified\\n     * ranges, are \u003ci\u003eequal\u003c/i\u003e to one another.\\n     *\\n     * \u003cp\u003eTwo arrays are considered equal if the number of elements covered by\\n     * each range is the same, and all corresponding pairs of elements over the\\n     * specified ranges in the two arrays are equal.  In other words, two arrays\\n     * are equal if they contain, over the specified ranges, the same elements\\n     * in the same order.\\n     *\\n     * \u003cp\u003eTwo doubles {@code d1} and {@code d2} are considered equal if:\\n     * \u003cpre\u003e    {@code new Double(d1).equals(new Double(d2))}\u003c/pre\u003e\\n     * (Unlike the {@code ==} operator, this method considers\\n     * {@code NaN} equal to itself, and 0.0d unequal to -0.0d.)\\n     *\\n     * @param a the first array to be tested for equality\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be tested\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be tested\\n     * @param b the second array to be tested for equality\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be tested\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be tested\\n     * @return {@code true} if the two arrays, over the specified ranges, are\\n     *         equal\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @see Double#equals(Object)\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean equals(float[] a, float[] a2)", "label": "public static boolean equals(float[] a, float[] a2)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if the two specified arrays of floats are\\n     * \u003ci\u003eequal\u003c/i\u003e to one another.  Two arrays are considered equal if both\\n     * arrays contain the same number of elements, and all corresponding pairs\\n     * of elements in the two arrays are equal.  In other words, two arrays\\n     * are equal if they contain the same elements in the same order.  Also,\\n     * two array references are considered equal if both are {@code null}.\\n     *\\n     * Two floats {@code f1} and {@code f2} are considered equal if:\\n     * \u003cpre\u003e    {@code new Float(f1).equals(new Float(f2))}\u003c/pre\u003e\\n     * (Unlike the {@code ==} operator, this method considers\\n     * {@code NaN} equal to itself, and 0.0f unequal to -0.0f.)\\n     *\\n     * @param a one array to be tested for equality\\n     * @param a2 the other array to be tested for equality\\n     * @return {@code true} if the two arrays are equal\\n     * @see Float#equals(Object)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean equals(float[] a, int aFromIndex, int aToIndex, float[] b, int bFromIndex, int bToIndex)", "label": "public static boolean equals(float[] a, int aFromIndex, int aToIndex, float[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns true if the two specified arrays of floats, over the specified\\n     * ranges, are \u003ci\u003eequal\u003c/i\u003e to one another.\\n     *\\n     * \u003cp\u003eTwo arrays are considered equal if the number of elements covered by\\n     * each range is the same, and all corresponding pairs of elements over the\\n     * specified ranges in the two arrays are equal.  In other words, two arrays\\n     * are equal if they contain, over the specified ranges, the same elements\\n     * in the same order.\\n     *\\n     * \u003cp\u003eTwo floats {@code f1} and {@code f2} are considered equal if:\\n     * \u003cpre\u003e    {@code new Float(f1).equals(new Float(f2))}\u003c/pre\u003e\\n     * (Unlike the {@code ==} operator, this method considers\\n     * {@code NaN} equal to itself, and 0.0f unequal to -0.0f.)\\n     *\\n     * @param a the first array to be tested for equality\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be tested\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be tested\\n     * @param b the second array to be tested for equality\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be tested\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be tested\\n     * @return {@code true} if the two arrays, over the specified ranges, are\\n     *         equal\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @see Float#equals(Object)\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean equals(Object[] a, Object[] a2)", "label": "public static boolean equals(Object[] a, Object[] a2)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if the two specified arrays of Objects are\\n     * \u003ci\u003eequal\u003c/i\u003e to one another.  The two arrays are considered equal if\\n     * both arrays contain the same number of elements, and all corresponding\\n     * pairs of elements in the two arrays are equal.  Two objects {@code e1}\\n     * and {@code e2} are considered \u003ci\u003eequal\u003c/i\u003e if\\n     * {@code Objects.equals(e1, e2)}.\\n     * In other words, the two arrays are equal if\\n     * they contain the same elements in the same order.  Also, two array\\n     * references are considered equal if both are {@code null}.\\n     *\\n     * @param a one array to be tested for equality\\n     * @param a2 the other array to be tested for equality\\n     * @return {@code true} if the two arrays are equal\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean equals(Object[] a, int aFromIndex, int aToIndex, Object[] b, int bFromIndex, int bToIndex)", "label": "public static boolean equals(Object[] a, int aFromIndex, int aToIndex, Object[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns true if the two specified arrays of Objects, over the specified\\n     * ranges, are \u003ci\u003eequal\u003c/i\u003e to one another.\\n     *\\n     * \u003cp\u003eTwo arrays are considered equal if the number of elements covered by\\n     * each range is the same, and all corresponding pairs of elements over the\\n     * specified ranges in the two arrays are equal.  In other words, two arrays\\n     * are equal if they contain, over the specified ranges, the same elements\\n     * in the same order.\\n     *\\n     * \u003cp\u003eTwo objects {@code e1} and {@code e2} are considered \u003ci\u003eequal\u003c/i\u003e if\\n     * {@code Objects.equals(e1, e2)}.\\n     *\\n     * @param a the first array to be tested for equality\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be tested\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be tested\\n     * @param b the second array to be tested for equality\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be tested\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be tested\\n     * @return {@code true} if the two arrays, over the specified ranges, are\\n     *         equal\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean equals(T[] a, T[] a2, Comparator\u003c? super T\u003e cmp)", "label": "public static boolean equals(T[] a, T[] a2, Comparator\u003c? super T\u003e cmp)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if the two specified arrays of Objects are\\n     * \u003ci\u003eequal\u003c/i\u003e to one another.\\n     *\\n     * \u003cp\u003eTwo arrays are considered equal if both arrays contain the same number\\n     * of elements, and all corresponding pairs of elements in the two arrays\\n     * are equal.  In other words, the two arrays are equal if they contain the\\n     * same elements in the same order.  Also, two array references are\\n     * considered equal if both are {@code null}.\\n     *\\n     * \u003cp\u003eTwo objects {@code e1} and {@code e2} are considered \u003ci\u003eequal\u003c/i\u003e if,\\n     * given the specified comparator, {@code cmp.compare(e1, e2) == 0}.\\n     *\\n     * @param a one array to be tested for equality\\n     * @param a2 the other array to be tested for equality\\n     * @param cmp the comparator to compare array elements\\n     * @param \u003cT\u003e the type of array elements\\n     * @return {@code true} if the two arrays are equal\\n     * @throws NullPointerException if the comparator is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean equals(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator\u003c? super T\u003e cmp)", "label": "public static boolean equals(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator\u003c? super T\u003e cmp)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns true if the two specified arrays of Objects, over the specified\\n     * ranges, are \u003ci\u003eequal\u003c/i\u003e to one another.\\n     *\\n     * \u003cp\u003eTwo arrays are considered equal if the number of elements covered by\\n     * each range is the same, and all corresponding pairs of elements over the\\n     * specified ranges in the two arrays are equal.  In other words, two arrays\\n     * are equal if they contain, over the specified ranges, the same elements\\n     * in the same order.\\n     *\\n     * \u003cp\u003eTwo objects {@code e1} and {@code e2} are considered \u003ci\u003eequal\u003c/i\u003e if,\\n     * given the specified comparator, {@code cmp.compare(e1, e2) == 0}.\\n     *\\n     * @param a the first array to be tested for equality\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be tested\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be tested\\n     * @param b the second array to be tested for equality\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be tested\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be tested\\n     * @param cmp the comparator to compare array elements\\n     * @param \u003cT\u003e the type of array elements\\n     * @return {@code true} if the two arrays, over the specified ranges, are\\n     *         equal\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array or the comparator is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void fill(long[] a, long val)", "label": "public static void fill(long[] a, long val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Assigns the specified long value to each element of the specified array\\n     * of longs.\\n     *\\n     * @param a the array to be filled\\n     * @param val the value to be stored in all elements of the array\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void fill(long[] a, int fromIndex, int toIndex, long val)", "label": "public static void fill(long[] a, int fromIndex, int toIndex, long val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Assigns the specified long value to each element of the specified\\n     * range of the specified array of longs.  The range to be filled\\n     * extends from index {@code fromIndex}, inclusive, to index\\n     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\\n     * range to be filled is empty.)\\n     *\\n     * @param a the array to be filled\\n     * @param fromIndex the index of the first element (inclusive) to be\\n     *        filled with the specified value\\n     * @param toIndex the index of the last element (exclusive) to be\\n     *        filled with the specified value\\n     * @param val the value to be stored in all elements of the array\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex \u003c 0} or\\n     *         {@code toIndex \u003e a.length}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void fill(int[] a, int val)", "label": "public static void fill(int[] a, int val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Assigns the specified int value to each element of the specified array\\n     * of ints.\\n     *\\n     * @param a the array to be filled\\n     * @param val the value to be stored in all elements of the array\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void fill(int[] a, int fromIndex, int toIndex, int val)", "label": "public static void fill(int[] a, int fromIndex, int toIndex, int val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Assigns the specified int value to each element of the specified\\n     * range of the specified array of ints.  The range to be filled\\n     * extends from index {@code fromIndex}, inclusive, to index\\n     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\\n     * range to be filled is empty.)\\n     *\\n     * @param a the array to be filled\\n     * @param fromIndex the index of the first element (inclusive) to be\\n     *        filled with the specified value\\n     * @param toIndex the index of the last element (exclusive) to be\\n     *        filled with the specified value\\n     * @param val the value to be stored in all elements of the array\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex \u003c 0} or\\n     *         {@code toIndex \u003e a.length}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void fill(short[] a, short val)", "label": "public static void fill(short[] a, short val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Assigns the specified short value to each element of the specified array\\n     * of shorts.\\n     *\\n     * @param a the array to be filled\\n     * @param val the value to be stored in all elements of the array\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void fill(short[] a, int fromIndex, int toIndex, short val)", "label": "public static void fill(short[] a, int fromIndex, int toIndex, short val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Assigns the specified short value to each element of the specified\\n     * range of the specified array of shorts.  The range to be filled\\n     * extends from index {@code fromIndex}, inclusive, to index\\n     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\\n     * range to be filled is empty.)\\n     *\\n     * @param a the array to be filled\\n     * @param fromIndex the index of the first element (inclusive) to be\\n     *        filled with the specified value\\n     * @param toIndex the index of the last element (exclusive) to be\\n     *        filled with the specified value\\n     * @param val the value to be stored in all elements of the array\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex \u003c 0} or\\n     *         {@code toIndex \u003e a.length}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void fill(char[] a, char val)", "label": "public static void fill(char[] a, char val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Assigns the specified char value to each element of the specified array\\n     * of chars.\\n     *\\n     * @param a the array to be filled\\n     * @param val the value to be stored in all elements of the array\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void fill(char[] a, int fromIndex, int toIndex, char val)", "label": "public static void fill(char[] a, int fromIndex, int toIndex, char val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Assigns the specified char value to each element of the specified\\n     * range of the specified array of chars.  The range to be filled\\n     * extends from index {@code fromIndex}, inclusive, to index\\n     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\\n     * range to be filled is empty.)\\n     *\\n     * @param a the array to be filled\\n     * @param fromIndex the index of the first element (inclusive) to be\\n     *        filled with the specified value\\n     * @param toIndex the index of the last element (exclusive) to be\\n     *        filled with the specified value\\n     * @param val the value to be stored in all elements of the array\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex \u003c 0} or\\n     *         {@code toIndex \u003e a.length}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void fill(byte[] a, byte val)", "label": "public static void fill(byte[] a, byte val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Assigns the specified byte value to each element of the specified array\\n     * of bytes.\\n     *\\n     * @param a the array to be filled\\n     * @param val the value to be stored in all elements of the array\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void fill(byte[] a, int fromIndex, int toIndex, byte val)", "label": "public static void fill(byte[] a, int fromIndex, int toIndex, byte val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Assigns the specified byte value to each element of the specified\\n     * range of the specified array of bytes.  The range to be filled\\n     * extends from index {@code fromIndex}, inclusive, to index\\n     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\\n     * range to be filled is empty.)\\n     *\\n     * @param a the array to be filled\\n     * @param fromIndex the index of the first element (inclusive) to be\\n     *        filled with the specified value\\n     * @param toIndex the index of the last element (exclusive) to be\\n     *        filled with the specified value\\n     * @param val the value to be stored in all elements of the array\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex \u003c 0} or\\n     *         {@code toIndex \u003e a.length}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void fill(boolean[] a, boolean val)", "label": "public static void fill(boolean[] a, boolean val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Assigns the specified boolean value to each element of the specified\\n     * array of booleans.\\n     *\\n     * @param a the array to be filled\\n     * @param val the value to be stored in all elements of the array\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void fill(boolean[] a, int fromIndex, int toIndex, boolean val)", "label": "public static void fill(boolean[] a, int fromIndex, int toIndex, boolean val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Assigns the specified boolean value to each element of the specified\\n     * range of the specified array of booleans.  The range to be filled\\n     * extends from index {@code fromIndex}, inclusive, to index\\n     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\\n     * range to be filled is empty.)\\n     *\\n     * @param a the array to be filled\\n     * @param fromIndex the index of the first element (inclusive) to be\\n     *        filled with the specified value\\n     * @param toIndex the index of the last element (exclusive) to be\\n     *        filled with the specified value\\n     * @param val the value to be stored in all elements of the array\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex \u003c 0} or\\n     *         {@code toIndex \u003e a.length}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void fill(double[] a, double val)", "label": "public static void fill(double[] a, double val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Assigns the specified double value to each element of the specified\\n     * array of doubles.\\n     *\\n     * @param a the array to be filled\\n     * @param val the value to be stored in all elements of the array\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void fill(double[] a, int fromIndex, int toIndex, double val)", "label": "public static void fill(double[] a, int fromIndex, int toIndex, double val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Assigns the specified double value to each element of the specified\\n     * range of the specified array of doubles.  The range to be filled\\n     * extends from index {@code fromIndex}, inclusive, to index\\n     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\\n     * range to be filled is empty.)\\n     *\\n     * @param a the array to be filled\\n     * @param fromIndex the index of the first element (inclusive) to be\\n     *        filled with the specified value\\n     * @param toIndex the index of the last element (exclusive) to be\\n     *        filled with the specified value\\n     * @param val the value to be stored in all elements of the array\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex \u003c 0} or\\n     *         {@code toIndex \u003e a.length}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void fill(float[] a, float val)", "label": "public static void fill(float[] a, float val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Assigns the specified float value to each element of the specified array\\n     * of floats.\\n     *\\n     * @param a the array to be filled\\n     * @param val the value to be stored in all elements of the array\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void fill(float[] a, int fromIndex, int toIndex, float val)", "label": "public static void fill(float[] a, int fromIndex, int toIndex, float val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Assigns the specified float value to each element of the specified\\n     * range of the specified array of floats.  The range to be filled\\n     * extends from index {@code fromIndex}, inclusive, to index\\n     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\\n     * range to be filled is empty.)\\n     *\\n     * @param a the array to be filled\\n     * @param fromIndex the index of the first element (inclusive) to be\\n     *        filled with the specified value\\n     * @param toIndex the index of the last element (exclusive) to be\\n     *        filled with the specified value\\n     * @param val the value to be stored in all elements of the array\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex \u003c 0} or\\n     *         {@code toIndex \u003e a.length}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void fill(Object[] a, Object val)", "label": "public static void fill(Object[] a, Object val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Assigns the specified Object reference to each element of the specified\\n     * array of Objects.\\n     *\\n     * @param a the array to be filled\\n     * @param val the value to be stored in all elements of the array\\n     * @throws ArrayStoreException if the specified value is not of a\\n     *         runtime type that can be stored in the specified array\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void fill(Object[] a, int fromIndex, int toIndex, Object val)", "label": "public static void fill(Object[] a, int fromIndex, int toIndex, Object val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Assigns the specified Object reference to each element of the specified\\n     * range of the specified array of Objects.  The range to be filled\\n     * extends from index {@code fromIndex}, inclusive, to index\\n     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\\n     * range to be filled is empty.)\\n     *\\n     * @param a the array to be filled\\n     * @param fromIndex the index of the first element (inclusive) to be\\n     *        filled with the specified value\\n     * @param toIndex the index of the last element (exclusive) to be\\n     *        filled with the specified value\\n     * @param val the value to be stored in all elements of the array\\n     * @throws IllegalArgumentException if {@code fromIndex \u003e toIndex}\\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex \u003c 0} or\\n     *         {@code toIndex \u003e a.length}\\n     * @throws ArrayStoreException if the specified value is not of a\\n     *         runtime type that can be stored in the specified array\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static T[] copyOf(T[] original, int newLength)", "label": "public static T[] copyOf(T[] original, int newLength)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies the specified array, truncating or padding with nulls (if necessary)\\n     * so the copy has the specified length.  For all indices that are\\n     * valid in both the original array and the copy, the two arrays will\\n     * contain identical values.  For any indices that are valid in the\\n     * copy but not the original, the copy will contain {@code null}.\\n     * Such indices will exist if and only if the specified length\\n     * is greater than that of the original array.\\n     * The resulting array is of exactly the same class as the original array.\\n     *\\n     * @param \u003cT\u003e the class of the objects in the array\\n     * @param original the array to be copied\\n     * @param newLength the length of the copy to be returned\\n     * @return a copy of the original array, truncated or padded with nulls\\n     *     to obtain the specified length\\n     * @throws NegativeArraySizeException if {@code newLength} is negative\\n     * @throws NullPointerException if {@code original} is null\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static T[] copyOf(U[] original, int newLength, Class\u003c? extends T[]\u003e newType)", "label": "public static T[] copyOf(U[] original, int newLength, Class\u003c? extends T[]\u003e newType)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies the specified array, truncating or padding with nulls (if necessary)\\n     * so the copy has the specified length.  For all indices that are\\n     * valid in both the original array and the copy, the two arrays will\\n     * contain identical values.  For any indices that are valid in the\\n     * copy but not the original, the copy will contain {@code null}.\\n     * Such indices will exist if and only if the specified length\\n     * is greater than that of the original array.\\n     * The resulting array is of the class {@code newType}.\\n     *\\n     * @param \u003cU\u003e the class of the objects in the original array\\n     * @param \u003cT\u003e the class of the objects in the returned array\\n     * @param original the array to be copied\\n     * @param newLength the length of the copy to be returned\\n     * @param newType the class of the copy to be returned\\n     * @return a copy of the original array, truncated or padded with nulls\\n     *     to obtain the specified length\\n     * @throws NegativeArraySizeException if {@code newLength} is negative\\n     * @throws NullPointerException if {@code original} is null\\n     * @throws ArrayStoreException if an element copied from\\n     *     {@code original} is not of a runtime type that can be stored in\\n     *     an array of class {@code newType}\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static byte[] copyOf(byte[] original, int newLength)", "label": "public static byte[] copyOf(byte[] original, int newLength)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies the specified array, truncating or padding with zeros (if necessary)\\n     * so the copy has the specified length.  For all indices that are\\n     * valid in both the original array and the copy, the two arrays will\\n     * contain identical values.  For any indices that are valid in the\\n     * copy but not the original, the copy will contain {@code (byte)0}.\\n     * Such indices will exist if and only if the specified length\\n     * is greater than that of the original array.\\n     *\\n     * @param original the array to be copied\\n     * @param newLength the length of the copy to be returned\\n     * @return a copy of the original array, truncated or padded with zeros\\n     *     to obtain the specified length\\n     * @throws NegativeArraySizeException if {@code newLength} is negative\\n     * @throws NullPointerException if {@code original} is null\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static short[] copyOf(short[] original, int newLength)", "label": "public static short[] copyOf(short[] original, int newLength)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies the specified array, truncating or padding with zeros (if necessary)\\n     * so the copy has the specified length.  For all indices that are\\n     * valid in both the original array and the copy, the two arrays will\\n     * contain identical values.  For any indices that are valid in the\\n     * copy but not the original, the copy will contain {@code (short)0}.\\n     * Such indices will exist if and only if the specified length\\n     * is greater than that of the original array.\\n     *\\n     * @param original the array to be copied\\n     * @param newLength the length of the copy to be returned\\n     * @return a copy of the original array, truncated or padded with zeros\\n     *     to obtain the specified length\\n     * @throws NegativeArraySizeException if {@code newLength} is negative\\n     * @throws NullPointerException if {@code original} is null\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int[] copyOf(int[] original, int newLength)", "label": "public static int[] copyOf(int[] original, int newLength)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies the specified array, truncating or padding with zeros (if necessary)\\n     * so the copy has the specified length.  For all indices that are\\n     * valid in both the original array and the copy, the two arrays will\\n     * contain identical values.  For any indices that are valid in the\\n     * copy but not the original, the copy will contain {@code 0}.\\n     * Such indices will exist if and only if the specified length\\n     * is greater than that of the original array.\\n     *\\n     * @param original the array to be copied\\n     * @param newLength the length of the copy to be returned\\n     * @return a copy of the original array, truncated or padded with zeros\\n     *     to obtain the specified length\\n     * @throws NegativeArraySizeException if {@code newLength} is negative\\n     * @throws NullPointerException if {@code original} is null\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static long[] copyOf(long[] original, int newLength)", "label": "public static long[] copyOf(long[] original, int newLength)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies the specified array, truncating or padding with zeros (if necessary)\\n     * so the copy has the specified length.  For all indices that are\\n     * valid in both the original array and the copy, the two arrays will\\n     * contain identical values.  For any indices that are valid in the\\n     * copy but not the original, the copy will contain {@code 0L}.\\n     * Such indices will exist if and only if the specified length\\n     * is greater than that of the original array.\\n     *\\n     * @param original the array to be copied\\n     * @param newLength the length of the copy to be returned\\n     * @return a copy of the original array, truncated or padded with zeros\\n     *     to obtain the specified length\\n     * @throws NegativeArraySizeException if {@code newLength} is negative\\n     * @throws NullPointerException if {@code original} is null\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static char[] copyOf(char[] original, int newLength)", "label": "public static char[] copyOf(char[] original, int newLength)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Copies the specified array, truncating or padding with null characters (if necessary)\\n     * so the copy has the specified length.  For all indices that are valid\\n     * in both the original array and the copy, the two arrays will contain\\n     * identical values.  For any indices that are valid in the copy but not\\n     * the original, the copy will contain {@code \u0027\\\\u005cu0000\u0027}.  Such indices\\n     * will exist if and only if the specified length is greater than that of\\n     * the original array.\\n     *\\n     * @param original the array to be copied\\n     * @param newLength the length of the copy to be returned\\n     * @return a copy of the original array, truncated or padded with null characters\\n     *     to obtain the specified length\\n     * @throws NegativeArraySizeException if {@code newLength} is negative\\n     * @throws NullPointerException if {@code original} is null\\n     * @since 1.6\\n     \"}"}, {"color": "#97c2fc", "id": "public static float[] copyOf(float[] original, int newLength)", "label": "public static float[] copyOf(float[] original, int newLength)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies the specified array, truncating or padding with zeros (if necessary)\\n     * so the copy has the specified length.  For all indices that are\\n     * valid in both the original array and the copy, the two arrays will\\n     * contain identical values.  For any indices that are valid in the\\n     * copy but not the original, the copy will contain {@code 0f}.\\n     * Such indices will exist if and only if the specified length\\n     * is greater than that of the original array.\\n     *\\n     * @param original the array to be copied\\n     * @param newLength the length of the copy to be returned\\n     * @return a copy of the original array, truncated or padded with zeros\\n     *     to obtain the specified length\\n     * @throws NegativeArraySizeException if {@code newLength} is negative\\n     * @throws NullPointerException if {@code original} is null\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static double[] copyOf(double[] original, int newLength)", "label": "public static double[] copyOf(double[] original, int newLength)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies the specified array, truncating or padding with zeros (if necessary)\\n     * so the copy has the specified length.  For all indices that are\\n     * valid in both the original array and the copy, the two arrays will\\n     * contain identical values.  For any indices that are valid in the\\n     * copy but not the original, the copy will contain {@code 0d}.\\n     * Such indices will exist if and only if the specified length\\n     * is greater than that of the original array.\\n     *\\n     * @param original the array to be copied\\n     * @param newLength the length of the copy to be returned\\n     * @return a copy of the original array, truncated or padded with zeros\\n     *     to obtain the specified length\\n     * @throws NegativeArraySizeException if {@code newLength} is negative\\n     * @throws NullPointerException if {@code original} is null\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean[] copyOf(boolean[] original, int newLength)", "label": "public static boolean[] copyOf(boolean[] original, int newLength)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies the specified array, truncating or padding with {@code false} (if necessary)\\n     * so the copy has the specified length.  For all indices that are\\n     * valid in both the original array and the copy, the two arrays will\\n     * contain identical values.  For any indices that are valid in the\\n     * copy but not the original, the copy will contain {@code false}.\\n     * Such indices will exist if and only if the specified length\\n     * is greater than that of the original array.\\n     *\\n     * @param original the array to be copied\\n     * @param newLength the length of the copy to be returned\\n     * @return a copy of the original array, truncated or padded with false elements\\n     *     to obtain the specified length\\n     * @throws NegativeArraySizeException if {@code newLength} is negative\\n     * @throws NullPointerException if {@code original} is null\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static T[] copyOfRange(T[] original, int from, int to)", "label": "public static T[] copyOfRange(T[] original, int from, int to)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies the specified range of the specified array into a new array.\\n     * The initial index of the range ({@code from}) must lie between zero\\n     * and {@code original.length}, inclusive.  The value at\\n     * {@code original[from]} is placed into the initial element of the copy\\n     * (unless {@code from == original.length} or {@code from == to}).\\n     * Values from subsequent elements in the original array are placed into\\n     * subsequent elements in the copy.  The final index of the range\\n     * ({@code to}), which must be greater than or equal to {@code from},\\n     * may be greater than {@code original.length}, in which case\\n     * {@code null} is placed in all elements of the copy whose index is\\n     * greater than or equal to {@code original.length - from}.  The length\\n     * of the returned array will be {@code to - from}.\\n     * \u003cp\u003e\\n     * The resulting array is of exactly the same class as the original array.\\n     *\\n     * @param \u003cT\u003e the class of the objects in the array\\n     * @param original the array from which a range is to be copied\\n     * @param from the initial index of the range to be copied, inclusive\\n     * @param to the final index of the range to be copied, exclusive.\\n     *     (This index may lie outside the array.)\\n     * @return a new array containing the specified range from the original array,\\n     *     truncated or padded with nulls to obtain the required length\\n     * @throws ArrayIndexOutOfBoundsException if {@code from \u003c 0}\\n     *     or {@code from \u003e original.length}\\n     * @throws IllegalArgumentException if {@code from \u003e to}\\n     * @throws NullPointerException if {@code original} is null\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static T[] copyOfRange(U[] original, int from, int to, Class\u003c? extends T[]\u003e newType)", "label": "public static T[] copyOfRange(U[] original, int from, int to, Class\u003c? extends T[]\u003e newType)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies the specified range of the specified array into a new array.\\n     * The initial index of the range ({@code from}) must lie between zero\\n     * and {@code original.length}, inclusive.  The value at\\n     * {@code original[from]} is placed into the initial element of the copy\\n     * (unless {@code from == original.length} or {@code from == to}).\\n     * Values from subsequent elements in the original array are placed into\\n     * subsequent elements in the copy.  The final index of the range\\n     * ({@code to}), which must be greater than or equal to {@code from},\\n     * may be greater than {@code original.length}, in which case\\n     * {@code null} is placed in all elements of the copy whose index is\\n     * greater than or equal to {@code original.length - from}.  The length\\n     * of the returned array will be {@code to - from}.\\n     * The resulting array is of the class {@code newType}.\\n     *\\n     * @param \u003cU\u003e the class of the objects in the original array\\n     * @param \u003cT\u003e the class of the objects in the returned array\\n     * @param original the array from which a range is to be copied\\n     * @param from the initial index of the range to be copied, inclusive\\n     * @param to the final index of the range to be copied, exclusive.\\n     *     (This index may lie outside the array.)\\n     * @param newType the class of the copy to be returned\\n     * @return a new array containing the specified range from the original array,\\n     *     truncated or padded with nulls to obtain the required length\\n     * @throws ArrayIndexOutOfBoundsException if {@code from \u003c 0}\\n     *     or {@code from \u003e original.length}\\n     * @throws IllegalArgumentException if {@code from \u003e to}\\n     * @throws NullPointerException if {@code original} is null\\n     * @throws ArrayStoreException if an element copied from\\n     *     {@code original} is not of a runtime type that can be stored in\\n     *     an array of class {@code newType}.\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static byte[] copyOfRange(byte[] original, int from, int to)", "label": "public static byte[] copyOfRange(byte[] original, int from, int to)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies the specified range of the specified array into a new array.\\n     * The initial index of the range ({@code from}) must lie between zero\\n     * and {@code original.length}, inclusive.  The value at\\n     * {@code original[from]} is placed into the initial element of the copy\\n     * (unless {@code from == original.length} or {@code from == to}).\\n     * Values from subsequent elements in the original array are placed into\\n     * subsequent elements in the copy.  The final index of the range\\n     * ({@code to}), which must be greater than or equal to {@code from},\\n     * may be greater than {@code original.length}, in which case\\n     * {@code (byte)0} is placed in all elements of the copy whose index is\\n     * greater than or equal to {@code original.length - from}.  The length\\n     * of the returned array will be {@code to - from}.\\n     *\\n     * @param original the array from which a range is to be copied\\n     * @param from the initial index of the range to be copied, inclusive\\n     * @param to the final index of the range to be copied, exclusive.\\n     *     (This index may lie outside the array.)\\n     * @return a new array containing the specified range from the original array,\\n     *     truncated or padded with zeros to obtain the required length\\n     * @throws ArrayIndexOutOfBoundsException if {@code from \u003c 0}\\n     *     or {@code from \u003e original.length}\\n     * @throws IllegalArgumentException if {@code from \u003e to}\\n     * @throws NullPointerException if {@code original} is null\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static short[] copyOfRange(short[] original, int from, int to)", "label": "public static short[] copyOfRange(short[] original, int from, int to)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies the specified range of the specified array into a new array.\\n     * The initial index of the range ({@code from}) must lie between zero\\n     * and {@code original.length}, inclusive.  The value at\\n     * {@code original[from]} is placed into the initial element of the copy\\n     * (unless {@code from == original.length} or {@code from == to}).\\n     * Values from subsequent elements in the original array are placed into\\n     * subsequent elements in the copy.  The final index of the range\\n     * ({@code to}), which must be greater than or equal to {@code from},\\n     * may be greater than {@code original.length}, in which case\\n     * {@code (short)0} is placed in all elements of the copy whose index is\\n     * greater than or equal to {@code original.length - from}.  The length\\n     * of the returned array will be {@code to - from}.\\n     *\\n     * @param original the array from which a range is to be copied\\n     * @param from the initial index of the range to be copied, inclusive\\n     * @param to the final index of the range to be copied, exclusive.\\n     *     (This index may lie outside the array.)\\n     * @return a new array containing the specified range from the original array,\\n     *     truncated or padded with zeros to obtain the required length\\n     * @throws ArrayIndexOutOfBoundsException if {@code from \u003c 0}\\n     *     or {@code from \u003e original.length}\\n     * @throws IllegalArgumentException if {@code from \u003e to}\\n     * @throws NullPointerException if {@code original} is null\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int[] copyOfRange(int[] original, int from, int to)", "label": "public static int[] copyOfRange(int[] original, int from, int to)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies the specified range of the specified array into a new array.\\n     * The initial index of the range ({@code from}) must lie between zero\\n     * and {@code original.length}, inclusive.  The value at\\n     * {@code original[from]} is placed into the initial element of the copy\\n     * (unless {@code from == original.length} or {@code from == to}).\\n     * Values from subsequent elements in the original array are placed into\\n     * subsequent elements in the copy.  The final index of the range\\n     * ({@code to}), which must be greater than or equal to {@code from},\\n     * may be greater than {@code original.length}, in which case\\n     * {@code 0} is placed in all elements of the copy whose index is\\n     * greater than or equal to {@code original.length - from}.  The length\\n     * of the returned array will be {@code to - from}.\\n     *\\n     * @param original the array from which a range is to be copied\\n     * @param from the initial index of the range to be copied, inclusive\\n     * @param to the final index of the range to be copied, exclusive.\\n     *     (This index may lie outside the array.)\\n     * @return a new array containing the specified range from the original array,\\n     *     truncated or padded with zeros to obtain the required length\\n     * @throws ArrayIndexOutOfBoundsException if {@code from \u003c 0}\\n     *     or {@code from \u003e original.length}\\n     * @throws IllegalArgumentException if {@code from \u003e to}\\n     * @throws NullPointerException if {@code original} is null\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static long[] copyOfRange(long[] original, int from, int to)", "label": "public static long[] copyOfRange(long[] original, int from, int to)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies the specified range of the specified array into a new array.\\n     * The initial index of the range ({@code from}) must lie between zero\\n     * and {@code original.length}, inclusive.  The value at\\n     * {@code original[from]} is placed into the initial element of the copy\\n     * (unless {@code from == original.length} or {@code from == to}).\\n     * Values from subsequent elements in the original array are placed into\\n     * subsequent elements in the copy.  The final index of the range\\n     * ({@code to}), which must be greater than or equal to {@code from},\\n     * may be greater than {@code original.length}, in which case\\n     * {@code 0L} is placed in all elements of the copy whose index is\\n     * greater than or equal to {@code original.length - from}.  The length\\n     * of the returned array will be {@code to - from}.\\n     *\\n     * @param original the array from which a range is to be copied\\n     * @param from the initial index of the range to be copied, inclusive\\n     * @param to the final index of the range to be copied, exclusive.\\n     *     (This index may lie outside the array.)\\n     * @return a new array containing the specified range from the original array,\\n     *     truncated or padded with zeros to obtain the required length\\n     * @throws ArrayIndexOutOfBoundsException if {@code from \u003c 0}\\n     *     or {@code from \u003e original.length}\\n     * @throws IllegalArgumentException if {@code from \u003e to}\\n     * @throws NullPointerException if {@code original} is null\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static char[] copyOfRange(char[] original, int from, int to)", "label": "public static char[] copyOfRange(char[] original, int from, int to)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Copies the specified range of the specified array into a new array.\\n     * The initial index of the range ({@code from}) must lie between zero\\n     * and {@code original.length}, inclusive.  The value at\\n     * {@code original[from]} is placed into the initial element of the copy\\n     * (unless {@code from == original.length} or {@code from == to}).\\n     * Values from subsequent elements in the original array are placed into\\n     * subsequent elements in the copy.  The final index of the range\\n     * ({@code to}), which must be greater than or equal to {@code from},\\n     * may be greater than {@code original.length}, in which case\\n     * {@code \u0027\\\\u005cu0000\u0027} is placed in all elements of the copy whose index is\\n     * greater than or equal to {@code original.length - from}.  The length\\n     * of the returned array will be {@code to - from}.\\n     *\\n     * @param original the array from which a range is to be copied\\n     * @param from the initial index of the range to be copied, inclusive\\n     * @param to the final index of the range to be copied, exclusive.\\n     *     (This index may lie outside the array.)\\n     * @return a new array containing the specified range from the original array,\\n     *     truncated or padded with null characters to obtain the required length\\n     * @throws ArrayIndexOutOfBoundsException if {@code from \u003c 0}\\n     *     or {@code from \u003e original.length}\\n     * @throws IllegalArgumentException if {@code from \u003e to}\\n     * @throws NullPointerException if {@code original} is null\\n     * @since 1.6\\n     \"}"}, {"color": "#97c2fc", "id": "public static float[] copyOfRange(float[] original, int from, int to)", "label": "public static float[] copyOfRange(float[] original, int from, int to)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies the specified range of the specified array into a new array.\\n     * The initial index of the range ({@code from}) must lie between zero\\n     * and {@code original.length}, inclusive.  The value at\\n     * {@code original[from]} is placed into the initial element of the copy\\n     * (unless {@code from == original.length} or {@code from == to}).\\n     * Values from subsequent elements in the original array are placed into\\n     * subsequent elements in the copy.  The final index of the range\\n     * ({@code to}), which must be greater than or equal to {@code from},\\n     * may be greater than {@code original.length}, in which case\\n     * {@code 0f} is placed in all elements of the copy whose index is\\n     * greater than or equal to {@code original.length - from}.  The length\\n     * of the returned array will be {@code to - from}.\\n     *\\n     * @param original the array from which a range is to be copied\\n     * @param from the initial index of the range to be copied, inclusive\\n     * @param to the final index of the range to be copied, exclusive.\\n     *     (This index may lie outside the array.)\\n     * @return a new array containing the specified range from the original array,\\n     *     truncated or padded with zeros to obtain the required length\\n     * @throws ArrayIndexOutOfBoundsException if {@code from \u003c 0}\\n     *     or {@code from \u003e original.length}\\n     * @throws IllegalArgumentException if {@code from \u003e to}\\n     * @throws NullPointerException if {@code original} is null\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static double[] copyOfRange(double[] original, int from, int to)", "label": "public static double[] copyOfRange(double[] original, int from, int to)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies the specified range of the specified array into a new array.\\n     * The initial index of the range ({@code from}) must lie between zero\\n     * and {@code original.length}, inclusive.  The value at\\n     * {@code original[from]} is placed into the initial element of the copy\\n     * (unless {@code from == original.length} or {@code from == to}).\\n     * Values from subsequent elements in the original array are placed into\\n     * subsequent elements in the copy.  The final index of the range\\n     * ({@code to}), which must be greater than or equal to {@code from},\\n     * may be greater than {@code original.length}, in which case\\n     * {@code 0d} is placed in all elements of the copy whose index is\\n     * greater than or equal to {@code original.length - from}.  The length\\n     * of the returned array will be {@code to - from}.\\n     *\\n     * @param original the array from which a range is to be copied\\n     * @param from the initial index of the range to be copied, inclusive\\n     * @param to the final index of the range to be copied, exclusive.\\n     *     (This index may lie outside the array.)\\n     * @return a new array containing the specified range from the original array,\\n     *     truncated or padded with zeros to obtain the required length\\n     * @throws ArrayIndexOutOfBoundsException if {@code from \u003c 0}\\n     *     or {@code from \u003e original.length}\\n     * @throws IllegalArgumentException if {@code from \u003e to}\\n     * @throws NullPointerException if {@code original} is null\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean[] copyOfRange(boolean[] original, int from, int to)", "label": "public static boolean[] copyOfRange(boolean[] original, int from, int to)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies the specified range of the specified array into a new array.\\n     * The initial index of the range ({@code from}) must lie between zero\\n     * and {@code original.length}, inclusive.  The value at\\n     * {@code original[from]} is placed into the initial element of the copy\\n     * (unless {@code from == original.length} or {@code from == to}).\\n     * Values from subsequent elements in the original array are placed into\\n     * subsequent elements in the copy.  The final index of the range\\n     * ({@code to}), which must be greater than or equal to {@code from},\\n     * may be greater than {@code original.length}, in which case\\n     * {@code false} is placed in all elements of the copy whose index is\\n     * greater than or equal to {@code original.length - from}.  The length\\n     * of the returned array will be {@code to - from}.\\n     *\\n     * @param original the array from which a range is to be copied\\n     * @param from the initial index of the range to be copied, inclusive\\n     * @param to the final index of the range to be copied, exclusive.\\n     *     (This index may lie outside the array.)\\n     * @return a new array containing the specified range from the original array,\\n     *     truncated or padded with false elements to obtain the required length\\n     * @throws ArrayIndexOutOfBoundsException if {@code from \u003c 0}\\n     *     or {@code from \u003e original.length}\\n     * @throws IllegalArgumentException if {@code from \u003e to}\\n     * @throws NullPointerException if {@code original} is null\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static List\u003cT\u003e asList(T... a)", "label": "public static List\u003cT\u003e asList(T... a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a fixed-size list backed by the specified array. Changes made to\\n     * the array will be visible in the returned list, and changes made to the\\n     * list will be visible in the array. The returned list is\\n     * {@link Serializable} and implements {@link RandomAccess}.\\n     *\\n     * \u003cp\u003eThe returned list implements the optional {@code Collection} methods, except\\n     * those that would change the size of the returned list. Those methods leave\\n     * the list unchanged and throw {@link UnsupportedOperationException}.\\n     *\\n     * @apiNote\\n     * This method acts as bridge between array-based and collection-based\\n     * APIs, in combination with {@link Collection#toArray}.\\n     *\\n     * \u003cp\u003eThis method provides a way to wrap an existing array:\\n     * \u003cpre\u003e{@code\\n     *     Integer[] numbers = ...\\n     *     ...\\n     *     List\u003cInteger\u003e values = Arrays.asList(numbers);\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eThis method also provides a convenient way to create a fixed-size\\n     * list initialized to contain several elements:\\n     * \u003cpre\u003e{@code\\n     *     List\u003cString\u003e stooges = Arrays.asList(\"Larry\", \"Moe\", \"Curly\");\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003e\u003cem\u003eThe list returned by this method is modifiable.\u003c/em\u003e\\n     * To create an unmodifiable list, use\\n     * {@link Collections#unmodifiableList Collections.unmodifiableList}\\n     * or \u003ca href=\"List.html#unmodifiable\"\u003eUnmodifiable Lists\u003c/a\u003e.\\n     *\\n     * @param \u003cT\u003e the class of the objects in the array\\n     * @param a the array by which the list will be backed\\n     * @return a list view of the specified array\\n     * @throws NullPointerException if the specified array is {@code null}\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.util.RandomAccess", "label": "java.util.RandomAccess", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Marker interface used by {@code List} implementations to indicate that\\n * they support fast (generally constant time) random access.  The primary\\n * purpose of this interface is to allow generic algorithms to alter their\\n * behavior to provide good performance when applied to either random or\\n * sequential access lists.\\n *\\n * \u003cp\u003eThe best algorithms for manipulating random access lists (such as\\n * {@code ArrayList}) can produce quadratic behavior when applied to\\n * sequential access lists (such as {@code LinkedList}).  Generic list\\n * algorithms are encouraged to check whether the given list is an\\n * {@code instanceof} this interface before applying an algorithm that would\\n * provide poor performance if it were applied to a sequential access list,\\n * and to alter their behavior if necessary to guarantee acceptable\\n * performance.\\n *\\n * \u003cp\u003eIt is recognized that the distinction between random and sequential\\n * access is often fuzzy.  For example, some {@code List} implementations\\n * provide asymptotically linear access times if they get huge, but constant\\n * access times in practice.  Such a {@code List} implementation\\n * should generally implement this interface.  As a rule of thumb, a\\n * {@code List} implementation should implement this interface if,\\n * for typical instances of the class, this loop:\\n * \u003cpre\u003e\\n *     for (int i=0, n=list.size(); i \u0026lt; n; i++)\\n *         list.get(i);\\n * \u003c/pre\u003e\\n * runs faster than this loop:\\n * \u003cpre\u003e\\n *     for (Iterator i=list.iterator(); i.hasNext(); )\\n *         i.next();\\n * \u003c/pre\u003e\\n *\\n * \u003cp\u003eThis interface is a member of the\\n * \u003ca href=\"{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework\"\u003e\\n * Java Collections Framework\u003c/a\u003e.\\n *\\n * @since 1.4\\n \u0027}"}, {"color": "#97c2fc", "id": "unmodifiableList", "label": "unmodifiableList", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.io.Serializable", "label": "java.io.Serializable", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Serializability of a class is enabled by the class implementing the\\n * java.io.Serializable interface.\\n *\\n * \u003cp\u003e\u003cstrong\u003eWarning: Deserialization of untrusted data is inherently dangerous\\n * and should be avoided. Untrusted data should be carefully validated.\\n * \u003c/strong\u003e\u003c/p\u003e\\n *\\n * Classes that do not implement this\\n * interface will not have any of their state serialized or\\n * deserialized.  All subtypes of a serializable class are themselves\\n * serializable.  The serialization interface has no methods or fields\\n * and serves only to identify the semantics of being serializable. \u003cp\u003e\\n *\\n * To allow subtypes of non-serializable classes to be serialized, the\\n * subtype may assume responsibility for saving and restoring the\\n * state of the supertype\\\u0027s public, protected, and (if accessible)\\n * package fields.  The subtype may assume this responsibility only if\\n * the class it extends has an accessible no-arg constructor to\\n * initialize the class\\\u0027s state.  It is an error to declare a class\\n * Serializable if this is not the case.  The error will be detected at\\n * runtime. \u003cp\u003e\\n *\\n * During deserialization, the fields of non-serializable classes will\\n * be initialized using the public or protected no-arg constructor of\\n * the class.  A no-arg constructor must be accessible to the subclass\\n * that is serializable.  The fields of serializable subclasses will\\n * be restored from the stream. \u003cp\u003e\\n *\\n * When traversing a graph, an object may be encountered that does not\\n * support the Serializable interface. In this case the\\n * NotSerializableException will be thrown and will identify the class\\n * of the non-serializable object. \u003cp\u003e\\n *\\n * Classes that require special handling during the serialization and\\n * deserialization process must implement special methods with these exact\\n * signatures:\\n *\\n * \u003cPRE\u003e\\n * private void writeObject(java.io.ObjectOutputStream out)\\n *     throws IOException\\n * private void readObject(java.io.ObjectInputStream in)\\n *     throws IOException, ClassNotFoundException;\\n * private void readObjectNoData()\\n *     throws ObjectStreamException;\\n * \u003c/PRE\u003e\\n *\\n * \u003cp\u003eThe writeObject method is responsible for writing the state of the\\n * object for its particular class so that the corresponding\\n * readObject method can restore it.  The default mechanism for saving\\n * the Object\\\u0027s fields can be invoked by calling\\n * out.defaultWriteObject. The method does not need to concern\\n * itself with the state belonging to its superclasses or subclasses.\\n * State is saved by writing the individual fields to the\\n * ObjectOutputStream using the writeObject method or by using the\\n * methods for primitive data types supported by DataOutput.\\n *\\n * \u003cp\u003eThe readObject method is responsible for reading from the stream and\\n * restoring the classes fields. It may call in.defaultReadObject to invoke\\n * the default mechanism for restoring the object\\\u0027s non-static and\\n * non-transient fields.  The defaultReadObject method uses information in\\n * the stream to assign the fields of the object saved in the stream with the\\n * correspondingly named fields in the current object.  This handles the case\\n * when the class has evolved to add new fields. The method does not need to\\n * concern itself with the state belonging to its superclasses or subclasses.\\n * State is restored by reading data from the ObjectInputStream for\\n * the individual fields and making assignments to the appropriate fields\\n * of the object. Reading primitive data types is supported by DataInput.\\n *\\n * \u003cp\u003eThe readObjectNoData method is responsible for initializing the state of\\n * the object for its particular class in the event that the serialization\\n * stream does not list the given class as a superclass of the object being\\n * deserialized.  This may occur in cases where the receiving party uses a\\n * different version of the deserialized instance\\\u0027s class than the sending\\n * party, and the receiver\\\u0027s version extends classes that are not extended by\\n * the sender\\\u0027s version.  This may also occur if the serialization stream has\\n * been tampered; hence, readObjectNoData is useful for initializing\\n * deserialized objects properly despite a \"hostile\" or incomplete source\\n * stream.\\n *\\n * \u003cp\u003eSerializable classes that need to designate an alternative object to be\\n * used when writing an object to the stream should implement this\\n * special method with the exact signature:\\n *\\n * \u003cPRE\u003e\\n * ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException;\\n * \u003c/PRE\u003e\u003cp\u003e\\n *\\n * This writeReplace method is invoked by serialization if the method\\n * exists and it would be accessible from a method defined within the\\n * class of the object being serialized. Thus, the method can have private,\\n * protected and package-private access. Subclass access to this method\\n * follows java accessibility rules. \u003cp\u003e\\n *\\n * Classes that need to designate a replacement when an instance of it\\n * is read from the stream should implement this special method with the\\n * exact signature.\\n *\\n * \u003cPRE\u003e\\n * ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException;\\n * \u003c/PRE\u003e\u003cp\u003e\\n *\\n * This readResolve method follows the same invocation rules and\\n * accessibility rules as writeReplace.\u003cp\u003e\\n *\\n * The serialization runtime associates with each serializable class a version\\n * number, called a serialVersionUID, which is used during deserialization to\\n * verify that the sender and receiver of a serialized object have loaded\\n * classes for that object that are compatible with respect to serialization.\\n * If the receiver has loaded a class for the object that has a different\\n * serialVersionUID than that of the corresponding sender\\\u0027s class, then\\n * deserialization will result in an {@link InvalidClassException}.  A\\n * serializable class can declare its own serialVersionUID explicitly by\\n * declaring a field named \u003ccode\u003e\"serialVersionUID\"\u003c/code\u003e that must be static,\\n * final, and of type \u003ccode\u003elong\u003c/code\u003e:\\n *\\n * \u003cPRE\u003e\\n * ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;\\n * \u003c/PRE\u003e\\n *\\n * If a serializable class does not explicitly declare a serialVersionUID, then\\n * the serialization runtime will calculate a default serialVersionUID value\\n * for that class based on various aspects of the class, as described in the\\n * Java(TM) Object Serialization Specification.  However, it is \u003cem\u003estrongly\\n * recommended\u003c/em\u003e that all serializable classes explicitly declare\\n * serialVersionUID values, since the default serialVersionUID computation is\\n * highly sensitive to class details that may vary depending on compiler\\n * implementations, and can thus result in unexpected\\n * \u003ccode\u003eInvalidClassException\u003c/code\u003es during deserialization.  Therefore, to\\n * guarantee a consistent serialVersionUID value across different java compiler\\n * implementations, a serializable class must declare an explicit\\n * serialVersionUID value.  It is also strongly advised that explicit\\n * serialVersionUID declarations use the \u003ccode\u003eprivate\u003c/code\u003e modifier where\\n * possible, since such declarations apply only to the immediately declaring\\n * class--serialVersionUID fields are not useful as inherited members. Array\\n * classes cannot declare an explicit serialVersionUID, so they always have\\n * the default computed value, but the requirement for matching\\n * serialVersionUID values is waived for array classes.\\n *\\n * Android implementation of serialVersionUID computation will change slightly\\n * for some classes if you\\\u0027re targeting android N. In order to preserve compatibility,\\n * this change is only enabled if the application target SDK version is set to\\n * 24 or higher. It is highly recommended to use an explicit serialVersionUID\\n * field to avoid compatibility issues.\\n *\\n * \u003ch3\u003eImplement Serializable Judiciously\u003c/h3\u003e\\n * Refer to \u003ci\u003eEffective Java\u003c/i\u003e\\\u0027s chapter on serialization for thorough\\n * coverage of the serialization API. The book explains how to use this\\n * interface without harming your application\\\u0027s maintainability.\\n *\\n * \u003ch3\u003eRecommended Alternatives\u003c/h3\u003e\\n * \u003cstrong\u003eJSON\u003c/strong\u003e is concise, human-readable and efficient. Android\\n * includes both a {@link android.util.JsonReader streaming API} and a {@link\\n * org.json.JSONObject tree API} to read and write JSON. Use a binding library\\n * like \u003ca href=\"http://code.google.com/p/google-gson/\"\u003eGSON\u003c/a\u003e to read and\\n * write Java objects directly.\\n *\\n * @author  unascribed\\n * @see java.io.ObjectOutputStream\\n * @see java.io.ObjectInputStream\\n * @see java.io.ObjectOutput\\n * @see java.io.ObjectInput\\n * @see java.io.Externalizable\\n * @since   1.1\\n \u0027}"}, {"color": "#97c2fc", "id": "public static int hashCode(long[] a)", "label": "public static int hashCode(long[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a hash code based on the contents of the specified array.\\n     * For any two {@code long} arrays {@code a} and {@code b}\\n     * such that {@code Arrays.equals(a, b)}, it is also the case that\\n     * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.\\n     *\\n     * \u003cp\u003eThe value returned by this method is the same value that would be\\n     * obtained by invoking the {@link List#hashCode() hashCode}\\n     * method on a {@link List} containing a sequence of {@link Long}\\n     * instances representing the elements of {@code a} in the same order.\\n     * If {@code a} is {@code null}, this method returns 0.\\n     *\\n     * @param a the array whose hash value to compute\\n     * @return a content-based hash code for {@code a}\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.util.List", "label": "java.util.List", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": " boolean addAll(int index, Collection\u003c? extends E\u003e c)", "label": " boolean addAll(int index, Collection\u003c? extends E\u003e c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Inserts all of the elements in the specified collection into this\\n     * list at the specified position (optional operation).  Shifts the\\n     * element currently at that position (if any) and any subsequent\\n     * elements to the right (increases their indices).  The new elements\\n     * will appear in this list in the order that they are returned by the\\n     * specified collection\u0027s iterator.  The behavior of this operation is\\n     * undefined if the specified collection is modified while the\\n     * operation is in progress.  (Note that this will occur if the specified\\n     * collection is this list, and it\u0027s nonempty.)\\n     *\\n     * @param index index at which to insert the first element from the\\n     *              specified collection\\n     * @param c collection containing elements to be added to this list\\n     * @return {@code true} if this list changed as a result of the call\\n     * @throws UnsupportedOperationException if the {@code addAll} operation\\n     *         is not supported by this list\\n     * @throws ClassCastException if the class of an element of the specified\\n     *         collection prevents it from being added to this list\\n     * @throws NullPointerException if the specified collection contains one\\n     *         or more null elements and this list does not permit null\\n     *         elements, or if the specified collection is null\\n     * @throws IllegalArgumentException if some property of an element of the\\n     *         specified collection prevents it from being added to this list\\n     * @throws IndexOutOfBoundsException if the index is out of range\\n     *         ({@code index \u003c 0 || index \u003e size()})\\n     \"}"}, {"color": "#97c2fc", "id": " void replaceAll(UnaryOperator\u003cE\u003e operator)", "label": " void replaceAll(UnaryOperator\u003cE\u003e operator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Replaces each element of this list with the result of applying the\\n     * operator to that element.  Errors or runtime exceptions thrown by\\n     * the operator are relayed to the caller.\\n     *\\n     * @implSpec\\n     * The default implementation is equivalent to, for this {@code list}:\\n     * \u003cpre\u003e{@code\\n     *     final ListIterator\u003cE\u003e li = list.listIterator();\\n     *     while (li.hasNext()) {\\n     *         li.set(operator.apply(li.next()));\\n     *     }\\n     * }\u003c/pre\u003e\\n     *\\n     * If the list\\\u0027s list-iterator does not support the {@code set} operation\\n     * then an {@code UnsupportedOperationException} will be thrown when\\n     * replacing the first element.\\n     *\\n     * @param operator the operator to apply to each element\\n     * @throws UnsupportedOperationException if this list is unmodifiable.\\n     *         Implementations may throw this exception if an element\\n     *         cannot be replaced or if, in general, modification is not\\n     *         supported\\n     * @throws NullPointerException if the specified operator is null or\\n     *         if the operator result is a null value and this list does\\n     *         not permit null elements\\n     *         (\u003ca href=\"Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": " void sort(Comparator\u003c? super E\u003e c)", "label": " void sort(Comparator\u003c? super E\u003e c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sorts this list according to the order induced by the specified\\n     * {@link Comparator}.\\n     *\\n     * \u003cp\u003eAll elements in this list must be \u003ci\u003emutually comparable\u003c/i\u003e using the\\n     * specified comparator (that is, {@code c.compare(e1, e2)} must not throw\\n     * a {@code ClassCastException} for any elements {@code e1} and {@code e2}\\n     * in the list).\\n     *\\n     * \u003cp\u003eIf the specified comparator is {@code null} then all elements in this\\n     * list must implement the {@link Comparable} interface and the elements\\\u0027\\n     * {@linkplain Comparable natural ordering} should be used.\\n     *\\n     * \u003cp\u003eThis list must be modifiable, but need not be resizable.\\n     *\\n     * \u003cp\u003eFor apps running on and targeting Android versions greater than\\n     * Nougat (API level {@code \u003e 25}), {@link Collections#sort(List)}\\n     * delegates to this method. Such apps must not call\\n     * {@link Collections#sort(List)} from this method. Instead, prefer\\n     * not overriding this method at all. If you must override it, consider\\n     * this implementation:\\n     * \u003cpre\u003e\\n     * \u0026#064;Override\\n     * public void sort(Comparator\u0026lt;? super E\u0026gt; c) {\\n     *   Object[] elements = toArray();\\n     *   Arrays.sort(elements, c);\\n     *   ListIterator\u0026lt;E\u0026gt; iterator = (ListIterator\u0026lt;Object\u0026gt;) listIterator();\\n     *   for (Object element : elements) {\\n     *     iterator.next();\\n     *     iterator.set((E) element);\\n     *   }\\n     * }\\n     * \u003c/pre\u003e\\n     *\\n     * @implSpec\\n     * The default implementation obtains an array containing all elements in\\n     * this list, sorts the array, and iterates over this list resetting each\\n     * element from the corresponding position in the array. (This avoids the\\n     * n\u003csup\u003e2\u003c/sup\u003e log(n) performance that would result from attempting\\n     * to sort a linked list in place.)\\n     *\\n     * @implNote\\n     * This implementation is a stable, adaptive, iterative mergesort that\\n     * requires far fewer than n lg(n) comparisons when the input array is\\n     * partially sorted, while offering the performance of a traditional\\n     * mergesort when the input array is randomly ordered.  If the input array\\n     * is nearly sorted, the implementation requires approximately n\\n     * comparisons.  Temporary storage requirements vary from a small constant\\n     * for nearly sorted input arrays to n/2 object references for randomly\\n     * ordered input arrays.\\n     *\\n     * \u003cp\u003eThe implementation takes equal advantage of ascending and\\n     * descending order in its input array, and can take advantage of\\n     * ascending and descending order in different parts of the same\\n     * input array.  It is well-suited to merging two or more sorted arrays:\\n     * simply concatenate the arrays and sort the resulting array.\\n     *\\n     * \u003cp\u003eThe implementation was adapted from Tim Peters\\\u0027s list sort for Python\\n     * (\u003ca href=\"http://svn.python.org/projects/python/trunk/Objects/listsort.txt\"\u003e\\n     * TimSort\u003c/a\u003e).  It uses techniques from Peter McIlroy\\\u0027s \"Optimistic\\n     * Sorting and Information Theoretic Complexity\", in Proceedings of the\\n     * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,\\n     * January 1993.\\n     *\\n     * @param c the {@code Comparator} used to compare list elements.\\n     *          A {@code null} value indicates that the elements\\\u0027\\n     *          {@linkplain Comparable natural ordering} should be used\\n     * @throws ClassCastException if the list contains elements that are not\\n     *         \u003ci\u003emutually comparable\u003c/i\u003e using the specified comparator\\n     * @throws UnsupportedOperationException if the list\\\u0027s list-iterator does\\n     *         not support the {@code set} operation\\n     * @throws IllegalArgumentException\\n     *         (\u003ca href=\"Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     *         if the comparator is found to violate the {@link Comparator}\\n     *         contract\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "sort(List)", "label": "sort(List)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "hashCode", "label": "hashCode", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " E get(int index)", "label": " E get(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the element at the specified position in this list.\\n     *\\n     * @param index index of the element to return\\n     * @return the element at the specified position in this list\\n     * @throws IndexOutOfBoundsException if the index is out of range\\n     *         ({@code index \u003c 0 || index \u003e= size()})\\n     \u0027}"}, {"color": "#97c2fc", "id": " E set(int index, E element)", "label": " E set(int index, E element)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Replaces the element at the specified position in this list with the\\n     * specified element (optional operation).\\n     *\\n     * @param index index of the element to replace\\n     * @param element element to be stored at the specified position\\n     * @return the element previously at the specified position\\n     * @throws UnsupportedOperationException if the {@code set} operation\\n     *         is not supported by this list\\n     * @throws ClassCastException if the class of the specified element\\n     *         prevents it from being added to this list\\n     * @throws NullPointerException if the specified element is null and\\n     *         this list does not permit null elements\\n     * @throws IllegalArgumentException if some property of the specified\\n     *         element prevents it from being added to this list\\n     * @throws IndexOutOfBoundsException if the index is out of range\\n     *         ({@code index \u003c 0 || index \u003e= size()})\\n     \u0027}"}, {"color": "#97c2fc", "id": " void add(int index, E element)", "label": " void add(int index, E element)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts the specified element at the specified position in this list\\n     * (optional operation).  Shifts the element currently at that position\\n     * (if any) and any subsequent elements to the right (adds one to their\\n     * indices).\\n     *\\n     * @param index index at which the specified element is to be inserted\\n     * @param element element to be inserted\\n     * @throws UnsupportedOperationException if the {@code add} operation\\n     *         is not supported by this list\\n     * @throws ClassCastException if the class of the specified element\\n     *         prevents it from being added to this list\\n     * @throws NullPointerException if the specified element is null and\\n     *         this list does not permit null elements\\n     * @throws IllegalArgumentException if some property of the specified\\n     *         element prevents it from being added to this list\\n     * @throws IndexOutOfBoundsException if the index is out of range\\n     *         ({@code index \u003c 0 || index \u003e size()})\\n     \u0027}"}, {"color": "#97c2fc", "id": " E remove(int index)", "label": " E remove(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Removes the element at the specified position in this list (optional\\n     * operation).  Shifts any subsequent elements to the left (subtracts one\\n     * from their indices).  Returns the element that was removed from the\\n     * list.\\n     *\\n     * @param index the index of the element to be removed\\n     * @return the element previously at the specified position\\n     * @throws UnsupportedOperationException if the {@code remove} operation\\n     *         is not supported by this list\\n     * @throws IndexOutOfBoundsException if the index is out of range\\n     *         ({@code index \u003c 0 || index \u003e= size()})\\n     \u0027}"}, {"color": "#97c2fc", "id": " int indexOf(Object o)", "label": " int indexOf(Object o)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index of the first occurrence of the specified element\\n     * in this list, or -1 if this list does not contain the element.\\n     * More formally, returns the lowest index {@code i} such that\\n     * {@code Objects.equals(o, get(i))},\\n     * or -1 if there is no such index.\\n     *\\n     * @param o element to search for\\n     * @return the index of the first occurrence of the specified element in\\n     *         this list, or -1 if this list does not contain the element\\n     * @throws ClassCastException if the type of the specified element\\n     *         is incompatible with this list\\n     *         (\u003ca href=\"Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     * @throws NullPointerException if the specified element is null and this\\n     *         list does not permit null elements\\n     *         (\u003ca href=\"Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     \u0027}"}, {"color": "#97c2fc", "id": " int lastIndexOf(Object o)", "label": " int lastIndexOf(Object o)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index of the last occurrence of the specified element\\n     * in this list, or -1 if this list does not contain the element.\\n     * More formally, returns the highest index {@code i} such that\\n     * {@code Objects.equals(o, get(i))},\\n     * or -1 if there is no such index.\\n     *\\n     * @param o element to search for\\n     * @return the index of the last occurrence of the specified element in\\n     *         this list, or -1 if this list does not contain the element\\n     * @throws ClassCastException if the type of the specified element\\n     *         is incompatible with this list\\n     *         (\u003ca href=\"Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     * @throws NullPointerException if the specified element is null and this\\n     *         list does not permit null elements\\n     *         (\u003ca href=\"Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     \u0027}"}, {"color": "#97c2fc", "id": " ListIterator\u003cE\u003e listIterator()", "label": " ListIterator\u003cE\u003e listIterator()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a list iterator over the elements in this list (in proper\\n     * sequence).\\n     *\\n     * @return a list iterator over the elements in this list (in proper\\n     *         sequence)\\n     \u0027}"}, {"color": "#97c2fc", "id": " ListIterator\u003cE\u003e listIterator(int index)", "label": " ListIterator\u003cE\u003e listIterator(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a list iterator over the elements in this list (in proper\\n     * sequence), starting at the specified position in the list.\\n     * The specified index indicates the first element that would be\\n     * returned by an initial call to {@link ListIterator#next next}.\\n     * An initial call to {@link ListIterator#previous previous} would\\n     * return the element with the specified index minus one.\\n     *\\n     * @param index index of the first element to be returned from the\\n     *        list iterator (by a call to {@link ListIterator#next next})\\n     * @return a list iterator over the elements in this list (in proper\\n     *         sequence), starting at the specified position in the list\\n     * @throws IndexOutOfBoundsException if the index is out of range\\n     *         ({@code index \u003c 0 || index \u003e size()})\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.util.ListIterator", "label": "java.util.ListIterator", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * An iterator for lists that allows the programmer\\n * to traverse the list in either direction, modify\\n * the list during iteration, and obtain the iterator\\\u0027s\\n * current position in the list. A {@code ListIterator}\\n * has no current element; its \u003cI\u003ecursor position\u003c/I\u003e always\\n * lies between the element that would be returned by a call\\n * to {@code previous()} and the element that would be\\n * returned by a call to {@code next()}.\\n * An iterator for a list of length {@code n} has {@code n+1} possible\\n * cursor positions, as illustrated by the carets ({@code ^}) below:\\n * \u003cPRE\u003e\\n *                      Element(0)   Element(1)   Element(2)   ... Element(n-1)\\n * cursor positions:  ^            ^            ^            ^                  ^\\n * \u003c/PRE\u003e\\n * Note that the {@link #remove} and {@link #set(Object)} methods are\\n * \u003ci\u003enot\u003c/i\u003e defined in terms of the cursor position;  they are defined to\\n * operate on the last element returned by a call to {@link #next} or\\n * {@link #previous()}.\\n *\\n * \u003cp\u003eThis interface is a member of the\\n * \u003ca href=\"{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework\"\u003e\\n * Java Collections Framework\u003c/a\u003e.\\n *\\n * @author  Josh Bloch\\n * @see Collection\\n * @see List\\n * @see Iterator\\n * @see Enumeration\\n * @see List#listIterator()\\n * @since   1.2\\n \u0027}"}, {"color": "#97c2fc", "id": "previous", "label": "previous", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " boolean hasPrevious()", "label": " boolean hasPrevious()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if this list iterator has more elements when\\n     * traversing the list in the reverse direction.  (In other words,\\n     * returns {@code true} if {@link #previous} would return an element\\n     * rather than throwing an exception.)\\n     *\\n     * @return {@code true} if the list iterator has more elements when\\n     *         traversing the list in the reverse direction\\n     \u0027}"}, {"color": "#97c2fc", "id": " E previous()", "label": " E previous()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the previous element in the list and moves the cursor\\n     * position backwards.  This method may be called repeatedly to\\n     * iterate through the list backwards, or intermixed with calls to\\n     * {@link #next} to go back and forth.  (Note that alternating calls\\n     * to {@code next} and {@code previous} will return the same\\n     * element repeatedly.)\\n     *\\n     * @return the previous element in the list\\n     * @throws NoSuchElementException if the iteration has no previous\\n     *         element\\n     \u0027}"}, {"color": "#97c2fc", "id": " int nextIndex()", "label": " int nextIndex()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index of the element that would be returned by a\\n     * subsequent call to {@link #next}. (Returns list size if the list\\n     * iterator is at the end of the list.)\\n     *\\n     * @return the index of the element that would be returned by a\\n     *         subsequent call to {@code next}, or list size if the list\\n     *         iterator is at the end of the list\\n     \u0027}"}, {"color": "#97c2fc", "id": " int previousIndex()", "label": " int previousIndex()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index of the element that would be returned by a\\n     * subsequent call to {@link #previous}. (Returns -1 if the list\\n     * iterator is at the beginning of the list.)\\n     *\\n     * @return the index of the element that would be returned by a\\n     *         subsequent call to {@code previous}, or -1 if the list\\n     *         iterator is at the beginning of the list\\n     \u0027}"}, {"color": "#97c2fc", "id": " void set(E e)", "label": " void set(E e)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Replaces the last element returned by {@link #next} or\\n     * {@link #previous} with the specified element (optional operation).\\n     * This call can be made only if neither {@link #remove} nor {@link\\n     * #add} have been called after the last call to {@code next} or\\n     * {@code previous}.\\n     *\\n     * @param e the element with which to replace the last element returned by\\n     *          {@code next} or {@code previous}\\n     * @throws UnsupportedOperationException if the {@code set} operation\\n     *         is not supported by this list iterator\\n     * @throws ClassCastException if the class of the specified element\\n     *         prevents it from being added to this list\\n     * @throws IllegalArgumentException if some aspect of the specified\\n     *         element prevents it from being added to this list\\n     * @throws IllegalStateException if neither {@code next} nor\\n     *         {@code previous} have been called, or {@code remove} or\\n     *         {@code add} have been called after the last call to\\n     *         {@code next} or {@code previous}\\n     \u0027}"}, {"color": "#97c2fc", "id": " void add(E e)", "label": " void add(E e)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Inserts the specified element into the list (optional operation).\\n     * The element is inserted immediately before the element that\\n     * would be returned by {@link #next}, if any, and after the element\\n     * that would be returned by {@link #previous}, if any.  (If the\\n     * list contains no elements, the new element becomes the sole element\\n     * on the list.)  The new element is inserted before the implicit\\n     * cursor: a subsequent call to {@code next} would be unaffected, and a\\n     * subsequent call to {@code previous} would return the new element.\\n     * (This call increases by one the value that would be returned by a\\n     * call to {@code nextIndex} or {@code previousIndex}.)\\n     *\\n     * @param e the element to insert\\n     * @throws UnsupportedOperationException if the {@code add} method is\\n     *         not supported by this list iterator\\n     * @throws ClassCastException if the class of the specified element\\n     *         prevents it from being added to this list\\n     * @throws IllegalArgumentException if some aspect of this element\\n     *         prevents it from being added to this list\\n     \u0027}"}, {"color": "#97c2fc", "id": " List\u003cE\u003e subList(int fromIndex, int toIndex)", "label": " List\u003cE\u003e subList(int fromIndex, int toIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a view of the portion of this list between the specified\\n     * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.  (If\\n     * {@code fromIndex} and {@code toIndex} are equal, the returned list is\\n     * empty.)  The returned list is backed by this list, so non-structural\\n     * changes in the returned list are reflected in this list, and vice-versa.\\n     * The returned list supports all of the optional list operations supported\\n     * by this list.\u003cp\u003e\\n     *\\n     * This method eliminates the need for explicit range operations (of\\n     * the sort that commonly exist for arrays).  Any operation that expects\\n     * a list can be used as a range operation by passing a subList view\\n     * instead of a whole list.  For example, the following idiom\\n     * removes a range of elements from a list:\\n     * \u003cpre\u003e{@code\\n     *      list.subList(from, to).clear();\\n     * }\u003c/pre\u003e\\n     * Similar idioms may be constructed for {@code indexOf} and\\n     * {@code lastIndexOf}, and all of the algorithms in the\\n     * {@code Collections} class can be applied to a subList.\u003cp\u003e\\n     *\\n     * The semantics of the list returned by this method become undefined if\\n     * the backing list (i.e., this list) is \u003ci\u003estructurally modified\u003c/i\u003e in\\n     * any way other than via the returned list.  (Structural modifications are\\n     * those that change the size of this list, or otherwise perturb it in such\\n     * a fashion that iterations in progress may yield incorrect results.)\\n     *\\n     * @param fromIndex low endpoint (inclusive) of the subList\\n     * @param toIndex high endpoint (exclusive) of the subList\\n     * @return a view of the specified range within this list\\n     * @throws IndexOutOfBoundsException for an illegal endpoint index value\\n     *         ({@code fromIndex \u003c 0 || toIndex \u003e size ||\\n     *         fromIndex \u003e toIndex})\\n     \u0027}"}, {"color": "#97c2fc", "id": "modCount", "label": "modCount", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.util.AbstractList", "label": "java.util.AbstractList", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public boolean add(E e)", "label": "public boolean add(E e)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Appends the specified element to the end of this list (optional\\n     * operation).\\n     *\\n     * \u003cp\u003eLists that support this operation may place limitations on what\\n     * elements may be added to this list.  In particular, some\\n     * lists will refuse to add null elements, and others will impose\\n     * restrictions on the type of elements that may be added.  List\\n     * classes should clearly specify in their documentation any restrictions\\n     * on what elements may be added.\\n     *\\n     * @implSpec\\n     * This implementation calls {@code add(size(), e)}.\\n     *\\n     * \u003cp\u003eNote that this implementation throws an\\n     * {@code UnsupportedOperationException} unless\\n     * {@link #add(int, Object) add(int, E)} is overridden.\\n     *\\n     * @param e element to be appended to this list\\n     * @return {@code true} (as specified by {@link Collection#add})\\n     * @throws UnsupportedOperationException if the {@code add} operation\\n     *         is not supported by this list\\n     * @throws ClassCastException if the class of the specified element\\n     *         prevents it from being added to this list\\n     * @throws NullPointerException if the specified element is null and this\\n     *         list does not permit null elements\\n     * @throws IllegalArgumentException if some property of this element\\n     *         prevents it from being added to this list\\n     \u0027}"}, {"color": "#97c2fc", "id": "add(int", "label": "add(int", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract E get(int index)", "label": "public abstract E get(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * {@inheritDoc}\\n     *\\n     * @throws IndexOutOfBoundsException {@inheritDoc}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public E set(int index, E element)", "label": "public E set(int index, E element)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * {@inheritDoc}\\n     *\\n     * @implSpec\\n     * This implementation always throws an\\n     * {@code UnsupportedOperationException}.\\n     *\\n     * @throws UnsupportedOperationException {@inheritDoc}\\n     * @throws ClassCastException            {@inheritDoc}\\n     * @throws NullPointerException          {@inheritDoc}\\n     * @throws IllegalArgumentException      {@inheritDoc}\\n     * @throws IndexOutOfBoundsException     {@inheritDoc}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void add(int index, E element)", "label": "public void add(int index, E element)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * {@inheritDoc}\\n     *\\n     * @implSpec\\n     * This implementation always throws an\\n     * {@code UnsupportedOperationException}.\\n     *\\n     * @throws UnsupportedOperationException {@inheritDoc}\\n     * @throws ClassCastException            {@inheritDoc}\\n     * @throws NullPointerException          {@inheritDoc}\\n     * @throws IllegalArgumentException      {@inheritDoc}\\n     * @throws IndexOutOfBoundsException     {@inheritDoc}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public E remove(int index)", "label": "public E remove(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * {@inheritDoc}\\n     *\\n     * @implSpec\\n     * This implementation always throws an\\n     * {@code UnsupportedOperationException}.\\n     *\\n     * @throws UnsupportedOperationException {@inheritDoc}\\n     * @throws IndexOutOfBoundsException     {@inheritDoc}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int indexOf(Object o)", "label": "public int indexOf(Object o)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * {@inheritDoc}\\n     *\\n     * @implSpec\\n     * This implementation first gets a list iterator (with\\n     * {@code listIterator()}).  Then, it iterates over the list until the\\n     * specified element is found or the end of the list is reached.\\n     *\\n     * @throws ClassCastException   {@inheritDoc}\\n     * @throws NullPointerException {@inheritDoc}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int lastIndexOf(Object o)", "label": "public int lastIndexOf(Object o)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * {@inheritDoc}\\n     *\\n     * @implSpec\\n     * This implementation first gets a list iterator that points to the end\\n     * of the list (with {@code listIterator(size())}).  Then, it iterates\\n     * backwards over the list until the specified element is found, or the\\n     * beginning of the list is reached.\\n     *\\n     * @throws ClassCastException   {@inheritDoc}\\n     * @throws NullPointerException {@inheritDoc}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void clear()", "label": "public void clear()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Removes all of the elements from this list (optional operation).\\n     * The list will be empty after this call returns.\\n     *\\n     * @implSpec\\n     * This implementation calls {@code removeRange(0, size())}.\\n     *\\n     * \u003cp\u003eNote that this implementation throws an\\n     * {@code UnsupportedOperationException} unless {@code remove(int\\n     * index)} or {@code removeRange(int fromIndex, int toIndex)} is\\n     * overridden.\\n     *\\n     * @throws UnsupportedOperationException if the {@code clear} operation\\n     *         is not supported by this list\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean addAll(int index, Collection\u003c? extends E\u003e c)", "label": "public boolean addAll(int index, Collection\u003c? extends E\u003e c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * {@inheritDoc}\\n     *\\n     * @implSpec\\n     * This implementation gets an iterator over the specified collection\\n     * and iterates over it, inserting the elements obtained from the\\n     * iterator into this list at the appropriate position, one at a time,\\n     * using {@code add(int, E)}.\\n     * Many implementations will override this method for efficiency.\\n     *\\n     * \u003cp\u003eNote that this implementation throws an\\n     * {@code UnsupportedOperationException} unless\\n     * {@link #add(int, Object) add(int, E)} is overridden.\\n     *\\n     * @throws UnsupportedOperationException {@inheritDoc}\\n     * @throws ClassCastException            {@inheritDoc}\\n     * @throws NullPointerException          {@inheritDoc}\\n     * @throws IllegalArgumentException      {@inheritDoc}\\n     * @throws IndexOutOfBoundsException     {@inheritDoc}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Iterator\u003cE\u003e iterator()", "label": "public Iterator\u003cE\u003e iterator()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns an iterator over the elements in this list in proper sequence.\\n     *\\n     * @implSpec\\n     * This implementation returns a straightforward implementation of the\\n     * iterator interface, relying on the backing list\u0027s {@code size()},\\n     * {@code get(int)}, and {@code remove(int)} methods.\\n     *\\n     * \u003cp\u003eNote that the iterator returned by this method will throw an\\n     * {@link UnsupportedOperationException} in response to its\\n     * {@code remove} method unless the list\u0027s {@code remove(int)} method is\\n     * overridden.\\n     *\\n     * \u003cp\u003eThis implementation can be made to throw runtime exceptions in the\\n     * face of concurrent modification, as described in the specification\\n     * for the (protected) {@link #modCount} field.\\n     *\\n     * @return an iterator over the elements in this list in proper sequence\\n     \"}"}, {"color": "#97c2fc", "id": "public ListIterator\u003cE\u003e listIterator()", "label": "public ListIterator\u003cE\u003e listIterator()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * {@inheritDoc}\\n     *\\n     * @implSpec\\n     * This implementation returns {@code listIterator(0)}.\\n     *\\n     * @see #listIterator(int)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ListIterator\u003cE\u003e listIterator(final int index)", "label": "public ListIterator\u003cE\u003e listIterator(final int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * {@inheritDoc}\\n     *\\n     * @implSpec\\n     * This implementation returns a straightforward implementation of the\\n     * {@code ListIterator} interface that extends the implementation of the\\n     * {@code Iterator} interface returned by the {@code iterator()} method.\\n     * The {@code ListIterator} implementation relies on the backing list\u0027s\\n     * {@code get(int)}, {@code set(int, E)}, {@code add(int, E)}\\n     * and {@code remove(int)} methods.\\n     *\\n     * \u003cp\u003eNote that the list iterator returned by this implementation will\\n     * throw an {@link UnsupportedOperationException} in response to its\\n     * {@code remove}, {@code set} and {@code add} methods unless the\\n     * list\u0027s {@code remove(int)}, {@code set(int, E)}, and\\n     * {@code add(int, E)} methods are overridden.\\n     *\\n     * \u003cp\u003eThis implementation can be made to throw runtime exceptions in the\\n     * face of concurrent modification, as described in the specification for\\n     * the (protected) {@link #modCount} field.\\n     *\\n     * @throws IndexOutOfBoundsException {@inheritDoc}\\n     \"}"}, {"color": "#97c2fc", "id": "public List\u003cE\u003e subList(int fromIndex, int toIndex)", "label": "public List\u003cE\u003e subList(int fromIndex, int toIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * {@inheritDoc}\\n     *\\n     * @implSpec\\n     * This implementation returns a list that subclasses\\n     * {@code AbstractList}.  The subclass stores, in private fields, the\\n     * size of the subList (which can change over its lifetime), and the\\n     * expected {@code modCount} value of the backing list.  There are two\\n     * variants of the subclass, one of which implements {@code RandomAccess}.\\n     * If this list implements {@code RandomAccess} the returned list will\\n     * be an instance of the subclass that implements {@code RandomAccess}.\\n     *\\n     * \u003cp\u003eThe subclass\\\u0027s {@code set(int, E)}, {@code get(int)},\\n     * {@code add(int, E)}, {@code remove(int)}, {@code addAll(int,\\n     * Collection)} and {@code removeRange(int, int)} methods all\\n     * delegate to the corresponding methods on the backing abstract list,\\n     * after bounds-checking the index and adjusting for the offset.  The\\n     * {@code addAll(Collection c)} method merely returns {@code addAll(size,\\n     * c)}.\\n     *\\n     * \u003cp\u003eThe {@code listIterator(int)} method returns a \"wrapper object\"\\n     * over a list iterator on the backing list, which is created with the\\n     * corresponding method on the backing list.  The {@code iterator} method\\n     * merely returns {@code listIterator()}, and the {@code size} method\\n     * merely returns the subclass\\\u0027s {@code size} field.\\n     *\\n     * \u003cp\u003eAll methods first check to see if the actual {@code modCount} of\\n     * the backing list is equal to its expected value, and throw a\\n     * {@code ConcurrentModificationException} if it is not.\\n     *\\n     * @throws IndexOutOfBoundsException if an endpoint index value is out of range\\n     *         {@code (fromIndex \u003c 0 || toIndex \u003e size)}\\n     * @throws IllegalArgumentException if the endpoint indices are out of order\\n     *         {@code (fromIndex \u003e toIndex)}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean equals(Object o)", "label": "public boolean equals(Object o)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares the specified object with this list for equality.  Returns\\n     * {@code true} if and only if the specified object is also a list, both\\n     * lists have the same size, and all corresponding pairs of elements in\\n     * the two lists are \u003ci\u003eequal\u003c/i\u003e.  (Two elements {@code e1} and\\n     * {@code e2} are \u003ci\u003eequal\u003c/i\u003e if {@code (e1==null ? e2==null :\\n     * e1.equals(e2))}.)  In other words, two lists are defined to be\\n     * equal if they contain the same elements in the same order.\\n     *\\n     * @implSpec\\n     * This implementation first checks if the specified object is this\\n     * list. If so, it returns {@code true}; if not, it checks if the\\n     * specified object is a list. If not, it returns {@code false}; if so,\\n     * it iterates over both lists, comparing corresponding pairs of elements.\\n     * If any comparison returns {@code false}, this method returns\\n     * {@code false}.  If either iterator runs out of elements before the\\n     * other it returns {@code false} (as the lists are of unequal length);\\n     * otherwise it returns {@code true} when the iterations complete.\\n     *\\n     * @param o the object to be compared for equality with this list\\n     * @return {@code true} if the specified object is equal to this list\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int hashCode()", "label": "public int hashCode()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a hash code for this {@code Double} object. The\\n     * result is the exclusive OR of the two halves of the\\n     * {@code long} integer bit representation, exactly as\\n     * produced by the method {@link #doubleToLongBits(double)}, of\\n     * the primitive {@code double} value represented by this\\n     * {@code Double} object. That is, the hash code is the value\\n     * of the expression:\\n     *\\n     * \u003cblockquote\u003e\\n     *  {@code (int)(v^(v\u003e\u003e\u003e32))}\\n     * \u003c/blockquote\u003e\\n     *\\n     * where {@code v} is defined by:\\n     *\\n     * \u003cblockquote\u003e\\n     *  {@code long v = Double.doubleToLongBits(this.doubleValue());}\\n     * \u003c/blockquote\u003e\\n     *\\n     * @return  a {@code hash code} value for this object.\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected void removeRange(int fromIndex, int toIndex)", "label": "protected void removeRange(int fromIndex, int toIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Removes from this list all of the elements whose index is between\\n     * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.\\n     * Shifts any succeeding elements to the left (reduces their index).\\n     * This call shortens the list by {@code (toIndex - fromIndex)} elements.\\n     * (If {@code toIndex==fromIndex}, this operation has no effect.)\\n     *\\n     * \u003cp\u003eThis method is called by the {@code clear} operation on this list\\n     * and its subLists.  Overriding this method to take advantage of\\n     * the internals of the list implementation can \u003ci\u003esubstantially\u003c/i\u003e\\n     * improve the performance of the {@code clear} operation on this list\\n     * and its subLists.\\n     *\\n     * @implSpec\\n     * This implementation gets a list iterator positioned before\\n     * {@code fromIndex}, and repeatedly calls {@code ListIterator.next}\\n     * followed by {@code ListIterator.remove} until the entire range has\\n     * been removed.  \u003cb\u003eNote: if {@code ListIterator.remove} requires linear\\n     * time, this implementation requires quadratic time.\u003c/b\u003e\\n     *\\n     * @param fromIndex index of first element to be removed\\n     * @param toIndex index after last element to be removed\\n     \u0027}"}, {"color": "#97c2fc", "id": "get", "label": "get", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " void addFirst(E e)", "label": " void addFirst(E e)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * {@inheritDoc}\\n     *\\n     * @implSpec\\n     * The implementation in this interface calls {@code add(0, e)}.\\n     *\\n     * @throws NullPointerException {@inheritDoc}\\n     * @throws UnsupportedOperationException {@inheritDoc}\\n     * @since 21\\n     \u0027}"}, {"color": "#97c2fc", "id": " void addLast(E e)", "label": " void addLast(E e)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * {@inheritDoc}\\n     *\\n     * @implSpec\\n     * The implementation in this interface calls {@code add(e)}.\\n     *\\n     * @throws NullPointerException {@inheritDoc}\\n     * @throws UnsupportedOperationException {@inheritDoc}\\n     * @since 21\\n     \u0027}"}, {"color": "#97c2fc", "id": " E getFirst()", "label": " E getFirst()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * {@inheritDoc}\\n     *\\n     * @implSpec\\n     * If this List is not empty, the implementation in this interface returns the result\\n     * of calling {@code get(0)}. Otherwise, it throws {@code NoSuchElementException}.\\n     *\\n     * @throws NoSuchElementException {@inheritDoc}\\n     * @since 21\\n     \u0027}"}, {"color": "#97c2fc", "id": " E getLast()", "label": " E getLast()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * {@inheritDoc}\\n     *\\n     * @implSpec\\n     * If this List is not empty, the implementation in this interface returns the result\\n     * of calling {@code get(size() - 1)}. Otherwise, it throws {@code NoSuchElementException}.\\n     *\\n     * @throws NoSuchElementException {@inheritDoc}\\n     * @since 21\\n     \u0027}"}, {"color": "#97c2fc", "id": " E removeFirst()", "label": " E removeFirst()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * {@inheritDoc}\\n     *\\n     * @implSpec\\n     * If this List is not empty, the implementation in this interface returns the result\\n     * of calling {@code remove(0)}. Otherwise, it throws {@code NoSuchElementException}.\\n     *\\n     * @throws NoSuchElementException {@inheritDoc}\\n     * @throws UnsupportedOperationException {@inheritDoc}\\n     * @since 21\\n     \u0027}"}, {"color": "#97c2fc", "id": " E removeLast()", "label": " E removeLast()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * {@inheritDoc}\\n     *\\n     * @implSpec\\n     * If this List is not empty, the implementation in this interface returns the result\\n     * of calling {@code remove(size() - 1)}. Otherwise, it throws {@code NoSuchElementException}.\\n     *\\n     * @throws NoSuchElementException {@inheritDoc}\\n     * @throws UnsupportedOperationException {@inheritDoc}\\n     * @since 21\\n     \u0027}"}, {"color": "#97c2fc", "id": " List\u003cE\u003e reversed()", "label": " List\u003cE\u003e reversed()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * {@inheritDoc}\\n     *\\n     * @implSpec\\n     * The implementation in this interface returns a reverse-ordered List\\n     * view. The {@code reversed()} method of the view returns a reference\\n     * to this List. Other operations on the view are implemented via calls to\\n     * public methods on this List. The exact relationship between calls on the\\n     * view and calls on this List is unspecified. However, order-sensitive\\n     * operations generally delegate to the appropriate method with the opposite\\n     * orientation. For example, calling {@code getFirst} on the view results in\\n     * a call to {@code getLast} on this List.\\n     *\\n     * @return a reverse-ordered view of this collection, as a {@code List}\\n     * @since 21\\n     \u0027}"}, {"color": "#97c2fc", "id": " static List\u003cE\u003e of()", "label": " static List\u003cE\u003e of()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable list containing zero elements.\\n     *\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Lists\u003c/a\u003e for details.\\n     *\\n     * @param \u003cE\u003e the {@code List}\\\u0027s element type\\n     * @return an empty {@code List}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static List\u003cE\u003e of(E e1)", "label": " static List\u003cE\u003e of(E e1)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable list containing one element.\\n     *\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Lists\u003c/a\u003e for details.\\n     *\\n     * @param \u003cE\u003e the {@code List}\\\u0027s element type\\n     * @param e1 the single element\\n     * @return a {@code List} containing the specified element\\n     * @throws NullPointerException if the element is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static List\u003cE\u003e of(E e1, E e2)", "label": " static List\u003cE\u003e of(E e1, E e2)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable list containing two elements.\\n     *\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Lists\u003c/a\u003e for details.\\n     *\\n     * @param \u003cE\u003e the {@code List}\\\u0027s element type\\n     * @param e1 the first element\\n     * @param e2 the second element\\n     * @return a {@code List} containing the specified elements\\n     * @throws NullPointerException if an element is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static List\u003cE\u003e of(E e1, E e2, E e3)", "label": " static List\u003cE\u003e of(E e1, E e2, E e3)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable list containing three elements.\\n     *\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Lists\u003c/a\u003e for details.\\n     *\\n     * @param \u003cE\u003e the {@code List}\\\u0027s element type\\n     * @param e1 the first element\\n     * @param e2 the second element\\n     * @param e3 the third element\\n     * @return a {@code List} containing the specified elements\\n     * @throws NullPointerException if an element is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static List\u003cE\u003e of(E e1, E e2, E e3, E e4)", "label": " static List\u003cE\u003e of(E e1, E e2, E e3, E e4)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable list containing four elements.\\n     *\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Lists\u003c/a\u003e for details.\\n     *\\n     * @param \u003cE\u003e the {@code List}\\\u0027s element type\\n     * @param e1 the first element\\n     * @param e2 the second element\\n     * @param e3 the third element\\n     * @param e4 the fourth element\\n     * @return a {@code List} containing the specified elements\\n     * @throws NullPointerException if an element is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static List\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5)", "label": " static List\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable list containing five elements.\\n     *\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Lists\u003c/a\u003e for details.\\n     *\\n     * @param \u003cE\u003e the {@code List}\\\u0027s element type\\n     * @param e1 the first element\\n     * @param e2 the second element\\n     * @param e3 the third element\\n     * @param e4 the fourth element\\n     * @param e5 the fifth element\\n     * @return a {@code List} containing the specified elements\\n     * @throws NullPointerException if an element is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static List\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6)", "label": " static List\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable list containing six elements.\\n     *\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Lists\u003c/a\u003e for details.\\n     *\\n     * @param \u003cE\u003e the {@code List}\\\u0027s element type\\n     * @param e1 the first element\\n     * @param e2 the second element\\n     * @param e3 the third element\\n     * @param e4 the fourth element\\n     * @param e5 the fifth element\\n     * @param e6 the sixth element\\n     * @return a {@code List} containing the specified elements\\n     * @throws NullPointerException if an element is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static List\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6, E e7)", "label": " static List\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6, E e7)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable list containing seven elements.\\n     *\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Lists\u003c/a\u003e for details.\\n     *\\n     * @param \u003cE\u003e the {@code List}\\\u0027s element type\\n     * @param e1 the first element\\n     * @param e2 the second element\\n     * @param e3 the third element\\n     * @param e4 the fourth element\\n     * @param e5 the fifth element\\n     * @param e6 the sixth element\\n     * @param e7 the seventh element\\n     * @return a {@code List} containing the specified elements\\n     * @throws NullPointerException if an element is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static List\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)", "label": " static List\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable list containing eight elements.\\n     *\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Lists\u003c/a\u003e for details.\\n     *\\n     * @param \u003cE\u003e the {@code List}\\\u0027s element type\\n     * @param e1 the first element\\n     * @param e2 the second element\\n     * @param e3 the third element\\n     * @param e4 the fourth element\\n     * @param e5 the fifth element\\n     * @param e6 the sixth element\\n     * @param e7 the seventh element\\n     * @param e8 the eighth element\\n     * @return a {@code List} containing the specified elements\\n     * @throws NullPointerException if an element is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static List\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)", "label": " static List\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable list containing nine elements.\\n     *\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Lists\u003c/a\u003e for details.\\n     *\\n     * @param \u003cE\u003e the {@code List}\\\u0027s element type\\n     * @param e1 the first element\\n     * @param e2 the second element\\n     * @param e3 the third element\\n     * @param e4 the fourth element\\n     * @param e5 the fifth element\\n     * @param e6 the sixth element\\n     * @param e7 the seventh element\\n     * @param e8 the eighth element\\n     * @param e9 the ninth element\\n     * @return a {@code List} containing the specified elements\\n     * @throws NullPointerException if an element is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static List\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)", "label": " static List\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable list containing ten elements.\\n     *\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Lists\u003c/a\u003e for details.\\n     *\\n     * @param \u003cE\u003e the {@code List}\\\u0027s element type\\n     * @param e1 the first element\\n     * @param e2 the second element\\n     * @param e3 the third element\\n     * @param e4 the fourth element\\n     * @param e5 the fifth element\\n     * @param e6 the sixth element\\n     * @param e7 the seventh element\\n     * @param e8 the eighth element\\n     * @param e9 the ninth element\\n     * @param e10 the tenth element\\n     * @return a {@code List} containing the specified elements\\n     * @throws NullPointerException if an element is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static List\u003cE\u003e of(E... elements)", "label": " static List\u003cE\u003e of(E... elements)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable list containing an arbitrary number of elements.\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Lists\u003c/a\u003e for details.\\n     *\\n     * @apiNote\\n     * This method also accepts a single array as an argument. The element type of\\n     * the resulting list will be the component type of the array, and the size of\\n     * the list will be equal to the length of the array. To create a list with\\n     * a single element that is an array, do the following:\\n     *\\n     * \u003cpre\u003e{@code\\n     *     String[] array = ... ;\\n     *     List\u003cString[]\u003e list = List.\u003cString[]\u003eof(array);\\n     * }\u003c/pre\u003e\\n     *\\n     * This will cause the {@link List#of(Object) List.of(E)} method\\n     * to be invoked instead.\\n     *\\n     * @param \u003cE\u003e the {@code List}\\\u0027s element type\\n     * @param elements the elements to be contained in the list\\n     * @return a {@code List} containing the specified elements\\n     * @throws NullPointerException if an element is {@code null} or if the array is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "of(Object)", "label": "of(Object)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " static List\u003cE\u003e copyOf(Collection\u003c? extends E\u003e coll)", "label": " static List\u003cE\u003e copyOf(Collection\u003c? extends E\u003e coll)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an \u003ca href=\"#unmodifiable\"\u003eunmodifiable List\u003c/a\u003e containing the elements of\\n     * the given Collection, in its iteration order. The given Collection must not be null,\\n     * and it must not contain any null elements. If the given Collection is subsequently\\n     * modified, the returned List will not reflect such modifications.\\n     *\\n     * @implNote\\n     * If the given Collection is an \u003ca href=\"#unmodifiable\"\u003eunmodifiable List\u003c/a\u003e,\\n     * calling copyOf will generally not create a copy.\\n     *\\n     * @param \u003cE\u003e the {@code List}\\\u0027s element type\\n     * @param coll a {@code Collection} from which elements are drawn, must be non-null\\n     * @return a {@code List} containing the elements of the given {@code Collection}\\n     * @throws NullPointerException if coll is null, or if it contains any nulls\\n     * @since 10\\n     \u0027}"}, {"color": "#97c2fc", "id": "Long", "label": "Long", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public static int hashCode(int[] a)", "label": "public static int hashCode(int[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a hash code based on the contents of the specified array.\\n     * For any two non-null {@code int} arrays {@code a} and {@code b}\\n     * such that {@code Arrays.equals(a, b)}, it is also the case that\\n     * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.\\n     *\\n     * \u003cp\u003eThe value returned by this method is the same value that would be\\n     * obtained by invoking the {@link List#hashCode() hashCode}\\n     * method on a {@link List} containing a sequence of {@link Integer}\\n     * instances representing the elements of {@code a} in the same order.\\n     * If {@code a} is {@code null}, this method returns 0.\\n     *\\n     * @param a the array whose hash value to compute\\n     * @return a content-based hash code for {@code a}\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "Integer", "label": "Integer", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public static int hashCode(short[] a)", "label": "public static int hashCode(short[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a hash code based on the contents of the specified array.\\n     * For any two {@code short} arrays {@code a} and {@code b}\\n     * such that {@code Arrays.equals(a, b)}, it is also the case that\\n     * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.\\n     *\\n     * \u003cp\u003eThe value returned by this method is the same value that would be\\n     * obtained by invoking the {@link List#hashCode() hashCode}\\n     * method on a {@link List} containing a sequence of {@link Short}\\n     * instances representing the elements of {@code a} in the same order.\\n     * If {@code a} is {@code null}, this method returns 0.\\n     *\\n     * @param a the array whose hash value to compute\\n     * @return a content-based hash code for {@code a}\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "Short", "label": "Short", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public static int hashCode(char[] a)", "label": "public static int hashCode(char[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a hash code based on the contents of the specified array.\\n     * For any two {@code char} arrays {@code a} and {@code b}\\n     * such that {@code Arrays.equals(a, b)}, it is also the case that\\n     * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.\\n     *\\n     * \u003cp\u003eThe value returned by this method is the same value that would be\\n     * obtained by invoking the {@link List#hashCode() hashCode}\\n     * method on a {@link List} containing a sequence of {@link Character}\\n     * instances representing the elements of {@code a} in the same order.\\n     * If {@code a} is {@code null}, this method returns 0.\\n     *\\n     * @param a the array whose hash value to compute\\n     * @return a content-based hash code for {@code a}\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "Character", "label": "Character", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public static int hashCode(byte[] a)", "label": "public static int hashCode(byte[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a hash code based on the contents of the specified array.\\n     * For any two {@code byte} arrays {@code a} and {@code b}\\n     * such that {@code Arrays.equals(a, b)}, it is also the case that\\n     * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.\\n     *\\n     * \u003cp\u003eThe value returned by this method is the same value that would be\\n     * obtained by invoking the {@link List#hashCode() hashCode}\\n     * method on a {@link List} containing a sequence of {@link Byte}\\n     * instances representing the elements of {@code a} in the same order.\\n     * If {@code a} is {@code null}, this method returns 0.\\n     *\\n     * @param a the array whose hash value to compute\\n     * @return a content-based hash code for {@code a}\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "Byte", "label": "Byte", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public static int hashCode(boolean[] a)", "label": "public static int hashCode(boolean[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a hash code based on the contents of the specified array.\\n     * For any two {@code boolean} arrays {@code a} and {@code b}\\n     * such that {@code Arrays.equals(a, b)}, it is also the case that\\n     * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.\\n     *\\n     * \u003cp\u003eThe value returned by this method is the same value that would be\\n     * obtained by invoking the {@link List#hashCode() hashCode}\\n     * method on a {@link List} containing a sequence of {@link Boolean}\\n     * instances representing the elements of {@code a} in the same order.\\n     * If {@code a} is {@code null}, this method returns 0.\\n     *\\n     * @param a the array whose hash value to compute\\n     * @return a content-based hash code for {@code a}\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "Boolean", "label": "Boolean", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public static int hashCode(float[] a)", "label": "public static int hashCode(float[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a hash code based on the contents of the specified array.\\n     * For any two {@code float} arrays {@code a} and {@code b}\\n     * such that {@code Arrays.equals(a, b)}, it is also the case that\\n     * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.\\n     *\\n     * \u003cp\u003eThe value returned by this method is the same value that would be\\n     * obtained by invoking the {@link List#hashCode() hashCode}\\n     * method on a {@link List} containing a sequence of {@link Float}\\n     * instances representing the elements of {@code a} in the same order.\\n     * If {@code a} is {@code null}, this method returns 0.\\n     *\\n     * @param a the array whose hash value to compute\\n     * @return a content-based hash code for {@code a}\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "Float", "label": "Float", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public static int hashCode(double[] a)", "label": "public static int hashCode(double[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a hash code based on the contents of the specified array.\\n     * For any two {@code double} arrays {@code a} and {@code b}\\n     * such that {@code Arrays.equals(a, b)}, it is also the case that\\n     * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.\\n     *\\n     * \u003cp\u003eThe value returned by this method is the same value that would be\\n     * obtained by invoking the {@link List#hashCode() hashCode}\\n     * method on a {@link List} containing a sequence of {@link Double}\\n     * instances representing the elements of {@code a} in the same order.\\n     * If {@code a} is {@code null}, this method returns 0.\\n     *\\n     * @param a the array whose hash value to compute\\n     * @return a content-based hash code for {@code a}\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "Double", "label": "Double", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public static int hashCode(Object[] a)", "label": "public static int hashCode(Object[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a hash code based on the contents of the specified array.  If\\n     * the array contains other arrays as elements, the hash code is based on\\n     * their identities rather than their contents.  It is therefore\\n     * acceptable to invoke this method on an array that contains itself as an\\n     * element,  either directly or indirectly through one or more levels of\\n     * arrays.\\n     *\\n     * \u003cp\u003eFor any two arrays {@code a} and {@code b} such that\\n     * {@code Arrays.equals(a, b)}, it is also the case that\\n     * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.\\n     *\\n     * \u003cp\u003eThe value returned by this method is equal to the value that would\\n     * be returned by {@code Arrays.asList(a).hashCode()}, unless {@code a}\\n     * is {@code null}, in which case {@code 0} is returned.\\n     *\\n     * @param a the array whose content-based hash code to compute\\n     * @return a content-based hash code for {@code a}\\n     * @see #deepHashCode(Object[])\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int deepHashCode(Object[] a)", "label": "public static int deepHashCode(Object[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a hash code based on the \"deep contents\" of the specified\\n     * array.  If the array contains other arrays as elements, the\\n     * hash code is based on their contents and so on, ad infinitum.\\n     * It is therefore unacceptable to invoke this method on an array that\\n     * contains itself as an element, either directly or indirectly through\\n     * one or more levels of arrays.  The behavior of such an invocation is\\n     * undefined.\\n     *\\n     * \u003cp\u003eFor any two arrays {@code a} and {@code b} such that\\n     * {@code Arrays.deepEquals(a, b)}, it is also the case that\\n     * {@code Arrays.deepHashCode(a) == Arrays.deepHashCode(b)}.\\n     *\\n     * \u003cp\u003eThe computation of the value returned by this method is similar to\\n     * that of the value returned by {@link List#hashCode()} on a list\\n     * containing the same elements as {@code a} in the same order, with one\\n     * difference: If an element {@code e} of {@code a} is itself an array,\\n     * its hash code is computed not by calling {@code e.hashCode()}, but as\\n     * by calling the appropriate overloading of {@code Arrays.hashCode(e)}\\n     * if {@code e} is an array of a primitive type, or as by calling\\n     * {@code Arrays.deepHashCode(e)} recursively if {@code e} is an array\\n     * of a reference type.  If {@code a} is {@code null}, this method\\n     * returns 0.\\n     *\\n     * @param a the array whose deep-content-based hash code to compute\\n     * @return a deep-content-based hash code for {@code a}\\n     * @see #hashCode(Object[])\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean deepEquals(Object[] a1, Object[] a2)", "label": "public static boolean deepEquals(Object[] a1, Object[] a2)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if the two specified arrays are \u003ci\u003edeeply\\n     * equal\u003c/i\u003e to one another.  Unlike the {@link #equals(Object[],Object[])}\\n     * method, this method is appropriate for use with nested arrays of\\n     * arbitrary depth.\\n     *\\n     * \u003cp\u003eTwo array references are considered deeply equal if both\\n     * are {@code null}, or if they refer to arrays that contain the same\\n     * number of elements and all corresponding pairs of elements in the two\\n     * arrays are deeply equal.\\n     *\\n     * \u003cp\u003eTwo possibly {@code null} elements {@code e1} and {@code e2} are\\n     * deeply equal if any of the following conditions hold:\\n     * \u003cul\u003e\\n     *    \u003cli\u003e {@code e1} and {@code e2} are both arrays of object reference\\n     *         types, and {@code Arrays.deepEquals(e1, e2) would return true}\\n     *    \u003cli\u003e {@code e1} and {@code e2} are arrays of the same primitive\\n     *         type, and the appropriate overloading of\\n     *         {@code Arrays.equals(e1, e2)} would return true.\\n     *    \u003cli\u003e {@code e1 == e2}\\n     *    \u003cli\u003e {@code e1.equals(e2)} would return true.\\n     * \u003c/ul\u003e\\n     * Note that this definition permits {@code null} elements at any depth.\\n     *\\n     * \u003cp\u003eIf either of the specified arrays contain themselves as elements\\n     * either directly or indirectly through one or more levels of arrays,\\n     * the behavior of this method is undefined.\\n     *\\n     * @param a1 one array to be tested for equality\\n     * @param a2 the other array to be tested for equality\\n     * @return {@code true} if the two arrays are equal\\n     * @see #equals(Object[],Object[])\\n     * @see Objects#deepEquals(Object, Object)\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "equals(Object", "label": "equals(Object", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static String toString(long[] a)", "label": "public static String toString(long[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string representation of the contents of the specified array.\\n     * The string representation consists of a list of the array\\\u0027s elements,\\n     * enclosed in square brackets ({@code \"[]\"}).  Adjacent elements are\\n     * separated by the characters {@code \", \"} (a comma followed by a\\n     * space).  Elements are converted to strings as by\\n     * {@code String.valueOf(long)}.  Returns {@code \"null\"} if {@code a}\\n     * is {@code null}.\\n     *\\n     * @param a the array whose string representation to return\\n     * @return a string representation of {@code a}\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String toString(int[] a)", "label": "public static String toString(int[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string representation of the contents of the specified array.\\n     * The string representation consists of a list of the array\\\u0027s elements,\\n     * enclosed in square brackets ({@code \"[]\"}).  Adjacent elements are\\n     * separated by the characters {@code \", \"} (a comma followed by a\\n     * space).  Elements are converted to strings as by\\n     * {@code String.valueOf(int)}.  Returns {@code \"null\"} if {@code a} is\\n     * {@code null}.\\n     *\\n     * @param a the array whose string representation to return\\n     * @return a string representation of {@code a}\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String toString(short[] a)", "label": "public static String toString(short[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string representation of the contents of the specified array.\\n     * The string representation consists of a list of the array\\\u0027s elements,\\n     * enclosed in square brackets ({@code \"[]\"}).  Adjacent elements are\\n     * separated by the characters {@code \", \"} (a comma followed by a\\n     * space).  Elements are converted to strings as by\\n     * {@code String.valueOf(short)}.  Returns {@code \"null\"} if {@code a}\\n     * is {@code null}.\\n     *\\n     * @param a the array whose string representation to return\\n     * @return a string representation of {@code a}\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String toString(char[] a)", "label": "public static String toString(char[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string representation of the contents of the specified array.\\n     * The string representation consists of a list of the array\\\u0027s elements,\\n     * enclosed in square brackets ({@code \"[]\"}).  Adjacent elements are\\n     * separated by the characters {@code \", \"} (a comma followed by a\\n     * space).  Elements are converted to strings as by\\n     * {@code String.valueOf(char)}.  Returns {@code \"null\"} if {@code a}\\n     * is {@code null}.\\n     *\\n     * @param a the array whose string representation to return\\n     * @return a string representation of {@code a}\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String toString(byte[] a)", "label": "public static String toString(byte[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string representation of the contents of the specified array.\\n     * The string representation consists of a list of the array\\\u0027s elements,\\n     * enclosed in square brackets ({@code \"[]\"}).  Adjacent elements\\n     * are separated by the characters {@code \", \"} (a comma followed\\n     * by a space).  Elements are converted to strings as by\\n     * {@code String.valueOf(byte)}.  Returns {@code \"null\"} if\\n     * {@code a} is {@code null}.\\n     *\\n     * @param a the array whose string representation to return\\n     * @return a string representation of {@code a}\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String toString(boolean[] a)", "label": "public static String toString(boolean[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string representation of the contents of the specified array.\\n     * The string representation consists of a list of the array\\\u0027s elements,\\n     * enclosed in square brackets ({@code \"[]\"}).  Adjacent elements are\\n     * separated by the characters {@code \", \"} (a comma followed by a\\n     * space).  Elements are converted to strings as by\\n     * {@code String.valueOf(boolean)}.  Returns {@code \"null\"} if\\n     * {@code a} is {@code null}.\\n     *\\n     * @param a the array whose string representation to return\\n     * @return a string representation of {@code a}\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String toString(float[] a)", "label": "public static String toString(float[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string representation of the contents of the specified array.\\n     * The string representation consists of a list of the array\\\u0027s elements,\\n     * enclosed in square brackets ({@code \"[]\"}).  Adjacent elements are\\n     * separated by the characters {@code \", \"} (a comma followed by a\\n     * space).  Elements are converted to strings as by\\n     * {@code String.valueOf(float)}.  Returns {@code \"null\"} if {@code a}\\n     * is {@code null}.\\n     *\\n     * @param a the array whose string representation to return\\n     * @return a string representation of {@code a}\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String toString(double[] a)", "label": "public static String toString(double[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string representation of the contents of the specified array.\\n     * The string representation consists of a list of the array\\\u0027s elements,\\n     * enclosed in square brackets ({@code \"[]\"}).  Adjacent elements are\\n     * separated by the characters {@code \", \"} (a comma followed by a\\n     * space).  Elements are converted to strings as by\\n     * {@code String.valueOf(double)}.  Returns {@code \"null\"} if {@code a}\\n     * is {@code null}.\\n     *\\n     * @param a the array whose string representation to return\\n     * @return a string representation of {@code a}\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String toString(Object[] a)", "label": "public static String toString(Object[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string representation of the contents of the specified array.\\n     * If the array contains other arrays as elements, they are converted to\\n     * strings by the {@link Object#toString} method inherited from\\n     * {@code Object}, which describes their \u003ci\u003eidentities\u003c/i\u003e rather than\\n     * their contents.\\n     *\\n     * \u003cp\u003eThe value returned by this method is equal to the value that would\\n     * be returned by {@code Arrays.asList(a).toString()}, unless {@code a}\\n     * is {@code null}, in which case {@code \"null\"} is returned.\\n     *\\n     * @param a the array whose string representation to return\\n     * @return a string representation of {@code a}\\n     * @see #deepToString(Object[])\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "toString", "label": "toString", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static String deepToString(Object[] a)", "label": "public static String deepToString(Object[] a)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string representation of the \"deep contents\" of the specified\\n     * array.  If the array contains other arrays as elements, the string\\n     * representation contains their contents and so on.  This method is\\n     * designed for converting multidimensional arrays to strings.\\n     *\\n     * \u003cp\u003eThe string representation consists of a list of the array\\\u0027s\\n     * elements, enclosed in square brackets ({@code \"[]\"}).  Adjacent\\n     * elements are separated by the characters {@code \", \"} (a comma\\n     * followed by a space).  Elements are converted to strings as by\\n     * {@code String.valueOf(Object)}, unless they are themselves\\n     * arrays.\\n     *\\n     * \u003cp\u003eIf an element {@code e} is an array of a primitive type, it is\\n     * converted to a string as by invoking the appropriate overloading of\\n     * {@code Arrays.toString(e)}.  If an element {@code e} is an array of a\\n     * reference type, it is converted to a string as by invoking\\n     * this method recursively.\\n     *\\n     * \u003cp\u003eTo avoid infinite recursion, if the specified array contains itself\\n     * as an element, or contains an indirect reference to itself through one\\n     * or more levels of arrays, the self-reference is converted to the string\\n     * {@code \"[...]\"}.  For example, an array containing only a reference\\n     * to itself would be rendered as {@code \"[[...]]\"}.\\n     *\\n     * \u003cp\u003eThis method returns {@code \"null\"} if the specified array\\n     * is {@code null}.\\n     *\\n     * @param a the array whose string representation to return\\n     * @return a string representation of {@code a}\\n     * @see #toString(Object[])\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void setAll(T[] array, IntFunction\u003c? extends T\u003e generator)", "label": "public static void setAll(T[] array, IntFunction\u003c? extends T\u003e generator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Set all elements of the specified array, using the provided\\n     * generator function to compute each element.\\n     *\\n     * \u003cp\u003eIf the generator function throws an exception, it is relayed to\\n     * the caller and the array is left in an indeterminate state.\\n     *\\n     * @apiNote\\n     * Setting a subrange of an array, using a generator function to compute\\n     * each element, can be written as follows:\\n     * \u003cpre\u003e{@code\\n     * IntStream.range(startInclusive, endExclusive)\\n     *          .forEach(i -\u003e array[i] = generator.apply(i));\\n     * }\u003c/pre\u003e\\n     *\\n     * @param \u003cT\u003e type of elements of the array\\n     * @param array array to be initialized\\n     * @param generator a function accepting an index and producing the desired\\n     *        value for that position\\n     * @throws NullPointerException if the generator is null\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void parallelSetAll(T[] array, IntFunction\u003c? extends T\u003e generator)", "label": "public static void parallelSetAll(T[] array, IntFunction\u003c? extends T\u003e generator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Set all elements of the specified array, in parallel, using the\\n     * provided generator function to compute each element.\\n     *\\n     * \u003cp\u003eIf the generator function throws an exception, an unchecked exception\\n     * is thrown from {@code parallelSetAll} and the array is left in an\\n     * indeterminate state.\\n     *\\n     * @apiNote\\n     * Setting a subrange of an array, in parallel, using a generator function\\n     * to compute each element, can be written as follows:\\n     * \u003cpre\u003e{@code\\n     * IntStream.range(startInclusive, endExclusive)\\n     *          .parallel()\\n     *          .forEach(i -\u003e array[i] = generator.apply(i));\\n     * }\u003c/pre\u003e\\n     *\\n     * @param \u003cT\u003e type of elements of the array\\n     * @param array array to be initialized\\n     * @param generator a function accepting an index and producing the desired\\n     *        value for that position\\n     * @throws NullPointerException if the generator is null\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void setAll(int[] array, IntUnaryOperator generator)", "label": "public static void setAll(int[] array, IntUnaryOperator generator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Set all elements of the specified array, using the provided\\n     * generator function to compute each element.\\n     *\\n     * \u003cp\u003eIf the generator function throws an exception, it is relayed to\\n     * the caller and the array is left in an indeterminate state.\\n     *\\n     * @apiNote\\n     * Setting a subrange of an array, using a generator function to compute\\n     * each element, can be written as follows:\\n     * \u003cpre\u003e{@code\\n     * IntStream.range(startInclusive, endExclusive)\\n     *          .forEach(i -\u003e array[i] = generator.applyAsInt(i));\\n     * }\u003c/pre\u003e\\n     *\\n     * @param array array to be initialized\\n     * @param generator a function accepting an index and producing the desired\\n     *        value for that position\\n     * @throws NullPointerException if the generator is null\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void parallelSetAll(int[] array, IntUnaryOperator generator)", "label": "public static void parallelSetAll(int[] array, IntUnaryOperator generator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Set all elements of the specified array, in parallel, using the\\n     * provided generator function to compute each element.\\n     *\\n     * \u003cp\u003eIf the generator function throws an exception, an unchecked exception\\n     * is thrown from {@code parallelSetAll} and the array is left in an\\n     * indeterminate state.\\n     *\\n     * @apiNote\\n     * Setting a subrange of an array, in parallel, using a generator function\\n     * to compute each element, can be written as follows:\\n     * \u003cpre\u003e{@code\\n     * IntStream.range(startInclusive, endExclusive)\\n     *          .parallel()\\n     *          .forEach(i -\u003e array[i] = generator.applyAsInt(i));\\n     * }\u003c/pre\u003e\\n     *\\n     * @param array array to be initialized\\n     * @param generator a function accepting an index and producing the desired\\n     * value for that position\\n     * @throws NullPointerException if the generator is null\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void setAll(long[] array, IntToLongFunction generator)", "label": "public static void setAll(long[] array, IntToLongFunction generator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Set all elements of the specified array, using the provided\\n     * generator function to compute each element.\\n     *\\n     * \u003cp\u003eIf the generator function throws an exception, it is relayed to\\n     * the caller and the array is left in an indeterminate state.\\n     *\\n     * @apiNote\\n     * Setting a subrange of an array, using a generator function to compute\\n     * each element, can be written as follows:\\n     * \u003cpre\u003e{@code\\n     * IntStream.range(startInclusive, endExclusive)\\n     *          .forEach(i -\u003e array[i] = generator.applyAsLong(i));\\n     * }\u003c/pre\u003e\\n     *\\n     * @param array array to be initialized\\n     * @param generator a function accepting an index and producing the desired\\n     *        value for that position\\n     * @throws NullPointerException if the generator is null\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void parallelSetAll(long[] array, IntToLongFunction generator)", "label": "public static void parallelSetAll(long[] array, IntToLongFunction generator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Set all elements of the specified array, in parallel, using the\\n     * provided generator function to compute each element.\\n     *\\n     * \u003cp\u003eIf the generator function throws an exception, an unchecked exception\\n     * is thrown from {@code parallelSetAll} and the array is left in an\\n     * indeterminate state.\\n     *\\n     * @apiNote\\n     * Setting a subrange of an array, in parallel, using a generator function\\n     * to compute each element, can be written as follows:\\n     * \u003cpre\u003e{@code\\n     * IntStream.range(startInclusive, endExclusive)\\n     *          .parallel()\\n     *          .forEach(i -\u003e array[i] = generator.applyAsLong(i));\\n     * }\u003c/pre\u003e\\n     *\\n     * @param array array to be initialized\\n     * @param generator a function accepting an index and producing the desired\\n     *        value for that position\\n     * @throws NullPointerException if the generator is null\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void setAll(double[] array, IntToDoubleFunction generator)", "label": "public static void setAll(double[] array, IntToDoubleFunction generator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Set all elements of the specified array, using the provided\\n     * generator function to compute each element.\\n     *\\n     * \u003cp\u003eIf the generator function throws an exception, it is relayed to\\n     * the caller and the array is left in an indeterminate state.\\n     *\\n     * @apiNote\\n     * Setting a subrange of an array, using a generator function to compute\\n     * each element, can be written as follows:\\n     * \u003cpre\u003e{@code\\n     * IntStream.range(startInclusive, endExclusive)\\n     *          .forEach(i -\u003e array[i] = generator.applyAsDouble(i));\\n     * }\u003c/pre\u003e\\n     *\\n     * @param array array to be initialized\\n     * @param generator a function accepting an index and producing the desired\\n     *        value for that position\\n     * @throws NullPointerException if the generator is null\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void parallelSetAll(double[] array, IntToDoubleFunction generator)", "label": "public static void parallelSetAll(double[] array, IntToDoubleFunction generator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Set all elements of the specified array, in parallel, using the\\n     * provided generator function to compute each element.\\n     *\\n     * \u003cp\u003eIf the generator function throws an exception, an unchecked exception\\n     * is thrown from {@code parallelSetAll} and the array is left in an\\n     * indeterminate state.\\n     *\\n     * @apiNote\\n     * Setting a subrange of an array, in parallel, using a generator function\\n     * to compute each element, can be written as follows:\\n     * \u003cpre\u003e{@code\\n     * IntStream.range(startInclusive, endExclusive)\\n     *          .parallel()\\n     *          .forEach(i -\u003e array[i] = generator.applyAsDouble(i));\\n     * }\u003c/pre\u003e\\n     *\\n     * @param array array to be initialized\\n     * @param generator a function accepting an index and producing the desired\\n     *        value for that position\\n     * @throws NullPointerException if the generator is null\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Spliterator\u003cT\u003e spliterator(T[] array)", "label": "public static Spliterator\u003cT\u003e spliterator(T[] array)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@link Spliterator} covering all of the specified array.\\n     *\\n     * \u003cp\u003eThe spliterator reports {@link Spliterator#SIZED},\\n     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and\\n     * {@link Spliterator#IMMUTABLE}.\\n     *\\n     * @param \u003cT\u003e type of elements\\n     * @param array the array, assumed to be unmodified during use\\n     * @return a spliterator for the array elements\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Spliterator\u003cT\u003e spliterator(T[] array, int startInclusive, int endExclusive)", "label": "public static Spliterator\u003cT\u003e spliterator(T[] array, int startInclusive, int endExclusive)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@link Spliterator} covering the specified range of the\\n     * specified array.\\n     *\\n     * \u003cp\u003eThe spliterator reports {@link Spliterator#SIZED},\\n     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and\\n     * {@link Spliterator#IMMUTABLE}.\\n     *\\n     * @param \u003cT\u003e type of elements\\n     * @param array the array, assumed to be unmodified during use\\n     * @param startInclusive the first index to cover, inclusive\\n     * @param endExclusive index immediately past the last index to cover\\n     * @return a spliterator for the array elements\\n     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is\\n     *         negative, {@code endExclusive} is less than\\n     *         {@code startInclusive}, or {@code endExclusive} is greater than\\n     *         the array size\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Spliterator.OfInt spliterator(int[] array)", "label": "public static Spliterator.OfInt spliterator(int[] array)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@link Spliterator.OfInt} covering all of the specified array.\\n     *\\n     * \u003cp\u003eThe spliterator reports {@link Spliterator#SIZED},\\n     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and\\n     * {@link Spliterator#IMMUTABLE}.\\n     *\\n     * @param array the array, assumed to be unmodified during use\\n     * @return a spliterator for the array elements\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "Spliterator.OfInt", "label": "Spliterator.OfInt", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public static Spliterator.OfInt spliterator(int[] array, int startInclusive, int endExclusive)", "label": "public static Spliterator.OfInt spliterator(int[] array, int startInclusive, int endExclusive)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@link Spliterator.OfInt} covering the specified range of the\\n     * specified array.\\n     *\\n     * \u003cp\u003eThe spliterator reports {@link Spliterator#SIZED},\\n     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and\\n     * {@link Spliterator#IMMUTABLE}.\\n     *\\n     * @param array the array, assumed to be unmodified during use\\n     * @param startInclusive the first index to cover, inclusive\\n     * @param endExclusive index immediately past the last index to cover\\n     * @return a spliterator for the array elements\\n     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is\\n     *         negative, {@code endExclusive} is less than\\n     *         {@code startInclusive}, or {@code endExclusive} is greater than\\n     *         the array size\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Spliterator.OfLong spliterator(long[] array)", "label": "public static Spliterator.OfLong spliterator(long[] array)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@link Spliterator.OfLong} covering all of the specified array.\\n     *\\n     * \u003cp\u003eThe spliterator reports {@link Spliterator#SIZED},\\n     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and\\n     * {@link Spliterator#IMMUTABLE}.\\n     *\\n     * @param array the array, assumed to be unmodified during use\\n     * @return the spliterator for the array elements\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "Spliterator.OfLong", "label": "Spliterator.OfLong", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public static Spliterator.OfLong spliterator(long[] array, int startInclusive, int endExclusive)", "label": "public static Spliterator.OfLong spliterator(long[] array, int startInclusive, int endExclusive)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@link Spliterator.OfLong} covering the specified range of the\\n     * specified array.\\n     *\\n     * \u003cp\u003eThe spliterator reports {@link Spliterator#SIZED},\\n     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and\\n     * {@link Spliterator#IMMUTABLE}.\\n     *\\n     * @param array the array, assumed to be unmodified during use\\n     * @param startInclusive the first index to cover, inclusive\\n     * @param endExclusive index immediately past the last index to cover\\n     * @return a spliterator for the array elements\\n     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is\\n     *         negative, {@code endExclusive} is less than\\n     *         {@code startInclusive}, or {@code endExclusive} is greater than\\n     *         the array size\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Spliterator.OfDouble spliterator(double[] array)", "label": "public static Spliterator.OfDouble spliterator(double[] array)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@link Spliterator.OfDouble} covering all of the specified\\n     * array.\\n     *\\n     * \u003cp\u003eThe spliterator reports {@link Spliterator#SIZED},\\n     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and\\n     * {@link Spliterator#IMMUTABLE}.\\n     *\\n     * @param array the array, assumed to be unmodified during use\\n     * @return a spliterator for the array elements\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "Spliterator.OfDouble", "label": "Spliterator.OfDouble", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public static Spliterator.OfDouble spliterator(double[] array, int startInclusive, int endExclusive)", "label": "public static Spliterator.OfDouble spliterator(double[] array, int startInclusive, int endExclusive)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@link Spliterator.OfDouble} covering the specified range of\\n     * the specified array.\\n     *\\n     * \u003cp\u003eThe spliterator reports {@link Spliterator#SIZED},\\n     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and\\n     * {@link Spliterator#IMMUTABLE}.\\n     *\\n     * @param array the array, assumed to be unmodified during use\\n     * @param startInclusive the first index to cover, inclusive\\n     * @param endExclusive index immediately past the last index to cover\\n     * @return a spliterator for the array elements\\n     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is\\n     *         negative, {@code endExclusive} is less than\\n     *         {@code startInclusive}, or {@code endExclusive} is greater than\\n     *         the array size\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Stream\u003cT\u003e stream(T[] array)", "label": "public static Stream\u003cT\u003e stream(T[] array)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a sequential {@link Stream} with the specified array as its\\n     * source.\\n     *\\n     * @param \u003cT\u003e The type of the array elements\\n     * @param array The array, assumed to be unmodified during use\\n     * @return a {@code Stream} for the array\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.util.stream.DoubleStream", "label": "java.util.stream.DoubleStream", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * A sequence of primitive double-valued elements supporting sequential and parallel\\n * aggregate operations.  This is the {@code double} primitive specialization of\\n * {@link Stream}.\\n *\\n * \u003cp\u003eThe following example illustrates an aggregate operation using\\n * {@link Stream} and {@link DoubleStream}, computing the sum of the weights of the\\n * red widgets:\\n *\\n * \u003cpre\u003e{@code\\n *     double sum = widgets.stream()\\n *                         .filter(w -\u003e w.getColor() == RED)\\n *                         .mapToDouble(w -\u003e w.getWeight())\\n *                         .sum();\\n * }\u003c/pre\u003e\\n *\\n * See the class documentation for {@link Stream} and the package documentation\\n * for \u003ca href=\"package-summary.html\"\u003ejava.util.stream\u003c/a\u003e for additional\\n * specification of streams, stream operations, stream pipelines, and\\n * parallelism.\\n *\\n * @since 1.8\\n * @see Stream\\n * @see \u003ca href=\"package-summary.html\"\u003ejava.util.stream\u003c/a\u003e\\n \u0027}"}, {"color": "#97c2fc", "id": " DoubleStream filter(DoublePredicate predicate)", "label": " DoubleStream filter(DoublePredicate predicate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the elements of this stream that match\\n     * the given predicate.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param predicate a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                  \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                  predicate to apply to each element to determine if it\\n     *                  should be included\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " DoubleStream map(DoubleUnaryOperator mapper)", "label": " DoubleStream map(DoubleUnaryOperator mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the results of applying the given\\n     * function to the elements of this stream.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function to apply to each element\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " Stream\u003cU\u003e mapToObj(DoubleFunction\u003c? extends U\u003e mapper)", "label": " Stream\u003cU\u003e mapToObj(DoubleFunction\u003c? extends U\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an object-valued {@code Stream} consisting of the results of\\n     * applying the given function to the elements of this stream.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003e\\n     *     intermediate operation\u003c/a\u003e.\\n     *\\n     * @param \u003cU\u003e the element type of the new stream\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function to apply to each element\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " IntStream mapToInt(DoubleToIntFunction mapper)", "label": " IntStream mapToInt(DoubleToIntFunction mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@code IntStream} consisting of the results of applying the\\n     * given function to the elements of this stream.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function to apply to each element\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " LongStream mapToLong(DoubleToLongFunction mapper)", "label": " LongStream mapToLong(DoubleToLongFunction mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code LongStream} consisting of the results of applying the\\n     * given function to the elements of this stream.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function to apply to each element\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " DoubleStream flatMap(DoubleFunction\u003c? extends DoubleStream\u003e mapper)", "label": " DoubleStream flatMap(DoubleFunction\u003c? extends DoubleStream\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the results of replacing each element of\\n     * this stream with the contents of a mapped stream produced by applying\\n     * the provided mapping function to each element.  Each mapped stream is\\n     * {@link java.util.stream.BaseStream#close() closed} after its contents\\n     * have been placed into this stream.  (If a mapped stream is {@code null}\\n     * an empty stream is used, instead.)\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function to apply to each element which produces a\\n     *               {@code DoubleStream} of new values\\n     * @return the new stream\\n     * @see Stream#flatMap(Function)\\n     \u0027}"}, {"color": "#97c2fc", "id": "close()", "label": "close()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.util.stream.BaseStream", "label": "java.util.stream.BaseStream", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Base interface for streams, which are sequences of elements supporting\\n * sequential and parallel aggregate operations.  The following example\\n * illustrates an aggregate operation using the stream types {@link Stream}\\n * and {@link IntStream}, computing the sum of the weights of the red widgets:\\n *\\n * \u003cpre\u003e{@code\\n *     int sum = widgets.stream()\\n *                      .filter(w -\u003e w.getColor() == RED)\\n *                      .mapToInt(w -\u003e w.getWeight())\\n *                      .sum();\\n * }\u003c/pre\u003e\\n *\\n * See the class documentation for {@link Stream} and the package documentation\\n * for \u003ca href=\"package-summary.html\"\u003ejava.util.stream\u003c/a\u003e for additional\\n * specification of streams, stream operations, stream pipelines, and\\n * parallelism, which governs the behavior of all stream types.\\n *\\n * @param \u003cT\u003e the type of the stream elements\\n * @param \u003cS\u003e the type of the stream implementing {@code BaseStream}\\n * @since 1.8\\n * @see Stream\\n * @see IntStream\\n * @see LongStream\\n * @see DoubleStream\\n * @see \u003ca href=\"package-summary.html\"\u003ejava.util.stream\u003c/a\u003e\\n \u0027}"}, {"color": "#97c2fc", "id": " Iterator\u003cT\u003e iterator()", "label": " Iterator\u003cT\u003e iterator()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the iterator associated with this {@code DirectoryStream}.\\n     *\\n     * @return  the iterator associated with this {@code DirectoryStream}\\n     *\\n     * @throws  IllegalStateException\\n     *          if this directory stream is closed or the iterator has already\\n     *          been returned\\n     \u0027}"}, {"color": "#97c2fc", "id": " Spliterator\u003cT\u003e spliterator()", "label": " Spliterator\u003cT\u003e spliterator()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a spliterator for the elements of this stream.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003e\\n     * The returned spliterator should report the set of characteristics derived\\n     * from the stream pipeline (namely the characteristics derived from the\\n     * stream source spliterator and the intermediate operations).\\n     * Implementations may report a sub-set of those characteristics.  For\\n     * example, it may be too expensive to compute the entire set for some or\\n     * all possible stream pipelines.\\n     *\\n     * @return the element spliterator for this stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean isParallel()", "label": " boolean isParallel()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns whether this stream, if a terminal operation were to be executed,\\n     * would execute in parallel.  Calling this method after invoking an\\n     * terminal stream operation method may yield unpredictable results.\\n     *\\n     * @return {@code true} if this stream would execute in parallel if executed\\n     \u0027}"}, {"color": "#97c2fc", "id": " S sequential()", "label": " S sequential()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an equivalent stream that is sequential.  May return\\n     * itself, either because the stream was already sequential, or because\\n     * the underlying stream state was modified to be sequential.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @return a sequential stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " S parallel()", "label": " S parallel()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an equivalent stream that is parallel.  May return\\n     * itself, either because the stream was already parallel, or because\\n     * the underlying stream state was modified to be parallel.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @return a parallel stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " S unordered()", "label": " S unordered()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an equivalent stream that is\\n     * \u003ca href=\"package-summary.html#Ordering\"\u003eunordered\u003c/a\u003e.  May return\\n     * itself, either because the stream was already unordered, or because\\n     * the underlying stream state was modified to be unordered.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @return an unordered stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " S onClose(Runnable closeHandler)", "label": " S onClose(Runnable closeHandler)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an equivalent stream with an additional close handler.  Close\\n     * handlers are run when the {@link #close()} method\\n     * is called on the stream, and are executed in the order they were\\n     * added.  All close handlers are run, even if earlier close handlers throw\\n     * exceptions.  If any close handler throws an exception, the first\\n     * exception thrown will be relayed to the caller of {@code close()}, with\\n     * any remaining exceptions added to that exception as suppressed exceptions\\n     * (unless one of the remaining exceptions is the same exception as the\\n     * first exception, since an exception cannot suppress itself.)  May\\n     * return itself.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param closeHandler A task to execute when the stream is closed\\n     * @return a stream with a handler that is run if the stream is closed\\n     \u0027}"}, {"color": "#97c2fc", "id": " void close()", "label": " void close()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Closes this stream, causing all close handlers for this stream pipeline\\n     * to be called.\\n     *\\n     * @see AutoCloseable#close()\\n     \u0027}"}, {"color": "#97c2fc", "id": " DoubleStream mapMulti(DoubleMapMultiConsumer mapper)", "label": " DoubleStream mapMulti(DoubleMapMultiConsumer mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the results of replacing each element of\\n     * this stream with multiple elements, specifically zero or more elements.\\n     * Replacement is performed by applying the provided mapping function to each\\n     * element in conjunction with a {@linkplain DoubleConsumer consumer} argument\\n     * that accepts replacement elements. The mapping function calls the consumer\\n     * zero or more times to provide the replacement elements.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eIf the {@linkplain DoubleConsumer consumer} argument is used outside the scope of\\n     * its application to the mapping function, the results are undefined.\\n     *\\n     * @implSpec\\n     * The default implementation invokes {@link #flatMap flatMap} on this stream,\\n     * passing a function that behaves as follows. First, it calls the mapper function\\n     * with a {@code DoubleConsumer} that accumulates replacement elements into a newly created\\n     * internal buffer. When the mapper function returns, it creates a {@code DoubleStream} from the\\n     * internal buffer. Finally, it returns this stream to {@code flatMap}.\\n     *\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function that generates replacement elements\\n     * @return the new stream\\n     * @see Stream#mapMulti Stream.mapMulti\\n     * @since 16\\n     \u0027}"}, {"color": "#97c2fc", "id": "flatMap", "label": "flatMap", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " DoubleStream distinct()", "label": " DoubleStream distinct()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the distinct elements of this stream. The\\n     * elements are compared for equality according to\\n     * {@link java.lang.Double#compare(double, double)}.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003estateful\\n     * intermediate operation\u003c/a\u003e.\\n     *\\n     * @return the result stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "compare(double", "label": "compare(double", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.lang.Double", "label": "java.lang.Double", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * The {@code Double} class wraps a value of the primitive type\\n * {@code double} in an object. An object of type\\n * {@code Double} contains a single field whose type is\\n * {@code double}.\\n *\\n * \u003cp\u003eIn addition, this class provides several methods for converting a\\n * {@code double} to a {@code String} and a\\n * {@code String} to a {@code double}, as well as other\\n * constants and methods useful when dealing with a\\n * {@code double}.\\n *\\n * \u003c!-- Android-removed: paragraph on ValueBased\\n * \u003cp\u003eThis is a \u003ca href=\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\\n * class; programmers should treat instances that are\\n * {@linkplain #equals(Object) equal} as interchangeable and should not\\n * use instances for synchronization, or unpredictable behavior may\\n * occur. For example, in a future release, synchronization may fail.\\n * --\u003e\\n *\\n * \u003ch2\u003e\u003ca id=equivalenceRelation\u003eFloating-point Equality, Equivalence,\\n * and Comparison\u003c/a\u003e\u003c/h2\u003e\\n *\\n * IEEE 754 floating-point values include finite nonzero values,\\n * signed zeros ({@code +0.0} and {@code -0.0}), signed infinities\\n * {@linkplain Double#POSITIVE_INFINITY positive infinity} and\\n * {@linkplain Double#NEGATIVE_INFINITY negative infinity}), and\\n * {@linkplain Double#NaN NaN} (not-a-number).\\n *\\n * \u003cp\u003eAn \u003cem\u003eequivalence relation\u003c/em\u003e on a set of values is a boolean\\n * relation on pairs of values that is reflexive, symmetric, and\\n * transitive. For more discussion of equivalence relations and object\\n * equality, see the {@link Object#equals Object.equals}\\n * specification. An equivalence relation partitions the values it\\n * operates over into sets called \u003ci\u003eequivalence classes\u003c/i\u003e.  All the\\n * members of the equivalence class are equal to each other under the\\n * relation. An equivalence class may contain only a single member. At\\n * least for some purposes, all the members of an equivalence class\\n * are substitutable for each other.  In particular, in a numeric\\n * expression equivalent values can be \u003cem\u003esubstituted\u003c/em\u003e for one\\n * another without changing the result of the expression, meaning\\n * changing the equivalence class of the result of the expression.\\n *\\n * \u003cp\u003eNotably, the built-in {@code ==} operation on floating-point\\n * values is \u003cem\u003enot\u003c/em\u003e an equivalence relation. Despite not\\n * defining an equivalence relation, the semantics of the IEEE 754\\n * {@code ==} operator were deliberately designed to meet other needs\\n * of numerical computation. There are two exceptions where the\\n * properties of an equivalence relation are not satisfied by {@code\\n * ==} on floating-point values:\\n *\\n * \u003cul\u003e\\n *\\n * \u003cli\u003eIf {@code v1} and {@code v2} are both NaN, then {@code v1\\n * == v2} has the value {@code false}. Therefore, for two NaN\\n * arguments the \u003cem\u003ereflexive\u003c/em\u003e property of an equivalence\\n * relation is \u003cem\u003enot\u003c/em\u003e satisfied by the {@code ==} operator.\\n *\\n * \u003cli\u003eIf {@code v1} represents {@code +0.0} while {@code v2}\\n * represents {@code -0.0}, or vice versa, then {@code v1 == v2} has\\n * the value {@code true} even though {@code +0.0} and {@code -0.0}\\n * are distinguishable under various floating-point operations. For\\n * example, {@code 1.0/+0.0} evaluates to positive infinity while\\n * {@code 1.0/-0.0} evaluates to \u003cem\u003enegative\u003c/em\u003e infinity and\\n * positive infinity and negative infinity are neither equal to each\\n * other nor equivalent to each other. Thus, while a signed zero input\\n * most commonly determines the sign of a zero result, because of\\n * dividing by zero, {@code +0.0} and {@code -0.0} may not be\\n * substituted for each other in general. The sign of a zero input\\n * also has a non-substitutable effect on the result of some math\\n * library methods.\\n *\\n * \u003c/ul\u003e\\n *\\n * \u003cp\u003eFor ordered comparisons using the built-in comparison operators\\n * ({@code \u003c}, {@code \u003c=}, etc.), NaN values have another anomalous\\n * situation: a NaN is neither less than, nor greater than, nor equal\\n * to any value, including itself. This means the \u003ci\u003etrichotomy of\\n * comparison\u003c/i\u003e does \u003cem\u003enot\u003c/em\u003e hold.\\n *\\n * \u003cp\u003eTo provide the appropriate semantics for {@code equals} and\\n * {@code compareTo} methods, those methods cannot simply be wrappers\\n * around {@code ==} or ordered comparison operations. Instead, {@link\\n * Double#equals equals} defines NaN arguments to be equal to each\\n * other and defines {@code +0.0} to \u003cem\u003enot\u003c/em\u003e be equal to {@code\\n * -0.0}, restoring reflexivity. For comparisons, {@link\\n * Double#compareTo compareTo} defines a total order where {@code\\n * -0.0} is less than {@code +0.0} and where a NaN is equal to itself\\n * and considered greater than positive infinity.\\n *\\n * \u003cp\u003eThe operational semantics of {@code equals} and {@code\\n * compareTo} are expressed in terms of {@linkplain #doubleToLongBits\\n * bit-wise converting} the floating-point values to integral values.\\n *\\n * \u003cp\u003eThe \u003cem\u003enatural ordering\u003c/em\u003e implemented by {@link #compareTo\\n * compareTo} is {@linkplain Comparable consistent with equals}. That\\n * is, two objects are reported as equal by {@code equals} if and only\\n * if {@code compareTo} on those objects returns zero.\\n *\\n * \u003cp\u003eThe adjusted behaviors defined for {@code equals} and {@code\\n * compareTo} allow instances of wrapper classes to work properly with\\n * conventional data structures. For example, defining NaN\\n * values to be {@code equals} to one another allows NaN to be used as\\n * an element of a {@link java.util.HashSet HashSet} or as the key of\\n * a {@link java.util.HashMap HashMap}. Similarly, defining {@code\\n * compareTo} as a total ordering, including {@code +0.0}, {@code\\n * -0.0}, and NaN, allows instances of wrapper classes to be used as\\n * elements of a {@link java.util.SortedSet SortedSet} or as keys of a\\n * {@link java.util.SortedMap SortedMap}.\\n *\\n * @jls 4.2.3 Floating-Point Types, Formats, and Values\\n * @jls 4.2.4. Floating-Point Operations\\n * @jls 15.21.1 Numerical Equality Operators == and !=\\n * @jls 15.20.1 Numerical Comparison Operators {@code \u003c}, {@code \u003c=}, {@code \u003e}, and {@code \u003e=}\\n *\\n * @author  Lee Boynton\\n * @author  Arthur van Hoff\\n * @author  Joseph D. Darcy\\n * @since 1.0\\n \u0027}"}, {"color": "#97c2fc", "id": "public static String toString(double d)", "label": "public static String toString(double d)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string representation of the {@code double}\\n     * argument. All characters mentioned below are ASCII characters.\\n     * \u003cul\u003e\\n     * \u003cli\u003eIf the argument is NaN, the result is the string\\n     *     \"{@code NaN}\".\\n     * \u003cli\u003eOtherwise, the result is a string that represents the sign and\\n     * magnitude (absolute value) of the argument. If the sign is negative,\\n     * the first character of the result is \\\u0027{@code -}\\\u0027\\n     * ({@code \\\u0027\\\\u005Cu002D\\\u0027}); if the sign is positive, no sign character\\n     * appears in the result. As for the magnitude \u003ci\u003em\u003c/i\u003e:\\n     * \u003cul\u003e\\n     * \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is infinity, it is represented by the characters\\n     * {@code \"Infinity\"}; thus, positive infinity produces the result\\n     * {@code \"Infinity\"} and negative infinity produces the result\\n     * {@code \"-Infinity\"}.\\n     *\\n     * \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is zero, it is represented by the characters\\n     * {@code \"0.0\"}; thus, negative zero produces the result\\n     * {@code \"-0.0\"} and positive zero produces the result\\n     * {@code \"0.0\"}.\\n     *\\n     * \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is greater than or equal to 10\u003csup\u003e-3\u003c/sup\u003e but less\\n     * than 10\u003csup\u003e7\u003c/sup\u003e, then it is represented as the integer part of\\n     * \u003ci\u003em\u003c/i\u003e, in decimal form with no leading zeroes, followed by\\n     * \\\u0027{@code .}\\\u0027 ({@code \\\u0027\\\\u005Cu002E\\\u0027}), followed by one or\\n     * more decimal digits representing the fractional part of \u003ci\u003em\u003c/i\u003e.\\n     *\\n     * \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is less than 10\u003csup\u003e-3\u003c/sup\u003e or greater than or\\n     * equal to 10\u003csup\u003e7\u003c/sup\u003e, then it is represented in so-called\\n     * \"computerized scientific notation.\" Let \u003ci\u003en\u003c/i\u003e be the unique\\n     * integer such that 10\u003csup\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e \u0026le; \u003ci\u003em\u003c/i\u003e {@literal \u003c}\\n     * 10\u003csup\u003e\u003ci\u003en\u003c/i\u003e+1\u003c/sup\u003e; then let \u003ci\u003ea\u003c/i\u003e be the\\n     * mathematically exact quotient of \u003ci\u003em\u003c/i\u003e and\\n     * 10\u003csup\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e so that 1 \u0026le; \u003ci\u003ea\u003c/i\u003e {@literal \u003c} 10. The\\n     * magnitude is then represented as the integer part of \u003ci\u003ea\u003c/i\u003e,\\n     * as a single decimal digit, followed by \\\u0027{@code .}\\\u0027\\n     * ({@code \\\u0027\\\\u005Cu002E\\\u0027}), followed by decimal digits\\n     * representing the fractional part of \u003ci\u003ea\u003c/i\u003e, followed by the\\n     * letter \\\u0027{@code E}\\\u0027 ({@code \\\u0027\\\\u005Cu0045\\\u0027}), followed\\n     * by a representation of \u003ci\u003en\u003c/i\u003e as a decimal integer, as\\n     * produced by the method {@link Integer#toString(int)}.\\n     * \u003c/ul\u003e\\n     * \u003c/ul\u003e\\n     * How many digits must be printed for the fractional part of\\n     * \u003ci\u003em\u003c/i\u003e or \u003ci\u003ea\u003c/i\u003e? There must be at least one digit to represent\\n     * the fractional part, and beyond that as many, but only as many, more\\n     * digits as are needed to uniquely distinguish the argument value from\\n     * adjacent values of type {@code double}. That is, suppose that\\n     * \u003ci\u003ex\u003c/i\u003e is the exact mathematical value represented by the decimal\\n     * representation produced by this method for a finite nonzero argument\\n     * \u003ci\u003ed\u003c/i\u003e. Then \u003ci\u003ed\u003c/i\u003e must be the {@code double} value nearest\\n     * to \u003ci\u003ex\u003c/i\u003e; or if two {@code double} values are equally close\\n     * to \u003ci\u003ex\u003c/i\u003e, then \u003ci\u003ed\u003c/i\u003e must be one of them and the least\\n     * significant bit of the significand of \u003ci\u003ed\u003c/i\u003e must be {@code 0}.\\n     *\\n     * \u003cp\u003eTo create localized string representations of a floating-point\\n     * value, use subclasses of {@link java.text.NumberFormat}.\\n     *\\n     * @param   d   the {@code double} to be converted.\\n     * @return a string representation of the argument.\\n     \u0027}"}, {"color": "#97c2fc", "id": "toString(int)", "label": "toString(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.lang.Integer", "label": "java.lang.Integer", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * The {@code Integer} class wraps a value of the primitive type\\n * {@code int} in an object. An object of type {@code Integer}\\n * contains a single field whose type is {@code int}.\\n *\\n * \u003cp\u003eIn addition, this class provides several methods for converting\\n * an {@code int} to a {@code String} and a {@code String} to an\\n * {@code int}, as well as other constants and methods useful when\\n * dealing with an {@code int}.\\n *\\n * \u003c!-- Android-removed: paragraph on ValueBased\\n * \u003cp\u003eThis is a \u003ca href=\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\\n * class; programmers should treat instances that are\\n * {@linkplain #equals(Object) equal} as interchangeable and should not\\n * use instances for synchronization, or unpredictable behavior may\\n * occur. For example, in a future release, synchronization may fail.\\n * --\u003e\\n *\\n * \u003cp\u003eImplementation note: The implementations of the \"bit twiddling\"\\n * methods (such as {@link #highestOneBit(int) highestOneBit} and\\n * {@link #numberOfTrailingZeros(int) numberOfTrailingZeros}) are\\n * based on material from Henry S. Warren, Jr.\\\u0027s \u003ci\u003eHacker\\\u0027s\\n * Delight\u003c/i\u003e, (Addison Wesley, 2002).\\n *\\n * @author  Lee Boynton\\n * @author  Arthur van Hoff\\n * @author  Josh Bloch\\n * @author  Joseph D. Darcy\\n * @since 1.0\\n \u0027}"}, {"color": "#97c2fc", "id": "public static String toString(int i, int radix)", "label": "public static String toString(int i, int radix)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a string representation of the first argument in the\\n     * radix specified by the second argument.\\n     *\\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\\n     * or larger than {@code Character.MAX_RADIX}, then the radix\\n     * {@code 10} is used instead.\\n     *\\n     * \u003cp\u003eIf the first argument is negative, the first element of the\\n     * result is the ASCII minus character {@code \u0027-\u0027}\\n     * ({@code \u0027\\\\u005Cu002D\u0027}). If the first argument is not\\n     * negative, no sign character appears in the result.\\n     *\\n     * \u003cp\u003eThe remaining characters of the result represent the magnitude\\n     * of the first argument. If the magnitude is zero, it is\\n     * represented by a single zero character {@code \u00270\u0027}\\n     * ({@code \u0027\\\\u005Cu0030\u0027}); otherwise, the first character of\\n     * the representation of the magnitude will not be the zero\\n     * character.  The following ASCII characters are used as digits:\\n     *\\n     * \u003cblockquote\u003e\\n     *   {@code 0123456789abcdefghijklmnopqrstuvwxyz}\\n     * \u003c/blockquote\u003e\\n     *\\n     * These are {@code \u0027\\\\u005Cu0030\u0027} through\\n     * {@code \u0027\\\\u005Cu0039\u0027} and {@code \u0027\\\\u005Cu0061\u0027} through\\n     * {@code \u0027\\\\u005Cu007A\u0027}. If {@code radix} is\\n     * \u003cvar\u003eN\u003c/var\u003e, then the first \u003cvar\u003eN\u003c/var\u003e of these characters\\n     * are used as radix-\u003cvar\u003eN\u003c/var\u003e digits in the order shown. Thus,\\n     * the digits for hexadecimal (radix 16) are\\n     * {@code 0123456789abcdef}. If uppercase letters are\\n     * desired, the {@link java.lang.String#toUpperCase()} method may\\n     * be called on the result:\\n     *\\n     * \u003cblockquote\u003e\\n     *  {@code Integer.toString(n, 16).toUpperCase()}\\n     * \u003c/blockquote\u003e\\n     *\\n     * @param   i       an integer to be converted to a string.\\n     * @param   radix   the radix to use in the string representation.\\n     * @return  a string representation of the argument in the specified radix.\\n     * @see     java.lang.Character#MAX_RADIX\\n     * @see     java.lang.Character#MIN_RADIX\\n     \"}"}, {"color": "#97c2fc", "id": "toUpperCase()", "label": "toUpperCase()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.lang.String", "label": "java.lang.String", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public int length()", "label": "public int length()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the length of the erroneous input described by this\\n     * object\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * @return  The length of the erroneous input, a positive integer\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          If this object does not describe an error condition, that is,\\n     *          if the {@link #isError() isError} does not return {@code true}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isEmpty()", "label": "public boolean isEmpty()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if, and only if, {@link #length()} is {@code 0}.\\n     *\\n     * @return {@code true} if {@link #length()} is {@code 0}, otherwise\\n     * {@code false}\\n     *\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "length()", "label": "length()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public native char charAt(int index)", "label": "public native char charAt(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public char charAt(int index) {\\n        if (isLatin1()) {\\n            return StringLatin1.charAt(value, index);\\n        } else {\\n            return StringUTF16.charAt(value, index);\\n        }\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public int codePointAt(int index)", "label": "public int codePointAt(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the character (Unicode code point) at the specified\\n     * index. The index refers to {@code char} values\\n     * (Unicode code units) and ranges from {@code 0} to\\n     * {@link #length()}{@code  - 1}.\\n     *\\n     * \u003cp\u003e If the {@code char} value specified at the given index\\n     * is in the high-surrogate range, the following index is less\\n     * than the length of this {@code String}, and the\\n     * {@code char} value at the following index is in the\\n     * low-surrogate range, then the supplementary code point\\n     * corresponding to this surrogate pair is returned. Otherwise,\\n     * the {@code char} value at the given index is returned.\\n     *\\n     * @param      index the index to the {@code char} values\\n     * @return     the code point value of the character at the\\n     *             {@code index}\\n     * @exception  IndexOutOfBoundsException  if the {@code index}\\n     *             argument is negative or not less than the length of this\\n     *             string.\\n     * @since      1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int codePointBefore(int index)", "label": "public int codePointBefore(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the character (Unicode code point) before the specified\\n     * index. The index refers to {@code char} values\\n     * (Unicode code units) and ranges from {@code 1} to {@link\\n     * CharSequence#length() length}.\\n     *\\n     * \u003cp\u003e If the {@code char} value at {@code (index - 1)}\\n     * is in the low-surrogate range, {@code (index - 2)} is not\\n     * negative, and the {@code char} value at {@code (index -\\n     * 2)} is in the high-surrogate range, then the\\n     * supplementary code point value of the surrogate pair is\\n     * returned. If the {@code char} value at {@code index -\\n     * 1} is an unpaired low-surrogate or a high-surrogate, the\\n     * surrogate value is returned.\\n     *\\n     * @param     index the index following the code point that should be returned\\n     * @return    the Unicode code point value before the given index.\\n     * @exception IndexOutOfBoundsException if the {@code index}\\n     *            argument is less than 1 or greater than the length\\n     *            of this string.\\n     * @since     1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.lang.CharSequence", "label": "java.lang.CharSequence", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": " int length()", "label": " int length()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the length of this character sequence.  The length is the number\\n     * of 16-bit {@code char}s in the sequence.\\n     *\\n     * @return  the number of {@code char}s in this sequence\\n     \u0027}"}, {"color": "#97c2fc", "id": " char charAt(int index)", "label": " char charAt(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the {@code char} value at the specified index.  An index ranges from zero\\n     * to {@code length() - 1}.  The first {@code char} value of the sequence is at\\n     * index zero, the next at index one, and so on, as for array\\n     * indexing.\\n     *\\n     * \u003cp\u003eIf the {@code char} value specified by the index is a\\n     * \u003ca href=\"{@docRoot}/java.base/java/lang/Character.html#unicode\"\u003esurrogate\u003c/a\u003e, the surrogate\\n     * value is returned.\\n     *\\n     * @param   index   the index of the {@code char} value to be returned\\n     *\\n     * @return  the specified {@code char} value\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          if the {@code index} argument is negative or not less than\\n     *          {@code length()}\\n     \u0027}"}, {"color": "#97c2fc", "id": " CharSequence subSequence(int start, int end)", "label": " CharSequence subSequence(int start, int end)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code CharSequence} that is a subsequence of this sequence.\\n     * The subsequence starts with the {@code char} value at the specified index and\\n     * ends with the {@code char} value at index {@code end - 1}.  The length\\n     * (in {@code char}s) of the\\n     * returned sequence is {@code end - start}, so if {@code start == end}\\n     * then an empty sequence is returned.\\n     *\\n     * @param   start   the start index, inclusive\\n     * @param   end     the end index, exclusive\\n     *\\n     * @return  the specified subsequence\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          if {@code start} or {@code end} are negative,\\n     *          if {@code end} is greater than {@code length()},\\n     *          or if {@code start} is greater than {@code end}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public IntStream chars()", "label": "public IntStream chars()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream of {@code int} zero-extending the {@code char} values\\n     * from this sequence.  Any char which maps to a \u003ca\\n     * href=\"{@docRoot}/java.base/java/lang/Character.html#unicode\"\u003esurrogate code\\n     * point\u003c/a\u003e is passed through uninterpreted.\\n     *\\n     * @return an IntStream of char values from this sequence\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public IntStream codePoints()", "label": "public IntStream codePoints()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream of code point values from this sequence.  Any surrogate\\n     * pairs encountered in the sequence are combined as if by {@linkplain\\n     * Character#toCodePoint Character.toCodePoint} and the result is passed\\n     * to the stream. Any other code units, including ordinary BMP characters,\\n     * unpaired surrogates, and undefined code units, are zero-extended to\\n     * {@code int} values which are then passed to the stream.\\n     *\\n     * @return an IntStream of Unicode code points from this sequence\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int compare(CharSequence cs1, CharSequence cs2)", "label": "public static int compare(CharSequence cs1, CharSequence cs2)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code CharSequence} instances lexicographically. Returns a\\n     * negative value, zero, or a positive value if the first sequence is lexicographically\\n     * less than, equal to, or greater than the second, respectively.\\n     *\\n     * \u003cp\u003e\\n     * The lexicographical ordering of {@code CharSequence} is defined as follows.\\n     * Consider a {@code CharSequence} \u003ci\u003ecs\u003c/i\u003e of length \u003ci\u003elen\u003c/i\u003e to be a\\n     * sequence of char values, \u003ci\u003ecs[0]\u003c/i\u003e to \u003ci\u003ecs[len-1]\u003c/i\u003e. Suppose \u003ci\u003ek\u003c/i\u003e\\n     * is the lowest index at which the corresponding char values from each sequence\\n     * differ. The lexicographic ordering of the sequences is determined by a numeric\\n     * comparison of the char values \u003ci\u003ecs1[k]\u003c/i\u003e with \u003ci\u003ecs2[k]\u003c/i\u003e. If there is\\n     * no such index \u003ci\u003ek\u003c/i\u003e, the shorter sequence is considered lexicographically\\n     * less than the other. If the sequences have the same length, the sequences are\\n     * considered lexicographically equal.\\n     *\\n     *\\n     * @param cs1 the first {@code CharSequence}\\n     * @param cs2 the second {@code CharSequence}\\n     *\\n     * @return  the value {@code 0} if the two {@code CharSequence} are equal;\\n     *          a negative integer if the first {@code CharSequence}\\n     *          is lexicographically less than the second; or a\\n     *          positive integer if the first {@code CharSequence} is\\n     *          lexicographically greater than the second.\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int codePointCount(int beginIndex, int endIndex)", "label": "public int codePointCount(int beginIndex, int endIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the number of Unicode code points in the specified text\\n     * range of this {@code String}. The text range begins at the\\n     * specified {@code beginIndex} and extends to the\\n     * {@code char} at index {@code endIndex - 1}. Thus the\\n     * length (in {@code char}s) of the text range is\\n     * {@code endIndex-beginIndex}. Unpaired surrogates within\\n     * the text range count as one code point each.\\n     *\\n     * @param beginIndex the index to the first {@code char} of\\n     * the text range.\\n     * @param endIndex the index after the last {@code char} of\\n     * the text range.\\n     * @return the number of Unicode code points in the specified text\\n     * range\\n     * @exception IndexOutOfBoundsException if the\\n     * {@code beginIndex} is negative, or {@code endIndex}\\n     * is larger than the length of this {@code String}, or\\n     * {@code beginIndex} is larger than {@code endIndex}.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int offsetByCodePoints(int index, int codePointOffset)", "label": "public int offsetByCodePoints(int index, int codePointOffset)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index within this {@code String} that is\\n     * offset from the given {@code index} by\\n     * {@code codePointOffset} code points. Unpaired surrogates\\n     * within the text range given by {@code index} and\\n     * {@code codePointOffset} count as one code point each.\\n     *\\n     * @param index the index to be offset\\n     * @param codePointOffset the offset in code points\\n     * @return the index within this {@code String}\\n     * @exception IndexOutOfBoundsException if {@code index}\\n     *   is negative or larger then the length of this\\n     *   {@code String}, or if {@code codePointOffset} is positive\\n     *   and the substring starting with {@code index} has fewer\\n     *   than {@code codePointOffset} code points,\\n     *   or if {@code codePointOffset} is negative and the substring\\n     *   before {@code index} has fewer than the absolute value\\n     *   of {@code codePointOffset} code points.\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": " void getChars(char[] dst, int dstBegin)", "label": " void getChars(char[] dst, int dstBegin)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Copy characters from this string into dst starting at dstBegin.\\n     * This method doesn\u0027t perform any range checking.\\n     \"}"}, {"color": "#97c2fc", "id": "public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)", "label": "public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies characters from this string into the destination character\\n     * array.\\n     * \u003cp\u003e\\n     * The first character to be copied is at index {@code srcBegin};\\n     * the last character to be copied is at index {@code srcEnd-1}\\n     * (thus the total number of characters to be copied is\\n     * {@code srcEnd-srcBegin}). The characters are copied into the\\n     * subarray of {@code dst} starting at index {@code dstBegin}\\n     * and ending at index:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     *     dstBegin + (srcEnd-srcBegin) - 1\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @param      srcBegin   index of the first character in the string\\n     *                        to copy.\\n     * @param      srcEnd     index after the last character in the string\\n     *                        to copy.\\n     * @param      dst        the destination array.\\n     * @param      dstBegin   the start offset in the destination array.\\n     * @exception IndexOutOfBoundsException If any of the following\\n     *            is true:\\n     *            \u003cul\u003e\u003cli\u003e{@code srcBegin} is negative.\\n     *            \u003cli\u003e{@code srcBegin} is greater than {@code srcEnd}\\n     *            \u003cli\u003e{@code srcEnd} is greater than the length of this\\n     *                string\\n     *            \u003cli\u003e{@code dstBegin} is negative\\n     *            \u003cli\u003e{@code dstBegin+(srcEnd-srcBegin)} is larger than\\n     *                {@code dst.length}\u003c/ul\u003e\\n     \u0027}"}, {"color": "#97c2fc", "id": " native void getCharsNoCheck(int start, int end, char[] buffer, int index)", "label": " native void getCharsNoCheck(int start, int end, char[] buffer, int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * getChars without bounds checks, for use by other classes\\n     * within the java.lang package only.  The caller is responsible for\\n     * ensuring that start \u003e= 0 \u0026\u0026 start \u003c= end \u0026\u0026 end \u003c= count.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public byte[] getBytes(String charsetName) throws UnsupportedEncodingException", "label": "public byte[] getBytes(String charsetName) throws UnsupportedEncodingException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Encodes this {@code String} into a sequence of bytes using the named\\n     * charset, storing the result into a new byte array.\\n     *\\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\\n     * the given charset is unspecified.  The {@link\\n     * java.nio.charset.CharsetEncoder} class should be used when more control\\n     * over the encoding process is required.\\n     *\\n     * @param  charsetName\\n     *         The name of a supported {@linkplain java.nio.charset.Charset\\n     *         charset}\\n     *\\n     * @return  The resultant byte array\\n     *\\n     * @throws  UnsupportedEncodingException\\n     *          If the named charset is not supported\\n     *\\n     * @since  1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.nio.charset.CharsetEncoder", "label": "java.nio.charset.CharsetEncoder", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public final Charset charset()", "label": "public final Charset charset()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the charset that created this decoder.\\n     *\\n     * @return  This decoder\u0027s charset\\n     \"}"}, {"color": "#97c2fc", "id": "public final byte[] replacement()", "label": "public final byte[] replacement()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns this encoder\u0027s replacement value.\\n     *\\n     * @return  This encoder\u0027s current replacement,\\n     *          which is never {@code null} and is never empty\\n     \"}"}, {"color": "#97c2fc", "id": "public final CharsetEncoder replaceWith(byte[] newReplacement)", "label": "public final CharsetEncoder replaceWith(byte[] newReplacement)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Changes this encoder\u0027s replacement value.\\n     *\\n     * \u003cp\u003e This method invokes the {@link #implReplaceWith implReplaceWith}\\n     * method, passing the new replacement, after checking that the new\\n     * replacement is acceptable.  \u003c/p\u003e\\n     *\\n     * @param  newReplacement  The new replacement; must not be\\n     *         {@code null}, must have non-zero length,\\n\\n\\n\\n\\n\\n     *         must not be longer than the value returned by the\\n     *         {@link #maxBytesPerChar() maxBytesPerChar} method, and\\n     *         must be {@link #isLegalReplacement legal}\\n\\n     *\\n     * @return  This encoder\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the preconditions on the parameter do not hold\\n     \"}"}, {"color": "#97c2fc", "id": "implReplaceWith", "label": "implReplaceWith", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "maxBytesPerChar()", "label": "maxBytesPerChar()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "isLegalReplacement", "label": "isLegalReplacement", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "protected void implReplaceWith(byte[] newReplacement)", "label": "protected void implReplaceWith(byte[] newReplacement)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reports a change to this encoder\u0027s replacement value.\\n     *\\n     * \u003cp\u003e The default implementation of this method does nothing.  This method\\n     * should be overridden by encoders that require notification of changes to\\n     * the replacement.  \u003c/p\u003e\\n     *\\n     * @param  newReplacement    The replacement value\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean isLegalReplacement(byte[] repl)", "label": "public boolean isLegalReplacement(byte[] repl)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Tells whether or not the given byte array is a legal replacement value\\n     * for this encoder.\\n     *\\n     * \u003cp\u003e A replacement is legal if, and only if, it is a legal sequence of\\n     * bytes in this encoder\u0027s charset; that is, it must be possible to decode\\n     * the replacement into one or more sixteen-bit Unicode characters.\\n     *\\n     * \u003cp\u003e The default implementation of this method is not very efficient; it\\n     * should generally be overridden to improve performance.  \u003c/p\u003e\\n     *\\n     * @param  repl  The byte array to be tested\\n     *\\n     * @return  {@code true} if, and only if, the given byte array\\n     *          is a legal replacement value for this encoder\\n     \"}"}, {"color": "#97c2fc", "id": "public CodingErrorAction malformedInputAction()", "label": "public CodingErrorAction malformedInputAction()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns this decoder\u0027s current action for malformed-input errors.\\n     *\\n     * @return The current malformed-input action, which is never {@code null}\\n     \"}"}, {"color": "#97c2fc", "id": "public final CharsetEncoder onMalformedInput(CodingErrorAction newAction)", "label": "public final CharsetEncoder onMalformedInput(CodingErrorAction newAction)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Changes this encoder\u0027s action for malformed-input errors.\\n     *\\n     * \u003cp\u003e This method invokes the {@link #implOnMalformedInput\\n     * implOnMalformedInput} method, passing the new action.  \u003c/p\u003e\\n     *\\n     * @param  newAction  The new action; must not be {@code null}\\n     *\\n     * @return  This encoder\\n     *\\n     * @throws IllegalArgumentException\\n     *         If the precondition on the parameter does not hold\\n     \"}"}, {"color": "#97c2fc", "id": "implOnMalformedInputimplOnMalformedInput", "label": "implOnMalformedInputimplOnMalformedInput", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "protected void implOnMalformedInput(CodingErrorAction newAction)", "label": "protected void implOnMalformedInput(CodingErrorAction newAction)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reports a change to this decoder\u0027s malformed-input action.\\n     *\\n     * \u003cp\u003e The default implementation of this method does nothing.  This method\\n     * should be overridden by decoders that require notification of changes to\\n     * the malformed-input action.  \u003c/p\u003e\\n     *\\n     * @param  newAction  The new action\\n     \"}"}, {"color": "#97c2fc", "id": "public CodingErrorAction unmappableCharacterAction()", "label": "public CodingErrorAction unmappableCharacterAction()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns this decoder\u0027s current action for unmappable-character errors.\\n     *\\n     * @return The current unmappable-character action, which is never\\n     *         {@code null}\\n     \"}"}, {"color": "#97c2fc", "id": "public final CharsetEncoder onUnmappableCharacter(CodingErrorAction newAction)", "label": "public final CharsetEncoder onUnmappableCharacter(CodingErrorAction newAction)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Changes this encoder\u0027s action for unmappable-character errors.\\n     *\\n     * \u003cp\u003e This method invokes the {@link #implOnUnmappableCharacter\\n     * implOnUnmappableCharacter} method, passing the new action.  \u003c/p\u003e\\n     *\\n     * @param  newAction  The new action; must not be {@code null}\\n     *\\n     * @return  This encoder\\n     *\\n     * @throws IllegalArgumentException\\n     *         If the precondition on the parameter does not hold\\n     \"}"}, {"color": "#97c2fc", "id": "implOnUnmappableCharacterimplOnUnmappableCharacter", "label": "implOnUnmappableCharacterimplOnUnmappableCharacter", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "protected void implOnUnmappableCharacter(CodingErrorAction newAction)", "label": "protected void implOnUnmappableCharacter(CodingErrorAction newAction)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reports a change to this decoder\u0027s unmappable-character action.\\n     *\\n     * \u003cp\u003e The default implementation of this method does nothing.  This method\\n     * should be overridden by decoders that require notification of changes to\\n     * the unmappable-character action.  \u003c/p\u003e\\n     *\\n     * @param  newAction  The new action\\n     \"}"}, {"color": "#97c2fc", "id": "public final float averageBytesPerChar()", "label": "public final float averageBytesPerChar()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the average number of bytes that will be produced for each\\n     * character of input.  This heuristic value may be used to estimate the size\\n     * of the output buffer required for a given input sequence.\\n     *\\n     * @return  The average number of bytes produced\\n     *          per character of input\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final float maxBytesPerChar()", "label": "public final float maxBytesPerChar()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the maximum number of bytes that will be produced for each\\n     * character of input.  This value may be used to compute the worst-case size\\n     * of the output buffer required for a given input sequence. This value\\n     * accounts for any necessary content-independent prefix or suffix\\n\\n     * bytes, such as byte-order marks.\\n\\n\\n\\n\\n     *\\n     * @return  The maximum number of bytes that will be produced per\\n     *          character of input\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final CoderResult encode(CharBuffer in, ByteBuffer out, boolean endOfInput)", "label": "public final CoderResult encode(CharBuffer in, ByteBuffer out, boolean endOfInput)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Encodes as many characters as possible from the given input buffer,\\n     * writing the results to the given output buffer.\\n     *\\n     * \u003cp\u003e The buffers are read from, and written to, starting at their current\\n     * positions.  At most {@link Buffer#remaining in.remaining()} characters\\n     * will be read and at most {@link Buffer#remaining out.remaining()}\\n     * bytes will be written.  The buffers\\\u0027 positions will be advanced to\\n     * reflect the characters read and the bytes written, but their marks and\\n     * limits will not be modified.\\n     *\\n     * \u003cp\u003e In addition to reading characters from the input buffer and writing\\n     * bytes to the output buffer, this method returns a {@link CoderResult}\\n     * object to describe its reason for termination:\\n     *\\n     * \u003cul\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e {@link CoderResult#UNDERFLOW} indicates that as much of the\\n     *   input buffer as possible has been encoded.  If there is no further\\n     *   input then the invoker can proceed to the next step of the\\n     *   \u003ca href=\"#steps\"\u003eencoding operation\u003c/a\u003e.  Otherwise this method\\n     *   should be invoked again with further input.  \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e {@link CoderResult#OVERFLOW} indicates that there is\\n     *   insufficient space in the output buffer to encode any more characters.\\n     *   This method should be invoked again with an output buffer that has\\n     *   more {@linkplain Buffer#remaining remaining} bytes. This is\\n     *   typically done by draining any encoded bytes from the output\\n     *   buffer.  \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e A {@linkplain CoderResult#malformedForLength\\n     *   malformed-input} result indicates that a malformed-input\\n     *   error has been detected.  The malformed characters begin at the input\\n     *   buffer\\\u0027s (possibly incremented) position; the number of malformed\\n     *   characters may be determined by invoking the result object\\\u0027s {@link\\n     *   CoderResult#length() length} method.  This case applies only if the\\n     *   {@linkplain #onMalformedInput malformed action} of this encoder\\n     *   is {@link CodingErrorAction#REPORT}; otherwise the malformed input\\n     *   will be ignored or replaced, as requested.  \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e An {@linkplain CoderResult#unmappableForLength\\n     *   unmappable-character} result indicates that an\\n     *   unmappable-character error has been detected.  The characters that\\n     *   encode the unmappable character begin at the input buffer\\\u0027s (possibly\\n     *   incremented) position; the number of such characters may be determined\\n     *   by invoking the result object\\\u0027s {@link CoderResult#length() length}\\n     *   method.  This case applies only if the {@linkplain #onUnmappableCharacter\\n     *   unmappable action} of this encoder is {@link\\n     *   CodingErrorAction#REPORT}; otherwise the unmappable character will be\\n     *   ignored or replaced, as requested.  \u003c/p\u003e\u003c/li\u003e\\n     *\\n     * \u003c/ul\u003e\\n     *\\n     * In any case, if this method is to be reinvoked in the same encoding\\n     * operation then care should be taken to preserve any characters remaining\\n     * in the input buffer so that they are available to the next invocation.\\n     *\\n     * \u003cp\u003e The {@code endOfInput} parameter advises this method as to whether\\n     * the invoker can provide further input beyond that contained in the given\\n     * input buffer.  If there is a possibility of providing additional input\\n     * then the invoker should pass {@code false} for this parameter; if there\\n     * is no possibility of providing further input then the invoker should\\n     * pass {@code true}.  It is not erroneous, and in fact it is quite\\n     * common, to pass {@code false} in one invocation and later discover that\\n     * no further input was actually available.  It is critical, however, that\\n     * the final invocation of this method in a sequence of invocations always\\n     * pass {@code true} so that any remaining unencoded input will be treated\\n     * as being malformed.\\n     *\\n     * \u003cp\u003e This method works by invoking the {@link #encodeLoop encodeLoop}\\n     * method, interpreting its results, handling error conditions, and\\n     * reinvoking it as necessary.  \u003c/p\u003e\\n     *\\n     *\\n     * @param  in\\n     *         The input character buffer\\n     *\\n     * @param  out\\n     *         The output byte buffer\\n     *\\n     * @param  endOfInput\\n     *         {@code true} if, and only if, the invoker can provide no\\n     *         additional input characters beyond those in the given buffer\\n     *\\n     * @return  A coder-result object describing the reason for termination\\n     *\\n     * @throws  IllegalStateException\\n     *          If an encoding operation is already in progress and the previous\\n     *          step was an invocation neither of the {@link #reset reset}\\n     *          method, nor of this method with a value of {@code false} for\\n     *          the {@code endOfInput} parameter, nor of this method with a\\n     *          value of {@code true} for the {@code endOfInput} parameter\\n     *          but a return value indicating an incomplete encoding operation\\n     *\\n     * @throws  CoderMalfunctionError\\n     *          If an invocation of the encodeLoop method threw\\n     *          an unexpected exception\\n     *\\n     * @throws  NullPointerException if input or output buffer is null\\n     \u0027}"}, {"color": "#97c2fc", "id": "OVERFLOW", "label": "OVERFLOW", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.charset.CoderResult", "label": "java.nio.charset.CoderResult", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public boolean isUnderflow()", "label": "public boolean isUnderflow()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this object describes an underflow condition.\\n     *\\n     * @return  {@code true} if, and only if, this object denotes underflow\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isOverflow()", "label": "public boolean isOverflow()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this object describes an overflow condition.\\n     *\\n     * @return  {@code true} if, and only if, this object denotes overflow\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isError()", "label": "public boolean isError()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this object describes an error condition.\\n     *\\n     * @return  {@code true} if, and only if, this object denotes either a\\n     *          malformed-input error or an unmappable-character error\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isMalformed()", "label": "public boolean isMalformed()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this object describes a malformed-input error.\\n     *\\n     * @return  {@code true} if, and only if, this object denotes a\\n     *          malformed-input error\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isUnmappable()", "label": "public boolean isUnmappable()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this object describes an unmappable-character\\n     * error.\\n     *\\n     * @return  {@code true} if, and only if, this object denotes an\\n     *          unmappable-character error\\n     \u0027}"}, {"color": "#97c2fc", "id": "isError()", "label": "isError()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static CoderResult malformedForLength(int length)", "label": "public static CoderResult malformedForLength(int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Static factory method that returns the unique object describing a\\n     * malformed-input error of the given length.\\n     *\\n     * @param   length\\n     *          The given length\\n     *\\n     * @return  The requested coder-result object\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static CoderResult unmappableForLength(int length)", "label": "public static CoderResult unmappableForLength(int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Static factory method that returns the unique result object describing\\n     * an unmappable-character error of the given length.\\n     *\\n     * @param   length\\n     *          The given length\\n     *\\n     * @return  The requested coder-result object\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void throwException() throws CharacterCodingException", "label": "public void throwException() throws CharacterCodingException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Throws an exception appropriate to the result described by this object.\\n     *\\n     * @throws  BufferUnderflowException\\n     *          If this object is {@link #UNDERFLOW}\\n     *\\n     * @throws  BufferOverflowException\\n     *          If this object is {@link #OVERFLOW}\\n     *\\n     * @throws  MalformedInputException\\n     *          If this object represents a malformed-input error; the\\n     *          exception\u0027s length value will be that of this object\\n     *\\n     * @throws  UnmappableCharacterException\\n     *          If this object represents an unmappable-character error; the\\n     *          exceptions length value will be that of this object\\n     \"}"}, {"color": "#97c2fc", "id": "UNDERFLOW", "label": "UNDERFLOW", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "reset", "label": "reset", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "REPORT", "label": "REPORT", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.charset.CodingErrorAction", "label": "java.nio.charset.CodingErrorAction", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "encodeLoop", "label": "encodeLoop", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "remaining", "label": "remaining", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.Buffer", "label": "java.nio.Buffer", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": " static IllegalArgumentException createSameBufferException()", "label": " static IllegalArgumentException createSameBufferException()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@code IllegalArgumentException} indicating that the source\\n     * and target are the same {@code Buffer}.  Intended for use in\\n     * {@code put(src)} when the parameter is the {@code Buffer} on which the\\n     * method is being invoked.\\n     *\\n     * @return  IllegalArgumentException\\n     *          With a message indicating equal source and target buffers\\n     \u0027}"}, {"color": "#97c2fc", "id": " static IllegalArgumentException createCapacityException(int capacity)", "label": " static IllegalArgumentException createCapacityException(int capacity)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Verify that the capacity is nonnegative.\\n     *\\n     * @param  capacity\\n     *         The new buffer\u0027s capacity, in $type$s\\n     *\\n     * @throws IllegalArgumentException\\n     *         If the {@code capacity} is a negative integer\\n     \"}"}, {"color": "#97c2fc", "id": "public final int capacity()", "label": "public final int capacity()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns this buffer\u0027s capacity.\\n     *\\n     * @return  The capacity of this buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public final int position()", "label": "public final int position()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns this buffer\u0027s position.\\n     *\\n     * @return  The position of this buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public Buffer position(int newPosition)", "label": "public Buffer position(int newPosition)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-changed: Un-final the method until confirmation of causing no app compat.\u0027}"}, {"color": "#97c2fc", "id": "private IllegalArgumentException createPositionException(int newPosition)", "label": "private IllegalArgumentException createPositionException(int newPosition)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Verify that {@code 0 \u003c newPosition \u003c= limit}\\n     *\\n     * @param newPosition\\n     *        The new position value\\n     *\\n     * @throws IllegalArgumentException\\n     *         If the specified position is out of bounds.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final int limit()", "label": "public final int limit()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns this buffer\u0027s limit.\\n     *\\n     * @return  The limit of this buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public Buffer limit(int newLimit)", "label": "public Buffer limit(int newLimit)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-changed: Un-final the method until confirmation of causing no app compat.\u0027}"}, {"color": "#97c2fc", "id": "private IllegalArgumentException createLimitException(int newLimit)", "label": "private IllegalArgumentException createLimitException(int newLimit)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Verify that {@code 0 \u003c newLimit \u003c= capacity}\\n     *\\n     * @param newLimit\\n     *        The new limit value\\n     *\\n     * @throws IllegalArgumentException\\n     *         If the specified limit is out of bounds.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Buffer mark()", "label": "public Buffer mark()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-changed: Un-final the method until confirmation of causing no app compat.\u0027}"}, {"color": "#97c2fc", "id": "public Buffer reset()", "label": "public Buffer reset()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-changed: Un-final the method until confirmation of causing no app compat.\u0027}"}, {"color": "#97c2fc", "id": "public Buffer clear()", "label": "public Buffer clear()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-changed: Un-final the method until confirmation of causing no app compat.\u0027}"}, {"color": "#97c2fc", "id": "public Buffer flip()", "label": "public Buffer flip()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-changed: Un-final the method until confirmation of causing no app compat.\u0027}"}, {"color": "#97c2fc", "id": "compact", "label": "compact", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.ByteBuffer", "label": "java.nio.ByteBuffer", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public static ByteBuffer allocateDirect(int capacity)", "label": "public static ByteBuffer allocateDirect(int capacity)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Allocates a new direct byte buffer.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s position will be zero, its limit will be its\\n     * capacity, its mark will be undefined, each of its elements will be\\n     * initialized to zero, and its byte order will be\\n     * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.  Whether or not it has a\\n     * {@link #hasArray backing array} is unspecified.\\n     *\\n     * @param  capacity\\n     *         The new buffer\u0027s capacity, in bytes\\n     *\\n     * @return  The new byte buffer\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the {@code capacity} is a negative integer\\n     \"}"}, {"color": "#97c2fc", "id": "BIG_ENDIAN", "label": "BIG_ENDIAN", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.ByteOrder", "label": "java.nio.ByteOrder", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public static ByteOrder nativeOrder()", "label": "public static ByteOrder nativeOrder()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Retrieves the native byte order of the underlying platform.\\n     *\\n     * \u003cp\u003e This method is defined so that performance-sensitive Java code can\\n     * allocate direct buffers with the same byte order as the hardware.\\n     * Native code libraries are often more efficient when such buffers are\\n     * used.  \u003c/p\u003e\\n     *\\n     * @return  The native byte order of the hardware upon which this Java\\n     *          virtual machine is running\\n     \u0027}"}, {"color": "#97c2fc", "id": "LITTLE_ENDIAN", "label": "LITTLE_ENDIAN", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "hasArray", "label": "hasArray", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static ByteBuffer allocate(int capacity)", "label": "public static ByteBuffer allocate(int capacity)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Allocates a new byte buffer.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s position will be zero, its limit will be its\\n     * capacity, its mark will be undefined, each of its elements will be\\n     * initialized to zero, and its byte order will be\\n\\n     * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.\\n\\n\\n\\n\\n     * It will have a {@link #array backing array}, and its\\n     * {@link #arrayOffset array offset} will be zero.\\n     *\\n     * @param  capacity\\n     *         The new buffer\u0027s capacity, in bytes\\n     *\\n     * @return  The new byte buffer\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the {@code capacity} is a negative integer\\n     \"}"}, {"color": "#97c2fc", "id": "array", "label": "array", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "arrayOffset", "label": "arrayOffset", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static ByteBuffer wrap(byte[] array, int offset, int length)", "label": "public static ByteBuffer wrap(byte[] array, int offset, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Wraps a byte array into a buffer.\\n     *\\n     * \u003cp\u003e The new buffer will be backed by the given byte array;\\n     * that is, modifications to the buffer will cause the array to be modified\\n     * and vice versa.  The new buffer\u0027s capacity will be\\n     * {@code array.length}, its position will be {@code offset}, its limit\\n     * will be {@code offset + length}, its mark will be undefined, and its\\n     * byte order will be\\n\\n     * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.\\n\\n\\n\\n\\n     * Its {@link #array backing array} will be the given array, and\\n     * its {@link #arrayOffset array offset} will be zero.  \u003c/p\u003e\\n     *\\n     * @param  array\\n     *         The array that will back the new buffer\\n     *\\n     * @param  offset\\n     *         The offset of the subarray to be used; must be non-negative and\\n     *         no larger than {@code array.length}.  The new buffer\u0027s position\\n     *         will be set to this value.\\n     *\\n     * @param  length\\n     *         The length of the subarray to be used;\\n     *         must be non-negative and no larger than\\n     *         {@code array.length - offset}.\\n     *         The new buffer\u0027s limit will be set to {@code offset + length}.\\n     *\\n     * @return  The new byte buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If the preconditions on the {@code offset} and {@code length}\\n     *          parameters do not hold\\n     \"}"}, {"color": "#97c2fc", "id": "public static ByteBuffer wrap(byte[] array)", "label": "public static ByteBuffer wrap(byte[] array)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Wraps a byte array into a buffer.\\n     *\\n     * \u003cp\u003e The new buffer will be backed by the given byte array;\\n     * that is, modifications to the buffer will cause the array to be modified\\n     * and vice versa.  The new buffer\u0027s capacity and limit will be\\n     * {@code array.length}, its position will be zero, its mark will be\\n     * undefined, and its byte order will be\\n\\n     * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.\\n\\n\\n\\n\\n     * Its {@link #array backing array} will be the given array, and its\\n     * {@link #arrayOffset array offset} will be zero.  \u003c/p\u003e\\n     *\\n     * @param  array\\n     *         The array that will back this buffer\\n     *\\n     * @return  The new byte buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer slice()", "label": "public abstract ByteBuffer slice()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-changed: covariant overloads of *Buffer methods that return this.\u0027}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer slice(int index, int length)", "label": "public abstract ByteBuffer slice(int index, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a new byte buffer whose content is a shared subsequence of\\n     * this buffer\u0027s content.\\n     *\\n     * \u003cp\u003e The content of the new buffer will start at position {@code index}\\n     * in this buffer, and will contain {@code length} elements. Changes to\\n     * this buffer\u0027s content will be visible in the new buffer, and vice versa;\\n     * the two buffers\u0027 position, limit, and mark values will be independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s position will be zero, its capacity and its limit\\n     * will be {@code length}, its mark will be undefined, and its byte order\\n     * will be\\n\\n     * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.\\n\\n\\n\\n     * The new buffer will be direct if, and only if, this buffer is direct,\\n     * and it will be read-only if, and only if, this buffer is read-only. \u003c/p\u003e\\n     *\\n     * @param   index\\n     *          The position in this buffer at which the content of the new\\n     *          buffer will start; must be non-negative and no larger than\\n     *          {@link #limit() limit()}\\n     *\\n     * @param   length\\n     *          The number of elements the new buffer will contain; must be\\n     *          non-negative and no larger than {@code limit() - index}\\n     *\\n     * @return  The new buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative or greater than {@code limit()},\\n     *          {@code length} is negative, or {@code length \u003e limit() - index}\\n     *\\n     * @since 13\\n     \"}"}, {"color": "#97c2fc", "id": "limit()", "label": "limit()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer duplicate()", "label": "public abstract ByteBuffer duplicate()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-changed: covariant overloads of *Buffer methods that return this.\u0027}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer asReadOnlyBuffer()", "label": "public abstract ByteBuffer asReadOnlyBuffer()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a new, read-only byte buffer that shares this buffer\u0027s\\n     * content.\\n     *\\n     * \u003cp\u003e The content of the new buffer will be that of this buffer.  Changes\\n     * to this buffer\u0027s content will be visible in the new buffer; the new\\n     * buffer itself, however, will be read-only and will not allow the shared\\n     * content to be modified.  The two buffers\u0027 position, limit, and mark\\n     * values will be independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s capacity, limit, position,\\n\\n     * and mark values will be identical to those of this buffer, and its byte\\n     * order will be {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.\\n\\n\\n\\n     *\\n     * \u003cp\u003e If this buffer is itself read-only then this method behaves in\\n     * exactly the same way as the {@link #duplicate duplicate} method.  \u003c/p\u003e\\n     *\\n     * @return  The new, read-only byte buffer\\n     \"}"}, {"color": "#97c2fc", "id": "duplicate", "label": "duplicate", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract byte get()", "label": "public abstract byte get()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Relative \u003ci\u003eget\u003c/i\u003e method.  Reads the byte at this buffer\u0027s\\n     * current position, and then increments the position.\\n     *\\n     * @return  The byte at the buffer\u0027s current position\\n     *\\n     * @throws  BufferUnderflowException\\n     *          If the buffer\u0027s current position is not smaller than its limit\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer put(byte b)", "label": "public abstract ByteBuffer put(byte b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Relative \u003ci\u003eput\u003c/i\u003e method\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes the given byte into this buffer at the current\\n     * position, and then increments the position. \u003c/p\u003e\\n     *\\n     * @param  b\\n     *         The byte to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  BufferOverflowException\\n     *          If this buffer\u0027s current position is not smaller than its limit\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract byte get(int index)", "label": "public abstract byte get(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eget\u003c/i\u003e method.  Reads the byte at the given\\n     * index.\\n     *\\n     * @param  index\\n     *         The index from which the byte will be read\\n     *\\n     * @return  The byte at the given index\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer put(int index, byte b)", "label": "public abstract ByteBuffer put(int index, byte b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eput\u003c/i\u003e method\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes the given byte into this buffer at the given\\n     * index. \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index at which the byte will be written\\n     *\\n     * @param  b\\n     *         The byte value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \"}"}, {"color": "#97c2fc", "id": "public ByteBuffer get(byte[] dst, int offset, int length)", "label": "public ByteBuffer get(byte[] dst, int offset, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Relative bulk \u003ci\u003eget\u003c/i\u003e method.\\n     *\\n     * \u003cp\u003e This method transfers bytes from this buffer into the given\\n     * destination array.  If there are fewer bytes remaining in the\\n     * buffer than are required to satisfy the request, that is, if\\n     * {@code length}\u0026nbsp;{@code \u003e}\u0026nbsp;{@code remaining()}, then no\\n     * bytes are transferred and a {@link BufferUnderflowException} is\\n     * thrown.\\n     *\\n     * \u003cp\u003e Otherwise, this method copies {@code length} bytes from this\\n     * buffer into the given array, starting at the current position of this\\n     * buffer and at the given offset in the array.  The position of this\\n     * buffer is then incremented by {@code length}.\\n     *\\n     * \u003cp\u003e In other words, an invocation of this method of the form\\n     * \u003ccode\u003esrc.get(dst,\u0026nbsp;off,\u0026nbsp;len)\u003c/code\u003e has exactly the same effect as\\n     * the loop\\n     *\\n     * \u003cpre\u003e{@code\\n     *     for (int i = off; i \u003c off + len; i++)\\n     *         dst[i] = src.get();\\n     * }\u003c/pre\u003e\\n     *\\n     * except that it first checks that there are sufficient bytes in\\n     * this buffer and it is potentially much more efficient.\\n     *\\n     * @param  dst\\n     *         The array into which bytes are to be written\\n     *\\n     * @param  offset\\n     *         The offset within the array of the first byte to be\\n     *         written; must be non-negative and no larger than\\n     *         {@code dst.length}\\n     *\\n     * @param  length\\n     *         The maximum number of bytes to be written to the given\\n     *         array; must be non-negative and no larger than\\n     *         {@code dst.length - offset}\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  BufferUnderflowException\\n     *          If there are fewer than {@code length} bytes\\n     *          remaining in this buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If the preconditions on the {@code offset} and {@code length}\\n     *          parameters do not hold\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.nio.BufferUnderflowException", "label": "java.nio.BufferUnderflowException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public ByteBuffer get(byte[] dst)", "label": "public ByteBuffer get(byte[] dst)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Relative bulk \u003ci\u003eget\u003c/i\u003e method.\\n     *\\n     * \u003cp\u003e This method transfers bytes from this buffer into the given\\n     * destination array.  An invocation of this method of the form\\n     * {@code src.get(a)} behaves in exactly the same way as the invocation\\n     *\\n     * \u003cpre\u003e\\n     *     src.get(a, 0, a.length) \u003c/pre\u003e\\n     *\\n     * @param   dst\\n     *          The destination array\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  BufferUnderflowException\\n     *          If there are fewer than {@code length} bytes\\n     *          remaining in this buffer\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ByteBuffer get(int index, byte[] dst, int offset, int length)", "label": "public ByteBuffer get(int index, byte[] dst, int offset, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Absolute bulk \u003ci\u003eget\u003c/i\u003e method.\\n     *\\n     * \u003cp\u003e This method transfers {@code length} bytes from this\\n     * buffer into the given array, starting at the given index in this\\n     * buffer and at the given offset in the array.  The position of this\\n     * buffer is unchanged.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form\\n     * \u003ccode\u003esrc.get(index,\u0026nbsp;dst,\u0026nbsp;offset,\u0026nbsp;length)\u003c/code\u003e\\n     * has exactly the same effect as the following loop except that it first\\n     * checks the consistency of the supplied parameters and it is potentially\\n     * much more efficient:\\n     *\\n     * \u003cpre\u003e{@code\\n     *     for (int i = offset, j = index; i \u003c offset + length; i++, j++)\\n     *         dst[i] = src.get(j);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param  index\\n     *         The index in this buffer from which the first byte will be\\n     *         read; must be non-negative and less than {@code limit()}\\n     *\\n     * @param  dst\\n     *         The destination array\\n     *\\n     * @param  offset\\n     *         The offset within the array of the first byte to be\\n     *         written; must be non-negative and less than\\n     *         {@code dst.length}\\n     *\\n     * @param  length\\n     *         The number of bytes to be written to the given array;\\n     *         must be non-negative and no larger than the smaller of\\n     *         {@code limit() - index} and {@code dst.length - offset}\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If the preconditions on the {@code index}, {@code offset}, and\\n     *          {@code length} parameters do not hold\\n     *\\n     * @since 13\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ByteBuffer get(int index, byte[] dst)", "label": "public ByteBuffer get(int index, byte[] dst)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Absolute bulk \u003ci\u003eget\u003c/i\u003e method.\\n     *\\n     * \u003cp\u003e This method transfers bytes from this buffer into the given\\n     * destination array.  The position of this buffer is unchanged.  An\\n     * invocation of this method of the form\\n     * \u003ccode\u003esrc.get(index,\u0026nbsp;dst)\u003c/code\u003e behaves in exactly the same\\n     * way as the invocation:\\n     *\\n     * \u003cpre\u003e\\n     *     src.get(index, dst, 0, dst.length) \u003c/pre\u003e\\n     *\\n     * @param  index\\n     *         The index in this buffer from which the first byte will be\\n     *         read; must be non-negative and less than {@code limit()}\\n     *\\n     * @param  dst\\n     *         The destination array\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative, not smaller than {@code limit()},\\n     *          or {@code limit() - index \u003c dst.length}\\n     *\\n     * @since 13\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ByteBuffer put(ByteBuffer src)", "label": "public ByteBuffer put(ByteBuffer src)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Relative bulk \u003ci\u003eput\u003c/i\u003e method\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e This method transfers the bytes remaining in the given source\\n     * buffer into this buffer.  If there are more bytes remaining in the\\n     * source buffer than in this buffer, that is, if\\n     * {@code src.remaining()}\u0026nbsp;{@code \u003e}\u0026nbsp;{@code remaining()},\\n     * then no bytes are transferred and a {@link\\n     * BufferOverflowException} is thrown.\\n     *\\n     * \u003cp\u003e Otherwise, this method copies\\n     * \u003ci\u003en\u003c/i\u003e\u0026nbsp;=\u0026nbsp;{@code src.remaining()} bytes from the given\\n     * buffer into this buffer, starting at each buffer\u0027s current position.\\n     * The positions of both buffers are then incremented by \u003ci\u003en\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e In other words, an invocation of this method of the form\\n     * {@code dst.put(src)} has exactly the same effect as the loop\\n     *\\n     * \u003cpre\u003e\\n     *     while (src.hasRemaining())\\n     *         dst.put(src.get()); \u003c/pre\u003e\\n     *\\n     * except that it first checks that there is sufficient space in this\\n     * buffer and it is potentially much more efficient.  If this buffer and\\n     * the source buffer share the same backing array or memory, then the\\n     * result will be as if the source elements were first copied to an\\n     * intermediate location before being written into this buffer.\\n     *\\n     * @param  src\\n     *         The source buffer from which bytes are to be read;\\n     *         must not be this buffer\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  BufferOverflowException\\n     *          If there is insufficient space in this buffer\\n     *          for the remaining bytes in the source buffer\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the source buffer is this buffer\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \"}"}, {"color": "#97c2fc", "id": "java.nio.BufferOverflowException", "label": "java.nio.BufferOverflowException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public ByteBuffer put(int index, ByteBuffer src, int offset, int length)", "label": "public ByteBuffer put(int index, ByteBuffer src, int offset, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Absolute bulk \u003ci\u003eput\u003c/i\u003e method\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e This method transfers {@code length} bytes into this buffer from\\n     * the given source buffer, starting at the given {@code offset} in the\\n     * source buffer and the given {@code index} in this buffer. The positions\\n     * of both buffers are unchanged.\\n     *\\n     * \u003cp\u003e In other words, an invocation of this method of the form\\n     * \u003ccode\u003edst.put(index,\u0026nbsp;src,\u0026nbsp;offset,\u0026nbsp;length)\u003c/code\u003e\\n     * has exactly the same effect as the loop\\n     *\\n     * \u003cpre\u003e{@code\\n     * for (int i = offset, j = index; i \u003c offset + length; i++, j++)\\n     *     dst.put(j, src.get(i));\\n     * }\u003c/pre\u003e\\n     *\\n     * except that it first checks the consistency of the supplied parameters\\n     * and it is potentially much more efficient.  If this buffer and\\n     * the source buffer share the same backing array or memory, then the\\n     * result will be as if the source elements were first copied to an\\n     * intermediate location before being written into this buffer.\\n     *\\n     * @param index\\n     *        The index in this buffer at which the first byte will be\\n     *        written; must be non-negative and less than {@code limit()}\\n     *\\n     * @param src\\n     *        The buffer from which bytes are to be read\\n     *\\n     * @param offset\\n     *        The index within the source buffer of the first byte to be\\n     *        read; must be non-negative and less than {@code src.limit()}\\n     *\\n     * @param length\\n     *        The number of bytes to be read from the given buffer;\\n     *        must be non-negative and no larger than the smaller of\\n     *        {@code limit() - index} and {@code src.limit() - offset}\\n     *\\n     * @return This buffer\\n     *\\n     * @throws IndexOutOfBoundsException\\n     *         If the preconditions on the {@code index}, {@code offset}, and\\n     *         {@code length} parameters do not hold\\n     *\\n     * @throws ReadOnlyBufferException\\n     *         If this buffer is read-only\\n     *\\n     * @since 16\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ByteBuffer put(byte[] src, int offset, int length)", "label": "public ByteBuffer put(byte[] src, int offset, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Relative bulk \u003ci\u003eput\u003c/i\u003e method\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e This method transfers bytes into this buffer from the given\\n     * source array.  If there are more bytes to be copied from the array\\n     * than remain in this buffer, that is, if\\n     * {@code length}\u0026nbsp;{@code \u003e}\u0026nbsp;{@code remaining()}, then no\\n     * bytes are transferred and a {@link BufferOverflowException} is\\n     * thrown.\\n     *\\n     * \u003cp\u003e Otherwise, this method copies {@code length} bytes from the\\n     * given array into this buffer, starting at the given offset in the array\\n     * and at the current position of this buffer.  The position of this buffer\\n     * is then incremented by {@code length}.\\n     *\\n     * \u003cp\u003e In other words, an invocation of this method of the form\\n     * \u003ccode\u003edst.put(src,\u0026nbsp;off,\u0026nbsp;len)\u003c/code\u003e has exactly the same effect as\\n     * the loop\\n     *\\n     * \u003cpre\u003e{@code\\n     *     for (int i = off; i \u003c off + len; i++)\\n     *         dst.put(src[i]);\\n     * }\u003c/pre\u003e\\n     *\\n     * except that it first checks that there is sufficient space in this\\n     * buffer and it is potentially much more efficient.\\n     *\\n     * @param  src\\n     *         The array from which bytes are to be read\\n     *\\n     * @param  offset\\n     *         The offset within the array of the first byte to be read;\\n     *         must be non-negative and no larger than {@code src.length}\\n     *\\n     * @param  length\\n     *         The number of bytes to be read from the given array;\\n     *         must be non-negative and no larger than\\n     *         {@code src.length - offset}\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  BufferOverflowException\\n     *          If there is insufficient space in this buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If the preconditions on the {@code offset} and {@code length}\\n     *          parameters do not hold\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final ByteBuffer put(byte[] src)", "label": "public final ByteBuffer put(byte[] src)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Relative bulk \u003ci\u003eput\u003c/i\u003e method\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e This method transfers the entire content of the given source\\n     * byte array into this buffer.  An invocation of this method of the\\n     * form {@code dst.put(a)} behaves in exactly the same way as the\\n     * invocation\\n     *\\n     * \u003cpre\u003e\\n     *     dst.put(a, 0, a.length) \u003c/pre\u003e\\n     *\\n     * @param   src\\n     *          The source array\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  BufferOverflowException\\n     *          If there is insufficient space in this buffer\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ByteBuffer put(int index, byte[] src, int offset, int length)", "label": "public ByteBuffer put(int index, byte[] src, int offset, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Absolute bulk \u003ci\u003eput\u003c/i\u003e method\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e This method transfers {@code length} bytes from the given\\n     * array, starting at the given offset in the array and at the given index\\n     * in this buffer.  The position of this buffer is unchanged.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form\\n     * \u003ccode\u003edst.put(index,\u0026nbsp;src,\u0026nbsp;offset,\u0026nbsp;length)\u003c/code\u003e\\n     * has exactly the same effect as the following loop except that it first\\n     * checks the consistency of the supplied parameters and it is potentially\\n     * much more efficient:\\n     *\\n     * \u003cpre\u003e{@code\\n     *     for (int i = offset, j = index; i \u003c offset + length; i++, j++)\\n     *         dst.put(j, src[i]);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param  index\\n     *         The index in this buffer at which the first byte will be\\n     *         written; must be non-negative and less than {@code limit()}\\n     *\\n     * @param  src\\n     *         The array from which bytes are to be read\\n     *\\n     * @param  offset\\n     *         The offset within the array of the first byte to be read;\\n     *         must be non-negative and less than {@code src.length}\\n     *\\n     * @param  length\\n     *         The number of bytes to be read from the given array;\\n     *         must be non-negative and no larger than the smaller of\\n     *         {@code limit() - index} and {@code src.length - offset}\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If the preconditions on the {@code index}, {@code offset}, and\\n     *          {@code length} parameters do not hold\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     *\\n     * @since 13\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ByteBuffer put(int index, byte[] src)", "label": "public ByteBuffer put(int index, byte[] src)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Absolute bulk \u003ci\u003eput\u003c/i\u003e method\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e This method copies bytes into this buffer from the given source\\n     * array.  The position of this buffer is unchanged.  An invocation of this\\n     * method of the form \u003ccode\u003edst.put(index,\u0026nbsp;src)\u003c/code\u003e\\n     * behaves in exactly the same way as the invocation:\\n     *\\n     * \u003cpre\u003e\\n     *     dst.put(index, src, 0, src.length); \u003c/pre\u003e\\n     *\\n     * @param  index\\n     *         The index in this buffer at which the first byte will be\\n     *         written; must be non-negative and less than {@code limit()}\\n     *\\n     * @param  src\\n     *         The array from which bytes are to be read\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative, not smaller than {@code limit()},\\n     *          or {@code limit() - index \u003c src.length}\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     *\\n     * @since 13\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final boolean hasArray()", "label": "public final boolean hasArray()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this buffer is backed by an accessible byte\\n     * array.\\n     *\\n     * \u003cp\u003e If this method returns {@code true} then the {@link #array() array}\\n     * and {@link #arrayOffset() arrayOffset} methods may safely be invoked.\\n     * \u003c/p\u003e\\n     *\\n     * @return  {@code true} if, and only if, this buffer\\n     *          is backed by an array and is not read-only\\n     \u0027}"}, {"color": "#97c2fc", "id": "array()", "label": "array()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "arrayOffset()", "label": "arrayOffset()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public final byte[] array()", "label": "public final byte[] array()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the byte array that backs this\\n     * buffer\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Modifications to this buffer\u0027s content will cause the returned\\n     * array\u0027s content to be modified, and vice versa.\\n     *\\n     * \u003cp\u003e Invoke the {@link #hasArray hasArray} method before invoking this\\n     * method in order to ensure that this buffer has an accessible backing\\n     * array.  \u003c/p\u003e\\n     *\\n     * @return  The array that backs this buffer\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is backed by an array but is read-only\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          If this buffer is not backed by an accessible array\\n     \"}"}, {"color": "#97c2fc", "id": "public final int arrayOffset()", "label": "public final int arrayOffset()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the offset within this buffer\u0027s backing array of the first\\n     * element of the buffer\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e If this buffer is backed by an array then buffer position \u003ci\u003ep\u003c/i\u003e\\n     * corresponds to array index \u003ci\u003ep\u003c/i\u003e\u0026nbsp;+\u0026nbsp;{@code arrayOffset()}.\\n     *\\n     * \u003cp\u003e Invoke the {@link #hasArray hasArray} method before invoking this\\n     * method in order to ensure that this buffer has an accessible backing\\n     * array.  \u003c/p\u003e\\n     *\\n     * @return  The offset within this buffer\u0027s array\\n     *          of the first element of the buffer\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is backed by an array but is read-only\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          If this buffer is not backed by an accessible array\\n     \"}"}, {"color": "#97c2fc", "id": "public Buffer rewind()", "label": "public Buffer rewind()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Rewinds this buffer.  The position is set to zero and the mark is\\n     * discarded.\\n     *\\n     * \u003cp\u003e Invoke this method before a sequence of channel-write or \u003ci\u003eget\u003c/i\u003e\\n     * operations, assuming that the limit has already been set\\n     * appropriately.  For example:\\n     *\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * out.write(buf);    // Write remaining data\\n     * buf.rewind();      // Rewind buffer\\n     * buf.get(array);    // Copy data into array\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @return  This buffer\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer compact()", "label": "public abstract ByteBuffer compact()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-changed: covariant overloads of *Buffer methods that return this.\u0027}"}, {"color": "#97c2fc", "id": "public abstract boolean isDirect()", "label": "public abstract boolean isDirect()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this buffer is\\n     * \u003ca href=\"ByteBuffer.html#direct\"\u003e\u003ci\u003edirect\u003c/i\u003e\u003c/a\u003e.\\n     *\\n     * @return  {@code true} if, and only if, this buffer is direct\\n     *\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean equals(Object ob)", "label": "public boolean equals(Object ob)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests this URI for equality with another object.\\n     *\\n     * \u003cp\u003e If the given object is not a URI then this method immediately\\n     * returns {@code false}.\\n     *\\n     * \u003cp\u003e For two URIs to be considered equal requires that either both are\\n     * opaque or both are hierarchical.  Their schemes must either both be\\n     * undefined or else be equal without regard to case. Their fragments\\n     * must either both be undefined or else be equal.\\n     *\\n     * \u003cp\u003e For two opaque URIs to be considered equal, their scheme-specific\\n     * parts must be equal.\\n     *\\n     * \u003cp\u003e For two hierarchical URIs to be considered equal, their paths must\\n     * be equal and their queries must either both be undefined or else be\\n     * equal.  Their authorities must either both be undefined, or both be\\n     * registry-based, or both be server-based.  If their authorities are\\n     * defined and are registry-based, then they must be equal.  If their\\n     * authorities are defined and are server-based, then their hosts must be\\n     * equal without regard to case, their port numbers must be equal, and\\n     * their user-information components must be equal.\\n     *\\n     * \u003cp\u003e When testing the user-information, path, query, fragment, authority,\\n     * or scheme-specific parts of two URIs for equality, the raw forms rather\\n     * than the encoded forms of these components are compared and the\\n     * hexadecimal digits of escaped octets are compared without regard to\\n     * case.\\n     *\\n     * \u003cp\u003e This method satisfies the general contract of the {@link\\n     * java.lang.Object#equals(Object) Object.equals} method. \u003c/p\u003e\\n     *\\n     * @param   ob   The object to which this object is to be compared\\n     *\\n     * @return  {@code true} if, and only if, the given object is a URI that\\n     *          is identical to this URI\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int compareTo(ByteBuffer that)", "label": "public int compareTo(ByteBuffer that)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares this buffer to another.\\n     *\\n     * \u003cp\u003e Two byte buffers are compared by comparing their sequences of\\n     * remaining elements lexicographically, without regard to the starting\\n     * position of each sequence within its corresponding buffer.\\n\\n\\n\\n\\n\\n\\n\\n\\n     * Pairs of {@code byte} elements are compared as if by invoking\\n     * {@link Byte#compare(byte,byte)}.\\n\\n     *\\n     * \u003cp\u003e A byte buffer is not comparable to any other type of object.\\n     *\\n     * @return  A negative integer, zero, or a positive integer as this buffer\\n     *          is less than, equal to, or greater than the given buffer\\n     \u0027}"}, {"color": "#97c2fc", "id": "compare(byte", "label": "compare(byte", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public int mismatch(ByteBuffer that)", "label": "public int mismatch(ByteBuffer that)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Finds and returns the relative index of the first mismatch between this\\n     * buffer and a given buffer.  The index is relative to the\\n     * {@link #position() position} of each buffer and will be in the range of\\n     * 0 (inclusive) up to the smaller of the {@link #remaining() remaining}\\n     * elements in each buffer (exclusive).\\n     *\\n     * \u003cp\u003e If the two buffers share a common prefix then the returned index is\\n     * the length of the common prefix and it follows that there is a mismatch\\n     * between the two buffers at that index within the respective buffers.\\n     * If one buffer is a proper prefix of the other then the returned index is\\n     * the smaller of the remaining elements in each buffer, and it follows that\\n     * the index is only valid for the buffer with the larger number of\\n     * remaining elements.\\n     * Otherwise, there is no mismatch.\\n     *\\n     * @param  that\\n     *         The byte buffer to be tested for a mismatch with this buffer\\n     *\\n     * @return  The relative index of the first mismatch between this and the\\n     *          given buffer, otherwise -1 if no mismatch.\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "position()", "label": "position()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "remaining()", "label": "remaining()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public final ByteOrder order()", "label": "public final ByteOrder order()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Retrieves this buffer\u0027s byte order.\\n     *\\n     * \u003cp\u003e The byte order is used when reading or writing multibyte values, and\\n     * when creating buffers that are views of this byte buffer.  The order of\\n     * a newly-created byte buffer is always {@link ByteOrder#BIG_ENDIAN\\n     * BIG_ENDIAN}.  \u003c/p\u003e\\n     *\\n     * @return  This buffer\u0027s byte order\\n     \"}"}, {"color": "#97c2fc", "id": "public final ByteBuffer order(ByteOrder bo)", "label": "public final ByteBuffer order(ByteOrder bo)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Modifies this buffer\u0027s byte order.\\n     *\\n     * @param  bo\\n     *         The new byte order,\\n     *         either {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}\\n     *         or {@link ByteOrder#LITTLE_ENDIAN LITTLE_ENDIAN}\\n     *\\n     * @return  This buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public final int alignmentOffset(int index, int unitSize)", "label": "public final int alignmentOffset(int index, int unitSize)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the memory address, pointing to the byte at the given index,\\n     * modulo the given unit size.\\n     *\\n     * \u003cp\u003e The return value is non-negative in the range of {@code 0}\\n     * (inclusive) up to {@code unitSize} (exclusive), with zero indicating\\n     * that the address of the byte at the index is aligned for the unit size,\\n     * and a positive value that the address is misaligned for the unit size.\\n     * If the address of the byte at the index is misaligned, the return value\\n     * represents how much the index should be adjusted to locate a byte at an\\n     * aligned address.  Specifically, the index should either be decremented by\\n     * the return value if the latter is not greater than {@code index}, or be\\n     * incremented by the unit size minus the return value.  Therefore given\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * int value = alignmentOffset(index, unitSize)\u003c/pre\u003e\u003c/blockquote\u003e\\n     * then the identities\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * alignmentOffset(index - value, unitSize) == 0, value \u0026le; index\u003c/pre\u003e\u003c/blockquote\u003e\\n     * and\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * alignmentOffset(index + (unitSize - value), unitSize) == 0\u003c/pre\u003e\u003c/blockquote\u003e\\n     * must hold.\\n     *\\n     * @apiNote\\n     * This method may be utilized to determine if unit size bytes from an\\n     * index can be accessed atomically, if supported by the native platform.\\n     *\\n     * @implNote\\n     * This implementation throws {@code UnsupportedOperationException} for\\n     * non-direct buffers when the given unit size is greater than {@code 8}.\\n     *\\n     * @param  index\\n     *         The index to query for alignment offset, must be non-negative, no\\n     *         upper bounds check is performed\\n     *\\n     * @param  unitSize\\n     *         The unit size in bytes, must be a power of {@code 2}\\n     *\\n     * @return  The indexed byte\u0027s memory address modulo the unit size\\n     *\\n     * @throws IllegalArgumentException\\n     *         If the index is negative or the unit size is not a power of\\n     *         {@code 2}\\n     *\\n     * @throws UnsupportedOperationException\\n     *         If the native platform does not guarantee stable alignment offset\\n     *         values for the given unit size when managing the memory regions\\n     *         of buffers of the same kind as this buffer (direct or\\n     *         non-direct).  For example, if garbage collection would result\\n     *         in the moving of a memory region covered by a non-direct buffer\\n     *         from one location to another and both locations have different\\n     *         alignment characteristics.\\n     *\\n     * @see #alignedSlice(int)\\n     * @since 9\\n     \"}"}, {"color": "#97c2fc", "id": "public final ByteBuffer alignedSlice(int unitSize)", "label": "public final ByteBuffer alignedSlice(int unitSize)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a new byte buffer whose content is a shared and aligned\\n     * subsequence of this buffer\u0027s content.\\n     *\\n     * \u003cp\u003e The content of the new buffer will start at this buffer\u0027s current\\n     * position rounded up to the index of the nearest aligned byte for the\\n     * given unit size, and end at this buffer\u0027s limit rounded down to the index\\n     * of the nearest aligned byte for the given unit size.\\n     * If rounding results in out-of-bound values then the new buffer\u0027s capacity\\n     * and limit will be zero.  If rounding is within bounds the following\\n     * expressions will be true for a new buffer {@code nb} and unit size\\n     * {@code unitSize}:\\n     * \u003cpre\u003e{@code\\n     * nb.alignmentOffset(0, unitSize) == 0\\n     * nb.alignmentOffset(nb.limit(), unitSize) == 0\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003e Changes to this buffer\u0027s content will be visible in the new\\n     * buffer, and vice versa; the two buffers\u0027 position, limit, and mark\\n     * values will be independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s position will be zero, its capacity and its limit\\n     * will be the number of bytes remaining in this buffer or fewer subject to\\n     * alignment, its mark will be undefined, and its byte order will be\\n     * {@link ByteOrder#BIG_ENDIAN BIG_ENDIAN}.\\n     *\\n     * The new buffer will be direct if, and only if, this buffer is direct, and\\n     * it will be read-only if, and only if, this buffer is read-only.  \u003c/p\u003e\\n     *\\n     * @apiNote\\n     * This method may be utilized to create a new buffer where unit size bytes\\n     * from index, that is a multiple of the unit size, may be accessed\\n     * atomically, if supported by the native platform.\\n     *\\n     * @implNote\\n     * This implementation throws {@code UnsupportedOperationException} for\\n     * non-direct buffers when the given unit size is greater than {@code 8}.\\n     *\\n     * @param  unitSize\\n     *         The unit size in bytes, must be a power of {@code 2}\\n     *\\n     * @return  The new byte buffer\\n     *\\n     * @throws IllegalArgumentException\\n     *         If the unit size not a power of {@code 2}\\n     *\\n     * @throws UnsupportedOperationException\\n     *         If the native platform does not guarantee stable aligned slices\\n     *         for the given unit size when managing the memory regions\\n     *         of buffers of the same kind as this buffer (direct or\\n     *         non-direct).  For example, if garbage collection would result\\n     *         in the moving of a memory region covered by a non-direct buffer\\n     *         from one location to another and both locations have different\\n     *         alignment characteristics.\\n     *\\n     * @see #alignmentOffset(int, int)\\n     * @see #slice()\\n     * @since 9\\n     \"}"}, {"color": "#97c2fc", "id": " abstract byte _get(int i)", "label": " abstract byte _get(int i)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 package-private\u0027}"}, {"color": "#97c2fc", "id": " abstract void _put(int i, byte b)", "label": " abstract void _put(int i, byte b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 package-private\u0027}"}, {"color": "#97c2fc", "id": "public abstract char getChar()", "label": "public abstract char getChar()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Relative \u003ci\u003eget\u003c/i\u003e method for reading a char value.\\n     *\\n     * \u003cp\u003e Reads the next two bytes at this buffer\u0027s current position,\\n     * composing them into a char value according to the current byte order,\\n     * and then increments the position by two.  \u003c/p\u003e\\n     *\\n     * @return  The char value at the buffer\u0027s current position\\n     *\\n     * @throws  BufferUnderflowException\\n     *          If there are fewer than two bytes\\n     *          remaining in this buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer putChar(char value)", "label": "public abstract ByteBuffer putChar(char value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Relative \u003ci\u003eput\u003c/i\u003e method for writing a char\\n     * value\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes two bytes containing the given char value, in the\\n     * current byte order, into this buffer at the current position, and then\\n     * increments the position by two.  \u003c/p\u003e\\n     *\\n     * @param  value\\n     *         The char value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  BufferOverflowException\\n     *          If there are fewer than two bytes\\n     *          remaining in this buffer\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract char getChar(int index)", "label": "public abstract char getChar(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eget\u003c/i\u003e method for reading a char value.\\n     *\\n     * \u003cp\u003e Reads two bytes at the given index, composing them into a\\n     * char value according to the current byte order.  \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index from which the bytes will be read\\n     *\\n     * @return  The char value at the given index\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit,\\n     *          minus one\\n     \"}"}, {"color": "#97c2fc", "id": " abstract char getCharUnchecked(int index)", "label": " abstract char getCharUnchecked(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: {get,put}*Unchecked() accessors.\u0027}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer putChar(int index, char value)", "label": "public abstract ByteBuffer putChar(int index, char value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eput\u003c/i\u003e method for writing a char\\n     * value\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes two bytes containing the given char value, in the\\n     * current byte order, into this buffer at the given index.  \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index at which the bytes will be written\\n     *\\n     * @param  value\\n     *         The char value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit,\\n     *          minus one\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \"}"}, {"color": "#97c2fc", "id": " abstract void putCharUnchecked(int index, char value)", "label": " abstract void putCharUnchecked(int index, char value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: {get,put}*Unchecked() accessors.\u0027}"}, {"color": "#97c2fc", "id": "public abstract CharBuffer asCharBuffer()", "label": "public abstract CharBuffer asCharBuffer()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a view of this byte buffer as a char buffer.\\n     *\\n     * \u003cp\u003e The content of the new buffer will start at this buffer\u0027s current\\n     * position.  Changes to this buffer\u0027s content will be visible in the new\\n     * buffer, and vice versa; the two buffers\u0027 position, limit, and mark\\n     * values will be independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s position will be zero, its capacity and its limit\\n     * will be the number of bytes remaining in this buffer divided by\\n     * two, its mark will be undefined, and its byte order will be that\\n     * of the byte buffer at the moment the view is created.  The new buffer\\n     * will be direct if, and only if, this buffer is direct, and it will be\\n     * read-only if, and only if, this buffer is read-only.  \u003c/p\u003e\\n     *\\n     * @return  A new char buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract short getShort()", "label": "public abstract short getShort()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Relative \u003ci\u003eget\u003c/i\u003e method for reading a short value.\\n     *\\n     * \u003cp\u003e Reads the next two bytes at this buffer\u0027s current position,\\n     * composing them into a short value according to the current byte order,\\n     * and then increments the position by two.  \u003c/p\u003e\\n     *\\n     * @return  The short value at the buffer\u0027s current position\\n     *\\n     * @throws  BufferUnderflowException\\n     *          If there are fewer than two bytes\\n     *          remaining in this buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer putShort(short value)", "label": "public abstract ByteBuffer putShort(short value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Relative \u003ci\u003eput\u003c/i\u003e method for writing a short\\n     * value\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes two bytes containing the given short value, in the\\n     * current byte order, into this buffer at the current position, and then\\n     * increments the position by two.  \u003c/p\u003e\\n     *\\n     * @param  value\\n     *         The short value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  BufferOverflowException\\n     *          If there are fewer than two bytes\\n     *          remaining in this buffer\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract short getShort(int index)", "label": "public abstract short getShort(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eget\u003c/i\u003e method for reading a short value.\\n     *\\n     * \u003cp\u003e Reads two bytes at the given index, composing them into a\\n     * short value according to the current byte order.  \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index from which the bytes will be read\\n     *\\n     * @return  The short value at the given index\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit,\\n     *          minus one\\n     \"}"}, {"color": "#97c2fc", "id": " abstract short getShortUnchecked(int index)", "label": " abstract short getShortUnchecked(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: {get,put}*Unchecked() accessors.\u0027}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer putShort(int index, short value)", "label": "public abstract ByteBuffer putShort(int index, short value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eput\u003c/i\u003e method for writing a short\\n     * value\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes two bytes containing the given short value, in the\\n     * current byte order, into this buffer at the given index.  \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index at which the bytes will be written\\n     *\\n     * @param  value\\n     *         The short value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit,\\n     *          minus one\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \"}"}, {"color": "#97c2fc", "id": " abstract void putShortUnchecked(int index, short value)", "label": " abstract void putShortUnchecked(int index, short value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: {get,put}*Unchecked() accessors.\u0027}"}, {"color": "#97c2fc", "id": "public abstract ShortBuffer asShortBuffer()", "label": "public abstract ShortBuffer asShortBuffer()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a view of this byte buffer as a short buffer.\\n     *\\n     * \u003cp\u003e The content of the new buffer will start at this buffer\u0027s current\\n     * position.  Changes to this buffer\u0027s content will be visible in the new\\n     * buffer, and vice versa; the two buffers\u0027 position, limit, and mark\\n     * values will be independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s position will be zero, its capacity and its limit\\n     * will be the number of bytes remaining in this buffer divided by\\n     * two, its mark will be undefined, and its byte order will be that\\n     * of the byte buffer at the moment the view is created.  The new buffer\\n     * will be direct if, and only if, this buffer is direct, and it will be\\n     * read-only if, and only if, this buffer is read-only.  \u003c/p\u003e\\n     *\\n     * @return  A new short buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract int getInt()", "label": "public abstract int getInt()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Relative \u003ci\u003eget\u003c/i\u003e method for reading an int value.\\n     *\\n     * \u003cp\u003e Reads the next four bytes at this buffer\u0027s current position,\\n     * composing them into an int value according to the current byte order,\\n     * and then increments the position by four.  \u003c/p\u003e\\n     *\\n     * @return  The int value at the buffer\u0027s current position\\n     *\\n     * @throws  BufferUnderflowException\\n     *          If there are fewer than four bytes\\n     *          remaining in this buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer putInt(int value)", "label": "public abstract ByteBuffer putInt(int value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Relative \u003ci\u003eput\u003c/i\u003e method for writing an int\\n     * value\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes four bytes containing the given int value, in the\\n     * current byte order, into this buffer at the current position, and then\\n     * increments the position by four.  \u003c/p\u003e\\n     *\\n     * @param  value\\n     *         The int value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  BufferOverflowException\\n     *          If there are fewer than four bytes\\n     *          remaining in this buffer\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract int getInt(int index)", "label": "public abstract int getInt(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eget\u003c/i\u003e method for reading an int value.\\n     *\\n     * \u003cp\u003e Reads four bytes at the given index, composing them into a\\n     * int value according to the current byte order.  \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index from which the bytes will be read\\n     *\\n     * @return  The int value at the given index\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit,\\n     *          minus three\\n     \"}"}, {"color": "#97c2fc", "id": " abstract int getIntUnchecked(int index)", "label": " abstract int getIntUnchecked(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: {get,put}*Unchecked() accessors.\u0027}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer putInt(int index, int value)", "label": "public abstract ByteBuffer putInt(int index, int value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eput\u003c/i\u003e method for writing an int\\n     * value\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes four bytes containing the given int value, in the\\n     * current byte order, into this buffer at the given index.  \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index at which the bytes will be written\\n     *\\n     * @param  value\\n     *         The int value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit,\\n     *          minus three\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \"}"}, {"color": "#97c2fc", "id": " abstract void putIntUnchecked(int index, int value)", "label": " abstract void putIntUnchecked(int index, int value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: {get,put}*Unchecked() accessors.\u0027}"}, {"color": "#97c2fc", "id": "public abstract IntBuffer asIntBuffer()", "label": "public abstract IntBuffer asIntBuffer()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a view of this byte buffer as an int buffer.\\n     *\\n     * \u003cp\u003e The content of the new buffer will start at this buffer\u0027s current\\n     * position.  Changes to this buffer\u0027s content will be visible in the new\\n     * buffer, and vice versa; the two buffers\u0027 position, limit, and mark\\n     * values will be independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s position will be zero, its capacity and its limit\\n     * will be the number of bytes remaining in this buffer divided by\\n     * four, its mark will be undefined, and its byte order will be that\\n     * of the byte buffer at the moment the view is created.  The new buffer\\n     * will be direct if, and only if, this buffer is direct, and it will be\\n     * read-only if, and only if, this buffer is read-only.  \u003c/p\u003e\\n     *\\n     * @return  A new int buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract long getLong()", "label": "public abstract long getLong()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Relative \u003ci\u003eget\u003c/i\u003e method for reading a long value.\\n     *\\n     * \u003cp\u003e Reads the next eight bytes at this buffer\u0027s current position,\\n     * composing them into a long value according to the current byte order,\\n     * and then increments the position by eight.  \u003c/p\u003e\\n     *\\n     * @return  The long value at the buffer\u0027s current position\\n     *\\n     * @throws  BufferUnderflowException\\n     *          If there are fewer than eight bytes\\n     *          remaining in this buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer putLong(long value)", "label": "public abstract ByteBuffer putLong(long value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Relative \u003ci\u003eput\u003c/i\u003e method for writing a long\\n     * value\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes eight bytes containing the given long value, in the\\n     * current byte order, into this buffer at the current position, and then\\n     * increments the position by eight.  \u003c/p\u003e\\n     *\\n     * @param  value\\n     *         The long value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  BufferOverflowException\\n     *          If there are fewer than eight bytes\\n     *          remaining in this buffer\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract long getLong(int index)", "label": "public abstract long getLong(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eget\u003c/i\u003e method for reading a long value.\\n     *\\n     * \u003cp\u003e Reads eight bytes at the given index, composing them into a\\n     * long value according to the current byte order.  \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index from which the bytes will be read\\n     *\\n     * @return  The long value at the given index\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit,\\n     *          minus seven\\n     \"}"}, {"color": "#97c2fc", "id": " abstract long getLongUnchecked(int index)", "label": " abstract long getLongUnchecked(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: {get,put}*Unchecked() accessors.\u0027}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer putLong(int index, long value)", "label": "public abstract ByteBuffer putLong(int index, long value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eput\u003c/i\u003e method for writing a long\\n     * value\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes eight bytes containing the given long value, in the\\n     * current byte order, into this buffer at the given index.  \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index at which the bytes will be written\\n     *\\n     * @param  value\\n     *         The long value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit,\\n     *          minus seven\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \"}"}, {"color": "#97c2fc", "id": " abstract void putLongUnchecked(int index, long value)", "label": " abstract void putLongUnchecked(int index, long value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: {get,put}*Unchecked() accessors.\u0027}"}, {"color": "#97c2fc", "id": "public abstract LongBuffer asLongBuffer()", "label": "public abstract LongBuffer asLongBuffer()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a view of this byte buffer as a long buffer.\\n     *\\n     * \u003cp\u003e The content of the new buffer will start at this buffer\u0027s current\\n     * position.  Changes to this buffer\u0027s content will be visible in the new\\n     * buffer, and vice versa; the two buffers\u0027 position, limit, and mark\\n     * values will be independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s position will be zero, its capacity and its limit\\n     * will be the number of bytes remaining in this buffer divided by\\n     * eight, its mark will be undefined, and its byte order will be that\\n     * of the byte buffer at the moment the view is created.  The new buffer\\n     * will be direct if, and only if, this buffer is direct, and it will be\\n     * read-only if, and only if, this buffer is read-only.  \u003c/p\u003e\\n     *\\n     * @return  A new long buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract float getFloat()", "label": "public abstract float getFloat()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Relative \u003ci\u003eget\u003c/i\u003e method for reading a float value.\\n     *\\n     * \u003cp\u003e Reads the next four bytes at this buffer\u0027s current position,\\n     * composing them into a float value according to the current byte order,\\n     * and then increments the position by four.  \u003c/p\u003e\\n     *\\n     * @return  The float value at the buffer\u0027s current position\\n     *\\n     * @throws  BufferUnderflowException\\n     *          If there are fewer than four bytes\\n     *          remaining in this buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer putFloat(float value)", "label": "public abstract ByteBuffer putFloat(float value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Relative \u003ci\u003eput\u003c/i\u003e method for writing a float\\n     * value\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes four bytes containing the given float value, in the\\n     * current byte order, into this buffer at the current position, and then\\n     * increments the position by four.  \u003c/p\u003e\\n     *\\n     * @param  value\\n     *         The float value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  BufferOverflowException\\n     *          If there are fewer than four bytes\\n     *          remaining in this buffer\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract float getFloat(int index)", "label": "public abstract float getFloat(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eget\u003c/i\u003e method for reading a float value.\\n     *\\n     * \u003cp\u003e Reads four bytes at the given index, composing them into a\\n     * float value according to the current byte order.  \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index from which the bytes will be read\\n     *\\n     * @return  The float value at the given index\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit,\\n     *          minus three\\n     \"}"}, {"color": "#97c2fc", "id": " abstract float getFloatUnchecked(int index)", "label": " abstract float getFloatUnchecked(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: {get,put}*Unchecked() accessors.\u0027}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer putFloat(int index, float value)", "label": "public abstract ByteBuffer putFloat(int index, float value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eput\u003c/i\u003e method for writing a float\\n     * value\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes four bytes containing the given float value, in the\\n     * current byte order, into this buffer at the given index.  \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index at which the bytes will be written\\n     *\\n     * @param  value\\n     *         The float value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit,\\n     *          minus three\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \"}"}, {"color": "#97c2fc", "id": " abstract void putFloatUnchecked(int index, float value)", "label": " abstract void putFloatUnchecked(int index, float value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: {get,put}*Unchecked() accessors.\u0027}"}, {"color": "#97c2fc", "id": "public abstract FloatBuffer asFloatBuffer()", "label": "public abstract FloatBuffer asFloatBuffer()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a view of this byte buffer as a float buffer.\\n     *\\n     * \u003cp\u003e The content of the new buffer will start at this buffer\u0027s current\\n     * position.  Changes to this buffer\u0027s content will be visible in the new\\n     * buffer, and vice versa; the two buffers\u0027 position, limit, and mark\\n     * values will be independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s position will be zero, its capacity and its limit\\n     * will be the number of bytes remaining in this buffer divided by\\n     * four, its mark will be undefined, and its byte order will be that\\n     * of the byte buffer at the moment the view is created.  The new buffer\\n     * will be direct if, and only if, this buffer is direct, and it will be\\n     * read-only if, and only if, this buffer is read-only.  \u003c/p\u003e\\n     *\\n     * @return  A new float buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract double getDouble()", "label": "public abstract double getDouble()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Relative \u003ci\u003eget\u003c/i\u003e method for reading a double value.\\n     *\\n     * \u003cp\u003e Reads the next eight bytes at this buffer\u0027s current position,\\n     * composing them into a double value according to the current byte order,\\n     * and then increments the position by eight.  \u003c/p\u003e\\n     *\\n     * @return  The double value at the buffer\u0027s current position\\n     *\\n     * @throws  BufferUnderflowException\\n     *          If there are fewer than eight bytes\\n     *          remaining in this buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer putDouble(double value)", "label": "public abstract ByteBuffer putDouble(double value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Relative \u003ci\u003eput\u003c/i\u003e method for writing a double\\n     * value\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes eight bytes containing the given double value, in the\\n     * current byte order, into this buffer at the current position, and then\\n     * increments the position by eight.  \u003c/p\u003e\\n     *\\n     * @param  value\\n     *         The double value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  BufferOverflowException\\n     *          If there are fewer than eight bytes\\n     *          remaining in this buffer\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract double getDouble(int index)", "label": "public abstract double getDouble(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eget\u003c/i\u003e method for reading a double value.\\n     *\\n     * \u003cp\u003e Reads eight bytes at the given index, composing them into a\\n     * double value according to the current byte order.  \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index from which the bytes will be read\\n     *\\n     * @return  The double value at the given index\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit,\\n     *          minus seven\\n     \"}"}, {"color": "#97c2fc", "id": " abstract double getDoubleUnchecked(int index)", "label": " abstract double getDoubleUnchecked(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: {get,put}*Unchecked() accessors.\u0027}"}, {"color": "#97c2fc", "id": "public abstract ByteBuffer putDouble(int index, double value)", "label": "public abstract ByteBuffer putDouble(int index, double value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Absolute \u003ci\u003eput\u003c/i\u003e method for writing a double\\n     * value\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e Writes eight bytes containing the given double value, in the\\n     * current byte order, into this buffer at the given index.  \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index at which the bytes will be written\\n     *\\n     * @param  value\\n     *         The double value to be written\\n     *\\n     * @return  This buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative\\n     *          or not smaller than the buffer\u0027s limit,\\n     *          minus seven\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is read-only\\n     \"}"}, {"color": "#97c2fc", "id": " abstract void putDoubleUnchecked(int index, double value)", "label": " abstract void putDoubleUnchecked(int index, double value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: {get,put}*Unchecked() accessors.\u0027}"}, {"color": "#97c2fc", "id": "public abstract DoubleBuffer asDoubleBuffer()", "label": "public abstract DoubleBuffer asDoubleBuffer()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a view of this byte buffer as a double buffer.\\n     *\\n     * \u003cp\u003e The content of the new buffer will start at this buffer\u0027s current\\n     * position.  Changes to this buffer\u0027s content will be visible in the new\\n     * buffer, and vice versa; the two buffers\u0027 position, limit, and mark\\n     * values will be independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s position will be zero, its capacity and its limit\\n     * will be the number of bytes remaining in this buffer divided by\\n     * eight, its mark will be undefined, and its byte order will be that\\n     * of the byte buffer at the moment the view is created.  The new buffer\\n     * will be direct if, and only if, this buffer is direct, and it will be\\n     * read-only if, and only if, this buffer is read-only.  \u003c/p\u003e\\n     *\\n     * @return  A new double buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public final int remaining()", "label": "public final int remaining()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the number of elements between the current position and the\\n     * limit.\\n     *\\n     * @return  The number of elements remaining in this buffer\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final boolean hasRemaining()", "label": "public final boolean hasRemaining()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether there are any elements between the current position and\\n     * the limit.\\n     *\\n     * @return  {@code true} if, and only if, there is at least one element\\n     *          remaining in this buffer\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract boolean isReadOnly()", "label": "public abstract boolean isReadOnly()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether this file store is read-only. A file store is read-only if\\n     * it does not support write operations or other changes to files. Any\\n     * attempt to create a file, open an existing file for writing etc. causes\\n     * an {@code IOException} to be thrown.\\n     *\\n     * @return  {@code true} if, and only if, this file store is read-only\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract boolean hasArray()", "label": "public abstract boolean hasArray()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this buffer is backed by an accessible\\n     * array.\\n     *\\n     * \u003cp\u003e If this method returns {@code true} then the {@link #array() array}\\n     * and {@link #arrayOffset() arrayOffset} methods may safely be invoked.\\n     * \u003c/p\u003e\\n     *\\n     * @return  {@code true} if, and only if, this buffer\\n     *          is backed by an array and is not read-only\\n     *\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract Object array()", "label": "public abstract Object array()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the array that backs this\\n     * buffer\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e This method is intended to allow array-backed buffers to be\\n     * passed to native code more efficiently. Concrete subclasses\\n     * provide more strongly-typed return values for this method.\\n     *\\n     * \u003cp\u003e Modifications to this buffer\u0027s content will cause the returned\\n     * array\u0027s content to be modified, and vice versa.\\n     *\\n     * \u003cp\u003e Invoke the {@link #hasArray hasArray} method before invoking this\\n     * method in order to ensure that this buffer has an accessible backing\\n     * array.  \u003c/p\u003e\\n     *\\n     * @return  The array that backs this buffer\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is backed by an array but is read-only\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          If this buffer is not backed by an accessible array\\n     *\\n     * @since 1.6\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract int arrayOffset()", "label": "public abstract int arrayOffset()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the offset within this buffer\u0027s backing array of the first\\n     * element of the buffer\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e If this buffer is backed by an array then buffer position \u003ci\u003ep\u003c/i\u003e\\n     * corresponds to array index \u003ci\u003ep\u003c/i\u003e\u0026nbsp;+\u0026nbsp;{@code arrayOffset()}.\\n     *\\n     * \u003cp\u003e Invoke the {@link #hasArray hasArray} method before invoking this\\n     * method in order to ensure that this buffer has an accessible backing\\n     * array.  \u003c/p\u003e\\n     *\\n     * @return  The offset within this buffer\u0027s array\\n     *          of the first element of the buffer\\n     *\\n     * @throws  ReadOnlyBufferException\\n     *          If this buffer is backed by an array but is read-only\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          If this buffer is not backed by an accessible array\\n     *\\n     * @since 1.6\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract Buffer slice()", "label": "public abstract Buffer slice()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a new buffer whose content is a shared subsequence of\\n     * this buffer\u0027s content.\\n     *\\n     * \u003cp\u003e The content of the new buffer will start at this buffer\u0027s current\\n     * position.  Changes to this buffer\u0027s content will be visible in the new\\n     * buffer, and vice versa; the two buffers\u0027 position, limit, and mark\\n     * values will be independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s position will be zero, its capacity and its limit\\n     * will be the number of elements remaining in this buffer, its mark will be\\n     * undefined. The new buffer will be direct if, and only if, this buffer is\\n     * direct, and it will be read-only if, and only if, this buffer is\\n     * read-only.  \u003c/p\u003e\\n     *\\n     * @return  The new buffer\\n     *\\n     * @since 9\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract Buffer slice(int index, int length)", "label": "public abstract Buffer slice(int index, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a new buffer whose content is a shared subsequence of\\n     * this buffer\u0027s content.\\n     *\\n     * \u003cp\u003e The content of the new buffer will start at position {@code index}\\n     * in this buffer, and will contain {@code length} elements. Changes to\\n     * this buffer\u0027s content will be visible in the new buffer, and vice versa;\\n     * the two buffers\u0027 position, limit, and mark values will be independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s position will be zero, its capacity and its limit\\n     * will be {@code length}, its mark will be undefined. The new buffer will\\n     * be direct if, and only if, this buffer is direct, and it will be\\n     * read-only if, and only if, this buffer is read-only.  \u003c/p\u003e\\n     *\\n     * @param   index\\n     *          The position in this buffer at which the content of the new\\n     *          buffer will start; must be non-negative and no larger than\\n     *          {@link #limit() limit()}\\n     *\\n     * @param   length\\n     *          The number of elements the new buffer will contain; must be\\n     *          non-negative and no larger than {@code limit() - index}\\n     *\\n     * @return  The new buffer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code index} is negative or greater than {@code limit()},\\n     *          {@code length} is negative, or {@code length \u003e limit() - index}\\n     *\\n     * @since 13\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract Buffer duplicate()", "label": "public abstract Buffer duplicate()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a new buffer that shares this buffer\u0027s content.\\n     *\\n     * \u003cp\u003e The content of the new buffer will be that of this buffer.  Changes\\n     * to this buffer\u0027s content will be visible in the new buffer, and vice\\n     * versa; the two buffers\u0027 position, limit, and mark values will be\\n     * independent.\\n     *\\n     * \u003cp\u003e The new buffer\u0027s capacity, limit, position and mark values will be\\n     * identical to those of this buffer. The new buffer will be direct if, and\\n     * only if, this buffer is direct, and it will be read-only if, and only if,\\n     * this buffer is read-only.  \u003c/p\u003e\\n     *\\n     * @return  The new buffer\\n     *\\n     * @since 9\\n     \"}"}, {"color": "#97c2fc", "id": " abstract Object base()", "label": " abstract Object base()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     *\\n     * @return the base reference, paired with the address\\n     * field, which in combination can be used for unsafe access into a heap\\n     * buffer or direct byte buffer (and views of).\\n     \u0027}"}, {"color": "#97c2fc", "id": " final int nextGetIndex()", "label": " final int nextGetIndex()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Checks the current position against the limit, throwing a {@link\\n     * BufferUnderflowException} if it is not smaller than the limit, and then\\n     * increments the position.\\n     *\\n     * @return  The current position value, before it is incremented\\n     \u0027}"}, {"color": "#97c2fc", "id": " final int nextPutIndex()", "label": " final int nextPutIndex()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Checks the current position against the limit, throwing a {@link\\n     * BufferOverflowException} if it is not smaller than the limit, and then\\n     * increments the position.\\n     *\\n     * @return  The current position value, before it is incremented\\n     \u0027}"}, {"color": "#97c2fc", "id": " final int checkIndex(int i)", "label": " final int checkIndex(int i)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Checks the given index against the limit, throwing an {@link\\n     * IndexOutOfBoundsException} if it is not smaller than the limit\\n     * or is smaller than zero.\\n     \u0027}"}, {"color": "#97c2fc", "id": "IndexOutOfBoundsException", "label": "IndexOutOfBoundsException", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public final CoderResult flush(ByteBuffer out)", "label": "public final CoderResult flush(ByteBuffer out)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Flushes this encoder.\\n     *\\n     * \u003cp\u003e Some encoders maintain internal state and may need to write some\\n     * final bytes to the output buffer once the overall input sequence has\\n     * been read.\\n     *\\n     * \u003cp\u003e Any additional output is written to the output buffer beginning at\\n     * its current position.  At most {@link Buffer#remaining out.remaining()}\\n     * bytes will be written.  The buffer\\\u0027s position will be advanced\\n     * appropriately, but its mark and limit will not be modified.\\n     *\\n     * \u003cp\u003e If this method completes successfully then it returns {@link\\n     * CoderResult#UNDERFLOW}.  If there is insufficient room in the output\\n     * buffer then it returns {@link CoderResult#OVERFLOW}.  If this happens\\n     * then this method must be invoked again, with an output buffer that has\\n     * more room, in order to complete the current \u003ca href=\"#steps\"\u003eencoding\\n     * operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003e If this encoder has already been flushed then invoking this method\\n     * has no effect.\\n     *\\n     * \u003cp\u003e This method invokes the {@link #implFlush implFlush} method to\\n     * perform the actual flushing operation.  \u003c/p\u003e\\n     *\\n     * @param  out\\n     *         The output byte buffer\\n     *\\n     * @return  A coder-result object, either {@link CoderResult#UNDERFLOW} or\\n     *          {@link CoderResult#OVERFLOW}\\n     *\\n     * @throws  IllegalStateException\\n     *          If the previous step of the current encoding operation was an\\n     *          invocation neither of the {@link #flush flush} method nor of\\n     *          the three-argument {@link\\n     *          #encode(CharBuffer,ByteBuffer,boolean) encode} method\\n     *          with a value of {@code true} for the {@code endOfInput}\\n     *          parameter\\n     \u0027}"}, {"color": "#97c2fc", "id": "encode(CharBuffer", "label": "encode(CharBuffer", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "flush", "label": "flush", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "implFlush", "label": "implFlush", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "protected CoderResult implFlush(ByteBuffer out)", "label": "protected CoderResult implFlush(ByteBuffer out)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Flushes this encoder.\\n     *\\n     * \u003cp\u003e The default implementation of this method does nothing, and always\\n     * returns {@link CoderResult#UNDERFLOW}.  This method should be overridden\\n     * by encoders that may need to write final bytes to the output buffer\\n     * once the entire input sequence has been read. \u003c/p\u003e\\n     *\\n     * @param  out\\n     *         The output byte buffer\\n     *\\n     * @return  A coder-result object, either {@link CoderResult#UNDERFLOW} or\\n     *          {@link CoderResult#OVERFLOW}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final CharsetEncoder reset()", "label": "public final CharsetEncoder reset()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Resets this encoder, clearing any internal state.\\n     *\\n     * \u003cp\u003e This method resets charset-independent state and also invokes the\\n     * {@link #implReset() implReset} method in order to perform any\\n     * charset-specific reset actions.  \u003c/p\u003e\\n     *\\n     * @return  This encoder\\n     *\\n     \u0027}"}, {"color": "#97c2fc", "id": "implReset()", "label": "implReset()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "protected void implReset()", "label": "protected void implReset()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Resets this decoder, clearing any charset-specific internal state.\\n     *\\n     * \u003cp\u003e The default implementation of this method does nothing.  This method\\n     * should be overridden by decoders that maintain internal state.  \u003c/p\u003e\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected abstract CoderResult encodeLoop(CharBuffer in, ByteBuffer out)", "label": "protected abstract CoderResult encodeLoop(CharBuffer in, ByteBuffer out)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Encodes one or more characters into one or more bytes.\\n     *\\n     * \u003cp\u003e This method encapsulates the basic encoding loop, encoding as many\\n     * characters as possible until it either runs out of input, runs out of room\\n     * in the output buffer, or encounters an encoding error.  This method is\\n     * invoked by the {@link #encode encode} method, which handles result\\n     * interpretation and error recovery.\\n     *\\n     * \u003cp\u003e The buffers are read from, and written to, starting at their current\\n     * positions.  At most {@link Buffer#remaining in.remaining()} characters\\n     * will be read, and at most {@link Buffer#remaining out.remaining()}\\n     * bytes will be written.  The buffers\u0027 positions will be advanced to\\n     * reflect the characters read and the bytes written, but their marks and\\n     * limits will not be modified.\\n     *\\n     * \u003cp\u003e This method returns a {@link CoderResult} object to describe its\\n     * reason for termination, in the same manner as the {@link #encode encode}\\n     * method.  Most implementations of this method will handle encoding errors\\n     * by returning an appropriate result object for interpretation by the\\n     * {@link #encode encode} method.  An optimized implementation may instead\\n     * examine the relevant error action and implement that action itself.\\n     *\\n     * \u003cp\u003e An implementation of this method may perform arbitrary lookahead by\\n     * returning {@link CoderResult#UNDERFLOW} until it receives sufficient\\n     * input.  \u003c/p\u003e\\n     *\\n     * @param  in\\n     *         The input character buffer\\n     *\\n     * @param  out\\n     *         The output byte buffer\\n     *\\n     * @return  A coder-result object describing the reason for termination\\n     \"}"}, {"color": "#97c2fc", "id": "encode", "label": "encode", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public final ByteBuffer encode(CharBuffer in) throws CharacterCodingException", "label": "public final ByteBuffer encode(CharBuffer in) throws CharacterCodingException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Convenience method that encodes the remaining content of a single input\\n     * character buffer into a newly-allocated byte buffer.\\n     *\\n     * \u003cp\u003e This method implements an entire \u003ca href=\"#steps\"\u003eencoding\\n     * operation\u003c/a\u003e; that is, it resets this encoder, then it encodes the\\n     * characters in the given character buffer, and finally it flushes this\\n     * encoder.  This method should therefore not be invoked if an encoding\\n     * operation is already in progress.  \u003c/p\u003e\\n     *\\n     * @param  in\\n     *         The input character buffer\\n     *\\n     * @return A newly-allocated byte buffer containing the result of the\\n     *         encoding operation.  The buffer\\\u0027s position will be zero and its\\n     *         limit will follow the last byte written.\\n     *\\n     * @throws  IllegalStateException\\n     *          If an encoding operation is already in progress\\n     *\\n     * @throws  MalformedInputException\\n     *          If the character sequence starting at the input buffer\\\u0027s current\\n     *          position is not a legal sixteen-bit Unicode sequence and the current malformed-input action\\n     *          is {@link CodingErrorAction#REPORT}\\n     *\\n     * @throws  UnmappableCharacterException\\n     *          If the character sequence starting at the input buffer\\\u0027s current\\n     *          position cannot be mapped to an equivalent byte sequence and\\n     *          the current unmappable-character action is {@link\\n     *          CodingErrorAction#REPORT}\\n     *\\n     * @throws  CoderMalfunctionError\\n     *          If an invocation of the encodeLoop method threw\\n     *          an unexpected exception\\n     *\\n     * @throws  NullPointerException if input buffer is null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean canEncode(char c)", "label": "public boolean canEncode(char c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this encoder can encode the given character.\\n     *\\n     * \u003cp\u003e This method returns {@code false} if the given character is a\\n     * surrogate character; such characters can be interpreted only when they\\n     * are members of a pair consisting of a high surrogate followed by a low\\n     * surrogate.  The {@link #canEncode(java.lang.CharSequence)\\n     * canEncode(CharSequence)} method may be used to test whether or not a\\n     * character sequence can be encoded.\\n     *\\n     * \u003cp\u003e This method may modify this encoder\\\u0027s state; it should therefore not\\n     * be invoked if an \u003ca href=\"#steps\"\u003eencoding operation\u003c/a\u003e is already in\\n     * progress.\\n     *\\n     * \u003cp\u003e The default implementation of this method is not very efficient; it\\n     * should generally be overridden to improve performance.  \u003c/p\u003e\\n     *\\n     * @param   c\\n     *          The given character\\n     *\\n     * @return  {@code true} if, and only if, this encoder can encode\\n     *          the given character\\n     *\\n     * @throws  IllegalStateException\\n     *          If an encoding operation is already in progress\\n     \u0027}"}, {"color": "#97c2fc", "id": "canEncode(java.lang.CharSequence)", "label": "canEncode(java.lang.CharSequence)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public boolean canEncode(CharSequence cs)", "label": "public boolean canEncode(CharSequence cs)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this encoder can encode the given character\\n     * sequence.\\n     *\\n     * \u003cp\u003e If this method returns {@code false} for a particular character\\n     * sequence then more information about why the sequence cannot be encoded\\n     * may be obtained by performing a full \u003ca href=\"#steps\"\u003eencoding\\n     * operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003e This method may modify this encoder\\\u0027s state; it should therefore not\\n     * be invoked if an encoding operation is already in progress.\\n     *\\n     * \u003cp\u003e The default implementation of this method is not very efficient; it\\n     * should generally be overridden to improve performance.  \u003c/p\u003e\\n     *\\n     * @param   cs\\n     *          The given character sequence\\n     *\\n     * @return  {@code true} if, and only if, this encoder can encode\\n     *          the given character without throwing any exceptions and without\\n     *          performing any replacements\\n     *\\n     * @throws  IllegalStateException\\n     *          If an encoding operation is already in progress\\n     \u0027}"}, {"color": "#97c2fc", "id": "public byte[] getBytes(Charset charset)", "label": "public byte[] getBytes(Charset charset)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Encodes this {@code String} into a sequence of bytes using the given\\n     * {@linkplain java.nio.charset.Charset charset}, storing the result into a\\n     * new byte array.\\n     *\\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\\n     * sequences with this charset\u0027s default replacement byte array.  The\\n     * {@link java.nio.charset.CharsetEncoder} class should be used when more\\n     * control over the encoding process is required.\\n     *\\n     * @param  charset\\n     *         The {@linkplain java.nio.charset.Charset} to be used to encode\\n     *         the {@code String}\\n     *\\n     * @return  The resultant byte array\\n     *\\n     * @since  1.6\\n     \"}"}, {"color": "#97c2fc", "id": "public byte[] getBytes()", "label": "public byte[] getBytes()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Encodes this {@code String} into a sequence of bytes using the\\n     * platform\u0027s default charset, storing the result into a new byte array.\\n     *\\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\\n     * the default charset is unspecified.  The {@link\\n     * java.nio.charset.CharsetEncoder} class should be used when more control\\n     * over the encoding process is required.\\n     *\\n     * @return  The resultant byte array\\n     *\\n     * @since      1.1\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean equals(Object anObject)", "label": "public boolean equals(Object anObject)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares this string to the specified object.  The result is {@code\\n     * true} if and only if the argument is not {@code null} and is a {@code\\n     * String} object that represents the same sequence of characters as this\\n     * object.\\n     *\\n     * \u003cp\u003eFor finer-grained String comparison, refer to\\n     * {@link java.text.Collator}.\\n     *\\n     * @param  anObject\\n     *         The object to compare this {@code String} against\\n     *\\n     * @return  {@code true} if the given object represents a {@code String}\\n     *          equivalent to this string, {@code false} otherwise\\n     *\\n     * @see  #compareTo(String)\\n     * @see  #equalsIgnoreCase(String)\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.text.Collator", "label": "java.text.Collator", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public static synchronized Collator getInstance()", "label": "public static synchronized Collator getInstance()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets the Collator for the current default locale.\\n     * The default locale is determined by java.util.Locale.getDefault.\\n     * @return the Collator for the default locale.(for example, en_US)\\n     * @see java.util.Locale#getDefault\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collator getInstance(Locale desiredLocale)", "label": "public static Collator getInstance(Locale desiredLocale)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets the Collator for the desired locale.\\n     * @param desiredLocale the desired locale.\\n     * @return the Collator for the desired locale.\\n     * @see java.util.Locale\\n     * @see java.util.ResourceBundle\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract int compare(String source, String target)", "label": "public abstract int compare(String source, String target)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares the source string to the target string according to the\\n     * collation rules for this Collator.  Returns an integer less than,\\n     * equal to or greater than zero depending on whether the source String is\\n     * less than, equal to or greater than the target string.  See the Collator\\n     * class description for an example of use.\\n     * \u003cp\u003e\\n     * For a one time comparison, this method has the best performance. If a\\n     * given String will be involved in multiple comparisons, CollationKey.compareTo\\n     * has the best performance. See the Collator class description for an example\\n     * using CollationKeys.\\n     * @param source the source string.\\n     * @param target the target string.\\n     * @return Returns an integer value. Value is less than zero if source is less than\\n     * target, value is zero if source and target are equal, value is greater than zero\\n     * if source is greater than target.\\n     * @see java.text.CollationKey\\n     * @see java.text.Collator#getCollationKey\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int compare(Object o1, Object o2)", "label": "public int compare(Object o1, Object o2)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares its two arguments for order.  Returns a negative integer,\\n     * zero, or a positive integer as the first argument is less than, equal\\n     * to, or greater than the second.\\n     * \u003cp\u003e\\n     * This implementation merely returns\\n     *  {@code  compare((String)o1, (String)o2) }.\\n     *\\n     * @return a negative integer, zero, or a positive integer as the\\n     *         first argument is less than, equal to, or greater than the\\n     *         second.\\n     * @throws    ClassCastException the arguments cannot be cast to Strings.\\n     * @see java.util.Comparator\\n     * @since   1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract CollationKey getCollationKey(String source)", "label": "public abstract CollationKey getCollationKey(String source)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Transforms the String into a series of bits that can be compared bitwise\\n     * to other CollationKeys. CollationKeys provide better performance than\\n     * Collator.compare when Strings are involved in multiple comparisons.\\n     * See the Collator class description for an example using CollationKeys.\\n     * @param source the string to be transformed into a collation key.\\n     * @return the CollationKey for the given String based on this Collator\u0027s collation\\n     * rules. If the source String is null, a null CollationKey is returned.\\n     * @see java.text.CollationKey\\n     * @see java.text.Collator#compare\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean equals(String source, String target)", "label": "public boolean equals(String source, String target)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Convenience method for comparing the equality of two strings based on\\n     * this Collator\u0027s collation rules.\\n     * @param source the source string to be compared with.\\n     * @param target the target string to be compared with.\\n     * @return true if the strings are equal according to the collation\\n     * rules.  false, otherwise.\\n     * @see java.text.Collator#compare\\n     \"}"}, {"color": "#97c2fc", "id": "public synchronized int getStrength()", "label": "public synchronized int getStrength()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns this Collator\u0027s strength property.  The strength property determines\\n     * the minimum level of difference considered significant during comparison.\\n     * See the Collator class description for an example of use.\\n     * @return this Collator\u0027s current strength property.\\n     * @see java.text.Collator#setStrength\\n     * @see java.text.Collator#PRIMARY\\n     * @see java.text.Collator#SECONDARY\\n     * @see java.text.Collator#TERTIARY\\n     * @see java.text.Collator#IDENTICAL\\n     \"}"}, {"color": "#97c2fc", "id": "public synchronized void setStrength(int newStrength)", "label": "public synchronized void setStrength(int newStrength)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Sets this Collator\u0027s strength property.  The strength property determines\\n     * the minimum level of difference considered significant during comparison.\\n     * See the Collator class description for an example of use.\\n     * @param newStrength  the new strength value.\\n     * @see java.text.Collator#getStrength\\n     * @see java.text.Collator#PRIMARY\\n     * @see java.text.Collator#SECONDARY\\n     * @see java.text.Collator#TERTIARY\\n     * @see java.text.Collator#IDENTICAL\\n     * @throws     IllegalArgumentException If the new strength value is not one of\\n     * PRIMARY, SECONDARY, TERTIARY or IDENTICAL.\\n     \"}"}, {"color": "#97c2fc", "id": "public synchronized int getDecomposition()", "label": "public synchronized int getDecomposition()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the decomposition mode of this Collator. Decomposition mode\\n     * determines how Unicode composed characters are handled. Adjusting\\n     * decomposition mode allows the user to select between faster and more\\n     * complete collation behavior.\\n     * \u003cp\u003eThe three values for decomposition mode are:\\n     * \u003cUL\u003e\\n     * \u003cLI\u003eNO_DECOMPOSITION,\\n     * \u003cLI\u003eCANONICAL_DECOMPOSITION\\n     * \u003cLI\u003eFULL_DECOMPOSITION.\\n     * \u003c/UL\u003e\\n     * See the documentation for these three constants for a description\\n     * of their meaning.\\n     * @return the decomposition mode\\n     * @see java.text.Collator#setDecomposition\\n     * @see java.text.Collator#NO_DECOMPOSITION\\n     * @see java.text.Collator#CANONICAL_DECOMPOSITION\\n     * @see java.text.Collator#FULL_DECOMPOSITION\\n     \u0027}"}, {"color": "#97c2fc", "id": "public synchronized void setDecomposition(int decompositionMode)", "label": "public synchronized void setDecomposition(int decompositionMode)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Set the decomposition mode of this Collator. See getDecomposition\\n     * for a description of decomposition mode.\\n     * @param decompositionMode  the new decomposition mode.\\n     * @see java.text.Collator#getDecomposition\\n     * @see java.text.Collator#NO_DECOMPOSITION\\n     * @see java.text.Collator#CANONICAL_DECOMPOSITION\\n     * @see java.text.Collator#FULL_DECOMPOSITION\\n     * @throws    IllegalArgumentException If the given value is not a valid decomposition\\n     * mode.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static synchronized Locale[] getAvailableLocales()", "label": "public static synchronized Locale[] getAvailableLocales()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an array of all locales for which the\\n     * {@code getInstance} methods of this class can return\\n     * localized instances.\\n     *\\n     * @return An array of locales for which localized\\n     *         {@code Collator} instances are available.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private int decompositionMode_Java_ICU(int mode)", "label": "private int decompositionMode_Java_ICU(int mode)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: conversion method for decompositionMode constants.\u0027}"}, {"color": "#97c2fc", "id": "public Object clone()", "label": "public Object clone()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Overrides Cloneable.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean equals(Object that)", "label": "public boolean equals(Object that)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares the equality of two Collators.\\n     * @param that the Collator to be compared with this.\\n     * @return true if this Collator is the same as that Collator;\\n     * false otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract int hashCode()", "label": "public abstract int hashCode()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Generates the hash code for this Collator.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean contentEquals(StringBuffer sb)", "label": "public boolean contentEquals(StringBuffer sb)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares this string to the specified {@code StringBuffer}.  The result\\n     * is {@code true} if and only if this {@code String} represents the same\\n     * sequence of characters as the specified {@code StringBuffer}. This method\\n     * synchronizes on the {@code StringBuffer}.\\n     *\\n     * \u003cp\u003eFor finer-grained String comparison, refer to\\n     * {@link java.text.Collator}.\\n     *\\n     * @param  sb\\n     *         The {@code StringBuffer} to compare this {@code String} against\\n     *\\n     * @return  {@code true} if this {@code String} represents the same\\n     *          sequence of characters as the specified {@code StringBuffer},\\n     *          {@code false} otherwise\\n     *\\n     * @since  1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean contentEquals(CharSequence cs)", "label": "public boolean contentEquals(CharSequence cs)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares this string to the specified {@code CharSequence}.  The\\n     * result is {@code true} if and only if this {@code String} represents the\\n     * same sequence of char values as the specified sequence. Note that if the\\n     * {@code CharSequence} is a {@code StringBuffer} then the method\\n     * synchronizes on it.\\n     *\\n     * \u003cp\u003eFor finer-grained String comparison, refer to\\n     * {@link java.text.Collator}.\\n     *\\n     * @param  cs\\n     *         The sequence to compare this {@code String} against\\n     *\\n     * @return  {@code true} if this {@code String} represents the same\\n     *          sequence of char values as the specified sequence, {@code\\n     *          false} otherwise\\n     *\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean equalsIgnoreCase(String anotherString)", "label": "public boolean equalsIgnoreCase(String anotherString)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares this {@code String} to another {@code String}, ignoring case\\n     * considerations.  Two strings are considered equal ignoring case if they\\n     * are of the same length and corresponding characters in the two strings\\n     * are equal ignoring case.\\n     *\\n     * \u003cp\u003e Two characters {@code c1} and {@code c2} are considered the same\\n     * ignoring case if at least one of the following is true:\\n     * \u003cul\u003e\\n     *   \u003cli\u003e The two characters are the same (as compared by the\\n     *        {@code ==} operator)\\n     *   \u003cli\u003e Calling {@code Character.toLowerCase(Character.toUpperCase(char))}\\n     *        on each character produces the same result\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account, and\\n     * will result in unsatisfactory results for certain locales.  The\\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\\n     *\\n     * @param  anotherString\\n     *         The {@code String} to compare this {@code String} against\\n     *\\n     * @return  {@code true} if the argument is not {@code null} and it\\n     *          represents an equivalent {@code String} ignoring case; {@code\\n     *          false} otherwise\\n     *\\n     * @see  #equals(Object)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public native int compareTo(String anotherString)", "label": "public native int compareTo(String anotherString)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public int compareTo(String anotherString) {\\n        byte v1[] = value;\\n        byte v2[] = anotherString.value;\\n        if (coder() == anotherString.coder()) {\\n            return isLatin1() ? StringLatin1.compareTo(v1, v2)\\n                              : StringUTF16.compareTo(v1, v2);\\n        }\\n        return isLatin1() ? StringLatin1.compareToUTF16(v1, v2)\\n                          : StringUTF16.compareToLatin1(v1, v2);\\n     }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public int compareToIgnoreCase(String str)", "label": "public int compareToIgnoreCase(String str)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two strings lexicographically, ignoring case\\n     * differences. This method returns an integer whose sign is that of\\n     * calling {@code compareTo} with normalized versions of the strings\\n     * where case differences have been eliminated by calling\\n     * {@code Character.toLowerCase(Character.toUpperCase(character))} on\\n     * each character.\\n     * \u003cp\u003e\\n     * Note that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\\n     * and will result in an unsatisfactory ordering for certain locales.\\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\\n     *\\n     * @param   str   the {@code String} to be compared.\\n     * @return  a negative integer, zero, or a positive integer as the\\n     *          specified String is greater than, equal to, or less\\n     *          than this String, ignoring case considerations.\\n     * @see     java.text.Collator\\n     * @since   1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean regionMatches(int toffset, String other, int ooffset, int len)", "label": "public boolean regionMatches(int toffset, String other, int ooffset, int len)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests if two string regions are equal.\\n     * \u003cp\u003e\\n     * A substring of this {@code String} object is compared to a substring\\n     * of the argument other. The result is true if these substrings\\n     * represent identical character sequences. The substring of this\\n     * {@code String} object to be compared begins at index {@code toffset}\\n     * and has length {@code len}. The substring of other to be compared\\n     * begins at index {@code ooffset} and has length {@code len}. The\\n     * result is {@code false} if and only if at least one of the following\\n     * is true:\\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is negative.\\n     * \u003cli\u003e{@code ooffset} is negative.\\n     * \u003cli\u003e{@code toffset+len} is greater than the length of this\\n     * {@code String} object.\\n     * \u003cli\u003e{@code ooffset+len} is greater than the length of the other\\n     * argument.\\n     * \u003cli\u003eThere is some nonnegative integer \u003ci\u003ek\u003c/i\u003e less than {@code len}\\n     * such that:\\n     * {@code this.charAt(toffset + }\u003ci\u003ek\u003c/i\u003e{@code ) != other.charAt(ooffset + }\\n     * \u003ci\u003ek\u003c/i\u003e{@code )}\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account.  The\\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\\n     *\\n     * @param   toffset   the starting offset of the subregion in this string.\\n     * @param   other     the string argument.\\n     * @param   ooffset   the starting offset of the subregion in the string\\n     *                    argument.\\n     * @param   len       the number of characters to compare.\\n     * @return  {@code true} if the specified subregion of this string\\n     *          exactly matches the specified subregion of the string argument;\\n     *          {@code false} otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)", "label": "public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests if two string regions are equal.\\n     * \u003cp\u003e\\n     * A substring of this {@code String} object is compared to a substring\\n     * of the argument {@code other}. The result is {@code true} if these\\n     * substrings represent character sequences that are the same, ignoring\\n     * case if and only if {@code ignoreCase} is true. The substring of\\n     * this {@code String} object to be compared begins at index\\n     * {@code toffset} and has length {@code len}. The substring of\\n     * {@code other} to be compared begins at index {@code ooffset} and\\n     * has length {@code len}. The result is {@code false} if and only if\\n     * at least one of the following is true:\\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is negative.\\n     * \u003cli\u003e{@code ooffset} is negative.\\n     * \u003cli\u003e{@code toffset+len} is greater than the length of this\\n     * {@code String} object.\\n     * \u003cli\u003e{@code ooffset+len} is greater than the length of the other\\n     * argument.\\n     * \u003cli\u003e{@code ignoreCase} is {@code false} and there is some nonnegative\\n     * integer \u003ci\u003ek\u003c/i\u003e less than {@code len} such that:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * this.charAt(toffset+k) != other.charAt(ooffset+k)\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * \u003cli\u003e{@code ignoreCase} is {@code true} and there is some nonnegative\\n     * integer \u003ci\u003ek\u003c/i\u003e less than {@code len} such that:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * Character.toLowerCase(Character.toUpperCase(this.charAt(toffset+k))) !=\\n     Character.toLowerCase(Character.toUpperCase(other.charAt(ooffset+k)))\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\\n     * and will result in unsatisfactory results for certain locales when\\n     * {@code ignoreCase} is {@code true}.  The {@link java.text.Collator} class\\n     * provides locale-sensitive comparison.\\n     *\\n     * @param   ignoreCase   if {@code true}, ignore case when comparing\\n     *                       characters.\\n     * @param   toffset      the starting offset of the subregion in this\\n     *                       string.\\n     * @param   other        the string argument.\\n     * @param   ooffset      the starting offset of the subregion in the string\\n     *                       argument.\\n     * @param   len          the number of characters to compare.\\n     * @return  {@code true} if the specified subregion of this string\\n     *          matches the specified subregion of the string argument;\\n     *          {@code false} otherwise. Whether the matching is exact\\n     *          or case insensitive depends on the {@code ignoreCase}\\n     *          argument.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean startsWith(String prefix, int toffset)", "label": "public boolean startsWith(String prefix, int toffset)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests if the substring of this string beginning at the\\n     * specified index starts with the specified prefix.\\n     *\\n     * @param   prefix    the prefix.\\n     * @param   toffset   where to begin looking in this string.\\n     * @return  {@code true} if the character sequence represented by the\\n     *          argument is a prefix of the substring of this object starting\\n     *          at index {@code toffset}; {@code false} otherwise.\\n     *          The result is {@code false} if {@code toffset} is\\n     *          negative or greater than the length of this\\n     *          {@code String} object; otherwise the result is the same\\n     *          as the result of the expression\\n     *          \u003cpre\u003e\\n     *          this.substring(toffset).startsWith(prefix)\\n     *          \u003c/pre\u003e\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean startsWith(String prefix)", "label": "public boolean startsWith(String prefix)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests if this string starts with the specified prefix.\\n     *\\n     * @param   prefix   the prefix.\\n     * @return  {@code true} if the character sequence represented by the\\n     *          argument is a prefix of the character sequence represented by\\n     *          this string; {@code false} otherwise.\\n     *          Note also that {@code true} will be returned if the\\n     *          argument is an empty string or is equal to this\\n     *          {@code String} object as determined by the\\n     *          {@link #equals(Object)} method.\\n     * @since   1.0\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean endsWith(String suffix)", "label": "public boolean endsWith(String suffix)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests if this string ends with the specified suffix.\\n     *\\n     * @param   suffix   the suffix.\\n     * @return  {@code true} if the character sequence represented by the\\n     *          argument is a suffix of the character sequence represented by\\n     *          this object; {@code false} otherwise. Note that the\\n     *          result will be {@code true} if the argument is the\\n     *          empty string or is equal to this {@code String} object\\n     *          as determined by the {@link #equals(Object)} method.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int indexOf(int ch)", "label": "public int indexOf(int ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index within this string of the first occurrence of\\n     * the specified character. If a character with value\\n     * {@code ch} occurs in the character sequence represented by\\n     * this {@code String} object, then the index (in Unicode\\n     * code units) of the first such occurrence is returned. For\\n     * values of {@code ch} in the range from 0 to 0xFFFF\\n     * (inclusive), this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) == ch\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * is true. For other values of {@code ch}, it is the\\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) == ch\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * is true. In either case, if no such character occurs in this\\n     * string, then {@code -1} is returned.\\n     *\\n     * @param   ch   a character (Unicode code point).\\n     * @return  the index of the first occurrence of the character in the\\n     *          character sequence represented by this object, or\\n     *          {@code -1} if the character does not occur.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int indexOf(int ch, int fromIndex)", "label": "public int indexOf(int ch, int fromIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index within this string of the first occurrence of the\\n     * specified character, starting the search at the specified index.\\n     * \u003cp\u003e\\n     * If a character with value {@code ch} occurs in the\\n     * character sequence represented by this {@code String}\\n     * object at an index no smaller than {@code fromIndex}, then\\n     * the index of the first such occurrence is returned. For values\\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) == ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;= fromIndex)\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * is true. For other values of {@code ch}, it is the\\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) == ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;= fromIndex)\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * is true. In either case, if no such character occurs in this\\n     * string at or after position {@code fromIndex}, then\\n     * {@code -1} is returned.\\n     *\\n     * \u003cp\u003e\\n     * There is no restriction on the value of {@code fromIndex}. If it\\n     * is negative, it has the same effect as if it were zero: this entire\\n     * string may be searched. If it is greater than the length of this\\n     * string, it has the same effect as if it were equal to the length of\\n     * this string: {@code -1} is returned.\\n     *\\n     * \u003cp\u003eAll indices are specified in {@code char} values\\n     * (Unicode code units).\\n     *\\n     * @param   ch          a character (Unicode code point).\\n     * @param   fromIndex   the index to start the search from.\\n     * @return  the index of the first occurrence of the character in the\\n     *          character sequence represented by this object that is greater\\n     *          than or equal to {@code fromIndex}, or {@code -1}\\n     *          if the character does not occur.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private int indexOfSupplementary(int ch, int fromIndex)", "label": "private int indexOfSupplementary(int ch, int fromIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Handles (rare) calls of indexOf with a supplementary character.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int lastIndexOf(int ch)", "label": "public int lastIndexOf(int ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index within this string of the last occurrence of\\n     * the specified character. For values of {@code ch} in the\\n     * range from 0 to 0xFFFF (inclusive), the index (in Unicode code\\n     * units) returned is the largest value \u003ci\u003ek\u003c/i\u003e such that:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) == ch\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * is true. For other values of {@code ch}, it is the\\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) == ch\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * is true.  In either case, if no such character occurs in this\\n     * string, then {@code -1} is returned.  The\\n     * {@code String} is searched backwards starting at the last\\n     * character.\\n     *\\n     * @param   ch   a character (Unicode code point).\\n     * @return  the index of the last occurrence of the character in the\\n     *          character sequence represented by this object, or\\n     *          {@code -1} if the character does not occur.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int lastIndexOf(int ch, int fromIndex)", "label": "public int lastIndexOf(int ch, int fromIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index within this string of the last occurrence of\\n     * the specified character, searching backward starting at the\\n     * specified index. For values of {@code ch} in the range\\n     * from 0 to 0xFFFF (inclusive), the index returned is the largest\\n     * value \u003ci\u003ek\u003c/i\u003e such that:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) == ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;= fromIndex)\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * is true. For other values of {@code ch}, it is the\\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) == ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;= fromIndex)\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * is true. In either case, if no such character occurs in this\\n     * string at or before position {@code fromIndex}, then\\n     * {@code -1} is returned.\\n     *\\n     * \u003cp\u003eAll indices are specified in {@code char} values\\n     * (Unicode code units).\\n     *\\n     * @param   ch          a character (Unicode code point).\\n     * @param   fromIndex   the index to start the search from. There is no\\n     *          restriction on the value of {@code fromIndex}. If it is\\n     *          greater than or equal to the length of this string, it has\\n     *          the same effect as if it were equal to one less than the\\n     *          length of this string: this entire string may be searched.\\n     *          If it is negative, it has the same effect as if it were -1:\\n     *          -1 is returned.\\n     * @return  the index of the last occurrence of the character in the\\n     *          character sequence represented by this object that is less\\n     *          than or equal to {@code fromIndex}, or {@code -1}\\n     *          if the character does not occur before that point.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private int lastIndexOfSupplementary(int ch, int fromIndex)", "label": "private int lastIndexOfSupplementary(int ch, int fromIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Handles (rare) calls of lastIndexOf with a supplementary character.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int indexOf(String str)", "label": "public int indexOf(String str)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index within this string of the first occurrence of the\\n     * specified substring.\\n     *\\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\\n     * \u003cpre\u003e{@code\\n     * this.startsWith(str, k)\\n     * }\u003c/pre\u003e\\n     * If no such value of {@code k} exists, then {@code -1} is returned.\\n     *\\n     * @param   str   the substring to search for.\\n     * @return  the index of the first occurrence of the specified substring,\\n     *          or {@code -1} if there is no such occurrence.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int indexOf(String str, int fromIndex)", "label": "public int indexOf(String str, int fromIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index within this string of the first occurrence of the\\n     * specified substring, starting at the specified index.\\n     *\\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\\n     * \u003cpre\u003e{@code\\n     *     k \u003e= Math.min(fromIndex, this.length()) \u0026\u0026\\n     *                   this.startsWith(str, k)\\n     * }\u003c/pre\u003e\\n     * If no such value of {@code k} exists, then {@code -1} is returned.\\n     *\\n     * @param   str         the substring to search for.\\n     * @param   fromIndex   the index from which to start the search.\\n     * @return  the index of the first occurrence of the specified substring,\\n     *          starting at the specified index,\\n     *          or {@code -1} if there is no such occurrence.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static int indexOf(String source, String target, int fromIndex)", "label": "private static int indexOf(String source, String target, int fromIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The source is the string being searched, and the target is the string being searched for.\\n     *\\n     * @param   source       the characters being searched.\\n     * @param   target       the characters being searched for.\\n     * @param   fromIndex    the index to begin searching from.\\n     \u0027}"}, {"color": "#97c2fc", "id": " static int indexOf(byte[] src, byte srcCoder, int srcCount, String tgtStr, int fromIndex)", "label": " static int indexOf(byte[] src, byte srcCoder, int srcCount, String tgtStr, int fromIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Code shared by String and AbstractStringBuilder to do searches. The\\n     * source is the character array being searched, and the target\\n     * is the string being searched for.\\n     *\\n     * @param   src       the characters being searched.\\n     * @param   srcCoder  the coder of the source string.\\n     * @param   srcCount  length of the source string.\\n     * @param   tgtStr    the characters being searched for.\\n     * @param   fromIndex the index to begin searching from.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int lastIndexOf(String str)", "label": "public int lastIndexOf(String str)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index within this string of the last occurrence of the\\n     * specified substring.  The last occurrence of the empty string \"\"\\n     * is considered to occur at the index value {@code this.length()}.\\n     *\\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\\n     * \u003cpre\u003e{@code\\n     * this.startsWith(str, k)\\n     * }\u003c/pre\u003e\\n     * If no such value of {@code k} exists, then {@code -1} is returned.\\n     *\\n     * @param   str   the substring to search for.\\n     * @return  the index of the last occurrence of the specified substring,\\n     *          or {@code -1} if there is no such occurrence.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int lastIndexOf(String str, int fromIndex)", "label": "public int lastIndexOf(String str, int fromIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index within this string of the last occurrence of the\\n     * specified substring, searching backward starting at the specified index.\\n     *\\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\\n     * \u003cpre\u003e{@code\\n     *     k \u003c= Math.min(fromIndex, this.length()) \u0026\u0026\\n     *                   this.startsWith(str, k)\\n     * }\u003c/pre\u003e\\n     * If no such value of {@code k} exists, then {@code -1} is returned.\\n     *\\n     * @param   str         the substring to search for.\\n     * @param   fromIndex   the index to start the search from.\\n     * @return  the index of the last occurrence of the specified substring,\\n     *          searching backward from the specified index,\\n     *          or {@code -1} if there is no such occurrence.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static int lastIndexOf(String source, String target, int fromIndex)", "label": "private static int lastIndexOf(String source, String target, int fromIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The source is the string being searched, and the target is the string being searched for.\\n     *\\n     * @param   source       the characters being searched.\\n     * @param   target       the characters being searched for.\\n     * @param   fromIndex    the index to begin searching from.\\n     \u0027}"}, {"color": "#97c2fc", "id": " static int lastIndexOf(byte[] src, byte srcCoder, int srcCount, String tgtStr, int fromIndex)", "label": " static int lastIndexOf(byte[] src, byte srcCoder, int srcCount, String tgtStr, int fromIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Code shared by String and AbstractStringBuilder to do searches. The\\n     * source is the character array being searched, and the target\\n     * is the string being searched for.\\n     *\\n     * @param   src         the characters being searched.\\n     * @param   srcCoder    coder handles the mapping between bytes/chars\\n     * @param   srcCount    count of the source string.\\n     * @param   tgtStr      the characters being searched for.\\n     * @param   fromIndex   the index to begin searching from.\\n     \u0027}"}, {"color": "#97c2fc", "id": " static int lastIndexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex)", "label": " static int lastIndexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Code shared by String and StringBuffer to do searches. The\\n     * source is the character array being searched, and the target\\n     * is the string being searched for.\\n     *\\n     * @param   source       the characters being searched.\\n     * @param   sourceOffset offset of the source string.\\n     * @param   sourceCount  count of the source string.\\n     * @param   target       the characters being searched for.\\n     * @param   targetOffset offset of the target string.\\n     * @param   targetCount  count of the target string.\\n     * @param   fromIndex    the index to begin searching from.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String substring(int beginIndex)", "label": "public String substring(int beginIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string that is a substring of this string. The\\n     * substring begins with the character at the specified index and\\n     * extends to the end of this string. \u003cp\u003e\\n     * Examples:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * \"unhappy\".substring(2) returns \"happy\"\\n     * \"Harbison\".substring(3) returns \"bison\"\\n     * \"emptiness\".substring(9) returns \"\" (an empty string)\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @param      beginIndex   the beginning index, inclusive.\\n     * @return     the specified substring.\\n     * @exception  IndexOutOfBoundsException  if\\n     *             {@code beginIndex} is negative or larger than the\\n     *             length of this {@code String} object.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String substring(int beginIndex, int endIndex)", "label": "public String substring(int beginIndex, int endIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string that is a substring of this string. The\\n     * substring begins at the specified {@code beginIndex} and\\n     * extends to the character at index {@code endIndex - 1}.\\n     * Thus the length of the substring is {@code endIndex-beginIndex}.\\n     * \u003cp\u003e\\n     * Examples:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * \"hamburger\".substring(4, 8) returns \"urge\"\\n     * \"smiles\".substring(1, 5) returns \"mile\"\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @param      beginIndex   the beginning index, inclusive.\\n     * @param      endIndex     the ending index, exclusive.\\n     * @return     the specified substring.\\n     * @exception  IndexOutOfBoundsException  if the\\n     *             {@code beginIndex} is negative, or\\n     *             {@code endIndex} is larger than the length of\\n     *             this {@code String} object, or\\n     *             {@code beginIndex} is larger than\\n     *             {@code endIndex}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private native String fastSubstring(int start, int length)", "label": "private native String fastSubstring(int start, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-added: Native method to access char storage managed by runtime.\u0027}"}, {"color": "#97c2fc", "id": "public CharSequence subSequence(int beginIndex, int endIndex)", "label": "public CharSequence subSequence(int beginIndex, int endIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a character sequence that is a subsequence of this sequence.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form\\n     *\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * str.subSequence(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * behaves in exactly the same way as the invocation\\n     *\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * str.substring(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @apiNote\\n     * This method is defined so that the {@code String} class can implement\\n     * the {@link CharSequence} interface.\\n     *\\n     * @param   beginIndex   the begin index, inclusive.\\n     * @param   endIndex     the end index, exclusive.\\n     * @return  the specified subsequence.\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          if {@code beginIndex} or {@code endIndex} is negative,\\n     *          if {@code endIndex} is greater than {@code length()},\\n     *          or if {@code beginIndex} is greater than {@code endIndex}\\n     *\\n     * @since 1.4\\n     * @spec JSR-51\\n     \u0027}"}, {"color": "#97c2fc", "id": "public native String concat(String str)", "label": "public native String concat(String str)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public String concat(String str) {\\n        if (str.isEmpty()) {\\n            return this;\\n        }\\n        if (coder() == str.coder()) {\\n            byte[] val = this.value;\\n            byte[] oval = str.value;\\n            int len = val.length + oval.length;\\n            byte[] buf = Arrays.copyOf(val, len);\\n            System.arraycopy(oval, 0, buf, val.length, oval.length);\\n            return new String(buf, coder);\\n        }\\n        int len = length();\\n        int olen = str.length();\\n        byte[] buf = StringUTF16.newBytesFor(len + olen);\\n        getBytes(buf, 0, UTF16);\\n        str.getBytes(buf, len, UTF16);\\n        return new String(buf, UTF16);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public String replace(char oldChar, char newChar)", "label": "public String replace(char oldChar, char newChar)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string resulting from replacing all occurrences of\\n     * {@code oldChar} in this string with {@code newChar}.\\n     * \u003cp\u003e\\n     * If the character {@code oldChar} does not occur in the\\n     * character sequence represented by this {@code String} object,\\n     * then a reference to this {@code String} object is returned.\\n     * Otherwise, a {@code String} object is returned that\\n     * represents a character sequence identical to the character sequence\\n     * represented by this {@code String} object, except that every\\n     * occurrence of {@code oldChar} is replaced by an occurrence\\n     * of {@code newChar}.\\n     * \u003cp\u003e\\n     * Examples:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * \"mesquite in your cellar\".replace(\\\u0027e\\\u0027, \\\u0027o\\\u0027)\\n     *         returns \"mosquito in your collar\"\\n     * \"the war of baronets\".replace(\\\u0027r\\\u0027, \\\u0027y\\\u0027)\\n     *         returns \"the way of bayonets\"\\n     * \"sparring with a purple porpoise\".replace(\\\u0027p\\\u0027, \\\u0027t\\\u0027)\\n     *         returns \"starring with a turtle tortoise\"\\n     * \"JonL\".replace(\\\u0027q\\\u0027, \\\u0027x\\\u0027) returns \"JonL\" (no change)\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @param   oldChar   the old character.\\n     * @param   newChar   the new character.\\n     * @return  a string derived from this string by replacing every\\n     *          occurrence of {@code oldChar} with {@code newChar}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private native String doReplace(char oldChar, char newChar)", "label": "private native String doReplace(char oldChar, char newChar)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Implementation of replace(char oldChar, char newChar) called when we found a match.\u0027}"}, {"color": "#97c2fc", "id": "public boolean matches(String regex)", "label": "public boolean matches(String regex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this string matches the given \u003ca\\n     * href=\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form\\n     * \u003ci\u003estr\u003c/i\u003e{@code .matches(}\u003ci\u003eregex\u003c/i\u003e{@code )} yields exactly the\\n     * same result as the expression\\n     *\\n     * \u003cblockquote\u003e\\n     * {@link java.util.regex.Pattern}.{@link java.util.regex.Pattern#matches(String,CharSequence)\\n     * matches(\u003ci\u003eregex\u003c/i\u003e, \u003ci\u003estr\u003c/i\u003e)}\\n     * \u003c/blockquote\u003e\\n     *\\n     * @param   regex\\n     *          the regular expression to which this string is to be matched\\n     *\\n     * @return  {@code true} if, and only if, this string matches the\\n     *          given regular expression\\n     *\\n     * @throws  PatternSyntaxException\\n     *          if the regular expression\\\u0027s syntax is invalid\\n     *\\n     * @see java.util.regex.Pattern\\n     *\\n     * @since 1.4\\n     * @spec JSR-51\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.util.regex.Pattern", "label": "java.util.regex.Pattern", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public static Pattern compile(String regex)", "label": "public static Pattern compile(String regex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Compiles the given regular expression into a pattern.\\n     *\\n     * @param  regex\\n     *         The expression to be compiled\\n     * @return the given regular expression compiled into a pattern\\n     * @throws  PatternSyntaxException\\n     *          If the expression\u0027s syntax is invalid\\n     \"}"}, {"color": "#97c2fc", "id": "public static Pattern compile(String regex, int flags)", "label": "public static Pattern compile(String regex, int flags)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Compiles the given regular expression into a pattern with the given\\n     * flags.\\n     *\\n     * @param  regex\\n     *         The expression to be compiled\\n     *\\n     * @param  flags\\n     *         Match flags, a bit mask that may include\\n     *         {@link #CASE_INSENSITIVE}, {@link #MULTILINE}, {@link #DOTALL},\\n     *         {@link #UNICODE_CASE}, {@link #UNIX_LINES}, {@link #LITERAL},\\n     *         and {@link #COMMENTS}\\n     *\\n     * @return the given regular expression compiled into a pattern with the given flags\\n     * @throws  IllegalArgumentException\\n     *          If bit values other than those corresponding to the defined\\n     *          match flags are set in {@code flags}\\n     *\\n     * @throws  PatternSyntaxException\\n     *          If the expression\u0027s syntax is invalid\\n     \"}"}, {"color": "#97c2fc", "id": "UNIX_LINES", "label": "UNIX_LINES", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "MULTILINE", "label": "MULTILINE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "LITERAL", "label": "LITERAL", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "CASE_INSENSITIVE", "label": "CASE_INSENSITIVE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "UNICODE_CASE", "label": "UNICODE_CASE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "DOTALL", "label": "DOTALL", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "COMMENTS", "label": "COMMENTS", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public String pattern()", "label": "public String pattern()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the regular expression from which this pattern was compiled.\\n     *\\n     * @return  The source of this pattern\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Matcher matcher(CharSequence input)", "label": "public Matcher matcher(CharSequence input)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a matcher that will match the given input against this pattern.\\n     *\\n     * @param  input\\n     *         The character sequence to be matched\\n     *\\n     * @return  A new matcher for this pattern\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int flags()", "label": "public int flags()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns this pattern\u0027s match flags.\\n     *\\n     * @return  The match flags specified when this pattern was compiled\\n     \"}"}, {"color": "#97c2fc", "id": "public static boolean matches(String regex, CharSequence input)", "label": "public static boolean matches(String regex, CharSequence input)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Compiles the given regular expression and attempts to match the given\\n     * input against it.\\n     *\\n     * \u003cp\u003e An invocation of this convenience method of the form\\n     *\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * Pattern.matches(regex, input);\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * behaves in exactly the same way as the expression\\n     *\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * Pattern.compile(regex).matcher(input).matches()\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * \u003cp\u003e If a pattern is to be used multiple times, compiling it once and reusing\\n     * it will be more efficient than invoking this method each time.  \u003c/p\u003e\\n     *\\n     * @param  regex\\n     *         The expression to be compiled\\n     *\\n     * @param  input\\n     *         The character sequence to be matched\\n     * @return whether or not the regular expression matches on the input\\n     * @throws  PatternSyntaxException\\n     *          If the expression\u0027s syntax is invalid\\n     \"}"}, {"color": "#97c2fc", "id": "public String[] split(CharSequence input, int limit)", "label": "public String[] split(CharSequence input, int limit)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Splits the given input sequence around matches of this pattern.\\n     *\\n     * \u003cp\u003e The array returned by this method contains each substring of the\\n     * input sequence that is terminated by another subsequence that matches\\n     * this pattern or is terminated by the end of the input sequence.  The\\n     * substrings in the array are in the order in which they occur in the\\n     * input. If this pattern does not match any subsequence of the input then\\n     * the resulting array has just one element, namely the input sequence in\\n     * string form.\\n     *\\n     * \u003cp\u003e When there is a positive-width match at the beginning of the input\\n     * sequence then an empty leading substring is included at the beginning\\n     * of the resulting array. A zero-width match at the beginning however\\n     * can only produce such an empty leading substring for apps running on or\\n     * targeting API versions \u003c= 28.\\n     *\\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\\n     * pattern is applied and therefore affects the length of the resulting\\n     * array.\\n     * \u003cul\u003e\\n     *    \u003cli\u003e\u003cp\u003e\\n     *    If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\\\u0027s length will be\\n     *    no greater than \u003ci\u003elimit\u003c/i\u003e, and the array\\\u0027s last entry will contain\\n     *    all input beyond the last matched delimiter.\u003c/p\u003e\u003c/li\u003e\\n     *\\n     *    \u003cli\u003e\u003cp\u003e\\n     *    If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\\n     *    many times as possible, the array can have any length, and trailing\\n     *    empty strings will be discarded.\u003c/p\u003e\u003c/li\u003e\\n     *\\n     *    \u003cli\u003e\u003cp\u003e\\n     *    If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\\n     *    as many times as possible and the array can have any length.\u003c/p\u003e\u003c/li\u003e\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003e The input {@code \"boo:and:foo\"}, for example, yields the following\\n     * results with these parameters:\\n     *\\n     * \u003ctable class=\"plain\" style=\"margin-left:2em;\"\u003e\\n     * \u003ccaption style=\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\\n     * \u003cthead\u003e\\n     * \u003ctr\u003e\\n     *     \u003cth scope=\"col\"\u003eRegex\u003c/th\u003e\\n     *     \u003cth scope=\"col\"\u003eLimit\u003c/th\u003e\\n     *     \u003cth scope=\"col\"\u003eResult\u003c/th\u003e\\n     * \u003c/tr\u003e\\n     * \u003c/thead\u003e\\n     * \u003ctbody\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\" rowspan=\"3\" style=\"font-weight:normal\"\u003e:\u003c/th\u003e\\n     *     \u003cth scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"boo\", \"and:foo\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003c!-- : --\u003e\\n     *     \u003cth scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003c!-- : --\u003e\\n     *     \u003cth scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\" rowspan=\"3\" style=\"font-weight:normal\"\u003eo\u003c/th\u003e\\n     *     \u003cth scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003c!-- o --\u003e\\n     *     \u003cth scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003c!-- o --\u003e\\n     *     \u003cth scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003c/tbody\u003e\\n     * \u003c/table\u003e\\n     *\\n     * @param  input\\n     *         The character sequence to be split\\n     *\\n     * @param  limit\\n     *         The result threshold, as described above\\n     *\\n     * @return  The array of strings computed by splitting the input\\n     *          around matches of this pattern\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String[] split(CharSequence input)", "label": "public String[] split(CharSequence input)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Splits the given input sequence around matches of this pattern.\\n     *\\n     * \u003cp\u003e This method works as if by invoking the two-argument {@link\\n     * #split(java.lang.CharSequence, int) split} method with the given input\\n     * sequence and a limit argument of zero.  Trailing empty strings are\\n     * therefore not included in the resulting array. \u003c/p\u003e\\n     *\\n     * \u003cp\u003e The input {@code \"boo:and:foo\"}, for example, yields the following\\n     * results with these expressions:\\n     *\\n     * \u003ctable class=\"plain\" style=\"margin-left:2em\"\u003e\\n     * \u003ccaption style=\"display:none\"\u003eSplit examples showing regex and result\u003c/caption\u003e\\n     * \u003cthead\u003e\\n     * \u003ctr\u003e\\n     *  \u003cth scope=\"col\"\u003eRegex\u003c/th\u003e\\n     *  \u003cth scope=\"col\"\u003eResult\u003c/th\u003e\\n     * \u003c/tr\u003e\\n     * \u003c/thead\u003e\\n     * \u003ctbody\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\" style=\"text-weight:normal\"\u003e:\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\" style=\"text-weight:normal\"\u003eo\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003c/tbody\u003e\\n     * \u003c/table\u003e\\n     *\\n     *\\n     * @param  input\\n     *         The character sequence to be split\\n     *\\n     * @return  The array of strings computed by splitting the input\\n     *          around matches of this pattern\\n     \u0027}"}, {"color": "#97c2fc", "id": "split(java.lang.CharSequence", "label": "split(java.lang.CharSequence", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static String quote(String s)", "label": "public static String quote(String s)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a literal pattern {@code String} for the specified\\n     * {@code String}.\\n     *\\n     * \u003cp\u003eThis method produces a {@code String} that can be used to\\n     * create a {@code Pattern} that would match the string\\n     * {@code s} as if it were a literal pattern.\u003c/p\u003e Metacharacters\\n     * or escape sequences in the input sequence will be given no special\\n     * meaning.\\n     *\\n     * @param  s The string to be literalized\\n     * @return  A literal string replacement\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void compile() throws PatternSyntaxException", "label": "private void compile() throws PatternSyntaxException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Use native implementation instead of \u003e 3000 lines of helper methods.\u0027}"}, {"color": "#97c2fc", "id": "public Predicate\u003cString\u003e asPredicate()", "label": "public Predicate\u003cString\u003e asPredicate()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a predicate that tests if this pattern is found in a given input\\n     * string.\\n     *\\n     * @apiNote\\n     * This method creates a predicate that behaves as if it creates a matcher\\n     * from the input sequence and then calls {@code find}, for example a\\n     * predicate of the form:\\n     * \u003cpre\u003e{@code\\n     *   s -\u003e matcher(s).find();\\n     * }\u003c/pre\u003e\\n     *\\n     * @return  The predicate which can be used for finding a match on a\\n     *          subsequence of a string\\n     * @since   1.8\\n     * @see     Matcher#find\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Predicate\u003cString\u003e asMatchPredicate()", "label": "public Predicate\u003cString\u003e asMatchPredicate()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a predicate that tests if this pattern matches a given input string.\\n     *\\n     * @apiNote\\n     * This method creates a predicate that behaves as if it creates a matcher\\n     * from the input sequence and then calls {@code matches}, for example a\\n     * predicate of the form:\\n     * \u003cpre\u003e{@code\\n     *   s -\u003e matcher(s).matches();\\n     * }\u003c/pre\u003e\\n     *\\n     * @return  The predicate which can be used for matching an input string\\n     *          against this pattern.\\n     * @since   11\\n     * @see     Matcher#matches\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Stream\u003cString\u003e splitAsStream(final CharSequence input)", "label": "public Stream\u003cString\u003e splitAsStream(final CharSequence input)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a stream from the given input sequence around matches of this\\n     * pattern.\\n     *\\n     * \u003cp\u003e The stream returned by this method contains each substring of the\\n     * input sequence that is terminated by another subsequence that matches\\n     * this pattern or is terminated by the end of the input sequence.  The\\n     * substrings in the stream are in the order in which they occur in the\\n     * input. Trailing empty strings will be discarded and not encountered in\\n     * the stream.\\n     *\\n     * \u003cp\u003e If this pattern does not match any subsequence of the input then\\n     * the resulting stream has just one element, namely the input sequence in\\n     * string form.\\n     *\\n     * \u003cp\u003e When there is a positive-width match at the beginning of the input\\n     * sequence then an empty leading substring is included at the beginning\\n     * of the stream. A zero-width match at the beginning however never produces\\n     * such empty leading substring.\\n     *\\n     * \u003cp\u003e If the input sequence is mutable, it must remain constant during the\\n     * execution of the terminal stream operation.  Otherwise, the result of the\\n     * terminal stream operation is undefined.\\n     *\\n     * @param   input\\n     *          The character sequence to be split\\n     *\\n     * @return  The stream of strings computed by splitting the input\\n     *          around matches of this pattern\\n     * @see     #split(CharSequence)\\n     * @since   1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean contains(CharSequence s)", "label": "public boolean contains(CharSequence s)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns true if and only if this string contains the specified\\n     * sequence of char values.\\n     *\\n     * @param s the sequence to search for\\n     * @return true if this string contains {@code s}, false otherwise\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String replaceFirst(String regex, String replacement)", "label": "public String replaceFirst(String regex, String replacement)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Replaces the first substring of this string that matches the given \u003ca\\n     * href=\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\\n     * given replacement.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form\\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceFirst(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\\n     * yields exactly the same result as the expression\\n     *\\n     * \u003cblockquote\u003e\\n     * \u003ccode\u003e\\n     * {@link java.util.regex.Pattern}.{@link\\n     * java.util.regex.Pattern#compile compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\\n     * java.util.regex.Matcher#replaceFirst replaceFirst}(\u003ci\u003erepl\u003c/i\u003e)\\n     * \u003c/code\u003e\\n     * \u003c/blockquote\u003e\\n     *\\n     *\u003cp\u003e\\n     * Note that backslashes ({@code \\\\}) and dollar signs ({@code $}) in the\\n     * replacement string may cause the results to be different than if it were\\n     * being treated as a literal replacement string; see\\n     * {@link java.util.regex.Matcher#replaceFirst}.\\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\\n     * meaning of these characters, if desired.\\n     *\\n     * @param   regex\\n     *          the regular expression to which this string is to be matched\\n     * @param   replacement\\n     *          the string to be substituted for the first match\\n     *\\n     * @return  The resulting {@code String}\\n     *\\n     * @throws  PatternSyntaxException\\n     *          if the regular expression\\\u0027s syntax is invalid\\n     *\\n     * @see java.util.regex.Pattern\\n     *\\n     * @since 1.4\\n     * @spec JSR-51\\n     \u0027}"}, {"color": "#97c2fc", "id": "replaceFirst", "label": "replaceFirst", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.util.regex.Matcher", "label": "java.util.regex.Matcher", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public Pattern pattern()", "label": "public Pattern pattern()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the pattern that is interpreted by this matcher.\\n     *\\n     * @return  The pattern for which this matcher was created\\n     \u0027}"}, {"color": "#97c2fc", "id": "public MatchResult toMatchResult()", "label": "public MatchResult toMatchResult()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the match state of this matcher as a {@link MatchResult}.\\n     * The result is unaffected by subsequent operations performed upon this\\n     * matcher.\\n     *\\n     * @return  a {@code MatchResult} with the state of this matcher\\n     * @throws IllegalStateException if no match is found.\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.util.regex.MatchResult", "label": "java.util.regex.MatchResult", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * The result of a match operation.\\n *\\n * \u003cp\u003eThis interface contains query methods used to determine the\\n * results of a match against a regular expression. The match boundaries,\\n * groups and group boundaries can be seen but not modified through\\n * a {@code MatchResult}.\\n *\\n * @author  Michael McCloskey\\n * @see Matcher\\n * @since 1.5\\n \u0027}"}, {"color": "#97c2fc", "id": "public int start()", "label": "public int start()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the start index of the previous match.\\n     *\\n     * @return  The index of the first character matched\\n     *\\n     * @throws  IllegalStateException\\n     *          If no match has yet been attempted,\\n     *          or if the previous match operation failed\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int start(int group)", "label": "public int start(int group)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the start index of the subsequence captured by the given group\\n     * during the previous match operation.\\n     *\\n     * \u003cp\u003e \u003ca href=\"Pattern.html#cg\"\u003eCapturing groups\u003c/a\u003e are indexed from left\\n     * to right, starting at one.  Group zero denotes the entire pattern, so\\n     * the expression \u003ci\u003em.\u003c/i\u003e{@code start(0)} is equivalent to\\n     * \u003ci\u003em.\u003c/i\u003e{@code start()}.  \u003c/p\u003e\\n     *\\n     * @param  group\\n     *         The index of a capturing group in this matcher\\\u0027s pattern\\n     *\\n     * @return  The index of the first character captured by the group,\\n     *          or {@code -1} if the match was successful but the group\\n     *          itself did not match anything\\n     *\\n     * @throws  IllegalStateException\\n     *          If no match has yet been attempted,\\n     *          or if the previous match operation failed\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If there is no capturing group in the pattern\\n     *          with the given index\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int end()", "label": "public int end()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the offset after the last character matched.\\n     *\\n     * @return  The offset after the last character matched\\n     *\\n     * @throws  IllegalStateException\\n     *          If no match has yet been attempted,\\n     *          or if the previous match operation failed\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int end(int group)", "label": "public int end(int group)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the offset after the last character of the subsequence\\n     * captured by the given group during the previous match operation.\\n     *\\n     * \u003cp\u003e \u003ca href=\"Pattern.html#cg\"\u003eCapturing groups\u003c/a\u003e are indexed from left\\n     * to right, starting at one.  Group zero denotes the entire pattern, so\\n     * the expression \u003ci\u003em.\u003c/i\u003e{@code end(0)} is equivalent to\\n     * \u003ci\u003em.\u003c/i\u003e{@code end()}.  \u003c/p\u003e\\n     *\\n     * @param  group\\n     *         The index of a capturing group in this matcher\\\u0027s pattern\\n     *\\n     * @return  The offset after the last character captured by the group,\\n     *          or {@code -1} if the match was successful\\n     *          but the group itself did not match anything\\n     *\\n     * @throws  IllegalStateException\\n     *          If no match has yet been attempted,\\n     *          or if the previous match operation failed\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If there is no capturing group in the pattern\\n     *          with the given index\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String group()", "label": "public String group()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the input subsequence matched by the previous match.\\n     *\\n     * \u003cp\u003e For a matcher \u003ci\u003em\u003c/i\u003e with input sequence \u003ci\u003es\u003c/i\u003e,\\n     * the expressions \u003ci\u003em.\u003c/i\u003e{@code group()} and\\n     * \u003ci\u003es.\u003c/i\u003e{@code substring(}\u003ci\u003em.\u003c/i\u003e{@code start(),}\u0026nbsp;\u003ci\u003em.\u003c/i\u003e\\n     * {@code end())} are equivalent.  \u003c/p\u003e\\n     *\\n     * \u003cp\u003e Note that some patterns, for example {@code a*}, match the empty\\n     * string.  This method will return the empty string when the pattern\\n     * successfully matches the empty string in the input.  \u003c/p\u003e\\n     *\\n     * @return The (possibly empty) subsequence matched by the previous match,\\n     *         in string form\\n     *\\n     * @throws  IllegalStateException\\n     *          If no match has yet been attempted,\\n     *          or if the previous match operation failed\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String group(int group)", "label": "public String group(int group)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the input subsequence captured by the given group during the\\n     * previous match operation.\\n     *\\n     * \u003cp\u003e For a matcher \u003ci\u003em\u003c/i\u003e, input sequence \u003ci\u003es\u003c/i\u003e, and group index\\n     * \u003ci\u003eg\u003c/i\u003e, the expressions \u003ci\u003em.\u003c/i\u003e{@code group(}\u003ci\u003eg\u003c/i\u003e{@code )} and\\n     * \u003ci\u003es.\u003c/i\u003e{@code substring(}\u003ci\u003em.\u003c/i\u003e{@code start(}\u003ci\u003eg\u003c/i\u003e{@code\\n     * ),}\u0026nbsp;\u003ci\u003em.\u003c/i\u003e{@code end(}\u003ci\u003eg\u003c/i\u003e{@code ))}\\n     * are equivalent.  \u003c/p\u003e\\n     *\\n     * \u003cp\u003e \u003ca href=\"Pattern.html#cg\"\u003eCapturing groups\u003c/a\u003e are indexed from left\\n     * to right, starting at one.  Group zero denotes the entire pattern, so\\n     * the expression {@code m.group(0)} is equivalent to {@code m.group()}.\\n     * \u003c/p\u003e\\n     *\\n     * \u003cp\u003e If the match was successful but the group specified failed to match\\n     * any part of the input sequence, then {@code null} is returned. Note\\n     * that some groups, for example {@code (a*)}, match the empty string.\\n     * This method will return the empty string when such a group successfully\\n     * matches the empty string in the input.  \u003c/p\u003e\\n     *\\n     * @param  group\\n     *         The index of a capturing group in this matcher\\\u0027s pattern\\n     *\\n     * @return  The (possibly empty) subsequence captured by the group\\n     *          during the previous match, or {@code null} if the group\\n     *          failed to match part of the input\\n     *\\n     * @throws  IllegalStateException\\n     *          If no match has yet been attempted,\\n     *          or if the previous match operation failed\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If there is no capturing group in the pattern\\n     *          with the given index\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int groupCount()", "label": "public int groupCount()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the number of capturing groups in this matcher\u0027s pattern.\\n     *\\n     * \u003cp\u003e Group zero denotes the entire pattern by convention. It is not\\n     * included in this count.\\n     *\\n     * \u003cp\u003e Any non-negative integer smaller than or equal to the value\\n     * returned by this method is guaranteed to be a valid group index for\\n     * this matcher.  \u003c/p\u003e\\n     *\\n     * @return The number of capturing groups in this matcher\u0027s pattern\\n     \"}"}, {"color": "#97c2fc", "id": "public Matcher usePattern(Pattern newPattern)", "label": "public Matcher usePattern(Pattern newPattern)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Changes the {@code Pattern} that this {@code Matcher} uses to\\n     * find matches with.\\n     *\\n     * \u003cp\u003e This method causes this matcher to lose information\\n     * about the groups of the last match that occurred. The\\n     * matcher\u0027s position in the input is maintained and its\\n     * last append position is unaffected.\u003c/p\u003e\\n     *\\n     * @param  newPattern\\n     *         The new pattern used by this matcher\\n     * @return  This matcher\\n     * @throws  IllegalArgumentException\\n     *          If newPattern is {@code null}\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": "public Matcher reset()", "label": "public Matcher reset()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Resets this matcher.\\n     *\\n     * \u003cp\u003e Resetting a matcher discards all of its explicit state information\\n     * and sets its append position to zero. The matcher\u0027s region is set to the\\n     * default region, which is its entire character sequence. The anchoring\\n     * and transparency of this matcher\u0027s region boundaries are unaffected.\\n     *\\n     * @return  This matcher\\n     \"}"}, {"color": "#97c2fc", "id": "public Matcher reset(CharSequence input)", "label": "public Matcher reset(CharSequence input)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Resets this matcher with a new input sequence.\\n     *\\n     * \u003cp\u003e Resetting a matcher discards all of its explicit state information\\n     * and sets its append position to zero.  The matcher\u0027s region is set to\\n     * the default region, which is its entire character sequence.  The\\n     * anchoring and transparency of this matcher\u0027s region boundaries are\\n     * unaffected.\\n     *\\n     * @param  input\\n     *         The new input character sequence\\n     *\\n     * @return  This matcher\\n     \"}"}, {"color": "#97c2fc", "id": "public int start(String name)", "label": "public int start(String name)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the start index of the subsequence captured by the given\\n     * \u003ca href=\"Pattern.html#groupname\"\u003enamed-capturing group\u003c/a\u003e during the\\n     * previous match operation.\\n     *\\n     * @param  name\\n     *         The name of a named-capturing group in this matcher\\\u0027s pattern\\n     *\\n     * @return  The index of the first character captured by the group,\\n     *          or {@code -1} if the match was successful but the group\\n     *          itself did not match anything\\n     *\\n     * @throws  IllegalStateException\\n     *          If no match has yet been attempted,\\n     *          or if the previous match operation failed\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If there is no capturing group in the pattern\\n     *          with the given name\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int end(String name)", "label": "public int end(String name)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the offset after the last character of the subsequence\\n     * captured by the given \u003ca href=\"Pattern.html#groupname\"\u003enamed-capturing\\n     * group\u003c/a\u003e during the previous match operation.\\n     *\\n     * @param  name\\n     *         The name of a named-capturing group in this matcher\\\u0027s pattern\\n     *\\n     * @return  The offset after the last character captured by the group,\\n     *          or {@code -1} if the match was successful\\n     *          but the group itself did not match anything\\n     *\\n     * @throws  IllegalStateException\\n     *          If no match has yet been attempted,\\n     *          or if the previous match operation failed\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If there is no capturing group in the pattern\\n     *          with the given name\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String group(String name)", "label": "public String group(String name)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the input subsequence captured by the given\\n     * \u003ca href=\"Pattern.html#groupname\"\u003enamed-capturing group\u003c/a\u003e during the\\n     * previous match operation.\\n     *\\n     * \u003cp\u003e If the match was successful but the group specified failed to match\\n     * any part of the input sequence, then {@code null} is returned. Note\\n     * that some groups, for example {@code (a*)}, match the empty string.\\n     * This method will return the empty string when such a group successfully\\n     * matches the empty string in the input.  \u003c/p\u003e\\n     *\\n     * @param  name\\n     *         The name of a named-capturing group in this matcher\\\u0027s pattern\\n     *\\n     * @return  The (possibly empty) subsequence captured by the named group\\n     *          during the previous match, or {@code null} if the group\\n     *          failed to match part of the input\\n     *\\n     * @throws  IllegalStateException\\n     *          If no match has yet been attempted,\\n     *          or if the previous match operation failed\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If there is no capturing group in the pattern\\n     *          with the given name\\n     * @since 1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean matches()", "label": "public boolean matches()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Attempts to match the entire region against the pattern.\\n     *\\n     * \u003cp\u003e If the match succeeds then more information can be obtained via the\\n     * {@code start}, {@code end}, and {@code group} methods.  \u003c/p\u003e\\n     *\\n     * @return  {@code true} if, and only if, the entire region sequence\\n     *          matches this matcher\u0027s pattern\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean find()", "label": "public boolean find()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Attempts to find the next subsequence of the input sequence that matches\\n     * the pattern.\\n     *\\n     * \u003cp\u003e This method starts at the beginning of this matcher\u0027s region, or, if\\n     * a previous invocation of the method was successful and the matcher has\\n     * not since been reset, at the first character not matched by the previous\\n     * match.\\n     *\\n     * \u003cp\u003e If the match succeeds then more information can be obtained via the\\n     * {@code start}, {@code end}, and {@code group} methods.  \u003c/p\u003e\\n     *\\n     * @return  {@code true} if, and only if, a subsequence of the input\\n     *          sequence matches this matcher\u0027s pattern\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean find(int start)", "label": "public boolean find(int start)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Resets this matcher and then attempts to find the next subsequence of\\n     * the input sequence that matches the pattern, starting at the specified\\n     * index.\\n     *\\n     * \u003cp\u003e If the match succeeds then more information can be obtained via the\\n     * {@code start}, {@code end}, and {@code group} methods, and subsequent\\n     * invocations of the {@link #find()} method will start at the first\\n     * character not matched by this match.  \u003c/p\u003e\\n     *\\n     * @param start the index to start searching for a match\\n     * @throws  IndexOutOfBoundsException\\n     *          If start is less than zero or if start is greater than the\\n     *          length of the input sequence.\\n     *\\n     * @return  {@code true} if, and only if, a subsequence of the input\\n     *          sequence starting at the given index matches this matcher\u0027s\\n     *          pattern\\n     \"}"}, {"color": "#97c2fc", "id": "find()", "label": "find()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public boolean lookingAt()", "label": "public boolean lookingAt()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Attempts to match the input sequence, starting at the beginning of the\\n     * region, against the pattern.\\n     *\\n     * \u003cp\u003e Like the {@link #matches matches} method, this method always starts\\n     * at the beginning of the region; unlike that method, it does not\\n     * require that the entire region be matched.\\n     *\\n     * \u003cp\u003e If the match succeeds then more information can be obtained via the\\n     * {@code start}, {@code end}, and {@code group} methods.  \u003c/p\u003e\\n     *\\n     * @return  {@code true} if, and only if, a prefix of the input\\n     *          sequence matches this matcher\u0027s pattern\\n     \"}"}, {"color": "#97c2fc", "id": "matches", "label": "matches", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static String quoteReplacement(String s)", "label": "public static String quoteReplacement(String s)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a literal replacement {@code String} for the specified\\n     * {@code String}.\\n     *\\n     * This method produces a {@code String} that will work\\n     * as a literal replacement {@code s} in the\\n     * {@code appendReplacement} method of the {@link Matcher} class.\\n     * The {@code String} produced will match the sequence of characters\\n     * in {@code s} treated as a literal sequence. Slashes (\u0027\\\\\u0027) and\\n     * dollar signs (\u0027$\u0027) will be given no special meaning.\\n     *\\n     * @param  s The string to be literalized\\n     * @return  A literal string replacement\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": "public Matcher appendReplacement(StringBuffer sb, String replacement)", "label": "public Matcher appendReplacement(StringBuffer sb, String replacement)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Implements a non-terminal append-and-replace step.\\n     *\\n     * \u003cp\u003e This method performs the following actions: \u003c/p\u003e\\n     *\\n     * \u003col\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e It reads characters from the input sequence, starting at the\\n     *   append position, and appends them to the given string buffer.  It\\n     *   stops after reading the last character preceding the previous match,\\n     *   that is, the character at index {@link\\n     *   #start()}\u0026nbsp;{@code -}\u0026nbsp;{@code 1}.  \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e It appends the given replacement string to the string buffer.\\n     *   \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e It sets the append position of this matcher to the index of\\n     *   the last character matched, plus one, that is, to {@link #end()}.\\n     *   \u003c/p\u003e\u003c/li\u003e\\n     *\\n     * \u003c/ol\u003e\\n     *\\n     * \u003cp\u003e The replacement string may contain references to subsequences\\n     * captured during the previous match: Each occurrence of\\n     * \u003ccode\u003e${\u003c/code\u003e\u003ci\u003ename\u003c/i\u003e\u003ccode\u003e}\u003c/code\u003e or {@code $}\u003ci\u003eg\u003c/i\u003e\\n     * will be replaced by the result of evaluating the corresponding\\n     * {@link #group(String) group(name)} or {@link #group(int) group(g)}\\n     * respectively. For {@code $}\u003ci\u003eg\u003c/i\u003e,\\n     * the first number after the {@code $} is always treated as part of\\n     * the group reference. Subsequent numbers are incorporated into g if\\n     * they would form a legal group reference. Only the numerals \\\u00270\\\u0027\\n     * through \\\u00279\\\u0027 are considered as potential components of the group\\n     * reference. If the second group matched the string {@code \"foo\"}, for\\n     * example, then passing the replacement string {@code \"$2bar\"} would\\n     * cause {@code \"foobar\"} to be appended to the string buffer. A dollar\\n     * sign ({@code $}) may be included as a literal in the replacement\\n     * string by preceding it with a backslash ({@code \\\\$}).\\n     *\\n     * \u003cp\u003e Note that backslashes ({@code \\\\}) and dollar signs ({@code $}) in\\n     * the replacement string may cause the results to be different than if it\\n     * were being treated as a literal replacement string. Dollar signs may be\\n     * treated as references to captured subsequences as described above, and\\n     * backslashes are used to escape literal characters in the replacement\\n     * string.\\n     *\\n     * \u003cp\u003e This method is intended to be used in a loop together with the\\n     * {@link #appendTail(StringBuffer) appendTail} and {@link #find() find}\\n     * methods.  The following code, for example, writes {@code one dog two dogs\\n     * in the yard} to the standard-output stream: \u003c/p\u003e\\n     *\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * Pattern p = Pattern.compile(\"cat\");\\n     * Matcher m = p.matcher(\"one cat two cats in the yard\");\\n     * StringBuffer sb = new StringBuffer();\\n     * while (m.find()) {\\n     *     m.appendReplacement(sb, \"dog\");\\n     * }\\n     * m.appendTail(sb);\\n     * System.out.println(sb.toString());\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @param  sb\\n     *         The target string buffer\\n     *\\n     * @param  replacement\\n     *         The replacement string\\n     *\\n     * @return  This matcher\\n     *\\n     * @throws  IllegalStateException\\n     *          If no match has yet been attempted,\\n     *          or if the previous match operation failed\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the replacement string refers to a named-capturing\\n     *          group that does not exist in the pattern\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If the replacement string refers to a capturing group\\n     *          that does not exist in the pattern\\n     \u0027}"}, {"color": "#97c2fc", "id": "group(String)", "label": "group(String)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "start()", "label": "start()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "end()", "label": "end()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "appendTail(StringBuffer)", "label": "appendTail(StringBuffer)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "group(int)", "label": "group(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public Matcher appendReplacement(StringBuilder sb, String replacement)", "label": "public Matcher appendReplacement(StringBuilder sb, String replacement)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Implements a non-terminal append-and-replace step.\\n     *\\n     * \u003cp\u003e This method performs the following actions: \u003c/p\u003e\\n     *\\n     * \u003col\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e It reads characters from the input sequence, starting at the\\n     *   append position, and appends them to the given string builder.  It\\n     *   stops after reading the last character preceding the previous match,\\n     *   that is, the character at index {@link\\n     *   #start()}\u0026nbsp;{@code -}\u0026nbsp;{@code 1}.  \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e It appends the given replacement string to the string builder.\\n     *   \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e It sets the append position of this matcher to the index of\\n     *   the last character matched, plus one, that is, to {@link #end()}.\\n     *   \u003c/p\u003e\u003c/li\u003e\\n     *\\n     * \u003c/ol\u003e\\n     *\\n     * \u003cp\u003e The replacement string may contain references to subsequences\\n     * captured during the previous match: Each occurrence of\\n     * {@code $}\u003ci\u003eg\u003c/i\u003e will be replaced by the result of\\n     * evaluating {@link #group(int) group}{@code (}\u003ci\u003eg\u003c/i\u003e{@code )}.\\n     * The first number after the {@code $} is always treated as part of\\n     * the group reference. Subsequent numbers are incorporated into g if\\n     * they would form a legal group reference. Only the numerals \\\u00270\\\u0027\\n     * through \\\u00279\\\u0027 are considered as potential components of the group\\n     * reference. If the second group matched the string {@code \"foo\"}, for\\n     * example, then passing the replacement string {@code \"$2bar\"} would\\n     * cause {@code \"foobar\"} to be appended to the string builder. A dollar\\n     * sign ({@code $}) may be included as a literal in the replacement\\n     * string by preceding it with a backslash ({@code \\\\$}).\\n     *\\n     * \u003cp\u003e Note that backslashes ({@code \\\\}) and dollar signs ({@code $}) in\\n     * the replacement string may cause the results to be different than if it\\n     * were being treated as a literal replacement string. Dollar signs may be\\n     * treated as references to captured subsequences as described above, and\\n     * backslashes are used to escape literal characters in the replacement\\n     * string.\\n     *\\n     * \u003cp\u003e This method is intended to be used in a loop together with the\\n     * {@link #appendTail(StringBuilder) appendTail} and\\n     * {@link #find() find} methods. The following code, for example, writes\\n     * {@code one dog two dogs in the yard} to the standard-output stream: \u003c/p\u003e\\n     *\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * Pattern p = Pattern.compile(\"cat\");\\n     * Matcher m = p.matcher(\"one cat two cats in the yard\");\\n     * StringBuilder sb = new StringBuilder();\\n     * while (m.find()) {\\n     *     m.appendReplacement(sb, \"dog\");\\n     * }\\n     * m.appendTail(sb);\\n     * System.out.println(sb.toString());\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @param  sb\\n     *         The target string builder\\n     * @param  replacement\\n     *         The replacement string\\n     * @return  This matcher\\n     *\\n     * @throws  IllegalStateException\\n     *          If no match has yet been attempted,\\n     *          or if the previous match operation failed\\n     * @throws  IllegalArgumentException\\n     *          If the replacement string refers to a named-capturing\\n     *          group that does not exist in the pattern\\n     * @throws  IndexOutOfBoundsException\\n     *          If the replacement string refers to a capturing group\\n     *          that does not exist in the pattern\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "appendTail(StringBuilder)", "label": "appendTail(StringBuilder)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public StringBuffer appendTail(StringBuffer sb)", "label": "public StringBuffer appendTail(StringBuffer sb)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Implements a terminal append-and-replace step.\\n     *\\n     * \u003cp\u003e This method reads characters from the input sequence, starting at\\n     * the append position, and appends them to the given string buffer.  It is\\n     * intended to be invoked after one or more invocations of the {@link\\n     * #appendReplacement(StringBuffer, String) appendReplacement} method in\\n     * order to copy the remainder of the input sequence.  \u003c/p\u003e\\n     *\\n     * @param  sb\\n     *         The target string buffer\\n     *\\n     * @return  The target string buffer\\n     \u0027}"}, {"color": "#97c2fc", "id": "appendReplacement(StringBuffer", "label": "appendReplacement(StringBuffer", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public StringBuilder appendTail(StringBuilder sb)", "label": "public StringBuilder appendTail(StringBuilder sb)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Implements a terminal append-and-replace step.\\n     *\\n     * \u003cp\u003e This method reads characters from the input sequence, starting at\\n     * the append position, and appends them to the given string builder.  It is\\n     * intended to be invoked after one or more invocations of the {@link\\n     * #appendReplacement(StringBuilder, String)\\n     * appendReplacement} method in order to copy the remainder of the input\\n     * sequence.  \u003c/p\u003e\\n     *\\n     * @param  sb\\n     *         The target string builder\\n     *\\n     * @return  The target string builder\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "appendReplacement(StringBuilder", "label": "appendReplacement(StringBuilder", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public String replaceAll(String replacement)", "label": "public String replaceAll(String replacement)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Replaces every subsequence of the input sequence that matches the\\n     * pattern with the given replacement string.\\n     *\\n     * \u003cp\u003e This method first resets this matcher.  It then scans the input\\n     * sequence looking for matches of the pattern.  Characters that are not\\n     * part of any match are appended directly to the result string; each match\\n     * is replaced in the result by the replacement string.  The replacement\\n     * string may contain references to captured subsequences as in the {@link\\n     * #appendReplacement appendReplacement} method.\\n     *\\n     * \u003cp\u003e Note that backslashes ({@code \\\\}) and dollar signs ({@code $}) in\\n     * the replacement string may cause the results to be different than if it\\n     * were being treated as a literal replacement string. Dollar signs may be\\n     * treated as references to captured subsequences as described above, and\\n     * backslashes are used to escape literal characters in the replacement\\n     * string.\\n     *\\n     * \u003cp\u003e Given the regular expression {@code a*b}, the input\\n     * {@code \"aabfooaabfooabfoob\"}, and the replacement string\\n     * {@code \"-\"}, an invocation of this method on a matcher for that\\n     * expression would yield the string {@code \"-foo-foo-foo-\"}.\\n     *\\n     * \u003cp\u003e Invoking this method changes this matcher\\\u0027s state.  If the matcher\\n     * is to be used in further matching operations then it should first be\\n     * reset.  \u003c/p\u003e\\n     *\\n     * @param  replacement\\n     *         The replacement string\\n     *\\n     * @return  The string constructed by replacing each matching subsequence\\n     *          by the replacement string, substituting captured subsequences\\n     *          as needed\\n     \u0027}"}, {"color": "#97c2fc", "id": "appendReplacement", "label": "appendReplacement", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public String replaceAll(Function\u003cMatchResult, String\u003e replacer)", "label": "public String replaceAll(Function\u003cMatchResult, String\u003e replacer)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Replaces every subsequence of the input sequence that matches the\\n     * pattern with the result of applying the given replacer function to the\\n     * match result of this matcher corresponding to that subsequence.\\n     * Exceptions thrown by the function are relayed to the caller.\\n     *\\n     * \u003cp\u003e This method first resets this matcher.  It then scans the input\\n     * sequence looking for matches of the pattern.  Characters that are not\\n     * part of any match are appended directly to the result string; each match\\n     * is replaced in the result by the applying the replacer function that\\n     * returns a replacement string.  Each replacement string may contain\\n     * references to captured subsequences as in the {@link #appendReplacement\\n     * appendReplacement} method.\\n     *\\n     * \u003cp\u003e Note that backslashes ({@code \\\\}) and dollar signs ({@code $}) in\\n     * a replacement string may cause the results to be different than if it\\n     * were being treated as a literal replacement string. Dollar signs may be\\n     * treated as references to captured subsequences as described above, and\\n     * backslashes are used to escape literal characters in the replacement\\n     * string.\\n     *\\n     * \u003cp\u003e Given the regular expression {@code dog}, the input\\n     * {@code \"zzzdogzzzdogzzz\"}, and the function\\n     * {@code mr -\u003e mr.group().toUpperCase()}, an invocation of this method on\\n     * a matcher for that expression would yield the string\\n     * {@code \"zzzDOGzzzDOGzzz\"}.\\n     *\\n     * \u003cp\u003e Invoking this method changes this matcher\\\u0027s state.  If the matcher\\n     * is to be used in further matching operations then it should first be\\n     * reset.  \u003c/p\u003e\\n     *\\n     * \u003cp\u003e The replacer function should not modify this matcher\\\u0027s state during\\n     * replacement.  This method will, on a best-effort basis, throw a\\n     * {@link java.util.ConcurrentModificationException} if such modification is\\n     * detected.\\n     *\\n     * \u003cp\u003e The state of each match result passed to the replacer function is\\n     * guaranteed to be constant only for the duration of the replacer function\\n     * call and only if the replacer function does not modify this matcher\\\u0027s\\n     * state.\\n     *\\n     * @implNote\\n     * This implementation applies the replacer function to this matcher, which\\n     * is an instance of {@code MatchResult}.\\n     *\\n     * @param  replacer\\n     *         The function to be applied to the match result of this matcher\\n     *         that returns a replacement string.\\n     * @return  The string constructed by replacing each matching subsequence\\n     *          with the result of applying the replacer function to that\\n     *          matched subsequence, substituting captured subsequences as\\n     *          needed.\\n     * @throws NullPointerException if the replacer function is null\\n     * @throws ConcurrentModificationException if it is detected, on a\\n     *         best-effort basis, that the replacer function modified this\\n     *         matcher\\\u0027s state\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "appendReplacementappendReplacement", "label": "appendReplacementappendReplacement", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.util.ConcurrentModificationException", "label": "java.util.ConcurrentModificationException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * This exception may be thrown by methods that have detected concurrent\\n * modification of an object when such modification is not permissible.\\n * \u003cp\u003e\\n * For example, it is not generally permissible for one thread to modify a Collection\\n * while another thread is iterating over it.  In general, the results of the\\n * iteration are undefined under these circumstances.  Some Iterator\\n * implementations (including those of all the general purpose collection implementations\\n * provided by the JRE) may choose to throw this exception if this behavior is\\n * detected.  Iterators that do this are known as \u003ci\u003efail-fast\u003c/i\u003e iterators,\\n * as they fail quickly and cleanly, rather that risking arbitrary,\\n * non-deterministic behavior at an undetermined time in the future.\\n * \u003cp\u003e\\n * Note that this exception does not always indicate that an object has\\n * been concurrently modified by a \u003ci\u003edifferent\u003c/i\u003e thread.  If a single\\n * thread issues a sequence of method invocations that violates the\\n * contract of an object, the object may throw this exception.  For\\n * example, if a thread modifies a collection directly while it is\\n * iterating over the collection with a fail-fast iterator, the iterator\\n * will throw this exception.\\n *\\n * \u003cp\u003eNote that fail-fast behavior cannot be guaranteed as it is, generally\\n * speaking, impossible to make any hard guarantees in the presence of\\n * unsynchronized concurrent modification.  Fail-fast operations\\n * throw {@code ConcurrentModificationException} on a best-effort basis.\\n * Therefore, it would be wrong to write a program that depended on this\\n * exception for its correctness: \u003ci\u003e{@code ConcurrentModificationException}\\n * should be used only to detect bugs.\u003c/i\u003e\\n *\\n * @author  Josh Bloch\\n * @see     Collection\\n * @see     Iterator\\n * @see     Spliterator\\n * @see     ListIterator\\n * @see     Vector\\n * @see     LinkedList\\n * @see     HashSet\\n * @see     Hashtable\\n * @see     TreeMap\\n * @see     AbstractList\\n * @since   1.2\\n \u0027}"}, {"color": "#97c2fc", "id": "public Stream\u003cMatchResult\u003e results()", "label": "public Stream\u003cMatchResult\u003e results()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a stream of match results for each subsequence of the input\\n     * sequence that matches the pattern.  The match results occur in the\\n     * same order as the matching subsequences in the input sequence.\\n     *\\n     * \u003cp\u003e Each match result is produced as if by {@link #toMatchResult()}.\\n     *\\n     * \u003cp\u003e This method does not reset this matcher.  Matching starts on\\n     * initiation of the terminal stream operation either at the beginning of\\n     * this matcher\u0027s region, or, if the matcher has not since been reset, at\\n     * the first character not matched by a previous match.\\n     *\\n     * \u003cp\u003e If the matcher is to be used for further matching operations after\\n     * the terminal stream operation completes then it should be first reset.\\n     *\\n     * \u003cp\u003e This matcher\u0027s state should not be modified during execution of the\\n     * returned stream\u0027s pipeline.  The returned stream\u0027s source\\n     * {@code Spliterator} is \u003cem\u003efail-fast\u003c/em\u003e and will, on a best-effort\\n     * basis, throw a {@link java.util.ConcurrentModificationException} if such\\n     * modification is detected.\\n     *\\n     * @return a sequential stream of match results.\\n     * @since 9\\n     \"}"}, {"color": "#97c2fc", "id": "toMatchResult()", "label": "toMatchResult()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public String replaceFirst(String replacement)", "label": "public String replaceFirst(String replacement)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Replaces the first subsequence of the input sequence that matches the\\n     * pattern with the given replacement string.\\n     *\\n     * \u003cp\u003e This method first resets this matcher.  It then scans the input\\n     * sequence looking for a match of the pattern.  Characters that are not\\n     * part of the match are appended directly to the result string; the match\\n     * is replaced in the result by the replacement string.  The replacement\\n     * string may contain references to captured subsequences as in the {@link\\n     * #appendReplacement appendReplacement} method.\\n     *\\n     * \u003cp\u003eNote that backslashes ({@code \\\\}) and dollar signs ({@code $}) in\\n     * the replacement string may cause the results to be different than if it\\n     * were being treated as a literal replacement string. Dollar signs may be\\n     * treated as references to captured subsequences as described above, and\\n     * backslashes are used to escape literal characters in the replacement\\n     * string.\\n     *\\n     * \u003cp\u003e Given the regular expression {@code dog}, the input\\n     * {@code \"zzzdogzzzdogzzz\"}, and the replacement string\\n     * {@code \"cat\"}, an invocation of this method on a matcher for that\\n     * expression would yield the string {@code \"zzzcatzzzdogzzz\"}.  \u003c/p\u003e\\n     *\\n     * \u003cp\u003e Invoking this method changes this matcher\\\u0027s state.  If the matcher\\n     * is to be used in further matching operations then it should first be\\n     * reset.  \u003c/p\u003e\\n     *\\n     * @param  replacement\\n     *         The replacement string\\n     * @return  The string constructed by replacing the first matching\\n     *          subsequence by the replacement string, substituting captured\\n     *          subsequences as needed\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String replaceFirst(Function\u003cMatchResult, String\u003e replacer)", "label": "public String replaceFirst(Function\u003cMatchResult, String\u003e replacer)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Replaces the first subsequence of the input sequence that matches the\\n     * pattern with the result of applying the given replacer function to the\\n     * match result of this matcher corresponding to that subsequence.\\n     * Exceptions thrown by the replace function are relayed to the caller.\\n     *\\n     * \u003cp\u003e This method first resets this matcher.  It then scans the input\\n     * sequence looking for a match of the pattern.  Characters that are not\\n     * part of the match are appended directly to the result string; the match\\n     * is replaced in the result by the applying the replacer function that\\n     * returns a replacement string.  The replacement string may contain\\n     * references to captured subsequences as in the {@link #appendReplacement\\n     * appendReplacement} method.\\n     *\\n     * \u003cp\u003eNote that backslashes ({@code \\\\}) and dollar signs ({@code $}) in\\n     * the replacement string may cause the results to be different than if it\\n     * were being treated as a literal replacement string. Dollar signs may be\\n     * treated as references to captured subsequences as described above, and\\n     * backslashes are used to escape literal characters in the replacement\\n     * string.\\n     *\\n     * \u003cp\u003e Given the regular expression {@code dog}, the input\\n     * {@code \"zzzdogzzzdogzzz\"}, and the function\\n     * {@code mr -\u003e mr.group().toUpperCase()}, an invocation of this method on\\n     * a matcher for that expression would yield the string\\n     * {@code \"zzzDOGzzzdogzzz\"}.\\n     *\\n     * \u003cp\u003e Invoking this method changes this matcher\\\u0027s state.  If the matcher\\n     * is to be used in further matching operations then it should first be\\n     * reset.\\n     *\\n     * \u003cp\u003e The replacer function should not modify this matcher\\\u0027s state during\\n     * replacement.  This method will, on a best-effort basis, throw a\\n     * {@link java.util.ConcurrentModificationException} if such modification is\\n     * detected.\\n     *\\n     * \u003cp\u003e The state of the match result passed to the replacer function is\\n     * guaranteed to be constant only for the duration of the replacer function\\n     * call and only if the replacer function does not modify this matcher\\\u0027s\\n     * state.\\n     *\\n     * @implNote\\n     * This implementation applies the replacer function to this matcher, which\\n     * is an instance of {@code MatchResult}.\\n     *\\n     * @param  replacer\\n     *         The function to be applied to the match result of this matcher\\n     *         that returns a replacement string.\\n     * @return  The string constructed by replacing the first matching\\n     *          subsequence with the result of applying the replacer function to\\n     *          the matched subsequence, substituting captured subsequences as\\n     *          needed.\\n     * @throws NullPointerException if the replacer function is null\\n     * @throws ConcurrentModificationException if it is detected, on a\\n     *         best-effort basis, that the replacer function modified this\\n     *         matcher\\\u0027s state\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Matcher region(int start, int end)", "label": "public Matcher region(int start, int end)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Sets the limits of this matcher\u0027s region. The region is the part of the\\n     * input sequence that will be searched to find a match. Invoking this\\n     * method resets the matcher, and then sets the region to start at the\\n     * index specified by the {@code start} parameter and end at the\\n     * index specified by the {@code end} parameter.\\n     *\\n     * \u003cp\u003eDepending on the transparency and anchoring being used (see\\n     * {@link #useTransparentBounds(boolean) useTransparentBounds} and\\n     * {@link #useAnchoringBounds(boolean) useAnchoringBounds}), certain\\n     * constructs such as anchors may behave differently at or around the\\n     * boundaries of the region.\\n     *\\n     * @param  start\\n     *         The index to start searching at (inclusive)\\n     * @param  end\\n     *         The index to end searching at (exclusive)\\n     * @throws  IndexOutOfBoundsException\\n     *          If start or end is less than zero, if\\n     *          start is greater than the length of the input sequence, if\\n     *          end is greater than the length of the input sequence, or if\\n     *          start is greater than end.\\n     * @return  this matcher\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": "useTransparentBounds(boolean)", "label": "useTransparentBounds(boolean)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "useAnchoringBounds(boolean)", "label": "useAnchoringBounds(boolean)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public int regionStart()", "label": "public int regionStart()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reports the start index of this matcher\u0027s region. The\\n     * searches this matcher conducts are limited to finding matches\\n     * within {@link #regionStart() regionStart} (inclusive) and\\n     * {@link #regionEnd() regionEnd} (exclusive).\\n     *\\n     * @return  The starting point of this matcher\u0027s region\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": "regionEnd()", "label": "regionEnd()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "regionStart()", "label": "regionStart()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public int regionEnd()", "label": "public int regionEnd()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reports the end index (exclusive) of this matcher\u0027s region.\\n     * The searches this matcher conducts are limited to finding matches\\n     * within {@link #regionStart() regionStart} (inclusive) and\\n     * {@link #regionEnd() regionEnd} (exclusive).\\n     *\\n     * @return  the ending point of this matcher\u0027s region\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean hasTransparentBounds()", "label": "public boolean hasTransparentBounds()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Queries the transparency of region bounds for this matcher.\\n     *\\n     * \u003cp\u003e This method returns {@code true} if this matcher uses\\n     * \u003ci\u003etransparent\u003c/i\u003e bounds, {@code false} if it uses \u003ci\u003eopaque\u003c/i\u003e\\n     * bounds.\\n     *\\n     * \u003cp\u003e See {@link #useTransparentBounds(boolean) useTransparentBounds} for a\\n     * description of transparent and opaque bounds.\\n     *\\n     * \u003cp\u003e By default, a matcher uses opaque region boundaries.\\n     *\\n     * @return {@code true} iff this matcher is using transparent bounds,\\n     *         {@code false} otherwise.\\n     * @see java.util.regex.Matcher#useTransparentBounds(boolean)\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Matcher useTransparentBounds(boolean b)", "label": "public Matcher useTransparentBounds(boolean b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Sets the transparency of region bounds for this matcher.\\n     *\\n     * \u003cp\u003e Invoking this method with an argument of {@code true} will set this\\n     * matcher to use \u003ci\u003etransparent\u003c/i\u003e bounds. If the boolean\\n     * argument is {@code false}, then \u003ci\u003eopaque\u003c/i\u003e bounds will be used.\\n     *\\n     * \u003cp\u003e Using transparent bounds, the boundaries of this\\n     * matcher\u0027s region are transparent to lookahead, lookbehind,\\n     * and boundary matching constructs. Those constructs can see beyond the\\n     * boundaries of the region to see if a match is appropriate.\\n     *\\n     * \u003cp\u003e Using opaque bounds, the boundaries of this matcher\u0027s\\n     * region are opaque to lookahead, lookbehind, and boundary matching\\n     * constructs that may try to see beyond them. Those constructs cannot\\n     * look past the boundaries so they will fail to match anything outside\\n     * of the region.\\n     *\\n     * \u003cp\u003e By default, a matcher uses opaque bounds.\\n     *\\n     * @param  b a boolean indicating whether to use opaque or transparent\\n     *         regions\\n     * @return this matcher\\n     * @see java.util.regex.Matcher#hasTransparentBounds\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean hasAnchoringBounds()", "label": "public boolean hasAnchoringBounds()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Queries the anchoring of region bounds for this matcher.\\n     *\\n     * \u003cp\u003e This method returns {@code true} if this matcher uses\\n     * \u003ci\u003eanchoring\u003c/i\u003e bounds, {@code false} otherwise.\\n     *\\n     * \u003cp\u003e See {@link #useAnchoringBounds(boolean) useAnchoringBounds} for a\\n     * description of anchoring bounds.\\n     *\\n     * \u003cp\u003e By default, a matcher uses anchoring region boundaries.\\n     *\\n     * @return {@code true} iff this matcher is using anchoring bounds,\\n     *         {@code false} otherwise.\\n     * @see java.util.regex.Matcher#useAnchoringBounds(boolean)\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Matcher useAnchoringBounds(boolean b)", "label": "public Matcher useAnchoringBounds(boolean b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Sets the anchoring of region bounds for this matcher.\\n     *\\n     * \u003cp\u003e Invoking this method with an argument of {@code true} will set this\\n     * matcher to use \u003ci\u003eanchoring\u003c/i\u003e bounds. If the boolean\\n     * argument is {@code false}, then \u003ci\u003enon-anchoring\u003c/i\u003e bounds will be\\n     * used.\\n     *\\n     * \u003cp\u003e Using anchoring bounds, the boundaries of this\\n     * matcher\u0027s region match anchors such as ^ and $.\\n     *\\n     * \u003cp\u003e Without anchoring bounds, the boundaries of this\\n     * matcher\u0027s region will not match anchors such as ^ and $.\\n     *\\n     * \u003cp\u003e By default, a matcher uses anchoring region boundaries.\\n     *\\n     * @param  b a boolean indicating whether or not to use anchoring bounds.\\n     * @return this matcher\\n     * @see java.util.regex.Matcher#hasAnchoringBounds\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean hitEnd()", "label": "public boolean hitEnd()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * \u003cp\u003eReturns true if the end of input was hit by the search engine in\\n     * the last match operation performed by this matcher.\\n     *\\n     * \u003cp\u003eWhen this method returns true, then it is possible that more input\\n     * would have changed the result of the last search.\\n     *\\n     * @return  true iff the end of input was hit in the last match; false\\n     *          otherwise\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean requireEnd()", "label": "public boolean requireEnd()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * \u003cp\u003eReturns true if more input could change a positive match into a\\n     * negative one.\\n     *\\n     * \u003cp\u003eIf this method returns true, and a match was found, then more\\n     * input could cause the match to be lost. If this method returns false\\n     * and a match was found, then more input might change the match but the\\n     * match won\u0027t be lost. If a match was not found, then requireEnd has no\\n     * meaning.\\n     *\\n     * @return  true iff more input could change a positive match into a\\n     *          negative one.\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": " int getTextLength()", "label": " int getTextLength()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the end index of the text.\\n     *\\n     * @return the index after the last character in the text\\n     \u0027}"}, {"color": "#97c2fc", "id": " CharSequence getSubSequence(int beginIndex, int endIndex)", "label": " CharSequence getSubSequence(int beginIndex, int endIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Generates a String from this matcher\u0027s input in the specified range.\\n     *\\n     * @param  beginIndex   the beginning index, inclusive\\n     * @param  endIndex     the ending index, exclusive\\n     * @return A String generated from this matcher\u0027s input\\n     \"}"}, {"color": "#97c2fc", "id": "private Matcher reset(CharSequence input, int start, int end)", "label": "private Matcher reset(CharSequence input, int start, int end)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Resets the Matcher. A new input sequence and a new region can be\\n     * specified. Results of a previous find get lost. The next attempt to find\\n     * an occurrence of the Pattern in the string will start at the beginning of\\n     * the region. This is the internal version of reset() to which the several\\n     * public versions delegate.\\n     *\\n     * @param input\\n     *            the input sequence.\\n     * @param start\\n     *            the start of the region.\\n     * @param end\\n     *            the end of the region.\\n     *\\n     * @return the matcher itself.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void ensureMatch()", "label": "private void ensureMatch()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Makes sure that a successful match has been made. Is invoked internally\\n     * from various places in the class.\\n     *\\n     * @throws IllegalStateException\\n     *             if no successful match has been made.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String replaceAll(String regex, String replacement)", "label": "public String replaceAll(String regex, String replacement)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Replaces each substring of this string that matches the given \u003ca\\n     * href=\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\\n     * given replacement.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form\\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceAll(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\\n     * yields exactly the same result as the expression\\n     *\\n     * \u003cblockquote\u003e\\n     * \u003ccode\u003e\\n     * {@link java.util.regex.Pattern}.{@link\\n     * java.util.regex.Pattern#compile compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\\n     * java.util.regex.Matcher#replaceAll replaceAll}(\u003ci\u003erepl\u003c/i\u003e)\\n     * \u003c/code\u003e\\n     * \u003c/blockquote\u003e\\n     *\\n     *\u003cp\u003e\\n     * Note that backslashes ({@code \\\\}) and dollar signs ({@code $}) in the\\n     * replacement string may cause the results to be different than if it were\\n     * being treated as a literal replacement string; see\\n     * {@link java.util.regex.Matcher#replaceAll Matcher.replaceAll}.\\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\\n     * meaning of these characters, if desired.\\n     *\\n     * @param   regex\\n     *          the regular expression to which this string is to be matched\\n     * @param   replacement\\n     *          the string to be substituted for each match\\n     *\\n     * @return  The resulting {@code String}\\n     *\\n     * @throws  PatternSyntaxException\\n     *          if the regular expression\\\u0027s syntax is invalid\\n     *\\n     * @see java.util.regex.Pattern\\n     *\\n     * @since 1.4\\n     * @spec JSR-51\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String replace(CharSequence target, CharSequence replacement)", "label": "public String replace(CharSequence target, CharSequence replacement)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Replaces each substring of this string that matches the literal target\\n     * sequence with the specified literal replacement sequence. The\\n     * replacement proceeds from the beginning of the string to the end, for\\n     * example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in\\n     * \"ba\" rather than \"ab\".\\n     *\\n     * @param  target The sequence of char values to be replaced\\n     * @param  replacement The replacement sequence of char values\\n     * @return  The resulting string\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String[] split(String regex, int limit)", "label": "public String[] split(String regex, int limit)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Splits this string around matches of the given\\n     * \u003ca href=\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\\n     *\\n     * \u003cp\u003e The array returned by this method contains each substring of this\\n     * string that is terminated by another substring that matches the given\\n     * expression or is terminated by the end of the string.  The substrings in\\n     * the array are in the order in which they occur in this string.  If the\\n     * expression does not match any part of the input then the resulting array\\n     * has just one element, namely this string.\\n     *\\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\\n     * string then an empty leading substring is included at the beginning\\n     * of the resulting array. A zero-width match at the beginning however\\n     * never produces such empty leading substring.\\n     *\\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\\n     * pattern is applied and therefore affects the length of the resulting\\n     * array.\\n     * \u003cul\u003e\\n     *    \u003cli\u003e\u003cp\u003e\\n     *    If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\\\u0027s length will be\\n     *    no greater than \u003ci\u003elimit\u003c/i\u003e, and the array\\\u0027s last entry will contain\\n     *    all input beyond the last matched delimiter.\u003c/p\u003e\u003c/li\u003e\\n     *\\n     *    \u003cli\u003e\u003cp\u003e\\n     *    If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\\n     *    many times as possible, the array can have any length, and trailing\\n     *    empty strings will be discarded.\u003c/p\u003e\u003c/li\u003e\\n     *\\n     *    \u003cli\u003e\u003cp\u003e\\n     *    If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\\n     *    as many times as possible and the array can have any length.\u003c/p\u003e\u003c/li\u003e\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the\\n     * following results with these parameters:\\n     *\\n     * \u003cblockquote\u003e\u003ctable class=\"plain\"\u003e\\n     * \u003ccaption style=\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\\n     * \u003cthead\u003e\\n     * \u003ctr\u003e\\n     *     \u003cth scope=\"col\"\u003eRegex\u003c/th\u003e\\n     *     \u003cth scope=\"col\"\u003eLimit\u003c/th\u003e\\n     *     \u003cth scope=\"col\"\u003eResult\u003c/th\u003e\\n     * \u003c/tr\u003e\\n     * \u003c/thead\u003e\\n     * \u003ctbody\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\" rowspan=\"3\" style=\"font-weight:normal\"\u003e:\u003c/th\u003e\\n     *     \u003cth scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"boo\", \"and:foo\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003c!-- : --\u003e\\n     *     \u003cth scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003c!-- : --\u003e\\n     *     \u003cth scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\" rowspan=\"3\" style=\"font-weight:normal\"\u003eo\u003c/th\u003e\\n     *     \u003cth scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003c!-- o --\u003e\\n     *     \u003cth scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003c!-- o --\u003e\\n     *     \u003cth scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003c/tbody\u003e\\n     * \u003c/table\u003e\u003c/blockquote\u003e\\n     *\\n     * \u003cp\u003e An invocation of this method of the form\\n     * \u003ci\u003estr.\u003c/i\u003e{@code split(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\\n     * yields the same result as the expression\\n     *\\n     * \u003cblockquote\u003e\\n     * \u003ccode\u003e\\n     * {@link java.util.regex.Pattern}.{@link\\n     * java.util.regex.Pattern#compile compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\\n     * java.util.regex.Pattern#split(java.lang.CharSequence,int) split}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\\n     * \u003c/code\u003e\\n     * \u003c/blockquote\u003e\\n     *\\n     *\\n     * @param  regex\\n     *         the delimiting regular expression\\n     *\\n     * @param  limit\\n     *         the result threshold, as described above\\n     *\\n     * @return  the array of strings computed by splitting this string\\n     *          around matches of the given regular expression\\n     *\\n     * @throws  PatternSyntaxException\\n     *          if the regular expression\\\u0027s syntax is invalid\\n     *\\n     * @see java.util.regex.Pattern\\n     *\\n     * @since 1.4\\n     * @spec JSR-51\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String[] split(String regex)", "label": "public String[] split(String regex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Splits this string around matches of the given \u003ca\\n     * href=\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\\n     *\\n     * \u003cp\u003e This method works as if by invoking the two-argument {@link\\n     * #split(String, int) split} method with the given expression and a limit\\n     * argument of zero.  Trailing empty strings are therefore not included in\\n     * the resulting array.\\n     *\\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the following\\n     * results with these expressions:\\n     *\\n     * \u003cblockquote\u003e\u003ctable class=\"plain\"\u003e\\n     * \u003ccaption style=\"display:none\"\u003eSplit examples showing regex and result\u003c/caption\u003e\\n     * \u003cthead\u003e\\n     * \u003ctr\u003e\\n     *  \u003cth scope=\"col\"\u003eRegex\u003c/th\u003e\\n     *  \u003cth scope=\"col\"\u003eResult\u003c/th\u003e\\n     * \u003c/tr\u003e\\n     * \u003c/thead\u003e\\n     * \u003ctbody\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\" style=\"text-weight:normal\"\u003e:\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\" style=\"text-weight:normal\"\u003eo\u003c/th\u003e\\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003c/tbody\u003e\\n     * \u003c/table\u003e\u003c/blockquote\u003e\\n     *\\n     *\\n     * @param  regex\\n     *         the delimiting regular expression\\n     *\\n     * @return  the array of strings computed by splitting this string\\n     *          around matches of the given regular expression\\n     *\\n     * @throws  PatternSyntaxException\\n     *          if the regular expression\\\u0027s syntax is invalid\\n     *\\n     * @see java.util.regex.Pattern\\n     *\\n     * @since 1.4\\n     * @spec JSR-51\\n     \u0027}"}, {"color": "#97c2fc", "id": "split(String", "label": "split(String", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static String join(CharSequence delimiter, CharSequence... elements)", "label": "public static String join(CharSequence delimiter, CharSequence... elements)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a new String composed of copies of the\\n     * {@code CharSequence elements} joined together with a copy of\\n     * the specified {@code delimiter}.\\n     *\\n     * \u003cblockquote\u003eFor example,\\n     * \u003cpre\u003e{@code\\n     *     String message = String.join(\"-\", \"Java\", \"is\", \"cool\");\\n     *     // message returned is: \"Java-is-cool\"\\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * Note that if an element is null, then {@code \"null\"} is added.\\n     *\\n     * @param  delimiter the delimiter that separates each element\\n     * @param  elements the elements to join together.\\n     *\\n     * @return a new {@code String} that is composed of the {@code elements}\\n     *         separated by the {@code delimiter}\\n     *\\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\\n     *         is {@code null}\\n     *\\n     * @see java.util.StringJoiner\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements)", "label": "public static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a new {@code String} composed of copies of the\\n     * {@code CharSequence elements} joined together with a copy of the\\n     * specified {@code delimiter}.\\n     *\\n     * \u003cblockquote\u003eFor example,\\n     * \u003cpre\u003e{@code\\n     *     List\u003cString\u003e strings = List.of(\"Java\", \"is\", \"cool\");\\n     *     String message = String.join(\" \", strings);\\n     *     //message returned is: \"Java is cool\"\\n     *\\n     *     Set\u003cString\u003e strings =\\n     *         new LinkedHashSet\u003c\u003e(List.of(\"Java\", \"is\", \"very\", \"cool\"));\\n     *     String message = String.join(\"-\", strings);\\n     *     //message returned is: \"Java-is-very-cool\"\\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * Note that if an individual element is {@code null}, then {@code \"null\"} is added.\\n     *\\n     * @param  delimiter a sequence of characters that is used to separate each\\n     *         of the {@code elements} in the resulting {@code String}\\n     * @param  elements an {@code Iterable} that will have its {@code elements}\\n     *         joined together.\\n     *\\n     * @return a new {@code String} that is composed from the {@code elements}\\n     *         argument\\n     *\\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\\n     *         is {@code null}\\n     *\\n     * @see    #join(CharSequence,CharSequence...)\\n     * @see    java.util.StringJoiner\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String toLowerCase(Locale locale)", "label": "public String toLowerCase(Locale locale)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Converts all of the characters in this {@code String} to lower\\n     * case using the rules of the given {@code Locale}.  Case mapping is based\\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\\n     * class. Since case mappings are not always 1:1 char mappings, the resulting\\n     * {@code String} may be a different length than the original {@code String}.\\n     * \u003cp\u003e\\n     * Examples of lowercase  mappings are in the following table:\\n     * \u003ctable class=\"plain\"\u003e\\n     * \u003ccaption style=\"display:none\"\u003eLowercase mapping examples showing language code of locale, upper case, lower case, and description\u003c/caption\u003e\\n     * \u003cthead\u003e\\n     * \u003ctr\u003e\\n     *   \u003cth scope=\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\\n     *   \u003cth scope=\"col\"\u003eUpper Case\u003c/th\u003e\\n     *   \u003cth scope=\"col\"\u003eLower Case\u003c/th\u003e\\n     *   \u003cth scope=\"col\"\u003eDescription\u003c/th\u003e\\n     * \u003c/tr\u003e\\n     * \u003c/thead\u003e\\n     * \u003ctbody\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\\n     *   \u003cth scope=\"row\" style=\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0130\u003c/th\u003e\\n     *   \u003ctd\u003e\u0026#92;u0069\u003c/td\u003e\\n     *   \u003ctd\u003ecapital letter I with dot above -\u0026gt; small letter i\u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\\n     *   \u003cth scope=\"row\" style=\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0049\u003c/th\u003e\\n     *   \u003ctd\u003e\u0026#92;u0131\u003c/td\u003e\\n     *   \u003ctd\u003ecapital letter I -\u0026gt; small letter dotless i \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e(all)\u003c/td\u003e\\n     *   \u003cth scope=\"row\" style=\"font-weight:normal; text-align:left\"\u003eFrench Fries\u003c/th\u003e\\n     *   \u003ctd\u003efrench fries\u003c/td\u003e\\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e(all)\u003c/td\u003e\\n     *   \u003cth scope=\"row\" style=\"font-weight:normal; text-align:left\"\u003e\\n     *       \u0026Iota;\u0026Chi;\u0026Theta;\u0026Upsilon;\u0026Sigma;\u003c/th\u003e\\n     *   \u003ctd\u003e\u0026iota;\u0026chi;\u0026theta;\u0026upsilon;\u0026sigma;\u003c/td\u003e\\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003c/tbody\u003e\\n     * \u003c/table\u003e\\n     *\\n     * @param locale use the case transformation rules for this locale\\n     * @return the {@code String}, converted to lowercase.\\n     * @see     java.lang.String#toLowerCase()\\n     * @see     java.lang.String#toUpperCase()\\n     * @see     java.lang.String#toUpperCase(Locale)\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.lang.Character", "label": "java.lang.Character", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * The {@code Character} class wraps a value of the primitive\\n * type {@code char} in an object. An object of class\\n * {@code Character} contains a single field whose type is\\n * {@code char}.\\n * \u003cp\u003e\\n * In addition, this class provides several methods for determining\\n * a character\\\u0027s category (lowercase letter, digit, etc.) and for converting\\n * characters from uppercase to lowercase and vice versa.\\n * \u003cp\u003e\\n * Character information is based on the Unicode Standard\\n * \u003cp\u003e\\n * The methods and data of class {@code Character} are defined by\\n * the information in the \u003ci\u003eUnicodeData\u003c/i\u003e file that is part of the\\n * Unicode Character Database maintained by the Unicode\\n * Consortium. This file specifies various properties including name\\n * and general category for every defined Unicode code point or\\n * character range.\\n * \u003cp\u003e\\n * The file and its description are available from the Unicode Consortium at:\\n * \u003cul\u003e\\n * \u003cli\u003e\u003ca href=\"http://www.unicode.org\"\u003ehttp://www.unicode.org\u003c/a\u003e\\n * \u003c/ul\u003e\\n *\\n * \u003ch2\u003e\u003ca id=\"conformance\"\u003eUnicode Conformance\u003c/a\u003e\u003c/h2\u003e\\n * \u003cp\u003e\\n * The fields and methods of class {@code Character} are defined in terms\\n * of character information from the Unicode Standard, specifically the\\n * \u003ci\u003eUnicodeData\u003c/i\u003e file that is part of the Unicode Character Database.\\n * This file specifies properties including name and category for every\\n * assigned Unicode code point or character range. The file is available\\n * from the Unicode Consortium at\\n * \u003ca href=\"http://www.unicode.org\"\u003ehttp://www.unicode.org\u003c/a\u003e.\\n * \u003cp\u003e\\n * Character information is based on the Unicode Standard, version 13.0.\\n * \u003cp\u003e\\n * The Java platform has supported different versions of the Unicode\\n * Standard over time. Upgrades to newer versions of the Unicode Standard\\n * occurred in the following Java releases, each indicating the new version:\\n * \u003ctable class=\"striped\"\u003e\\n * \u003ccaption style=\"display:none\"\u003eShows Java releases and supported Unicode versions\u003c/caption\u003e\\n * \u003cthead\u003e\\n * \u003ctr\u003e\u003cth scope=\"col\"\u003eJava release\u003c/th\u003e\\n *     \u003cth scope=\"col\"\u003eUnicode version\u003c/th\u003e\u003c/tr\u003e\\n * \u003c/thead\u003e\\n * \u003ctbody\u003e\\n * \u003ctr\u003e\u003ctd\u003eJava SE 15\u003c/td\u003e\\n *     \u003ctd\u003eUnicode 13.0\u003c/td\u003e\u003c/tr\u003e\\n * \u003ctr\u003e\u003ctd\u003eJava SE 13\u003c/td\u003e\\n *     \u003ctd\u003eUnicode 12.1\u003c/td\u003e\u003c/tr\u003e\\n * \u003ctr\u003e\u003ctd\u003eJava SE 12\u003c/td\u003e\\n *     \u003ctd\u003eUnicode 11.0\u003c/td\u003e\u003c/tr\u003e\\n * \u003ctr\u003e\u003ctd\u003eJava SE 11\u003c/td\u003e\\n *     \u003ctd\u003eUnicode 10.0\u003c/td\u003e\u003c/tr\u003e\\n * \u003ctr\u003e\u003ctd\u003eJava SE 9\u003c/td\u003e\\n *     \u003ctd\u003eUnicode 8.0\u003c/td\u003e\u003c/tr\u003e\\n * \u003ctr\u003e\u003ctd\u003eJava SE 8\u003c/td\u003e\\n *     \u003ctd\u003eUnicode 6.2\u003c/td\u003e\u003c/tr\u003e\\n * \u003ctr\u003e\u003ctd\u003eJava SE 7\u003c/td\u003e\\n *     \u003ctd\u003eUnicode 6.0\u003c/td\u003e\u003c/tr\u003e\\n * \u003ctr\u003e\u003ctd\u003eJava SE 5.0\u003c/td\u003e\\n *     \u003ctd\u003eUnicode 4.0\u003c/td\u003e\u003c/tr\u003e\\n * \u003ctr\u003e\u003ctd\u003eJava SE 1.4\u003c/td\u003e\\n *     \u003ctd\u003eUnicode 3.0\u003c/td\u003e\u003c/tr\u003e\\n * \u003ctr\u003e\u003ctd\u003eJDK 1.1\u003c/td\u003e\\n *     \u003ctd\u003eUnicode 2.0\u003c/td\u003e\u003c/tr\u003e\\n * \u003ctr\u003e\u003ctd\u003eJDK 1.0.2\u003c/td\u003e\\n *     \u003ctd\u003eUnicode 1.1.5\u003c/td\u003e\u003c/tr\u003e\\n * \u003c/tbody\u003e\\n * \u003c/table\u003e\\n * Variations from these base Unicode versions, such as recognized appendixes,\\n * are documented elsewhere.\\n * \u003ch2\u003e\u003ca id=\"unicode\"\u003eUnicode Character Representations\u003c/a\u003e\u003c/h2\u003e\\n *\\n * \u003cp\u003eThe {@code char} data type (and therefore the value that a\\n * {@code Character} object encapsulates) are based on the\\n * original Unicode specification, which defined characters as\\n * fixed-width 16-bit entities. The Unicode Standard has since been\\n * changed to allow for characters whose representation requires more\\n * than 16 bits.  The range of legal \u003cem\u003ecode point\u003c/em\u003es is now\\n * U+0000 to U+10FFFF, known as \u003cem\u003eUnicode scalar value\u003c/em\u003e.\\n * (Refer to the \u003ca\\n * href=\"http://www.unicode.org/reports/tr27/#notation\"\u003e\u003ci\u003e\\n * definition\u003c/i\u003e\u003c/a\u003e of the U+\u003ci\u003en\u003c/i\u003e notation in the Unicode\\n * Standard.)\\n *\\n * \u003cp\u003e\u003ca id=\"BMP\"\u003eThe set of characters from U+0000 to U+FFFF\u003c/a\u003e is\\n * sometimes referred to as the \u003cem\u003eBasic Multilingual Plane (BMP)\u003c/em\u003e.\\n * \u003ca id=\"supplementary\"\u003eCharacters\u003c/a\u003e whose code points are greater\\n * than U+FFFF are called \u003cem\u003esupplementary character\u003c/em\u003es.  The Java\\n * platform uses the UTF-16 representation in {@code char} arrays and\\n * in the {@code String} and {@code StringBuffer} classes. In\\n * this representation, supplementary characters are represented as a pair\\n * of {@code char} values, the first from the \u003cem\u003ehigh-surrogates\u003c/em\u003e\\n * range, (\u0026#92;uD800-\u0026#92;uDBFF), the second from the\\n * \u003cem\u003elow-surrogates\u003c/em\u003e range (\u0026#92;uDC00-\u0026#92;uDFFF).\\n *\\n * \u003cp\u003eA {@code char} value, therefore, represents Basic\\n * Multilingual Plane (BMP) code points, including the surrogate\\n * code points, or code units of the UTF-16 encoding. An\\n * {@code int} value represents all Unicode code points,\\n * including supplementary code points. The lower (least significant)\\n * 21 bits of {@code int} are used to represent Unicode code\\n * points and the upper (most significant) 11 bits must be zero.\\n * Unless otherwise specified, the behavior with respect to\\n * supplementary characters and surrogate {@code char} values is\\n * as follows:\\n *\\n * \u003cul\u003e\\n * \u003cli\u003eThe methods that only accept a {@code char} value cannot support\\n * supplementary characters. They treat {@code char} values from the\\n * surrogate ranges as undefined characters. For example,\\n * {@code Character.isLetter(\\\u0027\\\\u005CuD840\\\u0027)} returns {@code false}, even though\\n * this specific value if followed by any low-surrogate value in a string\\n * would represent a letter.\\n *\\n * \u003cli\u003eThe methods that accept an {@code int} value support all\\n * Unicode characters, including supplementary characters. For\\n * example, {@code Character.isLetter(0x2F81A)} returns\\n * {@code true} because the code point value represents a letter\\n * (a CJK ideograph).\\n * \u003c/ul\u003e\\n *\\n * \u003cp\u003eIn the Java SE API documentation, \u003cem\u003eUnicode code point\u003c/em\u003e is\\n * used for character values in the range between U+0000 and U+10FFFF,\\n * and \u003cem\u003eUnicode code unit\u003c/em\u003e is used for 16-bit\\n * {@code char} values that are code units of the \u003cem\u003eUTF-16\u003c/em\u003e\\n * encoding. For more information on Unicode terminology, refer to the\\n * \u003ca href=\"http://www.unicode.org/glossary/\"\u003eUnicode Glossary\u003c/a\u003e.\\n *\\n * \u003c!-- Android-removed: paragraph on ValueBased\\n * \u003cp\u003eThis is a \u003ca href=\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\\n * class; programmers should treat instances that are\\n * {@linkplain #equals(Object) equal} as interchangeable and should not\\n * use instances for synchronization, or unpredictable behavior may\\n * occur. For example, in a future release, synchronization may fail.\\n * --\u003e\\n *\\n * @author  Lee Boynton\\n * @author  Guy Steele\\n * @author  Akira Tanaka\\n * @author  Martin Buchholz\\n * @author  Ulf Zibis\\n * @since   1.0\\n \u0027}"}, {"color": "#97c2fc", "id": "public static Character valueOf(char c)", "label": "public static Character valueOf(char c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a {@code Character} instance representing the specified\\n     * {@code char} value.\\n     * If a new {@code Character} instance is not required, this method\\n     * should generally be used in preference to the constructor\\n     * {@link #Character(char)}, as this method is likely to yield\\n     * significantly better space and time performance by caching\\n     * frequently requested values.\\n     *\\n     * This method will always cache values in the range {@code\\n     * \u0027\\\\u005Cu0000\u0027} to {@code \u0027\\\\u005Cu007F\u0027}, inclusive, and may\\n     * cache other values outside of this range.\\n     *\\n     * @param  c a char value.\\n     * @return a {@code Character} instance representing {@code c}.\\n     * @since  1.5\\n     \"}"}, {"color": "#97c2fc", "id": "Character(char)", "label": "Character(char)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public char charValue()", "label": "public char charValue()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value of this {@code Character} object.\\n     * @return  the primitive {@code char} value represented by\\n     *          this object.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int hashCode(char value)", "label": "public static int hashCode(char value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a hash code for a {@code char} value; compatible with\\n     * {@code Character.hashCode()}.\\n     *\\n     * @since 1.8\\n     *\\n     * @param value The {@code char} for which to return a hash code.\\n     * @return a hash code value for a {@code char} value.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean equals(Object obj)", "label": "public boolean equals(Object obj)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares this object against the specified object.  The result\\n     * is {@code true} if and only if the argument is not\\n     * {@code null} and is a {@code Double} object that\\n     * represents a {@code double} that has the same value as the\\n     * {@code double} represented by this object. For this\\n     * purpose, two {@code double} values are considered to be\\n     * the same if and only if the method {@link\\n     * #doubleToLongBits(double)} returns the identical\\n     * {@code long} value when applied to each.\\n     *\\n     * @apiNote\\n     * This method is defined in terms of {@link\\n     * #doubleToLongBits(double)} rather than the {@code ==} operator\\n     * on {@code double} values since the {@code ==} operator does\\n     * \u003cem\u003enot\u003c/em\u003e define an equivalence relation and to satisfy the\\n     * {@linkplain Object#equals equals contract} an equivalence\\n     * relation must be implemented; see \u003ca\\n     * href=\"#equivalenceRelation\"\u003ethis discussion\u003c/a\u003e for details of\\n     * floating-point equality and equivalence.\\n     *\\n     * @see java.lang.Double#doubleToLongBits(double)\\n     * @jls 15.21.1 Numerical Equality Operators == and !=\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String toString(char c)", "label": "public static String toString(char c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code String} object representing the\\n     * specified {@code char}.  The result is a string of length\\n     * 1 consisting solely of the specified {@code char}.\\n     *\\n     * @param c the {@code char} to be converted\\n     * @return the string representation of the specified {@code char}\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String toString(int codePoint)", "label": "public static String toString(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code String} object representing the\\n     * specified character (Unicode code point).  The result is a string of\\n     * length 1 or 2, consisting solely of the specified {@code codePoint}.\\n     *\\n     * @param codePoint the {@code codePoint} to be converted\\n     * @return the string representation of the specified {@code codePoint}\\n     * @throws IllegalArgumentException if the specified\\n     *      {@code codePoint} is not a {@linkplain #isValidCodePoint\\n     *      valid Unicode code point}.\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isValidCodePoint(int codePoint)", "label": "public static boolean isValidCodePoint(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines whether the specified code point is a valid\\n     * \u003ca href=\"http://www.unicode.org/glossary/#code_point\"\u003e\\n     * Unicode code point value\u003c/a\u003e.\\n     *\\n     * @param  codePoint the Unicode code point to be tested\\n     * @return {@code true} if the specified code point value is between\\n     *         {@link #MIN_CODE_POINT} and\\n     *         {@link #MAX_CODE_POINT} inclusive;\\n     *         {@code false} otherwise.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "MIN_CODE_POINT", "label": "MIN_CODE_POINT", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "MAX_CODE_POINT", "label": "MAX_CODE_POINT", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isBmpCodePoint(int codePoint)", "label": "public static boolean isBmpCodePoint(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines whether the specified character (Unicode code point)\\n     * is in the \u003ca href=\"#BMP\"\u003eBasic Multilingual Plane (BMP)\u003c/a\u003e.\\n     * Such code points can be represented using a single {@code char}.\\n     *\\n     * @param  codePoint the character (Unicode code point) to be to\\n     * @return {@code true} if the specified code point is between\\n     *         {@link #MIN_VALUE} and {@link #MAX_VALUE} inclusive;\\n     *         {@code false} otherwise.\\n     * @since  1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "MIN_VALUE", "label": "MIN_VALUE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isSupplementaryCodePoint(int codePoint)", "label": "public static boolean isSupplementaryCodePoint(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines whether the specified character (Unicode code point)\\n     * is in the \u003ca href=\"#supplementary\"\u003esupplementary character\u003c/a\u003e range.\\n     *\\n     * @param  codePoint the character (Unicode code point) to be tested\\n     * @return {@code true} if the specified code point is between\\n     *         {@link #MIN_SUPPLEMENTARY_CODE_POINT} and\\n     *         {@link #MAX_CODE_POINT} inclusive;\\n     *         {@code false} otherwise.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "MIN_SUPPLEMENTARY_CODE_POINT", "label": "MIN_SUPPLEMENTARY_CODE_POINT", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isHighSurrogate(char ch)", "label": "public static boolean isHighSurrogate(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the given {@code char} value is a\\n     * \u003ca href=\"http://www.unicode.org/glossary/#high_surrogate_code_unit\"\u003e\\n     * Unicode high-surrogate code unit\u003c/a\u003e\\n     * (also known as \u003ci\u003eleading-surrogate code unit\u003c/i\u003e).\\n     *\\n     * \u003cp\u003eSuch values do not represent characters by themselves,\\n     * but are used in the representation of\\n     * \u003ca href=\"#supplementary\"\u003esupplementary characters\u003c/a\u003e\\n     * in the UTF-16 encoding.\\n     *\\n     * @param  ch the {@code char} value to be tested.\\n     * @return {@code true} if the {@code char} value is between\\n     *         {@link #MIN_HIGH_SURROGATE} and\\n     *         {@link #MAX_HIGH_SURROGATE} inclusive;\\n     *         {@code false} otherwise.\\n     * @see    Character#isLowSurrogate(char)\\n     * @see    Character.UnicodeBlock#of(int)\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "MIN_HIGH_SURROGATE", "label": "MIN_HIGH_SURROGATE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "MAX_HIGH_SURROGATE", "label": "MAX_HIGH_SURROGATE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isLowSurrogate(char ch)", "label": "public static boolean isLowSurrogate(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the given {@code char} value is a\\n     * \u003ca href=\"http://www.unicode.org/glossary/#low_surrogate_code_unit\"\u003e\\n     * Unicode low-surrogate code unit\u003c/a\u003e\\n     * (also known as \u003ci\u003etrailing-surrogate code unit\u003c/i\u003e).\\n     *\\n     * \u003cp\u003eSuch values do not represent characters by themselves,\\n     * but are used in the representation of\\n     * \u003ca href=\"#supplementary\"\u003esupplementary characters\u003c/a\u003e\\n     * in the UTF-16 encoding.\\n     *\\n     * @param  ch the {@code char} value to be tested.\\n     * @return {@code true} if the {@code char} value is between\\n     *         {@link #MIN_LOW_SURROGATE} and\\n     *         {@link #MAX_LOW_SURROGATE} inclusive;\\n     *         {@code false} otherwise.\\n     * @see    Character#isHighSurrogate(char)\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "MAX_LOW_SURROGATE", "label": "MAX_LOW_SURROGATE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "MIN_LOW_SURROGATE", "label": "MIN_LOW_SURROGATE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isSurrogate(char ch)", "label": "public static boolean isSurrogate(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the given {@code char} value is a Unicode\\n     * \u003ci\u003esurrogate code unit\u003c/i\u003e.\\n     *\\n     * \u003cp\u003eSuch values do not represent characters by themselves,\\n     * but are used in the representation of\\n     * \u003ca href=\"#supplementary\"\u003esupplementary characters\u003c/a\u003e\\n     * in the UTF-16 encoding.\\n     *\\n     * \u003cp\u003eA char value is a surrogate code unit if and only if it is either\\n     * a {@linkplain #isLowSurrogate(char) low-surrogate code unit} or\\n     * a {@linkplain #isHighSurrogate(char) high-surrogate code unit}.\\n     *\\n     * @param  ch the {@code char} value to be tested.\\n     * @return {@code true} if the {@code char} value is between\\n     *         {@link #MIN_SURROGATE} and\\n     *         {@link #MAX_SURROGATE} inclusive;\\n     *         {@code false} otherwise.\\n     * @since  1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "MIN_SURROGATE", "label": "MIN_SURROGATE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "MAX_SURROGATE", "label": "MAX_SURROGATE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isSurrogatePair(char high, char low)", "label": "public static boolean isSurrogatePair(char high, char low)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines whether the specified pair of {@code char}\\n     * values is a valid\\n     * \u003ca href=\"http://www.unicode.org/glossary/#surrogate_pair\"\u003e\\n     * Unicode surrogate pair\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eThis method is equivalent to the expression:\\n     * \u003cblockquote\u003e\u003cpre\u003e{@code\\n     * isHighSurrogate(high) \u0026\u0026 isLowSurrogate(low)\\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @param  high the high-surrogate code value to be tested\\n     * @param  low the low-surrogate code value to be tested\\n     * @return {@code true} if the specified high and\\n     * low-surrogate code values represent a valid surrogate pair;\\n     * {@code false} otherwise.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int charCount(int codePoint)", "label": "public static int charCount(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Determines the number of {@code char} values needed to\\n     * represent the specified character (Unicode code point). If the\\n     * specified character is equal to or greater than 0x10000, then\\n     * the method returns 2. Otherwise, the method returns 1.\\n     *\\n     * \u003cp\u003eThis method doesn\u0027t validate the specified character to be a\\n     * valid Unicode code point. The caller must validate the\\n     * character value using {@link #isValidCodePoint(int) isValidCodePoint}\\n     * if necessary.\\n     *\\n     * @param   codePoint the character (Unicode code point) to be tested.\\n     * @return  2 if the character is a valid supplementary character; 1 otherwise.\\n     * @see     Character#isSupplementaryCodePoint(int)\\n     * @since   1.5\\n     \"}"}, {"color": "#97c2fc", "id": "isValidCodePoint(int)", "label": "isValidCodePoint(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int toCodePoint(char high, char low)", "label": "public static int toCodePoint(char high, char low)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Converts the specified surrogate pair to its supplementary code\\n     * point value. This method does not validate the specified\\n     * surrogate pair. The caller must validate it using {@link\\n     * #isSurrogatePair(char, char) isSurrogatePair} if necessary.\\n     *\\n     * @param  high the high-surrogate code unit\\n     * @param  low the low-surrogate code unit\\n     * @return the supplementary code point composed from the\\n     *         specified surrogate pair.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "isSurrogatePair(char", "label": "isSurrogatePair(char", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int codePointAt(CharSequence seq, int index)", "label": "public static int codePointAt(CharSequence seq, int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the code point at the given index of the\\n     * {@code CharSequence}. If the {@code char} value at\\n     * the given index in the {@code CharSequence} is in the\\n     * high-surrogate range, the following index is less than the\\n     * length of the {@code CharSequence}, and the\\n     * {@code char} value at the following index is in the\\n     * low-surrogate range, then the supplementary code point\\n     * corresponding to this surrogate pair is returned. Otherwise,\\n     * the {@code char} value at the given index is returned.\\n     *\\n     * @param seq a sequence of {@code char} values (Unicode code\\n     * units)\\n     * @param index the index to the {@code char} values (Unicode\\n     * code units) in {@code seq} to be converted\\n     * @return the Unicode code point at the given index\\n     * @throws NullPointerException if {@code seq} is null.\\n     * @throws IndexOutOfBoundsException if the value\\n     * {@code index} is negative or not less than\\n     * {@link CharSequence#length() seq.length()}.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int codePointAt(char[] a, int index)", "label": "public static int codePointAt(char[] a, int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the code point at the given index of the\\n     * {@code char} array. If the {@code char} value at\\n     * the given index in the {@code char} array is in the\\n     * high-surrogate range, the following index is less than the\\n     * length of the {@code char} array, and the\\n     * {@code char} value at the following index is in the\\n     * low-surrogate range, then the supplementary code point\\n     * corresponding to this surrogate pair is returned. Otherwise,\\n     * the {@code char} value at the given index is returned.\\n     *\\n     * @param a the {@code char} array\\n     * @param index the index to the {@code char} values (Unicode\\n     * code units) in the {@code char} array to be converted\\n     * @return the Unicode code point at the given index\\n     * @throws NullPointerException if {@code a} is null.\\n     * @throws IndexOutOfBoundsException if the value\\n     * {@code index} is negative or not less than\\n     * the length of the {@code char} array.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int codePointAt(char[] a, int index, int limit)", "label": "public static int codePointAt(char[] a, int index, int limit)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the code point at the given index of the\\n     * {@code char} array, where only array elements with\\n     * {@code index} less than {@code limit} can be used. If\\n     * the {@code char} value at the given index in the\\n     * {@code char} array is in the high-surrogate range, the\\n     * following index is less than the {@code limit}, and the\\n     * {@code char} value at the following index is in the\\n     * low-surrogate range, then the supplementary code point\\n     * corresponding to this surrogate pair is returned. Otherwise,\\n     * the {@code char} value at the given index is returned.\\n     *\\n     * @param a the {@code char} array\\n     * @param index the index to the {@code char} values (Unicode\\n     * code units) in the {@code char} array to be converted\\n     * @param limit the index after the last array element that\\n     * can be used in the {@code char} array\\n     * @return the Unicode code point at the given index\\n     * @throws NullPointerException if {@code a} is null.\\n     * @throws IndexOutOfBoundsException if the {@code index}\\n     * argument is negative or not less than the {@code limit}\\n     * argument, or if the {@code limit} argument is negative or\\n     * greater than the length of the {@code char} array.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": " static int codePointAtImpl(char[] a, int index, int limit)", "label": " static int codePointAtImpl(char[] a, int index, int limit)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 throws ArrayIndexOutOfBoundsException if index out of bounds\u0027}"}, {"color": "#97c2fc", "id": "public static int codePointBefore(CharSequence seq, int index)", "label": "public static int codePointBefore(CharSequence seq, int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the code point preceding the given index of the\\n     * {@code CharSequence}. If the {@code char} value at\\n     * {@code (index - 1)} in the {@code CharSequence} is in\\n     * the low-surrogate range, {@code (index - 2)} is not\\n     * negative, and the {@code char} value at {@code (index - 2)}\\n     * in the {@code CharSequence} is in the\\n     * high-surrogate range, then the supplementary code point\\n     * corresponding to this surrogate pair is returned. Otherwise,\\n     * the {@code char} value at {@code (index - 1)} is\\n     * returned.\\n     *\\n     * @param seq the {@code CharSequence} instance\\n     * @param index the index following the code point that should be returned\\n     * @return the Unicode code point value before the given index.\\n     * @throws NullPointerException if {@code seq} is null.\\n     * @throws IndexOutOfBoundsException if the {@code index}\\n     * argument is less than 1 or greater than {@link\\n     * CharSequence#length() seq.length()}.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int codePointBefore(char[] a, int index)", "label": "public static int codePointBefore(char[] a, int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the code point preceding the given index of the\\n     * {@code char} array. If the {@code char} value at\\n     * {@code (index - 1)} in the {@code char} array is in\\n     * the low-surrogate range, {@code (index - 2)} is not\\n     * negative, and the {@code char} value at {@code (index - 2)}\\n     * in the {@code char} array is in the\\n     * high-surrogate range, then the supplementary code point\\n     * corresponding to this surrogate pair is returned. Otherwise,\\n     * the {@code char} value at {@code (index - 1)} is\\n     * returned.\\n     *\\n     * @param a the {@code char} array\\n     * @param index the index following the code point that should be returned\\n     * @return the Unicode code point value before the given index.\\n     * @throws NullPointerException if {@code a} is null.\\n     * @throws IndexOutOfBoundsException if the {@code index}\\n     * argument is less than 1 or greater than the length of the\\n     * {@code char} array\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int codePointBefore(char[] a, int index, int start)", "label": "public static int codePointBefore(char[] a, int index, int start)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the code point preceding the given index of the\\n     * {@code char} array, where only array elements with\\n     * {@code index} greater than or equal to {@code start}\\n     * can be used. If the {@code char} value at {@code (index - 1)}\\n     * in the {@code char} array is in the\\n     * low-surrogate range, {@code (index - 2)} is not less than\\n     * {@code start}, and the {@code char} value at\\n     * {@code (index - 2)} in the {@code char} array is in\\n     * the high-surrogate range, then the supplementary code point\\n     * corresponding to this surrogate pair is returned. Otherwise,\\n     * the {@code char} value at {@code (index - 1)} is\\n     * returned.\\n     *\\n     * @param a the {@code char} array\\n     * @param index the index following the code point that should be returned\\n     * @param start the index of the first array element in the\\n     * {@code char} array\\n     * @return the Unicode code point value before the given index.\\n     * @throws NullPointerException if {@code a} is null.\\n     * @throws IndexOutOfBoundsException if the {@code index}\\n     * argument is not greater than the {@code start} argument or\\n     * is greater than the length of the {@code char} array, or\\n     * if the {@code start} argument is negative or not less than\\n     * the length of the {@code char} array.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": " static int codePointBeforeImpl(char[] a, int index, int start)", "label": " static int codePointBeforeImpl(char[] a, int index, int start)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 throws ArrayIndexOutOfBoundsException if index-1 out of bounds\u0027}"}, {"color": "#97c2fc", "id": "public static char highSurrogate(int codePoint)", "label": "public static char highSurrogate(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the leading surrogate (a\\n     * \u003ca href=\"http://www.unicode.org/glossary/#high_surrogate_code_unit\"\u003e\\n     * high surrogate code unit\u003c/a\u003e) of the\\n     * \u003ca href=\"http://www.unicode.org/glossary/#surrogate_pair\"\u003e\\n     * surrogate pair\u003c/a\u003e\\n     * representing the specified supplementary character (Unicode\\n     * code point) in the UTF-16 encoding.  If the specified character\\n     * is not a\\n     * \u003ca href=\"Character.html#supplementary\"\u003esupplementary character\u003c/a\u003e,\\n     * an unspecified {@code char} is returned.\\n     *\\n     * \u003cp\u003eIf\\n     * {@link #isSupplementaryCodePoint isSupplementaryCodePoint(x)}\\n     * is {@code true}, then\\n     * {@link #isHighSurrogate isHighSurrogate}{@code (highSurrogate(x))} and\\n     * {@link #toCodePoint toCodePoint}{@code (highSurrogate(x), }{@link #lowSurrogate lowSurrogate}{@code (x)) == x}\\n     * are also always {@code true}.\\n     *\\n     * @param   codePoint a supplementary character (Unicode code point)\\n     * @return  the leading surrogate code unit used to represent the\\n     *          character in the UTF-16 encoding\\n     * @since   1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "isSupplementaryCodePoint", "label": "isSupplementaryCodePoint", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "toCodePoint", "label": "toCodePoint", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "lowSurrogate", "label": "lowSurrogate", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "isHighSurrogate", "label": "isHighSurrogate", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static char lowSurrogate(int codePoint)", "label": "public static char lowSurrogate(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the trailing surrogate (a\\n     * \u003ca href=\"http://www.unicode.org/glossary/#low_surrogate_code_unit\"\u003e\\n     * low surrogate code unit\u003c/a\u003e) of the\\n     * \u003ca href=\"http://www.unicode.org/glossary/#surrogate_pair\"\u003e\\n     * surrogate pair\u003c/a\u003e\\n     * representing the specified supplementary character (Unicode\\n     * code point) in the UTF-16 encoding.  If the specified character\\n     * is not a\\n     * \u003ca href=\"Character.html#supplementary\"\u003esupplementary character\u003c/a\u003e,\\n     * an unspecified {@code char} is returned.\\n     *\\n     * \u003cp\u003eIf\\n     * {@link #isSupplementaryCodePoint isSupplementaryCodePoint(x)}\\n     * is {@code true}, then\\n     * {@link #isLowSurrogate isLowSurrogate}{@code (lowSurrogate(x))} and\\n     * {@link #toCodePoint toCodePoint}{@code (}{@link #highSurrogate highSurrogate}{@code (x), lowSurrogate(x)) == x}\\n     * are also always {@code true}.\\n     *\\n     * @param   codePoint a supplementary character (Unicode code point)\\n     * @return  the trailing surrogate code unit used to represent the\\n     *          character in the UTF-16 encoding\\n     * @since   1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "isLowSurrogate", "label": "isLowSurrogate", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "highSurrogate", "label": "highSurrogate", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int toChars(int codePoint, char[] dst, int dstIndex)", "label": "public static int toChars(int codePoint, char[] dst, int dstIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Converts the specified character (Unicode code point) to its\\n     * UTF-16 representation. If the specified code point is a BMP\\n     * (Basic Multilingual Plane or Plane 0) value, the same value is\\n     * stored in {@code dst[dstIndex]}, and 1 is returned. If the\\n     * specified code point is a supplementary character, its\\n     * surrogate values are stored in {@code dst[dstIndex]}\\n     * (high-surrogate) and {@code dst[dstIndex+1]}\\n     * (low-surrogate), and 2 is returned.\\n     *\\n     * @param  codePoint the character (Unicode code point) to be converted.\\n     * @param  dst an array of {@code char} in which the\\n     * {@code codePoint}\u0027s UTF-16 value is stored.\\n     * @param dstIndex the start index into the {@code dst}\\n     * array where the converted value is stored.\\n     * @return 1 if the code point is a BMP code point, 2 if the\\n     * code point is a supplementary code point.\\n     * @throws IllegalArgumentException if the specified\\n     * {@code codePoint} is not a valid Unicode code point.\\n     * @throws NullPointerException if the specified {@code dst} is null.\\n     * @throws IndexOutOfBoundsException if {@code dstIndex}\\n     * is negative or not less than {@code dst.length}, or if\\n     * {@code dst} at {@code dstIndex} doesn\u0027t have enough\\n     * array element(s) to store the resulting {@code char}\\n     * value(s). (If {@code dstIndex} is equal to\\n     * {@code dst.length-1} and the specified\\n     * {@code codePoint} is a supplementary character, the\\n     * high-surrogate value is not stored in\\n     * {@code dst[dstIndex]}.)\\n     * @since  1.5\\n     \"}"}, {"color": "#97c2fc", "id": "public static char[] toChars(int codePoint)", "label": "public static char[] toChars(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Converts the specified character (Unicode code point) to its\\n     * UTF-16 representation stored in a {@code char} array. If\\n     * the specified code point is a BMP (Basic Multilingual Plane or\\n     * Plane 0) value, the resulting {@code char} array has\\n     * the same value as {@code codePoint}. If the specified code\\n     * point is a supplementary code point, the resulting\\n     * {@code char} array has the corresponding surrogate pair.\\n     *\\n     * @param  codePoint a Unicode code point\\n     * @return a {@code char} array having\\n     *         {@code codePoint}\u0027s UTF-16 representation.\\n     * @throws IllegalArgumentException if the specified\\n     * {@code codePoint} is not a valid Unicode code point.\\n     * @since  1.5\\n     \"}"}, {"color": "#97c2fc", "id": "public static int codePointCount(CharSequence seq, int beginIndex, int endIndex)", "label": "public static int codePointCount(CharSequence seq, int beginIndex, int endIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the number of Unicode code points in the text range of\\n     * the specified char sequence. The text range begins at the\\n     * specified {@code beginIndex} and extends to the\\n     * {@code char} at index {@code endIndex - 1}. Thus the\\n     * length (in {@code char}s) of the text range is\\n     * {@code endIndex-beginIndex}. Unpaired surrogates within\\n     * the text range count as one code point each.\\n     *\\n     * @param seq the char sequence\\n     * @param beginIndex the index to the first {@code char} of\\n     * the text range.\\n     * @param endIndex the index after the last {@code char} of\\n     * the text range.\\n     * @return the number of Unicode code points in the specified text\\n     * range\\n     * @throws NullPointerException if {@code seq} is null.\\n     * @throws IndexOutOfBoundsException if the\\n     * {@code beginIndex} is negative, or {@code endIndex}\\n     * is larger than the length of the given sequence, or\\n     * {@code beginIndex} is larger than {@code endIndex}.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int codePointCount(char[] a, int offset, int count)", "label": "public static int codePointCount(char[] a, int offset, int count)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the number of Unicode code points in a subarray of the\\n     * {@code char} array argument. The {@code offset}\\n     * argument is the index of the first {@code char} of the\\n     * subarray and the {@code count} argument specifies the\\n     * length of the subarray in {@code char}s. Unpaired\\n     * surrogates within the subarray count as one code point each.\\n     *\\n     * @param a the {@code char} array\\n     * @param offset the index of the first {@code char} in the\\n     * given {@code char} array\\n     * @param count the length of the subarray in {@code char}s\\n     * @return the number of Unicode code points in the specified subarray\\n     * @throws NullPointerException if {@code a} is null.\\n     * @throws IndexOutOfBoundsException if {@code offset} or\\n     * {@code count} is negative, or if {@code offset +\\n     * count} is larger than the length of the given array.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int offsetByCodePoints(CharSequence seq, int index, int codePointOffset)", "label": "public static int offsetByCodePoints(CharSequence seq, int index, int codePointOffset)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index within the given char sequence that is offset\\n     * from the given {@code index} by {@code codePointOffset}\\n     * code points. Unpaired surrogates within the text range given by\\n     * {@code index} and {@code codePointOffset} count as\\n     * one code point each.\\n     *\\n     * @param seq the char sequence\\n     * @param index the index to be offset\\n     * @param codePointOffset the offset in code points\\n     * @return the index within the char sequence\\n     * @throws NullPointerException if {@code seq} is null.\\n     * @throws IndexOutOfBoundsException if {@code index}\\n     *   is negative or larger then the length of the char sequence,\\n     *   or if {@code codePointOffset} is positive and the\\n     *   subsequence starting with {@code index} has fewer than\\n     *   {@code codePointOffset} code points, or if\\n     *   {@code codePointOffset} is negative and the subsequence\\n     *   before {@code index} has fewer than the absolute value\\n     *   of {@code codePointOffset} code points.\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int offsetByCodePoints(char[] a, int start, int count, int index, int codePointOffset)", "label": "public static int offsetByCodePoints(char[] a, int start, int count, int index, int codePointOffset)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the index within the given {@code char} subarray\\n     * that is offset from the given {@code index} by\\n     * {@code codePointOffset} code points. The\\n     * {@code start} and {@code count} arguments specify a\\n     * subarray of the {@code char} array. Unpaired surrogates\\n     * within the text range given by {@code index} and\\n     * {@code codePointOffset} count as one code point each.\\n     *\\n     * @param a the {@code char} array\\n     * @param start the index of the first {@code char} of the\\n     * subarray\\n     * @param count the length of the subarray in {@code char}s\\n     * @param index the index to be offset\\n     * @param codePointOffset the offset in code points\\n     * @return the index within the subarray\\n     * @throws NullPointerException if {@code a} is null.\\n     * @throws IndexOutOfBoundsException\\n     *   if {@code start} or {@code count} is negative,\\n     *   or if {@code start + count} is larger than the length of\\n     *   the given array,\\n     *   or if {@code index} is less than {@code start} or\\n     *   larger then {@code start + count},\\n     *   or if {@code codePointOffset} is positive and the text range\\n     *   starting with {@code index} and ending with {@code start + count - 1}\\n     *   has fewer than {@code codePointOffset} code\\n     *   points,\\n     *   or if {@code codePointOffset} is negative and the text range\\n     *   starting with {@code start} and ending with {@code index - 1}\\n     *   has fewer than the absolute value of\\n     *   {@code codePointOffset} code points.\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isLowerCase(char ch)", "label": "public static boolean isLowerCase(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character is a lowercase character.\\n     * \u003cp\u003e\\n     * A character is lowercase if its general category type, provided\\n     * by {@code Character.getType(ch)}, is\\n     * {@code LOWERCASE_LETTER}, or it has contributory property\\n     * Other_Lowercase as defined by the Unicode Standard.\\n     * \u003cp\u003e\\n     * The following are examples of lowercase characters:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * a b c d e f g h i j k l m n o p q r s t u v w x y z\\n     * \\\u0027\u0026#92;u00DF\\\u0027 \\\u0027\u0026#92;u00E0\\\u0027 \\\u0027\u0026#92;u00E1\\\u0027 \\\u0027\u0026#92;u00E2\\\u0027 \\\u0027\u0026#92;u00E3\\\u0027 \\\u0027\u0026#92;u00E4\\\u0027 \\\u0027\u0026#92;u00E5\\\u0027 \\\u0027\u0026#92;u00E6\\\u0027\\n     * \\\u0027\u0026#92;u00E7\\\u0027 \\\u0027\u0026#92;u00E8\\\u0027 \\\u0027\u0026#92;u00E9\\\u0027 \\\u0027\u0026#92;u00EA\\\u0027 \\\u0027\u0026#92;u00EB\\\u0027 \\\u0027\u0026#92;u00EC\\\u0027 \\\u0027\u0026#92;u00ED\\\u0027 \\\u0027\u0026#92;u00EE\\\u0027\\n     * \\\u0027\u0026#92;u00EF\\\u0027 \\\u0027\u0026#92;u00F0\\\u0027 \\\u0027\u0026#92;u00F1\\\u0027 \\\u0027\u0026#92;u00F2\\\u0027 \\\u0027\u0026#92;u00F3\\\u0027 \\\u0027\u0026#92;u00F4\\\u0027 \\\u0027\u0026#92;u00F5\\\u0027 \\\u0027\u0026#92;u00F6\\\u0027\\n     * \\\u0027\u0026#92;u00F8\\\u0027 \\\u0027\u0026#92;u00F9\\\u0027 \\\u0027\u0026#92;u00FA\\\u0027 \\\u0027\u0026#92;u00FB\\\u0027 \\\u0027\u0026#92;u00FC\\\u0027 \\\u0027\u0026#92;u00FD\\\u0027 \\\u0027\u0026#92;u00FE\\\u0027 \\\u0027\u0026#92;u00FF\\\u0027\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * \u003cp\u003e Many other Unicode characters are lowercase too.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isLowerCase(int)} method.\\n     *\\n     * @param   ch   the character to be tested.\\n     * @return  {@code true} if the character is lowercase;\\n     *          {@code false} otherwise.\\n     * @see     Character#isLowerCase(char)\\n     * @see     Character#isTitleCase(char)\\n     * @see     Character#toLowerCase(char)\\n     * @see     Character#getType(char)\\n     \u0027}"}, {"color": "#97c2fc", "id": "isLowerCase(int)", "label": "isLowerCase(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isLowerCase(int codePoint)", "label": "public static boolean isLowerCase(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isLowerCase(int codePoint) {\\n        return CharacterData.of(codePoint).isLowerCase(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isUpperCase(char ch)", "label": "public static boolean isUpperCase(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character is an uppercase character.\\n     * \u003cp\u003e\\n     * A character is uppercase if its general category type, provided by\\n     * {@code Character.getType(ch)}, is {@code UPPERCASE_LETTER}.\\n     * or it has contributory property Other_Uppercase as defined by the Unicode Standard.\\n     * \u003cp\u003e\\n     * The following are examples of uppercase characters:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\\n     * \\\u0027\u0026#92;u00C0\\\u0027 \\\u0027\u0026#92;u00C1\\\u0027 \\\u0027\u0026#92;u00C2\\\u0027 \\\u0027\u0026#92;u00C3\\\u0027 \\\u0027\u0026#92;u00C4\\\u0027 \\\u0027\u0026#92;u00C5\\\u0027 \\\u0027\u0026#92;u00C6\\\u0027 \\\u0027\u0026#92;u00C7\\\u0027\\n     * \\\u0027\u0026#92;u00C8\\\u0027 \\\u0027\u0026#92;u00C9\\\u0027 \\\u0027\u0026#92;u00CA\\\u0027 \\\u0027\u0026#92;u00CB\\\u0027 \\\u0027\u0026#92;u00CC\\\u0027 \\\u0027\u0026#92;u00CD\\\u0027 \\\u0027\u0026#92;u00CE\\\u0027 \\\u0027\u0026#92;u00CF\\\u0027\\n     * \\\u0027\u0026#92;u00D0\\\u0027 \\\u0027\u0026#92;u00D1\\\u0027 \\\u0027\u0026#92;u00D2\\\u0027 \\\u0027\u0026#92;u00D3\\\u0027 \\\u0027\u0026#92;u00D4\\\u0027 \\\u0027\u0026#92;u00D5\\\u0027 \\\u0027\u0026#92;u00D6\\\u0027 \\\u0027\u0026#92;u00D8\\\u0027\\n     * \\\u0027\u0026#92;u00D9\\\u0027 \\\u0027\u0026#92;u00DA\\\u0027 \\\u0027\u0026#92;u00DB\\\u0027 \\\u0027\u0026#92;u00DC\\\u0027 \\\u0027\u0026#92;u00DD\\\u0027 \\\u0027\u0026#92;u00DE\\\u0027\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * \u003cp\u003e Many other Unicode characters are uppercase too.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isUpperCase(int)} method.\\n     *\\n     * @param   ch   the character to be tested.\\n     * @return  {@code true} if the character is uppercase;\\n     *          {@code false} otherwise.\\n     * @see     Character#isLowerCase(char)\\n     * @see     Character#isTitleCase(char)\\n     * @see     Character#toUpperCase(char)\\n     * @see     Character#getType(char)\\n     * @since   1.0\\n     \u0027}"}, {"color": "#97c2fc", "id": "isUpperCase(int)", "label": "isUpperCase(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isUpperCase(int codePoint)", "label": "public static boolean isUpperCase(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isUpperCase(int codePoint) {\\n        return CharacterData.of(codePoint).isUpperCase(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isTitleCase(char ch)", "label": "public static boolean isTitleCase(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character is a titlecase character.\\n     * \u003cp\u003e\\n     * A character is a titlecase character if its general\\n     * category type, provided by {@code Character.getType(ch)},\\n     * is {@code TITLECASE_LETTER}.\\n     * \u003cp\u003e\\n     * Some characters look like pairs of Latin letters. For example, there\\n     * is an uppercase letter that looks like \"LJ\" and has a corresponding\\n     * lowercase letter that looks like \"lj\". A third form, which looks like \"Lj\",\\n     * is the appropriate form to use when rendering a word in lowercase\\n     * with initial capitals, as for a book title.\\n     * \u003cp\u003e\\n     * These are some of the Unicode characters for which this method returns\\n     * {@code true}:\\n     * \u003cul\u003e\\n     * \u003cli\u003e{@code LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON}\\n     * \u003cli\u003e{@code LATIN CAPITAL LETTER L WITH SMALL LETTER J}\\n     * \u003cli\u003e{@code LATIN CAPITAL LETTER N WITH SMALL LETTER J}\\n     * \u003cli\u003e{@code LATIN CAPITAL LETTER D WITH SMALL LETTER Z}\\n     * \u003c/ul\u003e\\n     * \u003cp\u003e Many other Unicode characters are titlecase too.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isTitleCase(int)} method.\\n     *\\n     * @param   ch   the character to be tested.\\n     * @return  {@code true} if the character is titlecase;\\n     *          {@code false} otherwise.\\n     * @see     Character#isLowerCase(char)\\n     * @see     Character#isUpperCase(char)\\n     * @see     Character#toTitleCase(char)\\n     * @see     Character#getType(char)\\n     * @since   1.0.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "isTitleCase(int)", "label": "isTitleCase(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isTitleCase(int codePoint)", "label": "public static boolean isTitleCase(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isTitleCase(int codePoint) {\\n        return getType(codePoint) == Character.TITLECASE_LETTER;\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isDigit(char ch)", "label": "public static boolean isDigit(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character is a digit.\\n     * \u003cp\u003e\\n     * A character is a digit if its general category type, provided\\n     * by {@code Character.getType(ch)}, is\\n     * {@code DECIMAL_DIGIT_NUMBER}.\\n     * \u003cp\u003e\\n     * Some Unicode character ranges that contain digits:\\n     * \u003cul\u003e\\n     * \u003cli\u003e{@code \\\u0027\\\\u005Cu0030\\\u0027} through {@code \\\u0027\\\\u005Cu0039\\\u0027},\\n     *     ISO-LATIN-1 digits ({@code \\\u00270\\\u0027} through {@code \\\u00279\\\u0027})\\n     * \u003cli\u003e{@code \\\u0027\\\\u005Cu0660\\\u0027} through {@code \\\u0027\\\\u005Cu0669\\\u0027},\\n     *     Arabic-Indic digits\\n     * \u003cli\u003e{@code \\\u0027\\\\u005Cu06F0\\\u0027} through {@code \\\u0027\\\\u005Cu06F9\\\u0027},\\n     *     Extended Arabic-Indic digits\\n     * \u003cli\u003e{@code \\\u0027\\\\u005Cu0966\\\u0027} through {@code \\\u0027\\\\u005Cu096F\\\u0027},\\n     *     Devanagari digits\\n     * \u003cli\u003e{@code \\\u0027\\\\u005CuFF10\\\u0027} through {@code \\\u0027\\\\u005CuFF19\\\u0027},\\n     *     Fullwidth digits\\n     * \u003c/ul\u003e\\n     *\\n     * Many other character ranges contain digits as well.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isDigit(int)} method.\\n     *\\n     * @param   ch   the character to be tested.\\n     * @return  {@code true} if the character is a digit;\\n     *          {@code false} otherwise.\\n     * @see     Character#digit(char, int)\\n     * @see     Character#forDigit(int, int)\\n     * @see     Character#getType(char)\\n     \u0027}"}, {"color": "#97c2fc", "id": "isDigit(int)", "label": "isDigit(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isDigit(int codePoint)", "label": "public static boolean isDigit(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isDigit(int codePoint) {\\n        return CharacterData.of(codePoint).isDigit(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isDefined(char ch)", "label": "public static boolean isDefined(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if a character is defined in Unicode.\\n     * \u003cp\u003e\\n     * A character is defined if at least one of the following is true:\\n     * \u003cul\u003e\\n     * \u003cli\u003eIt has an entry in the UnicodeData file.\\n     * \u003cli\u003eIt has a value in a range defined by the UnicodeData file.\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isDefined(int)} method.\\n     *\\n     * @param   ch   the character to be tested\\n     * @return  {@code true} if the character has a defined meaning\\n     *          in Unicode; {@code false} otherwise.\\n     * @see     Character#isDigit(char)\\n     * @see     Character#isLetter(char)\\n     * @see     Character#isLetterOrDigit(char)\\n     * @see     Character#isLowerCase(char)\\n     * @see     Character#isTitleCase(char)\\n     * @see     Character#isUpperCase(char)\\n     * @since   1.0.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "isDefined(int)", "label": "isDefined(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isDefined(int codePoint)", "label": "public static boolean isDefined(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isDefined(int codePoint) {\\n        return getType(codePoint) != Character.UNASSIGNED;\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isLetter(char ch)", "label": "public static boolean isLetter(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character is a letter.\\n     * \u003cp\u003e\\n     * A character is considered to be a letter if its general\\n     * category type, provided by {@code Character.getType(ch)},\\n     * is any of the following:\\n     * \u003cul\u003e\\n     * \u003cli\u003e {@code UPPERCASE_LETTER}\\n     * \u003cli\u003e {@code LOWERCASE_LETTER}\\n     * \u003cli\u003e {@code TITLECASE_LETTER}\\n     * \u003cli\u003e {@code MODIFIER_LETTER}\\n     * \u003cli\u003e {@code OTHER_LETTER}\\n     * \u003c/ul\u003e\\n     *\\n     * Not all letters have case. Many characters are\\n     * letters but are neither uppercase nor lowercase nor titlecase.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isLetter(int)} method.\\n     *\\n     * @param   ch   the character to be tested.\\n     * @return  {@code true} if the character is a letter;\\n     *          {@code false} otherwise.\\n     * @see     Character#isDigit(char)\\n     * @see     Character#isJavaIdentifierStart(char)\\n     * @see     Character#isJavaLetter(char)\\n     * @see     Character#isJavaLetterOrDigit(char)\\n     * @see     Character#isLetterOrDigit(char)\\n     * @see     Character#isLowerCase(char)\\n     * @see     Character#isTitleCase(char)\\n     * @see     Character#isUnicodeIdentifierStart(char)\\n     * @see     Character#isUpperCase(char)\\n     \u0027}"}, {"color": "#97c2fc", "id": "isLetter(int)", "label": "isLetter(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isLetter(int codePoint)", "label": "public static boolean isLetter(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isLetter(int codePoint) {\\n        return ((((1 \u003c\u003c Character.UPPERCASE_LETTER) |\\n            (1 \u003c\u003c Character.LOWERCASE_LETTER) |\\n            (1 \u003c\u003c Character.TITLECASE_LETTER) |\\n            (1 \u003c\u003c Character.MODIFIER_LETTER) |\\n            (1 \u003c\u003c Character.OTHER_LETTER)) \u003e\u003e getType(codePoint)) \u0026 1)\\n            != 0;\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isLetterOrDigit(char ch)", "label": "public static boolean isLetterOrDigit(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character is a letter or digit.\\n     * \u003cp\u003e\\n     * A character is considered to be a letter or digit if either\\n     * {@code Character.isLetter(char ch)} or\\n     * {@code Character.isDigit(char ch)} returns\\n     * {@code true} for the character.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isLetterOrDigit(int)} method.\\n     *\\n     * @param   ch   the character to be tested.\\n     * @return  {@code true} if the character is a letter or digit;\\n     *          {@code false} otherwise.\\n     * @see     Character#isDigit(char)\\n     * @see     Character#isJavaIdentifierPart(char)\\n     * @see     Character#isJavaLetter(char)\\n     * @see     Character#isJavaLetterOrDigit(char)\\n     * @see     Character#isLetter(char)\\n     * @see     Character#isUnicodeIdentifierPart(char)\\n     * @since   1.0.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "isLetterOrDigit(int)", "label": "isLetterOrDigit(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isLetterOrDigit(int codePoint)", "label": "public static boolean isLetterOrDigit(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isLetterOrDigit(int codePoint) {\\n        return ((((1 \u003c\u003c Character.UPPERCASE_LETTER) |\\n            (1 \u003c\u003c Character.LOWERCASE_LETTER) |\\n            (1 \u003c\u003c Character.TITLECASE_LETTER) |\\n            (1 \u003c\u003c Character.MODIFIER_LETTER) |\\n            (1 \u003c\u003c Character.OTHER_LETTER) |\\n            (1 \u003c\u003c Character.DECIMAL_DIGIT_NUMBER)) \u003e\u003e getType(codePoint)) \u0026 1)\\n            != 0;\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isAlphabetic(int codePoint)", "label": "public static boolean isAlphabetic(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isAlphabetic(int codePoint) {\\n        return (((((1 \u003c\u003c Character.UPPERCASE_LETTER) |\\n            (1 \u003c\u003c Character.LOWERCASE_LETTER) |\\n            (1 \u003c\u003c Character.TITLECASE_LETTER) |\\n            (1 \u003c\u003c Character.MODIFIER_LETTER) |\\n            (1 \u003c\u003c Character.OTHER_LETTER) |\\n            (1 \u003c\u003c Character.LETTER_NUMBER)) \u003e\u003e getType(codePoint)) \u0026 1) != 0) ||\\n            CharacterData.of(codePoint).isOtherAlphabetic(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isIdeographic(int codePoint)", "label": "public static boolean isIdeographic(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isIdeographic(int codePoint) {\\n        return CharacterData.of(codePoint).isIdeographic(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isJavaIdentifierStart(char ch)", "label": "public static boolean isJavaIdentifierStart(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character is\\n     * permissible as the first character in a Java identifier.\\n     * \u003cp\u003e\\n     * A character may start a Java identifier if and only if\\n     * one of the following conditions is true:\\n     * \u003cul\u003e\\n     * \u003cli\u003e {@link #isLetter(char) isLetter(ch)} returns {@code true}\\n     * \u003cli\u003e {@link #getType(char) getType(ch)} returns {@code LETTER_NUMBER}\\n     * \u003cli\u003e {@code ch} is a currency symbol (such as {@code \\\u0027$\\\u0027})\\n     * \u003cli\u003e {@code ch} is a connecting punctuation character (such as {@code \\\u0027_\\\u0027}).\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isJavaIdentifierStart(int)} method.\\n     *\\n     * @param   ch the character to be tested.\\n     * @return  {@code true} if the character may start a Java identifier;\\n     *          {@code false} otherwise.\\n     * @see     Character#isJavaIdentifierPart(char)\\n     * @see     Character#isLetter(char)\\n     * @see     Character#isUnicodeIdentifierStart(char)\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "isLetter(char)", "label": "isLetter(char)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "getType(char)", "label": "getType(char)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "isJavaIdentifierStart(int)", "label": "isJavaIdentifierStart(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isJavaIdentifierStart(int codePoint)", "label": "public static boolean isJavaIdentifierStart(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isJavaIdentifierStart(int codePoint) {\\n        return CharacterData.of(codePoint).isJavaIdentifierStart(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isJavaIdentifierPart(char ch)", "label": "public static boolean isJavaIdentifierPart(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character may be part of a Java\\n     * identifier as other than the first character.\\n     * \u003cp\u003e\\n     * A character may be part of a Java identifier if any of the following\\n     * conditions are true:\\n     * \u003cul\u003e\\n     * \u003cli\u003e  it is a letter\\n     * \u003cli\u003e  it is a currency symbol (such as {@code \\\u0027$\\\u0027})\\n     * \u003cli\u003e  it is a connecting punctuation character (such as {@code \\\u0027_\\\u0027})\\n     * \u003cli\u003e  it is a digit\\n     * \u003cli\u003e  it is a numeric letter (such as a Roman numeral character)\\n     * \u003cli\u003e  it is a combining mark\\n     * \u003cli\u003e  it is a non-spacing mark\\n     * \u003cli\u003e {@code isIdentifierIgnorable} returns\\n     * {@code true} for the character\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isJavaIdentifierPart(int)} method.\\n     *\\n     * @param   ch      the character to be tested.\\n     * @return {@code true} if the character may be part of a\\n     *          Java identifier; {@code false} otherwise.\\n     * @see     Character#isIdentifierIgnorable(char)\\n     * @see     Character#isJavaIdentifierStart(char)\\n     * @see     Character#isLetterOrDigit(char)\\n     * @see     Character#isUnicodeIdentifierPart(char)\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "isJavaIdentifierPart(int)", "label": "isJavaIdentifierPart(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isJavaIdentifierPart(int codePoint)", "label": "public static boolean isJavaIdentifierPart(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isJavaIdentifierPart(int codePoint) {\\n        return CharacterData.of(codePoint).isJavaIdentifierPart(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isUnicodeIdentifierStart(char ch)", "label": "public static boolean isUnicodeIdentifierStart(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character is permissible as the\\n     * first character in a Unicode identifier.\\n     * \u003cp\u003e\\n     * A character may start a Unicode identifier if and only if\\n     * one of the following conditions is true:\\n     * \u003cul\u003e\\n     * \u003cli\u003e {@link #isLetter(char) isLetter(ch)} returns {@code true}\\n     * \u003cli\u003e {@link #getType(char) getType(ch)} returns\\n     *      {@code LETTER_NUMBER}.\\n     * \u003cli\u003e it is an \u003ca href=\"http://www.unicode.org/reports/tr44/#Other_ID_Start\"\u003e\\n     *      {@code Other_ID_Start}\u003c/a\u003e character.\\n     * \u003c/ul\u003e\\n     * \u003cp\u003e\\n     * This method conforms to \u003ca href=\"https://unicode.org/reports/tr31/#R1\"\u003e\\n     * UAX31-R1: Default Identifiers\u003c/a\u003e requirement of the Unicode Standard,\\n     * with the following profile of UAX31:\\n     * \u003cpre\u003e\\n     * Start := ID_Start + \\\u0027VERTICAL TILDE\\\u0027 (U+2E2F)\\n     * \u003c/pre\u003e\\n     * {@code \\\u0027VERTICAL TILDE\\\u0027} is added to {@code Start} for backward\\n     * compatibility.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isUnicodeIdentifierStart(int)} method.\\n     *\\n     * @param   ch      the character to be tested.\\n     * @return  {@code true} if the character may start a Unicode\\n     *          identifier; {@code false} otherwise.\\n     * @see     Character#isJavaIdentifierStart(char)\\n     * @see     Character#isLetter(char)\\n     * @see     Character#isUnicodeIdentifierPart(char)\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "isUnicodeIdentifierStart(int)", "label": "isUnicodeIdentifierStart(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isUnicodeIdentifierStart(int codePoint)", "label": "public static boolean isUnicodeIdentifierStart(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isUnicodeIdentifierStart(int codePoint) {\\n        return CharacterData.of(codePoint).isUnicodeIdentifierStart(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isUnicodeIdentifierPart(char ch)", "label": "public static boolean isUnicodeIdentifierPart(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character may be part of a Unicode\\n     * identifier as other than the first character.\\n     * \u003cp\u003e\\n     * A character may be part of a Unicode identifier if and only if\\n     * one of the following statements is true:\\n     * \u003cul\u003e\\n     * \u003cli\u003e  it is a letter\\n     * \u003cli\u003e  it is a connecting punctuation character (such as {@code \\\u0027_\\\u0027})\\n     * \u003cli\u003e  it is a digit\\n     * \u003cli\u003e  it is a numeric letter (such as a Roman numeral character)\\n     * \u003cli\u003e  it is a combining mark\\n     * \u003cli\u003e  it is a non-spacing mark\\n     * \u003cli\u003e {@code isIdentifierIgnorable} returns\\n     * {@code true} for this character.\\n     * \u003cli\u003e it is an \u003ca href=\"http://www.unicode.org/reports/tr44/#Other_ID_Start\"\u003e\\n     *      {@code Other_ID_Start}\u003c/a\u003e character.\\n     * \u003cli\u003e it is an \u003ca href=\"http://www.unicode.org/reports/tr44/#Other_ID_Continue\"\u003e\\n     *      {@code Other_ID_Continue}\u003c/a\u003e character.\\n     * \u003c/ul\u003e\\n     * \u003cp\u003e\\n     * This method conforms to \u003ca href=\"https://unicode.org/reports/tr31/#R1\"\u003e\\n     * UAX31-R1: Default Identifiers\u003c/a\u003e requirement of the Unicode Standard,\\n     * with the following profile of UAX31:\\n     * \u003cpre\u003e\\n     * Continue := Start + ID_Continue + ignorable\\n     * Medial := empty\\n     * ignorable := isIdentifierIgnorable(char) returns true for the character\\n     * \u003c/pre\u003e\\n     * {@code ignorable} is added to {@code Continue} for backward\\n     * compatibility.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isUnicodeIdentifierPart(int)} method.\\n     *\\n     * @param   ch      the character to be tested.\\n     * @return  {@code true} if the character may be part of a\\n     *          Unicode identifier; {@code false} otherwise.\\n     * @see     Character#isIdentifierIgnorable(char)\\n     * @see     Character#isJavaIdentifierPart(char)\\n     * @see     Character#isLetterOrDigit(char)\\n     * @see     Character#isUnicodeIdentifierStart(char)\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "isUnicodeIdentifierPart(int)", "label": "isUnicodeIdentifierPart(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isUnicodeIdentifierPart(int codePoint)", "label": "public static boolean isUnicodeIdentifierPart(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isUnicodeIdentifierPart(int codePoint) {\\n        return CharacterData.of(codePoint).isUnicodeIdentifierPart(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isIdentifierIgnorable(char ch)", "label": "public static boolean isIdentifierIgnorable(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character should be regarded as\\n     * an ignorable character in a Java identifier or a Unicode identifier.\\n     * \u003cp\u003e\\n     * The following Unicode characters are ignorable in a Java identifier\\n     * or a Unicode identifier:\\n     * \u003cul\u003e\\n     * \u003cli\u003eISO control characters that are not whitespace\\n     * \u003cul\u003e\\n     * \u003cli\u003e{@code \\\u0027\\\\u005Cu0000\\\u0027} through {@code \\\u0027\\\\u005Cu0008\\\u0027}\\n     * \u003cli\u003e{@code \\\u0027\\\\u005Cu000E\\\u0027} through {@code \\\u0027\\\\u005Cu001B\\\u0027}\\n     * \u003cli\u003e{@code \\\u0027\\\\u005Cu007F\\\u0027} through {@code \\\u0027\\\\u005Cu009F\\\u0027}\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cli\u003eall characters that have the {@code FORMAT} general\\n     * category value\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isIdentifierIgnorable(int)} method.\\n     *\\n     * @param   ch      the character to be tested.\\n     * @return  {@code true} if the character is an ignorable control\\n     *          character that may be part of a Java or Unicode identifier;\\n     *           {@code false} otherwise.\\n     * @see     Character#isJavaIdentifierPart(char)\\n     * @see     Character#isUnicodeIdentifierPart(char)\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "isIdentifierIgnorable(int)", "label": "isIdentifierIgnorable(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isIdentifierIgnorable(int codePoint)", "label": "public static boolean isIdentifierIgnorable(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isIdentifierIgnorable(int codePoint) {\\n        return CharacterData.of(codePoint).isIdentifierIgnorable(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static char toLowerCase(char ch)", "label": "public static char toLowerCase(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Converts the character argument to lowercase using case\\n     * mapping information from the UnicodeData file.\\n     * \u003cp\u003e\\n     * Note that\\n     * {@code Character.isLowerCase(Character.toLowerCase(ch))}\\n     * does not always return {@code true} for some ranges of\\n     * characters, particularly those that are symbols or ideographs.\\n     *\\n     * \u003cp\u003eIn general, {@link String#toLowerCase()} should be used to map\\n     * characters to lowercase. {@code String} case mapping methods\\n     * have several benefits over {@code Character} case mapping methods.\\n     * {@code String} case mapping methods can perform locale-sensitive\\n     * mappings, context-sensitive mappings, and 1:M character mappings, whereas\\n     * the {@code Character} case mapping methods cannot.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #toLowerCase(int)} method.\\n     *\\n     * @param   ch   the character to be converted.\\n     * @return  the lowercase equivalent of the character, if any;\\n     *          otherwise, the character itself.\\n     * @see     Character#isLowerCase(char)\\n     * @see     String#toLowerCase()\\n     \u0027}"}, {"color": "#97c2fc", "id": "toLowerCase(int)", "label": "toLowerCase(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int toLowerCase(int codePoint)", "label": "public static int toLowerCase(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static int toLowerCase(int codePoint) {\\n        return CharacterData.of(codePoint).toLowerCase(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static char toUpperCase(char ch)", "label": "public static char toUpperCase(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Converts the character argument to uppercase using case mapping\\n     * information from the UnicodeData file.\\n     * \u003cp\u003e\\n     * Note that\\n     * {@code Character.isUpperCase(Character.toUpperCase(ch))}\\n     * does not always return {@code true} for some ranges of\\n     * characters, particularly those that are symbols or ideographs.\\n     *\\n     * \u003cp\u003eIn general, {@link String#toUpperCase()} should be used to map\\n     * characters to uppercase. {@code String} case mapping methods\\n     * have several benefits over {@code Character} case mapping methods.\\n     * {@code String} case mapping methods can perform locale-sensitive\\n     * mappings, context-sensitive mappings, and 1:M character mappings, whereas\\n     * the {@code Character} case mapping methods cannot.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #toUpperCase(int)} method.\\n     *\\n     * @param   ch   the character to be converted.\\n     * @return  the uppercase equivalent of the character, if any;\\n     *          otherwise, the character itself.\\n     * @see     Character#isUpperCase(char)\\n     * @see     String#toUpperCase()\\n     \u0027}"}, {"color": "#97c2fc", "id": "toUpperCase(int)", "label": "toUpperCase(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int toUpperCase(int codePoint)", "label": "public static int toUpperCase(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static int toUpperCase(int codePoint) {\\n        return CharacterData.of(codePoint).toUpperCase(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static char toTitleCase(char ch)", "label": "public static char toTitleCase(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Converts the character argument to titlecase using case mapping\\n     * information from the UnicodeData file. If a character has no\\n     * explicit titlecase mapping and is not itself a titlecase char\\n     * according to UnicodeData, then the uppercase mapping is\\n     * returned as an equivalent titlecase mapping. If the\\n     * {@code char} argument is already a titlecase\\n     * {@code char}, the same {@code char} value will be\\n     * returned.\\n     * \u003cp\u003e\\n     * Note that\\n     * {@code Character.isTitleCase(Character.toTitleCase(ch))}\\n     * does not always return {@code true} for some ranges of\\n     * characters.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #toTitleCase(int)} method.\\n     *\\n     * @param   ch   the character to be converted.\\n     * @return  the titlecase equivalent of the character, if any;\\n     *          otherwise, the character itself.\\n     * @see     Character#isTitleCase(char)\\n     * @see     Character#toLowerCase(char)\\n     * @see     Character#toUpperCase(char)\\n     * @since   1.0.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "toTitleCase(int)", "label": "toTitleCase(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int toTitleCase(int codePoint)", "label": "public static int toTitleCase(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static int toTitleCase(int codePoint) {\\n        return CharacterData.of(codePoint).toTitleCase(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static int digit(char ch, int radix)", "label": "public static int digit(char ch, int radix)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the numeric value of the character {@code ch} in the\\n     * specified radix.\\n     * \u003cp\u003e\\n     * If the radix is not in the range {@code MIN_RADIX} \u0026le;\\n     * {@code radix} \u0026le; {@code MAX_RADIX} or if the\\n     * value of {@code ch} is not a valid digit in the specified\\n     * radix, {@code -1} is returned. A character is a valid digit\\n     * if at least one of the following is true:\\n     * \u003cul\u003e\\n     * \u003cli\u003eThe method {@code isDigit} is {@code true} of the character\\n     *     and the Unicode decimal digit value of the character (or its\\n     *     single-character decomposition) is less than the specified radix.\\n     *     In this case the decimal digit value is returned.\\n     * \u003cli\u003eThe character is one of the uppercase Latin letters\\n     *     {@code \\\u0027A\\\u0027} through {@code \\\u0027Z\\\u0027} and its code is less than\\n     *     {@code radix + \\\u0027A\\\u0027 - 10}.\\n     *     In this case, {@code ch - \\\u0027A\\\u0027 + 10}\\n     *     is returned.\\n     * \u003cli\u003eThe character is one of the lowercase Latin letters\\n     *     {@code \\\u0027a\\\u0027} through {@code \\\u0027z\\\u0027} and its code is less than\\n     *     {@code radix + \\\u0027a\\\u0027 - 10}.\\n     *     In this case, {@code ch - \\\u0027a\\\u0027 + 10}\\n     *     is returned.\\n     * \u003cli\u003eThe character is one of the fullwidth uppercase Latin letters A\\n     *     ({@code \\\u0027\\\\u005CuFF21\\\u0027}) through Z ({@code \\\u0027\\\\u005CuFF3A\\\u0027})\\n     *     and its code is less than\\n     *     {@code radix + \\\u0027\\\\u005CuFF21\\\u0027 - 10}.\\n     *     In this case, {@code ch - \\\u0027\\\\u005CuFF21\\\u0027 + 10}\\n     *     is returned.\\n     * \u003cli\u003eThe character is one of the fullwidth lowercase Latin letters a\\n     *     ({@code \\\u0027\\\\u005CuFF41\\\u0027}) through z ({@code \\\u0027\\\\u005CuFF5A\\\u0027})\\n     *     and its code is less than\\n     *     {@code radix + \\\u0027\\\\u005CuFF41\\\u0027 - 10}.\\n     *     In this case, {@code ch - \\\u0027\\\\u005CuFF41\\\u0027 + 10}\\n     *     is returned.\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #digit(int, int)} method.\\n     *\\n     * @param   ch      the character to be converted.\\n     * @param   radix   the radix.\\n     * @return  the numeric value represented by the character in the\\n     *          specified radix.\\n     * @see     Character#forDigit(int, int)\\n     * @see     Character#isDigit(char)\\n     \u0027}"}, {"color": "#97c2fc", "id": "digit(int", "label": "digit(int", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int digit(int codePoint, int radix)", "label": "public static int digit(int codePoint, int radix)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static int digit(int codePoint, int radix) {\\n        return CharacterData.of(codePoint).digit(codePoint, radix);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static int getNumericValue(char ch)", "label": "public static int getNumericValue(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the {@code int} value that the specified Unicode\\n     * character represents. For example, the character\\n     * {@code \\\u0027\\\\u005Cu216C\\\u0027} (the roman numeral fifty) will return\\n     * an int with a value of 50.\\n     * \u003cp\u003e\\n     * The letters A-Z in their uppercase ({@code \\\u0027\\\\u005Cu0041\\\u0027} through\\n     * {@code \\\u0027\\\\u005Cu005A\\\u0027}), lowercase\\n     * ({@code \\\u0027\\\\u005Cu0061\\\u0027} through {@code \\\u0027\\\\u005Cu007A\\\u0027}), and\\n     * full width variant ({@code \\\u0027\\\\u005CuFF21\\\u0027} through\\n     * {@code \\\u0027\\\\u005CuFF3A\\\u0027} and {@code \\\u0027\\\\u005CuFF41\\\u0027} through\\n     * {@code \\\u0027\\\\u005CuFF5A\\\u0027}) forms have numeric values from 10\\n     * through 35. This is independent of the Unicode specification,\\n     * which does not assign numeric values to these {@code char}\\n     * values.\\n     * \u003cp\u003e\\n     * If the character does not have a numeric value, then -1 is returned.\\n     * If the character has a numeric value that cannot be represented as a\\n     * nonnegative integer (for example, a fractional value), then -2\\n     * is returned.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #getNumericValue(int)} method.\\n     *\\n     * @param   ch      the character to be converted.\\n     * @return  the numeric value of the character, as a nonnegative {@code int}\\n     *          value; -2 if the character has a numeric value but the value\\n     *          can not be represented as a nonnegative {@code int} value;\\n     *          -1 if the character has no numeric value.\\n     * @see     Character#forDigit(int, int)\\n     * @see     Character#isDigit(char)\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "getNumericValue(int)", "label": "getNumericValue(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int getNumericValue(int codePoint)", "label": "public static int getNumericValue(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static int getNumericValue(int codePoint) {\\n        return CharacterData.of(codePoint).getNumericValue(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isSpaceChar(char ch)", "label": "public static boolean isSpaceChar(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character is a Unicode space character.\\n     * A character is considered to be a space character if and only if\\n     * it is specified to be a space character by the Unicode Standard. This\\n     * method returns true if the character\\\u0027s general category type is any of\\n     * the following:\\n     * \u003cul\u003e\\n     * \u003cli\u003e {@code SPACE_SEPARATOR}\\n     * \u003cli\u003e {@code LINE_SEPARATOR}\\n     * \u003cli\u003e {@code PARAGRAPH_SEPARATOR}\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isSpaceChar(int)} method.\\n     *\\n     * @param   ch      the character to be tested.\\n     * @return  {@code true} if the character is a space character;\\n     *          {@code false} otherwise.\\n     * @see     Character#isWhitespace(char)\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "isSpaceChar(int)", "label": "isSpaceChar(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isSpaceChar(int codePoint)", "label": "public static boolean isSpaceChar(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isSpaceChar(int codePoint) {\\n        return ((((1 \u003c\u003c Character.SPACE_SEPARATOR) |\\n                  (1 \u003c\u003c Character.LINE_SEPARATOR) |\\n                  (1 \u003c\u003c Character.PARAGRAPH_SEPARATOR)) \u003e\u003e getType(codePoint)) \u0026 1)\\n            != 0;\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isWhitespace(char ch)", "label": "public static boolean isWhitespace(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character is white space according to Java.\\n     * A character is a Java whitespace character if and only if it satisfies\\n     * one of the following criteria:\\n     * \u003cul\u003e\\n     * \u003cli\u003e It is a Unicode space character ({@code SPACE_SEPARATOR},\\n     *      {@code LINE_SEPARATOR}, or {@code PARAGRAPH_SEPARATOR})\\n     *      but is not also a non-breaking space ({@code \\\u0027\\\\u005Cu00A0\\\u0027},\\n     *      {@code \\\u0027\\\\u005Cu2007\\\u0027}, {@code \\\u0027\\\\u005Cu202F\\\u0027}).\\n     * \u003cli\u003e It is {@code \\\u0027\\\\u005Ct\\\u0027}, U+0009 HORIZONTAL TABULATION.\\n     * \u003cli\u003e It is {@code \\\u0027\\\\u005Cn\\\u0027}, U+000A LINE FEED.\\n     * \u003cli\u003e It is {@code \\\u0027\\\\u005Cu000B\\\u0027}, U+000B VERTICAL TABULATION.\\n     * \u003cli\u003e It is {@code \\\u0027\\\\u005Cf\\\u0027}, U+000C FORM FEED.\\n     * \u003cli\u003e It is {@code \\\u0027\\\\u005Cr\\\u0027}, U+000D CARRIAGE RETURN.\\n     * \u003cli\u003e It is {@code \\\u0027\\\\u005Cu001C\\\u0027}, U+001C FILE SEPARATOR.\\n     * \u003cli\u003e It is {@code \\\u0027\\\\u005Cu001D\\\u0027}, U+001D GROUP SEPARATOR.\\n     * \u003cli\u003e It is {@code \\\u0027\\\\u005Cu001E\\\u0027}, U+001E RECORD SEPARATOR.\\n     * \u003cli\u003e It is {@code \\\u0027\\\\u005Cu001F\\\u0027}, U+001F UNIT SEPARATOR.\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isWhitespace(int)} method.\\n     *\\n     * @param   ch the character to be tested.\\n     * @return  {@code true} if the character is a Java whitespace\\n     *          character; {@code false} otherwise.\\n     * @see     Character#isSpaceChar(char)\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "isWhitespace(int)", "label": "isWhitespace(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isWhitespace(int codePoint)", "label": "public static boolean isWhitespace(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isWhitespace(int codePoint) {\\n        return CharacterData.of(codePoint).isWhitespace(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isISOControl(char ch)", "label": "public static boolean isISOControl(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the specified character is an ISO control\\n     * character.  A character is considered to be an ISO control\\n     * character if its code is in the range {@code \\\u0027\\\\u005Cu0000\\\u0027}\\n     * through {@code \\\u0027\\\\u005Cu001F\\\u0027} or in the range\\n     * {@code \\\u0027\\\\u005Cu007F\\\u0027} through {@code \\\u0027\\\\u005Cu009F\\\u0027}.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isISOControl(int)} method.\\n     *\\n     * @param   ch      the character to be tested.\\n     * @return  {@code true} if the character is an ISO control character;\\n     *          {@code false} otherwise.\\n     *\\n     * @see     Character#isSpaceChar(char)\\n     * @see     Character#isWhitespace(char)\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "isISOControl(int)", "label": "isISOControl(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isISOControl(int codePoint)", "label": "public static boolean isISOControl(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Determines if the referenced character (Unicode code point) is an ISO control\\n     * character.  A character is considered to be an ISO control\\n     * character if its code is in the range {@code \u0027\\\\u005Cu0000\u0027}\\n     * through {@code \u0027\\\\u005Cu001F\u0027} or in the range\\n     * {@code \u0027\\\\u005Cu007F\u0027} through {@code \u0027\\\\u005Cu009F\u0027}.\\n     *\\n     * @param   codePoint the character (Unicode code point) to be tested.\\n     * @return  {@code true} if the character is an ISO control character;\\n     *          {@code false} otherwise.\\n     * @see     Character#isSpaceChar(int)\\n     * @see     Character#isWhitespace(int)\\n     * @since   1.5\\n     \"}"}, {"color": "#97c2fc", "id": "public static int getType(char ch)", "label": "public static int getType(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a value indicating a character\\\u0027s general category.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #getType(int)} method.\\n     *\\n     * @param   ch      the character to be tested.\\n     * @return  a value of type {@code int} representing the\\n     *          character\\\u0027s general category.\\n     * @see     Character#COMBINING_SPACING_MARK\\n     * @see     Character#CONNECTOR_PUNCTUATION\\n     * @see     Character#CONTROL\\n     * @see     Character#CURRENCY_SYMBOL\\n     * @see     Character#DASH_PUNCTUATION\\n     * @see     Character#DECIMAL_DIGIT_NUMBER\\n     * @see     Character#ENCLOSING_MARK\\n     * @see     Character#END_PUNCTUATION\\n     * @see     Character#FINAL_QUOTE_PUNCTUATION\\n     * @see     Character#FORMAT\\n     * @see     Character#INITIAL_QUOTE_PUNCTUATION\\n     * @see     Character#LETTER_NUMBER\\n     * @see     Character#LINE_SEPARATOR\\n     * @see     Character#LOWERCASE_LETTER\\n     * @see     Character#MATH_SYMBOL\\n     * @see     Character#MODIFIER_LETTER\\n     * @see     Character#MODIFIER_SYMBOL\\n     * @see     Character#NON_SPACING_MARK\\n     * @see     Character#OTHER_LETTER\\n     * @see     Character#OTHER_NUMBER\\n     * @see     Character#OTHER_PUNCTUATION\\n     * @see     Character#OTHER_SYMBOL\\n     * @see     Character#PARAGRAPH_SEPARATOR\\n     * @see     Character#PRIVATE_USE\\n     * @see     Character#SPACE_SEPARATOR\\n     * @see     Character#START_PUNCTUATION\\n     * @see     Character#SURROGATE\\n     * @see     Character#TITLECASE_LETTER\\n     * @see     Character#UNASSIGNED\\n     * @see     Character#UPPERCASE_LETTER\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "getType(int)", "label": "getType(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int getType(int codePoint)", "label": "public static int getType(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static int getType(int codePoint) {\\n        return CharacterData.of(codePoint).getType(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static char forDigit(int digit, int radix)", "label": "public static char forDigit(int digit, int radix)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Determines the character representation for a specific digit in\\n     * the specified radix. If the value of {@code radix} is not a\\n     * valid radix, or the value of {@code digit} is not a valid\\n     * digit in the specified radix, the null character\\n     * ({@code \u0027\\\\u005Cu0000\u0027}) is returned.\\n     * \u003cp\u003e\\n     * The {@code radix} argument is valid if it is greater than or\\n     * equal to {@code MIN_RADIX} and less than or equal to\\n     * {@code MAX_RADIX}. The {@code digit} argument is valid if\\n     * {@code 0 \u003c= digit \u003c radix}.\\n     * \u003cp\u003e\\n     * If the digit is less than 10, then\\n     * {@code \u00270\u0027 + digit} is returned. Otherwise, the value\\n     * {@code \u0027a\u0027 + digit - 10} is returned.\\n     *\\n     * @param   digit   the number to convert to a character.\\n     * @param   radix   the radix.\\n     * @return  the {@code char} representation of the specified digit\\n     *          in the specified radix.\\n     * @see     Character#MIN_RADIX\\n     * @see     Character#MAX_RADIX\\n     * @see     Character#digit(char, int)\\n     \"}"}, {"color": "#97c2fc", "id": "public static byte getDirectionality(char ch)", "label": "public static byte getDirectionality(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the Unicode directionality property for the given\\n     * character.  Character directionality is used to calculate the\\n     * visual ordering of text. The directionality value of undefined\\n     * {@code char} values is {@code DIRECTIONALITY_UNDEFINED}.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #getDirectionality(int)} method.\\n     *\\n     * @param  ch {@code char} for which the directionality property\\n     *            is requested.\\n     * @return the directionality property of the {@code char} value.\\n     *\\n     * @see Character#DIRECTIONALITY_UNDEFINED\\n     * @see Character#DIRECTIONALITY_LEFT_TO_RIGHT\\n     * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT\\n     * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC\\n     * @see Character#DIRECTIONALITY_EUROPEAN_NUMBER\\n     * @see Character#DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR\\n     * @see Character#DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR\\n     * @see Character#DIRECTIONALITY_ARABIC_NUMBER\\n     * @see Character#DIRECTIONALITY_COMMON_NUMBER_SEPARATOR\\n     * @see Character#DIRECTIONALITY_NONSPACING_MARK\\n     * @see Character#DIRECTIONALITY_BOUNDARY_NEUTRAL\\n     * @see Character#DIRECTIONALITY_PARAGRAPH_SEPARATOR\\n     * @see Character#DIRECTIONALITY_SEGMENT_SEPARATOR\\n     * @see Character#DIRECTIONALITY_WHITESPACE\\n     * @see Character#DIRECTIONALITY_OTHER_NEUTRALS\\n     * @see Character#DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING\\n     * @see Character#DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE\\n     * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING\\n     * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE\\n     * @see Character#DIRECTIONALITY_POP_DIRECTIONAL_FORMAT\\n     * @see Character#DIRECTIONALITY_LEFT_TO_RIGHT_ISOLATE\\n     * @see Character#DIRECTIONALITY_RIGHT_TO_LEFT_ISOLATE\\n     * @see Character#DIRECTIONALITY_FIRST_STRONG_ISOLATE\\n     * @see Character#DIRECTIONALITY_POP_DIRECTIONAL_ISOLATE\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "getDirectionality(int)", "label": "getDirectionality(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static byte getDirectionality(int codePoint)", "label": "public static byte getDirectionality(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static byte getDirectionality(int codePoint) {\\n        return CharacterData.of(codePoint).getDirectionality(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isMirrored(char ch)", "label": "public static boolean isMirrored(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines whether the character is mirrored according to the\\n     * Unicode specification.  Mirrored characters should have their\\n     * glyphs horizontally mirrored when displayed in text that is\\n     * right-to-left.  For example, {@code \\\u0027\\\\u005Cu0028\\\u0027} LEFT\\n     * PARENTHESIS is semantically defined to be an \u003ci\u003eopening\\n     * parenthesis\u003c/i\u003e.  This will appear as a \"(\" in text that is\\n     * left-to-right but as a \")\" in text that is right-to-left.\\n     *\\n     * \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e This method cannot handle \u003ca\\n     * href=\"#supplementary\"\u003e supplementary characters\u003c/a\u003e. To support\\n     * all Unicode characters, including supplementary characters, use\\n     * the {@link #isMirrored(int)} method.\\n     *\\n     * @param  ch {@code char} for which the mirrored property is requested\\n     * @return {@code true} if the char is mirrored, {@code false}\\n     *         if the {@code char} is not mirrored or is not defined.\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "isMirrored(int)", "label": "isMirrored(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isMirrored(int codePoint)", "label": "public static boolean isMirrored(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public static boolean isMirrored(int codePoint) {\\n        return CharacterData.of(codePoint).isMirrored(codePoint);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public int compareTo(Character anotherCharacter)", "label": "public int compareTo(Character anotherCharacter)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code Character} objects numerically.\\n     *\\n     * @param   anotherCharacter   the {@code Character} to be compared.\\n     * @return  the value {@code 0} if the argument {@code Character}\\n     *          is equal to this {@code Character}; a value less than\\n     *          {@code 0} if this {@code Character} is numerically less\\n     *          than the {@code Character} argument; and a value greater than\\n     *          {@code 0} if this {@code Character} is numerically greater\\n     *          than the {@code Character} argument (unsigned comparison).\\n     *          Note that this is strictly a numerical comparison; it is not\\n     *          locale-dependent.\\n     * @since   1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int compare(char x, char y)", "label": "public static int compare(char x, char y)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code char} values numerically.\\n     * The value returned is identical to what would be returned by:\\n     * \u003cpre\u003e\\n     *    Character.valueOf(x).compareTo(Character.valueOf(y))\\n     * \u003c/pre\u003e\\n     *\\n     * @param  x the first {@code char} to compare\\n     * @param  y the second {@code char} to compare\\n     * @return the value {@code 0} if {@code x == y};\\n     *         a value less than {@code 0} if {@code x \u003c y}; and\\n     *         a value greater than {@code 0} if {@code x \u003e y}\\n     * @since 1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static char reverseBytes(char ch)", "label": "public static char reverseBytes(char ch)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value obtained by reversing the order of the bytes in the\\n     * specified {@code char} value.\\n     *\\n     * @param ch The {@code char} of which to reverse the byte order.\\n     * @return the value obtained by reversing (or, equivalently, swapping)\\n     *     the bytes in the specified {@code char} value.\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String getName(int codePoint)", "label": "public static String getName(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the Unicode name of the specified character\\n     * {@code codePoint}, or null if the code point is\\n     * {@link #UNASSIGNED unassigned}.\\n     * \u003cp\u003e\\n     * Note: if the specified character is not assigned a name by\\n     * the \u003ci\u003eUnicodeData\u003c/i\u003e file (part of the Unicode Character\\n     * Database maintained by the Unicode Consortium), the returned\\n     * name is the same as the result of expression:\\n     *\\n     * \u003cblockquote\u003e{@code\\n     *     Character.UnicodeBlock.of(codePoint).toString().replace(\\\u0027_\\\u0027, \\\u0027 \\\u0027)\\n     *     + \" \"\\n     *     + Integer.toHexString(codePoint).toUpperCase(Locale.ROOT);\\n     *\\n     * }\u003c/blockquote\u003e\\n     *\\n     * @param  codePoint the character (Unicode code point)\\n     *\\n     * @return the Unicode name of the specified character, or null if\\n     *         the code point is unassigned.\\n     *\\n     * @throws IllegalArgumentException if the specified\\n     *            {@code codePoint} is not a valid Unicode\\n     *            code point.\\n     *\\n     * @since 1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "UNASSIGNED", "label": "UNASSIGNED", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int codePointOf(String name)", "label": "public static int codePointOf(String name)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the code point value of the Unicode character specified by\\n     * the given Unicode character name.\\n     * \u003cp\u003e\\n     * Note: if a character is not assigned a name by the \u003ci\u003eUnicodeData\u003c/i\u003e\\n     * file (part of the Unicode Character Database maintained by the Unicode\\n     * Consortium), its name is defined as the result of expression:\\n     *\\n     * \u003cblockquote\u003e{@code\\n     *     Character.UnicodeBlock.of(codePoint).toString().replace(\\\u0027_\\\u0027, \\\u0027 \\\u0027)\\n     *     + \" \"\\n     *     + Integer.toHexString(codePoint).toUpperCase(Locale.ROOT);\\n     *\\n     * }\u003c/blockquote\u003e\\n     * \u003cp\u003e\\n     * The {@code name} matching is case insensitive, with any leading and\\n     * trailing whitespace character removed.\\n     *\\n     * @param  name the Unicode character name\\n     *\\n     * @return the code point value of the character specified by its name.\\n     *\\n     * @throws IllegalArgumentException if the specified {@code name}\\n     *         is not a valid Unicode character name.\\n     * @throws NullPointerException if {@code name} is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static native String getNameImpl(int codePoint)", "label": "private static native String getNameImpl(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Implement getNameImpl() and codePointOfImpl() natively.\u0027}"}, {"color": "#97c2fc", "id": "public String toLowerCase()", "label": "public String toLowerCase()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Converts all of the characters in this {@code String} to lower\\n     * case using the rules of the default locale. This is equivalent to calling\\n     * {@code toLowerCase(Locale.getDefault())}.\\n     * \u003cp\u003e\\n     * \u003cb\u003eNote:\u003c/b\u003e This method is locale sensitive, and may produce unexpected\\n     * results if used for strings that are intended to be interpreted locale\\n     * independently.\\n     * Examples are programming language identifiers, protocol keys, and HTML\\n     * tags.\\n     * For instance, {@code \"TITLE\".toLowerCase()} in a Turkish locale\\n     * returns {@code \"t\\\\u005Cu0131tle\"}, where \\\u0027\\\\u005Cu0131\\\u0027 is the\\n     * LATIN SMALL LETTER DOTLESS I character.\\n     * To obtain correct results for locale insensitive strings, use\\n     * {@code toLowerCase(Locale.ROOT)}.\\n     *\\n     * @return  the {@code String}, converted to lowercase.\\n     * @see     java.lang.String#toLowerCase(Locale)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String toUpperCase(Locale locale)", "label": "public String toUpperCase(Locale locale)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Converts all of the characters in this {@code String} to upper\\n     * case using the rules of the given {@code Locale}. Case mapping is based\\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\\n     * class. Since case mappings are not always 1:1 char mappings, the resulting\\n     * {@code String} may be a different length than the original {@code String}.\\n     * \u003cp\u003e\\n     * Examples of locale-sensitive and 1:M case mappings are in the following table.\\n     *\\n     * \u003ctable class=\"plain\"\u003e\\n     * \u003ccaption style=\"display:none\"\u003eExamples of locale-sensitive and 1:M case mappings. Shows Language code of locale, lower case, upper case, and description.\u003c/caption\u003e\\n     * \u003cthead\u003e\\n     * \u003ctr\u003e\\n     *   \u003cth scope=\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\\n     *   \u003cth scope=\"col\"\u003eLower Case\u003c/th\u003e\\n     *   \u003cth scope=\"col\"\u003eUpper Case\u003c/th\u003e\\n     *   \u003cth scope=\"col\"\u003eDescription\u003c/th\u003e\\n     * \u003c/tr\u003e\\n     * \u003c/thead\u003e\\n     * \u003ctbody\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\\n     *   \u003cth scope=\"row\" style=\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0069\u003c/th\u003e\\n     *   \u003ctd\u003e\u0026#92;u0130\u003c/td\u003e\\n     *   \u003ctd\u003esmall letter i -\u0026gt; capital letter I with dot above\u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\\n     *   \u003cth scope=\"row\" style=\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0131\u003c/th\u003e\\n     *   \u003ctd\u003e\u0026#92;u0049\u003c/td\u003e\\n     *   \u003ctd\u003esmall letter dotless i -\u0026gt; capital letter I\u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e(all)\u003c/td\u003e\\n     *   \u003cth scope=\"row\" style=\"font-weight:normal; text-align:left\"\u003e\u0026#92;u00df\u003c/th\u003e\\n     *   \u003ctd\u003e\u0026#92;u0053 \u0026#92;u0053\u003c/td\u003e\\n     *   \u003ctd\u003esmall letter sharp s -\u0026gt; two letters: SS\u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e(all)\u003c/td\u003e\\n     *   \u003cth scope=\"row\" style=\"font-weight:normal; text-align:left\"\u003eFahrvergn\u0026uuml;gen\u003c/th\u003e\\n     *   \u003ctd\u003eFAHRVERGN\u0026Uuml;GEN\u003c/td\u003e\\n     *   \u003ctd\u003e\u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003c/tbody\u003e\\n     * \u003c/table\u003e\\n     * @param locale use the case transformation rules for this locale\\n     * @return the {@code String}, converted to uppercase.\\n     * @see     java.lang.String#toUpperCase()\\n     * @see     java.lang.String#toLowerCase()\\n     * @see     java.lang.String#toLowerCase(Locale)\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String toUpperCase()", "label": "public String toUpperCase()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Converts all of the characters in this {@code String} to upper\\n     * case using the rules of the default locale. This method is equivalent to\\n     * {@code toUpperCase(Locale.getDefault())}.\\n     * \u003cp\u003e\\n     * \u003cb\u003eNote:\u003c/b\u003e This method is locale sensitive, and may produce unexpected\\n     * results if used for strings that are intended to be interpreted locale\\n     * independently.\\n     * Examples are programming language identifiers, protocol keys, and HTML\\n     * tags.\\n     * For instance, {@code \"title\".toUpperCase()} in a Turkish locale\\n     * returns {@code \"T\\\\u005Cu0130TLE\"}, where \\\u0027\\\\u005Cu0130\\\u0027 is the\\n     * LATIN CAPITAL LETTER I WITH DOT ABOVE character.\\n     * To obtain correct results for locale insensitive strings, use\\n     * {@code toUpperCase(Locale.ROOT)}.\\n     *\\n     * @return  the {@code String}, converted to uppercase.\\n     * @see     java.lang.String#toUpperCase(Locale)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String trim()", "label": "public String trim()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a string whose value is this string, with all leading\\n     * and trailing space removed, where space is defined\\n     * as any character whose codepoint is less than or equal to\\n     * {@code \u0027U+0020\u0027} (the space character).\\n     * \u003cp\u003e\\n     * If this {@code String} object represents an empty character\\n     * sequence, or the first and last characters of character sequence\\n     * represented by this {@code String} object both have codes\\n     * that are not space (as defined above), then a\\n     * reference to this {@code String} object is returned.\\n     * \u003cp\u003e\\n     * Otherwise, if all characters in this string are space (as\\n     * defined above), then a  {@code String} object representing an\\n     * empty string is returned.\\n     * \u003cp\u003e\\n     * Otherwise, let \u003ci\u003ek\u003c/i\u003e be the index of the first character in the\\n     * string whose code is not a space (as defined above) and let\\n     * \u003ci\u003em\u003c/i\u003e be the index of the last character in the string whose code\\n     * is not a space (as defined above). A {@code String}\\n     * object is returned, representing the substring of this string that\\n     * begins with the character at index \u003ci\u003ek\u003c/i\u003e and ends with the\\n     * character at index \u003ci\u003em\u003c/i\u003e-that is, the result of\\n     * {@code this.substring(k, m + 1)}.\\n     * \u003cp\u003e\\n     * This method may be used to trim space (as defined above) from\\n     * the beginning and end of a string.\\n     *\\n     * @return  a string whose value is this string, with all leading\\n     *          and trailing space removed, or this string if it\\n     *          has no leading or trailing space.\\n     \"}"}, {"color": "#97c2fc", "id": "public String strip()", "label": "public String strip()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string whose value is this string, with all leading\\n     * and trailing {@link Character#isWhitespace(int) white space}\\n     * removed.\\n     * \u003cp\u003e\\n     * If this {@code String} object represents an empty string,\\n     * or if all code points in this string are\\n     * {@link Character#isWhitespace(int) white space}, then an empty string\\n     * is returned.\\n     * \u003cp\u003e\\n     * Otherwise, returns a substring of this string beginning with the first\\n     * code point that is not a {@link Character#isWhitespace(int) white space}\\n     * up to and including the last code point that is not a\\n     * {@link Character#isWhitespace(int) white space}.\\n     * \u003cp\u003e\\n     * This method may be used to strip\\n     * {@link Character#isWhitespace(int) white space} from\\n     * the beginning and end of a string.\\n     *\\n     * @return  a string whose value is this string, with all leading\\n     *          and trailing white space removed\\n     *\\n     * @see Character#isWhitespace(int)\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String stripLeading()", "label": "public String stripLeading()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string whose value is this string, with all leading\\n     * {@link Character#isWhitespace(int) white space} removed.\\n     * \u003cp\u003e\\n     * If this {@code String} object represents an empty string,\\n     * or if all code points in this string are\\n     * {@link Character#isWhitespace(int) white space}, then an empty string\\n     * is returned.\\n     * \u003cp\u003e\\n     * Otherwise, returns a substring of this string beginning with the first\\n     * code point that is not a {@link Character#isWhitespace(int) white space}\\n     * up to to and including the last code point of this string.\\n     * \u003cp\u003e\\n     * This method may be used to trim\\n     * {@link Character#isWhitespace(int) white space} from\\n     * the beginning of a string.\\n     *\\n     * @return  a string whose value is this string, with all leading white\\n     *          space removed\\n     *\\n     * @see Character#isWhitespace(int)\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String stripTrailing()", "label": "public String stripTrailing()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string whose value is this string, with all trailing\\n     * {@link Character#isWhitespace(int) white space} removed.\\n     * \u003cp\u003e\\n     * If this {@code String} object represents an empty string,\\n     * or if all characters in this string are\\n     * {@link Character#isWhitespace(int) white space}, then an empty string\\n     * is returned.\\n     * \u003cp\u003e\\n     * Otherwise, returns a substring of this string beginning with the first\\n     * code point of this string up to and including the last code point\\n     * that is not a {@link Character#isWhitespace(int) white space}.\\n     * \u003cp\u003e\\n     * This method may be used to trim\\n     * {@link Character#isWhitespace(int) white space} from\\n     * the end of a string.\\n     *\\n     * @return  a string whose value is this string, with all trailing white\\n     *          space removed\\n     *\\n     * @see Character#isWhitespace(int)\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isBlank()", "label": "public boolean isBlank()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if the string is empty or contains only\\n     * {@link Character#isWhitespace(int) white space} codepoints,\\n     * otherwise {@code false}.\\n     *\\n     * @return {@code true} if the string is empty or contains only\\n     *         {@link Character#isWhitespace(int) white space} codepoints,\\n     *         otherwise {@code false}\\n     *\\n     * @see Character#isWhitespace(int)\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Stream\u003cString\u003e lines()", "label": "public Stream\u003cString\u003e lines()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Stream}, the elements of which are lines read from\\n     * this {@code BufferedReader}.  The {@link Stream} is lazily populated,\\n     * i.e., read only occurs during the\\n     * \u003ca href=\"../util/stream/package-summary.html#StreamOps\"\u003eterminal\\n     * stream operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003e The reader must not be operated on during the execution of the\\n     * terminal stream operation. Otherwise, the result of the terminal stream\\n     * operation is undefined.\\n     *\\n     * \u003cp\u003e After execution of the terminal stream operation there are no\\n     * guarantees that the reader will be at a specific position from which to\\n     * read the next character or line.\\n     *\\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the underlying\\n     * {@code BufferedReader}, it is wrapped in an {@link\\n     * UncheckedIOException} which will be thrown from the {@code Stream}\\n     * method that caused the read to take place. This method will return a\\n     * Stream if invoked on a BufferedReader that is closed. Any operation on\\n     * that stream that requires reading from the BufferedReader after it is\\n     * closed, will cause an UncheckedIOException to be thrown.\\n     *\\n     * @return a {@code Stream\u003cString\u003e} providing the lines of text\\n     *         described by this {@code BufferedReader}\\n     *\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String indent(int n)", "label": "public String indent(int n)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Adjusts the indentation of each line of this string based on the value of\\n     * {@code n}, and normalizes line termination characters.\\n     * \u003cp\u003e\\n     * This string is conceptually separated into lines using\\n     * {@link String#lines()}. Each line is then adjusted as described below\\n     * and then suffixed with a line feed {@code \"\\\\n\"} (U+000A). The resulting\\n     * lines are then concatenated and returned.\\n     * \u003cp\u003e\\n     * If {@code n \u003e 0} then {@code n} spaces (U+0020) are inserted at the\\n     * beginning of each line.\\n     * \u003cp\u003e\\n     * If {@code n \u003c 0} then up to {@code n}\\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed\\n     * from the beginning of each line. If a given line does not contain\\n     * sufficient white space then all leading\\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed.\\n     * Each white space character is treated as a single character. In\\n     * particular, the tab character {@code \"\\\\t\"} (U+0009) is considered a\\n     * single character; it is not expanded.\\n     * \u003cp\u003e\\n     * If {@code n == 0} then the line remains unchanged. However, line\\n     * terminators are still normalized.\\n     *\\n     * @param n  number of leading\\n     *           {@linkplain Character#isWhitespace(int) white space characters}\\n     *           to add or remove\\n     *\\n     * @return string with indentation adjusted and line endings normalized\\n     *\\n     * @see String#lines()\\n     * @see String#isBlank()\\n     * @see Character#isWhitespace(int)\\n     *\\n     * @since 12\\n     \u0027}"}, {"color": "#97c2fc", "id": "lines()", "label": "lines()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public String stripIndent()", "label": "public String stripIndent()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string whose value is this string, with incidental\\n     * {@linkplain Character#isWhitespace(int) white space} removed from\\n     * the beginning and end of every line.\\n     * \u003cp\u003e\\n     * Incidental {@linkplain Character#isWhitespace(int) white space}\\n     * is often present in a text block to align the content with the opening\\n     * delimiter. For example, in the following code, dots represent incidental\\n     * {@linkplain Character#isWhitespace(int) white space}:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * String html = \"\"\"\\n     * ..............\u0026lt;html\u0026gt;\\n     * ..............    \u0026lt;body\u0026gt;\\n     * ..............        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\\n     * ..............    \u0026lt;/body\u0026gt;\\n     * ..............\u0026lt;/html\u0026gt;\\n     * ..............\"\"\";\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * This method treats the incidental\\n     * {@linkplain Character#isWhitespace(int) white space} as indentation to be\\n     * stripped, producing a string that preserves the relative indentation of\\n     * the content. Using | to visualize the start of each line of the string:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * |\u0026lt;html\u0026gt;\\n     * |    \u0026lt;body\u0026gt;\\n     * |        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\\n     * |    \u0026lt;/body\u0026gt;\\n     * |\u0026lt;/html\u0026gt;\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * First, the individual lines of this string are extracted. A \u003ci\u003eline\u003c/i\u003e\\n     * is a sequence of zero or more characters followed by either a line\\n     * terminator or the end of the string.\\n     * If the string has at least one line terminator, the last line consists\\n     * of the characters between the last terminator and the end of the string.\\n     * Otherwise, if the string has no terminators, the last line is the start\\n     * of the string to the end of the string, in other words, the entire\\n     * string.\\n     * A line does not include the line terminator.\\n     * \u003cp\u003e\\n     * Then, the \u003ci\u003eminimum indentation\u003c/i\u003e (min) is determined as follows:\\n     * \u003cul\u003e\\n     *   \u003cli\u003e\u003cp\u003eFor each non-blank line (as defined by {@link String#isBlank()}),\\n     *   the leading {@linkplain Character#isWhitespace(int) white space}\\n     *   characters are counted.\u003c/p\u003e\\n     *   \u003c/li\u003e\\n     *   \u003cli\u003e\u003cp\u003eThe leading {@linkplain Character#isWhitespace(int) white space}\\n     *   characters on the last line are also counted even if\\n     *   {@linkplain String#isBlank() blank}.\u003c/p\u003e\\n     *   \u003c/li\u003e\\n     * \u003c/ul\u003e\\n     * \u003cp\u003eThe \u003ci\u003emin\u003c/i\u003e value is the smallest of these counts.\\n     * \u003cp\u003e\\n     * For each {@linkplain String#isBlank() non-blank} line, \u003ci\u003emin\u003c/i\u003e leading\\n     * {@linkplain Character#isWhitespace(int) white space} characters are\\n     * removed, and any trailing {@linkplain Character#isWhitespace(int) white\\n     * space} characters are removed. {@linkplain String#isBlank() Blank} lines\\n     * are replaced with the empty string.\\n     *\\n     * \u003cp\u003e\\n     * Finally, the lines are joined into a new string, using the LF character\\n     * {@code \"\\\\n\"} (U+000A) to separate lines.\\n     *\\n     * @apiNote\\n     * This method\\\u0027s primary purpose is to shift a block of lines as far as\\n     * possible to the left, while preserving relative indentation. Lines\\n     * that were indented the least will thus have no leading\\n     * {@linkplain Character#isWhitespace(int) white space}.\\n     * The result will have the same number of line terminators as this string.\\n     * If this string ends with a line terminator then the result will end\\n     * with a line terminator.\\n     *\\n     * @implSpec\\n     * This method treats all {@linkplain Character#isWhitespace(int) white space}\\n     * characters as having equal width. As long as the indentation on every\\n     * line is consistently composed of the same character sequences, then the\\n     * result will be as described above.\\n     *\\n     * @return string with incidental indentation removed and line\\n     *         terminators normalized\\n     *\\n     * @see String#lines()\\n     * @see String#isBlank()\\n     * @see String#indent(int)\\n     * @see Character#isWhitespace(int)\\n     *\\n     * @since 15\\n     *\\n     \u0027}"}, {"color": "#97c2fc", "id": "isBlank()", "label": "isBlank()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public String translateEscapes()", "label": "public String translateEscapes()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string whose value is this string, with escape sequences\\n     * translated as if in a string literal.\\n     * \u003cp\u003e\\n     * Escape sequences are translated as follows;\\n     * \u003ctable class=\"striped\"\u003e\\n     *   \u003ccaption style=\"display:none\"\u003eTranslation\u003c/caption\u003e\\n     *   \u003cthead\u003e\\n     *   \u003ctr\u003e\\n     *     \u003cth scope=\"col\"\u003eEscape\u003c/th\u003e\\n     *     \u003cth scope=\"col\"\u003eName\u003c/th\u003e\\n     *     \u003cth scope=\"col\"\u003eTranslation\u003c/th\u003e\\n     *   \u003c/tr\u003e\\n     *   \u003c/thead\u003e\\n     *   \u003ctbody\u003e\\n     *   \u003ctr\u003e\\n     *     \u003cth scope=\"row\"\u003e{@code \\\\u005Cb}\u003c/th\u003e\\n     *     \u003ctd\u003ebackspace\u003c/td\u003e\\n     *     \u003ctd\u003e{@code U+0008}\u003c/td\u003e\\n     *   \u003c/tr\u003e\\n     *   \u003ctr\u003e\\n     *     \u003cth scope=\"row\"\u003e{@code \\\\u005Ct}\u003c/th\u003e\\n     *     \u003ctd\u003ehorizontal tab\u003c/td\u003e\\n     *     \u003ctd\u003e{@code U+0009}\u003c/td\u003e\\n     *   \u003c/tr\u003e\\n     *   \u003ctr\u003e\\n     *     \u003cth scope=\"row\"\u003e{@code \\\\u005Cn}\u003c/th\u003e\\n     *     \u003ctd\u003eline feed\u003c/td\u003e\\n     *     \u003ctd\u003e{@code U+000A}\u003c/td\u003e\\n     *   \u003c/tr\u003e\\n     *   \u003ctr\u003e\\n     *     \u003cth scope=\"row\"\u003e{@code \\\\u005Cf}\u003c/th\u003e\\n     *     \u003ctd\u003eform feed\u003c/td\u003e\\n     *     \u003ctd\u003e{@code U+000C}\u003c/td\u003e\\n     *   \u003c/tr\u003e\\n     *   \u003ctr\u003e\\n     *     \u003cth scope=\"row\"\u003e{@code \\\\u005Cr}\u003c/th\u003e\\n     *     \u003ctd\u003ecarriage return\u003c/td\u003e\\n     *     \u003ctd\u003e{@code U+000D}\u003c/td\u003e\\n     *   \u003c/tr\u003e\\n     *   \u003ctr\u003e\\n     *     \u003cth scope=\"row\"\u003e{@code \\\\u005Cs}\u003c/th\u003e\\n     *     \u003ctd\u003espace\u003c/td\u003e\\n     *     \u003ctd\u003e{@code U+0020}\u003c/td\u003e\\n     *   \u003c/tr\u003e\\n     *   \u003ctr\u003e\\n     *     \u003cth scope=\"row\"\u003e{@code \\\\u005C\"}\u003c/th\u003e\\n     *     \u003ctd\u003edouble quote\u003c/td\u003e\\n     *     \u003ctd\u003e{@code U+0022}\u003c/td\u003e\\n     *   \u003c/tr\u003e\\n     *   \u003ctr\u003e\\n     *     \u003cth scope=\"row\"\u003e{@code \\\\u005C\\\u0027}\u003c/th\u003e\\n     *     \u003ctd\u003esingle quote\u003c/td\u003e\\n     *     \u003ctd\u003e{@code U+0027}\u003c/td\u003e\\n     *   \u003c/tr\u003e\\n     *   \u003ctr\u003e\\n     *     \u003cth scope=\"row\"\u003e{@code \\\\u005C\\\\u005C}\u003c/th\u003e\\n     *     \u003ctd\u003ebackslash\u003c/td\u003e\\n     *     \u003ctd\u003e{@code U+005C}\u003c/td\u003e\\n     *   \u003c/tr\u003e\\n     *   \u003ctr\u003e\\n     *     \u003cth scope=\"row\"\u003e{@code \\\\u005C0 - \\\\u005C377}\u003c/th\u003e\\n     *     \u003ctd\u003eoctal escape\u003c/td\u003e\\n     *     \u003ctd\u003ecode point equivalents\u003c/td\u003e\\n     *   \u003c/tr\u003e\\n     *   \u003ctr\u003e\\n     *     \u003cth scope=\"row\"\u003e{@code \\\\u005C\u003cline-terminator\u003e}\u003c/th\u003e\\n     *     \u003ctd\u003econtinuation\u003c/td\u003e\\n     *     \u003ctd\u003ediscard\u003c/td\u003e\\n     *   \u003c/tr\u003e\\n     *   \u003c/tbody\u003e\\n     * \u003c/table\u003e\\n     *\\n     * @implNote\\n     * This method does \u003cem\u003enot\u003c/em\u003e translate Unicode escapes such as \"{@code \\\\u005cu2022}\".\\n     * Unicode escapes are translated by the Java compiler when reading input characters and\\n     * are not part of the string literal specification.\\n     *\\n     * @throws IllegalArgumentException when an escape sequence is malformed.\\n     *\\n     * @return String with escape sequences translated.\\n     *\\n     * @jls 3.10.7 Escape Sequences\\n     *\\n     * @since 15\\n     \u0027}"}, {"color": "#97c2fc", "id": "public R transform(Function\u003c? super String, ? extends R\u003e f)", "label": "public R transform(Function\u003c? super String, ? extends R\u003e f)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * This method allows the application of a function to {@code this}\\n     * string. The function should expect a single String argument\\n     * and produce an {@code R} result.\\n     * \u003cp\u003e\\n     * Any exception thrown by {@code f.apply()} will be propagated to the\\n     * caller.\\n     *\\n     * @param f    a function to apply\\n     *\\n     * @param \u003cR\u003e  the type of the result\\n     *\\n     * @return     the result of applying the function to this string\\n     *\\n     * @see java.util.function.Function\\n     *\\n     * @since 12\\n     \u0027}"}, {"color": "#97c2fc", "id": "public native char[] toCharArray()", "label": "public native char[] toCharArray()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public char[] toCharArray() {\\n        return isLatin1() ? StringLatin1.toChars(value)\\n                          : StringUTF16.toChars(value);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public static String format(String format, Object... args)", "label": "public static String format(String format, Object... args)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a formatted string using the specified format string and\\n     * arguments.\\n     *\\n     * \u003cp\u003e The locale always used is the one returned by {@link\\n     * java.util.Locale#getDefault(java.util.Locale.Category)\\n     * Locale.getDefault(Locale.Category)} with\\n     * {@link java.util.Locale.Category#FORMAT FORMAT} category specified.\\n     *\\n     * @param  format\\n     *         A \u003ca href=\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\\n     *\\n     * @param  args\\n     *         Arguments referenced by the format specifiers in the format\\n     *         string.  If there are more arguments than format specifiers, the\\n     *         extra arguments are ignored.  The number of arguments is\\n     *         variable and may be zero.  The maximum number of arguments is\\n     *         limited by the maximum dimension of a Java array as defined by\\n     *         \u003ccite\u003eThe Java\u0026trade; Virtual Machine Specification\u003c/cite\u003e.\\n     *         The behaviour on a\\n     *         {@code null} argument depends on the \u003ca\\n     *         href=\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\\n     *\\n     * @throws  java.util.IllegalFormatException\\n     *          If a format string contains an illegal syntax, a format\\n     *          specifier that is incompatible with the given arguments,\\n     *          insufficient arguments given the format string, or other\\n     *          illegal conditions.  For specification of all possible\\n     *          formatting errors, see the \u003ca\\n     *          href=\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\\n     *          formatter class specification.\\n     *\\n     * @return  A formatted string\\n     *\\n     * @see  java.util.Formatter\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "getDefault(java.util.Locale.Category)", "label": "getDefault(java.util.Locale.Category)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "FORMAT", "label": "FORMAT", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static String format(Locale l, String format, Object... args)", "label": "public static String format(Locale l, String format, Object... args)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a formatted string using the specified locale, format string,\\n     * and arguments.\\n     *\\n     * @param  l\\n     *         The {@linkplain java.util.Locale locale} to apply during\\n     *         formatting.  If {@code l} is {@code null} then no localization\\n     *         is applied.\\n     *\\n     * @param  format\\n     *         A \u003ca href=\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\\n     *\\n     * @param  args\\n     *         Arguments referenced by the format specifiers in the format\\n     *         string.  If there are more arguments than format specifiers, the\\n     *         extra arguments are ignored.  The number of arguments is\\n     *         variable and may be zero.  The maximum number of arguments is\\n     *         limited by the maximum dimension of a Java array as defined by\\n     *         \u003ccite\u003eThe Java\u0026trade; Virtual Machine Specification\u003c/cite\u003e.\\n     *         The behaviour on a\\n     *         {@code null} argument depends on the\\n     *         \u003ca href=\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\\n     *\\n     * @throws  java.util.IllegalFormatException\\n     *          If a format string contains an illegal syntax, a format\\n     *          specifier that is incompatible with the given arguments,\\n     *          insufficient arguments given the format string, or other\\n     *          illegal conditions.  For specification of all possible\\n     *          formatting errors, see the \u003ca\\n     *          href=\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\\n     *          formatter class specification\\n     *\\n     * @return  A formatted string\\n     *\\n     * @see  java.util.Formatter\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String formatted(Object... args)", "label": "public String formatted(Object... args)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Formats using this string as the format string, and the supplied\\n     * arguments.\\n     *\\n     * @implSpec This method is equivalent to {@code String.format(this, args)}.\\n     *\\n     * @param  args\\n     *         Arguments referenced by the format specifiers in this string.\\n     *\\n     * @return  A formatted string\\n     *\\n     * @see  java.lang.String#format(String,Object...)\\n     * @see  java.util.Formatter\\n     *\\n     * @since 15\\n     *\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String valueOf(Object obj)", "label": "public static String valueOf(Object obj)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the string representation of the {@code Object} argument.\\n     *\\n     * @param   obj   an {@code Object}.\\n     * @return  if the argument is {@code null}, then a string equal to\\n     *          {@code \"null\"}; otherwise, the value of\\n     *          {@code obj.toString()} is returned.\\n     * @see     java.lang.Object#toString()\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String valueOf(char[] data)", "label": "public static String valueOf(char[] data)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the string representation of the {@code char} array\\n     * argument. The contents of the character array are copied; subsequent\\n     * modification of the character array does not affect the returned\\n     * string.\\n     *\\n     * @param   data     the character array.\\n     * @return  a {@code String} that contains the characters of the\\n     *          character array.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String valueOf(char[] data, int offset, int count)", "label": "public static String valueOf(char[] data, int offset, int count)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the string representation of a specific subarray of the\\n     * {@code char} array argument.\\n     * \u003cp\u003e\\n     * The {@code offset} argument is the index of the first\\n     * character of the subarray. The {@code count} argument\\n     * specifies the length of the subarray. The contents of the subarray\\n     * are copied; subsequent modification of the character array does not\\n     * affect the returned string.\\n     *\\n     * @param   data     the character array.\\n     * @param   offset   initial offset of the subarray.\\n     * @param   count    length of the subarray.\\n     * @return  a {@code String} that contains the characters of the\\n     *          specified subarray of the character array.\\n     * @exception IndexOutOfBoundsException if {@code offset} is\\n     *          negative, or {@code count} is negative, or\\n     *          {@code offset+count} is larger than\\n     *          {@code data.length}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String copyValueOf(char[] data, int offset, int count)", "label": "public static String copyValueOf(char[] data, int offset, int count)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Equivalent to {@link #valueOf(char[], int, int)}.\\n     *\\n     * @param   data     the character array.\\n     * @param   offset   initial offset of the subarray.\\n     * @param   count    length of the subarray.\\n     * @return  a {@code String} that contains the characters of the\\n     *          specified subarray of the character array.\\n     * @exception IndexOutOfBoundsException if {@code offset} is\\n     *          negative, or {@code count} is negative, or\\n     *          {@code offset+count} is larger than\\n     *          {@code data.length}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "valueOf(char", "label": "valueOf(char", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static String copyValueOf(char[] data)", "label": "public static String copyValueOf(char[] data)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Equivalent to {@link #valueOf(char[])}.\\n     *\\n     * @param   data   the character array.\\n     * @return  a {@code String} that contains the characters of the\\n     *          character array.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String valueOf(boolean b)", "label": "public static String valueOf(boolean b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the string representation of the {@code boolean} argument.\\n     *\\n     * @param   b   a {@code boolean}.\\n     * @return  if the argument is {@code true}, a string equal to\\n     *          {@code \"true\"} is returned; otherwise, a string equal to\\n     *          {@code \"false\"} is returned.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String valueOf(char c)", "label": "public static String valueOf(char c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the string representation of the {@code char}\\n     * argument.\\n     *\\n     * @param   c   a {@code char}.\\n     * @return  a string of length {@code 1} containing\\n     *          as its single character the argument {@code c}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String valueOf(int i)", "label": "public static String valueOf(int i)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the string representation of the {@code int} argument.\\n     * \u003cp\u003e\\n     * The representation is exactly the one returned by the\\n     * {@code Integer.toString} method of one argument.\\n     *\\n     * @param   i   an {@code int}.\\n     * @return  a string representation of the {@code int} argument.\\n     * @see     java.lang.Integer#toString(int, int)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String valueOf(long l)", "label": "public static String valueOf(long l)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the string representation of the {@code long} argument.\\n     * \u003cp\u003e\\n     * The representation is exactly the one returned by the\\n     * {@code Long.toString} method of one argument.\\n     *\\n     * @param   l   a {@code long}.\\n     * @return  a string representation of the {@code long} argument.\\n     * @see     java.lang.Long#toString(long)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String valueOf(float f)", "label": "public static String valueOf(float f)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the string representation of the {@code float} argument.\\n     * \u003cp\u003e\\n     * The representation is exactly the one returned by the\\n     * {@code Float.toString} method of one argument.\\n     *\\n     * @param   f   a {@code float}.\\n     * @return  a string representation of the {@code float} argument.\\n     * @see     java.lang.Float#toString(float)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String valueOf(double d)", "label": "public static String valueOf(double d)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the string representation of the {@code double} argument.\\n     * \u003cp\u003e\\n     * The representation is exactly the one returned by the\\n     * {@code Double.toString} method of one argument.\\n     *\\n     * @param   d   a {@code double}.\\n     * @return  a  string representation of the {@code double} argument.\\n     * @see     java.lang.Double#toString(double)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public native String intern()", "label": "public native String intern()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-added: Annotate native method as @FastNative.\u0027}"}, {"color": "#97c2fc", "id": "public String repeat(int count)", "label": "public String repeat(int count)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string whose value is the concatenation of this\\n     * string repeated {@code count} times.\\n     * \u003cp\u003e\\n     * If this string is empty or count is zero then the empty\\n     * string is returned.\\n     *\\n     * @param   count number of times to repeat\\n     *\\n     * @return  A string composed of this string repeated\\n     *          {@code count} times or the empty string if this\\n     *          string is empty or count is zero\\n     *\\n     * @throws  IllegalArgumentException if the {@code count} is\\n     *          negative.\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": " void getBytes(byte[] dst, int dstBegin, byte coder)", "label": " void getBytes(byte[] dst, int dstBegin, byte coder)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Copy character bytes from this string into dst starting at dstBegin.\\n     * This method doesn\u0027t perform any range checking.\\n     *\\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\\n     * coders are different, and dst is big enough (range check)\\n     *\\n     * @param dstBegin  the char index, not offset of byte[]\\n     * @param coder     the coder of dst[]\\n     \"}"}, {"color": "#97c2fc", "id": "private native void fillBytesLatin1(byte[] dst, int byteIndex)", "label": "private native void fillBytesLatin1(byte[] dst, int byteIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Fill the underlying characters into the byte buffer. No range check.\\n     * The caller should guarantee that dst is big enough for this operation.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private native void fillBytesUTF16(byte[] dst, int byteIndex)", "label": "private native void fillBytesUTF16(byte[] dst, int byteIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Fill the underlying characters into the byte buffer. No range check.\\n     * The caller should guarantee that dst is big enough for this operation.\\n     \u0027}"}, {"color": "#97c2fc", "id": " byte coder()", "label": " byte coder()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Android note: It returns UTF16 if the string has any 0x00 char.\\n     * See the difference between {@link StringLatin1#canEncode(int)} and\\n     * art::mirror::String::IsASCII(uint16_t) in string.h.\\n     \u0027}"}, {"color": "#97c2fc", "id": "canEncode(int)", "label": "canEncode(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.lang.StringLatin1", "label": "java.lang.StringLatin1", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public static int compareToUTF16(byte[] value, byte[] other, int len1, int len2)", "label": "public static int compareToUTF16(byte[] value, byte[] other, int len1, int len2)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Checks the boundary and then compares the byte arrays.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void inflate(byte[] src, int srcOff, char[] dst, int dstOff, int len)", "label": "public static void inflate(byte[] src, int srcOff, char[] dst, int dstOff, int len)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 inflatedCopy byte[] -\u003e char[]\u0027}"}, {"color": "#97c2fc", "id": "public static void inflate(byte[] src, int srcOff, byte[] dst, int dstOff, int len)", "label": "public static void inflate(byte[] src, int srcOff, byte[] dst, int dstOff, int len)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 inflatedCopy byte[] -\u003e byte[]\u0027}"}, {"color": "#97c2fc", "id": " static void checkIndex(int index, int length)", "label": " static void checkIndex(int index, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * StringIndexOutOfBoundsException  if {@code index} is\\n     * negative or greater than or equal to {@code length}.\\n     \u0027}"}, {"color": "#97c2fc", "id": " static void checkOffset(int offset, int length)", "label": " static void checkOffset(int offset, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * StringIndexOutOfBoundsException  if {@code offset}\\n     * is negative or greater than {@code length}.\\n     \u0027}"}, {"color": "#97c2fc", "id": " static void checkBoundsOffCount(int offset, int count, int length)", "label": " static void checkBoundsOffCount(int offset, int count, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Check {@code offset}, {@code count} against {@code 0} and {@code length}\\n     * bounds.\\n     *\\n     * @throws  StringIndexOutOfBoundsException\\n     *          If {@code offset} is negative, {@code count} is negative,\\n     *          or {@code offset} is greater than {@code length - count}\\n     \u0027}"}, {"color": "#97c2fc", "id": " static String valueOfCodePoint(int codePoint)", "label": " static String valueOfCodePoint(int codePoint)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the string representation of the {@code codePoint}\\n     * argument.\\n     *\\n     * @param   codePoint a {@code codePoint}.\\n     * @return  a string of length {@code 1} or {@code 2} containing\\n     *          as its single character the argument {@code codePoint}.\\n     * @throws IllegalArgumentException if the specified\\n     *          {@code codePoint} is not a {@linkplain Character#isValidCodePoint\\n     *          valid Unicode code point}.\\n     \u0027}"}, {"color": "#97c2fc", "id": " static void checkBoundsBeginEnd(int begin, int end, int length)", "label": " static void checkBoundsBeginEnd(int begin, int end, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Check {@code begin}, {@code end} against {@code 0} and {@code length}\\n     * bounds.\\n     *\\n     * @throws  StringIndexOutOfBoundsException\\n     *          If {@code begin} is negative, {@code begin} is greater than\\n     *          {@code end}, or {@code end} is greater than {@code length}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String toUnsignedString(int i, int radix)", "label": "public static String toUnsignedString(int i, int radix)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a string representation of the first argument as an\\n     * unsigned integer value in the radix specified by the second\\n     * argument.\\n     *\\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\\n     * or larger than {@code Character.MAX_RADIX}, then the radix\\n     * {@code 10} is used instead.\\n     *\\n     * \u003cp\u003eNote that since the first argument is treated as an unsigned\\n     * value, no leading sign character is printed.\\n     *\\n     * \u003cp\u003eIf the magnitude is zero, it is represented by a single zero\\n     * character {@code \u00270\u0027} ({@code \u0027\\\\u005Cu0030\u0027}); otherwise,\\n     * the first character of the representation of the magnitude will\\n     * not be the zero character.\\n     *\\n     * \u003cp\u003eThe behavior of radixes and the characters used as digits\\n     * are the same as {@link #toString(int, int) toString}.\\n     *\\n     * @param   i       an integer to be converted to an unsigned string.\\n     * @param   radix   the radix to use in the string representation.\\n     * @return  an unsigned string representation of the argument in the specified radix.\\n     * @see     #toString(int, int)\\n     * @since 1.8\\n     \"}"}, {"color": "#97c2fc", "id": "toString(int", "label": "toString(int", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static String toHexString(int i)", "label": "public static String toHexString(int i)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a string representation of the integer argument as an\\n     * unsigned integer in base\u0026nbsp;16.\\n     *\\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\\n     * if the argument is negative; otherwise, it is equal to the\\n     * argument.  This value is converted to a string of ASCII digits\\n     * in hexadecimal (base\u0026nbsp;16) with no extra leading\\n     * {@code 0}s.\\n     *\\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\\n     * string {@code s} by calling {@link\\n     * Integer#parseUnsignedInt(String, int)\\n     * Integer.parseUnsignedInt(s, 16)}.\\n     *\\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\\\u005Cu0030\u0027});\\n     * otherwise, the first character of the representation of the\\n     * unsigned magnitude will not be the zero character. The\\n     * following characters are used as hexadecimal digits:\\n     *\\n     * \u003cblockquote\u003e\\n     *  {@code 0123456789abcdef}\\n     * \u003c/blockquote\u003e\\n     *\\n     * These are the characters {@code \u0027\\\\u005Cu0030\u0027} through\\n     * {@code \u0027\\\\u005Cu0039\u0027} and {@code \u0027\\\\u005Cu0061\u0027} through\\n     * {@code \u0027\\\\u005Cu0066\u0027}. If uppercase letters are\\n     * desired, the {@link java.lang.String#toUpperCase()} method may\\n     * be called on the result:\\n     *\\n     * \u003cblockquote\u003e\\n     *  {@code Integer.toHexString(n).toUpperCase()}\\n     * \u003c/blockquote\u003e\\n     *\\n     * @param   i   an integer to be converted to a string.\\n     * @return  the string representation of the unsigned integer value\\n     *          represented by the argument in hexadecimal (base\u0026nbsp;16).\\n     * @see #parseUnsignedInt(String, int)\\n     * @see #toUnsignedString(int, int)\\n     * @since   1.0.2\\n     \"}"}, {"color": "#97c2fc", "id": "parseUnsignedInt(String", "label": "parseUnsignedInt(String", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static String toOctalString(int i)", "label": "public static String toOctalString(int i)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a string representation of the integer argument as an\\n     * unsigned integer in base\u0026nbsp;8.\\n     *\\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\\n     * if the argument is negative; otherwise, it is equal to the\\n     * argument.  This value is converted to a string of ASCII digits\\n     * in octal (base\u0026nbsp;8) with no extra leading {@code 0}s.\\n     *\\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\\n     * string {@code s} by calling {@link\\n     * Integer#parseUnsignedInt(String, int)\\n     * Integer.parseUnsignedInt(s, 8)}.\\n     *\\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\\\u005Cu0030\u0027});\\n     * otherwise, the first character of the representation of the\\n     * unsigned magnitude will not be the zero character. The\\n     * following characters are used as octal digits:\\n     *\\n     * \u003cblockquote\u003e\\n     * {@code 01234567}\\n     * \u003c/blockquote\u003e\\n     *\\n     * These are the characters {@code \u0027\\\\u005Cu0030\u0027} through\\n     * {@code \u0027\\\\u005Cu0037\u0027}.\\n     *\\n     * @param   i   an integer to be converted to a string.\\n     * @return  the string representation of the unsigned integer value\\n     *          represented by the argument in octal (base\u0026nbsp;8).\\n     * @see #parseUnsignedInt(String, int)\\n     * @see #toUnsignedString(int, int)\\n     * @since   1.0.2\\n     \"}"}, {"color": "#97c2fc", "id": "public static String toBinaryString(int i)", "label": "public static String toBinaryString(int i)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a string representation of the integer argument as an\\n     * unsigned integer in base\u0026nbsp;2.\\n     *\\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\\n     * if the argument is negative; otherwise it is equal to the\\n     * argument.  This value is converted to a string of ASCII digits\\n     * in binary (base\u0026nbsp;2) with no extra leading {@code 0}s.\\n     *\\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\\n     * string {@code s} by calling {@link\\n     * Integer#parseUnsignedInt(String, int)\\n     * Integer.parseUnsignedInt(s, 2)}.\\n     *\\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\\\u005Cu0030\u0027});\\n     * otherwise, the first character of the representation of the\\n     * unsigned magnitude will not be the zero character. The\\n     * characters {@code \u00270\u0027} ({@code \u0027\\\\u005Cu0030\u0027}) and {@code\\n     * \u00271\u0027} ({@code \u0027\\\\u005Cu0031\u0027}) are used as binary digits.\\n     *\\n     * @param   i   an integer to be converted to a string.\\n     * @return  the string representation of the unsigned integer value\\n     *          represented by the argument in binary (base\u0026nbsp;2).\\n     * @see #parseUnsignedInt(String, int)\\n     * @see #toUnsignedString(int, int)\\n     * @since   1.0.2\\n     \"}"}, {"color": "#97c2fc", "id": "private static String toUnsignedString0(int val, int shift)", "label": "private static String toUnsignedString0(int val, int shift)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Convert the integer to an unsigned number.\\n     \u0027}"}, {"color": "#97c2fc", "id": " static void formatUnsignedInt(int val, int shift, char[] buf, int offset, int len)", "label": " static void formatUnsignedInt(int val, int shift, char[] buf, int offset, int len)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Format an {@code int} (treated as unsigned) into a character buffer. If\\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\\n     * {@code buf} will be padded with leading zeroes.\\n     *\\n     * @param val the unsigned int to format\\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\\n     * @param buf the character buffer to write to\\n     * @param offset the offset in the destination buffer to start at\\n     * @param len the number of characters to write\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static void formatUnsignedInt(int val, int shift, byte[] buf, int len)", "label": "private static void formatUnsignedInt(int val, int shift, byte[] buf, int len)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Format an {@code int} (treated as unsigned) into a byte buffer (LATIN1 version). If\\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\\n     * {@code buf} will be padded with leading zeroes.\\n     *\\n     * @param val the unsigned int to format\\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\\n     * @param buf the byte buffer to write to\\n     * @param len the number of characters to write\\n     \u0027}"}, {"color": "#97c2fc", "id": " static void formatUnsignedInt(int val, int shift, byte[] buf, int offset, int len)", "label": " static void formatUnsignedInt(int val, int shift, byte[] buf, int offset, int len)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 byte[]/LATIN1 version    \u0027}"}, {"color": "#97c2fc", "id": "public static String toString(int i)", "label": "public static String toString(int i)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code String} object representing the\\n     * specified integer. The argument is converted to signed decimal\\n     * representation and returned as a string, exactly as if the\\n     * argument and radix 10 were given as arguments to the {@link\\n     * #toString(int, int)} method.\\n     *\\n     * @param   i   an integer to be converted.\\n     * @return  a string representation of the argument in base\u0026nbsp;10.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String toUnsignedString(int i)", "label": "public static String toUnsignedString(int i)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string representation of the argument as an unsigned\\n     * decimal value.\\n     *\\n     * The argument is converted to unsigned decimal representation\\n     * and returned as a string exactly as if the argument and radix\\n     * 10 were given as arguments to the {@link #toUnsignedString(int,\\n     * int)} method.\\n     *\\n     * @param   i  an integer to be converted to an unsigned string.\\n     * @return  an unsigned string representation of the argument.\\n     * @see     #toUnsignedString(int, int)\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "toUnsignedString(int", "label": "toUnsignedString(int", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " static int getChars(int i, int index, byte[] buf)", "label": " static int getChars(int i, int index, byte[] buf)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Places characters representing the integer i into the\\n     * character array buf. The characters are placed into\\n     * the buffer backwards starting with the least significant\\n     * digit at the specified index (exclusive), and working\\n     * backwards from there.\\n     *\\n     * @implNote This method converts positive inputs into negative\\n     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\\n     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\\n     * integer.\\n     *\\n     * @param i     value to convert\\n     * @param index next index, after the least significant digit\\n     * @param buf   target buffer, Latin1-encoded\\n     * @return index of the most significant digit or minus sign, if present\\n     \u0027}"}, {"color": "#97c2fc", "id": " static int getChars(int i, int index, char[] buf)", "label": " static int getChars(int i, int index, char[] buf)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 for java.lang.AbstractStringBuilder#append(int).\u0027}"}, {"color": "#97c2fc", "id": " static int stringSize(int x)", "label": " static int stringSize(int x)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the string representation size for a given int value.\\n     *\\n     * @param x int value\\n     * @return string size\\n     *\\n     * @implNote There are other ways to compute this: e.g. binary search,\\n     * but values are biased heavily towards zero, and therefore linear search\\n     * wins. The iteration results are also routinely inlined in the generated\\n     * code after loop unrolling.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int parseInt(String s, int radix) throws NumberFormatException", "label": "public static int parseInt(String s, int radix) throws NumberFormatException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Parses the string argument as a signed integer in the radix\\n     * specified by the second argument. The characters in the string\\n     * must all be digits of the specified radix (as determined by\\n     * whether {@link java.lang.Character#digit(char, int)} returns a\\n     * nonnegative value), except that the first character may be an\\n     * ASCII minus sign {@code \\\u0027-\\\u0027} ({@code \\\u0027\\\\u005Cu002D\\\u0027}) to\\n     * indicate a negative value or an ASCII plus sign {@code \\\u0027+\\\u0027}\\n     * ({@code \\\u0027\\\\u005Cu002B\\\u0027}) to indicate a positive value. The\\n     * resulting integer value is returned.\\n     *\\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\\n     * thrown if any of the following situations occurs:\\n     * \u003cul\u003e\\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\\n     * length zero.\\n     *\\n     * \u003cli\u003eThe radix is either smaller than\\n     * {@link java.lang.Character#MIN_RADIX} or\\n     * larger than {@link java.lang.Character#MAX_RADIX}.\\n     *\\n     * \u003cli\u003eAny character of the string is not a digit of the specified\\n     * radix, except that the first character may be a minus sign\\n     * {@code \\\u0027-\\\u0027} ({@code \\\u0027\\\\u005Cu002D\\\u0027}) or plus sign\\n     * {@code \\\u0027+\\\u0027} ({@code \\\u0027\\\\u005Cu002B\\\u0027}) provided that the\\n     * string is longer than length 1.\\n     *\\n     * \u003cli\u003eThe value represented by the string is not a value of type\\n     * {@code int}.\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003eExamples:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * parseInt(\"0\", 10) returns 0\\n     * parseInt(\"473\", 10) returns 473\\n     * parseInt(\"+42\", 10) returns 42\\n     * parseInt(\"-0\", 10) returns 0\\n     * parseInt(\"-FF\", 16) returns -255\\n     * parseInt(\"1100110\", 2) returns 102\\n     * parseInt(\"2147483647\", 10) returns 2147483647\\n     * parseInt(\"-2147483648\", 10) returns -2147483648\\n     * parseInt(\"2147483648\", 10) throws a NumberFormatException\\n     * parseInt(\"99\", 8) throws a NumberFormatException\\n     * parseInt(\"Kona\", 10) throws a NumberFormatException\\n     * parseInt(\"Kona\", 27) returns 411787\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @param      s   the {@code String} containing the integer\\n     *                  representation to be parsed\\n     * @param      radix   the radix to be used while parsing {@code s}.\\n     * @return     the integer represented by the string argument in the\\n     *             specified radix.\\n     * @throws     NumberFormatException if the {@code String}\\n     *             does not contain a parsable {@code int}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix) throws NumberFormatException", "label": "public static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix) throws NumberFormatException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Parses the {@link CharSequence} argument as a signed {@code int} in the\\n     * specified {@code radix}, beginning at the specified {@code beginIndex}\\n     * and extending to {@code endIndex - 1}.\\n     *\\n     * \u003cp\u003eThe method does not take steps to guard against the\\n     * {@code CharSequence} being mutated while parsing.\\n     *\\n     * @param      s   the {@code CharSequence} containing the {@code int}\\n     *                  representation to be parsed\\n     * @param      beginIndex   the beginning index, inclusive.\\n     * @param      endIndex     the ending index, exclusive.\\n     * @param      radix   the radix to be used while parsing {@code s}.\\n     * @return     the signed {@code int} represented by the subsequence in\\n     *             the specified radix.\\n     * @throws     NullPointerException  if {@code s} is null.\\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\\n     *             negative, or if {@code beginIndex} is greater than\\n     *             {@code endIndex} or if {@code endIndex} is greater than\\n     *             {@code s.length()}.\\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\\n     *             contain a parsable {@code int} in the specified\\n     *             {@code radix}, or if {@code radix} is either smaller than\\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\\n     *             {@link java.lang.Character#MAX_RADIX}.\\n     * @since  9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int parseInt(String s) throws NumberFormatException", "label": "public static int parseInt(String s) throws NumberFormatException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Parses the string argument as a signed decimal integer. The\\n     * characters in the string must all be decimal digits, except\\n     * that the first character may be an ASCII minus sign {@code \u0027-\u0027}\\n     * ({@code \u0027\\\\u005Cu002D\u0027}) to indicate a negative value or an\\n     * ASCII plus sign {@code \u0027+\u0027} ({@code \u0027\\\\u005Cu002B\u0027}) to\\n     * indicate a positive value. The resulting integer value is\\n     * returned, exactly as if the argument and the radix 10 were\\n     * given as arguments to the {@link #parseInt(java.lang.String,\\n     * int)} method.\\n     *\\n     * @param s    a {@code String} containing the {@code int}\\n     *             representation to be parsed\\n     * @return     the integer value represented by the argument in decimal.\\n     * @throws     NumberFormatException  if the string does not contain a\\n     *               parsable integer.\\n     \"}"}, {"color": "#97c2fc", "id": "parseInt(java.lang.String", "label": "parseInt(java.lang.String", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int parseUnsignedInt(String s, int radix) throws NumberFormatException", "label": "public static int parseUnsignedInt(String s, int radix) throws NumberFormatException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Parses the string argument as an unsigned integer in the radix\\n     * specified by the second argument.  An unsigned integer maps the\\n     * values usually associated with negative numbers to positive\\n     * numbers larger than {@code MAX_VALUE}.\\n     *\\n     * The characters in the string must all be digits of the\\n     * specified radix (as determined by whether {@link\\n     * java.lang.Character#digit(char, int)} returns a nonnegative\\n     * value), except that the first character may be an ASCII plus\\n     * sign {@code \u0027+\u0027} ({@code \u0027\\\\u005Cu002B\u0027}). The resulting\\n     * integer value is returned.\\n     *\\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\\n     * thrown if any of the following situations occurs:\\n     * \u003cul\u003e\\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\\n     * length zero.\\n     *\\n     * \u003cli\u003eThe radix is either smaller than\\n     * {@link java.lang.Character#MIN_RADIX} or\\n     * larger than {@link java.lang.Character#MAX_RADIX}.\\n     *\\n     * \u003cli\u003eAny character of the string is not a digit of the specified\\n     * radix, except that the first character may be a plus sign\\n     * {@code \u0027+\u0027} ({@code \u0027\\\\u005Cu002B\u0027}) provided that the\\n     * string is longer than length 1.\\n     *\\n     * \u003cli\u003eThe value represented by the string is larger than the\\n     * largest unsigned {@code int}, 2\u003csup\u003e32\u003c/sup\u003e-1.\\n     *\\n     * \u003c/ul\u003e\\n     *\\n     *\\n     * @param      s   the {@code String} containing the unsigned integer\\n     *                  representation to be parsed\\n     * @param      radix   the radix to be used while parsing {@code s}.\\n     * @return     the integer represented by the string argument in the\\n     *             specified radix.\\n     * @throws     NumberFormatException if the {@code String}\\n     *             does not contain a parsable {@code int}.\\n     * @since 1.8\\n     \"}"}, {"color": "#97c2fc", "id": "public static int parseUnsignedInt(CharSequence s, int beginIndex, int endIndex, int radix) throws NumberFormatException", "label": "public static int parseUnsignedInt(CharSequence s, int beginIndex, int endIndex, int radix) throws NumberFormatException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Parses the {@link CharSequence} argument as an unsigned {@code int} in\\n     * the specified {@code radix}, beginning at the specified\\n     * {@code beginIndex} and extending to {@code endIndex - 1}.\\n     *\\n     * \u003cp\u003eThe method does not take steps to guard against the\\n     * {@code CharSequence} being mutated while parsing.\\n     *\\n     * @param      s   the {@code CharSequence} containing the unsigned\\n     *                 {@code int} representation to be parsed\\n     * @param      beginIndex   the beginning index, inclusive.\\n     * @param      endIndex     the ending index, exclusive.\\n     * @param      radix   the radix to be used while parsing {@code s}.\\n     * @return     the unsigned {@code int} represented by the subsequence in\\n     *             the specified radix.\\n     * @throws     NullPointerException  if {@code s} is null.\\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\\n     *             negative, or if {@code beginIndex} is greater than\\n     *             {@code endIndex} or if {@code endIndex} is greater than\\n     *             {@code s.length()}.\\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\\n     *             contain a parsable unsigned {@code int} in the specified\\n     *             {@code radix}, or if {@code radix} is either smaller than\\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\\n     *             {@link java.lang.Character#MAX_RADIX}.\\n     * @since  9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int parseUnsignedInt(String s) throws NumberFormatException", "label": "public static int parseUnsignedInt(String s) throws NumberFormatException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Parses the string argument as an unsigned decimal integer. The\\n     * characters in the string must all be decimal digits, except\\n     * that the first character may be an ASCII plus sign {@code\\n     * \u0027+\u0027} ({@code \u0027\\\\u005Cu002B\u0027}). The resulting integer value\\n     * is returned, exactly as if the argument and the radix 10 were\\n     * given as arguments to the {@link\\n     * #parseUnsignedInt(java.lang.String, int)} method.\\n     *\\n     * @param s   a {@code String} containing the unsigned {@code int}\\n     *            representation to be parsed\\n     * @return    the unsigned integer value represented by the argument in decimal.\\n     * @throws    NumberFormatException  if the string does not contain a\\n     *            parsable unsigned integer.\\n     * @since 1.8\\n     \"}"}, {"color": "#97c2fc", "id": "parseUnsignedInt(java.lang.String", "label": "parseUnsignedInt(java.lang.String", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static Integer valueOf(String s, int radix) throws NumberFormatException", "label": "public static Integer valueOf(String s, int radix) throws NumberFormatException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@code Integer} object holding the value\\n     * extracted from the specified {@code String} when parsed\\n     * with the radix given by the second argument. The first argument\\n     * is interpreted as representing a signed integer in the radix\\n     * specified by the second argument, exactly as if the arguments\\n     * were given to the {@link #parseInt(java.lang.String, int)}\\n     * method. The result is an {@code Integer} object that\\n     * represents the integer value specified by the string.\\n     *\\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\\n     * object equal to the value of:\\n     *\\n     * \u003cblockquote\u003e\\n     *  {@code new Integer(Integer.parseInt(s, radix))}\\n     * \u003c/blockquote\u003e\\n     *\\n     * @param      s   the string to be parsed.\\n     * @param      radix the radix to be used in interpreting {@code s}\\n     * @return     an {@code Integer} object holding the value\\n     *             represented by the string argument in the specified\\n     *             radix.\\n     * @throws    NumberFormatException if the {@code String}\\n     *            does not contain a parsable {@code int}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Integer valueOf(String s) throws NumberFormatException", "label": "public static Integer valueOf(String s) throws NumberFormatException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@code Integer} object holding the\\n     * value of the specified {@code String}. The argument is\\n     * interpreted as representing a signed decimal integer, exactly\\n     * as if the argument were given to the {@link\\n     * #parseInt(java.lang.String)} method. The result is an\\n     * {@code Integer} object that represents the integer value\\n     * specified by the string.\\n     *\\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\\n     * object equal to the value of:\\n     *\\n     * \u003cblockquote\u003e\\n     *  {@code new Integer(Integer.parseInt(s))}\\n     * \u003c/blockquote\u003e\\n     *\\n     * @param      s   the string to be parsed.\\n     * @return     an {@code Integer} object holding the value\\n     *             represented by the string argument.\\n     * @throws     NumberFormatException  if the string cannot be parsed\\n     *             as an integer.\\n     \u0027}"}, {"color": "#97c2fc", "id": "parseInt(java.lang.String)", "label": "parseInt(java.lang.String)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static Integer valueOf(int i)", "label": "public static Integer valueOf(int i)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@code Integer} instance representing the specified\\n     * {@code int} value.  If a new {@code Integer} instance is not\\n     * required, this method should generally be used in preference to\\n     * the constructor {@link #Integer(int)}, as this method is likely\\n     * to yield significantly better space and time performance by\\n     * caching frequently requested values.\\n     *\\n     * This method will always cache values in the range -128 to 127,\\n     * inclusive, and may cache other values outside of this range.\\n     *\\n     * @param  i an {@code int} value.\\n     * @return an {@code Integer} instance representing {@code i}.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "Integer(int)", "label": "Integer(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public byte byteValue()", "label": "public byte byteValue()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value of this {@code Double} as a {@code byte}\\n     * after a narrowing primitive conversion.\\n     *\\n     * @return  the {@code double} value represented by this object\\n     *          converted to type {@code byte}\\n     * @jls 5.1.3 Narrowing Primitive Conversion\\n     * @since 1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "public short shortValue()", "label": "public short shortValue()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value of this {@code Double} as a {@code short}\\n     * after a narrowing primitive conversion.\\n     *\\n     * @return  the {@code double} value represented by this object\\n     *          converted to type {@code short}\\n     * @jls 5.1.3 Narrowing Primitive Conversion\\n     * @since 1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int intValue()", "label": "public int intValue()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value of this {@code Double} as an {@code int}\\n     * after a narrowing primitive conversion.\\n     * @jls 5.1.3 Narrowing Primitive Conversion\\n     *\\n     * @return  the {@code double} value represented by this object\\n     *          converted to type {@code int}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public long longValue()", "label": "public long longValue()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value of this {@code Double} as a {@code long}\\n     * after a narrowing primitive conversion.\\n     *\\n     * @return  the {@code double} value represented by this object\\n     *          converted to type {@code long}\\n     * @jls 5.1.3 Narrowing Primitive Conversion\\n     \u0027}"}, {"color": "#97c2fc", "id": "public float floatValue()", "label": "public float floatValue()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value of this {@code Double} as a {@code float}\\n     * after a narrowing primitive conversion.\\n     *\\n     * @return  the {@code double} value represented by this object\\n     *          converted to type {@code float}\\n     * @jls 5.1.3 Narrowing Primitive Conversion\\n     * @since 1.0\\n     \u0027}"}, {"color": "#97c2fc", "id": "public double doubleValue()", "label": "public double doubleValue()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the {@code double} value of this {@code Double} object.\\n     *\\n     * @return the {@code double} value represented by this object\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int hashCode(int value)", "label": "public static int hashCode(int value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a hash code for an {@code int} value; compatible with\\n     * {@code Integer.hashCode()}.\\n     *\\n     * @param value the value to hash\\n     * @since 1.8\\n     *\\n     * @return a hash code value for an {@code int} value.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Integer getInteger(String nm)", "label": "public static Integer getInteger(String nm)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines the integer value of the system property with the\\n     * specified name.\\n     *\\n     * \u003cp\u003eThe first argument is treated as the name of a system\\n     * property.  System properties are accessible through the {@link\\n     * java.lang.System#getProperty(java.lang.String)} method. The\\n     * string value of this property is then interpreted as an integer\\n     * value using the grammar supported by {@link Integer#decode decode} and\\n     * an {@code Integer} object representing this value is returned.\\n     *\\n     * \u003cp\u003eIf there is no property with the specified name, if the\\n     * specified name is empty or {@code null}, or if the property\\n     * does not have the correct numeric format, then {@code null} is\\n     * returned.\\n     *\\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\\n     * object equal to the value of:\\n     *\\n     * \u003cblockquote\u003e\\n     *  {@code getInteger(nm, null)}\\n     * \u003c/blockquote\u003e\\n     *\\n     * @param   nm   property name.\\n     * @return  the {@code Integer} value of the property.\\n     * @throws  SecurityException for the same reasons as\\n     *          {@link System#getProperty(String) System.getProperty}\\n     * @see     java.lang.System#getProperty(java.lang.String)\\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\\n     \u0027}"}, {"color": "#97c2fc", "id": "getProperty(java.lang.String)", "label": "getProperty(java.lang.String)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.lang.System", "label": "java.lang.System", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * The \u003ccode\u003eSystem\u003c/code\u003e class contains several useful class fields\\n * and methods. It cannot be instantiated.\\n *\\n * \u003cp\u003eAmong the facilities provided by the \u003ccode\u003eSystem\u003c/code\u003e class\\n * are standard input, standard output, and error output streams;\\n * access to externally defined properties and environment\\n * variables; a means of loading files and libraries; and a utility\\n * method for quickly copying a portion of an array.\\n *\\n * @author  unascribed\\n * @since   JDK1.0\\n \u0027}"}, {"color": "#97c2fc", "id": "public static void setIn(InputStream in)", "label": "public static void setIn(InputStream in)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reassigns the \"standard\" input stream.\\n     *\\n     * \u003cp\u003eFirst, if there is a security manager, its \u003ccode\u003echeckPermission\u003c/code\u003e\\n     * method is called with a \u003ccode\u003eRuntimePermission(\"setIO\")\u003c/code\u003e permission\\n     *  to see if it\\\u0027s ok to reassign the \"standard\" input stream.\\n     * \u003cp\u003e\\n     *\\n     * @param in the new standard input stream.\\n     *\\n     * @throws SecurityException\\n     *        if a security manager exists and its\\n     *        \u003ccode\u003echeckPermission\u003c/code\u003e method doesn\\\u0027t allow\\n     *        reassigning of the standard input stream.\\n     *\\n     * @see SecurityManager#checkPermission\\n     * @see java.lang.RuntimePermission\\n     *\\n     * @since   JDK1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void setOut(PrintStream out)", "label": "public static void setOut(PrintStream out)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reassigns the \"standard\" output stream.\\n     *\\n     * \u003cp\u003eFirst, if there is a security manager, its \u003ccode\u003echeckPermission\u003c/code\u003e\\n     * method is called with a \u003ccode\u003eRuntimePermission(\"setIO\")\u003c/code\u003e permission\\n     *  to see if it\\\u0027s ok to reassign the \"standard\" output stream.\\n     *\\n     * @param out the new standard output stream\\n     *\\n     * @throws SecurityException\\n     *        if a security manager exists and its\\n     *        \u003ccode\u003echeckPermission\u003c/code\u003e method doesn\\\u0027t allow\\n     *        reassigning of the standard output stream.\\n     *\\n     * @see SecurityManager#checkPermission\\n     * @see java.lang.RuntimePermission\\n     *\\n     * @since   JDK1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void setErr(PrintStream err)", "label": "public static void setErr(PrintStream err)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reassigns the \"standard\" error output stream.\\n     *\\n     * \u003cp\u003eFirst, if there is a security manager, its \u003ccode\u003echeckPermission\u003c/code\u003e\\n     * method is called with a \u003ccode\u003eRuntimePermission(\"setIO\")\u003c/code\u003e permission\\n     *  to see if it\\\u0027s ok to reassign the \"standard\" error output stream.\\n     *\\n     * @param err the new standard error output stream.\\n     *\\n     * @throws SecurityException\\n     *        if a security manager exists and its\\n     *        \u003ccode\u003echeckPermission\u003c/code\u003e method doesn\\\u0027t allow\\n     *        reassigning of the standard error output stream.\\n     *\\n     * @see SecurityManager#checkPermission\\n     * @see java.lang.RuntimePermission\\n     *\\n     * @since   JDK1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Console console()", "label": "public static Console console()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the unique {@link java.io.Console Console} object associated\\n     * with the current Java virtual machine, if any.\\n     *\\n     * @return  The system console, if any, otherwise \u003ctt\u003enull\u003c/tt\u003e.\\n     *\\n     * @since   1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.io.Console", "label": "java.io.Console", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public PrintWriter writer()", "label": "public PrintWriter writer()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    * Retrieves the unique {@link java.io.PrintWriter PrintWriter} object\\n    * associated with this console.\\n    *\\n    * @return  The printwriter associated with this console\\n    \u0027}"}, {"color": "#97c2fc", "id": "java.io.PrintWriter", "label": "java.io.PrintWriter", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "private static Charset toCharset(String csn) throws UnsupportedEncodingException", "label": "private static Charset toCharset(String csn) throws UnsupportedEncodingException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a charset object for the given charset name.\\n     * @throws NullPointerException          is csn is null\\n     * @throws UnsupportedEncodingException  if the charset is not supported\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void ensureOpen() throws IOException", "label": "private void ensureOpen() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Checks to make sure that the stream has not been closed \u0027}"}, {"color": "#97c2fc", "id": "public void flush()", "label": "public void flush()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Flushes the console and forces any buffered output to be written\\n     * immediately .\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void close()", "label": "public void close()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Closes this datagram socket.\\n     * \u003cp\u003e\\n     * Any thread currently blocked in {@link #receive} upon this socket\\n     * will throw a {@link SocketException}.\\n     *\\n     * \u003cp\u003e If this socket has an associated channel then the channel is closed\\n     * as well.\\n     *\\n     * @revised 1.4\\n     * @spec JSR-51\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean checkError()", "label": "public boolean checkError()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Flushes the stream if it\u0027s not closed and checks its error state.\\n     *\\n     * @return {@code true} if the print stream has encountered an error,\\n     *          either on the underlying output stream or during a format\\n     *          conversion.\\n     \"}"}, {"color": "#97c2fc", "id": "protected void setError()", "label": "protected void setError()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Indicates that an error has occurred.\\n     *\\n     * \u003cp\u003e This method will cause subsequent invocations of {@link\\n     * #checkError()} to return {@code true} until {@link\\n     * #clearError()} is invoked.\\n     \u0027}"}, {"color": "#97c2fc", "id": "checkError()", "label": "checkError()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "clearError()", "label": "clearError()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "protected void clearError()", "label": "protected void clearError()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Clears the error state of this stream.\\n     *\\n     * \u003cp\u003e This method will cause subsequent invocations of {@link\\n     * #checkError()} to return {@code false} until another write\\n     * operation fails and invokes {@link #setError()}.\\n     *\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "setError()", "label": "setError()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void write(int c)", "label": "public void write(int c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes a single character.\\n     * @param c int specifying a character to be written.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void write(char[] buf, int off, int len)", "label": "public void write(char[] buf, int off, int len)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes A Portion of an array of characters.\\n     * @param buf Array of characters\\n     * @param off Offset from which to start writing characters\\n     * @param len Number of characters to write\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If the values of the {@code off} and {@code len} parameters\\n     *          cause the corresponding method of the underlying {@code Writer}\\n     *          to throw an {@code IndexOutOfBoundsException}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void write(char[] buf)", "label": "public void write(char[] buf)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes an array of characters.  This method cannot be inherited from the\\n     * Writer class because it must suppress I/O exceptions.\\n     * @param buf Array of characters to be written\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void write(String s, int off, int len)", "label": "public void write(String s, int off, int len)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes a portion of a string.\\n     * @param s A String\\n     * @param off Offset from which to start writing characters\\n     * @param len Number of characters to write\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If the values of the {@code off} and {@code len} parameters\\n     *          cause the corresponding method of the underlying {@code Writer}\\n     *          to throw an {@code IndexOutOfBoundsException}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void write(String s)", "label": "public void write(String s)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes a string.  This method cannot be inherited from the Writer class\\n     * because it must suppress I/O exceptions.\\n     * @param s String to be written\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void print(boolean b)", "label": "public void print(boolean b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Prints a boolean value.  The string produced by {@link\\n     * java.lang.String#valueOf(boolean)} is translated into bytes\\n     * according to the platform\u0027s default character encoding, and these bytes\\n     * are written in exactly the manner of the {@link\\n     * #write(int)} method.\\n     *\\n     * @param      b   The {@code boolean} to be printed\\n     \"}"}, {"color": "#97c2fc", "id": "write(int)", "label": "write(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void print(char c)", "label": "public void print(char c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Prints a character.  The character is translated into one or more bytes\\n     * according to the platform\u0027s default character encoding, and these bytes\\n     * are written in exactly the manner of the {@link\\n     * #write(int)} method.\\n     *\\n     * @param      c   The {@code char} to be printed\\n     \"}"}, {"color": "#97c2fc", "id": "public void print(int i)", "label": "public void print(int i)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Prints an integer.  The string produced by {@link\\n     * java.lang.String#valueOf(int)} is translated into bytes according\\n     * to the platform\u0027s default character encoding, and these bytes are\\n     * written in exactly the manner of the {@link #write(int)}\\n     * method.\\n     *\\n     * @param      i   The {@code int} to be printed\\n     * @see        java.lang.Integer#toString(int)\\n     \"}"}, {"color": "#97c2fc", "id": "public void print(long l)", "label": "public void print(long l)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Prints a long integer.  The string produced by {@link\\n     * java.lang.String#valueOf(long)} is translated into bytes\\n     * according to the platform\u0027s default character encoding, and these bytes\\n     * are written in exactly the manner of the {@link #write(int)}\\n     * method.\\n     *\\n     * @param      l   The {@code long} to be printed\\n     * @see        java.lang.Long#toString(long)\\n     \"}"}, {"color": "#97c2fc", "id": "public void print(float f)", "label": "public void print(float f)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Prints a floating-point number.  The string produced by {@link\\n     * java.lang.String#valueOf(float)} is translated into bytes\\n     * according to the platform\u0027s default character encoding, and these bytes\\n     * are written in exactly the manner of the {@link #write(int)}\\n     * method.\\n     *\\n     * @param      f   The {@code float} to be printed\\n     * @see        java.lang.Float#toString(float)\\n     \"}"}, {"color": "#97c2fc", "id": "public void print(double d)", "label": "public void print(double d)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Prints a double-precision floating-point number.  The string produced by\\n     * {@link java.lang.String#valueOf(double)} is translated into\\n     * bytes according to the platform\u0027s default character encoding, and these\\n     * bytes are written in exactly the manner of the {@link\\n     * #write(int)} method.\\n     *\\n     * @param      d   The {@code double} to be printed\\n     * @see        java.lang.Double#toString(double)\\n     \"}"}, {"color": "#97c2fc", "id": "public void print(char[] s)", "label": "public void print(char[] s)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Prints an array of characters.  The characters are converted into bytes\\n     * according to the platform\u0027s default character encoding, and these bytes\\n     * are written in exactly the manner of the {@link #write(int)}\\n     * method.\\n     *\\n     * @param      s   The array of chars to be printed\\n     *\\n     * @throws  NullPointerException  If {@code s} is {@code null}\\n     \"}"}, {"color": "#97c2fc", "id": "public void print(String s)", "label": "public void print(String s)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Prints a string.  If the argument is {@code null} then the string\\n     * {@code \"null\"} is printed.  Otherwise, the string\\\u0027s characters are\\n     * converted into bytes according to the platform\\\u0027s default character\\n     * encoding, and these bytes are written in exactly the manner of the\\n     * {@link #write(int)} method.\\n     *\\n     * @param      s   The {@code String} to be printed\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void print(Object obj)", "label": "public void print(Object obj)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Prints an object.  The string produced by the {@link\\n     * java.lang.String#valueOf(Object)} method is translated into bytes\\n     * according to the platform\u0027s default character encoding, and these bytes\\n     * are written in exactly the manner of the {@link #write(int)}\\n     * method.\\n     *\\n     * @param      obj   The {@code Object} to be printed\\n     * @see        java.lang.Object#toString()\\n     \"}"}, {"color": "#97c2fc", "id": "public void println()", "label": "public void println()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Terminates the current line by writing the line separator string.  The\\n     * line separator string is defined by the system property\\n     * {@code line.separator}, and is not necessarily a single newline\\n     * character ({@code \u0027\\\\n\u0027}).\\n     \"}"}, {"color": "#97c2fc", "id": "public void println(boolean x)", "label": "public void println(boolean x)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Prints a boolean value and then terminates the line.  This method behaves\\n     * as though it invokes {@link #print(boolean)} and then\\n     * {@link #println()}.\\n     *\\n     * @param x the {@code boolean} value to be printed\\n     \u0027}"}, {"color": "#97c2fc", "id": "print(boolean)", "label": "print(boolean)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "println()", "label": "println()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void println(char x)", "label": "public void println(char x)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Prints a character and then terminates the line.  This method behaves as\\n     * though it invokes {@link #print(char)} and then {@link\\n     * #println()}.\\n     *\\n     * @param x the {@code char} value to be printed\\n     \u0027}"}, {"color": "#97c2fc", "id": "print(char)", "label": "print(char)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void println(int x)", "label": "public void println(int x)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Prints an integer and then terminates the line.  This method behaves as\\n     * though it invokes {@link #print(int)} and then {@link\\n     * #println()}.\\n     *\\n     * @param x the {@code int} value to be printed\\n     \u0027}"}, {"color": "#97c2fc", "id": "print(int)", "label": "print(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void println(long x)", "label": "public void println(long x)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Prints a long integer and then terminates the line.  This method behaves\\n     * as though it invokes {@link #print(long)} and then\\n     * {@link #println()}.\\n     *\\n     * @param x the {@code long} value to be printed\\n     \u0027}"}, {"color": "#97c2fc", "id": "print(long)", "label": "print(long)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void println(float x)", "label": "public void println(float x)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Prints a floating-point number and then terminates the line.  This method\\n     * behaves as though it invokes {@link #print(float)} and then\\n     * {@link #println()}.\\n     *\\n     * @param x the {@code float} value to be printed\\n     \u0027}"}, {"color": "#97c2fc", "id": "print(float)", "label": "print(float)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void println(double x)", "label": "public void println(double x)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Prints a double-precision floating-point number and then terminates the\\n     * line.  This method behaves as though it invokes {@link\\n     * #print(double)} and then {@link #println()}.\\n     *\\n     * @param x the {@code double} value to be printed\\n     \u0027}"}, {"color": "#97c2fc", "id": "print(double)", "label": "print(double)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void println(char[] x)", "label": "public void println(char[] x)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Prints an array of characters and then terminates the line.  This method\\n     * behaves as though it invokes {@link #print(char[])} and then\\n     * {@link #println()}.\\n     *\\n     * @param x the array of {@code char} values to be printed\\n     \u0027}"}, {"color": "#97c2fc", "id": "print(char", "label": "print(char", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void println(String x)", "label": "public void println(String x)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Prints a String and then terminates the line.  This method behaves as\\n     * though it invokes {@link #print(String)} and then\\n     * {@link #println()}.\\n     *\\n     * @param x the {@code String} value to be printed\\n     \u0027}"}, {"color": "#97c2fc", "id": "print(String)", "label": "print(String)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void println(Object x)", "label": "public void println(Object x)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Prints an Object and then terminates the line.  This method calls\\n     * at first String.valueOf(x) to get the printed object\u0027s string value,\\n     * then behaves as\\n     * though it invokes {@link #print(String)} and then\\n     * {@link #println()}.\\n     *\\n     * @param x  The {@code Object} to be printed.\\n     \"}"}, {"color": "#97c2fc", "id": "public PrintWriter printf(String format, Object... args)", "label": "public PrintWriter printf(String format, Object... args)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * A convenience method to write a formatted string to this writer using\\n     * the specified format string and arguments.  If automatic flushing is\\n     * enabled, calls to this method will flush the output buffer.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form\\n     * {@code out.printf(format, args)}\\n     * behaves in exactly the same way as the invocation\\n     *\\n     * \u003cpre\u003e{@code\\n     *     out.format(format, args)\\n     * }\u003c/pre\u003e\\n     *\\n     * @param  format\\n     *         A format string as described in \u003ca\\n     *         href=\"../util/Formatter.html#syntax\"\u003eFormat string syntax\u003c/a\u003e.\\n     *\\n     * @param  args\\n     *         Arguments referenced by the format specifiers in the format\\n     *         string.  If there are more arguments than format specifiers, the\\n     *         extra arguments are ignored.  The number of arguments is\\n     *         variable and may be zero.  The maximum number of arguments is\\n     *         limited by the maximum dimension of a Java array as defined by\\n     *         \u003ccite\u003eThe Java\u0026trade; Virtual Machine Specification\u003c/cite\u003e.\\n     *         The behaviour on a\\n     *         {@code null} argument depends on the \u003ca\\n     *         href=\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\\n     *\\n     * @throws  java.util.IllegalFormatException\\n     *          If a format string contains an illegal syntax, a format\\n     *          specifier that is incompatible with the given arguments,\\n     *          insufficient arguments given the format string, or other\\n     *          illegal conditions.  For specification of all possible\\n     *          formatting errors, see the \u003ca\\n     *          href=\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\\n     *          formatter class specification.\\n     *\\n     * @throws  NullPointerException\\n     *          If the {@code format} is {@code null}\\n     *\\n     * @return  This writer\\n     *\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public PrintWriter printf(Locale l, String format, Object... args)", "label": "public PrintWriter printf(Locale l, String format, Object... args)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * A convenience method to write a formatted string to this writer using\\n     * the specified format string and arguments.  If automatic flushing is\\n     * enabled, calls to this method will flush the output buffer.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form\\n     * {@code out.printf(l, format, args)}\\n     * behaves in exactly the same way as the invocation\\n     *\\n     * \u003cpre\u003e{@code\\n     *     out.format(l, format, args)\\n     * }\u003c/pre\u003e\\n     *\\n     * @param  l\\n     *         The {@linkplain java.util.Locale locale} to apply during\\n     *         formatting.  If {@code l} is {@code null} then no localization\\n     *         is applied.\\n     *\\n     * @param  format\\n     *         A format string as described in \u003ca\\n     *         href=\"../util/Formatter.html#syntax\"\u003eFormat string syntax\u003c/a\u003e.\\n     *\\n     * @param  args\\n     *         Arguments referenced by the format specifiers in the format\\n     *         string.  If there are more arguments than format specifiers, the\\n     *         extra arguments are ignored.  The number of arguments is\\n     *         variable and may be zero.  The maximum number of arguments is\\n     *         limited by the maximum dimension of a Java array as defined by\\n     *         \u003ccite\u003eThe Java\u0026trade; Virtual Machine Specification\u003c/cite\u003e.\\n     *         The behaviour on a\\n     *         {@code null} argument depends on the \u003ca\\n     *         href=\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\\n     *\\n     * @throws  java.util.IllegalFormatException\\n     *          If a format string contains an illegal syntax, a format\\n     *          specifier that is incompatible with the given arguments,\\n     *          insufficient arguments given the format string, or other\\n     *          illegal conditions.  For specification of all possible\\n     *          formatting errors, see the \u003ca\\n     *          href=\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\\n     *          formatter class specification.\\n     *\\n     * @throws  NullPointerException\\n     *          If the {@code format} is {@code null}\\n     *\\n     * @return  This writer\\n     *\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public PrintWriter format(String format, Object... args)", "label": "public PrintWriter format(String format, Object... args)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes a formatted string to this writer using the specified format\\n     * string and arguments.  If automatic flushing is enabled, calls to this\\n     * method will flush the output buffer.\\n     *\\n     * \u003cp\u003e The locale always used is the one returned by {@link\\n     * java.util.Locale#getDefault() Locale.getDefault()}, regardless of any\\n     * previous invocations of other formatting methods on this object.\\n     *\\n     * @param  format\\n     *         A format string as described in \u003ca\\n     *         href=\"../util/Formatter.html#syntax\"\u003eFormat string syntax\u003c/a\u003e.\\n     *\\n     * @param  args\\n     *         Arguments referenced by the format specifiers in the format\\n     *         string.  If there are more arguments than format specifiers, the\\n     *         extra arguments are ignored.  The number of arguments is\\n     *         variable and may be zero.  The maximum number of arguments is\\n     *         limited by the maximum dimension of a Java array as defined by\\n     *         \u003ccite\u003eThe Java\u0026trade; Virtual Machine Specification\u003c/cite\u003e.\\n     *         The behaviour on a\\n     *         {@code null} argument depends on the \u003ca\\n     *         href=\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\\n     *\\n     * @throws  java.util.IllegalFormatException\\n     *          If a format string contains an illegal syntax, a format\\n     *          specifier that is incompatible with the given arguments,\\n     *          insufficient arguments given the format string, or other\\n     *          illegal conditions.  For specification of all possible\\n     *          formatting errors, see the \u003ca\\n     *          href=\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\\n     *          Formatter class specification.\\n     *\\n     * @throws  NullPointerException\\n     *          If the {@code format} is {@code null}\\n     *\\n     * @return  This writer\\n     *\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "getDefault()", "label": "getDefault()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public PrintWriter format(Locale l, String format, Object... args)", "label": "public PrintWriter format(Locale l, String format, Object... args)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes a formatted string to this writer using the specified format\\n     * string and arguments.  If automatic flushing is enabled, calls to this\\n     * method will flush the output buffer.\\n     *\\n     * @param  l\\n     *         The {@linkplain java.util.Locale locale} to apply during\\n     *         formatting.  If {@code l} is {@code null} then no localization\\n     *         is applied.\\n     *\\n     * @param  format\\n     *         A format string as described in \u003ca\\n     *         href=\"../util/Formatter.html#syntax\"\u003eFormat string syntax\u003c/a\u003e.\\n     *\\n     * @param  args\\n     *         Arguments referenced by the format specifiers in the format\\n     *         string.  If there are more arguments than format specifiers, the\\n     *         extra arguments are ignored.  The number of arguments is\\n     *         variable and may be zero.  The maximum number of arguments is\\n     *         limited by the maximum dimension of a Java array as defined by\\n     *         \u003ccite\u003eThe Java\u0026trade; Virtual Machine Specification\u003c/cite\u003e.\\n     *         The behaviour on a\\n     *         {@code null} argument depends on the \u003ca\\n     *         href=\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\\n     *\\n     * @throws  java.util.IllegalFormatException\\n     *          If a format string contains an illegal syntax, a format\\n     *          specifier that is incompatible with the given arguments,\\n     *          insufficient arguments given the format string, or other\\n     *          illegal conditions.  For specification of all possible\\n     *          formatting errors, see the \u003ca\\n     *          href=\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\\n     *          formatter class specification.\\n     *\\n     * @throws  NullPointerException\\n     *          If the {@code format} is {@code null}\\n     *\\n     * @return  This writer\\n     *\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public PrintWriter append(CharSequence csq)", "label": "public PrintWriter append(CharSequence csq)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Appends the specified character sequence to this writer.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form {@code out.append(csq)}\\n     * behaves in exactly the same way as the invocation\\n     *\\n     * \u003cpre\u003e{@code\\n     *     out.write(csq.toString())\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003e Depending on the specification of {@code toString} for the\\n     * character sequence {@code csq}, the entire sequence may not be\\n     * appended. For instance, invoking the {@code toString} method of a\\n     * character buffer will return a subsequence whose content depends upon\\n     * the buffer\\\u0027s position and limit.\\n     *\\n     * @param  csq\\n     *         The character sequence to append.  If {@code csq} is\\n     *         {@code null}, then the four characters {@code \"null\"} are\\n     *         appended to this writer.\\n     *\\n     * @return  This writer\\n     *\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public PrintWriter append(CharSequence csq, int start, int end)", "label": "public PrintWriter append(CharSequence csq, int start, int end)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Appends a subsequence of the specified character sequence to this writer.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form\\n     * {@code out.append(csq, start, end)}\\n     * when {@code csq} is not {@code null}, behaves in\\n     * exactly the same way as the invocation\\n     *\\n     * \u003cpre\u003e{@code\\n     *     out.write(csq.subSequence(start, end).toString())\\n     * }\u003c/pre\u003e\\n     *\\n     * @param  csq\\n     *         The character sequence from which a subsequence will be\\n     *         appended.  If {@code csq} is {@code null}, then characters\\n     *         will be appended as if {@code csq} contained the four\\n     *         characters {@code \"null\"}.\\n     *\\n     * @param  start\\n     *         The index of the first character in the subsequence\\n     *\\n     * @param  end\\n     *         The index of the character following the last character in the\\n     *         subsequence\\n     *\\n     * @return  This writer\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If {@code start} or {@code end} are negative, {@code start}\\n     *          is greater than {@code end}, or {@code end} is greater than\\n     *          {@code csq.length()}\\n     *\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public PrintWriter append(char c)", "label": "public PrintWriter append(char c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Appends the specified character to this writer.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form {@code out.append(c)}\\n     * behaves in exactly the same way as the invocation\\n     *\\n     * \u003cpre\u003e{@code\\n     *     out.write(c)\\n     * }\u003c/pre\u003e\\n     *\\n     * @param  c\\n     *         The 16-bit character to append\\n     *\\n     * @return  This writer\\n     *\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Reader reader()", "label": "public Reader reader()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n    * Retrieves the unique {@link java.io.Reader Reader} object associated\\n    * with this console.\\n    * \u003cp\u003e\\n    * This method is intended to be used by sophisticated applications, for\\n    * example, a {@link java.util.Scanner} object which utilizes the rich\\n    * parsing/scanning functionality provided by the {@code Scanner}:\\n    * \u003cblockquote\u003e\u003cpre\u003e\\n    * Console con = System.console();\\n    * if (con != null) {\\n    *     Scanner sc = new Scanner(con.reader());\\n    *     ...\\n    * }\\n    * \u003c/pre\u003e\u003c/blockquote\u003e\\n    * \u003cp\u003e\\n    * For simple applications requiring only line-oriented reading, use\\n    * {@link #readLine}.\\n    * \u003cp\u003e\\n    * The bulk read operations {@link java.io.Reader#read(char[]) read(char[]) },\\n    * {@link java.io.Reader#read(char[], int, int) read(char[], int, int) } and\\n    * {@link java.io.Reader#read(java.nio.CharBuffer) read(java.nio.CharBuffer)}\\n    * on the returned object will not read in characters beyond the line\\n    * bound for each invocation, even if the destination buffer has space for\\n    * more characters. The {@code Reader}\u0027s {@code read} methods may block if a\\n    * line bound has not been entered or reached on the console\u0027s input device.\\n    * A line bound is considered to be any one of a line feed ({@code \u0027\\\\n\u0027}),\\n    * a carriage return ({@code \u0027\\\\r\u0027}), a carriage return followed immediately\\n    * by a linefeed, or an end of stream.\\n    *\\n    * @return  The reader associated with this console\\n    \"}"}, {"color": "#97c2fc", "id": "read(char", "label": "read(char", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.io.Reader", "label": "java.io.Reader", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public static Reader nullReader()", "label": "public static Reader nullReader()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a new {@code Reader} that reads no characters. The returned\\n     * stream is initially open.  The stream is closed by calling the\\n     * {@code close()} method.  Subsequent calls to {@code close()} have no\\n     * effect.\\n     *\\n     * \u003cp\u003e While the stream is open, the {@code read()}, {@code read(char[])},\\n     * {@code read(char[], int, int)}, {@code read(Charbuffer)}, {@code\\n     * ready()}, {@code skip(long)}, and {@code transferTo()} methods all\\n     * behave as if end of stream has been reached. After the stream has been\\n     * closed, these methods all throw {@code IOException}.\\n     *\\n     * \u003cp\u003e The {@code markSupported()} method returns {@code false}.  The\\n     * {@code mark()} and {@code reset()} methods throw an {@code IOException}.\\n     *\\n     * \u003cp\u003e The {@link #lock object} used to synchronize operations on the\\n     * returned {@code Reader} is not specified.\\n     *\\n     * @return a {@code Reader} which reads no characters\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "lock", "label": "lock", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public int read(java.nio.CharBuffer target) throws IOException", "label": "public int read(java.nio.CharBuffer target) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Attempts to read characters into the specified character buffer.\\n     * The buffer is used as a repository of characters as-is: the only\\n     * changes made are the results of a put operation. No flipping or\\n     * rewinding of the buffer is performed.\\n     *\\n     * @param target the buffer to read characters into\\n     * @return The number of characters added to the buffer, or\\n     *         -1 if this source of characters is at its end\\n     * @throws IOException if an I/O error occurs\\n     * @throws NullPointerException if target is null\\n     * @throws java.nio.ReadOnlyBufferException if target is a read only buffer\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int read() throws IOException", "label": "public int read() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads a byte of data. This method will block if no input is available.\\n     *\\n     * @return  the byte read, or -1 if the end of the stream is reached.\\n     * @throws  IOException If an I/O error has occurred.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int read(char[] cbuf) throws IOException", "label": "public int read(char[] cbuf) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads characters into an array.  This method will block until some input\\n     * is available, an I/O error occurs, or the end of the stream is reached.\\n     *\\n     * @param       cbuf  Destination buffer\\n     *\\n     * @return      The number of characters read, or -1\\n     *              if the end of the stream\\n     *              has been reached\\n     *\\n     * @exception   IOException  If an I/O error occurs\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract int read(char[] cbuf, int off, int len) throws IOException", "label": "public abstract int read(char[] cbuf, int off, int len) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads characters into a portion of an array.  This method will block\\n     * until some input is available, an I/O error occurs, or the end of the\\n     * stream is reached.\\n     *\\n     * @param      cbuf  Destination buffer\\n     * @param      off   Offset at which to start storing characters\\n     * @param      len   Maximum number of characters to read\\n     *\\n     * @return     The number of characters read, or -1 if the end of the\\n     *             stream has been reached\\n     *\\n     * @exception  IOException  If an I/O error occurs\\n     * @exception  IndexOutOfBoundsException\\n     *             If {@code off} is negative, or {@code len} is negative,\\n     *             or {@code len} is greater than {@code cbuf.length - off}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public long skip(long n) throws IOException", "label": "public long skip(long n) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Skips characters.\\n     *\\n     * @param  n  The number of characters to skip\\n     *\\n     * @return    The number of characters actually skipped\\n     *\\n     * @exception  IllegalArgumentException  If \u003ccode\u003en\u003c/code\u003e is negative.\\n     * @exception  IOException  If an I/O error occurs\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean ready() throws IOException", "label": "public boolean ready() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether this stream is ready to be read.  A buffered character\\n     * stream is ready if the buffer is not empty, or if the underlying\\n     * character stream is ready.\\n     *\\n     * @exception  IOException  If an I/O error occurs\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean markSupported()", "label": "public boolean markSupported()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether this stream supports the mark() operation, which it does.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void mark(int readAheadLimit) throws IOException", "label": "public void mark(int readAheadLimit) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Marks the present position in the stream.  Subsequent calls to reset()\\n     * will attempt to reposition the stream to this point.\\n     *\\n     * @param readAheadLimit   Limit on the number of characters that may be\\n     *                         read while still preserving the mark. An attempt\\n     *                         to reset the stream after reading characters\\n     *                         up to this limit or beyond may fail.\\n     *                         A limit value larger than the size of the input\\n     *                         buffer will cause a new buffer to be allocated\\n     *                         whose size is no smaller than limit.\\n     *                         Therefore large values should be used with care.\\n     *\\n     * @exception  IllegalArgumentException  If {@code readAheadLimit \u003c 0}\\n     * @exception  IOException  If an I/O error occurs\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void reset() throws IOException", "label": "public void reset() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reset will disregard the state of any objects already written to the\\n     * stream.  The state is reset to be the same as a new ObjectOutputStream.\\n     * The current point in the stream is marked as reset so the corresponding\\n     * ObjectInputStream will be reset at the same point.  Objects previously\\n     * written to the stream will not be referred to as already being in the\\n     * stream.  They will be written to the stream again.\\n     *\\n     * @throws  IOException if reset() is invoked while serializing an object.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract void close() throws IOException", "label": "public abstract void close() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Closes this file system.\\n     *\\n     * \u003cp\u003e After a file system is closed then all subsequent access to the file\\n     * system, either by methods defined by this class or on objects associated\\n     * with this file system, throw {@link ClosedFileSystemException}. If the\\n     * file system is already closed then invoking this method has no effect.\\n     *\\n     * \u003cp\u003e Closing a file system will close all open {@link\\n     * java.nio.channels.Channel channels}, {@link DirectoryStream directory-streams},\\n     * {@link WatchService watch-service}, and other closeable objects associated\\n     * with this file system. The {@link FileSystems#getDefault default} file\\n     * system cannot be closed.\\n     *\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     * @throws  UnsupportedOperationException\\n     *          Thrown in the case of the default file system\\n     \u0027}"}, {"color": "#97c2fc", "id": "public long transferTo(Writer out) throws IOException", "label": "public long transferTo(Writer out) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads all characters from this reader and writes the characters to the\\n     * given writer in the order that they are read. On return, this reader\\n     * will be at end of the stream. This method does not close either reader\\n     * or writer.\\n     * \u003cp\u003e\\n     * This method may block indefinitely reading from the reader, or\\n     * writing to the writer. The behavior for the case where the reader\\n     * and/or writer is \u003ci\u003easynchronously closed\u003c/i\u003e, or the thread\\n     * interrupted during the transfer, is highly reader and writer\\n     * specific, and therefore not specified.\\n     * \u003cp\u003e\\n     * If an I/O error occurs reading from the reader or writing to the\\n     * writer, then it may do so after some characters have been read or\\n     * written. Consequently the reader may not be at end of the stream and\\n     * one, or both, streams may be in an inconsistent state. It is strongly\\n     * recommended that both streams be promptly closed if an I/O error occurs.\\n     *\\n     * @param  out the writer, non-null\\n     * @return the number of characters transferred\\n     * @throws IOException if an I/O error occurs when reading or writing\\n     * @throws NullPointerException if {@code out} is {@code null}\\n     *\\n     * @since 10\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.util.Scanner", "label": "java.util.Scanner", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "readLine", "label": "readLine", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public Console format(String fmt, Object... args)", "label": "public Console format(String fmt, Object... args)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    * Writes a formatted string to this console\\\u0027s output stream using\\n    * the specified format string and arguments.\\n    *\\n    * @param  fmt\\n    *         A format string as described in \u003ca\\n    *         href=\"../util/Formatter.html#syntax\"\u003eFormat string syntax\u003c/a\u003e\\n    *\\n    * @param  args\\n    *         Arguments referenced by the format specifiers in the format\\n    *         string.  If there are more arguments than format specifiers, the\\n    *         extra arguments are ignored.  The number of arguments is\\n    *         variable and may be zero.  The maximum number of arguments is\\n    *         limited by the maximum dimension of a Java array as defined by\\n    *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\\n    *         The behaviour on a\\n    *         {@code null} argument depends on the \u003ca\\n    *         href=\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\\n    *\\n    * @throws  IllegalFormatException\\n    *          If a format string contains an illegal syntax, a format\\n    *          specifier that is incompatible with the given arguments,\\n    *          insufficient arguments given the format string, or other\\n    *          illegal conditions.  For specification of all possible\\n    *          formatting errors, see the \u003ca\\n    *          href=\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section\\n    *          of the formatter class specification.\\n    *\\n    * @return  This console\\n    \u0027}"}, {"color": "#97c2fc", "id": "public Console printf(String format, Object... args)", "label": "public Console printf(String format, Object... args)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    * A convenience method to write a formatted string to this console\\\u0027s\\n    * output stream using the specified format string and arguments.\\n    *\\n    * \u003cp\u003e An invocation of this method of the form\\n    * {@code con.printf(format, args)} behaves in exactly the same way\\n    * as the invocation of\\n    * \u003cpre\u003econ.format(format, args)\u003c/pre\u003e.\\n    *\\n    * @param  format\\n    *         A format string as described in \u003ca\\n    *         href=\"../util/Formatter.html#syntax\"\u003eFormat string syntax\u003c/a\u003e.\\n    *\\n    * @param  args\\n    *         Arguments referenced by the format specifiers in the format\\n    *         string.  If there are more arguments than format specifiers, the\\n    *         extra arguments are ignored.  The number of arguments is\\n    *         variable and may be zero.  The maximum number of arguments is\\n    *         limited by the maximum dimension of a Java array as defined by\\n    *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\\n    *         The behaviour on a\\n    *         {@code null} argument depends on the \u003ca\\n    *         href=\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\\n    *\\n    * @throws  IllegalFormatException\\n    *          If a format string contains an illegal syntax, a format\\n    *          specifier that is incompatible with the given arguments,\\n    *          insufficient arguments given the format string, or other\\n    *          illegal conditions.  For specification of all possible\\n    *          formatting errors, see the \u003ca\\n    *          href=\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\\n    *          formatter class specification.\\n    *\\n    * @return  This console\\n    \u0027}"}, {"color": "#97c2fc", "id": "public String readLine(String fmt, Object... args)", "label": "public String readLine(String fmt, Object... args)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    * Provides a formatted prompt, then reads a single line of text from the\\n    * console.\\n    *\\n    * @param  fmt\\n    *         A format string as described in \u003ca\\n    *         href=\"../util/Formatter.html#syntax\"\u003eFormat string syntax\u003c/a\u003e.\\n    *\\n    * @param  args\\n    *         Arguments referenced by the format specifiers in the format\\n    *         string.  If there are more arguments than format specifiers, the\\n    *         extra arguments are ignored.  The maximum number of arguments is\\n    *         limited by the maximum dimension of a Java array as defined by\\n    *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\\n    *\\n    * @throws  IllegalFormatException\\n    *          If a format string contains an illegal syntax, a format\\n    *          specifier that is incompatible with the given arguments,\\n    *          insufficient arguments given the format string, or other\\n    *          illegal conditions.  For specification of all possible\\n    *          formatting errors, see the \u003ca\\n    *          href=\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section\\n    *          of the formatter class specification.\\n    *\\n    * @throws IOError\\n    *         If an I/O error occurs.\\n    *\\n    * @return  A string containing the line read from the console, not\\n    *          including any line-termination characters, or {@code null}\\n    *          if an end of stream has been reached.\\n    \u0027}"}, {"color": "#97c2fc", "id": "public String readLine()", "label": "public String readLine()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    * Reads a single line of text from the console.\\n    *\\n    * @throws IOError\\n    *         If an I/O error occurs.\\n    *\\n    * @return  A string containing the line read from the console, not\\n    *          including any line-termination characters, or {@code null}\\n    *          if an end of stream has been reached.\\n    \u0027}"}, {"color": "#97c2fc", "id": "public char[] readPassword(String fmt, Object... args)", "label": "public char[] readPassword(String fmt, Object... args)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    * Provides a formatted prompt, then reads a password or passphrase from\\n    * the console with echoing disabled.\\n    *\\n    * @param  fmt\\n    *         A format string as described in \u003ca\\n    *         href=\"../util/Formatter.html#syntax\"\u003eFormat string syntax\u003c/a\u003e\\n    *         for the prompt text.\\n    *\\n    * @param  args\\n    *         Arguments referenced by the format specifiers in the format\\n    *         string.  If there are more arguments than format specifiers, the\\n    *         extra arguments are ignored.  The maximum number of arguments is\\n    *         limited by the maximum dimension of a Java array as defined by\\n    *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\\n    *\\n    * @throws  IllegalFormatException\\n    *          If a format string contains an illegal syntax, a format\\n    *          specifier that is incompatible with the given arguments,\\n    *          insufficient arguments given the format string, or other\\n    *          illegal conditions.  For specification of all possible\\n    *          formatting errors, see the \u003ca\\n    *          href=\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e\\n    *          section of the formatter class specification.\\n    *\\n    * @throws IOError\\n    *         If an I/O error occurs.\\n    *\\n    * @return  A character array containing the password or passphrase read\\n    *          from the console, not including any line-termination characters,\\n    *          or {@code null} if an end of stream has been reached.\\n    \u0027}"}, {"color": "#97c2fc", "id": "public char[] readPassword()", "label": "public char[] readPassword()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    * Reads a password or passphrase from the console with echoing disabled\\n    *\\n    * @throws IOError\\n    *         If an I/O error occurs.\\n    *\\n    * @return  A character array containing the password or passphrase read\\n    *          from the console, not including any line-termination characters,\\n    *          or {@code null} if an end of stream has been reached.\\n    \u0027}"}, {"color": "#97c2fc", "id": "public Charset charset()", "label": "public Charset charset()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the {@link java.nio.charset.Charset Charset} object used for\\n     * the {@code Console}.\\n     * \u003cp\u003e\\n     * The returned charset corresponds to the input and output source\\n     * (e.g., keyboard and/or display) specified by the host environment or user.\\n     * It may not necessarily be the same as the default charset returned from\\n     * {@link java.nio.charset.Charset#defaultCharset() Charset.defaultCharset()}.\\n     *\\n     * @return a {@link java.nio.charset.Charset Charset} object used for the\\n     *          {@code Console}\\n     * @since 17\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.nio.charset.Charset", "label": "java.nio.charset.Charset", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "private static void checkName(String s)", "label": "private static void checkName(String s)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Checks that the given string is a legal charset name. \u003c/p\u003e\\n     *\\n     * @param  s\\n     *         A purported charset name\\n     *\\n     * @throws  IllegalCharsetNameException\\n     *          If the given name is not a legal charset name\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static Charset lookup(String charsetName)", "label": "private static Charset lookup(String charsetName)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 instance in a map for level 2 cache.\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isSupported(String charsetName)", "label": "public static boolean isSupported(String charsetName)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether the named charset is supported.\\n     *\\n     * @param  charsetName\\n     *         The name of the requested charset; may be either\\n     *         a canonical name or an alias\\n     *\\n     * @return  {@code true} if, and only if, support for the named charset\\n     *          is available in the current Java virtual machine\\n     *\\n     * @throws IllegalCharsetNameException\\n     *         If the given charset name is illegal\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the given {@code charsetName} is null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Charset forName(String charsetName)", "label": "public static Charset forName(String charsetName)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a charset object for the named charset.\\n     *\\n     * @param  charsetName\\n     *         The name of the requested charset; may be either\\n     *         a canonical name or an alias\\n     *\\n     * @return  A charset object for the named charset\\n     *\\n     * @throws  IllegalCharsetNameException\\n     *          If the given charset name is illegal\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the given {@code charsetName} is null\\n     *\\n     * @throws  UnsupportedCharsetException\\n     *          If no support for the named charset is available\\n     *          in this instance of the Java virtual machine\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static SortedMap\u003cString, Charset\u003e availableCharsets()", "label": "public static SortedMap\u003cString, Charset\u003e availableCharsets()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Constructs a sorted map from canonical charset names to charset objects.\\n     *\\n     * \u003cp\u003e The map returned by this method will have one entry for each charset\\n     * for which support is available in the current Java virtual machine.  If\\n     * two or more supported charsets have the same canonical name then the\\n     * resulting map will contain just one of them; which one it will contain\\n     * is not specified. \u003c/p\u003e\\n     *\\n     * \u003cp\u003e The invocation of this method, and the subsequent use of the\\n     * resulting map, may cause time-consuming disk or network I/O operations\\n     * to occur.  This method is provided for applications that need to\\n     * enumerate all of the available charsets, for example to allow user\\n     * charset selection.  This method is not used by the {@link #forName\\n     * forName} method, which instead employs an efficient incremental lookup\\n     * algorithm.\\n     *\\n     * \u003cp\u003e This method may return different results at different times if new\\n     * charset providers are dynamically made available to the current Java\\n     * virtual machine.  In the absence of such changes, the charsets returned\\n     * by this method are exactly those that can be retrieved via the {@link\\n     * #forName forName} method.  \u003c/p\u003e\\n     *\\n     * @return An immutable, case-insensitive map from canonical charset names\\n     *         to charset objects\\n     \u0027}"}, {"color": "#97c2fc", "id": "forNameforName", "label": "forNameforName", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "forName", "label": "forName", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static Charset defaultCharset()", "label": "public static Charset defaultCharset()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the default charset of this Java virtual machine.\\n     *\\n     * \u003cp\u003eAndroid note: The Android platform default is always UTF-8.\\n     *\\n     * @return  A charset object for the default charset\\n     *\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final String name()", "label": "public final String name()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns this charset\u0027s canonical name.\\n     *\\n     * @return  The canonical name of this charset\\n     \"}"}, {"color": "#97c2fc", "id": "public final Set\u003cString\u003e aliases()", "label": "public final Set\u003cString\u003e aliases()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a set containing this charset\u0027s aliases.\\n     *\\n     * @return  An immutable set of this charset\u0027s aliases\\n     \"}"}, {"color": "#97c2fc", "id": "public String displayName()", "label": "public String displayName()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns this charset\u0027s human-readable name for the default locale.\\n     *\\n     * \u003cp\u003e The default implementation of this method simply returns this\\n     * charset\u0027s canonical name.  Concrete subclasses of this class may\\n     * override this method in order to provide a localized display name. \u003c/p\u003e\\n     *\\n     * @return  The display name of this charset in the default locale\\n     \"}"}, {"color": "#97c2fc", "id": "public final boolean isRegistered()", "label": "public final boolean isRegistered()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this charset is registered in the \u003ca\\n     * href=\"http://www.iana.org/assignments/character-sets\"\u003eIANA Charset\\n     * Registry\u003c/a\u003e.\\n     *\\n     * @return  {@code true} if, and only if, this charset is known by its\\n     *          implementor to be registered with the IANA\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String displayName(Locale locale)", "label": "public String displayName(Locale locale)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns this charset\u0027s human-readable name for the given locale.\\n     *\\n     * \u003cp\u003e The default implementation of this method simply returns this\\n     * charset\u0027s canonical name.  Concrete subclasses of this class may\\n     * override this method in order to provide a localized display name. \u003c/p\u003e\\n     *\\n     * @param  locale\\n     *         The locale for which the display name is to be retrieved\\n     *\\n     * @return  The display name of this charset in the given locale\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract boolean contains(Charset cs)", "label": "public abstract boolean contains(Charset cs)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this charset contains the given charset.\\n     *\\n     * \u003cp\u003e A charset \u003ci\u003eC\u003c/i\u003e is said to \u003ci\u003econtain\u003c/i\u003e a charset \u003ci\u003eD\u003c/i\u003e if,\\n     * and only if, every character representable in \u003ci\u003eD\u003c/i\u003e is also\\n     * representable in \u003ci\u003eC\u003c/i\u003e.  If this relationship holds then it is\\n     * guaranteed that every string that can be encoded in \u003ci\u003eD\u003c/i\u003e can also be\\n     * encoded in \u003ci\u003eC\u003c/i\u003e without performing any replacements.\\n     *\\n     * \u003cp\u003e That \u003ci\u003eC\u003c/i\u003e contains \u003ci\u003eD\u003c/i\u003e does not imply that each character\\n     * representable in \u003ci\u003eC\u003c/i\u003e by a particular byte sequence is represented\\n     * in \u003ci\u003eD\u003c/i\u003e by the same byte sequence, although sometimes this is the\\n     * case.\\n     *\\n     * \u003cp\u003e Every charset contains itself.\\n     *\\n     * \u003cp\u003e This method computes an approximation of the containment relation:\\n     * If it returns {@code true} then the given charset is known to be\\n     * contained by this charset; if it returns {@code false}, however, then\\n     * it is not necessarily the case that the given charset is not contained\\n     * in this charset.\\n     *\\n     * @param   cs\\n     *          The given charset\\n     *\\n     * @return  {@code true} if the given charset is contained in this charset\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract CharsetDecoder newDecoder()", "label": "public abstract CharsetDecoder newDecoder()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Constructs a new decoder for this charset.\\n     *\\n     * @return  A new decoder for this charset\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract CharsetEncoder newEncoder()", "label": "public abstract CharsetEncoder newEncoder()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Constructs a new encoder for this charset.\\n     *\\n     * @return  A new encoder for this charset\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          If this charset does not support encoding\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean canEncode()", "label": "public boolean canEncode()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this charset supports encoding.\\n     *\\n     * \u003cp\u003e Nearly all charsets support encoding.  The primary exceptions are\\n     * special-purpose \u003ci\u003eauto-detect\u003c/i\u003e charsets whose decoders can determine\\n     * which of several possible encoding schemes is in use by examining the\\n     * input byte sequence.  Such charsets do not support encoding because\\n     * there is no way to determine which encoding should be used on output.\\n     * Implementations of such charsets should override this method to return\\n     * {@code false}. \u003c/p\u003e\\n     *\\n     * @return  {@code true} if, and only if, this charset supports encoding\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final CharBuffer decode(ByteBuffer bb)", "label": "public final CharBuffer decode(ByteBuffer bb)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Convenience method that decodes bytes in this charset into Unicode\\n     * characters.\\n     *\\n     * \u003cp\u003e An invocation of this method upon a charset {@code cs} returns the\\n     * same result as the expression\\n     *\\n     * \u003cpre\u003e\\n     *     cs.newDecoder()\\n     *       .onMalformedInput(CodingErrorAction.REPLACE)\\n     *       .onUnmappableCharacter(CodingErrorAction.REPLACE)\\n     *       .decode(bb); \u003c/pre\u003e\\n     *\\n     * except that it is potentially more efficient because it can cache\\n     * decoders between successive invocations.\\n     *\\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\\n     * sequences with this charset\u0027s default replacement byte array.  In order\\n     * to detect such sequences, use the {@link\\n     * CharsetDecoder#decode(java.nio.ByteBuffer)} method directly.  \u003c/p\u003e\\n     *\\n     * @param  bb  The byte buffer to be decoded\\n     *\\n     * @return  A char buffer containing the decoded characters\\n     \"}"}, {"color": "#97c2fc", "id": "decode(java.nio.ByteBuffer)", "label": "decode(java.nio.ByteBuffer)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.charset.CharsetDecoder", "label": "java.nio.charset.CharsetDecoder", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public final String replacement()", "label": "public final String replacement()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns this decoder\u0027s replacement value.\\n     *\\n     * @return  This decoder\u0027s current replacement,\\n     *          which is never {@code null} and is never empty\\n     \"}"}, {"color": "#97c2fc", "id": "public final CharsetDecoder replaceWith(String newReplacement)", "label": "public final CharsetDecoder replaceWith(String newReplacement)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Changes this decoder\u0027s replacement value.\\n     *\\n     * \u003cp\u003e This method invokes the {@link #implReplaceWith implReplaceWith}\\n     * method, passing the new replacement, after checking that the new\\n     * replacement is acceptable.  \u003c/p\u003e\\n     *\\n     * @param  newReplacement  The new replacement; must not be\\n     *         {@code null}, must have non-zero length,\\n\\n     *         and must not be longer than the value returned by the\\n     *         {@link #maxCharsPerByte() maxCharsPerByte} method\\n\\n\\n\\n\\n\\n\\n     *\\n     * @return  This decoder\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the preconditions on the parameter do not hold\\n     \"}"}, {"color": "#97c2fc", "id": "maxCharsPerByte()", "label": "maxCharsPerByte()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "protected void implReplaceWith(String newReplacement)", "label": "protected void implReplaceWith(String newReplacement)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reports a change to this decoder\u0027s replacement value.\\n     *\\n     * \u003cp\u003e The default implementation of this method does nothing.  This method\\n     * should be overridden by decoders that require notification of changes to\\n     * the replacement.  \u003c/p\u003e\\n     *\\n     * @param  newReplacement    The replacement value\\n     \"}"}, {"color": "#97c2fc", "id": "public final CharsetDecoder onMalformedInput(CodingErrorAction newAction)", "label": "public final CharsetDecoder onMalformedInput(CodingErrorAction newAction)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Changes this decoder\u0027s action for malformed-input errors.\\n     *\\n     * \u003cp\u003e This method invokes the {@link #implOnMalformedInput\\n     * implOnMalformedInput} method, passing the new action.  \u003c/p\u003e\\n     *\\n     * @param  newAction  The new action; must not be {@code null}\\n     *\\n     * @return  This decoder\\n     *\\n     * @throws IllegalArgumentException\\n     *         If the precondition on the parameter does not hold\\n     \"}"}, {"color": "#97c2fc", "id": "public final CharsetDecoder onUnmappableCharacter(CodingErrorAction newAction)", "label": "public final CharsetDecoder onUnmappableCharacter(CodingErrorAction newAction)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Changes this decoder\u0027s action for unmappable-character errors.\\n     *\\n     * \u003cp\u003e This method invokes the {@link #implOnUnmappableCharacter\\n     * implOnUnmappableCharacter} method, passing the new action.  \u003c/p\u003e\\n     *\\n     * @param  newAction  The new action; must not be {@code null}\\n     *\\n     * @return  This decoder\\n     *\\n     * @throws IllegalArgumentException\\n     *         If the precondition on the parameter does not hold\\n     \"}"}, {"color": "#97c2fc", "id": "public final float averageCharsPerByte()", "label": "public final float averageCharsPerByte()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the average number of characters that will be produced for each\\n     * byte of input.  This heuristic value may be used to estimate the size\\n     * of the output buffer required for a given input sequence.\\n     *\\n     * @return  The average number of characters produced\\n     *          per byte of input\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final float maxCharsPerByte()", "label": "public final float maxCharsPerByte()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the maximum number of characters that will be produced for each\\n     * byte of input.  This value may be used to compute the worst-case size\\n     * of the output buffer required for a given input sequence. This value\\n     * accounts for any necessary content-independent prefix or suffix\\n\\n\\n\\n\\n     * characters.\\n\\n     *\\n     * @return  The maximum number of characters that will be produced per\\n     *          byte of input\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final CoderResult decode(ByteBuffer in, CharBuffer out, boolean endOfInput)", "label": "public final CoderResult decode(ByteBuffer in, CharBuffer out, boolean endOfInput)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Decodes as many bytes as possible from the given input buffer,\\n     * writing the results to the given output buffer.\\n     *\\n     * \u003cp\u003e The buffers are read from, and written to, starting at their current\\n     * positions.  At most {@link Buffer#remaining in.remaining()} bytes\\n     * will be read and at most {@link Buffer#remaining out.remaining()}\\n     * characters will be written.  The buffers\\\u0027 positions will be advanced to\\n     * reflect the bytes read and the characters written, but their marks and\\n     * limits will not be modified.\\n     *\\n     * \u003cp\u003e In addition to reading bytes from the input buffer and writing\\n     * characters to the output buffer, this method returns a {@link CoderResult}\\n     * object to describe its reason for termination:\\n     *\\n     * \u003cul\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e {@link CoderResult#UNDERFLOW} indicates that as much of the\\n     *   input buffer as possible has been decoded.  If there is no further\\n     *   input then the invoker can proceed to the next step of the\\n     *   \u003ca href=\"#steps\"\u003edecoding operation\u003c/a\u003e.  Otherwise this method\\n     *   should be invoked again with further input.  \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e {@link CoderResult#OVERFLOW} indicates that there is\\n     *   insufficient space in the output buffer to decode any more bytes.\\n     *   This method should be invoked again with an output buffer that has\\n     *   more {@linkplain Buffer#remaining remaining} characters. This is\\n     *   typically done by draining any decoded characters from the output\\n     *   buffer.  \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e A {@linkplain CoderResult#malformedForLength\\n     *   malformed-input} result indicates that a malformed-input\\n     *   error has been detected.  The malformed bytes begin at the input\\n     *   buffer\\\u0027s (possibly incremented) position; the number of malformed\\n     *   bytes may be determined by invoking the result object\\\u0027s {@link\\n     *   CoderResult#length() length} method.  This case applies only if the\\n     *   {@linkplain #onMalformedInput malformed action} of this decoder\\n     *   is {@link CodingErrorAction#REPORT}; otherwise the malformed input\\n     *   will be ignored or replaced, as requested.  \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e An {@linkplain CoderResult#unmappableForLength\\n     *   unmappable-character} result indicates that an\\n     *   unmappable-character error has been detected.  The bytes that\\n     *   decode the unmappable character begin at the input buffer\\\u0027s (possibly\\n     *   incremented) position; the number of such bytes may be determined\\n     *   by invoking the result object\\\u0027s {@link CoderResult#length() length}\\n     *   method.  This case applies only if the {@linkplain #onUnmappableCharacter\\n     *   unmappable action} of this decoder is {@link\\n     *   CodingErrorAction#REPORT}; otherwise the unmappable character will be\\n     *   ignored or replaced, as requested.  \u003c/p\u003e\u003c/li\u003e\\n     *\\n     * \u003c/ul\u003e\\n     *\\n     * In any case, if this method is to be reinvoked in the same decoding\\n     * operation then care should be taken to preserve any bytes remaining\\n     * in the input buffer so that they are available to the next invocation.\\n     *\\n     * \u003cp\u003e The {@code endOfInput} parameter advises this method as to whether\\n     * the invoker can provide further input beyond that contained in the given\\n     * input buffer.  If there is a possibility of providing additional input\\n     * then the invoker should pass {@code false} for this parameter; if there\\n     * is no possibility of providing further input then the invoker should\\n     * pass {@code true}.  It is not erroneous, and in fact it is quite\\n     * common, to pass {@code false} in one invocation and later discover that\\n     * no further input was actually available.  It is critical, however, that\\n     * the final invocation of this method in a sequence of invocations always\\n     * pass {@code true} so that any remaining undecoded input will be treated\\n     * as being malformed.\\n     *\\n     * \u003cp\u003e This method works by invoking the {@link #decodeLoop decodeLoop}\\n     * method, interpreting its results, handling error conditions, and\\n     * reinvoking it as necessary.  \u003c/p\u003e\\n     *\\n     *\\n     * @param  in\\n     *         The input byte buffer\\n     *\\n     * @param  out\\n     *         The output character buffer\\n     *\\n     * @param  endOfInput\\n     *         {@code true} if, and only if, the invoker can provide no\\n     *         additional input bytes beyond those in the given buffer\\n     *\\n     * @return  A coder-result object describing the reason for termination\\n     *\\n     * @throws  IllegalStateException\\n     *          If a decoding operation is already in progress and the previous\\n     *          step was an invocation neither of the {@link #reset reset}\\n     *          method, nor of this method with a value of {@code false} for\\n     *          the {@code endOfInput} parameter, nor of this method with a\\n     *          value of {@code true} for the {@code endOfInput} parameter\\n     *          but a return value indicating an incomplete decoding operation\\n     *\\n     * @throws  CoderMalfunctionError\\n     *          If an invocation of the decodeLoop method threw\\n     *          an unexpected exception\\n     *\\n     * @throws  NullPointerException if input or output buffer is null\\n     \u0027}"}, {"color": "#97c2fc", "id": "decodeLoop", "label": "decodeLoop", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public final CoderResult flush(CharBuffer out)", "label": "public final CoderResult flush(CharBuffer out)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Flushes this decoder.\\n     *\\n     * \u003cp\u003e Some decoders maintain internal state and may need to write some\\n     * final characters to the output buffer once the overall input sequence has\\n     * been read.\\n     *\\n     * \u003cp\u003e Any additional output is written to the output buffer beginning at\\n     * its current position.  At most {@link Buffer#remaining out.remaining()}\\n     * characters will be written.  The buffer\\\u0027s position will be advanced\\n     * appropriately, but its mark and limit will not be modified.\\n     *\\n     * \u003cp\u003e If this method completes successfully then it returns {@link\\n     * CoderResult#UNDERFLOW}.  If there is insufficient room in the output\\n     * buffer then it returns {@link CoderResult#OVERFLOW}.  If this happens\\n     * then this method must be invoked again, with an output buffer that has\\n     * more room, in order to complete the current \u003ca href=\"#steps\"\u003edecoding\\n     * operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003e If this decoder has already been flushed then invoking this method\\n     * has no effect.\\n     *\\n     * \u003cp\u003e This method invokes the {@link #implFlush implFlush} method to\\n     * perform the actual flushing operation.  \u003c/p\u003e\\n     *\\n     * @param  out\\n     *         The output character buffer\\n     *\\n     * @return  A coder-result object, either {@link CoderResult#UNDERFLOW} or\\n     *          {@link CoderResult#OVERFLOW}\\n     *\\n     * @throws  IllegalStateException\\n     *          If the previous step of the current decoding operation was an\\n     *          invocation neither of the {@link #flush flush} method nor of\\n     *          the three-argument {@link\\n     *          #decode(ByteBuffer,CharBuffer,boolean) decode} method\\n     *          with a value of {@code true} for the {@code endOfInput}\\n     *          parameter\\n     \u0027}"}, {"color": "#97c2fc", "id": "decode(ByteBuffer", "label": "decode(ByteBuffer", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "protected CoderResult implFlush(CharBuffer out)", "label": "protected CoderResult implFlush(CharBuffer out)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Flushes this decoder.\\n     *\\n     * \u003cp\u003e The default implementation of this method does nothing, and always\\n     * returns {@link CoderResult#UNDERFLOW}.  This method should be overridden\\n     * by decoders that may need to write final characters to the output buffer\\n     * once the entire input sequence has been read. \u003c/p\u003e\\n     *\\n     * @param  out\\n     *         The output character buffer\\n     *\\n     * @return  A coder-result object, either {@link CoderResult#UNDERFLOW} or\\n     *          {@link CoderResult#OVERFLOW}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final CharsetDecoder reset()", "label": "public final CharsetDecoder reset()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Resets this decoder, clearing any internal state.\\n     *\\n     * \u003cp\u003e This method resets charset-independent state and also invokes the\\n     * {@link #implReset() implReset} method in order to perform any\\n     * charset-specific reset actions.  \u003c/p\u003e\\n     *\\n     * @return  This decoder\\n     *\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected abstract CoderResult decodeLoop(ByteBuffer in, CharBuffer out)", "label": "protected abstract CoderResult decodeLoop(ByteBuffer in, CharBuffer out)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Decodes one or more bytes into one or more characters.\\n     *\\n     * \u003cp\u003e This method encapsulates the basic decoding loop, decoding as many\\n     * bytes as possible until it either runs out of input, runs out of room\\n     * in the output buffer, or encounters a decoding error.  This method is\\n     * invoked by the {@link #decode decode} method, which handles result\\n     * interpretation and error recovery.\\n     *\\n     * \u003cp\u003e The buffers are read from, and written to, starting at their current\\n     * positions.  At most {@link Buffer#remaining in.remaining()} bytes\\n     * will be read, and at most {@link Buffer#remaining out.remaining()}\\n     * characters will be written.  The buffers\u0027 positions will be advanced to\\n     * reflect the bytes read and the characters written, but their marks and\\n     * limits will not be modified.\\n     *\\n     * \u003cp\u003e This method returns a {@link CoderResult} object to describe its\\n     * reason for termination, in the same manner as the {@link #decode decode}\\n     * method.  Most implementations of this method will handle decoding errors\\n     * by returning an appropriate result object for interpretation by the\\n     * {@link #decode decode} method.  An optimized implementation may instead\\n     * examine the relevant error action and implement that action itself.\\n     *\\n     * \u003cp\u003e An implementation of this method may perform arbitrary lookahead by\\n     * returning {@link CoderResult#UNDERFLOW} until it receives sufficient\\n     * input.  \u003c/p\u003e\\n     *\\n     * @param  in\\n     *         The input byte buffer\\n     *\\n     * @param  out\\n     *         The output character buffer\\n     *\\n     * @return  A coder-result object describing the reason for termination\\n     \"}"}, {"color": "#97c2fc", "id": "decode", "label": "decode", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public final CharBuffer decode(ByteBuffer in) throws CharacterCodingException", "label": "public final CharBuffer decode(ByteBuffer in) throws CharacterCodingException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Convenience method that decodes the remaining content of a single input\\n     * byte buffer into a newly-allocated character buffer.\\n     *\\n     * \u003cp\u003e This method implements an entire \u003ca href=\"#steps\"\u003edecoding\\n     * operation\u003c/a\u003e; that is, it resets this decoder, then it decodes the\\n     * bytes in the given byte buffer, and finally it flushes this\\n     * decoder.  This method should therefore not be invoked if a decoding\\n     * operation is already in progress.  \u003c/p\u003e\\n     *\\n     * @param  in\\n     *         The input byte buffer\\n     *\\n     * @return A newly-allocated character buffer containing the result of the\\n     *         decoding operation.  The buffer\\\u0027s position will be zero and its\\n     *         limit will follow the last character written.\\n     *\\n     * @throws  IllegalStateException\\n     *          If a decoding operation is already in progress\\n     *\\n     * @throws  MalformedInputException\\n     *          If the byte sequence starting at the input buffer\\\u0027s current\\n     *          position is not legal for this charset and the current malformed-input action\\n     *          is {@link CodingErrorAction#REPORT}\\n     *\\n     * @throws  UnmappableCharacterException\\n     *          If the byte sequence starting at the input buffer\\\u0027s current\\n     *          position cannot be mapped to an equivalent character sequence and\\n     *          the current unmappable-character action is {@link\\n     *          CodingErrorAction#REPORT}\\n     *\\n     * @throws  CoderMalfunctionError\\n     *          If an invocation of the decodeLoop method threw\\n     *          an unexpected exception\\n     *\\n     * @throws  NullPointerException if input buffer is null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isAutoDetecting()", "label": "public boolean isAutoDetecting()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this decoder implements an auto-detecting charset.\\n     *\\n     * \u003cp\u003e The default implementation of this method always returns\\n     * {@code false}; it should be overridden by auto-detecting decoders to\\n     * return {@code true}.  \u003c/p\u003e\\n     *\\n     * @return  {@code true} if, and only if, this decoder implements an\\n     *          auto-detecting charset\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isCharsetDetected()", "label": "public boolean isCharsetDetected()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this decoder has yet detected a\\n     * charset\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e If this decoder implements an auto-detecting charset then at a\\n     * single point during a decoding operation this method may start returning\\n     * {@code true} to indicate that a specific charset has been detected in\\n     * the input byte sequence.  Once this occurs, the {@link #detectedCharset\\n     * detectedCharset} method may be invoked to retrieve the detected charset.\\n     *\\n     * \u003cp\u003e That this method returns {@code false} does not imply that no bytes\\n     * have yet been decoded.  Some auto-detecting decoders are capable of\\n     * decoding some, or even all, of an input byte sequence without fixing on\\n     * a particular charset.\\n     *\\n     * \u003cp\u003e The default implementation of this method always throws an {@link\\n     * UnsupportedOperationException}; it should be overridden by\\n     * auto-detecting decoders to return {@code true} once the input charset\\n     * has been determined.  \u003c/p\u003e\\n     *\\n     * @return  {@code true} if, and only if, this decoder has detected a\\n     *          specific charset\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          If this decoder does not implement an auto-detecting charset\\n     \u0027}"}, {"color": "#97c2fc", "id": "detectedCharsetdetectedCharset", "label": "detectedCharsetdetectedCharset", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public Charset detectedCharset()", "label": "public Charset detectedCharset()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Retrieves the charset that was detected by this\\n     * decoder\u0026nbsp;\u0026nbsp;\u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e If this decoder implements an auto-detecting charset then this\\n     * method returns the actual charset once it has been detected.  After that\\n     * point, this method returns the same value for the duration of the\\n     * current decoding operation.  If not enough input bytes have yet been\\n     * read to determine the actual charset then this method throws an {@link\\n     * IllegalStateException}.\\n     *\\n     * \u003cp\u003e The default implementation of this method always throws an {@link\\n     * UnsupportedOperationException}; it should be overridden by\\n     * auto-detecting decoders to return the appropriate value.  \u003c/p\u003e\\n     *\\n     * @return  The charset detected by this auto-detecting decoder,\\n     *          or {@code null} if the charset has not yet been determined\\n     *\\n     * @throws  IllegalStateException\\n     *          If insufficient bytes have been read to determine a charset\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          If this decoder does not implement an auto-detecting charset\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final ByteBuffer encode(CharBuffer cb)", "label": "public final ByteBuffer encode(CharBuffer cb)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Convenience method that encodes Unicode characters into bytes in this\\n     * charset.\\n     *\\n     * \u003cp\u003e An invocation of this method upon a charset {@code cs} returns the\\n     * same result as the expression\\n     *\\n     * \u003cpre\u003e\\n     *     cs.newEncoder()\\n     *       .onMalformedInput(CodingErrorAction.REPLACE)\\n     *       .onUnmappableCharacter(CodingErrorAction.REPLACE)\\n     *       .encode(bb); \u003c/pre\u003e\\n     *\\n     * except that it is potentially more efficient because it can cache\\n     * encoders between successive invocations.\\n     *\\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\\n     * sequences with this charset\u0027s default replacement string.  In order to\\n     * detect such sequences, use the {@link\\n     * CharsetEncoder#encode(java.nio.CharBuffer)} method directly.  \u003c/p\u003e\\n     *\\n     * @param  cb  The char buffer to be encoded\\n     *\\n     * @return  A byte buffer containing the encoded characters\\n     \"}"}, {"color": "#97c2fc", "id": "public final ByteBuffer encode(String str)", "label": "public final ByteBuffer encode(String str)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Convenience method that encodes a string into bytes in this charset.\\n     *\\n     * \u003cp\u003e An invocation of this method upon a charset {@code cs} returns the\\n     * same result as the expression\\n     *\\n     * \u003cpre\u003e\\n     *     cs.encode(CharBuffer.wrap(s)); \u003c/pre\u003e\\n     *\\n     * @param  str  The string to be encoded\\n     *\\n     * @return  A byte buffer containing the encoded characters\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final int compareTo(Charset that)", "label": "public final int compareTo(Charset that)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares this charset to another.\\n     *\\n     * \u003cp\u003e Charsets are ordered by their canonical names, without regard to\\n     * case. \u003c/p\u003e\\n     *\\n     * @param  that\\n     *         The charset to which this charset is to be compared\\n     *\\n     * @return A negative integer, zero, or a positive integer as this charset\\n     *         is less than, equal to, or greater than the specified charset\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final int hashCode()", "label": "public final int hashCode()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a hashcode for this socket address.\\n     *\\n     * @return  a hash code value for this socket address.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final boolean equals(Object ob)", "label": "public final boolean equals(Object ob)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this object is equal to another.\\n     *\\n     * \u003cp\u003e Two charsets are equal if, and only if, they have the same canonical\\n     * names.  A charset is never equal to any other type of object.  \u003c/p\u003e\\n     *\\n     * @return  {@code true} if, and only if, this charset is equal to the\\n     *          given object\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final String toString()", "label": "public final String toString()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string describing the range, type, and validity of this lock.\\n     *\\n     * @return  A descriptive string\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static native boolean echo(boolean on) throws IOException", "label": "private static native boolean echo(boolean on) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the console echo status to {@code on} and returns the previous\\n     * console on/off status.\\n     * @param on    the echo status to set to. {@code true} for echo on and\\n     *              {@code false} for echo off\\n     * @return true if the previous console echo status is on\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Channel inheritedChannel() throws IOException", "label": "public static Channel inheritedChannel() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the channel inherited from the entity that created this\\n     * Java virtual machine.\\n     *\\n     * \u003cp\u003e This method returns the channel obtained by invoking the\\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\\n     * inheritedChannel} method of the system-wide default\\n     * {@link java.nio.channels.spi.SelectorProvider} object. \u003c/p\u003e\\n     *\\n     * \u003cp\u003e In addition to the network-oriented channels described in\\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\\n     * inheritedChannel}, this method may return other kinds of\\n     * channels in the future.\\n     *\\n     * @return  The inherited channel, if any, otherwise \u003ctt\u003enull\u003c/tt\u003e.\\n     *\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager is present and it does not\\n     *          permit access to the channel.\\n     *\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.nio.channels.spi.SelectorProvider", "label": "java.nio.channels.spi.SelectorProvider", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public static SelectorProvider provider()", "label": "public static SelectorProvider provider()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the system-wide default selector provider for this invocation of\\n     * the Java virtual machine.\\n     *\\n     * \u003cp\u003e The first invocation of this method locates the default provider\\n     * object as follows: \u003c/p\u003e\\n     *\\n     * \u003col\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e If the system property\\n     *   {@code java.nio.channels.spi.SelectorProvider} is defined then it is\\n     *   taken to be the fully-qualified name of a concrete provider class.\\n     *   The class is loaded and instantiated; if this process fails then an\\n     *   unspecified error is thrown.  \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e If a provider class has been installed in a jar file that is\\n     *   visible to the system class loader, and that jar file contains a\\n     *   provider-configuration file named\\n     *   {@code java.nio.channels.spi.SelectorProvider} in the resource\\n     *   directory {@code META-INF/services}, then the first class name\\n     *   specified in that file is taken.  The class is loaded and\\n     *   instantiated; if this process fails then an unspecified error is\\n     *   thrown.  \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e Finally, if no provider has been specified by any of the above\\n     *   means then the system-default provider class is instantiated and the\\n     *   result is returned.  \u003c/p\u003e\u003c/li\u003e\\n     *\\n     * \u003c/ol\u003e\\n     *\\n     * \u003cp\u003e Subsequent invocations of this method return the provider that was\\n     * returned by the first invocation.  \u003c/p\u003e\\n     *\\n     * @return  The system-wide default selector provider\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract DatagramChannel openDatagramChannel() throws IOException", "label": "public abstract DatagramChannel openDatagramChannel() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens a datagram channel.\\n     *\\n     * @return  The new channel\\n     *\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract DatagramChannel openDatagramChannel(ProtocolFamily family) throws IOException", "label": "public abstract DatagramChannel openDatagramChannel(ProtocolFamily family) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens a datagram channel.\\n     *\\n     * @param   family\\n     *          The protocol family\\n     *\\n     * @return  A new datagram channel\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          If the specified protocol family is not supported\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     *\\n     * @since 1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract Pipe openPipe() throws IOException", "label": "public abstract Pipe openPipe() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens a pipe.\\n     *\\n     * @return  The new pipe\\n     *\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract AbstractSelector openSelector() throws IOException", "label": "public abstract AbstractSelector openSelector() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens a selector.\\n     *\\n     * @return  The new selector\\n     *\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract ServerSocketChannel openServerSocketChannel() throws IOException", "label": "public abstract ServerSocketChannel openServerSocketChannel() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens a server-socket channel.\\n     *\\n     * @return  The new channel\\n     *\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract SocketChannel openSocketChannel() throws IOException", "label": "public abstract SocketChannel openSocketChannel() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens a socket channel.\\n     *\\n     * @return  The new channel\\n     *\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Channel inheritedChannel() throws IOException", "label": "public Channel inheritedChannel() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the channel inherited from the entity that created this\\n     * Java virtual machine.\\n     *\\n     * \u003cp\u003e On many operating systems a process, such as a Java virtual\\n     * machine, can be started in a manner that allows the process to\\n     * inherit a channel from the entity that created the process. The\\n     * manner in which this is done is system dependent, as are the\\n     * possible entities to which the channel may be connected. For example,\\n     * on UNIX systems, the Internet services daemon (\u003ci\u003einetd\u003c/i\u003e) is used to\\n     * start programs to service requests when a request arrives on an\\n     * associated network port. In this example, the process that is started,\\n     * inherits a channel representing a network socket.\\n     *\\n     * \u003cp\u003e In cases where the inherited channel represents a network socket\\n     * then the {@link java.nio.channels.Channel Channel} type returned\\n     * by this method is determined as follows:\\n     *\\n     * \u003cul\u003e\\n     *\\n     *  \u003cli\u003e\u003cp\u003e If the inherited channel represents a stream-oriented connected\\n     *  socket then a {@link java.nio.channels.SocketChannel SocketChannel} is\\n     *  returned. The socket channel is, at least initially, in blocking\\n     *  mode, bound to a socket address, and connected to a peer.\\n     *  \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *  \u003cli\u003e\u003cp\u003e If the inherited channel represents a stream-oriented listening\\n     *  socket then a {@link java.nio.channels.ServerSocketChannel\\n     *  ServerSocketChannel} is returned. The server-socket channel is, at\\n     *  least initially, in blocking mode, and bound to a socket address.\\n     *  \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *  \u003cli\u003e\u003cp\u003e If the inherited channel is a datagram-oriented socket\\n     *  then a {@link java.nio.channels.DatagramChannel DatagramChannel} is\\n     *  returned. The datagram channel is, at least initially, in blocking\\n     *  mode, and bound to a socket address.\\n     *  \u003c/p\u003e\u003c/li\u003e\\n     *\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003e In addition to the network-oriented channels described, this method\\n     * may return other kinds of channels in the future.\\n     *\\n     * \u003cp\u003e The first invocation of this method creates the channel that is\\n     * returned. Subsequent invocations of this method return the same\\n     * channel. \u003c/p\u003e\\n     *\\n     * @return  The inherited channel, if any, otherwise {@code null}.\\n     *\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager has been installed and it denies\\n     *          {@link RuntimePermission}{@code (\"inheritedChannel\")}\\n     *\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.nio.channels.ServerSocketChannelServerSocketChannel", "label": "java.nio.channels.ServerSocketChannelServerSocketChannel", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "java.nio.channels.SocketChannel", "label": "java.nio.channels.SocketChannel", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public static SocketChannel open() throws IOException", "label": "public static SocketChannel open() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens a socket channel.\\n     *\\n     * \u003cp\u003e The new channel is created by invoking the {@link\\n     * java.nio.channels.spi.SelectorProvider#openSocketChannel\\n     * openSocketChannel} method of the system-wide default {@link\\n     * java.nio.channels.spi.SelectorProvider} object.  \u003c/p\u003e\\n     *\\n     * @return  A new socket channel\\n     *\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static SocketChannel open(SocketAddress remote) throws IOException", "label": "public static SocketChannel open(SocketAddress remote) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Opens a socket channel and connects it to a remote address.\\n     *\\n     * \u003cp\u003e This convenience method works as if by invoking the {@link #open()}\\n     * method, invoking the {@link #connect(SocketAddress) connect} method upon\\n     * the resulting socket channel, passing it {@code remote}, and then\\n     * returning that channel.  \u003c/p\u003e\\n     *\\n     * @param  remote\\n     *         The remote address to which the new channel is to be connected\\n     *\\n     * @return  A new, and connected, socket channel\\n     *\\n     * @throws  AsynchronousCloseException\\n     *          If another thread closes this channel\\n     *          while the connect operation is in progress\\n     *\\n     * @throws  ClosedByInterruptException\\n     *          If another thread interrupts the current thread\\n     *          while the connect operation is in progress, thereby\\n     *          closing the channel and setting the current thread\u0027s\\n     *          interrupt status\\n     *\\n     * @throws  UnresolvedAddressException\\n     *          If the given remote address is not fully resolved\\n     *\\n     * @throws  UnsupportedAddressTypeException\\n     *          If the type of the given remote address is not supported\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager has been installed\\n     *          and it does not permit access to the given remote endpoint\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "open()", "label": "open()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "connect(SocketAddress)", "label": "connect(SocketAddress)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public final int validOps()", "label": "public final int validOps()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns an operation set identifying this channel\u0027s supported\\n     * operations.\\n     *\\n     * \u003cp\u003e Datagram channels support reading and writing, so this method\\n     * returns {@code (}{@link SelectionKey#OP_READ} {@code |}\u0026nbsp;{@link\\n     * SelectionKey#OP_WRITE}{@code )}.\\n     *\\n     * @return  The valid-operation set\\n     \"}"}, {"color": "#97c2fc", "id": "OP_READ", "label": "OP_READ", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.channels.SelectionKey", "label": "java.nio.channels.SelectionKey", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public abstract SelectableChannel channel()", "label": "public abstract SelectableChannel channel()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the channel for which this key was created.  This method will\\n     * continue to return the channel even after the key is cancelled.\\n     *\\n     * @return  This key\u0027s channel\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract Selector selector()", "label": "public abstract Selector selector()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the selector for which this key was created.  This method will\\n     * continue to return the selector even after the key is cancelled.\\n     *\\n     * @return  This key\u0027s selector\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract boolean isValid()", "label": "public abstract boolean isValid()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this lock is valid.\\n     *\\n     * \u003cp\u003e A lock object remains valid until it is released or the associated\\n     * file channel is closed, whichever comes first.  \u003c/p\u003e\\n     *\\n     * @return  {@code true} if, and only if, this lock is valid\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract void cancel()", "label": "public abstract void cancel()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Requests that the registration of this key\u0027s channel with its selector\\n     * be cancelled.  Upon return the key will be invalid and will have been\\n     * added to its selector\u0027s cancelled-key set.  The key will be removed from\\n     * all of the selector\u0027s key sets during the next selection operation.\\n     *\\n     * \u003cp\u003e If this key has already been cancelled then invoking this method has\\n     * no effect.  Once cancelled, a key remains forever invalid. \u003c/p\u003e\\n     *\\n     * \u003cp\u003e This method may be invoked at any time.  It synchronizes on the\\n     * selector\u0027s cancelled-key set, and therefore may block briefly if invoked\\n     * concurrently with a cancellation or selection operation involving the\\n     * same selector.  \u003c/p\u003e\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract int interestOps()", "label": "public abstract int interestOps()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Retrieves this key\u0027s interest set.\\n     *\\n     * \u003cp\u003e It is guaranteed that the returned set will only contain operation\\n     * bits that are valid for this key\u0027s channel. \u003c/p\u003e\\n     *\\n     * @return  This key\u0027s interest set\\n     *\\n     * @throws  CancelledKeyException\\n     *          If this key has been cancelled\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract SelectionKey interestOps(int ops)", "label": "public abstract SelectionKey interestOps(int ops)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Sets this key\u0027s interest set to the given value.\\n     *\\n     * \u003cp\u003e This method may be invoked at any time.  If this method is invoked\\n     * while a selection operation is in progress then it has no effect upon\\n     * that operation; the change to the key\u0027s interest set will be seen by the\\n     * next selection operation.\\n     *\\n     * @param  ops  The new interest set\\n     *\\n     * @return  This selection key\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If a bit in the set does not correspond to an operation that\\n     *          is supported by this key\u0027s channel, that is, if\\n     *          {@code (ops \u0026 ~channel().validOps()) != 0}\\n     *\\n     * @throws  CancelledKeyException\\n     *          If this key has been cancelled\\n     \"}"}, {"color": "#97c2fc", "id": "public int interestOpsOr(int ops)", "label": "public int interestOpsOr(int ops)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Atomically sets this key\\\u0027s interest set to the bitwise union (\"or\") of\\n     * the existing interest set and the given value. This method is guaranteed\\n     * to be atomic with respect to other concurrent calls to this method or to\\n     * {@link #interestOpsAnd(int)}.\\n     *\\n     * \u003cp\u003e This method may be invoked at any time.  If this method is invoked\\n     * while a selection operation is in progress then it has no effect upon\\n     * that operation; the change to the key\\\u0027s interest set will be seen by the\\n     * next selection operation.\\n     *\\n     * @implSpec The default implementation synchronizes on this key and invokes\\n     * {@code interestOps()} and {@code interestOps(int)} to retrieve and set\\n     * this key\\\u0027s interest set.\\n     *\\n     * @param  ops  The interest set to apply\\n     *\\n     * @return  The previous interest set\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If a bit in the set does not correspond to an operation that\\n     *          is supported by this key\\\u0027s channel, that is, if\\n     *          {@code (ops \u0026 ~channel().validOps()) != 0}\\n     *\\n     * @throws  CancelledKeyException\\n     *          If this key has been cancelled\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "interestOpsAnd(int)", "label": "interestOpsAnd(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public int interestOpsAnd(int ops)", "label": "public int interestOpsAnd(int ops)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Atomically sets this key\\\u0027s interest set to the bitwise intersection (\"and\")\\n     * of the existing interest set and the given value. This method is guaranteed\\n     * to be atomic with respect to other concurrent calls to this method or to\\n     * {@link #interestOpsOr(int)}.\\n     *\\n     * \u003cp\u003e This method may be invoked at any time.  If this method is invoked\\n     * while a selection operation is in progress then it has no effect upon\\n     * that operation; the change to the key\\\u0027s interest set will be seen by the\\n     * next selection operation.\\n     *\\n     * @apiNote Unlike the {@code interestOps(int)} and {@code interestOpsOr(int)}\\n     * methods, this method does not throw {@code IllegalArgumentException} when\\n     * invoked with bits in the interest set that do not correspond to an\\n     * operation that is supported by this key\\\u0027s channel. This is to allow\\n     * operation bits in the interest set to be cleared using bitwise complement\\n     * values, e.g., {@code interestOpsAnd(~SelectionKey.OP_READ)} will remove\\n     * the {@code OP_READ} from the interest set without affecting other bits.\\n     *\\n     * @implSpec The default implementation synchronizes on this key and invokes\\n     * {@code interestOps()} and {@code interestOps(int)} to retrieve and set\\n     * this key\\\u0027s interest set.\\n     *\\n     * @param  ops  The interest set to apply\\n     *\\n     * @return  The previous interest set\\n     *\\n     * @throws  CancelledKeyException\\n     *          If this key has been cancelled\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "interestOpsOr(int)", "label": "interestOpsOr(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract int readyOps()", "label": "public abstract int readyOps()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Retrieves this key\u0027s ready-operation set.\\n     *\\n     * \u003cp\u003e It is guaranteed that the returned set will only contain operation\\n     * bits that are valid for this key\u0027s channel.  \u003c/p\u003e\\n     *\\n     * @return  This key\u0027s ready-operation set\\n     *\\n     * @throws  CancelledKeyException\\n     *          If this key has been cancelled\\n     \"}"}, {"color": "#97c2fc", "id": "public final boolean isReadable()", "label": "public final boolean isReadable()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Tests whether this key\u0027s channel is ready for reading.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form {@code k.isReadable()}\\n     * behaves in exactly the same way as the expression\\n     *\\n     * \u003cblockquote\u003e\u003cpre\u003e{@code\\n     * k.readyOps() \u0026 OP_READ != 0\\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * \u003cp\u003e If this key\u0027s channel does not support read operations then this\\n     * method always returns {@code false}.  \u003c/p\u003e\\n     *\\n     * @return  {@code true} if, and only if,\\n                {@code readyOps() \u0026 OP_READ} is nonzero\\n     *\\n     * @throws  CancelledKeyException\\n     *          If this key has been cancelled\\n     \"}"}, {"color": "#97c2fc", "id": "public final boolean isWritable()", "label": "public final boolean isWritable()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Tests whether this key\u0027s channel is ready for writing.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form {@code k.isWritable()}\\n     * behaves in exactly the same way as the expression\\n     *\\n     * \u003cblockquote\u003e\u003cpre\u003e{@code\\n     * k.readyOps() \u0026 OP_WRITE != 0\\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * \u003cp\u003e If this key\u0027s channel does not support write operations then this\\n     * method always returns {@code false}.  \u003c/p\u003e\\n     *\\n     * @return  {@code true} if, and only if,\\n     *          {@code readyOps() \u0026 OP_WRITE} is nonzero\\n     *\\n     * @throws  CancelledKeyException\\n     *          If this key has been cancelled\\n     \"}"}, {"color": "#97c2fc", "id": "public final boolean isConnectable()", "label": "public final boolean isConnectable()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Tests whether this key\u0027s channel has either finished, or failed to\\n     * finish, its socket-connection operation.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form {@code k.isConnectable()}\\n     * behaves in exactly the same way as the expression\\n     *\\n     * \u003cblockquote\u003e\u003cpre\u003e{@code\\n     * k.readyOps() \u0026 OP_CONNECT != 0\\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * \u003cp\u003e If this key\u0027s channel does not support socket-connect operations\\n     * then this method always returns {@code false}.  \u003c/p\u003e\\n     *\\n     * @return  {@code true} if, and only if,\\n     *          {@code readyOps() \u0026 OP_CONNECT} is nonzero\\n     *\\n     * @throws  CancelledKeyException\\n     *          If this key has been cancelled\\n     \"}"}, {"color": "#97c2fc", "id": "public final boolean isAcceptable()", "label": "public final boolean isAcceptable()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Tests whether this key\u0027s channel is ready to accept a new socket\\n     * connection.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form {@code k.isAcceptable()}\\n     * behaves in exactly the same way as the expression\\n     *\\n     * \u003cblockquote\u003e\u003cpre\u003e{@code\\n     * k.readyOps() \u0026 OP_ACCEPT != 0\\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * \u003cp\u003e If this key\u0027s channel does not support socket-accept operations then\\n     * this method always returns {@code false}.  \u003c/p\u003e\\n     *\\n     * @return  {@code true} if, and only if,\\n     *          {@code readyOps() \u0026 OP_ACCEPT} is nonzero\\n     *\\n     * @throws  CancelledKeyException\\n     *          If this key has been cancelled\\n     \"}"}, {"color": "#97c2fc", "id": "public final Object attach(Object ob)", "label": "public final Object attach(Object ob)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Attaches the given object to this key.\\n     *\\n     * \u003cp\u003e An attached object may later be retrieved via the {@link #attachment()\\n     * attachment} method.  Only one object may be attached at a time; invoking\\n     * this method causes any previous attachment to be discarded.  The current\\n     * attachment may be discarded by attaching {@code null}.  \u003c/p\u003e\\n     *\\n     * @param  ob\\n     *         The object to be attached; may be {@code null}\\n     *\\n     * @return  The previously-attached object, if any,\\n     *          otherwise {@code null}\\n     \u0027}"}, {"color": "#97c2fc", "id": "attachment()", "label": "attachment()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public final Object attachment()", "label": "public final Object attachment()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Retrieves the current attachment.\\n     *\\n     * @return  The object currently attached to this key,\\n     *          or {@code null} if there is no attachment\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract SocketChannel bind(SocketAddress local) throws IOException", "label": "public abstract SocketChannel bind(SocketAddress local) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @throws  ConnectionPendingException\\n     *          If a non-blocking connect operation is already in progress on\\n     *          this channel\\n     * @throws  AlreadyBoundException               {@inheritDoc}\\n     * @throws  UnsupportedAddressTypeException     {@inheritDoc}\\n     * @throws  ClosedChannelException              {@inheritDoc}\\n     * @throws  IOException                         {@inheritDoc}\\n     * @throws  SecurityException\\n     *          If a security manager has been installed and its\\n     *          {@link SecurityManager#checkListen checkListen} method denies\\n     *          the operation\\n     *\\n     * @since 1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "checkListen", "label": "checkListen", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract SocketChannel setOption(SocketOption\u003cT\u003e name, T value) throws IOException", "label": "public abstract SocketChannel setOption(SocketOption\u003cT\u003e name, T value) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @throws  UnsupportedOperationException           {@inheritDoc}\\n     * @throws  IllegalArgumentException                {@inheritDoc}\\n     * @throws  ClosedChannelException                  {@inheritDoc}\\n     * @throws  IOException                             {@inheritDoc}\\n     *\\n     * @since 1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract SocketChannel shutdownInput() throws IOException", "label": "public abstract SocketChannel shutdownInput() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Shutdown the connection for reading without closing the channel.\\n     *\\n     * \u003cp\u003e Once shutdown for reading then further reads on the channel will\\n     * return {@code -1}, the end-of-stream indication. If the input side of the\\n     * connection is already shutdown then invoking this method has no effect.\\n     *\\n     * @return  The channel\\n     *\\n     * @throws  NotYetConnectedException\\n     *          If this channel is not yet connected\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     *\\n     * @since 1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract SocketChannel shutdownOutput() throws IOException", "label": "public abstract SocketChannel shutdownOutput() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Shutdown the connection for writing without closing the channel.\\n     *\\n     * \u003cp\u003e Once shutdown for writing then further attempts to write to the\\n     * channel will throw {@link ClosedChannelException}. If the output side of\\n     * the connection is already shutdown then invoking this method has no\\n     * effect.\\n     *\\n     * @return  The channel\\n     *\\n     * @throws  NotYetConnectedException\\n     *          If this channel is not yet connected\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     *\\n     * @since 1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.nio.channels.ClosedChannelException", "label": "java.nio.channels.ClosedChannelException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public abstract Socket socket()", "label": "public abstract Socket socket()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Retrieves a socket associated with this channel.\\n     *\\n     * \u003cp\u003e The returned object will not declare any public methods that are not\\n     * declared in the {@link java.net.Socket} class.  \u003c/p\u003e\\n     *\\n     * @return  A socket associated with this channel\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.net.Socket", "label": "java.net.Socket", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * This class implements client sockets (also called just\\n * \"sockets\"). A socket is an endpoint for communication\\n * between two machines.\\n * \u003cp\u003e\\n * The actual work of the socket is performed by an instance of the\\n * {@code SocketImpl} class. An application, by changing\\n * the socket factory that creates the socket implementation,\\n * can configure itself to create sockets appropriate to the local\\n * firewall.\\n *\\n * @author  unascribed\\n * @see     java.net.Socket#setSocketImplFactory(java.net.SocketImplFactory)\\n * @see     java.net.SocketImpl\\n * @see     java.nio.channels.SocketChannel\\n * @since   1.0\\n \u0027}"}, {"color": "#97c2fc", "id": "private static InetAddress[] nonNullAddress(InetAddress address)", "label": "private static InetAddress[] nonNullAddress(InetAddress address)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-changed: App compat. Socket ctor should try all addresses. http://b/30007735\u0027}"}, {"color": "#97c2fc", "id": " void createImpl(boolean stream) throws SocketException", "label": " void createImpl(boolean stream) throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates the socket implementation.\\n     *\\n     * @param stream a {@code boolean} value : {@code true} for a TCP socket,\\n     *               {@code false} for UDP.\\n     * @throws IOException if creation fails\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": " void setImpl()", "label": " void setImpl()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets impl to the system-default type of SocketImpl.\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": " SocketImpl getImpl() throws SocketException", "label": " SocketImpl getImpl() throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the {@code SocketImpl} attached to this socket, creating\\n     * it if necessary.\\n     *\\n     * @return  the {@code SocketImpl} attached to that ServerSocket.\\n     * @throws SocketException if creation fails\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void connect(SocketAddress endpoint) throws IOException", "label": "public void connect(SocketAddress endpoint) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Connects this socket to the server.\\n     *\\n     * @param   endpoint the {@code SocketAddress}\\n     * @throws  IOException if an error occurs during the connection\\n     * @throws  java.nio.channels.IllegalBlockingModeException\\n     *          if this socket has an associated channel,\\n     *          and the channel is in non-blocking mode\\n     * @throws  IllegalArgumentException if endpoint is null or is a\\n     *          SocketAddress subclass not supported by this socket\\n     * @since 1.4\\n     * @spec JSR-51\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void connect(SocketAddress endpoint, int timeout) throws IOException", "label": "public void connect(SocketAddress endpoint, int timeout) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Connects this socket to the server with a specified timeout value.\\n     * A timeout of zero is interpreted as an infinite timeout. The connection\\n     * will then block until established or an error occurs.\\n     *\\n     * @param   endpoint the {@code SocketAddress}\\n     * @param   timeout  the timeout value to be used in milliseconds.\\n     * @throws  IOException if an error occurs during the connection\\n     * @throws  SocketTimeoutException if timeout expires before connecting\\n     * @throws  java.nio.channels.IllegalBlockingModeException\\n     *          if this socket has an associated channel,\\n     *          and the channel is in non-blocking mode\\n     * @throws  IllegalArgumentException if endpoint is null or is a\\n     *          SocketAddress subclass not supported by this socket\\n     * @since 1.4\\n     * @spec JSR-51\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void bind(SocketAddress bindpoint) throws IOException", "label": "public void bind(SocketAddress bindpoint) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Binds the socket to a local address.\\n     * \u003cP\u003e\\n     * If the address is {@code null}, then the system will pick up\\n     * an ephemeral port and a valid local address to bind the socket.\\n     *\\n     * @param   bindpoint the {@code SocketAddress} to bind to\\n     * @throws  IOException if the bind operation fails, or if the socket\\n     *                     is already bound.\\n     * @throws  IllegalArgumentException if bindpoint is a\\n     *          SocketAddress subclass not supported by this socket\\n     * @throws  SecurityException  if a security manager exists and its\\n     *          {@code checkListen} method doesn\u0027t allow the bind\\n     *          to the local port.\\n     *\\n     * @since   1.4\\n     * @see #isBound\\n     \"}"}, {"color": "#97c2fc", "id": " final void postAccept()", "label": " final void postAccept()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * set the flags after an accept() call.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public InetAddress getInetAddress()", "label": "public InetAddress getInetAddress()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the address to which this socket is connected. Returns\\n     * {@code null} if the socket is not connected.\\n     * \u003cp\u003e\\n     * If the socket was connected prior to being {@link #close closed},\\n     * then this method will continue to return the connected address\\n     * after the socket is closed.\\n     *\\n     * @return the address to which this socket is connected.\\n     \u0027}"}, {"color": "#97c2fc", "id": "close", "label": "close", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public InetAddress getLocalAddress()", "label": "public InetAddress getLocalAddress()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets the local address to which the socket is bound.\\n     *\\n     * \u003cp\u003eIf there is a security manager, its\\n     * {@code checkConnect} method is first called\\n     * with the host address and {@code -1}\\n     * as its arguments to see if the operation is allowed.\\n     *\\n     * @see SecurityManager#checkConnect\\n     * @return  the local address to which the socket is bound,\\n     *          {@code null} if the socket is closed, or\\n     *          an {@code InetAddress} representing\\n     *          {@link InetAddress#isAnyLocalAddress wildcard}\\n     *          address if either the socket is not bound, or\\n     *          the security manager {@code checkConnect}\\n     *          method does not allow the operation\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "getLoopbackAddress", "label": "getLoopbackAddress", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.net.InetAddress", "label": "java.net.InetAddress", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * This class represents an Internet Protocol (IP) address.\\n *\\n * \u003cp\u003e An IP address is either a 32-bit or 128-bit unsigned number\\n * used by IP, a lower-level protocol on which protocols like UDP and\\n * TCP are built. The IP address architecture is defined by \u003ca\\n * href=\"http://www.ietf.org/rfc/rfc790.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;790:\\n * Assigned Numbers\u003c/i\u003e\u003c/a\u003e, \u003ca\\n * href=\"http://www.ietf.org/rfc/rfc1918.txt\"\u003e \u003ci\u003eRFC\u0026nbsp;1918:\\n * Address Allocation for Private Internets\u003c/i\u003e\u003c/a\u003e, \u003ca\\n * href=\"http://www.ietf.org/rfc/rfc2365.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;2365:\\n * Administratively Scoped IP Multicast\u003c/i\u003e\u003c/a\u003e, and \u003ca\\n * href=\"http://www.ietf.org/rfc/rfc2373.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;2373: IP\\n * Version 6 Addressing Architecture\u003c/i\u003e\u003c/a\u003e. An instance of an\\n * InetAddress consists of an IP address and possibly its\\n * corresponding host name (depending on whether it is constructed\\n * with a host name or whether it has already done reverse host name\\n * resolution).\\n *\\n * \u003ch3\u003e Address types \u003c/h3\u003e\\n *\\n * \u003cblockquote\u003e\u003ctable cellspacing=2 summary=\"Description of unicast and multicast address types\"\u003e\\n *   \u003ctr\u003e\u003cth valign=top\u003e\u003ci\u003eunicast\u003c/i\u003e\u003c/th\u003e\\n *       \u003ctd\u003eAn identifier for a single interface. A packet sent to\\n *         a unicast address is delivered to the interface identified by\\n *         that address.\\n *\\n *         \u003cp\u003e The Unspecified Address -- Also called anylocal or wildcard\\n *         address. It must never be assigned to any node. It indicates the\\n *         absence of an address. One example of its use is as the target of\\n *         bind, which allows a server to accept a client connection on any\\n *         interface, in case the server host has multiple interfaces.\\n *\\n *         \u003cp\u003e The \u003ci\u003eunspecified\u003c/i\u003e address must not be used as\\n *         the destination address of an IP packet.\\n *\\n *         \u003cp\u003e The \u003ci\u003eLoopback\u003c/i\u003e Addresses -- This is the address\\n *         assigned to the loopback interface. Anything sent to this\\n *         IP address loops around and becomes IP input on the local\\n *         host. This address is often used when testing a\\n *         client.\u003c/td\u003e\u003c/tr\u003e\\n *   \u003ctr\u003e\u003cth valign=top\u003e\u003ci\u003emulticast\u003c/i\u003e\u003c/th\u003e\\n *       \u003ctd\u003eAn identifier for a set of interfaces (typically belonging\\n *         to different nodes). A packet sent to a multicast address is\\n *         delivered to all interfaces identified by that address.\u003c/td\u003e\u003c/tr\u003e\\n * \u003c/table\u003e\u003c/blockquote\u003e\\n *\\n * \u003ch4\u003e IP address scope \u003c/h4\u003e\\n *\\n * \u003cp\u003e \u003ci\u003eLink-local\u003c/i\u003e addresses are designed to be used for addressing\\n * on a single link for purposes such as auto-address configuration,\\n * neighbor discovery, or when no routers are present.\\n *\\n * \u003cp\u003e \u003ci\u003eSite-local\u003c/i\u003e addresses are designed to be used for addressing\\n * inside of a site without the need for a global prefix.\\n *\\n * \u003cp\u003e \u003ci\u003eGlobal\u003c/i\u003e addresses are unique across the internet.\\n *\\n * \u003ch4\u003e Textual representation of IP addresses \u003c/h4\u003e\\n *\\n * The textual representation of an IP address is address family specific.\\n *\\n * \u003cp\u003e\\n *\\n * For IPv4 address format, please refer to \u003cA\\n * HREF=\"Inet4Address.html#format\"\u003eInet4Address#format\u003c/A\u003e; For IPv6\\n * address format, please refer to \u003cA\\n * HREF=\"Inet6Address.html#format\"\u003eInet6Address#format\u003c/A\u003e.\\n *\\n * \u003cP\u003eThere is a \u003ca href=\"doc-files/net-properties.html#Ipv4IPv6\"\u003ecouple of\\n * System Properties\u003c/a\u003e affecting how IPv4 and IPv6 addresses are used.\u003c/P\u003e\\n *\\n * \u003ch4\u003e Host Name Resolution \u003c/h4\u003e\\n *\\n * Host name-to-IP address \u003ci\u003eresolution\u003c/i\u003e is accomplished through\\n * the use of a combination of local machine configuration information\\n * and network naming services such as the Domain Name System (DNS)\\n * and Network Information Service(NIS). The particular naming\\n * services(s) being used is by default the local machine configured\\n * one. For any host name, its corresponding IP address is returned.\\n *\\n * \u003cp\u003e \u003ci\u003eReverse name resolution\u003c/i\u003e means that for any IP address,\\n * the host associated with the IP address is returned.\\n *\\n * \u003cp\u003e The InetAddress class provides methods to resolve host names to\\n * their IP addresses and vice versa.\\n *\\n * \u003ch4\u003e InetAddress Caching \u003c/h4\u003e\\n *\\n * The InetAddress class has a cache to store successful as well as\\n * unsuccessful host name resolutions.\\n *\\n * \u003cp\u003e By default, when a security manager is installed, in order to\\n * protect against DNS spoofing attacks,\\n * the result of positive host name resolutions are\\n * cached forever. When a security manager is not installed, the default\\n * behavior is to cache entries for a finite (implementation dependent)\\n * period of time. The result of unsuccessful host\\n * name resolution is cached for a very short period of time (10\\n * seconds) to improve performance.\\n *\\n * \u003cp\u003e If the default behavior is not desired, then a Java security property\\n * can be set to a different Time-to-live (TTL) value for positive\\n * caching. Likewise, a system admin can configure a different\\n * negative caching TTL value when needed.\\n *\\n * \u003cp\u003e Two Java security properties control the TTL values used for\\n *  positive and negative host name resolution caching:\\n *\\n * \u003cblockquote\u003e\\n * \u003cdl\u003e\\n * \u003cdt\u003e\u003cb\u003enetworkaddress.cache.ttl\u003c/b\u003e\u003c/dt\u003e\\n * \u003cdd\u003eIndicates the caching policy for successful name lookups from\\n * the name service. The value is specified as as integer to indicate\\n * the number of seconds to cache the successful lookup. The default\\n * setting is to cache for an implementation specific period of time.\\n * \u003cp\u003e\\n * A value of -1 indicates \"cache forever\".\\n * \u003c/dd\u003e\\n * \u003cdt\u003e\u003cb\u003enetworkaddress.cache.negative.ttl\u003c/b\u003e (default: 10)\u003c/dt\u003e\\n * \u003cdd\u003eIndicates the caching policy for un-successful name lookups\\n * from the name service. The value is specified as as integer to\\n * indicate the number of seconds to cache the failure for\\n * un-successful lookups.\\n * \u003cp\u003e\\n * A value of 0 indicates \"never cache\".\\n * A value of -1 indicates \"cache forever\".\\n * \u003c/dd\u003e\\n * \u003c/dl\u003e\\n * \u003c/blockquote\u003e\\n *\\n * @author  Chris Warth\\n * @see     java.net.InetAddress#getByAddress(byte[])\\n * @see     java.net.InetAddress#getByAddress(java.lang.String, byte[])\\n * @see     java.net.InetAddress#getAllByName(java.lang.String)\\n * @see     java.net.InetAddress#getByName(java.lang.String)\\n * @see     java.net.InetAddress#getLocalHost()\\n * @since JDK1.0\\n \u0027}"}, {"color": "#97c2fc", "id": "private Object readResolve() throws ObjectStreamException", "label": "private Object readResolve() throws ObjectStreamException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Replaces the de-serialized object with an Inet4Address object.\\n     *\\n     * @return the alternate object to the de-serialized object.\\n     *\\n     * @throws ObjectStreamException if a new object replacing this\\n     * object could not be created\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isMulticastAddress()", "label": "public boolean isMulticastAddress()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Utility routine to check if the InetAddress is an\\n     * IP multicast address.\\n     * @return a {@code boolean} indicating if the InetAddress is\\n     * an IP multicast address\\n     * @since   JDK1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isAnyLocalAddress()", "label": "public boolean isAnyLocalAddress()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Utility routine to check if the InetAddress in a wildcard address.\\n     * @return a {@code boolean} indicating if the Inetaddress is\\n     *         a wildcard address.\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isLoopbackAddress()", "label": "public boolean isLoopbackAddress()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Utility routine to check if the InetAddress is a loopback address.\\n     *\\n     * @return a {@code boolean} indicating if the InetAddress is\\n     * a loopback address; or false otherwise.\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isLinkLocalAddress()", "label": "public boolean isLinkLocalAddress()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Utility routine to check if the InetAddress is an link local address.\\n     *\\n     * @return a {@code boolean} indicating if the InetAddress is\\n     * a link local address; or false if address is not a link local unicast address.\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isSiteLocalAddress()", "label": "public boolean isSiteLocalAddress()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Utility routine to check if the InetAddress is a site local address.\\n     *\\n     * @return a {@code boolean} indicating if the InetAddress is\\n     * a site local address; or false if address is not a site local unicast address.\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isMCGlobal()", "label": "public boolean isMCGlobal()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Utility routine to check if the multicast address has global scope.\\n     *\\n     * @return a {@code boolean} indicating if the address has\\n     *         is a multicast address of global scope, false if it is not\\n     *         of global scope or it is not a multicast address\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isMCNodeLocal()", "label": "public boolean isMCNodeLocal()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Utility routine to check if the multicast address has node scope.\\n     *\\n     * @return a {@code boolean} indicating if the address has\\n     *         is a multicast address of node-local scope, false if it is not\\n     *         of node-local scope or it is not a multicast address\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isMCLinkLocal()", "label": "public boolean isMCLinkLocal()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Utility routine to check if the multicast address has link scope.\\n     *\\n     * @return a {@code boolean} indicating if the address has\\n     *         is a multicast address of link-local scope, false if it is not\\n     *         of link-local scope or it is not a multicast address\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isMCSiteLocal()", "label": "public boolean isMCSiteLocal()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Utility routine to check if the multicast address has site scope.\\n     *\\n     * @return a {@code boolean} indicating if the address has\\n     *         is a multicast address of site-local scope, false if it is not\\n     *         of site-local scope or it is not a multicast address\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isMCOrgLocal()", "label": "public boolean isMCOrgLocal()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Utility routine to check if the multicast address has organization scope.\\n     *\\n     * @return a {@code boolean} indicating if the address has\\n     *         is a multicast address of organization-local scope,\\n     *         false if it is not of organization-local scope\\n     *         or it is not a multicast address\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isReachable(int timeout) throws IOException", "label": "public boolean isReachable(int timeout) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Test whether that address is reachable. Best effort is made by the\\n     * implementation to try to reach the host, but firewalls and server\\n     * configuration may block requests resulting in a unreachable status\\n     * while some specific ports may be accessible.\\n     * \u003cp\u003e\\n     * Android implementation attempts ICMP ECHO REQUESTs first, on failure it\\n     * will fall back to TCP ECHO REQUESTs. Success on either protocol will\\n     * return true.\\n     * \u003cp\u003e\\n     * The timeout value, in milliseconds, indicates the maximum amount of time\\n     * the try should take. If the operation times out before getting an\\n     * answer, the host is deemed unreachable. A negative value will result\\n     * in an IllegalArgumentException being thrown.\\n     *\\n     * @param   timeout the time, in milliseconds, before the call aborts\\n     * @return a {@code boolean} indicating if the address is reachable.\\n     * @throws IOException if a network error occurs\\n     * @throws  IllegalArgumentException if {@code timeout} is negative.\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isReachable(NetworkInterface netif, int ttl, int timeout) throws IOException", "label": "public boolean isReachable(NetworkInterface netif, int ttl, int timeout) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Test whether that address is reachable. Best effort is made by the\\n     * implementation to try to reach the host, but firewalls and server\\n     * configuration may block requests resulting in a unreachable status\\n     * while some specific ports may be accessible.\\n     * \u003cp\u003e\\n     * Android implementation attempts ICMP ECHO REQUESTs first, on failure it\\n     * will fall back to TCP ECHO REQUESTs. Success on either protocol will\\n     * return true.\\n     * \u003cp\u003e\\n     * The {@code network interface} and {@code ttl} parameters\\n     * let the caller specify which network interface the test will go through\\n     * and the maximum number of hops the packets should go through.\\n     * A negative value for the {@code ttl} will result in an\\n     * IllegalArgumentException being thrown.\\n     * \u003cp\u003e\\n     * The timeout value, in milliseconds, indicates the maximum amount of time\\n     * the try should take. If the operation times out before getting an\\n     * answer, the host is deemed unreachable. A negative value will result\\n     * in an IllegalArgumentException being thrown.\\n     *\\n     * @param   netif   the NetworkInterface through which the\\n     *                    test will be done, or null for any interface\\n     * @param   ttl     the maximum numbers of hops to try or 0 for the\\n     *                  default\\n     * @param   timeout the time, in milliseconds, before the call aborts\\n     * @throws  IllegalArgumentException if either {@code timeout}\\n     *                          or {@code ttl} are negative.\\n     * @return a {@code boolean}indicating if the address is reachable.\\n     * @throws IOException if a network error occurs\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getHostName()", "label": "public String getHostName()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets the host name for this IP address.\\n     *\\n     * \u003cp\u003eIf this InetAddress was created with a host name,\\n     * this host name will be remembered and returned;\\n     * otherwise, a reverse name lookup will be performed\\n     * and the result will be returned based on the system\\n     * configured name lookup service. If a lookup of the name service\\n     * is required, call\\n     * {@link #getCanonicalHostName() getCanonicalHostName}.\\n     *\\n     * \u003cp\u003eIf there is a security manager, its\\n     * {@code checkConnect} method is first called\\n     * with the hostname and {@code -1}\\n     * as its arguments to see if the operation is allowed.\\n     * If the operation is not allowed, it will return\\n     * the textual representation of the IP address.\\n     *\\n     * @return  the host name for this IP address, or if the operation\\n     *    is not allowed by the security check, the textual\\n     *    representation of the IP address.\\n     *\\n     * @see InetAddress#getCanonicalHostName\\n     * @see SecurityManager#checkConnect\\n     \u0027}"}, {"color": "#97c2fc", "id": "getCanonicalHostName()", "label": "getCanonicalHostName()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public String getCanonicalHostName()", "label": "public String getCanonicalHostName()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets the fully qualified domain name for this IP address.\\n     * Best effort method, meaning we may not be able to return\\n     * the FQDN depending on the underlying system configuration.\\n     *\\n     * \u003cp\u003eIf there is a security manager, this method first\\n     * calls its {@code checkConnect} method\\n     * with the hostname and {@code -1}\\n     * as its arguments to see if the calling code is allowed to know\\n     * the hostname for this IP address, i.e., to connect to the host.\\n     * If the operation is not allowed, it will return\\n     * the textual representation of the IP address.\\n     *\\n     * @return  the fully qualified domain name for this IP address,\\n     *    or if the operation is not allowed by the security check,\\n     *    the textual representation of the IP address.\\n     *\\n     * @see SecurityManager#checkConnect\\n     *\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static String getHostFromNameService(InetAddress addr)", "label": "private static String getHostFromNameService(InetAddress addr)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the hostname for this address.\\n     *\\n     * \u003cp\u003eIf there is a security manager, this method first\\n     * calls its {@code checkConnect} method\\n     * with the hostname and {@code -1}\\n     * as its arguments to see if the calling code is allowed to know\\n     * the hostname for this IP address, i.e., to connect to the host.\\n     * If the operation is not allowed, it will return\\n     * the textual representation of the IP address.\\n     *\\n     * @return  the host name for this IP address, or if the operation\\n     *    is not allowed by the security check, the textual\\n     *    representation of the IP address.\\n     *\\n     * @see SecurityManager#checkConnect\\n     \u0027}"}, {"color": "#97c2fc", "id": "public byte[] getAddress()", "label": "public byte[] getAddress()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the raw IP address of this {@code InetAddress}\\n     * object. The result is in network byte order: the highest order\\n     * byte of the address is in {@code getAddress()[0]}.\\n     *\\n     * @return  the raw IP address of this object.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getHostAddress()", "label": "public String getHostAddress()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the IP address string in textual presentation.\\n     *\\n     * @return  the raw IP address in a string format.\\n     * @since   JDK1.0.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static InetAddress getByAddress(String host, byte[] addr) throws UnknownHostException", "label": "public static InetAddress getByAddress(String host, byte[] addr) throws UnknownHostException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates an InetAddress based on the provided host name and IP address.\\n     * No name service is checked for the validity of the address.\\n     *\\n     * \u003cp\u003e The host name can either be a machine name, such as\\n     * \"{@code java.sun.com}\", or a textual representation of its IP\\n     * address.\\n     * \u003cp\u003e No validity checking is done on the host name either.\\n     *\\n     * \u003cp\u003e If addr specifies an IPv4 address an instance of Inet4Address\\n     * will be returned; otherwise, an instance of Inet6Address\\n     * will be returned.\\n     *\\n     * \u003cp\u003e IPv4 address byte array must be 4 bytes long and IPv6 byte array\\n     * must be 16 bytes long\\n     *\\n     * @param host the specified host\\n     * @param addr the raw IP address in network byte order\\n     * @return  an InetAddress object created from the raw IP address.\\n     * @exception  UnknownHostException  if IP address is of illegal length\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static InetAddress getByAddress(String host, byte[] addr, int scopeId) throws UnknownHostException", "label": "private static InetAddress getByAddress(String host, byte[] addr, int scopeId) throws UnknownHostException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Do not delete. Called from native code.\u0027}"}, {"color": "#97c2fc", "id": "public static InetAddress getByName(String host) throws UnknownHostException", "label": "public static InetAddress getByName(String host) throws UnknownHostException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines the IP address of a host, given the host\\\u0027s name.\\n     *\\n     * \u003cp\u003e The host name can either be a machine name, such as\\n     * \"{@code java.sun.com}\", or a textual representation of its\\n     * IP address. If a literal IP address is supplied, only the\\n     * validity of the address format is checked.\\n     *\\n     * \u003cp\u003e For {@code host} specified in literal IPv6 address,\\n     * either the form defined in RFC 2732 or the literal IPv6 address\\n     * format defined in RFC 2373 is accepted. IPv6 scoped addresses are also\\n     * supported. See \u003ca href=\"Inet6Address.html#scoped\"\u003ehere\u003c/a\u003e for a description of IPv6\\n     * scoped addresses.\\n     *\\n     * \u003cp\u003e If the host is {@code null} then an {@code InetAddress}\\n     * representing an address of the loopback interface is returned.\\n     * See \u003ca href=\"http://www.ietf.org/rfc/rfc3330.txt\"\u003eRFC\u0026nbsp;3330\u003c/a\u003e\\n     * section\u0026nbsp;2 and \u003ca href=\"http://www.ietf.org/rfc/rfc2373.txt\"\u003eRFC\u0026nbsp;2373\u003c/a\u003e\\n     * section\u0026nbsp;2.5.3. \u003c/p\u003e\\n     *\\n     * @param      host   the specified host, or {@code null}.\\n     * @return     an IP address for the given host name.\\n     * @exception  UnknownHostException  if no IP address for the\\n     *               {@code host} could be found, or if a scope_id was specified\\n     *               for a global IPv6 address.\\n     * @exception  SecurityException if a security manager exists\\n     *             and its checkConnect method doesn\\\u0027t allow the operation\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static InetAddress[] getAllByName(String host) throws UnknownHostException", "label": "public static InetAddress[] getAllByName(String host) throws UnknownHostException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Given the name of a host, returns an array of its IP addresses,\\n     * based on the configured name service on the system.\\n     *\\n     * \u003cp\u003e The host name can either be a machine name, such as\\n     * \"{@code java.sun.com}\", or a textual representation of its IP\\n     * address. If a literal IP address is supplied, only the\\n     * validity of the address format is checked.\\n     *\\n     * \u003cp\u003e For {@code host} specified in \u003ci\u003eliteral IPv6 address\u003c/i\u003e,\\n     * either the form defined in RFC 2732 or the literal IPv6 address\\n     * format defined in RFC 2373 is accepted. A literal IPv6 address may\\n     * also be qualified by appending a scoped zone identifier or scope_id.\\n     * The syntax and usage of scope_ids is described\\n     * \u003ca href=\"Inet6Address.html#scoped\"\u003ehere\u003c/a\u003e.\\n     * \u003cp\u003e If the host is {@code null} then an {@code InetAddress}\\n     * representing an address of the loopback interface is returned.\\n     * See \u003ca href=\"http://www.ietf.org/rfc/rfc3330.txt\"\u003eRFC\u0026nbsp;3330\u003c/a\u003e\\n     * section\u0026nbsp;2 and \u003ca href=\"http://www.ietf.org/rfc/rfc2373.txt\"\u003eRFC\u0026nbsp;2373\u003c/a\u003e\\n     * section\u0026nbsp;2.5.3. \u003c/p\u003e\\n     *\\n     * \u003cp\u003e If there is a security manager and {@code host} is not\\n     * null and {@code host.length() } is not equal to zero, the\\n     * security manager\\\u0027s\\n     * {@code checkConnect} method is called\\n     * with the hostname and {@code -1}\\n     * as its arguments to see if the operation is allowed.\\n     *\\n     * @param      host   the name of the host, or {@code null}.\\n     * @return     an array of all the IP addresses for a given host name.\\n     *\\n     * @exception  UnknownHostException  if no IP address for the\\n     *               {@code host} could be found, or if a scope_id was specified\\n     *               for a global IPv6 address.\\n     * @exception  SecurityException  if a security manager exists and its\\n     *               {@code checkConnect} method doesn\\\u0027t allow the operation.\\n     *\\n     * @see SecurityManager#checkConnect\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static InetAddress getLoopbackAddress()", "label": "public static InetAddress getLoopbackAddress()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the loopback address.\\n     * \u003cp\u003e\\n     * The InetAddress returned will represent the IPv4\\n     * loopback address, 127.0.0.1, or the IPv6 loopback\\n     * address, ::1. The IPv4 loopback address returned\\n     * is only one of many in the form 127.*.*.*\\n     *\\n     * @return  the InetAddress loopback instance.\\n     * @since 1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static InetAddress getByAddress(byte[] addr) throws UnknownHostException", "label": "public static InetAddress getByAddress(byte[] addr) throws UnknownHostException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns an {@code InetAddress} object given the raw IP address .\\n     * The argument is in network byte order: the highest order\\n     * byte of the address is in {@code getAddress()[0]}.\\n     *\\n     * \u003cp\u003e This method doesn\u0027t block, i.e. no reverse name service lookup\\n     * is performed.\\n     *\\n     * \u003cp\u003e IPv4 address byte array must be 4 bytes long and IPv6 byte array\\n     * must be 16 bytes long\\n     *\\n     * @param addr the raw IP address in network byte order\\n     * @return  an InetAddress object created from the raw IP address.\\n     * @exception  UnknownHostException  if IP address is of illegal length\\n     * @since 1.4\\n     \"}"}, {"color": "#97c2fc", "id": "public static InetAddress getLocalHost() throws UnknownHostException", "label": "public static InetAddress getLocalHost() throws UnknownHostException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the address of the local host. This is achieved by retrieving\\n     * the name of the host from the system, then resolving that name into\\n     * an {@code InetAddress}.\\n     *\\n     * \u003cP\u003eNote: The resolved address may be cached for a short period of time.\\n     * \u003c/P\u003e\\n     *\\n     * \u003cp\u003eIf there is a security manager, its\\n     * {@code checkConnect} method is called\\n     * with the local host name and {@code -1}\\n     * as its arguments to see if the operation is allowed.\\n     * If the operation is not allowed, an InetAddress representing\\n     * the loopback address is returned.\\n     *\\n     * @return     the address of the local host.\\n     *\\n     * @exception  UnknownHostException  if the local host name could not\\n     *             be resolved into an address.\\n     *\\n     * @see SecurityManager#checkConnect\\n     * @see java.net.InetAddress#getByName(java.lang.String)\\n     \u0027}"}, {"color": "#97c2fc", "id": " static InetAddress anyLocalAddress()", "label": " static InetAddress anyLocalAddress()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the InetAddress representing anyLocalAddress\\n     * (typically 0.0.0.0 or ::0)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getPort()", "label": "public int getPort()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the port number of this URI.\\n     *\\n     * \u003cp\u003e The port component of a URI, if defined, is a non-negative\\n     * integer. \u003c/p\u003e\\n     *\\n     * @return  The port component of this URI,\\n     *          or {@code -1} if the port is undefined\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getLocalPort()", "label": "public int getLocalPort()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the port number on the local host to which this socket\\n     * is bound.\\n     *\\n     * @return  the port number on the local host to which this socket is bound,\\n                {@code -1} if the socket is closed, or\\n                {@code 0} if it is not bound yet.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public SocketAddress getRemoteSocketAddress()", "label": "public SocketAddress getRemoteSocketAddress()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the address of the endpoint this socket is connected to, or\\n     * {@code null} if it is unconnected.\\n     * \u003cp\u003e\\n     * If the socket was connected prior to being {@link #close closed},\\n     * then this method will continue to return the connected address\\n     * after the socket is closed.\\n     *\\n     * @return a {@code SocketAddress} representing the remote\\n     *         endpoint of this socket, or {@code null} if it is\\n     *         not connected yet.\\n     * @see #getInetAddress()\\n     * @see #getPort()\\n     * @see #connect(SocketAddress)\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public SocketChannel getChannel()", "label": "public SocketChannel getChannel()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the unique {@link java.nio.channels.SocketChannel SocketChannel}\\n     * object associated with this socket, if any.\\n     *\\n     * \u003cp\u003e A socket will have a channel if, and only if, the channel itself was\\n     * created via the {@link java.nio.channels.SocketChannel#open\\n     * SocketChannel.open} or {@link\\n     * java.nio.channels.ServerSocketChannel#accept ServerSocketChannel.accept}\\n     * methods.\\n     *\\n     * @return  the socket channel associated with this socket,\\n     *          or {@code null} if this socket was not created\\n     *          for a channel\\n     *\\n     * @since 1.4\\n     * @spec JSR-51\\n     \u0027}"}, {"color": "#97c2fc", "id": "accept", "label": "accept", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.channels.ServerSocketChannel", "label": "java.nio.channels.ServerSocketChannel", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public static ServerSocketChannel open() throws IOException", "label": "public static ServerSocketChannel open() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Opens a server-socket channel.\\n     *\\n     * \u003cp\u003e The new channel is created by invoking the {@link\\n     * java.nio.channels.spi.SelectorProvider#openServerSocketChannel\\n     * openServerSocketChannel} method of the system-wide default {@link\\n     * java.nio.channels.spi.SelectorProvider} object.\\n     *\\n     * \u003cp\u003e The new channel\u0027s socket is initially unbound; it must be bound to a\\n     * specific address via one of its socket\u0027s {@link\\n     * java.net.ServerSocket#bind(SocketAddress) bind} methods before\\n     * connections can be accepted.  \u003c/p\u003e\\n     *\\n     * @return  A new socket channel\\n     *\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "bind(SocketAddress)", "label": "bind(SocketAddress)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.net.ServerSocket", "label": "java.net.ServerSocket", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * This class implements server sockets. A server socket waits for\\n * requests to come in over the network. It performs some operation\\n * based on that request, and then possibly returns a result to the requester.\\n * \u003cp\u003e\\n * The actual work of the server socket is performed by an instance\\n * of the {@code SocketImpl} class. An application can\\n * change the socket factory that creates the socket\\n * implementation to configure itself to create sockets\\n * appropriate to the local firewall.\\n *\\n * @author  unascribed\\n * @see     java.net.SocketImpl\\n * @see     java.net.ServerSocket#setSocketFactory(java.net.SocketImplFactory)\\n * @see     java.nio.channels.ServerSocketChannel\\n * @since   1.0\\n \u0027}"}, {"color": "#97c2fc", "id": " void createImpl() throws SocketException", "label": " void createImpl() throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates the socket implementation.\\n     *\\n     * @throws IOException if creation fails\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void bind(SocketAddress endpoint) throws IOException", "label": "public void bind(SocketAddress endpoint) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     *\\n     * Binds the {@code ServerSocket} to a specific address\\n     * (IP address and port number).\\n     * \u003cp\u003e\\n     * If the address is {@code null}, then the system will pick up\\n     * an ephemeral port and a valid local address to bind the socket.\\n     *\\n     * @param   endpoint        The IP address and port number to bind to.\\n     * @throws  IOException if the bind operation fails, or if the socket\\n     *                     is already bound.\\n     * @throws  SecurityException       if a {@code SecurityManager} is present and\\n     * its {@code checkListen} method doesn\u0027t allow the operation.\\n     * @throws  IllegalArgumentException if endpoint is a\\n     *          SocketAddress subclass not supported by this socket\\n     * @since 1.4\\n     \"}"}, {"color": "#97c2fc", "id": "public void bind(SocketAddress endpoint, int backlog) throws IOException", "label": "public void bind(SocketAddress endpoint, int backlog) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     *\\n     * Binds the {@code ServerSocket} to a specific address\\n     * (IP address and port number).\\n     * \u003cp\u003e\\n     * If the address is {@code null}, then the system will pick up\\n     * an ephemeral port and a valid local address to bind the socket.\\n     * \u003cP\u003e\\n     * The {@code backlog} argument is the requested maximum number of\\n     * pending connections on the socket. Its exact semantics are implementation\\n     * specific. In particular, an implementation may impose a maximum length\\n     * or may choose to ignore the parameter altogther. The value provided\\n     * should be greater than {@code 0}. If it is less than or equal to\\n     * {@code 0}, then an implementation specific default will be used.\\n     * @param   endpoint        The IP address and port number to bind to.\\n     * @param   backlog         requested maximum length of the queue of\\n     *                          incoming connections.\\n     * @throws  IOException if the bind operation fails, or if the socket\\n     *                     is already bound.\\n     * @throws  SecurityException       if a {@code SecurityManager} is present and\\n     * its {@code checkListen} method doesn\u0027t allow the operation.\\n     * @throws  IllegalArgumentException if endpoint is a\\n     *          SocketAddress subclass not supported by this socket\\n     * @since 1.4\\n     \"}"}, {"color": "#97c2fc", "id": "public Socket accept() throws IOException", "label": "public Socket accept() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Listens for a connection to be made to this socket and accepts\\n     * it. The method blocks until a connection is made.\\n     *\\n     * \u003cp\u003eA new Socket {@code s} is created and, if there\\n     * is a security manager,\\n     * the security manager\u0027s {@code checkAccept} method is called\\n     * with {@code s.getInetAddress().getHostAddress()} and\\n     * {@code s.getPort()}\\n     * as its arguments to ensure the operation is allowed.\\n     * This could result in a SecurityException.\\n     *\\n     * @exception  IOException  if an I/O error occurs when waiting for a\\n     *               connection.\\n     * @exception  SecurityException  if a security manager exists and its\\n     *             {@code checkAccept} method doesn\u0027t allow the operation.\\n     * @exception  SocketTimeoutException if a timeout was previously set with setSoTimeout and\\n     *             the timeout has been reached.\\n     * @exception  java.nio.channels.IllegalBlockingModeException\\n     *             if this socket has an associated channel, the channel is in\\n     *             non-blocking mode, and there is no connection ready to be\\n     *             accepted\\n     *\\n     * @return the new Socket\\n     * @see SecurityManager#checkAccept\\n     * @revised 1.4\\n     * @spec JSR-51\\n     \"}"}, {"color": "#97c2fc", "id": "protected final void implAccept(Socket s) throws IOException", "label": "protected final void implAccept(Socket s) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Subclasses of ServerSocket use this method to override accept()\\n     * to return their own subclass of socket.  So a FooServerSocket\\n     * will typically hand this method an \u003ci\u003eempty\u003c/i\u003e FooSocket.  On\\n     * return from implAccept the FooSocket will be connected to a client.\\n     *\\n     * @param s the Socket\\n     * @throws java.nio.channels.IllegalBlockingModeException\\n     *         if this socket has an associated channel,\\n     *         and the channel is in non-blocking mode\\n     * @throws IOException if an I/O error occurs when waiting\\n     * for a connection.\\n     * @since   1.1\\n     * @revised 1.4\\n     * @spec JSR-51\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void close() throws IOException", "label": "public void close() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Closes the input stream. Must be called to release any resources\\n     * associated with the stream.\\n     *\\n     * @throws  IOException If an I/O error has occurred.\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.net.SocketException", "label": "java.net.SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Thrown to indicate that there is an error creating or accessing a Socket.\\n *\\n * @author  Jonathan Payne\\n * @since   1.0\\n \u0027}"}, {"color": "#97c2fc", "id": "accept()", "label": "accept()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public ServerSocketChannel getChannel()", "label": "public ServerSocketChannel getChannel()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the unique {@link java.nio.channels.ServerSocketChannel} object\\n     * associated with this socket, if any.\\n     *\\n     * \u003cp\u003e A server socket will have a channel if, and only if, the channel\\n     * itself was created via the {@link\\n     * java.nio.channels.ServerSocketChannel#open ServerSocketChannel.open}\\n     * method.\\n     *\\n     * @return  the server-socket channel associated with this socket,\\n     *          or {@code null} if this socket was not created\\n     *          for a channel\\n     *\\n     * @since 1.4\\n     * @spec JSR-51\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isBound()", "label": "public boolean isBound()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the binding state of the socket.\\n     * \u003cp\u003e\\n     * If the socket was bound prior to being {@link #close closed},\\n     * then this method will continue to return {@code true}\\n     * after the socket is closed.\\n     *\\n     * @return true if the socket successfully bound to an address\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isClosed()", "label": "public boolean isClosed()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns whether the socket is closed or not.\\n     *\\n     * @return true if the socket has been closed\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public synchronized void setSoTimeout(int timeout) throws SocketException", "label": "public synchronized void setSoTimeout(int timeout) throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Enable/disable SO_TIMEOUT with the specified timeout, in\\n     *  milliseconds. With this option set to a non-zero timeout,\\n     *  a call to receive() for this DatagramSocket\\n     *  will block for only this amount of time.  If the timeout expires,\\n     *  a \u003cB\u003ejava.net.SocketTimeoutException\u003c/B\u003e is raised, though the\\n     *  DatagramSocket is still valid.  The option \u003cB\u003emust\u003c/B\u003e be enabled\\n     *  prior to entering the blocking operation to have effect.  The\\n     *  timeout must be {@code \u003e 0}.\\n     *  A timeout of zero is interpreted as an infinite timeout.\\n     *\\n     * @param timeout the specified timeout in milliseconds.\\n     * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.\\n     * @since   1.1\\n     * @see #getSoTimeout()\\n     \u0027}"}, {"color": "#97c2fc", "id": "SO_TIMEOUT", "label": "SO_TIMEOUT", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.net.SocketOptions", "label": "java.net.SocketOptions", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public void setOption(int optID, Object value) throws SocketException", "label": "public void setOption(int optID, Object value) throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Enable/disable the option specified by \u003cI\u003eoptID\u003c/I\u003e.  If the option\\n     * is to be enabled, and it takes an option-specific \"value\",  this is\\n     * passed in \u003cI\u003evalue\u003c/I\u003e.  The actual type of value is option-specific,\\n     * and it is an error to pass something that isn\\\u0027t of the expected type:\\n     * \u003cBR\u003e\u003cPRE\u003e\\n     * SocketImpl s;\\n     * ...\\n     * s.setOption(SO_LINGER, new Integer(10));\\n     *    // OK - set SO_LINGER w/ timeout of 10 sec.\\n     * s.setOption(SO_LINGER, new Double(10));\\n     *    // ERROR - expects java.lang.Integer\\n     *\u003c/PRE\u003e\\n     * If the requested option is binary, it can be set using this method by\\n     * a java.lang.Boolean:\\n     * \u003cBR\u003e\u003cPRE\u003e\\n     * s.setOption(TCP_NODELAY, Boolean.TRUE);\\n     *    // OK - enables TCP_NODELAY, a binary option\\n     * \u003c/PRE\u003e\\n     * \u003cBR\u003e\\n     * Any option can be disabled using this method with a Boolean.FALSE:\\n     * \u003cBR\u003e\u003cPRE\u003e\\n     * s.setOption(TCP_NODELAY, Boolean.FALSE);\\n     *    // OK - disables TCP_NODELAY\\n     * s.setOption(SO_LINGER, Boolean.FALSE);\\n     *    // OK - disables SO_LINGER\\n     * \u003c/PRE\u003e\\n     * \u003cBR\u003e\\n     * For an option that has a notion of on and off, and requires\\n     * a non-boolean parameter, setting its value to anything other than\\n     * \u003cI\u003eBoolean.FALSE\u003c/I\u003e implicitly enables it.\\n     * \u003cBR\u003e\\n     * Throws SocketException if the option is unrecognized,\\n     * the socket is closed, or some low-level error occurred\\n     * \u003cBR\u003e\\n     * @param optID identifies the option\\n     * @param value the parameter of the socket option\\n     * @throws SocketException if the option is unrecognized,\\n     * the socket is closed, or some low-level error occurred\\n     * @see #getOption(int)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Object getOption(int optID) throws SocketException", "label": "public Object getOption(int optID) throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Fetch the value of an option.\\n     * Binary options will return java.lang.Boolean.TRUE\\n     * if enabled, java.lang.Boolean.FALSE if disabled, e.g.:\\n     * \u003cBR\u003e\u003cPRE\u003e\\n     * SocketImpl s;\\n     * ...\\n     * Boolean noDelay = (Boolean)(s.getOption(TCP_NODELAY));\\n     * if (noDelay.booleanValue()) {\\n     *     // true if TCP_NODELAY is enabled...\\n     * ...\\n     * }\\n     * \u003c/PRE\u003e\\n     * \u003cP\u003e\\n     * For options that take a particular type as a parameter,\\n     * getOption(int) will return the parameter\\\u0027s value, else\\n     * it will return java.lang.Boolean.FALSE:\\n     * \u003cPRE\u003e\\n     * Object o = s.getOption(SO_LINGER);\\n     * if (o instanceof Integer) {\\n     *     System.out.print(\"Linger time is \" + ((Integer)o).intValue());\\n     * } else {\\n     *   // the true type of o is java.lang.Boolean.FALSE;\\n     * }\\n     * \u003c/PRE\u003e\\n     *\\n     * @param optID an {@code int} identifying the option to fetch\\n     * @return the value of the option\\n     * @throws SocketException if the socket is closed\\n     * @throws SocketException if \u003cI\u003eoptID\u003c/I\u003e is unknown along the\\n     *         protocol stack (including the SocketImpl)\\n     * @see #setOption(int, java.lang.Object)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public synchronized int getSoTimeout() throws IOException", "label": "public synchronized int getSoTimeout() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Retrieve setting for {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT}.\\n     * 0 returns implies that the option is disabled (i.e., timeout of infinity).\\n     * @return the {@link SocketOptions#SO_TIMEOUT SO_TIMEOUT} value\\n     * @exception IOException if an I/O error occurs\\n     * @since   1.1\\n     * @see #setSoTimeout(int)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void setReuseAddress(boolean on) throws SocketException", "label": "public void setReuseAddress(boolean on) throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Enable/disable the {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}\\n     * socket option.\\n     * \u003cp\u003e\\n     * When a TCP connection is closed the connection may remain\\n     * in a timeout state for a period of time after the connection\\n     * is closed (typically known as the {@code TIME_WAIT} state\\n     * or {@code 2MSL} wait state).\\n     * For applications using a well known socket address or port\\n     * it may not be possible to bind a socket to the required\\n     * {@code SocketAddress} if there is a connection in the\\n     * timeout state involving the socket address or port.\\n     * \u003cp\u003e\\n     * Enabling {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}\\n     * prior to binding the socket using {@link #bind(SocketAddress)} allows\\n     * the socket to be bound even though a previous connection is in a timeout\\n     * state.\\n     * \u003cp\u003e\\n     * When a {@code Socket} is created the initial setting\\n     * of {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is disabled.\\n     * \u003cp\u003e\\n     * The behaviour when {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is\\n     * enabled or disabled after a socket is bound (See {@link #isBound()})\\n     * is not defined.\\n     *\\n     * @param on  whether to enable or disable the socket option\\n     * @exception SocketException if an error occurs enabling or\\n     *            disabling the {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR}\\n     *            socket option, or the socket is closed.\\n     * @since 1.4\\n     * @see #getReuseAddress()\\n     * @see #bind(SocketAddress)\\n     * @see #isClosed()\\n     * @see #isBound()\\n     \u0027}"}, {"color": "#97c2fc", "id": "getReuseAddress()", "label": "getReuseAddress()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "isBound()", "label": "isBound()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public boolean getReuseAddress() throws SocketException", "label": "public boolean getReuseAddress() throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests if {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.\\n     *\\n     * @return a {@code boolean} indicating whether or not\\n     *         {@link SocketOptions#SO_REUSEADDR SO_REUSEADDR} is enabled.\\n     * @exception SocketException if there is an error\\n     * in the underlying protocol, such as a TCP error.\\n     * @since   1.4\\n     * @see #setReuseAddress(boolean)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static synchronized void setSocketFactory(SocketImplFactory fac) throws IOException", "label": "public static synchronized void setSocketFactory(SocketImplFactory fac) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Sets the server socket implementation factory for the\\n     * application. The factory can be specified only once.\\n     * \u003cp\u003e\\n     * When an application creates a new server socket, the socket\\n     * implementation factory\u0027s {@code createSocketImpl} method is\\n     * called to create the actual socket implementation.\\n     * \u003cp\u003e\\n     * Passing {@code null} to the method is a no-op unless the factory\\n     * was already set.\\n     * \u003cp\u003e\\n     * If there is a security manager, this method first calls\\n     * the security manager\u0027s {@code checkSetFactory} method\\n     * to ensure the operation is allowed.\\n     * This could result in a SecurityException.\\n     *\\n     * @param      fac   the desired factory.\\n     * @exception  IOException  if an I/O error occurs when setting the\\n     *               socket factory.\\n     * @exception  SocketException  if the factory has already been defined.\\n     * @exception  SecurityException  if a security manager exists and its\\n     *             {@code checkSetFactory} method doesn\u0027t allow the operation.\\n     * @see        java.net.SocketImplFactory#createSocketImpl()\\n     * @see        SecurityManager#checkSetFactory\\n     \"}"}, {"color": "#97c2fc", "id": "public synchronized void setReceiveBufferSize(int size) throws SocketException", "label": "public synchronized void setReceiveBufferSize(int size) throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the SO_RCVBUF option to the specified value for this\\n     * {@code DatagramSocket}. The SO_RCVBUF option is used by\\n     * the network implementation as a hint to size the underlying\\n     * network I/O buffers. The SO_RCVBUF setting may also be used\\n     * by the network implementation to determine the maximum size\\n     * of the packet that can be received on this socket.\\n     * \u003cp\u003e\\n     * Because SO_RCVBUF is a hint, applications that want to\\n     * verify what size the buffers were set to should call\\n     * {@link #getReceiveBufferSize()}.\\n     * \u003cp\u003e\\n     * Increasing SO_RCVBUF may allow the network implementation\\n     * to buffer multiple packets when packets arrive faster than\\n     * are being received using {@link #receive(DatagramPacket)}.\\n     * \u003cp\u003e\\n     * Note: It is implementation specific if a packet larger\\n     * than SO_RCVBUF can be received.\\n     *\\n     * @param size the size to which to set the receive buffer\\n     * size. This value must be greater than 0.\\n     *\\n     * @exception SocketException if there is an error in\\n     * the underlying protocol, such as an UDP error.\\n     * @exception IllegalArgumentException if the value is 0 or is\\n     * negative.\\n     * @see #getReceiveBufferSize()\\n     \u0027}"}, {"color": "#97c2fc", "id": "public synchronized int getReceiveBufferSize() throws SocketException", "label": "public synchronized int getReceiveBufferSize() throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get value of the SO_RCVBUF option for this {@code DatagramSocket}, that is the\\n     * buffer size used by the platform for input on this {@code DatagramSocket}.\\n     *\\n     * @return the value of the SO_RCVBUF option for this {@code DatagramSocket}\\n     * @exception SocketException if there is an error in the underlying protocol, such as an UDP error.\\n     * @see #setReceiveBufferSize(int)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void setPerformancePreferences(int connectionTime, int latency, int bandwidth)", "label": "public void setPerformancePreferences(int connectionTime, int latency, int bandwidth)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets performance preferences for this socket.\\n     *\\n     * \u003cp\u003e Sockets use the TCP/IP protocol by default.  Some implementations\\n     * may offer alternative protocols which have different performance\\n     * characteristics than TCP/IP.  This method allows the application to\\n     * express its own preferences as to how these tradeoffs should be made\\n     * when the implementation chooses from the available protocols.\\n     *\\n     * \u003cp\u003e Performance preferences are described by three integers\\n     * whose values indicate the relative importance of short connection time,\\n     * low latency, and high bandwidth.  The absolute values of the integers\\n     * are irrelevant; in order to choose a protocol the values are simply\\n     * compared, with larger values indicating stronger preferences. Negative\\n     * values represent a lower priority than positive values. If the\\n     * application prefers short connection time over both low latency and high\\n     * bandwidth, for example, then it could invoke this method with the values\\n     * {@code (1, 0, 0)}.  If the application prefers high bandwidth above low\\n     * latency, and low latency above short connection time, then it could\\n     * invoke this method with the values {@code (0, 1, 2)}.\\n     *\\n     * \u003cp\u003e Invoking this method after this socket has been connected\\n     * will have no effect.\\n     *\\n     * @param  connectionTime\\n     *         An {@code int} expressing the relative importance of a short\\n     *         connection time\\n     *\\n     * @param  latency\\n     *         An {@code int} expressing the relative importance of low\\n     *         latency\\n     *\\n     * @param  bandwidth\\n     *         An {@code int} expressing the relative importance of high\\n     *         bandwidth\\n     *\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ServerSocket setOption(SocketOption\u003cT\u003e name, T value) throws IOException", "label": "public ServerSocket setOption(SocketOption\u003cT\u003e name, T value) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the value of a socket option.\\n     *\\n     * @param \u003cT\u003e The type of the socket option value\\n     * @param name The socket option\\n     * @param value The value of the socket option. A value of {@code null}\\n     *              may be valid for some options.\\n     * @return this ServerSocket\\n     *\\n     * @throws UnsupportedOperationException if the server socket does not\\n     *         support the option.\\n     *\\n     * @throws IllegalArgumentException if the value is not valid for\\n     *         the option.\\n     *\\n     * @throws IOException if an I/O error occurs, or if the socket is closed.\\n     *\\n     * @throws NullPointerException if name is {@code null}\\n     *\\n     * @throws SecurityException if a security manager is set and if the socket\\n     *         option requires a security permission and if the caller does\\n     *         not have the required permission.\\n     *         {@link java.net.StandardSocketOptions StandardSocketOptions}\\n     *         do not require any security permission.\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.net.StandardSocketOptions", "label": "java.net.StandardSocketOptions", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public T getOption(SocketOption\u003cT\u003e name) throws IOException", "label": "public T getOption(SocketOption\u003cT\u003e name) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value of a socket option.\\n     *\\n     * @param \u003cT\u003e The type of the socket option value\\n     * @param name The socket option\\n     *\\n     * @return The value of the socket option.\\n     *\\n     * @throws UnsupportedOperationException if the datagram socket\\n     *         does not support the option.\\n     *\\n     * @throws IOException if an I/O error occurs, or if the socket is closed.\\n     *\\n     * @throws NullPointerException if name is {@code null}\\n     *\\n     * @throws SecurityException if a security manager is set and if the socket\\n     *         option requires a security permission and if the caller does\\n     *         not have the required permission.\\n     *         {@link java.net.StandardSocketOptions StandardSocketOptions}\\n     *         do not require any security permission.\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Set\u003cSocketOption\u003c?\u003e\u003e supportedOptions()", "label": "public Set\u003cSocketOption\u003c?\u003e\u003e supportedOptions()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a set of the socket options supported by this socket.\\n     *\\n     * This method will continue to return the set of options even after\\n     * the socket has been closed.\\n     *\\n     * @return A set of the socket options supported by this socket. This set\\n     *        may be empty if the socket\u0027s DatagramSocketImpl cannot be created.\\n     *\\n     * @since 9\\n     \"}"}, {"color": "#97c2fc", "id": "public final ServerSocketChannel bind(SocketAddress local) throws IOException", "label": "public final ServerSocketChannel bind(SocketAddress local) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Binds the channel\u0027s socket to a local address and configures the socket\\n     * to listen for connections.\\n     *\\n     * \u003cp\u003e An invocation of this method is equivalent to the following:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * bind(local, 0);\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @param   local\\n     *          The local address to bind the socket, or {@code null} to bind\\n     *          to an automatically assigned socket address\\n     *\\n     * @return  This channel\\n     *\\n     * @throws  AlreadyBoundException               {@inheritDoc}\\n     * @throws  UnsupportedAddressTypeException     {@inheritDoc}\\n     * @throws  ClosedChannelException              {@inheritDoc}\\n     * @throws  IOException                         {@inheritDoc}\\n     * @throws  SecurityException\\n     *          If a security manager has been installed and its {@link\\n     *          SecurityManager#checkListen checkListen} method denies the\\n     *          operation\\n     *\\n     * @since 1.7\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract ServerSocketChannel bind(SocketAddress local, int backlog) throws IOException", "label": "public abstract ServerSocketChannel bind(SocketAddress local, int backlog) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Binds the channel\u0027s socket to a local address and configures the socket to\\n     * listen for connections.\\n     *\\n     * \u003cp\u003e This method is used to establish an association between the socket and\\n     * a local address. Once an association is established then the socket remains\\n     * bound until the channel is closed.\\n     *\\n     * \u003cp\u003e The {@code backlog} parameter is the maximum number of pending\\n     * connections on the socket. Its exact semantics are implementation specific.\\n     * In particular, an implementation may impose a maximum length or may choose\\n     * to ignore the parameter altogther. If the {@code backlog} parameter has\\n     * the value {@code 0}, or a negative value, then an implementation specific\\n     * default is used.\\n     *\\n     * @param   local\\n     *          The address to bind the socket, or {@code null} to bind to an\\n     *          automatically assigned socket address\\n     * @param   backlog\\n     *          The maximum number of pending connections\\n     *\\n     * @return  This channel\\n     *\\n     * @throws  AlreadyBoundException\\n     *          If the socket is already bound\\n     * @throws  UnsupportedAddressTypeException\\n     *          If the type of the given address is not supported\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     * @throws  SecurityException\\n     *          If a security manager has been installed and its {@link\\n     *          SecurityManager#checkListen checkListen} method denies the\\n     *          operation\\n     *\\n     * @since 1.7\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract ServerSocketChannel setOption(SocketOption\u003cT\u003e name, T value) throws IOException", "label": "public abstract ServerSocketChannel setOption(SocketOption\u003cT\u003e name, T value) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @throws  UnsupportedOperationException           {@inheritDoc}\\n     * @throws  IllegalArgumentException                {@inheritDoc}\\n     * @throws  ClosedChannelException                  {@inheritDoc}\\n     * @throws  IOException                             {@inheritDoc}\\n     *\\n     * @since 1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract ServerSocket socket()", "label": "public abstract ServerSocket socket()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Retrieves a server socket associated with this channel.\\n     *\\n     * \u003cp\u003e The returned object will not declare any public methods that are not\\n     * declared in the {@link java.net.ServerSocket} class.  \u003c/p\u003e\\n     *\\n     * @return  A server socket associated with this channel\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract SocketChannel accept() throws IOException", "label": "public abstract SocketChannel accept() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Accepts a connection made to this channel\u0027s socket.\\n     *\\n     * \u003cp\u003e If this channel is in non-blocking mode then this method will\\n     * immediately return {@code null} if there are no pending connections.\\n     * Otherwise it will block indefinitely until a new connection is available\\n     * or an I/O error occurs.\\n     *\\n     * \u003cp\u003e The socket channel returned by this method, if any, will be in\\n     * blocking mode regardless of the blocking mode of this channel.\\n     *\\n     * \u003cp\u003e This method performs exactly the same security checks as the {@link\\n     * java.net.ServerSocket#accept accept} method of the {@link\\n     * java.net.ServerSocket} class.  That is, if a security manager has been\\n     * installed then for each new connection this method verifies that the\\n     * address and port number of the connection\u0027s remote endpoint are\\n     * permitted by the security manager\u0027s {@link\\n     * java.lang.SecurityManager#checkAccept checkAccept} method.  \u003c/p\u003e\\n     *\\n     * @return  The socket channel for the new connection,\\n     *          or {@code null} if this channel is in non-blocking mode\\n     *          and no connection is available to be accepted\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     *\\n     * @throws  AsynchronousCloseException\\n     *          If another thread closes this channel\\n     *          while the accept operation is in progress\\n     *\\n     * @throws  ClosedByInterruptException\\n     *          If another thread interrupts the current thread\\n     *          while the accept operation is in progress, thereby\\n     *          closing the channel and setting the current thread\u0027s\\n     *          interrupt status\\n     *\\n     * @throws  NotYetBoundException\\n     *          If this channel\u0027s socket has not yet been bound\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager has been installed\\n     *          and it does not permit access to the remote endpoint\\n     *          of the new connection\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "checkAccept", "label": "checkAccept", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.lang.SecurityManager", "label": "java.lang.SecurityManager", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \"\\n * Legacy security code; do not use.\\n *\\n * \u003cp\u003eSecurity managers do \u003ci\u003enot\u003c/i\u003e provide a secure environment for\\n * executing untrusted code and are unsupported on Android. Untrusted code\\n * cannot be safely isolated within a single VM on Android. Application\\n * developers can assume that there\u0027s no SecurityManager installed,\\n * i.e. {@link java.lang.System#getSecurityManager()} will return null.\\n \"}"}, {"color": "#97c2fc", "id": "public ThreadGroup getThreadGroup()", "label": "public ThreadGroup getThreadGroup()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the current thread\u0027s thread group.\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract SocketAddress getLocalAddress() throws IOException", "label": "public abstract SocketAddress getLocalAddress() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * {@inheritDoc}\\n     * \u003cp\u003e\\n     * If there is a security manager set, its {@code checkConnect} method is\\n     * called with the local address and {@code -1} as its arguments to see\\n     * if the operation is allowed. If the operation is not allowed,\\n     * a {@code SocketAddress} representing the\\n     * {@link java.net.InetAddress#getLoopbackAddress loopback} address and the\\n     * local port of the channel\u0027s socket is returned.\\n     *\\n     * @return  The {@code SocketAddress} that the socket is bound to, or the\\n     *          {@code SocketAddress} representing the loopback address if\\n     *          denied by the security manager, or {@code null} if the\\n     *          channel\u0027s socket is not bound\\n     *\\n     * @throws  ClosedChannelException     {@inheritDoc}\\n     * @throws  IOException                {@inheritDoc}\\n     \"}"}, {"color": "#97c2fc", "id": "public InputStream getInputStream() throws IOException", "label": "public InputStream getInputStream() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns an input stream for this socket.\\n     *\\n     * \u003cp\u003e If this socket has an associated channel then the resulting input\\n     * stream delegates all of its operations to the channel.  If the channel\\n     * is in non-blocking mode then the input stream\u0027s {@code read} operations\\n     * will throw an {@link java.nio.channels.IllegalBlockingModeException}.\\n     *\\n     * \u003cp\u003eUnder abnormal conditions the underlying connection may be\\n     * broken by the remote host or the network software (for example\\n     * a connection reset in the case of TCP connections). When a\\n     * broken connection is detected by the network software the\\n     * following applies to the returned input stream :-\\n     *\\n     * \u003cul\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003eThe network software may discard bytes that are buffered\\n     *   by the socket. Bytes that aren\u0027t discarded by the network\\n     *   software can be read using {@link java.io.InputStream#read read}.\\n     *\\n     *   \u003cli\u003e\u003cp\u003eIf there are no bytes buffered on the socket, or all\\n     *   buffered bytes have been consumed by\\n     *   {@link java.io.InputStream#read read}, then all subsequent\\n     *   calls to {@link java.io.InputStream#read read} will throw an\\n     *   {@link java.io.IOException IOException}.\\n     *\\n     *   \u003cli\u003e\u003cp\u003eIf there are no bytes buffered on the socket, and the\\n     *   socket has not been closed using {@link #close close}, then\\n     *   {@link java.io.InputStream#available available} will\\n     *   return {@code 0}.\\n     *\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003e Closing the returned {@link java.io.InputStream InputStream}\\n     * will close the associated socket.\\n     *\\n     * @return     an input stream for reading bytes from this socket.\\n     * @exception  IOException  if an I/O error occurs when creating the\\n     *             input stream, the socket is closed, the socket is\\n     *             not connected, or the socket input has been shutdown\\n     *             using {@link #shutdownInput()}\\n     *\\n     * @revised 1.4\\n     * @spec JSR-51\\n     \"}"}, {"color": "#97c2fc", "id": "java.nio.channels.IllegalBlockingModeException", "label": "java.nio.channels.IllegalBlockingModeException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "read", "label": "read", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.io.InputStream", "label": "java.io.InputStream", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * This abstract class is the superclass of all classes representing\\n * an input stream of bytes.\\n *\\n * \u003cp\u003e Applications that need to define a subclass of {@code InputStream}\\n * must always provide a method that returns the next byte of input.\\n *\\n * @author  Arthur van Hoff\\n * @see     java.io.BufferedInputStream\\n * @see     java.io.ByteArrayInputStream\\n * @see     java.io.DataInputStream\\n * @see     java.io.FilterInputStream\\n * @see     java.io.InputStream#read()\\n * @see     java.io.OutputStream\\n * @see     java.io.PushbackInputStream\\n * @since   1.0\\n \u0027}"}, {"color": "#97c2fc", "id": "public static InputStream nullInputStream()", "label": "public static InputStream nullInputStream()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a new {@code InputStream} that reads no bytes. The returned\\n     * stream is initially open.  The stream is closed by calling the\\n     * {@code close()} method.  Subsequent calls to {@code close()} have no\\n     * effect.\\n     *\\n     * \u003cp\u003e While the stream is open, the {@code available()}, {@code read()},\\n     * {@code read(byte[])}, {@code read(byte[], int, int)},\\n     * {@code readAllBytes()}, {@code readNBytes(byte[], int, int)},\\n     * {@code readNBytes(int)}, {@code skip(long)}, {@code skipNBytes(long)},\\n     * and {@code transferTo()} methods all behave as if end of stream has been\\n     * reached.  After the stream has been closed, these methods all throw\\n     * {@code IOException}.\\n     *\\n     * \u003cp\u003e The {@code markSupported()} method returns {@code false}.  The\\n     * {@code mark()} method does nothing, and the {@code reset()} method\\n     * throws {@code IOException}.\\n     *\\n     * @return an {@code InputStream} which contains no bytes\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract int read() throws IOException", "label": "public abstract int read() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads the next byte of data from the input stream. The value byte is\\n     * returned as an {@code int} in the range {@code 0} to\\n     * {@code 255}. If no byte is available because the end of the stream\\n     * has been reached, the value {@code -1} is returned. This method\\n     * blocks until input data is available, the end of the stream is detected,\\n     * or an exception is thrown.\\n     *\\n     * \u003cp\u003e A subclass must provide an implementation of this method.\\n     *\\n     * @return     the next byte of data, or {@code -1} if the end of the\\n     *             stream is reached.\\n     * @throws     IOException  if an I/O error occurs.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int read(byte[] b) throws IOException", "label": "public int read(byte[] b) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads some number of bytes from the input stream and stores them into\\n     * the buffer array {@code b}. The number of bytes actually read is\\n     * returned as an integer.  This method blocks until input data is\\n     * available, end of file is detected, or an exception is thrown.\\n     *\\n     * \u003cp\u003e If the length of {@code b} is zero, then no bytes are read and\\n     * {@code 0} is returned; otherwise, there is an attempt to read at\\n     * least one byte. If no byte is available because the stream is at the\\n     * end of the file, the value {@code -1} is returned; otherwise, at\\n     * least one byte is read and stored into {@code b}.\\n     *\\n     * \u003cp\u003e The first byte read is stored into element {@code b[0]}, the\\n     * next one into {@code b[1]}, and so on. The number of bytes read is,\\n     * at most, equal to the length of {@code b}. Let \u003ci\u003ek\u003c/i\u003e be the\\n     * number of bytes actually read; these bytes will be stored in elements\\n     * {@code b[0]} through {@code b[}\u003ci\u003ek\u003c/i\u003e{@code -1]},\\n     * leaving elements {@code b[}\u003ci\u003ek\u003c/i\u003e{@code ]} through\\n     * {@code b[b.length-1]} unaffected.\\n     *\\n     * \u003cp\u003e The {@code read(b)} method for class {@code InputStream}\\n     * has the same effect as: \u003cpre\u003e{@code  read(b, 0, b.length) }\u003c/pre\u003e\\n     *\\n     * @param      b   the buffer into which the data is read.\\n     * @return     the total number of bytes read into the buffer, or\\n     *             {@code -1} if there is no more data because the end of\\n     *             the stream has been reached.\\n     * @throws     IOException  If the first byte cannot be read for any reason\\n     *             other than the end of the file, if the input stream has been\\n     *             closed, or if some other I/O error occurs.\\n     * @throws     NullPointerException  if {@code b} is {@code null}.\\n     * @see        java.io.InputStream#read(byte[], int, int)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int read(byte[] b, int off, int len) throws IOException", "label": "public int read(byte[] b, int off, int len) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads up to {@code len} bytes of data from the input stream into\\n     * an array of bytes.  An attempt is made to read as many as\\n     * {@code len} bytes, but a smaller number may be read.\\n     * The number of bytes actually read is returned as an integer.\\n     *\\n     * \u003cp\u003e This method blocks until input data is available, end of file is\\n     * detected, or an exception is thrown.\\n     *\\n     * \u003cp\u003e If {@code len} is zero, then no bytes are read and\\n     * {@code 0} is returned; otherwise, there is an attempt to read at\\n     * least one byte. If no byte is available because the stream is at end of\\n     * file, the value {@code -1} is returned; otherwise, at least one\\n     * byte is read and stored into {@code b}.\\n     *\\n     * \u003cp\u003e The first byte read is stored into element {@code b[off]}, the\\n     * next one into {@code b[off+1]}, and so on. The number of bytes read\\n     * is, at most, equal to {@code len}. Let \u003ci\u003ek\u003c/i\u003e be the number of\\n     * bytes actually read; these bytes will be stored in elements\\n     * {@code b[off]} through {@code b[off+}\u003ci\u003ek\u003c/i\u003e{@code -1]},\\n     * leaving elements {@code b[off+}\u003ci\u003ek\u003c/i\u003e{@code ]} through\\n     * {@code b[off+len-1]} unaffected.\\n     *\\n     * \u003cp\u003e In every case, elements {@code b[0]} through\\n     * {@code b[off-1]} and elements {@code b[off+len]} through\\n     * {@code b[b.length-1]} are unaffected.\\n     *\\n     * \u003cp\u003e The {@code read(b, off, len)} method\\n     * for class {@code InputStream} simply calls the method\\n     * {@code read()} repeatedly. If the first such call results in an\\n     * {@code IOException}, that exception is returned from the call to\\n     * the {@code read(b,} {@code off,} {@code len)} method.  If\\n     * any subsequent call to {@code read()} results in a\\n     * {@code IOException}, the exception is caught and treated as if it\\n     * were end of file; the bytes read up to that point are stored into\\n     * {@code b} and the number of bytes read before the exception\\n     * occurred is returned. The default implementation of this method blocks\\n     * until the requested amount of input data {@code len} has been read,\\n     * end of file is detected, or an exception is thrown. Subclasses are\\n     * encouraged to provide a more efficient implementation of this method.\\n     *\\n     * @param      b     the buffer into which the data is read.\\n     * @param      off   the start offset in array {@code b}\\n     *                   at which the data is written.\\n     * @param      len   the maximum number of bytes to read.\\n     * @return     the total number of bytes read into the buffer, or\\n     *             {@code -1} if there is no more data because the end of\\n     *             the stream has been reached.\\n     * @throws     IOException If the first byte cannot be read for any reason\\n     *             other than end of file, or if the input stream has been closed,\\n     *             or if some other I/O error occurs.\\n     * @throws     NullPointerException If {@code b} is {@code null}.\\n     * @throws     IndexOutOfBoundsException If {@code off} is negative,\\n     *             {@code len} is negative, or {@code len} is greater than\\n     *             {@code b.length - off}\\n     * @see        java.io.InputStream#read()\\n     \u0027}"}, {"color": "#97c2fc", "id": "public byte[] readAllBytes() throws IOException", "label": "public byte[] readAllBytes() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads all remaining bytes from the input stream. This method blocks until\\n     * all remaining bytes have been read and end of stream is detected, or an\\n     * exception is thrown. This method does not close the input stream.\\n     *\\n     * \u003cp\u003e When this stream reaches end of stream, further invocations of this\\n     * method will return an empty byte array.\\n     *\\n     * \u003cp\u003e Note that this method is intended for simple cases where it is\\n     * convenient to read all bytes into a byte array. It is not intended for\\n     * reading input streams with large amounts of data.\\n     *\\n     * \u003cp\u003e The behavior for the case where the input stream is \u003ci\u003easynchronously\\n     * closed\u003c/i\u003e, or the thread interrupted during the read, is highly input\\n     * stream specific, and therefore not specified.\\n     *\\n     * \u003cp\u003e If an I/O error occurs reading from the input stream, then it may do\\n     * so after some, but not all, bytes have been read. Consequently the input\\n     * stream may not be at end of stream and may be in an inconsistent state.\\n     * It is strongly recommended that the stream be promptly closed if an I/O\\n     * error occurs.\\n     *\\n     * @implSpec\\n     * This method invokes {@link #readNBytes(int)} with a length of\\n     * {@link Integer#MAX_VALUE}.\\n     *\\n     * @return a byte array containing the bytes read from this input stream\\n     * @throws IOException if an I/O error occurs\\n     * @throws OutOfMemoryError if an array of the required size cannot be\\n     *         allocated.\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "readNBytes(int)", "label": "readNBytes(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public byte[] readNBytes(int len) throws IOException", "label": "public byte[] readNBytes(int len) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads up to a specified number of bytes from the input stream. This\\n     * method blocks until the requested number of bytes has been read, end\\n     * of stream is detected, or an exception is thrown. This method does not\\n     * close the input stream.\\n     *\\n     * \u003cp\u003e The length of the returned array equals the number of bytes read\\n     * from the stream. If {@code len} is zero, then no bytes are read and\\n     * an empty byte array is returned. Otherwise, up to {@code len} bytes\\n     * are read from the stream. Fewer than {@code len} bytes may be read if\\n     * end of stream is encountered.\\n     *\\n     * \u003cp\u003e When this stream reaches end of stream, further invocations of this\\n     * method will return an empty byte array.\\n     *\\n     * \u003cp\u003e Note that this method is intended for simple cases where it is\\n     * convenient to read the specified number of bytes into a byte array. The\\n     * total amount of memory allocated by this method is proportional to the\\n     * number of bytes read from the stream which is bounded by {@code len}.\\n     * Therefore, the method may be safely called with very large values of\\n     * {@code len} provided sufficient memory is available.\\n     *\\n     * \u003cp\u003e The behavior for the case where the input stream is \u003ci\u003easynchronously\\n     * closed\u003c/i\u003e, or the thread interrupted during the read, is highly input\\n     * stream specific, and therefore not specified.\\n     *\\n     * \u003cp\u003e If an I/O error occurs reading from the input stream, then it may do\\n     * so after some, but not all, bytes have been read. Consequently the input\\n     * stream may not be at end of stream and may be in an inconsistent state.\\n     * It is strongly recommended that the stream be promptly closed if an I/O\\n     * error occurs.\\n     *\\n     * @implNote\\n     * The number of bytes allocated to read data from this stream and return\\n     * the result is bounded by {@code 2*(long)len}, inclusive.\\n     *\\n     * @param len the maximum number of bytes to read\\n     * @return a byte array containing the bytes read from this input stream\\n     * @throws IllegalArgumentException if {@code length} is negative\\n     * @throws IOException if an I/O error occurs\\n     * @throws OutOfMemoryError if an array of the required size cannot be\\n     *         allocated.\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int readNBytes(byte[] b, int off, int len) throws IOException", "label": "public int readNBytes(byte[] b, int off, int len) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads the requested number of bytes from the input stream into the given\\n     * byte array. This method blocks until {@code len} bytes of input data have\\n     * been read, end of stream is detected, or an exception is thrown. The\\n     * number of bytes actually read, possibly zero, is returned. This method\\n     * does not close the input stream.\\n     *\\n     * \u003cp\u003e In the case where end of stream is reached before {@code len} bytes\\n     * have been read, then the actual number of bytes read will be returned.\\n     * When this stream reaches end of stream, further invocations of this\\n     * method will return zero.\\n     *\\n     * \u003cp\u003e If {@code len} is zero, then no bytes are read and {@code 0} is\\n     * returned; otherwise, there is an attempt to read up to {@code len} bytes.\\n     *\\n     * \u003cp\u003e The first byte read is stored into element {@code b[off]}, the next\\n     * one in to {@code b[off+1]}, and so on. The number of bytes read is, at\\n     * most, equal to {@code len}. Let \u003ci\u003ek\u003c/i\u003e be the number of bytes actually\\n     * read; these bytes will be stored in elements {@code b[off]} through\\n     * {@code b[off+}\u003ci\u003ek\u003c/i\u003e{@code -1]}, leaving elements {@code b[off+}\u003ci\u003ek\u003c/i\u003e\\n     * {@code ]} through {@code b[off+len-1]} unaffected.\\n     *\\n     * \u003cp\u003e The behavior for the case where the input stream is \u003ci\u003easynchronously\\n     * closed\u003c/i\u003e, or the thread interrupted during the read, is highly input\\n     * stream specific, and therefore not specified.\\n     *\\n     * \u003cp\u003e If an I/O error occurs reading from the input stream, then it may do\\n     * so after some, but not all, bytes of {@code b} have been updated with\\n     * data from the input stream. Consequently the input stream and {@code b}\\n     * may be in an inconsistent state. It is strongly recommended that the\\n     * stream be promptly closed if an I/O error occurs.\\n     *\\n     * @param  b the byte array into which the data is read\\n     * @param  off the start offset in {@code b} at which the data is written\\n     * @param  len the maximum number of bytes to read\\n     * @return the actual number of bytes read into the buffer\\n     * @throws IOException if an I/O error occurs\\n     * @throws NullPointerException if {@code b} is {@code null}\\n     * @throws IndexOutOfBoundsException If {@code off} is negative, {@code len}\\n     *         is negative, or {@code len} is greater than {@code b.length - off}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void skipNBytes(long n) throws IOException", "label": "public void skipNBytes(long n) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Skips over and discards exactly {@code n} bytes of data from this input\\n     * stream.  If {@code n} is zero, then no bytes are skipped.\\n     * If {@code n} is negative, then no bytes are skipped.\\n     * Subclasses may handle the negative value differently.\\n     *\\n     * \u003cp\u003e This method blocks until the requested number of bytes has been\\n     * skipped, end of file is reached, or an exception is thrown.\\n     *\\n     * \u003cp\u003e If end of stream is reached before the stream is at the desired\\n     * position, then an {@code EOFException} is thrown.\\n     *\\n     * \u003cp\u003e If an I/O error occurs, then the input stream may be\\n     * in an inconsistent state. It is strongly recommended that the\\n     * stream be promptly closed if an I/O error occurs.\\n     *\\n     * @implNote\\n     * Subclasses are encouraged to provide a more efficient implementation\\n     * of this method.\\n     *\\n     * @implSpec\\n     * If {@code n} is zero or negative, then no bytes are skipped.\\n     * If {@code n} is positive, the default implementation of this method\\n     * invokes {@link #skip(long) skip()} repeatedly with its parameter equal\\n     * to the remaining number of bytes to skip until the requested number\\n     * of bytes has been skipped or an error condition occurs.  If at any\\n     * point the return value of {@code skip()} is negative or greater than the\\n     * remaining number of bytes to be skipped, then an {@code IOException} is\\n     * thrown.  If {@code skip()} ever returns zero, then {@link #read()} is\\n     * invoked to read a single byte, and if it returns {@code -1}, then an\\n     * {@code EOFException} is thrown.  Any exception thrown by {@code skip()}\\n     * or {@code read()} will be propagated.\\n     *\\n     * @param      n   the number of bytes to be skipped.\\n     * @throws     EOFException if end of stream is encountered before the\\n     *             stream can be positioned {@code n} bytes beyond its position\\n     *             when this method was invoked.\\n     * @throws     IOException  if the stream cannot be positioned properly or\\n     *             if an I/O error occurs.\\n     * @see        java.io.InputStream#skip(long)\\n     *\\n     * @since 12\\n     \u0027}"}, {"color": "#97c2fc", "id": "read()", "label": "read()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "skip(long)", "label": "skip(long)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public int available() throws IOException", "label": "public int available() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the number of bytes that can be read without blocking.\\n     *\\n     * @return  the number of available bytes.\\n     * @throws  IOException if there are I/O errors while reading from the\\n     *          underlying \u003ccode\u003eInputStream\u003c/code\u003e\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.io.IOException", "label": "java.io.IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Signals that an I/O exception of some sort has occurred. This\\n * class is the general class of exceptions produced by failed or\\n * interrupted I/O operations.\\n *\\n * @see     java.io.InputStream\\n * @see     java.io.OutputStream\\n * @since   1.0\\n \u0027}"}, {"color": "#97c2fc", "id": "public synchronized void mark(int readlimit)", "label": "public synchronized void mark(int readlimit)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Marks the current position in this input stream. A subsequent call to\\n     * the {@code reset} method repositions this stream at the last marked\\n     * position so that subsequent reads re-read the same bytes.\\n     *\\n     * \u003cp\u003e The {@code readlimit} arguments tells this input stream to\\n     * allow that many bytes to be read before the mark position gets\\n     * invalidated.\\n     *\\n     * \u003cp\u003e The general contract of {@code mark} is that, if the method\\n     * {@code markSupported} returns {@code true}, the stream somehow\\n     * remembers all the bytes read after the call to {@code mark} and\\n     * stands ready to supply those same bytes again if and whenever the method\\n     * {@code reset} is called.  However, the stream is not required to\\n     * remember any data at all if more than {@code readlimit} bytes are\\n     * read from the stream before {@code reset} is called.\\n     *\\n     * \u003cp\u003e Marking a closed stream should not have any effect on the stream.\\n     *\\n     * \u003cp\u003e The {@code mark} method of {@code InputStream} does\\n     * nothing.\\n     *\\n     * @param   readlimit   the maximum limit of bytes that can be read before\\n     *                      the mark position becomes invalid.\\n     * @see     java.io.InputStream#reset()\\n     \u0027}"}, {"color": "#97c2fc", "id": "public synchronized void reset() throws IOException", "label": "public synchronized void reset() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Repositions this stream to the position at the time the\\n     * {@code mark} method was last called on this input stream.\\n     *\\n     * \u003cp\u003e The general contract of {@code reset} is:\\n     *\\n     * \u003cul\u003e\\n     * \u003cli\u003e If the method {@code markSupported} returns\\n     * {@code true}, then:\\n     *\\n     *     \u003cul\u003e\u003cli\u003e If the method {@code mark} has not been called since\\n     *     the stream was created, or the number of bytes read from the stream\\n     *     since {@code mark} was last called is larger than the argument\\n     *     to {@code mark} at that last call, then an\\n     *     {@code IOException} might be thrown.\\n     *\\n     *     \u003cli\u003e If such an {@code IOException} is not thrown, then the\\n     *     stream is reset to a state such that all the bytes read since the\\n     *     most recent call to {@code mark} (or since the start of the\\n     *     file, if {@code mark} has not been called) will be resupplied\\n     *     to subsequent callers of the {@code read} method, followed by\\n     *     any bytes that otherwise would have been the next input data as of\\n     *     the time of the call to {@code reset}. \u003c/ul\u003e\\n     *\\n     * \u003cli\u003e If the method {@code markSupported} returns\\n     * {@code false}, then:\\n     *\\n     *     \u003cul\u003e\u003cli\u003e The call to {@code reset} may throw an\\n     *     {@code IOException}.\\n     *\\n     *     \u003cli\u003e If an {@code IOException} is not thrown, then the stream\\n     *     is reset to a fixed state that depends on the particular type of the\\n     *     input stream and how it was created. The bytes that will be supplied\\n     *     to subsequent callers of the {@code read} method depend on the\\n     *     particular type of the input stream. \u003c/ul\u003e\u003c/ul\u003e\\n     *\\n     * \u003cp\u003eThe method {@code reset} for class {@code InputStream}\\n     * does nothing except throw an {@code IOException}.\\n     *\\n     * @throws  IOException  if this stream has not been marked or if the\\n     *          mark has been invalidated.\\n     * @see     java.io.InputStream#mark(int)\\n     * @see     java.io.IOException\\n     \u0027}"}, {"color": "#97c2fc", "id": "public long transferTo(OutputStream out) throws IOException", "label": "public long transferTo(OutputStream out) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads all bytes from this input stream and writes the bytes to the\\n     * given output stream in the order that they are read. On return, this\\n     * input stream will be at end of stream. This method does not close either\\n     * stream.\\n     * \u003cp\u003e\\n     * This method may block indefinitely reading from the input stream, or\\n     * writing to the output stream. The behavior for the case where the input\\n     * and/or output stream is \u003ci\u003easynchronously closed\u003c/i\u003e, or the thread\\n     * interrupted during the transfer, is highly input and output stream\\n     * specific, and therefore not specified.\\n     * \u003cp\u003e\\n     * If an I/O error occurs reading from the input stream or writing to the\\n     * output stream, then it may do so after some bytes have been read or\\n     * written. Consequently the input stream may not be at end of stream and\\n     * one, or both, streams may be in an inconsistent state. It is strongly\\n     * recommended that both streams be promptly closed if an I/O error occurs.\\n     *\\n     * @param  out the output stream, non-null\\n     * @return the number of bytes transferred\\n     * @throws IOException if an I/O error occurs when reading or writing\\n     * @throws NullPointerException if {@code out} is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "shutdownInput()", "label": "shutdownInput()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public OutputStream getOutputStream() throws IOException", "label": "public OutputStream getOutputStream() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns an output stream for this socket.\\n     *\\n     * \u003cp\u003e If this socket has an associated channel then the resulting output\\n     * stream delegates all of its operations to the channel.  If the channel\\n     * is in non-blocking mode then the output stream\u0027s {@code write}\\n     * operations will throw an {@link\\n     * java.nio.channels.IllegalBlockingModeException}.\\n     *\\n     * \u003cp\u003e Closing the returned {@link java.io.OutputStream OutputStream}\\n     * will close the associated socket.\\n     *\\n     * @return     an output stream for writing bytes to this socket.\\n     * @exception  IOException  if an I/O error occurs when creating the\\n     *               output stream or if the socket is not connected.\\n     * @revised 1.4\\n     * @spec JSR-51\\n     \"}"}, {"color": "#97c2fc", "id": "java.io.OutputStream", "label": "java.io.OutputStream", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * This abstract class is the superclass of all classes representing\\n * an output stream of bytes. An output stream accepts output bytes\\n * and sends them to some sink.\\n * \u003cp\u003e\\n * Applications that need to define a subclass of\\n * {@code OutputStream} must always provide at least a method\\n * that writes one byte of output.\\n *\\n * @author  Arthur van Hoff\\n * @see     java.io.BufferedOutputStream\\n * @see     java.io.ByteArrayOutputStream\\n * @see     java.io.DataOutputStream\\n * @see     java.io.FilterOutputStream\\n * @see     java.io.InputStream\\n * @see     java.io.OutputStream#write(int)\\n * @since   1.0\\n \u0027}"}, {"color": "#97c2fc", "id": "public static OutputStream nullOutputStream()", "label": "public static OutputStream nullOutputStream()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a new {@code OutputStream} which discards all bytes.  The\\n     * returned stream is initially open.  The stream is closed by calling\\n     * the {@code close()} method.  Subsequent calls to {@code close()} have\\n     * no effect.\\n     *\\n     * \u003cp\u003e While the stream is open, the {@code write(int)}, {@code\\n     * write(byte[])}, and {@code write(byte[], int, int)} methods do nothing.\\n     * After the stream has been closed, these methods all throw {@code\\n     * IOException}.\\n     *\\n     * \u003cp\u003e The {@code flush()} method does nothing.\\n     *\\n     * @return an {@code OutputStream} which discards all bytes\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract void write(int b) throws IOException", "label": "public abstract void write(int b) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes the specified byte to this output stream. The general\\n     * contract for {@code write} is that one byte is written\\n     * to the output stream. The byte to be written is the eight\\n     * low-order bits of the argument {@code b}. The 24\\n     * high-order bits of {@code b} are ignored.\\n     * \u003cp\u003e\\n     * Subclasses of {@code OutputStream} must provide an\\n     * implementation for this method.\\n     *\\n     * @param      b   the {@code byte}.\\n     * @throws     IOException  if an I/O error occurs. In particular,\\n     *             an {@code IOException} may be thrown if the\\n     *             output stream has been closed.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void write(byte[] b) throws IOException", "label": "public void write(byte[] b) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes {@code b.length} bytes from the specified byte array\\n     * to this output stream. The general contract for {@code write(b)}\\n     * is that it should have exactly the same effect as the call\\n     * {@code write(b, 0, b.length)}.\\n     *\\n     * @param      b   the data.\\n     * @throws     IOException  if an I/O error occurs.\\n     * @see        java.io.OutputStream#write(byte[], int, int)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void write(byte[] b, int off, int len) throws IOException", "label": "public void write(byte[] b, int off, int len) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes {@code len} bytes from the specified byte array\\n     * starting at offset {@code off} to this output stream.\\n     * The general contract for {@code write(b, off, len)} is that\\n     * some of the bytes in the array {@code b} are written to the\\n     * output stream in order; element {@code b[off]} is the first\\n     * byte written and {@code b[off+len-1]} is the last byte written\\n     * by this operation.\\n     * \u003cp\u003e\\n     * The {@code write} method of {@code OutputStream} calls\\n     * the write method of one argument on each of the bytes to be\\n     * written out. Subclasses are encouraged to override this method and\\n     * provide a more efficient implementation.\\n     * \u003cp\u003e\\n     * If {@code b} is {@code null}, a\\n     * {@code NullPointerException} is thrown.\\n     * \u003cp\u003e\\n     * If {@code off} is negative, or {@code len} is negative, or\\n     * {@code off+len} is greater than the length of the array\\n     * {@code b}, then an {@code IndexOutOfBoundsException} is thrown.\\n     *\\n     * @param      b     the data.\\n     * @param      off   the start offset in the data.\\n     * @param      len   the number of bytes to write.\\n     * @throws     IOException  if an I/O error occurs. In particular,\\n     *             an {@code IOException} is thrown if the output\\n     *             stream is closed.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void flush() throws IOException", "label": "public void flush() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Flushes the stream. This will write any buffered output bytes and flush\\n     * through to the underlying stream.\\n     *\\n     * @throws  IOException If an I/O error has occurred.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void setTcpNoDelay(boolean on) throws SocketException", "label": "public void setTcpNoDelay(boolean on) throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Enable/disable {@link SocketOptions#TCP_NODELAY TCP_NODELAY}\\n     * (disable/enable Nagle\u0027s algorithm).\\n     *\\n     * @param on {@code true} to enable TCP_NODELAY,\\n     * {@code false} to disable.\\n     *\\n     * @exception SocketException if there is an error\\n     * in the underlying protocol, such as a TCP error.\\n     *\\n     * @since   1.1\\n     *\\n     * @see #getTcpNoDelay()\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean getTcpNoDelay() throws SocketException", "label": "public boolean getTcpNoDelay() throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests if {@link SocketOptions#TCP_NODELAY TCP_NODELAY} is enabled.\\n     *\\n     * @return a {@code boolean} indicating whether or not\\n     *         {@link SocketOptions#TCP_NODELAY TCP_NODELAY} is enabled.\\n     * @exception SocketException if there is an error\\n     * in the underlying protocol, such as a TCP error.\\n     * @since   1.1\\n     * @see #setTcpNoDelay(boolean)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void setSoLinger(boolean on, int linger) throws SocketException", "label": "public void setSoLinger(boolean on, int linger) throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Enable/disable {@link SocketOptions#SO_LINGER SO_LINGER} with the\\n     * specified linger time in seconds. The maximum timeout value is platform\\n     * specific.\\n     *\\n     * The setting only affects socket close.\\n     *\\n     * @param on     whether or not to linger on.\\n     * @param linger how long to linger for, if on is true.\\n     * @exception SocketException if there is an error\\n     * in the underlying protocol, such as a TCP error.\\n     * @exception IllegalArgumentException if the linger value is negative.\\n     * @since 1.1\\n     * @see #getSoLinger()\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getSoLinger() throws SocketException", "label": "public int getSoLinger() throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns setting for {@link SocketOptions#SO_LINGER SO_LINGER}.\\n     * -1 returns implies that the\\n     * option is disabled.\\n     *\\n     * The setting only affects socket close.\\n     *\\n     * @return the setting for {@link SocketOptions#SO_LINGER SO_LINGER}.\\n     * @exception SocketException if there is an error\\n     * in the underlying protocol, such as a TCP error.\\n     * @since   1.1\\n     * @see #setSoLinger(boolean, int)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void sendUrgentData(int data) throws IOException", "label": "public void sendUrgentData(int data) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Send one byte of urgent data on the socket. The byte to be sent is the lowest eight\\n     * bits of the data parameter. The urgent byte is\\n     * sent after any preceding writes to the socket OutputStream\\n     * and before any future writes to the OutputStream.\\n     * @param data The byte of data to send\\n     * @exception IOException if there is an error\\n     *  sending the data.\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void setOOBInline(boolean on) throws SocketException", "label": "public void setOOBInline(boolean on) throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Enable/disable {@link SocketOptions#SO_OOBINLINE SO_OOBINLINE}\\n     * (receipt of TCP urgent data)\\n     *\\n     * By default, this option is disabled and TCP urgent data received on a\\n     * socket is silently discarded. If the user wishes to receive urgent data, then\\n     * this option must be enabled. When enabled, urgent data is received\\n     * inline with normal data.\\n     * \u003cp\u003e\\n     * Note, only limited support is provided for handling incoming urgent\\n     * data. In particular, no notification of incoming urgent data is provided\\n     * and there is no capability to distinguish between normal data and urgent\\n     * data unless provided by a higher level protocol.\\n     *\\n     * @param on {@code true} to enable\\n     *           {@link SocketOptions#SO_OOBINLINE SO_OOBINLINE},\\n     *           {@code false} to disable.\\n     *\\n     * @exception SocketException if there is an error\\n     * in the underlying protocol, such as a TCP error.\\n     *\\n     * @since   1.4\\n     *\\n     * @see #getOOBInline()\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean getOOBInline() throws SocketException", "label": "public boolean getOOBInline() throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests if {@link SocketOptions#SO_OOBINLINE SO_OOBINLINE} is enabled.\\n     *\\n     * @return a {@code boolean} indicating whether or not\\n     *         {@link SocketOptions#SO_OOBINLINE SO_OOBINLINE}is enabled.\\n     *\\n     * @exception SocketException if there is an error\\n     * in the underlying protocol, such as a TCP error.\\n     * @since   1.4\\n     * @see #setOOBInline(boolean)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public synchronized int getSoTimeout() throws SocketException", "label": "public synchronized int getSoTimeout() throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Retrieve setting for SO_TIMEOUT.  0 returns implies that the\\n     * option is disabled (i.e., timeout of infinity).\\n     *\\n     * @return the setting for SO_TIMEOUT\\n     * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.\\n     * @since   1.1\\n     * @see #setSoTimeout(int)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public synchronized void setSendBufferSize(int size) throws SocketException", "label": "public synchronized void setSendBufferSize(int size) throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the SO_SNDBUF option to the specified value for this\\n     * {@code DatagramSocket}. The SO_SNDBUF option is used by the\\n     * network implementation as a hint to size the underlying\\n     * network I/O buffers. The SO_SNDBUF setting may also be used\\n     * by the network implementation to determine the maximum size\\n     * of the packet that can be sent on this socket.\\n     * \u003cp\u003e\\n     * As SO_SNDBUF is a hint, applications that want to verify\\n     * what size the buffer is should call {@link #getSendBufferSize()}.\\n     * \u003cp\u003e\\n     * Increasing the buffer size may allow multiple outgoing packets\\n     * to be queued by the network implementation when the send rate\\n     * is high.\\n     * \u003cp\u003e\\n     * Note: If {@link #send(DatagramPacket)} is used to send a\\n     * {@code DatagramPacket} that is larger than the setting\\n     * of SO_SNDBUF then it is implementation specific if the\\n     * packet is sent or discarded.\\n     *\\n     * @param size the size to which to set the send buffer\\n     * size. This value must be greater than 0.\\n     *\\n     * @exception SocketException if there is an error\\n     * in the underlying protocol, such as an UDP error.\\n     * @exception IllegalArgumentException if the value is 0 or is\\n     * negative.\\n     * @see #getSendBufferSize()\\n     \u0027}"}, {"color": "#97c2fc", "id": "getSendBufferSize()", "label": "getSendBufferSize()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public synchronized int getSendBufferSize() throws SocketException", "label": "public synchronized int getSendBufferSize() throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get value of the SO_SNDBUF option for this {@code DatagramSocket}, that is the\\n     * buffer size used by the platform for output on this {@code DatagramSocket}.\\n     *\\n     * @return the value of the SO_SNDBUF option for this {@code DatagramSocket}\\n     * @exception SocketException if there is an error in\\n     * the underlying protocol, such as an UDP error.\\n     * @see #setSendBufferSize\\n     \u0027}"}, {"color": "#97c2fc", "id": "getReceiveBufferSize()", "label": "getReceiveBufferSize()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void setKeepAlive(boolean on) throws SocketException", "label": "public void setKeepAlive(boolean on) throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Enable/disable {@link SocketOptions#SO_KEEPALIVE SO_KEEPALIVE}.\\n     *\\n     * @param on  whether or not to have socket keep alive turned on.\\n     * @exception SocketException if there is an error\\n     * in the underlying protocol, such as a TCP error.\\n     * @since 1.3\\n     * @see #getKeepAlive()\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean getKeepAlive() throws SocketException", "label": "public boolean getKeepAlive() throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests if {@link SocketOptions#SO_KEEPALIVE SO_KEEPALIVE} is enabled.\\n     *\\n     * @return a {@code boolean} indicating whether or not\\n     *         {@link SocketOptions#SO_KEEPALIVE SO_KEEPALIVE} is enabled.\\n     * @exception SocketException if there is an error\\n     * in the underlying protocol, such as a TCP error.\\n     * @since   1.3\\n     * @see #setKeepAlive(boolean)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void setTrafficClass(int tc) throws SocketException", "label": "public void setTrafficClass(int tc) throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets traffic class or type-of-service octet in the IP\\n     * header for packets sent from this Socket.\\n     * As the underlying network implementation may ignore this\\n     * value applications should consider it a hint.\\n     *\\n     * \u003cP\u003e The tc \u003cB\u003emust\u003c/B\u003e be in the range {@code 0 \u003c= tc \u003c=\\n     * 255} or an IllegalArgumentException will be thrown.\\n     * \u003cp\u003eNotes:\\n     * \u003cp\u003eFor Internet Protocol v4 the value consists of an\\n     * {@code integer}, the least significant 8 bits of which\\n     * represent the value of the TOS octet in IP packets sent by\\n     * the socket.\\n     * RFC 1349 defines the TOS values as follows:\\n     *\\n     * \u003cUL\u003e\\n     * \u003cLI\u003e\u003cCODE\u003eIPTOS_LOWCOST (0x02)\u003c/CODE\u003e\u003c/LI\u003e\\n     * \u003cLI\u003e\u003cCODE\u003eIPTOS_RELIABILITY (0x04)\u003c/CODE\u003e\u003c/LI\u003e\\n     * \u003cLI\u003e\u003cCODE\u003eIPTOS_THROUGHPUT (0x08)\u003c/CODE\u003e\u003c/LI\u003e\\n     * \u003cLI\u003e\u003cCODE\u003eIPTOS_LOWDELAY (0x10)\u003c/CODE\u003e\u003c/LI\u003e\\n     * \u003c/UL\u003e\\n     * The last low order bit is always ignored as this\\n     * corresponds to the MBZ (must be zero) bit.\\n     * \u003cp\u003e\\n     * Setting bits in the precedence field may result in a\\n     * SocketException indicating that the operation is not\\n     * permitted.\\n     * \u003cp\u003e\\n     * As RFC 1122 section 4.2.4.2 indicates, a compliant TCP\\n     * implementation should, but is not required to, let application\\n     * change the TOS field during the lifetime of a connection.\\n     * So whether the type-of-service field can be changed after the\\n     * TCP connection has been established depends on the implementation\\n     * in the underlying platform. Applications should not assume that\\n     * they can change the TOS field after the connection.\\n     * \u003cp\u003e\\n     * For Internet Protocol v6 {@code tc} is the value that\\n     * would be placed into the sin6_flowinfo field of the IP header.\\n     *\\n     * @param tc        an {@code int} value for the bitset.\\n     * @throws SocketException if there is an error setting the\\n     * traffic class or type-of-service\\n     * @since 1.4\\n     * @see #getTrafficClass\\n     * @see SocketOptions#IP_TOS\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getTrafficClass() throws SocketException", "label": "public int getTrafficClass() throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets traffic class or type-of-service in the IP header\\n     * for packets sent from this Socket\\n     * \u003cp\u003e\\n     * As the underlying network implementation may ignore the\\n     * traffic class or type-of-service set using {@link #setTrafficClass(int)}\\n     * this method may return a different value than was previously\\n     * set using the {@link #setTrafficClass(int)} method on this Socket.\\n     *\\n     * @return the traffic class or type-of-service already set\\n     * @throws SocketException if there is an error obtaining the\\n     * traffic class or type-of-service value.\\n     * @since 1.4\\n     * @see #setTrafficClass(int)\\n     * @see SocketOptions#IP_TOS\\n     \u0027}"}, {"color": "#97c2fc", "id": "setTrafficClass(int)", "label": "setTrafficClass(int)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public synchronized void close() throws IOException", "label": "public synchronized void close() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Closes this socket.\\n     * \u003cp\u003e\\n     * Any thread currently blocked in an I/O operation upon this socket\\n     * will throw a {@link SocketException}.\\n     * \u003cp\u003e\\n     * Once a socket has been closed, it is not available for further networking\\n     * use (i.e. can\u0027t be reconnected or rebound). A new socket needs to be\\n     * created.\\n     *\\n     * \u003cp\u003e Closing this socket will also close the socket\u0027s\\n     * {@link java.io.InputStream InputStream} and\\n     * {@link java.io.OutputStream OutputStream}.\\n     *\\n     * \u003cp\u003e If this socket has an associated channel then the channel is closed\\n     * as well.\\n     *\\n     * @exception  IOException  if an I/O error occurs when closing this socket.\\n     * @revised 1.4\\n     * @spec JSR-51\\n     * @see #isClosed\\n     \"}"}, {"color": "#97c2fc", "id": "public void shutdownInput() throws IOException", "label": "public void shutdownInput() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Places the input stream for this socket at \"end of stream\".\\n     * Any data sent to the input stream side of the socket is acknowledged\\n     * and then silently discarded.\\n     * \u003cp\u003e\\n     * If you read from a socket input stream after invoking this method on the\\n     * socket, the stream\\\u0027s {@code available} method will return 0, and its\\n     * {@code read} methods will return {@code -1} (end of stream).\\n     *\\n     * @exception IOException if an I/O error occurs when shutting down this\\n     * socket.\\n     *\\n     * @since 1.3\\n     * @see java.net.Socket#shutdownOutput()\\n     * @see java.net.Socket#close()\\n     * @see java.net.Socket#setSoLinger(boolean, int)\\n     * @see #isInputShutdown\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void shutdownOutput() throws IOException", "label": "public void shutdownOutput() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Disables the output stream for this socket.\\n     * For a TCP socket, any previously written data will be sent\\n     * followed by TCP\u0027s normal connection termination sequence.\\n     *\\n     * If you write to a socket output stream after invoking\\n     * shutdownOutput() on the socket, the stream will throw\\n     * an IOException.\\n     *\\n     * @exception IOException if an I/O error occurs when shutting down this\\n     * socket.\\n     *\\n     * @since 1.3\\n     * @see java.net.Socket#shutdownInput()\\n     * @see java.net.Socket#close()\\n     * @see java.net.Socket#setSoLinger(boolean, int)\\n     * @see #isOutputShutdown\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean isConnected()", "label": "public boolean isConnected()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the connection state of the socket.\\n     * \u003cp\u003e\\n     * If the socket was connected prior to being {@link #close closed},\\n     * then this method will continue to return {@code true}\\n     * after the socket is closed.\\n     *\\n     * @return true if the socket successfully connected to a server\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "isClosed()", "label": "isClosed()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public boolean isInputShutdown()", "label": "public boolean isInputShutdown()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns whether the read-half of the socket connection is closed.\\n     *\\n     * @return true if the input of the socket has been shutdown\\n     * @since 1.4\\n     * @see #shutdownInput\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isOutputShutdown()", "label": "public boolean isOutputShutdown()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns whether the write-half of the socket connection is closed.\\n     *\\n     * @return true if the output of the socket has been shutdown\\n     * @since 1.4\\n     * @see #shutdownOutput\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static synchronized void setSocketImplFactory(SocketImplFactory fac) throws IOException", "label": "public static synchronized void setSocketImplFactory(SocketImplFactory fac) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Sets the client socket implementation factory for the\\n     * application. The factory can be specified only once.\\n     * \u003cp\u003e\\n     * When an application creates a new client socket, the socket\\n     * implementation factory\u0027s {@code createSocketImpl} method is\\n     * called to create the actual socket implementation.\\n     * \u003cp\u003e\\n     * Passing {@code null} to the method is a no-op unless the factory\\n     * was already set.\\n     * \u003cp\u003eIf there is a security manager, this method first calls\\n     * the security manager\u0027s {@code checkSetFactory} method\\n     * to ensure the operation is allowed.\\n     * This could result in a SecurityException.\\n     *\\n     * @param      fac   the desired factory.\\n     * @exception  IOException  if an I/O error occurs when setting the\\n     *               socket factory.\\n     * @exception  SocketException  if the factory is already defined.\\n     * @exception  SecurityException  if a security manager exists and its\\n     *             {@code checkSetFactory} method doesn\u0027t allow the operation.\\n     * @see        java.net.SocketImplFactory#createSocketImpl()\\n     * @see        SecurityManager#checkSetFactory\\n     \"}"}, {"color": "#97c2fc", "id": "public Socket setOption(SocketOption\u003cT\u003e name, T value) throws IOException", "label": "public Socket setOption(SocketOption\u003cT\u003e name, T value) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the value of a socket option.\\n     *\\n     * @param \u003cT\u003e The type of the socket option value\\n     * @param name The socket option\\n     * @param value The value of the socket option. A value of {@code null}\\n     *              may be valid for some options.\\n     * @return this Socket\\n     *\\n     * @throws UnsupportedOperationException if the socket does not support\\n     *         the option.\\n     *\\n     * @throws IllegalArgumentException if the value is not valid for\\n     *         the option.\\n     *\\n     * @throws IOException if an I/O error occurs, or if the socket is closed.\\n     *\\n     * @throws NullPointerException if name is {@code null}\\n     *\\n     * @throws SecurityException if a security manager is set and if the socket\\n     *         option requires a security permission and if the caller does\\n     *         not have the required permission.\\n     *         {@link java.net.StandardSocketOptions StandardSocketOptions}\\n     *         do not require any security permission.\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract boolean isConnected()", "label": "public abstract boolean isConnected()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Tells whether or not this channel\u0027s socket is connected.\\n     *\\n     * @return  {@code true} if, and only if, this channel\u0027s socket\\n     *          is {@link #isOpen open} and connected\\n     \"}"}, {"color": "#97c2fc", "id": "isOpen", "label": "isOpen", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract boolean isConnectionPending()", "label": "public abstract boolean isConnectionPending()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not a connection operation is in progress on this\\n     * channel.\\n     *\\n     * @return  {@code true} if, and only if, a connection operation has been\\n     *          initiated on this channel but not yet completed by invoking the\\n     *          {@link #finishConnect finishConnect} method\\n     \u0027}"}, {"color": "#97c2fc", "id": "finishConnect", "label": "finishConnect", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract boolean connect(SocketAddress remote) throws IOException", "label": "public abstract boolean connect(SocketAddress remote) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Connects this channel\u0027s socket.\\n     *\\n     * \u003cp\u003e If this channel is in non-blocking mode then an invocation of this\\n     * method initiates a non-blocking connection operation.  If the connection\\n     * is established immediately, as can happen with a local connection, then\\n     * this method returns {@code true}.  Otherwise this method returns\\n     * {@code false} and the connection operation must later be completed by\\n     * invoking the {@link #finishConnect finishConnect} method.\\n     *\\n     * \u003cp\u003e If this channel is in blocking mode then an invocation of this\\n     * method will block until the connection is established or an I/O error\\n     * occurs.\\n     *\\n     * \u003cp\u003e This method performs exactly the same security checks as the {@link\\n     * java.net.Socket} class.  That is, if a security manager has been\\n     * installed then this method verifies that its {@link\\n     * java.lang.SecurityManager#checkConnect checkConnect} method permits\\n     * connecting to the address and port number of the given remote endpoint.\\n     *\\n     * \u003cp\u003e This method may be invoked at any time.  If a read or write\\n     * operation upon this channel is invoked while an invocation of this\\n     * method is in progress then that operation will first block until this\\n     * invocation is complete.  If a connection attempt is initiated but fails,\\n     * that is, if an invocation of this method throws a checked exception,\\n     * then the channel will be closed.  \u003c/p\u003e\\n     *\\n     * @param  remote\\n     *         The remote address to which this channel is to be connected\\n     *\\n     * @return  {@code true} if a connection was established,\\n     *          {@code false} if this channel is in non-blocking mode\\n     *          and the connection operation is in progress\\n     *\\n     * @throws  AlreadyConnectedException\\n     *          If this channel is already connected\\n     *\\n     * @throws  ConnectionPendingException\\n     *          If a non-blocking connection operation is already in progress\\n     *          on this channel\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     *\\n     * @throws  AsynchronousCloseException\\n     *          If another thread closes this channel\\n     *          while the connect operation is in progress\\n     *\\n     * @throws  ClosedByInterruptException\\n     *          If another thread interrupts the current thread\\n     *          while the connect operation is in progress, thereby\\n     *          closing the channel and setting the current thread\u0027s\\n     *          interrupt status\\n     *\\n     * @throws  UnresolvedAddressException\\n     *          If the given remote address is not fully resolved\\n     *\\n     * @throws  UnsupportedAddressTypeException\\n     *          If the type of the given remote address is not supported\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager has been installed\\n     *          and it does not permit access to the given remote endpoint\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract boolean finishConnect() throws IOException", "label": "public abstract boolean finishConnect() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Finishes the process of connecting a socket channel.\\n     *\\n     * \u003cp\u003e A non-blocking connection operation is initiated by placing a socket\\n     * channel in non-blocking mode and then invoking its {@link #connect\\n     * connect} method.  Once the connection is established, or the attempt has\\n     * failed, the socket channel will become connectable and this method may\\n     * be invoked to complete the connection sequence.  If the connection\\n     * operation failed then invoking this method will cause an appropriate\\n     * {@link java.io.IOException} to be thrown.\\n     *\\n     * \u003cp\u003e If this channel is already connected then this method will not block\\n     * and will immediately return {@code true}.  If this channel is in\\n     * non-blocking mode then this method will return {@code false} if the\\n     * connection process is not yet complete.  If this channel is in blocking\\n     * mode then this method will block until the connection either completes\\n     * or fails, and will always either return {@code true} or throw a checked\\n     * exception describing the failure.\\n     *\\n     * \u003cp\u003e This method may be invoked at any time.  If a read or write\\n     * operation upon this channel is invoked while an invocation of this\\n     * method is in progress then that operation will first block until this\\n     * invocation is complete.  If a connection attempt fails, that is, if an\\n     * invocation of this method throws a checked exception, then the channel\\n     * will be closed.  \u003c/p\u003e\\n     *\\n     * @return  {@code true} if, and only if, this channel\u0027s socket is now\\n     *          connected\\n     *\\n     * @throws  NoConnectionPendingException\\n     *          If this channel is not connected and a connection operation\\n     *          has not been initiated\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     *\\n     * @throws  AsynchronousCloseException\\n     *          If another thread closes this channel\\n     *          while the connect operation is in progress\\n     *\\n     * @throws  ClosedByInterruptException\\n     *          If another thread interrupts the current thread\\n     *          while the connect operation is in progress, thereby\\n     *          closing the channel and setting the current thread\u0027s\\n     *          interrupt status\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "connectconnect", "label": "connectconnect", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract SocketAddress getRemoteAddress() throws IOException", "label": "public abstract SocketAddress getRemoteAddress() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the remote address to which this channel\u0027s socket is connected.\\n     *\\n     * @return  The remote address; {@code null} if the channel\u0027s socket is not\\n     *          connected\\n     *\\n     * @throws  ClosedChannelException\\n     *          If the channel is closed\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     *\\n     * @since 1.7\\n     \"}"}, {"color": "#97c2fc", "id": "java.net.InetSocketAddress", "label": "java.net.InetSocketAddress", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n *\\n * This class implements an IP Socket Address (IP address + port number)\\n * It can also be a pair (hostname + port number), in which case an attempt\\n * will be made to resolve the hostname. If resolution fails then the address\\n * is said to be \u003cI\u003eunresolved\u003c/I\u003e but can still be used on some circumstances\\n * like connecting through a proxy.\\n * \u003cp\u003e\\n * It provides an immutable object used by sockets for binding, connecting, or\\n * as returned values.\\n * \u003cp\u003e\\n * The \u003ci\u003ewildcard\u003c/i\u003e is a special local IP address. It usually means \"any\"\\n * and can only be used for {@code bind} operations.\\n *\\n * @see java.net.Socket\\n * @see java.net.ServerSocket\\n * @since 1.4\\n \u0027}"}, {"color": "#97c2fc", "id": "public static InetSocketAddress createUnresolved(String host, int port)", "label": "public static InetSocketAddress createUnresolved(String host, int port)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     *\\n     * Creates an unresolved socket address from a hostname and a port number.\\n     * \u003cp\u003e\\n     * No attempt will be made to resolve the hostname into an InetAddress.\\n     * The address will be flagged as \u003cI\u003eunresolved\u003c/I\u003e.\\n     * \u003cp\u003e\\n     * A valid port value is between 0 and 65535.\\n     * A port number of {@code zero} will let the system pick up an\\n     * ephemeral port in a {@code bind} operation.\\n     *\\n     * @param   host    the Host name\\n     * @param   port    The port number\\n     * @throws IllegalArgumentException if the port parameter is outside\\n     *                  the range of valid port values, or if the hostname\\n     *                  parameter is {@code null}.\\n     * @see     #isUnresolved()\\n     * @return  an {@code InetSocketAddress} representing the unresolved\\n     *          socket address\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void writeObject(ObjectOutputStream out) throws IOException", "label": "private void writeObject(ObjectOutputStream out) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes the state of this object to the stream.\\n     *\\n     * @param  out the {@code ObjectOutputStream} to which data is written\\n     * @throws IOException if an I/O error occurs\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException", "label": "private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Restores the state of this object from the stream.\\n     *\\n     * @param  in the {@code ObjectInputStream} from which data is read\\n     * @throws IOException if an I/O error occurs\\n     * @throws ClassNotFoundException if a serialized class cannot be loaded\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void readObjectNoData() throws ObjectStreamException", "label": "private void readObjectNoData() throws ObjectStreamException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Throws {@code InvalidObjectException}, always.\\n     * @throws ObjectStreamException always\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final int getPort()", "label": "public final int getPort()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets the port number.\\n     *\\n     * @return the port number.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final InetAddress getAddress()", "label": "public final InetAddress getAddress()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets the {@code InetAddress}.\\n     *\\n     * @return the InetAddress or {@code null} if it is unresolved.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final String getHostName()", "label": "public final String getHostName()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets the {@code hostname}.\\n     * Note: This method may trigger a name service reverse lookup if the\\n     * address was created with a literal IP address.\\n     *\\n     * @return  the hostname part of the address.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final String getHostString()", "label": "public final String getHostString()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the hostname, or the String form of the address if it\\n     * doesn\u0027t have a hostname (it was created using a literal).\\n     * This has the benefit of \u003cb\u003enot\u003c/b\u003e attempting a reverse lookup.\\n     *\\n     * @return the hostname, or String representation of the address.\\n     * @since 1.7\\n     \"}"}, {"color": "#97c2fc", "id": "public final boolean isUnresolved()", "label": "public final boolean isUnresolved()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Checks whether the address has been resolved or not.\\n     *\\n     * @return {@code true} if the hostname couldn\u0027t be resolved into\\n     *          an {@code InetAddress}.\\n     \"}"}, {"color": "#97c2fc", "id": "getHostString()", "label": "getHostString()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "toString()", "label": "toString()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public final boolean equals(Object obj)", "label": "public final boolean equals(Object obj)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares this object against the specified object.\\n     * The result is {@code true} if and only if the argument is\\n     * not {@code null} and it represents the same address as\\n     * this object.\\n     * \u003cp\u003e\\n     * Two instances of {@code InetSocketAddress} represent the same\\n     * address if both the InetAddresses (or hostnames if it is unresolved) and port\\n     * numbers are equal.\\n     * If both addresses are unresolved, then the hostname and the port number\\n     * are compared.\\n     *\\n     * Note: Hostnames are case insensitive. e.g. \"FooBar\" and \"foobar\" are\\n     * considered equal.\\n     *\\n     * @param   obj   the object to compare against.\\n     * @return  {@code true} if the objects are the same;\\n     *          {@code false} otherwise.\\n     * @see java.net.InetAddress#equals(java.lang.Object)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract int read(ByteBuffer dst) throws IOException", "label": "public abstract int read(ByteBuffer dst) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reads a sequence of bytes from this channel into the given buffer.\\n     *\\n     * \u003cp\u003e Bytes are read starting at this channel\u0027s current file position, and\\n     * then the file position is updated with the number of bytes actually\\n     * read.  Otherwise this method behaves exactly as specified in the {@link\\n     * ReadableByteChannel} interface. \u003c/p\u003e\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract long read(ByteBuffer[] dsts, int offset, int length) throws IOException", "label": "public abstract long read(ByteBuffer[] dsts, int offset, int length) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reads a sequence of bytes from this channel into a subsequence of the\\n     * given buffers.\\n     *\\n     * \u003cp\u003e Bytes are read starting at this channel\u0027s current file position, and\\n     * then the file position is updated with the number of bytes actually\\n     * read.  Otherwise this method behaves exactly as specified in the {@link\\n     * ScatteringByteChannel} interface.  \u003c/p\u003e\\n     \"}"}, {"color": "#97c2fc", "id": "public final long read(ByteBuffer[] dsts) throws IOException", "label": "public final long read(ByteBuffer[] dsts) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reads a sequence of bytes from this channel into the given buffers.\\n     *\\n     * \u003cp\u003e Bytes are read starting at this channel\u0027s current file position, and\\n     * then the file position is updated with the number of bytes actually\\n     * read.  Otherwise this method behaves exactly as specified in the {@link\\n     * ScatteringByteChannel} interface.  \u003c/p\u003e\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract int write(ByteBuffer src) throws IOException", "label": "public abstract int write(ByteBuffer src) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Writes a sequence of bytes to this channel from the given buffer.\\n     *\\n     * \u003cp\u003e Bytes are written starting at this channel\u0027s current file position\\n     * unless the channel is in append mode, in which case the position is\\n     * first advanced to the end of the file.  The file is grown, if necessary,\\n     * to accommodate the written bytes, and then the file position is updated\\n     * with the number of bytes actually written.  Otherwise this method\\n     * behaves exactly as specified by the {@link WritableByteChannel}\\n     * interface. \u003c/p\u003e\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract long write(ByteBuffer[] srcs, int offset, int length) throws IOException", "label": "public abstract long write(ByteBuffer[] srcs, int offset, int length) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Writes a sequence of bytes to this channel from a subsequence of the\\n     * given buffers.\\n     *\\n     * \u003cp\u003e Bytes are written starting at this channel\u0027s current file position\\n     * unless the channel is in append mode, in which case the position is\\n     * first advanced to the end of the file.  The file is grown, if necessary,\\n     * to accommodate the written bytes, and then the file position is updated\\n     * with the number of bytes actually written.  Otherwise this method\\n     * behaves exactly as specified in the {@link GatheringByteChannel}\\n     * interface.  \u003c/p\u003e\\n     \"}"}, {"color": "#97c2fc", "id": "public final long write(ByteBuffer[] srcs) throws IOException", "label": "public final long write(ByteBuffer[] srcs) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Writes a sequence of bytes to this channel from the given buffers.\\n     *\\n     * \u003cp\u003e Bytes are written starting at this channel\u0027s current file position\\n     * unless the channel is in append mode, in which case the position is\\n     * first advanced to the end of the file.  The file is grown, if necessary,\\n     * to accommodate the written bytes, and then the file position is updated\\n     * with the number of bytes actually written.  Otherwise this method\\n     * behaves exactly as specified in the {@link GatheringByteChannel}\\n     * interface.  \u003c/p\u003e\\n     \"}"}, {"color": "#97c2fc", "id": "java.nio.channels.DatagramChannel", "label": "java.nio.channels.DatagramChannel", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public static DatagramChannel open() throws IOException", "label": "public static DatagramChannel open() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Opens a datagram channel.\\n     *\\n     * \u003cp\u003e The new channel is created by invoking the {@link\\n     * java.nio.channels.spi.SelectorProvider#openDatagramChannel()\\n     * openDatagramChannel} method of the system-wide default {@link\\n     * java.nio.channels.spi.SelectorProvider} object.  The channel will not be\\n     * connected.\\n     *\\n     * \u003cp\u003e The {@link ProtocolFamily ProtocolFamily} of the channel\u0027s socket\\n     * is platform (and possibly configuration) dependent and therefore unspecified.\\n     * The {@link #open(ProtocolFamily) open} allows the protocol family to be\\n     * selected when opening a datagram channel, and should be used to open\\n     * datagram channels that are intended for Internet Protocol multicasting.\\n     *\\n     * @return  A new datagram channel\\n     *\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "open(ProtocolFamily)", "label": "open(ProtocolFamily)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.net.ProtocolFamily", "label": "java.net.ProtocolFamily", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": " String name()", "label": " String name()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the name of the attribute view. Attribute views of this type\\n     * have the name {@code \"owner\"}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static DatagramChannel open(ProtocolFamily family) throws IOException", "label": "public static DatagramChannel open(ProtocolFamily family) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens a datagram channel.\\n     *\\n     * \u003cp\u003e The {@code family} parameter is used to specify the {@link\\n     * ProtocolFamily}. If the datagram channel is to be used for IP multicasting\\n     * then this should correspond to the address type of the multicast groups\\n     * that this channel will join.\\n     *\\n     * \u003cp\u003e The new channel is created by invoking the {@link\\n     * java.nio.channels.spi.SelectorProvider#openDatagramChannel(ProtocolFamily)\\n     * openDatagramChannel} method of the system-wide default {@link\\n     * java.nio.channels.spi.SelectorProvider} object.  The channel will not be\\n     * connected.\\n     *\\n     * @param   family\\n     *          The protocol family\\n     *\\n     * @return  A new datagram channel\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          If the specified protocol family is not supported. For example,\\n     *          suppose the parameter is specified as {@link\\n     *          java.net.StandardProtocolFamily#INET6 StandardProtocolFamily.INET6}\\n     *          but IPv6 is not enabled on the platform.\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     *\\n     * @since   1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "INET6", "label": "INET6", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract DatagramChannel bind(SocketAddress local) throws IOException", "label": "public abstract DatagramChannel bind(SocketAddress local) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @throws  AlreadyBoundException               {@inheritDoc}\\n     * @throws  UnsupportedAddressTypeException     {@inheritDoc}\\n     * @throws  ClosedChannelException              {@inheritDoc}\\n     * @throws  IOException                         {@inheritDoc}\\n     * @throws  SecurityException\\n     *          If a security manager has been installed and its {@link\\n     *          SecurityManager#checkListen checkListen} method denies the\\n     *          operation\\n     *\\n     * @since 1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract DatagramChannel setOption(SocketOption\u003cT\u003e name, T value) throws IOException", "label": "public abstract DatagramChannel setOption(SocketOption\u003cT\u003e name, T value) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @throws  UnsupportedOperationException           {@inheritDoc}\\n     * @throws  IllegalArgumentException                {@inheritDoc}\\n     * @throws  ClosedChannelException                  {@inheritDoc}\\n     * @throws  IOException                             {@inheritDoc}\\n     *\\n     * @since 1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract DatagramSocket socket()", "label": "public abstract DatagramSocket socket()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Retrieves a datagram socket associated with this channel.\\n     *\\n     * \u003cp\u003e The returned object will not declare any public methods that are not\\n     * declared in the {@link java.net.DatagramSocket} class.  \u003c/p\u003e\\n     *\\n     * @return  A datagram socket associated with this channel\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.net.DatagramSocket", "label": "java.net.DatagramSocket", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * This class represents a socket for sending and receiving datagram packets.\\n *\\n * \u003cp\u003eA datagram socket is the sending or receiving point for a packet\\n * delivery service. Each packet sent or received on a datagram socket\\n * is individually addressed and routed. Multiple packets sent from\\n * one machine to another may be routed differently, and may arrive in\\n * any order.\\n *\\n * \u003cp\u003e Where possible, a newly constructed {@code DatagramSocket} has the\\n * {@link SocketOptions#SO_BROADCAST SO_BROADCAST} socket option enabled so as\\n * to allow the transmission of broadcast datagrams. In order to receive\\n * broadcast packets a DatagramSocket should be bound to the wildcard address.\\n * In some implementations, broadcast packets may also be received when\\n * a DatagramSocket is bound to a more specific address.\\n * \u003cp\u003e\\n * Example:\\n * {@code\\n *              DatagramSocket s = new DatagramSocket(null);\\n *              s.bind(new InetSocketAddress(8888));\\n * }\\n * Which is equivalent to:\\n * {@code\\n *              DatagramSocket s = new DatagramSocket(8888);\\n * }\\n * Both cases will create a DatagramSocket able to receive broadcasts on\\n * UDP port 8888.\\n *\\n * @author  Pavani Diwanji\\n * @see     java.net.DatagramPacket\\n * @see     java.nio.channels.DatagramChannel\\n * @since JDK1.0\\n \u0027}"}, {"color": "#97c2fc", "id": "private synchronized void connectInternal(InetAddress address, int port) throws SocketException", "label": "private synchronized void connectInternal(InetAddress address, int port) throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Connects this socket to a remote socket address (IP address + port number).\\n     * Binds socket if not already bound.\\n     *\\n     * @param   address The remote address.\\n     * @param   port    The remote port\\n     * @throws  SocketException if binding the socket fails.\\n     \u0027}"}, {"color": "#97c2fc", "id": " DatagramSocketImpl getImpl() throws SocketException", "label": " DatagramSocketImpl getImpl() throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the {@code DatagramSocketImpl} attached to this socket,\\n     * creating it if necessary.\\n     *\\n     * @return  the {@code DatagramSocketImpl} attached to that\\n     *          DatagramSocket\\n     * @throws SocketException if creation fails.\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public synchronized void bind(SocketAddress addr) throws SocketException", "label": "public synchronized void bind(SocketAddress addr) throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Binds this DatagramSocket to a specific address and port.\\n     * \u003cp\u003e\\n     * If the address is {@code null}, then the system will pick up\\n     * an ephemeral port and a valid local address to bind the socket.\\n     *\\n     * @param   addr The address and port to bind to.\\n     * @throws  SocketException if any error happens during the bind, or if the\\n     *          socket is already bound.\\n     * @throws  SecurityException  if a security manager exists and its\\n     *             {@code checkListen} method doesn\u0027t allow the operation.\\n     * @throws IllegalArgumentException if addr is a SocketAddress subclass\\n     *         not supported by this socket.\\n     * @since 1.4\\n     \"}"}, {"color": "#97c2fc", "id": "public void connect(InetAddress address, int port)", "label": "public void connect(InetAddress address, int port)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Connects the socket to a remote address for this socket. When a\\n     * socket is connected to a remote address, packets may only be\\n     * sent to or received from that address. By default a datagram\\n     * socket is not connected.\\n     *\\n     * \u003cp\u003eIf the remote destination to which the socket is connected does not\\n     * exist, or is otherwise unreachable, and if an ICMP destination unreachable\\n     * packet has been received for that address, then a subsequent call to\\n     * send or receive may throw a PortUnreachableException. Note, there is no\\n     * guarantee that the exception will be thrown.\\n     *\\n     * \u003cp\u003e If a security manager has been installed then it is invoked to check\\n     * access to the remote address. Specifically, if the given {@code address}\\n     * is a {@link InetAddress#isMulticastAddress multicast address},\\n     * the security manager\u0027s {@link\\n     * java.lang.SecurityManager#checkMulticast(InetAddress)\\n     * checkMulticast} method is invoked with the given {@code address}.\\n     * Otherwise, the security manager\u0027s {@link\\n     * java.lang.SecurityManager#checkConnect(String,int) checkConnect}\\n     * and {@link java.lang.SecurityManager#checkAccept checkAccept} methods\\n     * are invoked, with the given {@code address} and {@code port}, to\\n     * verify that datagrams are permitted to be sent and received\\n     * respectively.\\n     *\\n     * \u003cp\u003e When a socket is connected, {@link #receive receive} and\\n     * {@link #send send} \u003cb\u003ewill not perform any security checks\u003c/b\u003e\\n     * on incoming and outgoing packets, other than matching the packet\u0027s\\n     * and the socket\u0027s address and port. On a send operation, if the\\n     * packet\u0027s address is set and the packet\u0027s address and the socket\u0027s\\n     * address do not match, an {@code IllegalArgumentException} will be\\n     * thrown. A socket connected to a multicast address may only be used\\n     * to send packets.\\n     *\\n     * @param address the remote address for the socket\\n     *\\n     * @param port the remote port for the socket.\\n     *\\n     * @throws IllegalArgumentException\\n     *         if the address is null, or the port is out of range.\\n     *\\n     * @throws SecurityException\\n     *         if a security manager has been installed and it does\\n     *         not permit access to the given remote address\\n     *\\n     * @see #disconnect\\n     \"}"}, {"color": "#97c2fc", "id": "send", "label": "send", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "receive", "label": "receive", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void connect(SocketAddress addr) throws SocketException", "label": "public void connect(SocketAddress addr) throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Connects this socket to a remote socket address (IP address + port number).\\n     *\\n     * \u003cp\u003e If given an {@link InetSocketAddress InetSocketAddress}, this method\\n     * behaves as if invoking {@link #connect(InetAddress,int) connect(InetAddress,int)}\\n     * with the given socket addresses IP address and port number.\\n     *\\n     * @param   addr    The remote address.\\n     *\\n     * @throws  SocketException\\n     *          if the connect fails\\n     *\\n     * @throws IllegalArgumentException\\n     *         if {@code addr} is {@code null}, or {@code addr} is a SocketAddress\\n     *         subclass not supported by this socket\\n     *\\n     * @throws SecurityException\\n     *         if a security manager has been installed and it does\\n     *         not permit access to the given remote address\\n     *\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "connect(InetAddress", "label": "connect(InetAddress", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void disconnect()", "label": "public void disconnect()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Disconnects the socket. If the socket is closed or not connected,\\n     * then this method has no effect.\\n     *\\n     * @see #connect\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void send(DatagramPacket p) throws IOException", "label": "public void send(DatagramPacket p) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Sends a datagram packet from this socket. The\\n     * {@code DatagramPacket} includes information indicating the\\n     * data to be sent, its length, the IP address of the remote host,\\n     * and the port number on the remote host.\\n     *\\n     * \u003cp\u003eIf there is a security manager, and the socket is not currently\\n     * connected to a remote address, this method first performs some\\n     * security checks. First, if {@code p.getAddress().isMulticastAddress()}\\n     * is true, this method calls the\\n     * security manager\u0027s {@code checkMulticast} method\\n     * with {@code p.getAddress()} as its argument.\\n     * If the evaluation of that expression is false,\\n     * this method instead calls the security manager\u0027s\\n     * {@code checkConnect} method with arguments\\n     * {@code p.getAddress().getHostAddress()} and\\n     * {@code p.getPort()}. Each call to a security manager method\\n     * could result in a SecurityException if the operation is not allowed.\\n     *\\n     * @param      p   the {@code DatagramPacket} to be sent.\\n     *\\n     * @exception  IOException  if an I/O error occurs.\\n     * @exception  SecurityException  if a security manager exists and its\\n     *             {@code checkMulticast} or {@code checkConnect}\\n     *             method doesn\u0027t allow the send.\\n     * @exception  PortUnreachableException may be thrown if the socket is connected\\n     *             to a currently unreachable destination. Note, there is no\\n     *             guarantee that the exception will be thrown.\\n     * @exception  java.nio.channels.IllegalBlockingModeException\\n     *             if this socket has an associated channel,\\n     *             and the channel is in non-blocking mode.\\n     * @exception  IllegalArgumentException if the socket is connected,\\n     *             and connected address and packet address differ.\\n     *\\n     * @see        java.net.DatagramPacket\\n     * @see        SecurityManager#checkMulticast(InetAddress)\\n     * @see        SecurityManager#checkConnect\\n     * @revised 1.4\\n     * @spec JSR-51\\n     \"}"}, {"color": "#97c2fc", "id": "public synchronized void receive(DatagramPacket p) throws IOException", "label": "public synchronized void receive(DatagramPacket p) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Receives a datagram packet from this socket. When this method\\n     * returns, the {@code DatagramPacket}\u0027s buffer is filled with\\n     * the data received. The datagram packet also contains the sender\u0027s\\n     * IP address, and the port number on the sender\u0027s machine.\\n     * \u003cp\u003e\\n     * This method blocks until a datagram is received. The\\n     * {@code length} field of the datagram packet object contains\\n     * the length of the received message. If the message is longer than\\n     * the packet\u0027s length, the message is truncated.\\n     * \u003cp\u003e\\n     * If there is a security manager, a packet cannot be received if the\\n     * security manager\u0027s {@code checkAccept} method\\n     * does not allow it.\\n     *\\n     * @param      p   the {@code DatagramPacket} into which to place\\n     *                 the incoming data.\\n     * @exception  IOException  if an I/O error occurs.\\n     * @exception  SocketTimeoutException  if setSoTimeout was previously called\\n     *                 and the timeout has expired.\\n     * @exception  PortUnreachableException may be thrown if the socket is connected\\n     *             to a currently unreachable destination. Note, there is no guarantee that the\\n     *             exception will be thrown.\\n     * @exception  java.nio.channels.IllegalBlockingModeException\\n     *             if this socket has an associated channel,\\n     *             and the channel is in non-blocking mode.\\n     * @see        java.net.DatagramPacket\\n     * @see        java.net.DatagramSocket\\n     * @revised 1.4\\n     * @spec JSR-51\\n     \"}"}, {"color": "#97c2fc", "id": "send(DatagramPacket)", "label": "send(DatagramPacket)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "receive(DatagramPacket)", "label": "receive(DatagramPacket)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public synchronized void setReuseAddress(boolean on) throws SocketException", "label": "public synchronized void setReuseAddress(boolean on) throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Enable/disable the SO_REUSEADDR socket option.\\n     * \u003cp\u003e\\n     * For UDP sockets it may be necessary to bind more than one\\n     * socket to the same socket address. This is typically for the\\n     * purpose of receiving multicast packets\\n     * (See {@link java.net.MulticastSocket}). The\\n     * {@code SO_REUSEADDR} socket option allows multiple\\n     * sockets to be bound to the same socket address if the\\n     * {@code SO_REUSEADDR} socket option is enabled prior\\n     * to binding the socket using {@link #bind(SocketAddress)}.\\n     * \u003cp\u003e\\n     * Note: This functionality is not supported by all existing platforms,\\n     * so it is implementation specific whether this option will be ignored\\n     * or not. However, if it is not supported then\\n     * {@link #getReuseAddress()} will always return {@code false}.\\n     * \u003cp\u003e\\n     * When a {@code DatagramSocket} is created the initial setting\\n     * of {@code SO_REUSEADDR} is disabled.\\n     * \u003cp\u003e\\n     * The behaviour when {@code SO_REUSEADDR} is enabled or\\n     * disabled after a socket is bound (See {@link #isBound()})\\n     * is not defined.\\n     *\\n     * @param on  whether to enable or disable the\\n     * @exception SocketException if an error occurs enabling or\\n     *            disabling the {@code SO_RESUEADDR} socket option,\\n     *            or the socket is closed.\\n     * @since 1.4\\n     * @see #getReuseAddress()\\n     * @see #bind(SocketAddress)\\n     * @see #isBound()\\n     * @see #isClosed()\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.net.MulticastSocket", "label": "java.net.MulticastSocket", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * The multicast datagram socket class is useful for sending\\n * and receiving IP multicast packets.  A MulticastSocket is\\n * a (UDP) DatagramSocket, with additional capabilities for\\n * joining \"groups\" of other multicast hosts on the internet.\\n * \u003cP\u003e\\n * A multicast group is specified by a class D IP address\\n * and by a standard UDP port number. Class D IP addresses\\n * are in the range \u003cCODE\u003e224.0.0.0\u003c/CODE\u003e to \u003cCODE\u003e239.255.255.255\u003c/CODE\u003e,\\n * inclusive. The address 224.0.0.0 is reserved and should not be used.\\n * \u003cP\u003e\\n * One would join a multicast group by first creating a MulticastSocket\\n * with the desired port, then invoking the\\n * \u003cCODE\u003ejoinGroup(InetAddress groupAddr)\u003c/CODE\u003e\\n * method:\\n * \u003cPRE\u003e\\n * // join a Multicast group and send the group salutations\\n * ...\\n * String msg = \"Hello\";\\n * InetAddress group = InetAddress.getByName(\"228.5.6.7\");\\n * MulticastSocket s = new MulticastSocket(6789);\\n * s.joinGroup(group);\\n * byte[] bytes = msg.getBytes(StandardCharsets.UTF_8);\\n * DatagramPacket hi = new DatagramPacket(bytes, bytes.length,\\n *                             group, 6789);\\n * s.send(hi);\\n * // get their responses!\\n * byte[] buf = new byte[1000];\\n * DatagramPacket recv = new DatagramPacket(buf, buf.length);\\n * s.receive(recv);\\n * ...\\n * // OK, I\\\u0027m done talking - leave the group...\\n * s.leaveGroup(group);\\n * \u003c/PRE\u003e\\n *\\n * When one sends a message to a multicast group, \u003cB\u003eall\u003c/B\u003e subscribing\\n * recipients to that host and port receive the message (within the\\n * time-to-live range of the packet, see below).  The socket needn\\\u0027t\\n * be a member of the multicast group to send messages to it.\\n * \u003cP\u003e\\n * When a socket subscribes to a multicast group/port, it receives\\n * datagrams sent by other hosts to the group/port, as do all other\\n * members of the group and port.  A socket relinquishes membership\\n * in a group by the leaveGroup(InetAddress addr) method.  \u003cB\u003e\\n * Multiple MulticastSocket\\\u0027s\u003c/B\u003e may subscribe to a multicast group\\n * and port concurrently, and they will all receive group datagrams.\\n * \u003cP\u003e\\n * Currently applets are not allowed to use multicast sockets.\\n *\\n * @author Pavani Diwanji\\n * @since  1.1\\n \u0027}"}, {"color": "#97c2fc", "id": "public void setTimeToLive(int ttl) throws IOException", "label": "public void setTimeToLive(int ttl) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Set the default time-to-live for multicast packets sent out\\n     * on this {@code MulticastSocket} in order to control the\\n     * scope of the multicasts.\\n     *\\n     * \u003cP\u003e The ttl \u003cB\u003emust\u003c/B\u003e be in the range {@code  0 \u003c= ttl \u003c=\\n     * 255} or an {@code IllegalArgumentException} will be thrown.\\n     * Multicast packets sent with a TTL of {@code 0} are not transmitted\\n     * on the network but may be delivered locally.\\n     *\\n     * @param  ttl\\n     *         the time-to-live\\n     *\\n     * @throws  IOException\\n     *          if an I/O exception occurs while setting the\\n     *          default time-to-live value\\n     *\\n     * @see #getTimeToLive()\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getTimeToLive() throws IOException", "label": "public int getTimeToLive() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the default time-to-live for multicast packets sent out on\\n     * the socket.\\n     * @exception IOException if an I/O exception occurs while\\n     * getting the default time-to-live value\\n     * @return the default time-to-live value\\n     * @see #setTimeToLive(int)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void joinGroup(InetAddress mcastaddr) throws IOException", "label": "public void joinGroup(InetAddress mcastaddr) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Joins a multicast group. Its behavior may be affected by\\n     * {@code setInterface} or {@code setNetworkInterface}.\\n     *\\n     * \u003cp\u003eIf there is a security manager, this method first\\n     * calls its {@code checkMulticast} method\\n     * with the {@code mcastaddr} argument\\n     * as its argument.\\n     *\\n     * @param mcastaddr is the multicast address to join\\n     *\\n     * @exception IOException if there is an error joining, or when the address\\n     *            is not a multicast address, or the platform does not support\\n     *            multicasting\\n     * @exception  SecurityException  if a security manager exists and its\\n     * {@code checkMulticast} method doesn\u0027t allow the join.\\n     *\\n     * @see SecurityManager#checkMulticast(InetAddress)\\n     \"}"}, {"color": "#97c2fc", "id": "public void leaveGroup(InetAddress mcastaddr) throws IOException", "label": "public void leaveGroup(InetAddress mcastaddr) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Leave a multicast group. Its behavior may be affected by\\n     * {@code setInterface} or {@code setNetworkInterface}.\\n     *\\n     * \u003cp\u003eIf there is a security manager, this method first\\n     * calls its {@code checkMulticast} method\\n     * with the {@code mcastaddr} argument\\n     * as its argument.\\n     *\\n     * @param mcastaddr is the multicast address to leave\\n     * @exception IOException if there is an error leaving\\n     * or when the address is not a multicast address.\\n     * @exception  SecurityException  if a security manager exists and its\\n     * {@code checkMulticast} method doesn\u0027t allow the operation.\\n     *\\n     * @see SecurityManager#checkMulticast(InetAddress)\\n     \"}"}, {"color": "#97c2fc", "id": "public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException", "label": "public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Joins the specified multicast group at the specified interface.\\n     *\\n     * \u003cp\u003eIf there is a security manager, this method first\\n     * calls its {@code checkMulticast} method\\n     * with the {@code mcastaddr} argument\\n     * as its argument.\\n     *\\n     * @param mcastaddr is the multicast address to join\\n     * @param netIf specifies the local interface to receive multicast\\n     *        datagram packets, or \u003ci\u003enull\u003c/i\u003e to defer to the interface set by\\n     *       {@link MulticastSocket#setInterface(InetAddress)} or\\n     *       {@link MulticastSocket#setNetworkInterface(NetworkInterface)}\\n     *\\n     * @exception IOException if there is an error joining, or when the address\\n     *            is not a multicast address, or the platform does not support\\n     *            multicasting\\n     * @exception  SecurityException  if a security manager exists and its\\n     * {@code checkMulticast} method doesn\u0027t allow the join.\\n     * @throws  IllegalArgumentException if mcastaddr is null or is a\\n     *          SocketAddress subclass not supported by this socket\\n     *\\n     * @see SecurityManager#checkMulticast(InetAddress)\\n     * @since 1.4\\n     \"}"}, {"color": "#97c2fc", "id": "setNetworkInterface(NetworkInterface)", "label": "setNetworkInterface(NetworkInterface)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "setInterface(InetAddress)", "label": "setInterface(InetAddress)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException", "label": "public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Leave a multicast group on a specified local interface.\\n     *\\n     * \u003cp\u003eIf there is a security manager, this method first\\n     * calls its {@code checkMulticast} method\\n     * with the {@code mcastaddr} argument\\n     * as its argument.\\n     *\\n     * @param mcastaddr is the multicast address to leave\\n     * @param netIf specifies the local interface or \u003ci\u003enull\u003c/i\u003e to defer\\n     *             to the interface set by\\n     *             {@link MulticastSocket#setInterface(InetAddress)} or\\n     *             {@link MulticastSocket#setNetworkInterface(NetworkInterface)}\\n     * @exception IOException if there is an error leaving\\n     * or when the address is not a multicast address.\\n     * @exception  SecurityException  if a security manager exists and its\\n     * {@code checkMulticast} method doesn\u0027t allow the operation.\\n     * @throws  IllegalArgumentException if mcastaddr is null or is a\\n     *          SocketAddress subclass not supported by this socket\\n     *\\n     * @see SecurityManager#checkMulticast(InetAddress)\\n     * @since 1.4\\n     \"}"}, {"color": "#97c2fc", "id": "public void setInterface(InetAddress inf) throws SocketException", "label": "public void setInterface(InetAddress inf) throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Set the multicast network interface used by methods\\n     * whose behavior would be affected by the value of the\\n     * network interface. Useful for multihomed hosts.\\n     * @param inf the InetAddress\\n     * @exception SocketException if there is an error in\\n     * the underlying protocol, such as a TCP error.\\n     * @see #getInterface()\\n     \u0027}"}, {"color": "#97c2fc", "id": "public InetAddress getInterface() throws SocketException", "label": "public InetAddress getInterface() throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Retrieve the address of the network interface used for\\n     * multicast packets.\\n     *\\n     * @return An {@code InetAddress} representing\\n     *  the address of the network interface used for\\n     *  multicast packets.\\n     *\\n     * @exception SocketException if there is an error in\\n     * the underlying protocol, such as a TCP error.\\n     *\\n     * @see #setInterface(java.net.InetAddress)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void setNetworkInterface(NetworkInterface netIf) throws SocketException", "label": "public void setNetworkInterface(NetworkInterface netIf) throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Specify the network interface for outgoing multicast datagrams\\n     * sent on this socket.\\n     *\\n     * @param netIf the interface\\n     * @exception SocketException if there is an error in\\n     * the underlying protocol, such as a TCP error.\\n     * @see #getNetworkInterface()\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public NetworkInterface getNetworkInterface() throws SocketException", "label": "public NetworkInterface getNetworkInterface() throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the multicast network interface set.\\n     *\\n     * @exception SocketException if there is an error in\\n     * the underlying protocol, such as a TCP error.\\n     * @return the multicast {@code NetworkInterface} currently\\n     * set or {@code null} when no interface is set.\\n     * @see #setNetworkInterface(NetworkInterface)\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void setLoopbackMode(boolean disable) throws SocketException", "label": "public void setLoopbackMode(boolean disable) throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Disable/Enable local loopback of multicast datagrams\\n     * The option is used by the platform\u0027s networking code as a hint\\n     * for setting whether multicast data will be looped back to\\n     * the local socket.\\n     *\\n     * \u003cp\u003eBecause this option is a hint, applications that want to\\n     * verify what loopback mode is set to should call\\n     * {@link #getLoopbackMode()}\\n     * @param disable {@code true} to disable the LoopbackMode\\n     * @throws SocketException if an error occurs while setting the value\\n     * @since 1.4\\n     * @see #getLoopbackMode\\n     \"}"}, {"color": "#97c2fc", "id": "getLoopbackMode()", "label": "getLoopbackMode()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public boolean getLoopbackMode() throws SocketException", "label": "public boolean getLoopbackMode() throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Get the setting for local loopback of multicast datagrams.\\n     *\\n     * @throws SocketException  if an error occurs while getting the value\\n     * @return true if the LoopbackMode has been disabled\\n     * @since 1.4\\n     * @see #setLoopbackMode\\n     \u0027}"}, {"color": "#97c2fc", "id": "public synchronized boolean getReuseAddress() throws SocketException", "label": "public synchronized boolean getReuseAddress() throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests if SO_REUSEADDR is enabled.\\n     *\\n     * @return a {@code boolean} indicating whether or not SO_REUSEADDR is enabled.\\n     * @exception SocketException if there is an error\\n     * in the underlying protocol, such as an UDP error.\\n     * @since   1.4\\n     * @see #setReuseAddress(boolean)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public synchronized void setBroadcast(boolean on) throws SocketException", "label": "public synchronized void setBroadcast(boolean on) throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Enable/disable SO_BROADCAST.\\n     *\\n     * \u003cp\u003e Some operating systems may require that the Java virtual machine be\\n     * started with implementation specific privileges to enable this option or\\n     * send broadcast datagrams.\\n     *\\n     * @param  on\\n     *         whether or not to have broadcast turned on.\\n     *\\n     * @throws  SocketException\\n     *          if there is an error in the underlying protocol, such as an UDP\\n     *          error.\\n     *\\n     * @since 1.4\\n     * @see #getBroadcast()\\n     \u0027}"}, {"color": "#97c2fc", "id": "public synchronized boolean getBroadcast() throws SocketException", "label": "public synchronized boolean getBroadcast() throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests if SO_BROADCAST is enabled.\\n     * @return a {@code boolean} indicating whether or not SO_BROADCAST is enabled.\\n     * @exception SocketException if there is an error\\n     * in the underlying protocol, such as an UDP error.\\n     * @since 1.4\\n     * @see #setBroadcast(boolean)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public synchronized void setTrafficClass(int tc) throws SocketException", "label": "public synchronized void setTrafficClass(int tc) throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets traffic class or type-of-service octet in the IP\\n     * datagram header for datagrams sent from this DatagramSocket.\\n     * As the underlying network implementation may ignore this\\n     * value applications should consider it a hint.\\n     *\\n     * \u003cP\u003e The tc \u003cB\u003emust\u003c/B\u003e be in the range {@code 0 \u003c= tc \u003c=\\n     * 255} or an IllegalArgumentException will be thrown.\\n     * \u003cp\u003eNotes:\\n     * \u003cp\u003eFor Internet Protocol v4 the value consists of an\\n     * {@code integer}, the least significant 8 bits of which\\n     * represent the value of the TOS octet in IP packets sent by\\n     * the socket.\\n     * RFC 1349 defines the TOS values as follows:\\n     *\\n     * \u003cUL\u003e\\n     * \u003cLI\u003e\u003cCODE\u003eIPTOS_LOWCOST (0x02)\u003c/CODE\u003e\u003c/LI\u003e\\n     * \u003cLI\u003e\u003cCODE\u003eIPTOS_RELIABILITY (0x04)\u003c/CODE\u003e\u003c/LI\u003e\\n     * \u003cLI\u003e\u003cCODE\u003eIPTOS_THROUGHPUT (0x08)\u003c/CODE\u003e\u003c/LI\u003e\\n     * \u003cLI\u003e\u003cCODE\u003eIPTOS_LOWDELAY (0x10)\u003c/CODE\u003e\u003c/LI\u003e\\n     * \u003c/UL\u003e\\n     * The last low order bit is always ignored as this\\n     * corresponds to the MBZ (must be zero) bit.\\n     * \u003cp\u003e\\n     * Setting bits in the precedence field may result in a\\n     * SocketException indicating that the operation is not\\n     * permitted.\\n     * \u003cp\u003e\\n     * for Internet Protocol v6 {@code tc} is the value that\\n     * would be placed into the sin6_flowinfo field of the IP header.\\n     *\\n     * @param tc        an {@code int} value for the bitset.\\n     * @throws SocketException if there is an error setting the\\n     * traffic class or type-of-service\\n     * @since 1.4\\n     * @see #getTrafficClass\\n     \u0027}"}, {"color": "#97c2fc", "id": "public synchronized int getTrafficClass() throws SocketException", "label": "public synchronized int getTrafficClass() throws SocketException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets traffic class or type-of-service in the IP datagram\\n     * header for packets sent from this DatagramSocket.\\n     * \u003cp\u003e\\n     * As the underlying network implementation may ignore the\\n     * traffic class or type-of-service set using {@link #setTrafficClass(int)}\\n     * this method may return a different value than was previously\\n     * set using the {@link #setTrafficClass(int)} method on this\\n     * DatagramSocket.\\n     *\\n     * @return the traffic class or type-of-service already set\\n     * @throws SocketException if there is an error obtaining the\\n     * traffic class or type-of-service value.\\n     * @since 1.4\\n     * @see #setTrafficClass(int)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public DatagramChannel getChannel()", "label": "public DatagramChannel getChannel()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the unique {@link java.nio.channels.DatagramChannel} object\\n     * associated with this datagram socket, if any.\\n     *\\n     * \u003cp\u003e A datagram socket will have a channel if, and only if, the channel\\n     * itself was created via the {@link java.nio.channels.DatagramChannel#open\\n     * DatagramChannel.open} method.\\n     *\\n     * @return  the datagram channel associated with this datagram socket,\\n     *          or {@code null} if this socket was not created for a channel\\n     *\\n     * @since 1.4\\n     * @spec JSR-51\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static synchronized void setDatagramSocketImplFactory(DatagramSocketImplFactory fac) throws IOException", "label": "public static synchronized void setDatagramSocketImplFactory(DatagramSocketImplFactory fac) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Sets the datagram socket implementation factory for the\\n     * application. The factory can be specified only once.\\n     * \u003cp\u003e\\n     * When an application creates a new datagram socket, the socket\\n     * implementation factory\u0027s {@code createDatagramSocketImpl} method is\\n     * called to create the actual datagram socket implementation.\\n     * \u003cp\u003e\\n     * Passing {@code null} to the method is a no-op unless the factory\\n     * was already set.\\n     *\\n     * \u003cp\u003eIf there is a security manager, this method first calls\\n     * the security manager\u0027s {@code checkSetFactory} method\\n     * to ensure the operation is allowed.\\n     * This could result in a SecurityException.\\n     *\\n     * @param      fac   the desired factory.\\n     * @exception  IOException  if an I/O error occurs when setting the\\n     *              datagram socket factory.\\n     * @exception  SocketException  if the factory is already defined.\\n     * @exception  SecurityException  if a security manager exists and its\\n     *             {@code checkSetFactory} method doesn\u0027t allow the operation.\\n     * @see       java.net.DatagramSocketImplFactory#createDatagramSocketImpl()\\n     * @see       SecurityManager#checkSetFactory\\n     * @since 1.3\\n     \"}"}, {"color": "#97c2fc", "id": "public DatagramSocket setOption(SocketOption\u003cT\u003e name, T value) throws IOException", "label": "public DatagramSocket setOption(SocketOption\u003cT\u003e name, T value) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the value of a socket option.\\n     *\\n     * @param \u003cT\u003e The type of the socket option value\\n     * @param name The socket option\\n     * @param value The value of the socket option. A value of {@code null}\\n     *              may be valid for some options.\\n     *\\n     * @return this DatagramSocket\\n     *\\n     * @throws UnsupportedOperationException if the datagram socket\\n     *         does not support the option.\\n     *\\n     * @throws IllegalArgumentException if the value is not valid for\\n     *         the option.\\n     *\\n     * @throws IOException if an I/O error occurs, or if the socket is closed.\\n     *\\n     * @throws SecurityException if a security manager is set and if the socket\\n     *         option requires a security permission and if the caller does\\n     *         not have the required permission.\\n     *         {@link java.net.StandardSocketOptions StandardSocketOptions}\\n     *         do not require any security permission.\\n     *\\n     * @throws NullPointerException if name is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract DatagramChannel connect(SocketAddress remote) throws IOException", "label": "public abstract DatagramChannel connect(SocketAddress remote) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Connects this channel\u0027s socket.\\n     *\\n     * \u003cp\u003e The channel\u0027s socket is configured so that it only receives\\n     * datagrams from, and sends datagrams to, the given remote \u003ci\u003epeer\u003c/i\u003e\\n     * address.  Once connected, datagrams may not be received from or sent to\\n     * any other address.  A datagram socket remains connected until it is\\n     * explicitly disconnected or until it is closed.\\n     *\\n     * \u003cp\u003e This method performs exactly the same security checks as the {@link\\n     * java.net.DatagramSocket#connect connect} method of the {@link\\n     * java.net.DatagramSocket} class.  That is, if a security manager has been\\n     * installed then this method verifies that its {@link\\n     * java.lang.SecurityManager#checkAccept checkAccept} and {@link\\n     * java.lang.SecurityManager#checkConnect checkConnect} methods permit\\n     * datagrams to be received from and sent to, respectively, the given\\n     * remote address.\\n     *\\n     * \u003cp\u003e This method may be invoked at any time.  It will not have any effect\\n     * on read or write operations that are already in progress at the moment\\n     * that it is invoked. If this channel\u0027s socket is not bound then this method\\n     * will first cause the socket to be bound to an address that is assigned\\n     * automatically, as if invoking the {@link #bind bind} method with a\\n     * parameter of {@code null}. \u003c/p\u003e\\n     *\\n     * @param  remote\\n     *         The remote address to which this channel is to be connected\\n     *\\n     * @return  This datagram channel\\n     *\\n     * @throws  AlreadyConnectedException\\n     *          If this channel is already connected\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     *\\n     * @throws  AsynchronousCloseException\\n     *          If another thread closes this channel\\n     *          while the connect operation is in progress\\n     *\\n     * @throws  ClosedByInterruptException\\n     *          If another thread interrupts the current thread\\n     *          while the connect operation is in progress, thereby\\n     *          closing the channel and setting the current thread\u0027s\\n     *          interrupt status\\n     *\\n     * @throws  UnresolvedAddressException\\n     *          If the given remote address is not fully resolved\\n     *\\n     * @throws  UnsupportedAddressTypeException\\n     *          If the type of the given remote address is not supported\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager has been installed\\n     *          and it does not permit access to the given remote address\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "bind", "label": "bind", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract DatagramChannel disconnect() throws IOException", "label": "public abstract DatagramChannel disconnect() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Disconnects this channel\u0027s socket.\\n     *\\n     * \u003cp\u003e The channel\u0027s socket is configured so that it can receive datagrams\\n     * from, and sends datagrams to, any remote address so long as the security\\n     * manager, if installed, permits it.\\n     *\\n     * \u003cp\u003e This method may be invoked at any time.  It will not have any effect\\n     * on read or write operations that are already in progress at the moment\\n     * that it is invoked.\\n     *\\n     * \u003cp\u003e If this channel\u0027s socket is not connected, or if the channel is\\n     * closed, then invoking this method has no effect.  \u003c/p\u003e\\n     *\\n     * @return  This datagram channel\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract SocketAddress receive(ByteBuffer dst) throws IOException", "label": "public abstract SocketAddress receive(ByteBuffer dst) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Receives a datagram via this channel.\\n     *\\n     * \u003cp\u003e If a datagram is immediately available, or if this channel is in\\n     * blocking mode and one eventually becomes available, then the datagram is\\n     * copied into the given byte buffer and its source address is returned.\\n     * If this channel is in non-blocking mode and a datagram is not\\n     * immediately available then this method immediately returns\\n     * {@code null}.\\n     *\\n     * \u003cp\u003e The datagram is transferred into the given byte buffer starting at\\n     * its current position, as if by a regular {@link\\n     * ReadableByteChannel#read(java.nio.ByteBuffer) read} operation.  If there\\n     * are fewer bytes remaining in the buffer than are required to hold the\\n     * datagram then the remainder of the datagram is silently discarded.\\n     *\\n     * \u003cp\u003e This method performs exactly the same security checks as the {@link\\n     * java.net.DatagramSocket#receive receive} method of the {@link\\n     * java.net.DatagramSocket} class.  That is, if the socket is not connected\\n     * to a specific remote address and a security manager has been installed\\n     * then for each datagram received this method verifies that the source\u0027s\\n     * address and port number are permitted by the security manager\u0027s {@link\\n     * java.lang.SecurityManager#checkAccept checkAccept} method.  The overhead\\n     * of this security check can be avoided by first connecting the socket via\\n     * the {@link #connect connect} method.\\n     *\\n     * \u003cp\u003e This method may be invoked at any time.  If another thread has\\n     * already initiated a read operation upon this channel, however, then an\\n     * invocation of this method will block until the first operation is\\n     * complete. If this channel\u0027s socket is not bound then this method will\\n     * first cause the socket to be bound to an address that is assigned\\n     * automatically, as if invoking the {@link #bind bind} method with a\\n     * parameter of {@code null}. \u003c/p\u003e\\n     *\\n     * @param  dst\\n     *         The buffer into which the datagram is to be transferred\\n     *\\n     * @return  The datagram\u0027s source address,\\n     *          or {@code null} if this channel is in non-blocking mode\\n     *          and no datagram was immediately available\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     *\\n     * @throws  AsynchronousCloseException\\n     *          If another thread closes this channel\\n     *          while the read operation is in progress\\n     *\\n     * @throws  ClosedByInterruptException\\n     *          If another thread interrupts the current thread\\n     *          while the read operation is in progress, thereby\\n     *          closing the channel and setting the current thread\u0027s\\n     *          interrupt status\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager has been installed\\n     *          and it does not permit datagrams to be accepted\\n     *          from the datagram\u0027s sender\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "read(java.nio.ByteBuffer)", "label": "read(java.nio.ByteBuffer)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.channels.ReadableByteChannel", "label": "java.nio.channels.ReadableByteChannel", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public int read(ByteBuffer dst) throws IOException", "label": "public int read(ByteBuffer dst) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reads a sequence of bytes from this channel into the given buffer.\\n     *\\n     * \u003cp\u003e An attempt is made to read up to \u003ci\u003er\u003c/i\u003e bytes from the channel,\\n     * where \u003ci\u003er\u003c/i\u003e is the number of bytes remaining in the buffer, that is,\\n     * {@code dst.remaining()}, at the moment this method is invoked.\\n     *\\n     * \u003cp\u003e Suppose that a byte sequence of length \u003ci\u003en\u003c/i\u003e is read, where\\n     * {@code 0}\u0026nbsp;{@code \u003c=}\u0026nbsp;\u003ci\u003en\u003c/i\u003e\u0026nbsp;{@code \u003c=}\u0026nbsp;\u003ci\u003er\u003c/i\u003e.\\n     * This byte sequence will be transferred into the buffer so that the first\\n     * byte in the sequence is at index \u003ci\u003ep\u003c/i\u003e and the last byte is at index\\n     * \u003ci\u003ep\u003c/i\u003e\u0026nbsp;{@code +}\u0026nbsp;\u003ci\u003en\u003c/i\u003e\u0026nbsp;{@code -}\u0026nbsp;{@code 1},\\n     * where \u003ci\u003ep\u003c/i\u003e is the buffer\u0027s position at the moment this method is\\n     * invoked.  Upon return the buffer\u0027s position will be equal to\\n     * \u003ci\u003ep\u003c/i\u003e\u0026nbsp;{@code +}\u0026nbsp;\u003ci\u003en\u003c/i\u003e; its limit will not have changed.\\n     *\\n     * \u003cp\u003e A read operation might not fill the buffer, and in fact it might not\\n     * read any bytes at all.  Whether or not it does so depends upon the\\n     * nature and state of the channel.  A socket channel in non-blocking mode,\\n     * for example, cannot read any more bytes than are immediately available\\n     * from the socket\u0027s input buffer; similarly, a file channel cannot read\\n     * any more bytes than remain in the file.  It is guaranteed, however, that\\n     * if a channel is in blocking mode and there is at least one byte\\n     * remaining in the buffer then this method will block until at least one\\n     * byte is read.\\n     *\\n     * \u003cp\u003e This method may be invoked at any time.  If another thread has\\n     * already initiated a read operation upon this channel, however, then an\\n     * invocation of this method will block until the first operation is\\n     * complete. \u003c/p\u003e\\n     *\\n     * @param  dst\\n     *         The buffer into which bytes are to be transferred\\n     *\\n     * @return  The number of bytes read, possibly zero, or {@code -1} if the\\n     *          channel has reached end-of-stream\\n     *\\n     * @throws  NonReadableChannelException\\n     *          If this channel was not opened for reading\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     *\\n     * @throws  AsynchronousCloseException\\n     *          If another thread closes this channel\\n     *          while the read operation is in progress\\n     *\\n     * @throws  ClosedByInterruptException\\n     *          If another thread interrupts the current thread\\n     *          while the read operation is in progress, thereby\\n     *          closing the channel and setting the current thread\u0027s\\n     *          interrupt status\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "connect", "label": "connect", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract int send(ByteBuffer src, SocketAddress target) throws IOException", "label": "public abstract int send(ByteBuffer src, SocketAddress target) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Sends a datagram via this channel.\\n     *\\n     * \u003cp\u003e If this channel is in non-blocking mode and there is sufficient room\\n     * in the underlying output buffer, or if this channel is in blocking mode\\n     * and sufficient room becomes available, then the remaining bytes in the\\n     * given buffer are transmitted as a single datagram to the given target\\n     * address.\\n     *\\n     * \u003cp\u003e The datagram is transferred from the byte buffer as if by a regular\\n     * {@link WritableByteChannel#write(java.nio.ByteBuffer) write} operation.\\n     *\\n     * \u003cp\u003e This method performs exactly the same security checks as the {@link\\n     * java.net.DatagramSocket#send send} method of the {@link\\n     * java.net.DatagramSocket} class.  That is, if the socket is not connected\\n     * to a specific remote address and a security manager has been installed\\n     * then for each datagram sent this method verifies that the target address\\n     * and port number are permitted by the security manager\u0027s {@link\\n     * java.lang.SecurityManager#checkConnect checkConnect} method.  The\\n     * overhead of this security check can be avoided by first connecting the\\n     * socket via the {@link #connect connect} method.\\n     *\\n     * \u003cp\u003e This method may be invoked at any time.  If another thread has\\n     * already initiated a write operation upon this channel, however, then an\\n     * invocation of this method will block until the first operation is\\n     * complete. If this channel\u0027s socket is not bound then this method will\\n     * first cause the socket to be bound to an address that is assigned\\n     * automatically, as if by invoking the {@link #bind bind} method with a\\n     * parameter of {@code null}. \u003c/p\u003e\\n     *\\n     * @param  src\\n     *         The buffer containing the datagram to be sent\\n     *\\n     * @param  target\\n     *         The address to which the datagram is to be sent\\n     *\\n     * @return   The number of bytes sent, which will be either the number\\n     *           of bytes that were remaining in the source buffer when this\\n     *           method was invoked or, if this channel is non-blocking, may be\\n     *           zero if there was insufficient room for the datagram in the\\n     *           underlying output buffer\\n     *\\n     * @throws  AlreadyConnectedException\\n     *          If this channel is connected to a different address\\n     *          from that specified by {@code target}\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     *\\n     * @throws  AsynchronousCloseException\\n     *          If another thread closes this channel\\n     *          while the read operation is in progress\\n     *\\n     * @throws  ClosedByInterruptException\\n     *          If another thread interrupts the current thread\\n     *          while the read operation is in progress, thereby\\n     *          closing the channel and setting the current thread\u0027s\\n     *          interrupt status\\n     *\\n     * @throws  UnresolvedAddressException\\n     *          If the given remote address is not fully resolved\\n     *\\n     * @throws  UnsupportedAddressTypeException\\n     *          If the type of the given remote address is not supported\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager has been installed\\n     *          and it does not permit datagrams to be sent\\n     *          to the given address\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "write(java.nio.ByteBuffer)", "label": "write(java.nio.ByteBuffer)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.channels.WritableByteChannel", "label": "java.nio.channels.WritableByteChannel", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public int write(ByteBuffer src) throws IOException", "label": "public int write(ByteBuffer src) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Writes a sequence of bytes to this channel from the given buffer.\\n     *\\n     * \u003cp\u003e An attempt is made to write up to \u003ci\u003er\u003c/i\u003e bytes to the channel,\\n     * where \u003ci\u003er\u003c/i\u003e is the number of bytes remaining in the buffer, that is,\\n     * {@code src.remaining()}, at the moment this method is invoked.\\n     *\\n     * \u003cp\u003e Suppose that a byte sequence of length \u003ci\u003en\u003c/i\u003e is written, where\\n     * {@code 0}\u0026nbsp;{@code \u003c=}\u0026nbsp;\u003ci\u003en\u003c/i\u003e\u0026nbsp;{@code \u003c=}\u0026nbsp;\u003ci\u003er\u003c/i\u003e.\\n     * This byte sequence will be transferred from the buffer starting at index\\n     * \u003ci\u003ep\u003c/i\u003e, where \u003ci\u003ep\u003c/i\u003e is the buffer\u0027s position at the moment this\\n     * method is invoked; the index of the last byte written will be\\n     * \u003ci\u003ep\u003c/i\u003e\u0026nbsp;{@code +}\u0026nbsp;\u003ci\u003en\u003c/i\u003e\u0026nbsp;{@code -}\u0026nbsp;{@code 1}.\\n     * Upon return the buffer\u0027s position will be equal to\\n     * \u003ci\u003ep\u003c/i\u003e\u0026nbsp;{@code +}\u0026nbsp;\u003ci\u003en\u003c/i\u003e; its limit will not have changed.\\n     *\\n     * \u003cp\u003e Unless otherwise specified, a write operation will return only after\\n     * writing all of the \u003ci\u003er\u003c/i\u003e requested bytes.  Some types of channels,\\n     * depending upon their state, may write only some of the bytes or possibly\\n     * none at all.  A socket channel in non-blocking mode, for example, cannot\\n     * write any more bytes than are free in the socket\u0027s output buffer.\\n     *\\n     * \u003cp\u003e This method may be invoked at any time.  If another thread has\\n     * already initiated a write operation upon this channel, however, then an\\n     * invocation of this method will block until the first operation is\\n     * complete. \u003c/p\u003e\\n     *\\n     * @param  src\\n     *         The buffer from which bytes are to be retrieved\\n     *\\n     * @return The number of bytes written, possibly zero\\n     *\\n     * @throws  NonWritableChannelException\\n     *          If this channel was not opened for writing\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     *\\n     * @throws  AsynchronousCloseException\\n     *          If another thread closes this channel\\n     *          while the write operation is in progress\\n     *\\n     * @throws  ClosedByInterruptException\\n     *          If another thread interrupts the current thread\\n     *          while the write operation is in progress, thereby\\n     *          closing the channel and setting the current thread\u0027s\\n     *          interrupt status\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "java.nio.channels.ScatteringByteChannel", "label": "java.nio.channels.ScatteringByteChannel", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public long read(ByteBuffer[] dsts, int offset, int length) throws IOException", "label": "public long read(ByteBuffer[] dsts, int offset, int length) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reads a sequence of bytes from this channel into a subsequence of the\\n     * given buffers.\\n     *\\n     * \u003cp\u003e An invocation of this method attempts to read up to \u003ci\u003er\u003c/i\u003e bytes\\n     * from this channel, where \u003ci\u003er\u003c/i\u003e is the total number of bytes remaining\\n     * the specified subsequence of the given buffer array, that is,\\n     *\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * dsts[offset].remaining()\\n     *     + dsts[offset+1].remaining()\\n     *     + ... + dsts[offset+length-1].remaining()\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * at the moment that this method is invoked.\\n     *\\n     * \u003cp\u003e Suppose that a byte sequence of length \u003ci\u003en\u003c/i\u003e is read, where\\n     * {@code 0}\u0026nbsp;{@code \u003c=}\u0026nbsp;\u003ci\u003en\u003c/i\u003e\u0026nbsp;{@code \u003c=}\u0026nbsp;\u003ci\u003er\u003c/i\u003e.\\n     * Up to the first {@code dsts[offset].remaining()} bytes of this sequence\\n     * are transferred into buffer {@code dsts[offset]}, up to the next\\n     * {@code dsts[offset+1].remaining()} bytes are transferred into buffer\\n     * {@code dsts[offset+1]}, and so forth, until the entire byte sequence\\n     * is transferred into the given buffers.  As many bytes as possible are\\n     * transferred into each buffer, hence the final position of each updated\\n     * buffer, except the last updated buffer, is guaranteed to be equal to\\n     * that buffer\u0027s limit.\\n     *\\n     * \u003cp\u003e This method may be invoked at any time.  If another thread has\\n     * already initiated a read operation upon this channel, however, then an\\n     * invocation of this method will block until the first operation is\\n     * complete. \u003c/p\u003e\\n     *\\n     * @param  dsts\\n     *         The buffers into which bytes are to be transferred\\n     *\\n     * @param  offset\\n     *         The offset within the buffer array of the first buffer into\\n     *         which bytes are to be transferred; must be non-negative and no\\n     *         larger than {@code dsts.length}\\n     *\\n     * @param  length\\n     *         The maximum number of buffers to be accessed; must be\\n     *         non-negative and no larger than\\n     *         {@code dsts.length}\u0026nbsp;-\u0026nbsp;{@code offset}\\n     *\\n     * @return The number of bytes read, possibly zero,\\n     *         or {@code -1} if the channel has reached end-of-stream\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If the preconditions on the {@code offset} and {@code length}\\n     *          parameters do not hold\\n     *\\n     * @throws  NonReadableChannelException\\n     *          If this channel was not opened for reading\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     *\\n     * @throws  AsynchronousCloseException\\n     *          If another thread closes this channel\\n     *          while the read operation is in progress\\n     *\\n     * @throws  ClosedByInterruptException\\n     *          If another thread interrupts the current thread\\n     *          while the read operation is in progress, thereby\\n     *          closing the channel and setting the current thread\u0027s\\n     *          interrupt status\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "public long read(ByteBuffer[] dsts) throws IOException", "label": "public long read(ByteBuffer[] dsts) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reads a sequence of bytes from this channel into the given buffers.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form {@code c.read(dsts)}\\n     * behaves in exactly the same manner as the invocation\\n     *\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * c.read(dsts, 0, dsts.length);\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @param  dsts\\n     *         The buffers into which bytes are to be transferred\\n     *\\n     * @return The number of bytes read, possibly zero,\\n     *         or {@code -1} if the channel has reached end-of-stream\\n     *\\n     * @throws  NonReadableChannelException\\n     *          If this channel was not opened for reading\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     *\\n     * @throws  AsynchronousCloseException\\n     *          If another thread closes this channel\\n     *          while the read operation is in progress\\n     *\\n     * @throws  ClosedByInterruptException\\n     *          If another thread interrupts the current thread\\n     *          while the read operation is in progress, thereby\\n     *          closing the channel and setting the current thread\u0027s\\n     *          interrupt status\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "java.nio.channels.GatheringByteChannel", "label": "java.nio.channels.GatheringByteChannel", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public long write(ByteBuffer[] srcs, int offset, int length) throws IOException", "label": "public long write(ByteBuffer[] srcs, int offset, int length) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Writes a sequence of bytes to this channel from a subsequence of the\\n     * given buffers.\\n     *\\n     * \u003cp\u003e An attempt is made to write up to \u003ci\u003er\u003c/i\u003e bytes to this channel,\\n     * where \u003ci\u003er\u003c/i\u003e is the total number of bytes remaining in the specified\\n     * subsequence of the given buffer array, that is,\\n     *\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * srcs[offset].remaining()\\n     *     + srcs[offset+1].remaining()\\n     *     + ... + srcs[offset+length-1].remaining()\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * at the moment that this method is invoked.\\n     *\\n     * \u003cp\u003e Suppose that a byte sequence of length \u003ci\u003en\u003c/i\u003e is written, where\\n     * {@code 0}\u0026nbsp;{@code \u003c=}\u0026nbsp;\u003ci\u003en\u003c/i\u003e\u0026nbsp;{@code \u003c=}\u0026nbsp;\u003ci\u003er\u003c/i\u003e.\\n     * Up to the first {@code srcs[offset].remaining()} bytes of this sequence\\n     * are written from buffer {@code srcs[offset]}, up to the next\\n     * {@code srcs[offset+1].remaining()} bytes are written from buffer\\n     * {@code srcs[offset+1]}, and so forth, until the entire byte sequence is\\n     * written.  As many bytes as possible are written from each buffer, hence\\n     * the final position of each updated buffer, except the last updated\\n     * buffer, is guaranteed to be equal to that buffer\u0027s limit.\\n     *\\n     * \u003cp\u003e Unless otherwise specified, a write operation will return only after\\n     * writing all of the \u003ci\u003er\u003c/i\u003e requested bytes.  Some types of channels,\\n     * depending upon their state, may write only some of the bytes or possibly\\n     * none at all.  A socket channel in non-blocking mode, for example, cannot\\n     * write any more bytes than are free in the socket\u0027s output buffer.\\n     *\\n     * \u003cp\u003e This method may be invoked at any time.  If another thread has\\n     * already initiated a write operation upon this channel, however, then an\\n     * invocation of this method will block until the first operation is\\n     * complete. \u003c/p\u003e\\n     *\\n     * @param  srcs\\n     *         The buffers from which bytes are to be retrieved\\n     *\\n     * @param  offset\\n     *         The offset within the buffer array of the first buffer from\\n     *         which bytes are to be retrieved; must be non-negative and no\\n     *         larger than {@code srcs.length}\\n     *\\n     * @param  length\\n     *         The maximum number of buffers to be accessed; must be\\n     *         non-negative and no larger than\\n     *         {@code srcs.length}\u0026nbsp;-\u0026nbsp;{@code offset}\\n     *\\n     * @return  The number of bytes written, possibly zero\\n     *\\n     * @throws  IndexOutOfBoundsException\\n     *          If the preconditions on the {@code offset} and {@code length}\\n     *          parameters do not hold\\n     *\\n     * @throws  NonWritableChannelException\\n     *          If this channel was not opened for writing\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     *\\n     * @throws  AsynchronousCloseException\\n     *          If another thread closes this channel\\n     *          while the write operation is in progress\\n     *\\n     * @throws  ClosedByInterruptException\\n     *          If another thread interrupts the current thread\\n     *          while the write operation is in progress, thereby\\n     *          closing the channel and setting the current thread\u0027s\\n     *          interrupt status\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "public long write(ByteBuffer[] srcs) throws IOException", "label": "public long write(ByteBuffer[] srcs) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Writes a sequence of bytes to this channel from the given buffers.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form {@code c.write(srcs)}\\n     * behaves in exactly the same manner as the invocation\\n     *\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * c.write(srcs, 0, srcs.length);\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @param  srcs\\n     *         The buffers from which bytes are to be retrieved\\n     *\\n     * @return  The number of bytes written, possibly zero\\n     *\\n     * @throws  NonWritableChannelException\\n     *          If this channel was not opened for writing\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     *\\n     * @throws  AsynchronousCloseException\\n     *          If another thread closes this channel\\n     *          while the write operation is in progress\\n     *\\n     * @throws  ClosedByInterruptException\\n     *          If another thread interrupts the current thread\\n     *          while the write operation is in progress, thereby\\n     *          closing the channel and setting the current thread\u0027s\\n     *          interrupt status\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "RuntimePermission", "label": "RuntimePermission", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "java.nio.channels.Channel", "label": "java.nio.channels.Channel", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public boolean isOpen()", "label": "public boolean isOpen()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this channel is open.\\n     *\\n     * @return {@code true} if, and only if, this channel is open\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void setSecurityManager(final SecurityManager s)", "label": "public static void setSecurityManager(final SecurityManager s)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Throws {@code SecurityException} (except in case {@code sm == null}).\\n     *\\n     * \u003cp\u003eSecurity managers do \u003ci\u003enot\u003c/i\u003e provide a secure environment for\\n     * executing untrusted code and are unsupported on Android. Untrusted code\\n     * cannot be safely isolated within a single VM on Android, so this method\\n     * \u003ci\u003ealways\u003c/i\u003e throws a {@code SecurityException} when passed a non-null SecurityManager\\n     *\\n     * @param s a security manager\\n     * @throws SecurityException always, unless {@code sm == null}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static SecurityManager getSecurityManager()", "label": "public static SecurityManager getSecurityManager()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Always returns {@code null} in Android\\n     *\\n     * @return  {@code null} in Android\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static native long currentTimeMillis()", "label": "public static native long currentTimeMillis()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the current time in milliseconds.  Note that\\n     * while the unit of time of the return value is a millisecond,\\n     * the granularity of the value depends on the underlying\\n     * operating system and may be larger.  For example, many\\n     * operating systems measure time in units of tens of\\n     * milliseconds.\\n     *\\n     * \u003cp\u003e See the description of the class \u003ccode\u003eDate\u003c/code\u003e for\\n     * a discussion of slight discrepancies that may arise between\\n     * \"computer time\" and coordinated universal time (UTC).\\n     *\\n     * @return  the difference, measured in milliseconds, between\\n     *          the current time and midnight, January 1, 1970 UTC.\\n     * @see     java.util.Date\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static native long nanoTime()", "label": "public static native long nanoTime()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the current value of the running Java Virtual Machine\u0027s\\n     * high-resolution time source, in nanoseconds.\\n     *\\n     * \u003cp\u003eThis method can only be used to measure elapsed time and is\\n     * not related to any other notion of system or wall-clock time.\\n     * The value returned represents nanoseconds since some fixed but\\n     * arbitrary \u003ci\u003eorigin\u003c/i\u003e time (perhaps in the future, so values\\n     * may be negative).  The same origin is used by all invocations of\\n     * this method in an instance of a Java virtual machine; other\\n     * virtual machine instances are likely to use a different origin.\\n     *\\n     * \u003cp\u003eThis method provides nanosecond precision, but not necessarily\\n     * nanosecond resolution (that is, how frequently the value changes)\\n     * - no guarantees are made except that the resolution is at least as\\n     * good as that of {@link #currentTimeMillis()}.\\n     *\\n     * \u003cp\u003eDifferences in successive calls that span greater than\\n     * approximately 292 years (2\u003csup\u003e63\u003c/sup\u003e nanoseconds) will not\\n     * correctly compute elapsed time due to numerical overflow.\\n     *\\n     * \u003cp\u003eThe values returned by this method become meaningful only when\\n     * the difference between two such values, obtained within the same\\n     * instance of a Java virtual machine, is computed.\\n     *\\n     * \u003cp\u003e For example, to measure how long some code takes to execute:\\n     *  \u003cpre\u003e {@code\\n     * long startTime = System.nanoTime();\\n     * // ... the code being measured ...\\n     * long estimatedTime = System.nanoTime() - startTime;}\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eTo compare two nanoTime values\\n     *  \u003cpre\u003e {@code\\n     * long t0 = System.nanoTime();\\n     * ...\\n     * long t1 = System.nanoTime();}\u003c/pre\u003e\\n     *\\n     * one should use {@code t1 - t0 \u003c 0}, not {@code t1 \u003c t0},\\n     * because of the possibility of numerical overflow.\\n     *\\n     * \u003cp\u003eThe value returned by this method does not account for elapsed\\n     * time during deep sleep. For timekeeping facilities available on\\n     * Android see {@link android.os.SystemClock}.\\n     *\\n     * @return the current value of the running Java Virtual Machine\u0027s\\n     *         high-resolution time source, in nanoseconds\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": "currentTimeMillis()", "label": "currentTimeMillis()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "android.os.SystemClock", "label": "android.os.SystemClock", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Core timekeeping facilities.\\n *\\n * \u003cp\u003e Three different clocks are available, and they should not be confused:\\n *\\n * \u003cul\u003e\\n *     \u003cli\u003e \u003cp\u003e {@link System#currentTimeMillis System.currentTimeMillis()}\\n *     is the standard \"wall\" clock (time and date) expressing milliseconds\\n *     since the epoch.  The wall clock can be set by the user or the phone\\n *     network (see {@link #setCurrentTimeMillis}), so the time may jump\\n *     backwards or forwards unpredictably.  This clock should only be used\\n *     when correspondence with real-world dates and times is important, such\\n *     as in a calendar or alarm clock application.  Interval or elapsed\\n *     time measurements should use a different clock.  If you are using\\n *     System.currentTimeMillis(), consider listening to the\\n *     {@link android.content.Intent#ACTION_TIME_TICK ACTION_TIME_TICK},\\n *     {@link android.content.Intent#ACTION_TIME_CHANGED ACTION_TIME_CHANGED}\\n *     and {@link android.content.Intent#ACTION_TIMEZONE_CHANGED\\n *     ACTION_TIMEZONE_CHANGED} {@link android.content.Intent Intent}\\n *     broadcasts to find out when the time changes.\\n *\\n *     \u003cli\u003e \u003cp\u003e {@link #uptimeMillis} is counted in milliseconds since the\\n *     system was booted.  This clock stops when the system enters deep\\n *     sleep (CPU off, display dark, device waiting for external input),\\n *     but is not affected by clock scaling, idle, or other power saving\\n *     mechanisms.  This is the basis for most interval timing\\n *     such as {@link Thread#sleep(long) Thread.sleep(millls)},\\n *     {@link Object#wait(long) Object.wait(millis)}, and\\n *     {@link System#nanoTime System.nanoTime()}.  This clock is guaranteed\\n *     to be monotonic, and is suitable for interval timing when the\\n *     interval does not span device sleep.  Most methods that accept a\\n *     timestamp value currently expect the {@link #uptimeMillis} clock.\\n *\\n *     \u003cli\u003e \u003cp\u003e {@link #elapsedRealtime} and {@link #elapsedRealtimeNanos}\\n *     return the time since the system was booted, and include deep sleep.\\n *     This clock is guaranteed to be monotonic, and continues to tick even\\n *     when the CPU is in power saving modes, so is the recommend basis\\n *     for general purpose interval timing.\\n *\\n * \u003c/ul\u003e\\n *\\n * There are several mechanisms for controlling the timing of events:\\n *\\n * \u003cul\u003e\\n *     \u003cli\u003e \u003cp\u003e Standard functions like {@link Thread#sleep(long)\\n *     Thread.sleep(millis)} and {@link Object#wait(long) Object.wait(millis)}\\n *     are always available.  These functions use the {@link #uptimeMillis}\\n *     clock; if the device enters sleep, the remainder of the time will be\\n *     postponed until the device wakes up.  These synchronous functions may\\n *     be interrupted with {@link Thread#interrupt Thread.interrupt()}, and\\n *     you must handle {@link InterruptedException}.\\n *\\n *     \u003cli\u003e \u003cp\u003e {@link #sleep SystemClock.sleep(millis)} is a utility function\\n *     very similar to {@link Thread#sleep(long) Thread.sleep(millis)}, but it\\n *     ignores {@link InterruptedException}.  Use this function for delays if\\n *     you do not use {@link Thread#interrupt Thread.interrupt()}, as it will\\n *     preserve the interrupted state of the thread.\\n *\\n *     \u003cli\u003e \u003cp\u003e The {@link android.os.Handler} class can schedule asynchronous\\n *     callbacks at an absolute or relative time.  Handler objects also use the\\n *     {@link #uptimeMillis} clock, and require an {@link android.os.Looper\\n *     event loop} (normally present in any GUI application).\\n *\\n *     \u003cli\u003e \u003cp\u003e The {@link android.app.AlarmManager} can trigger one-time or\\n *     recurring events which occur even when the device is in deep sleep\\n *     or your application is not running.  Events may be scheduled with your\\n *     choice of {@link java.lang.System#currentTimeMillis} (RTC) or\\n *     {@link #elapsedRealtime} (ELAPSED_REALTIME), and cause an\\n *     {@link android.content.Intent} broadcast when they occur.\\n * \u003c/ul\u003e\\n \u0027}"}, {"color": "#97c2fc", "id": "public static void sleep(long ms)", "label": "public static void sleep(long ms)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Waits a given number of milliseconds (of uptimeMillis) before returning.\\n     * Similar to {@link java.lang.Thread#sleep(long)}, but does not throw\\n     * {@link InterruptedException}; {@link Thread#interrupt()} events are\\n     * deferred until the next interruptible operation.  Does not return until\\n     * at least the specified number of milliseconds has elapsed.\\n     *\\n     * @param ms to sleep before returning, in milliseconds of uptime.\\n     \u0027}"}, {"color": "#97c2fc", "id": "interrupt()", "label": "interrupt()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "sleep(long)", "label": "sleep(long)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.lang.Thread", "label": "java.lang.Thread", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * A \u003ci\u003ethread\u003c/i\u003e is a thread of execution in a program. The Java\\n * Virtual Machine allows an application to have multiple threads of\\n * execution running concurrently.\\n * \u003cp\u003e\\n * Every thread has a priority. Threads with higher priority are\\n * executed in preference to threads with lower priority. Each thread\\n * may or may not also be marked as a daemon. When code running in\\n * some thread creates a new {@code Thread} object, the new\\n * thread has its priority initially set equal to the priority of the\\n * creating thread, and is a daemon thread if and only if the\\n * creating thread is a daemon.\\n * \u003cp\u003e\\n * When a Java Virtual Machine starts up, there is usually a single\\n * non-daemon thread (which typically calls the method named\\n * {@code main} of some designated class). The Java Virtual\\n * Machine continues to execute threads until either of the following\\n * occurs:\\n * \u003cul\u003e\\n * \u003cli\u003eThe {@code exit} method of class {@code Runtime} has been\\n *     called and the security manager has permitted the exit operation\\n *     to take place.\\n * \u003cli\u003eAll threads that are not daemon threads have died, either by\\n *     returning from the call to the {@code run} method or by\\n *     throwing an exception that propagates beyond the {@code run}\\n *     method.\\n * \u003c/ul\u003e\\n * \u003cp\u003e\\n * There are two ways to create a new thread of execution. One is to\\n * declare a class to be a subclass of {@code Thread}. This\\n * subclass should override the {@code run} method of class\\n * {@code Thread}. An instance of the subclass can then be\\n * allocated and started. For example, a thread that computes primes\\n * larger than a stated value could be written as follows:\\n * \u003chr\u003e\u003cblockquote\u003e\u003cpre\u003e\\n *     class PrimeThread extends Thread {\\n *         long minPrime;\\n *         PrimeThread(long minPrime) {\\n *             this.minPrime = minPrime;\\n *         }\\n *\\n *         public void run() {\\n *             // compute primes larger than minPrime\\n *             \u0026nbsp;.\u0026nbsp;.\u0026nbsp;.\\n *         }\\n *     }\\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003chr\u003e\\n * \u003cp\u003e\\n * The following code would then create a thread and start it running:\\n * \u003cblockquote\u003e\u003cpre\u003e\\n *     PrimeThread p = new PrimeThread(143);\\n *     p.start();\\n * \u003c/pre\u003e\u003c/blockquote\u003e\\n * \u003cp\u003e\\n * The other way to create a thread is to declare a class that\\n * implements the {@code Runnable} interface. That class then\\n * implements the {@code run} method. An instance of the class can\\n * then be allocated, passed as an argument when creating\\n * {@code Thread}, and started. The same example in this other\\n * style looks like the following:\\n * \u003chr\u003e\u003cblockquote\u003e\u003cpre\u003e\\n *     class PrimeRun implements Runnable {\\n *         long minPrime;\\n *         PrimeRun(long minPrime) {\\n *             this.minPrime = minPrime;\\n *         }\\n *\\n *         public void run() {\\n *             // compute primes larger than minPrime\\n *             \u0026nbsp;.\u0026nbsp;.\u0026nbsp;.\\n *         }\\n *     }\\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003chr\u003e\\n * \u003cp\u003e\\n * The following code would then create a thread and start it running:\\n * \u003cblockquote\u003e\u003cpre\u003e\\n *     PrimeRun p = new PrimeRun(143);\\n *     new Thread(p).start();\\n * \u003c/pre\u003e\u003c/blockquote\u003e\\n * \u003cp\u003e\\n * Every thread has a name for identification purposes. More than\\n * one thread may have the same name. If a name is not specified when\\n * a thread is created, a new name is generated for it.\\n * \u003cp\u003e\\n * Unless otherwise noted, passing a {@code null} argument to a constructor\\n * or method in this class will cause a {@link NullPointerException} to be\\n * thrown.\\n *\\n * @author  unascribed\\n * @see     Runnable\\n * @see     Runtime#exit(int)\\n * @see     #run()\\n * @see     #stop()\\n * @since   1.0\\n \u0027}"}, {"color": "#97c2fc", "id": "public static native Thread currentThread()", "label": "public static native Thread currentThread()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a reference to the currently executing thread object.\\n     *\\n     * @return  the currently executing thread.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static native void yield()", "label": "public static native void yield()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * A hint to the scheduler that the current thread is willing to yield\\n     * its current use of a processor. The scheduler is free to ignore this\\n     * hint.\\n     *\\n     * \u003cp\u003e Yield is a heuristic attempt to improve relative progression\\n     * between threads that would otherwise over-utilise a CPU. Its use\\n     * should be combined with detailed profiling and benchmarking to\\n     * ensure that it actually has the desired effect.\\n     *\\n     * \u003cp\u003e It is rarely appropriate to use this method. It may be useful\\n     * for debugging or testing purposes, where it may help to reproduce\\n     * bugs due to race conditions. It may also be useful when designing\\n     * concurrency control constructs such as the ones in the\\n     * {@link java.util.concurrent.locks} package.\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.util.concurrent.locks", "label": "java.util.concurrent.locks", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public static void sleep(long millis) throws InterruptedException", "label": "public static void sleep(long millis) throws InterruptedException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 BEGIN Android-changed: Implement sleep() methods using a shared native implementation.\u0027}"}, {"color": "#97c2fc", "id": "public static void sleep(long millis, int nanos) throws InterruptedException", "label": "public static void sleep(long millis, int nanos) throws InterruptedException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Causes the currently executing thread to sleep (temporarily cease\\n     * execution) for the specified number of milliseconds plus the specified\\n     * number of nanoseconds, subject to the precision and accuracy of system\\n     * timers and schedulers. The thread does not lose ownership of any\\n     * monitors.\\n     *\\n     * @param  millis\\n     *         the length of time to sleep in milliseconds\\n     *\\n     * @param  nanos\\n     *         {@code 0-999999} additional nanoseconds to sleep\\n     *\\n     * @throws  IllegalArgumentException\\n     *          if the value of {@code millis} is negative, or the value of\\n     *          {@code nanos} is not in the range {@code 0-999999}\\n     *\\n     * @throws  InterruptedException\\n     *          if any thread has interrupted the current thread. The\\n     *          \u003ci\u003einterrupted status\u003c/i\u003e of the current thread is\\n     *          cleared when this exception is thrown.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void onSpinWait()", "label": "public static void onSpinWait()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Indicates that the caller is momentarily unable to progress, until the\\n     * occurrence of one or more actions on the part of other activities. By\\n     * invoking this method within each iteration of a spin-wait loop construct,\\n     * the calling thread indicates to the runtime that it is busy-waiting.\\n     * The runtime may take action to improve the performance of invoking\\n     * spin-wait loop constructions.\\n     *\\n     * @apiNote\\n     * As an example consider a method in a class that spins in a loop until\\n     * some flag is set outside of that method. A call to the {@code onSpinWait}\\n     * method should be placed inside the spin loop.\\n     * \u003cpre\u003e{@code\\n     *     class EventHandler {\\n     *         volatile boolean eventNotificationNotReceived;\\n     *         void waitForEventAndHandleIt() {\\n     *             while ( eventNotificationNotReceived ) {\\n     *                 java.lang.Thread.onSpinWait();\\n     *             }\\n     *             readAndProcessEvent();\\n     *         }\\n     *\\n     *         void readAndProcessEvent() {\\n     *             // Read event from some source and process it\\n     *              . . .\\n     *         }\\n     *     }\\n     * }\u003c/pre\u003e\\n     * \u003cp\u003e\\n     * The code above would remain correct even if the {@code onSpinWait}\\n     * method was not called at all. However on some architectures the Java\\n     * Virtual Machine may issue the processor instructions to address such\\n     * code patterns in a more beneficial way.\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected Object clone() throws CloneNotSupportedException", "label": "protected Object clone() throws CloneNotSupportedException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates and returns a copy of this object.  The precise meaning\\n     * of \"copy\" may depend on the class of the object. The general\\n     * intent is that, for any object {@code x}, the expression:\\n     * \u003cblockquote\u003e\\n     * \u003cpre\u003e\\n     * x.clone() != x\u003c/pre\u003e\u003c/blockquote\u003e\\n     * will be true, and that the expression:\\n     * \u003cblockquote\u003e\\n     * \u003cpre\u003e\\n     * x.clone().getClass() == x.getClass()\u003c/pre\u003e\u003c/blockquote\u003e\\n     * will be {@code true}, but these are not absolute requirements.\\n     * While it is typically the case that:\\n     * \u003cblockquote\u003e\\n     * \u003cpre\u003e\\n     * x.clone().equals(x)\u003c/pre\u003e\u003c/blockquote\u003e\\n     * will be {@code true}, this is not an absolute requirement.\\n     * \u003cp\u003e\\n     * By convention, the returned object should be obtained by calling\\n     * {@code super.clone}.  If a class and all of its superclasses (except\\n     * {@code Object}) obey this convention, it will be the case that\\n     * {@code x.clone().getClass() == x.getClass()}.\\n     * \u003cp\u003e\\n     * By convention, the object returned by this method should be independent\\n     * of this object (which is being cloned).  To achieve this independence,\\n     * it may be necessary to modify one or more fields of the object returned\\n     * by {@code super.clone} before returning it.  Typically, this means\\n     * copying any mutable objects that comprise the internal \"deep structure\"\\n     * of the object being cloned and replacing the references to these\\n     * objects with references to the copies.  If a class contains only\\n     * primitive fields or references to immutable objects, then it is usually\\n     * the case that no fields in the object returned by {@code super.clone}\\n     * need to be modified.\\n     *\\n     * @implSpec\\n     * The method {@code clone} for class {@code Object} performs a\\n     * specific cloning operation. First, if the class of this object does\\n     * not implement the interface {@code Cloneable}, then a\\n     * {@code CloneNotSupportedException} is thrown. Note that all arrays\\n     * are considered to implement the interface {@code Cloneable} and that\\n     * the return type of the {@code clone} method of an array type {@code T[]}\\n     * is {@code T[]} where T is any reference or primitive type.\\n     * Otherwise, this method creates a new instance of the class of this\\n     * object and initializes all its fields with exactly the contents of\\n     * the corresponding fields of this object, as if by assignment; the\\n     * contents of the fields are not themselves cloned. Thus, this method\\n     * performs a \"shallow copy\" of this object, not a \"deep copy\" operation.\\n     * \u003cp\u003e\\n     * The class {@code Object} does not itself implement the interface\\n     * {@code Cloneable}, so calling the {@code clone} method on an object\\n     * whose class is {@code Object} will result in throwing an\\n     * exception at run time.\\n     *\\n     * @return     a clone of this instance.\\n     * @throws  CloneNotSupportedException  if the object\\\u0027s class does not\\n     *               support the {@code Cloneable} interface. Subclasses\\n     *               that override the {@code clone} method can also\\n     *               throw this exception to indicate that an instance cannot\\n     *               be cloned.\\n     * @see java.lang.Cloneable\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void init2(Thread parent, boolean inheritThreadLocals)", "label": "private void init2(Thread parent, boolean inheritThreadLocals)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-added: Helper method for previous constructor and init(...) method.\u0027}"}, {"color": "#97c2fc", "id": "public synchronized void start()", "label": "public synchronized void start()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Causes this thread to begin execution; the Java Virtual Machine\\n     * calls the {@code run} method of this thread.\\n     * \u003cp\u003e\\n     * The result is that two threads are running concurrently: the\\n     * current thread (which returns from the call to the\\n     * {@code start} method) and the other thread (which executes its\\n     * {@code run} method).\\n     * \u003cp\u003e\\n     * It is never legal to start a thread more than once.\\n     * In particular, a thread may not be restarted once it has completed\\n     * execution.\\n     *\\n     * @throws     IllegalThreadStateException  if the thread was already started.\\n     * @see        #run()\\n     * @see        #stop()\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static native void nativeCreate(Thread t, long stackSize, boolean daemon)", "label": "private static native void nativeCreate(Thread t, long stackSize, boolean daemon)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 private native void start0();\u0027}"}, {"color": "#97c2fc", "id": "private void exit()", "label": "private void exit()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * This method is called by the system to give a Thread\\n     * a chance to clean up before it actually exits.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void interrupt()", "label": "public void interrupt()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Interrupts this thread.\\n     *\\n     * \u003cp\u003e Unless the current thread is interrupting itself, which is\\n     * always permitted, the {@link #checkAccess() checkAccess} method\\n     * of this thread is invoked, which may cause a {@link\\n     * SecurityException} to be thrown.\\n     *\\n     * \u003cp\u003e If this thread is blocked in an invocation of the {@link\\n     * Object#wait() wait()}, {@link Object#wait(long) wait(long)}, or {@link\\n     * Object#wait(long, int) wait(long, int)} methods of the {@link Object}\\n     * class, or of the {@link #join()}, {@link #join(long)}, {@link\\n     * #join(long, int)}, {@link #sleep(long)}, or {@link #sleep(long, int)},\\n     * methods of this class, then its interrupt status will be cleared and it\\n     * will receive an {@link InterruptedException}.\\n     *\\n     * \u003cp\u003e If this thread is blocked in an I/O operation upon an {@link\\n     * java.nio.channels.InterruptibleChannel InterruptibleChannel}\\n     * then the channel will be closed, the thread\u0027s interrupt\\n     * status will be set, and the thread will receive a {@link\\n     * java.nio.channels.ClosedByInterruptException}.\\n     *\\n     * \u003cp\u003e If this thread is blocked in a {@link java.nio.channels.Selector}\\n     * then the thread\u0027s interrupt status will be set and it will return\\n     * immediately from the selection operation, possibly with a non-zero\\n     * value, just as if the selector\u0027s {@link\\n     * java.nio.channels.Selector#wakeup wakeup} method were invoked.\\n     *\\n     * \u003cp\u003e If none of the previous conditions hold then this thread\u0027s interrupt\\n     * status will be set. \u003c/p\u003e\\n     *\\n     * \u003cp\u003e Interrupting a thread that is not alive need not have any effect.\\n     *\\n     * @throws  SecurityException\\n     *          if the current thread cannot modify this thread\\n     *\\n     * @revised 6.0\\n     * @spec JSR-51\\n     \"}"}, {"color": "#97c2fc", "id": "sleep(long", "label": "sleep(long", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "checkAccess()", "label": "checkAccess()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "wait(long)", "label": "wait(long)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.lang.Object", "label": "java.lang.Object", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Class {@code Object} is the root of the class hierarchy.\\n * Every class has {@code Object} as a superclass. All objects,\\n * including arrays, implement the methods of this class.\\n *\\n * @see     java.lang.Class\\n * @since   1.0\\n \u0027}"}, {"color": "#97c2fc", "id": "public final Class\u003c?\u003e getClass()", "label": "public final Class\u003c?\u003e getClass()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the runtime class of this {@code Object}. The returned\\n     * {@code Class} object is the object that is locked by {@code\\n     * static synchronized} methods of the represented class.\\n     *\\n     * \u003cp\u003e\u003cb\u003eThe actual result type is {@code Class\u003c? extends |X|\u003e}\\n     * where {@code |X|} is the erasure of the static type of the\\n     * expression on which {@code getClass} is called.\u003c/b\u003e For\\n     * example, no cast is required in this code fragment:\u003c/p\u003e\\n     *\\n     * \u003cp\u003e\\n     * {@code Number n = 0;                             }\u003cbr\u003e\\n     * {@code Class\u003c? extends Number\u003e c = n.getClass(); }\\n     * \u003c/p\u003e\\n     *\\n     * @return The {@code Class} object that represents the runtime\\n     *         class of this object.\\n     * @jls 15.8.2 Class Literals\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.util.HashMap", "label": "java.util.HashMap", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": " static int identityHashCode(Object obj)", "label": " static int identityHashCode(Object obj)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 package-private \u0027}"}, {"color": "#97c2fc", "id": "private static native int identityHashCodeNative(Object obj)", "label": "private static native int identityHashCodeNative(Object obj)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return the identity hash code when the information in the monitor field\\n     * is not sufficient.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private native Object internalClone()", "label": "private native Object internalClone()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Native helper method for cloning.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final native void notify()", "label": "public final native void notify()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Wakes up a single thread that is waiting on this object\u0027s\\n     * monitor. If any threads are waiting on this object, one of them\\n     * is chosen to be awakened. The choice is arbitrary and occurs at\\n     * the discretion of the implementation. A thread waits on an object\u0027s\\n     * monitor by calling one of the {@code wait} methods.\\n     * \u003cp\u003e\\n     * The awakened thread will not be able to proceed until the current\\n     * thread relinquishes the lock on this object. The awakened thread will\\n     * compete in the usual manner with any other threads that might be\\n     * actively competing to synchronize on this object; for example, the\\n     * awakened thread enjoys no reliable privilege or disadvantage in being\\n     * the next thread to lock this object.\\n     * \u003cp\u003e\\n     * This method should only be called by a thread that is the owner\\n     * of this object\u0027s monitor. A thread becomes the owner of the\\n     * object\u0027s monitor in one of three ways:\\n     * \u003cul\u003e\\n     * \u003cli\u003eBy executing a synchronized instance method of that object.\\n     * \u003cli\u003eBy executing the body of a {@code synchronized} statement\\n     *     that synchronizes on the object.\\n     * \u003cli\u003eFor objects of type {@code Class,} by executing a\\n     *     synchronized static method of that class.\\n     * \u003c/ul\u003e\\n     * \u003cp\u003e\\n     * Only one thread at a time can own an object\u0027s monitor.\\n     *\\n     * @throws  IllegalMonitorStateException  if the current thread is not\\n     *               the owner of this object\u0027s monitor.\\n     * @see        java.lang.Object#notifyAll()\\n     * @see        java.lang.Object#wait()\\n     \"}"}, {"color": "#97c2fc", "id": "public final native void notifyAll()", "label": "public final native void notifyAll()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Wakes up all threads that are waiting on this object\u0027s monitor. A\\n     * thread waits on an object\u0027s monitor by calling one of the\\n     * {@code wait} methods.\\n     * \u003cp\u003e\\n     * The awakened threads will not be able to proceed until the current\\n     * thread relinquishes the lock on this object. The awakened threads\\n     * will compete in the usual manner with any other threads that might\\n     * be actively competing to synchronize on this object; for example,\\n     * the awakened threads enjoy no reliable privilege or disadvantage in\\n     * being the next thread to lock this object.\\n     * \u003cp\u003e\\n     * This method should only be called by a thread that is the owner\\n     * of this object\u0027s monitor. See the {@code notify} method for a\\n     * description of the ways in which a thread can become the owner of\\n     * a monitor.\\n     *\\n     * @throws  IllegalMonitorStateException  if the current thread is not\\n     *               the owner of this object\u0027s monitor.\\n     * @see        java.lang.Object#notify()\\n     * @see        java.lang.Object#wait()\\n     \"}"}, {"color": "#97c2fc", "id": "public final void wait(long timeoutMillis) throws InterruptedException", "label": "public final void wait(long timeoutMillis) throws InterruptedException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 public final native void wait(long timeoutMillis) throws InterruptedException;\u0027}"}, {"color": "#97c2fc", "id": "public final native void wait(long timeoutMillis, int nanos) throws InterruptedException", "label": "public final native void wait(long timeoutMillis, int nanos) throws InterruptedException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n    public final void wait(long timeoutMillis, int nanos) throws InterruptedException {\\n        if (timeoutMillis \u003c 0) {\\n            throw new IllegalArgumentException(\"timeoutMillis value is negative\");\\n        }\\n\\n        if (nanos \u003c 0 || nanos \u003e 999999) {\\n            throw new IllegalArgumentException(\\n                                \"nanosecond timeout value out of range\");\\n        }\\n\\n        if (nanos \u003e 0 \u0026\u0026 timeoutMillis \u003c Long.MAX_VALUE) {\\n            timeoutMillis++;\\n        }\\n\\n        wait(timeoutMillis);\\n    }\\n    \u0027}"}, {"color": "#97c2fc", "id": "public final void wait() throws InterruptedException", "label": "public final void wait() throws InterruptedException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Causes the current thread to wait until it is awakened, typically\\n     * by being \u003cem\u003enotified\u003c/em\u003e or \u003cem\u003einterrupted\u003c/em\u003e.\\n     * \u003cp\u003e\\n     * In all respects, this method behaves as if {@code wait(0L, 0)}\\n     * had been called. See the specification of the {@link #wait(long, int)} method\\n     * for details.\\n     *\\n     * @throws IllegalMonitorStateException if the current thread is not\\n     *         the owner of the object\u0027s monitor\\n     * @throws InterruptedException if any thread interrupted the current thread before or\\n     *         while the current thread was waiting. The \u003cem\u003einterrupted status\u003c/em\u003e of the\\n     *         current thread is cleared when this exception is thrown.\\n     * @see    #notify()\\n     * @see    #notifyAll()\\n     * @see    #wait(long)\\n     * @see    #wait(long, int)\\n     \"}"}, {"color": "#97c2fc", "id": "wait(long", "label": "wait(long", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "protected void finalize() throws Throwable", "label": "protected void finalize() throws Throwable", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 @Deprecated(since=\"9\")\u0027}"}, {"color": "#97c2fc", "id": "join()", "label": "join()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.channels.Selector", "label": "java.nio.channels.Selector", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public static Selector open() throws IOException", "label": "public static Selector open() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens a selector.\\n     *\\n     * \u003cp\u003e The new selector is created by invoking the {@link\\n     * java.nio.channels.spi.SelectorProvider#openSelector openSelector} method\\n     * of the system-wide default {@link\\n     * java.nio.channels.spi.SelectorProvider} object.  \u003c/p\u003e\\n     *\\n     * @return  A new selector\\n     *\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract boolean isOpen()", "label": "public abstract boolean isOpen()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this file system is open.\\n     *\\n     * \u003cp\u003e File systems created by the default provider are always open.\\n     *\\n     * @return  {@code true} if, and only if, this file system is open\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract SelectorProvider provider()", "label": "public abstract SelectorProvider provider()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the provider that created this channel.\\n     *\\n     * @return  The provider that created this channel\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract Set\u003cSelectionKey\u003e keys()", "label": "public abstract Set\u003cSelectionKey\u003e keys()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns this selector\\\u0027s key set.\\n     *\\n     * \u003cp\u003e The key set is not directly modifiable.  A key is removed only after\\n     * it has been cancelled and its channel has been deregistered.  Any\\n     * attempt to modify the key set will cause an {@link\\n     * UnsupportedOperationException} to be thrown.\\n     *\\n     * \u003cp\u003e The set is \u003ca href=\"#ksc\"\u003esafe\u003c/a\u003e for use by multiple concurrent\\n     * threads.  \u003c/p\u003e\\n     *\\n     * @return  This selector\\\u0027s key set\\n     *\\n     * @throws  ClosedSelectorException\\n     *          If this selector is closed\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract Set\u003cSelectionKey\u003e selectedKeys()", "label": "public abstract Set\u003cSelectionKey\u003e selectedKeys()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns this selector\\\u0027s selected-key set.\\n     *\\n     * \u003cp\u003e Keys may be removed from, but not directly added to, the\\n     * selected-key set.  Any attempt to add an object to the key set will\\n     * cause an {@link UnsupportedOperationException} to be thrown.\\n     *\\n     * \u003cp\u003e The selected-key set is \u003ca href=\"#sksc\"\u003enot thread-safe\u003c/a\u003e.  \u003c/p\u003e\\n     *\\n     * @return  This selector\\\u0027s selected-key set\\n     *\\n     * @throws  ClosedSelectorException\\n     *          If this selector is closed\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract int selectNow() throws IOException", "label": "public abstract int selectNow() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Selects a set of keys whose corresponding channels are ready for I/O\\n     * operations.\\n     *\\n     * \u003cp\u003e This method performs a non-blocking \u003ca href=\"#selop\"\u003eselection\\n     * operation\u003c/a\u003e.  If no channels have become selectable since the previous\\n     * selection operation then this method immediately returns zero.\\n     *\\n     * \u003cp\u003e Invoking this method clears the effect of any previous invocations\\n     * of the {@link #wakeup wakeup} method.  \u003c/p\u003e\\n     *\\n     * @return  The number of keys, possibly zero, whose ready-operation sets\\n     *          were updated by the selection operation\\n     *\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     *\\n     * @throws  ClosedSelectorException\\n     *          If this selector is closed\\n     \u0027}"}, {"color": "#97c2fc", "id": "wakeup", "label": "wakeup", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract int select(long timeout) throws IOException", "label": "public abstract int select(long timeout) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Selects a set of keys whose corresponding channels are ready for I/O\\n     * operations.\\n     *\\n     * \u003cp\u003e This method performs a blocking \u003ca href=\"#selop\"\u003eselection\\n     * operation\u003c/a\u003e.  It returns only after at least one channel is selected,\\n     * this selector\\\u0027s {@link #wakeup wakeup} method is invoked, the current\\n     * thread is interrupted, or the given timeout period expires, whichever\\n     * comes first.\\n     *\\n     * \u003cp\u003e This method does not offer real-time guarantees: It schedules the\\n     * timeout as if by invoking the {@link Object#wait(long)} method. \u003c/p\u003e\\n     *\\n     * @param  timeout  If positive, block for up to {@code timeout}\\n     *                  milliseconds, more or less, while waiting for a\\n     *                  channel to become ready; if zero, block indefinitely;\\n     *                  must not be negative\\n     *\\n     * @return  The number of keys, possibly zero,\\n     *          whose ready-operation sets were updated\\n     *\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     *\\n     * @throws  ClosedSelectorException\\n     *          If this selector is closed\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the value of the timeout argument is negative\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract int select() throws IOException", "label": "public abstract int select() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Selects a set of keys whose corresponding channels are ready for I/O\\n     * operations.\\n     *\\n     * \u003cp\u003e This method performs a blocking \u003ca href=\"#selop\"\u003eselection\\n     * operation\u003c/a\u003e.  It returns only after at least one channel is selected,\\n     * this selector\\\u0027s {@link #wakeup wakeup} method is invoked, or the current\\n     * thread is interrupted, whichever comes first.  \u003c/p\u003e\\n     *\\n     * @return  The number of keys, possibly zero,\\n     *          whose ready-operation sets were updated\\n     *\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     *\\n     * @throws  ClosedSelectorException\\n     *          If this selector is closed\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int select(Consumer\u003cSelectionKey\u003e action, long timeout) throws IOException", "label": "public int select(Consumer\u003cSelectionKey\u003e action, long timeout) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Selects and performs an action on the keys whose corresponding channels\\n     * are ready for I/O operations.\\n     *\\n     * \u003cp\u003e This method performs a blocking \u003ca href=\"#selop\"\u003eselection\\n     * operation\u003c/a\u003e.  It wakes up from querying the operating system only when\\n     * at least one channel is selected, this selector\\\u0027s {@link #wakeup wakeup}\\n     * method is invoked, the current thread is interrupted, or the given\\n     * timeout period expires, whichever comes first.\\n     *\\n     * \u003cp\u003e The specified \u003ci\u003eaction\u003c/i\u003e\\\u0027s {@link Consumer#accept(Object) accept}\\n     * method is invoked with the key for each channel that is ready to perform\\n     * an operation identified by its key\\\u0027s interest set.  The {@code accept}\\n     * method may be invoked more than once for the same key but with the\\n     * ready-operation set containing a subset of the operations for which the\\n     * channel is ready (as described above).  The {@code accept} method is\\n     * invoked while synchronized on the selector and its selected-key set.\\n     * Great care must be taken to avoid deadlocking with other threads that\\n     * also synchronize on these objects.  Selection operations are not reentrant\\n     * in general and consequently the \u003ci\u003eaction\u003c/i\u003e should take great care not\\n     * to attempt a selection operation on the same selector.  The behavior when\\n     * attempting a reentrant selection operation is implementation specific and\\n     * therefore not specified.  If the \u003ci\u003eaction\u003c/i\u003e closes the selector then\\n     * {@code ClosedSelectorException} is thrown when the action completes.\\n     * The \u003ci\u003eaction\u003c/i\u003e is not prohibited from closing channels registered with\\n     * the selector, nor prohibited from cancelling keys or changing a key\\\u0027s\\n     * interest set.  If a channel is selected but its key is cancelled or its\\n     * interest set changed before the \u003ci\u003eaction\u003c/i\u003e is performed on the key\\n     * then it is implementation specific as to whether the \u003ci\u003eaction\u003c/i\u003e is\\n     * invoked (it may be invoked with an {@link SelectionKey#isValid() invalid}\\n     * key).  Exceptions thrown by the action are relayed to the caller.\\n     *\\n     * \u003cp\u003e This method does not offer real-time guarantees: It schedules the\\n     * timeout as if by invoking the {@link Object#wait(long)} method.\\n     *\\n     * @implSpec The default implementation removes all keys from the\\n     * selected-key set, invokes {@link #select(long) select(long)} with the\\n     * given timeout and then performs the action for each key added to the\\n     * selected-key set.  The default implementation does not detect the action\\n     * performing a reentrant selection operation.  The selected-key set may\\n     * or may not be empty on completion of the default implementation.\\n     *\\n     * @param  action   The action to perform\\n     *\\n     * @param  timeout  If positive, block for up to {@code timeout}\\n     *                  milliseconds, more or less, while waiting for a\\n     *                  channel to become ready; if zero, block indefinitely;\\n     *                  must not be negative\\n     *\\n     * @return  The number of unique keys consumed, possibly zero\\n     *\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     *\\n     * @throws  ClosedSelectorException\\n     *          If this selector is closed or is closed by the action\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the value of the timeout argument is negative\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "select(long)", "label": "select(long)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "accept(Object)", "label": "accept(Object)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.util.function.Consumer", "label": "java.util.function.Consumer", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Represents an operation that accepts a single input argument and returns no\\n * result. Unlike most other functional interfaces, {@code Consumer} is expected\\n * to operate via side-effects.\\n *\\n * \u003cp\u003eThis is a \u003ca href=\"package-summary.html\"\u003efunctional interface\u003c/a\u003e\\n * whose functional method is {@link #accept(Object)}.\\n *\\n * @param \u003cT\u003e the type of the input to the operation\\n *\\n * @since 1.8\\n \u0027}"}, {"color": "#97c2fc", "id": " void accept(T t)", "label": " void accept(T t)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs this operation on the given argument.\\n     *\\n     * @param t the input argument\\n     \u0027}"}, {"color": "#97c2fc", "id": " Consumer\u003cT\u003e andThen(Consumer\u003c? super T\u003e after)", "label": " Consumer\u003cT\u003e andThen(Consumer\u003c? super T\u003e after)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a composed {@code Consumer} that performs, in sequence, this\\n     * operation followed by the {@code after} operation. If performing either\\n     * operation throws an exception, it is relayed to the caller of the\\n     * composed operation.  If performing this operation throws an exception,\\n     * the {@code after} operation will not be performed.\\n     *\\n     * @param after the operation to perform after this operation\\n     * @return a composed {@code Consumer} that performs in sequence this\\n     * operation followed by the {@code after} operation\\n     * @throws NullPointerException if {@code after} is null\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int select(Consumer\u003cSelectionKey\u003e action) throws IOException", "label": "public int select(Consumer\u003cSelectionKey\u003e action) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Selects and performs an action on the keys whose corresponding channels\\n     * are ready for I/O operations.\\n     *\\n     * \u003cp\u003e This method performs a blocking \u003ca href=\"#selop\"\u003eselection\\n     * operation\u003c/a\u003e.  It wakes up from querying the operating system only when\\n     * at least one channel is selected, this selector\\\u0027s {@link #wakeup wakeup}\\n     * method is invoked, or the current thread is interrupted, whichever comes\\n     * first.\\n     *\\n     * \u003cp\u003e This method is equivalent to invoking the 2-arg\\n     * {@link #select(Consumer, long) select} method with a timeout of {@code 0}\\n     * to block indefinitely.  \u003c/p\u003e\\n     *\\n     * @implSpec The default implementation invokes the 2-arg {@code select}\\n     * method with a timeout of {@code 0}.\\n     *\\n     * @param  action   The action to perform\\n     *\\n     * @return  The number of unique keys consumed, possibly zero\\n     *\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     *\\n     * @throws  ClosedSelectorException\\n     *          If this selector is closed or is closed by the action\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "select(Consumer", "label": "select(Consumer", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public int selectNow(Consumer\u003cSelectionKey\u003e action) throws IOException", "label": "public int selectNow(Consumer\u003cSelectionKey\u003e action) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Selects and performs an action on the keys whose corresponding channels\\n     * are ready for I/O operations.\\n     *\\n     * \u003cp\u003e This method performs a non-blocking \u003ca href=\"#selop\"\u003eselection\\n     * operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003e Invoking this method clears the effect of any previous invocations\\n     * of the {@link #wakeup wakeup} method.  \u003c/p\u003e\\n     *\\n     * @implSpec The default implementation removes all keys from the\\n     * selected-key set, invokes {@link #selectNow() selectNow()} and then\\n     * performs the action for each key added to the selected-key set.  The\\n     * default implementation does not detect the action performing a reentrant\\n     * selection operation.  The selected-key set may or may not be empty on\\n     * completion of the default implementation.\\n     *\\n     * @param  action   The action to perform\\n     *\\n     * @return  The number of unique keys consumed, possibly zero\\n     *\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     *\\n     * @throws  ClosedSelectorException\\n     *          If this selector is closed or is closed by the action\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "selectNow()", "label": "selectNow()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "private int doSelect(Consumer\u003cSelectionKey\u003e action, long timeout) throws IOException", "label": "private int doSelect(Consumer\u003cSelectionKey\u003e action, long timeout) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Default implementation of select(Consumer) and selectNow(Consumer).\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract Selector wakeup()", "label": "public abstract Selector wakeup()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Causes the first selection operation that has not yet returned to return\\n     * immediately.\\n     *\\n     * \u003cp\u003e If another thread is currently blocked in a selection operation then\\n     * that invocation will return immediately.  If no selection operation is\\n     * currently in progress then the next invocation of a selection operation\\n     * will return immediately unless {@link #selectNow()} or {@link\\n     * #selectNow(Consumer)} is invoked in the meantime.  In any case the value\\n     * returned by that invocation may be non-zero.  Subsequent selection\\n     * operations will block as usual unless this method is invoked again in the\\n     * meantime.\\n     *\\n     * \u003cp\u003e Invoking this method more than once between two successive selection\\n     * operations has the same effect as invoking it just once.  \u003c/p\u003e\\n     *\\n     * @return  This selector\\n     \u0027}"}, {"color": "#97c2fc", "id": "selectNow(Consumer)", "label": "selectNow(Consumer)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.channels.ClosedSelectorException", "label": "java.nio.channels.ClosedSelectorException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "java.nio.channels.ClosedByInterruptException", "label": "java.nio.channels.ClosedByInterruptException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "java.nio.channels.InterruptibleChannel", "label": "java.nio.channels.InterruptibleChannel", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "java.nio.channels.AsynchronousCloseException", "label": "java.nio.channels.AsynchronousCloseException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "java.lang.InterruptedException", "label": "java.lang.InterruptedException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Thrown when a thread is waiting, sleeping, or otherwise occupied,\\n * and the thread is interrupted, either before or during the activity.\\n * Occasionally a method may wish to test whether the current\\n * thread has been interrupted, and if so, to immediately throw\\n * this exception.  The following code can be used to achieve\\n * this effect:\\n * \u003cpre\u003e\\n *  if (Thread.interrupted())  // Clears interrupted status!\\n *      throw new InterruptedException();\\n * \u003c/pre\u003e\\n *\\n * @author  Frank Yellin\\n * @see     java.lang.Object#wait()\\n * @see     java.lang.Object#wait(long)\\n * @see     java.lang.Object#wait(long, int)\\n * @see     java.lang.Thread#sleep(long)\\n * @see     java.lang.Thread#interrupt()\\n * @see     java.lang.Thread#interrupted()\\n * @since   1.0\\n \u0027}"}, {"color": "#97c2fc", "id": "join(long)", "label": "join(long)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.lang.SecurityException", "label": "java.lang.SecurityException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Thrown by the security manager to indicate a security violation.\\n *\\n * @see     java.lang.SecurityManager\\n * @since   1.0\\n \u0027}"}, {"color": "#97c2fc", "id": "join(long", "label": "join(long", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static native boolean interrupted()", "label": "public static native boolean interrupted()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 }\u0027}"}, {"color": "#97c2fc", "id": "public native boolean isInterrupted()", "label": "public native boolean isInterrupted()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 }\u0027}"}, {"color": "#97c2fc", "id": "public final boolean isAlive()", "label": "public final boolean isAlive()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 public final native boolean isAlive();\u0027}"}, {"color": "#97c2fc", "id": "public final void setPriority(int newPriority)", "label": "public final void setPriority(int newPriority)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Changes the priority of this thread.\\n     * \u003cp\u003e\\n     * First the {@code checkAccess} method of this thread is called\\n     * with no arguments. This may result in throwing a {@code SecurityException}.\\n     * \u003cp\u003e\\n     * Otherwise, the priority of this thread is set to the smaller of\\n     * the specified {@code newPriority} and the maximum permitted\\n     * priority of the thread\u0027s thread group.\\n     *\\n     * @param newPriority priority to set this thread to\\n     * @throws     IllegalArgumentException  If the priority is not in the\\n     *               range {@code MIN_PRIORITY} to\\n     *               {@code MAX_PRIORITY}.\\n     * @throws     SecurityException  if the current thread cannot modify\\n     *               this thread.\\n     * @see        #getPriority\\n     * @see        #checkAccess()\\n     * @see        #getThreadGroup()\\n     * @see        #MAX_PRIORITY\\n     * @see        #MIN_PRIORITY\\n     * @see        ThreadGroup#getMaxPriority()\\n     \"}"}, {"color": "#97c2fc", "id": "public final int getPriority()", "label": "public final int getPriority()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns this thread\u0027s priority.\\n     *\\n     * @return  this thread\u0027s priority.\\n     * @see     #setPriority\\n     \"}"}, {"color": "#97c2fc", "id": "public final synchronized void setName(String name)", "label": "public final synchronized void setName(String name)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Changes the name of this thread to be equal to the argument {@code name}.\\n     * \u003cp\u003e\\n     * First the {@code checkAccess} method of this thread is called\\n     * with no arguments. This may result in throwing a\\n     * {@code SecurityException}.\\n     *\\n     * @param      name   the new name for this thread.\\n     * @throws     SecurityException  if the current thread cannot modify this\\n     *             thread.\\n     * @see        #getName\\n     * @see        #checkAccess()\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final String getName()", "label": "public final String getName()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the name of this thread group.\\n     *\\n     * @return  the name of this thread group.\\n     * @since   1.0\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final ThreadGroup getThreadGroup()", "label": "public final ThreadGroup getThreadGroup()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the thread group to which this thread belongs.\\n     * This method returns null if this thread has died\\n     * (been stopped).\\n     *\\n     * @return  this thread\u0027s thread group.\\n     \"}"}, {"color": "#97c2fc", "id": "public static int activeCount()", "label": "public static int activeCount()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns an estimate of the number of active threads in the current\\n     * thread\u0027s {@linkplain java.lang.ThreadGroup thread group} and its\\n     * subgroups. Recursively iterates over all subgroups in the current\\n     * thread\u0027s thread group.\\n     *\\n     * \u003cp\u003e The value returned is only an estimate because the number of\\n     * threads may change dynamically while this method traverses internal\\n     * data structures, and might be affected by the presence of certain\\n     * system threads. This method is intended primarily for debugging\\n     * and monitoring purposes.\\n     *\\n     * @return  an estimate of the number of active threads in the current\\n     *          thread\u0027s thread group and in any other thread group that\\n     *          has the current thread\u0027s thread group as an ancestor\\n     \"}"}, {"color": "#97c2fc", "id": "public static int enumerate(Thread[] tarray)", "label": "public static int enumerate(Thread[] tarray)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Copies into the specified array every active thread in the current\\n     * thread\u0027s thread group and its subgroups. This method simply\\n     * invokes the {@link java.lang.ThreadGroup#enumerate(Thread[])}\\n     * method of the current thread\u0027s thread group.\\n     *\\n     * \u003cp\u003e An application might use the {@linkplain #activeCount activeCount}\\n     * method to get an estimate of how big the array should be, however\\n     * \u003ci\u003eif the array is too short to hold all the threads, the extra threads\\n     * are silently ignored.\u003c/i\u003e  If it is critical to obtain every active\\n     * thread in the current thread\u0027s thread group and its subgroups, the\\n     * invoker should verify that the returned int value is strictly less\\n     * than the length of {@code tarray}.\\n     *\\n     * \u003cp\u003e Due to the inherent race condition in this method, it is recommended\\n     * that the method only be used for debugging and monitoring purposes.\\n     *\\n     * @param  tarray\\n     *         an array into which to put the list of threads\\n     *\\n     * @return  the number of threads put into the array\\n     *\\n     * @throws  SecurityException\\n     *          if {@link java.lang.ThreadGroup#checkAccess} determines that\\n     *          the current thread cannot access its thread group\\n     \"}"}, {"color": "#97c2fc", "id": "checkAccess", "label": "checkAccess", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.lang.ThreadGroup", "label": "java.lang.ThreadGroup", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027 The locking strategy for this code is to try to lock only one level of the\\n * tree wherever possible, but otherwise to lock from the bottom up.\\n * That is, from child thread groups to parents.\\n * This has the advantage of limiting the number of locks that need to be held\\n * and in particular avoids having to grab the lock for the root thread group,\\n * (or a global lock) which would be a source of contention on a\\n * multi-processor system with many thread groups.\\n * This policy often leads to taking a snapshot of the state of a thread group\\n * and working off of that snapshot, rather than holding the thread group locked\\n * while we work on the children.\\n \u0027}"}, {"color": "#97c2fc", "id": "private static Void checkParentAccess(ThreadGroup parent)", "label": "private static Void checkParentAccess(ThreadGroup parent)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @throws  NullPointerException  if the parent argument is {@code null}\\n     * @throws  SecurityException     if the current thread cannot create a\\n     *                                thread in the specified thread group.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final ThreadGroup getParent()", "label": "public final ThreadGroup getParent()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the parent of this thread group.\\n     * \u003cp\u003e\\n     * First, if the parent is not {@code null}, the\\n     * {@code checkAccess} method of the parent thread group is\\n     * called with no arguments; this may result in a security exception.\\n     *\\n     * @return  the parent of this thread group. The top-level thread group\\n     *          is the only thread group whose parent is {@code null}.\\n     * @throws  SecurityException  if the current thread cannot modify\\n     *               this thread group.\\n     * @see        java.lang.ThreadGroup#checkAccess()\\n     * @see        java.lang.SecurityException\\n     * @see        java.lang.RuntimePermission\\n     * @since   1.0\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final int getMaxPriority()", "label": "public final int getMaxPriority()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the maximum priority of this thread group. Threads that are\\n     * part of this group cannot have a higher priority than the maximum\\n     * priority.\\n     *\\n     * @return  the maximum priority that a thread in this thread group\\n     *          can have.\\n     * @see     #setMaxPriority\\n     * @since   1.0\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final boolean isDaemon()", "label": "public final boolean isDaemon()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests if this thread is a daemon thread.\\n     *\\n     * @return  {@code true} if this thread is a daemon thread;\\n     *          {@code false} otherwise.\\n     * @see     #setDaemon(boolean)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public synchronized boolean isDestroyed()", "label": "public synchronized boolean isDestroyed()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests if this thread group has been destroyed.\\n     *\\n     * @return  true if this object is destroyed\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final void setDaemon(boolean daemon)", "label": "public final void setDaemon(boolean daemon)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Changes the daemon status of this thread group.\\n     * \u003cp\u003e\\n     * First, the {@code checkAccess} method of this thread group is\\n     * called with no arguments; this may result in a security exception.\\n     * \u003cp\u003e\\n     * A daemon thread group is automatically destroyed when its last\\n     * thread is stopped or its last thread group is destroyed.\\n     *\\n     * @param      daemon   if {@code true}, marks this thread group as\\n     *                      a daemon thread group; otherwise, marks this\\n     *                      thread group as normal.\\n     * @throws     SecurityException  if the current thread cannot modify\\n     *               this thread group.\\n     * @see        java.lang.SecurityException\\n     * @see        java.lang.ThreadGroup#checkAccess()\\n     * @since      1.0\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final void setMaxPriority(int pri)", "label": "public final void setMaxPriority(int pri)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the maximum priority of the group. Threads in the thread\\n     * group that already have a higher priority are not affected.\\n     * \u003cp\u003e\\n     * First, the {@code checkAccess} method of this thread group is\\n     * called with no arguments; this may result in a security exception.\\n     * \u003cp\u003e\\n     * If the {@code pri} argument is less than\\n     * {@link Thread#MIN_PRIORITY} or greater than\\n     * {@link Thread#MAX_PRIORITY}, it is clamped to those values.\\n     * \u003cp\u003e\\n     * Otherwise, the priority of this ThreadGroup object is set to the\\n     * smaller of the specified {@code pri} and the maximum permitted\\n     * priority of the parent of this thread group. (If this thread group\\n     * is the system thread group, which has no parent, then its maximum\\n     * priority is simply set to {@code pri}.) Then this method is\\n     * called recursively, with {@code pri} as its argument, for\\n     * every thread group that belongs to this thread group.\\n     *\\n     * @param      pri   the new priority of the thread group.\\n     * @throws     SecurityException  if the current thread cannot modify\\n     *               this thread group.\\n     * @see        #getMaxPriority\\n     * @see        java.lang.SecurityException\\n     * @see        java.lang.ThreadGroup#checkAccess()\\n     * @since      1.0\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final boolean parentOf(ThreadGroup g)", "label": "public final boolean parentOf(ThreadGroup g)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests if this thread group is either the thread group\\n     * argument or one of its ancestor thread groups.\\n     *\\n     * @param   g   a thread group.\\n     * @return  {@code true} if this thread group is the thread group\\n     *          argument or one of its ancestor thread groups;\\n     *          {@code false} otherwise.\\n     * @since   1.0\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final void checkAccess()", "label": "public final void checkAccess()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines if the currently running thread has permission to\\n     * modify this thread.\\n     * \u003cp\u003e\\n     * If there is a security manager, its {@code checkAccess} method\\n     * is called with this thread as its argument. This may result in\\n     * throwing a {@code SecurityException}.\\n     *\\n     * @throws  SecurityException  if the current thread is not allowed to\\n     *          access this thread.\\n     * @see        SecurityManager#checkAccess(Thread)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int activeCount()", "label": "public int activeCount()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an estimate of the number of active threads in this thread\\n     * group and its subgroups. Recursively iterates over all subgroups in\\n     * this thread group.\\n     *\\n     * \u003cp\u003e The value returned is only an estimate because the number of\\n     * threads may change dynamically while this method traverses internal\\n     * data structures, and might be affected by the presence of certain\\n     * system threads. This method is intended primarily for debugging\\n     * and monitoring purposes.\\n     *\\n     * @return  an estimate of the number of active threads in this thread\\n     *          group and in any other thread group that has this thread\\n     *          group as an ancestor\\n     *\\n     * @since   1.0\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int enumerate(Thread[] list)", "label": "public int enumerate(Thread[] list)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies into the specified array every active thread in this\\n     * thread group and its subgroups.\\n     *\\n     * \u003cp\u003e An invocation of this method behaves in exactly the same\\n     * way as the invocation\\n     *\\n     * \u003cblockquote\u003e\\n     * {@linkplain #enumerate(Thread[], boolean) enumerate}{@code (list, true)}\\n     * \u003c/blockquote\u003e\\n     *\\n     * @param  list\\n     *         an array into which to put the list of threads\\n     *\\n     * @return  the number of threads put into the array\\n     *\\n     * @throws  SecurityException\\n     *          if {@linkplain #checkAccess checkAccess} determines that\\n     *          the current thread cannot access this thread group\\n     *\\n     * @since   1.0\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int enumerate(Thread[] list, boolean recurse)", "label": "public int enumerate(Thread[] list, boolean recurse)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies into the specified array every active thread in this\\n     * thread group. If {@code recurse} is {@code true},\\n     * this method recursively enumerates all subgroups of this\\n     * thread group and references to every active thread in these\\n     * subgroups are also included. If the array is too short to\\n     * hold all the threads, the extra threads are silently ignored.\\n     *\\n     * \u003cp\u003e An application might use the {@linkplain #activeCount activeCount}\\n     * method to get an estimate of how big the array should be, however\\n     * \u003ci\u003eif the array is too short to hold all the threads, the extra threads\\n     * are silently ignored.\u003c/i\u003e  If it is critical to obtain every active\\n     * thread in this thread group, the caller should verify that the returned\\n     * int value is strictly less than the length of {@code list}.\\n     *\\n     * \u003cp\u003e Due to the inherent race condition in this method, it is recommended\\n     * that the method only be used for debugging and monitoring purposes.\\n     *\\n     * @param  list\\n     *         an array into which to put the list of threads\\n     *\\n     * @param  recurse\\n     *         if {@code true}, recursively enumerate all subgroups of this\\n     *         thread group\\n     *\\n     * @return  the number of threads put into the array\\n     *\\n     * @throws  SecurityException\\n     *          if {@linkplain #checkAccess checkAccess} determines that\\n     *          the current thread cannot access this thread group\\n     *\\n     * @since   1.0\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int activeGroupCount()", "label": "public int activeGroupCount()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an estimate of the number of active groups in this\\n     * thread group and its subgroups. Recursively iterates over\\n     * all subgroups in this thread group.\\n     *\\n     * \u003cp\u003e The value returned is only an estimate because the number of\\n     * thread groups may change dynamically while this method traverses\\n     * internal data structures. This method is intended primarily for\\n     * debugging and monitoring purposes.\\n     *\\n     * @return  the number of active thread groups with this thread group as\\n     *          an ancestor\\n     *\\n     * @since   1.0\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int enumerate(ThreadGroup[] list)", "label": "public int enumerate(ThreadGroup[] list)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies into the specified array references to every active\\n     * subgroup in this thread group and its subgroups.\\n     *\\n     * \u003cp\u003e An invocation of this method behaves in exactly the same\\n     * way as the invocation\\n     *\\n     * \u003cblockquote\u003e\\n     * {@linkplain #enumerate(ThreadGroup[], boolean) enumerate}{@code (list, true)}\\n     * \u003c/blockquote\u003e\\n     *\\n     * @param  list\\n     *         an array into which to put the list of thread groups\\n     *\\n     * @return  the number of thread groups put into the array\\n     *\\n     * @throws  SecurityException\\n     *          if {@linkplain #checkAccess checkAccess} determines that\\n     *          the current thread cannot access this thread group\\n     *\\n     * @since   1.0\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int enumerate(ThreadGroup[] list, boolean recurse)", "label": "public int enumerate(ThreadGroup[] list, boolean recurse)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies into the specified array references to every active\\n     * subgroup in this thread group. If {@code recurse} is\\n     * {@code true}, this method recursively enumerates all subgroups of this\\n     * thread group and references to every active thread group in these\\n     * subgroups are also included.\\n     *\\n     * \u003cp\u003e An application might use the\\n     * {@linkplain #activeGroupCount activeGroupCount} method to\\n     * get an estimate of how big the array should be, however \u003ci\u003eif the\\n     * array is too short to hold all the thread groups, the extra thread\\n     * groups are silently ignored.\u003c/i\u003e  If it is critical to obtain every\\n     * active subgroup in this thread group, the caller should verify that\\n     * the returned int value is strictly less than the length of\\n     * {@code list}.\\n     *\\n     * \u003cp\u003e Due to the inherent race condition in this method, it is recommended\\n     * that the method only be used for debugging and monitoring purposes.\\n     *\\n     * @param  list\\n     *         an array into which to put the list of thread groups\\n     *\\n     * @param  recurse\\n     *         if {@code true}, recursively enumerate all subgroups\\n     *\\n     * @return  the number of thread groups put into the array\\n     *\\n     * @throws  SecurityException\\n     *          if {@linkplain #checkAccess checkAccess} determines that\\n     *          the current thread cannot access this thread group\\n     *\\n     * @since   1.0\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final void interrupt()", "label": "public final void interrupt()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Interrupts all threads in this thread group.\\n     * \u003cp\u003e\\n     * First, the {@code checkAccess} method of this thread group is\\n     * called with no arguments; this may result in a security exception.\\n     * \u003cp\u003e\\n     * This method then calls the {@code interrupt} method on all the\\n     * threads in this thread group and in all of its subgroups.\\n     *\\n     * @throws     SecurityException  if the current thread is not allowed\\n     *               to access this thread group or any of the threads in\\n     *               the thread group.\\n     * @see        java.lang.Thread#interrupt()\\n     * @see        java.lang.SecurityException\\n     * @see        java.lang.ThreadGroup#checkAccess()\\n     * @since      1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "private boolean stopOrSuspend(boolean suspend)", "label": "private boolean stopOrSuspend(boolean suspend)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Helper method: recursively stops or suspends (as directed by the\\n     * boolean argument) all of the threads in this thread group and its\\n     * subgroups, except the current thread.  This method returns true\\n     * if (and only if) the current thread is found to be in this thread\\n     * group or one of its subgroups.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final void destroy()", "label": "public final void destroy()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Destroys this thread group and all of its subgroups. This thread\\n     * group must be empty, indicating that all threads that had been in\\n     * this thread group have since stopped.\\n     * \u003cp\u003e\\n     * First, the {@code checkAccess} method of this thread group is\\n     * called with no arguments; this may result in a security exception.\\n     *\\n     * @throws     IllegalThreadStateException  if the thread group is not\\n     *               empty or if the thread group has already been destroyed.\\n     * @throws     SecurityException  if the current thread cannot modify this\\n     *               thread group.\\n     * @see        java.lang.ThreadGroup#checkAccess()\\n     * @since      1.0\\n     \u0027}"}, {"color": "#97c2fc", "id": "private final void add(ThreadGroup g)", "label": "private final void add(ThreadGroup g)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Adds the specified Thread group to this group.\\n     * @param g the specified Thread group to be added\\n     * @throws  IllegalThreadStateException If the Thread group has been destroyed.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void remove(ThreadGroup g)", "label": "private void remove(ThreadGroup g)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Removes the specified Thread group from this group.\\n     * @param g the Thread group to be removed\\n     * @return if this Thread has already been destroyed.\\n     \u0027}"}, {"color": "#97c2fc", "id": " void addUnstarted()", "label": " void addUnstarted()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Increments the count of unstarted threads in the thread group.\\n     * Unstarted threads are not added to the thread group so that they\\n     * can be collected if they are never started, but they must be\\n     * counted so that daemon thread groups with unstarted threads in\\n     * them are not destroyed.\\n     \u0027}"}, {"color": "#97c2fc", "id": " void add(Thread t)", "label": " void add(Thread t)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Adds the specified thread to this thread group.\\n     *\\n     * \u003cp\u003e Note: This method is called from both library code\\n     * and the Virtual Machine. It is called from VM to add\\n     * certain system threads to the system thread group.\\n     *\\n     * @param  t\\n     *         the Thread to be added\\n     *\\n     * @throws IllegalThreadStateException\\n     *          if the Thread group has been destroyed\\n     \u0027}"}, {"color": "#97c2fc", "id": " void threadStartFailed(Thread t)", "label": " void threadStartFailed(Thread t)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Notifies the group that the thread {@code t} has failed\\n     * an attempt to start.\\n     *\\n     * \u003cp\u003e The state of this thread group is rolled back as if the\\n     * attempt to start the thread has never occurred. The thread is again\\n     * considered an unstarted member of the thread group, and a subsequent\\n     * attempt to start the thread is permitted.\\n     *\\n     * @param  t\\n     *         the Thread whose start method was invoked\\n     \u0027}"}, {"color": "#97c2fc", "id": " void threadTerminated(Thread t)", "label": " void threadTerminated(Thread t)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Notifies the group that the thread {@code t} has terminated.\\n     *\\n     * \u003cp\u003e Destroy the group if all of the following conditions are\\n     * true: this is a daemon thread group; there are no more alive\\n     * or unstarted threads in the group; there are no subgroups in\\n     * this thread group.\\n     *\\n     * @param  t\\n     *         the Thread that has terminated\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void remove(Thread t)", "label": "private void remove(Thread t)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Removes the specified Thread from this group. Invoking this method\\n     * on a thread group that has been destroyed has no effect.\\n     *\\n     * @param  t\\n     *         the Thread to be removed\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void list()", "label": "public void list()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Prints information about this thread group to the standard\\n     * output. This method is useful only for debugging.\\n     *\\n     * @since   1.0\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void uncaughtException(Thread t, Throwable e)", "label": "public void uncaughtException(Thread t, Throwable e)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Called by the Java Virtual Machine when a thread in this\\n     * thread group stops because of an uncaught exception, and the thread\\n     * does not have a specific {@link Thread.UncaughtExceptionHandler}\\n     * installed.\\n     * \u003cp\u003e\\n     * The {@code uncaughtException} method of\\n     * {@code ThreadGroup} does the following:\\n     * \u003cul\u003e\\n     * \u003cli\u003eIf this thread group has a parent thread group, the\\n     *     {@code uncaughtException} method of that parent is called\\n     *     with the same two arguments.\\n     * \u003cli\u003eOtherwise, this method checks to see if there is a\\n     *     {@linkplain Thread#getDefaultUncaughtExceptionHandler default\\n     *     uncaught exception handler} installed, and if so, its\\n     *     {@code uncaughtException} method is called with the same\\n     *     two arguments.\\n     * \u003cli\u003eOtherwise, this method determines if the {@code Throwable}\\n     *     argument is an instance of {@link ThreadDeath}. If so, nothing\\n     *     special is done. Otherwise, a message containing the\\n     *     thread\u0027s name, as returned from the thread\u0027s {@link\\n     *     Thread#getName getName} method, and a stack backtrace,\\n     *     using the {@code Throwable}\u0027s {@link\\n     *     Throwable#printStackTrace printStackTrace} method, is\\n     *     printed to the {@linkplain System#err standard error stream}.\\n     * \u003c/ul\u003e\\n     * \u003cp\u003e\\n     * Applications can override this method in subclasses of\\n     * {@code ThreadGroup} to provide alternative handling of\\n     * uncaught exceptions.\\n     *\\n     * @param   t   the thread that is about to exit.\\n     * @param   e   the uncaught exception.\\n     * @since   1.0\\n     \"}"}, {"color": "#97c2fc", "id": "printStackTrace", "label": "printStackTrace", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.lang.Throwable", "label": "java.lang.Throwable", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * The {@code Throwable} class is the superclass of all errors and\\n * exceptions in the Java language. Only objects that are instances of this\\n * class (or one of its subclasses) are thrown by the Java Virtual Machine or\\n * can be thrown by the Java {@code throw} statement. Similarly, only\\n * this class or one of its subclasses can be the argument type in a\\n * {@code catch} clause.\\n *\\n * For the purposes of compile-time checking of exceptions, {@code\\n * Throwable} and any subclass of {@code Throwable} that is not also a\\n * subclass of either {@link RuntimeException} or {@link Error} are\\n * regarded as checked exceptions.\\n *\\n * \u003cp\u003eInstances of two subclasses, {@link java.lang.Error} and\\n * {@link java.lang.Exception}, are conventionally used to indicate\\n * that exceptional situations have occurred. Typically, these instances\\n * are freshly created in the context of the exceptional situation so\\n * as to include relevant information (such as stack trace data).\\n *\\n * \u003cp\u003eA throwable contains a snapshot of the execution stack of its\\n * thread at the time it was created. It can also contain a message\\n * string that gives more information about the error. Over time, a\\n * throwable can {@linkplain Throwable#addSuppressed suppress} other\\n * throwables from being propagated.  Finally, the throwable can also\\n * contain a \u003ci\u003ecause\u003c/i\u003e: another throwable that caused this\\n * throwable to be constructed.  The recording of this causal information\\n * is referred to as the \u003ci\u003echained exception\u003c/i\u003e facility, as the\\n * cause can, itself, have a cause, and so on, leading to a \"chain\" of\\n * exceptions, each caused by another.\\n *\\n * \u003cp\u003eOne reason that a throwable may have a cause is that the class that\\n * throws it is built atop a lower layered abstraction, and an operation on\\n * the upper layer fails due to a failure in the lower layer.  It would be bad\\n * design to let the throwable thrown by the lower layer propagate outward, as\\n * it is generally unrelated to the abstraction provided by the upper layer.\\n * Further, doing so would tie the API of the upper layer to the details of\\n * its implementation, assuming the lower layer\\\u0027s exception was a checked\\n * exception.  Throwing a \"wrapped exception\" (i.e., an exception containing a\\n * cause) allows the upper layer to communicate the details of the failure to\\n * its caller without incurring either of these shortcomings.  It preserves\\n * the flexibility to change the implementation of the upper layer without\\n * changing its API (in particular, the set of exceptions thrown by its\\n * methods).\\n *\\n * \u003cp\u003eA second reason that a throwable may have a cause is that the method\\n * that throws it must conform to a general-purpose interface that does not\\n * permit the method to throw the cause directly.  For example, suppose\\n * a persistent collection conforms to the {@link java.util.Collection\\n * Collection} interface, and that its persistence is implemented atop\\n * {@code java.io}.  Suppose the internals of the {@code add} method\\n * can throw an {@link java.io.IOException IOException}.  The implementation\\n * can communicate the details of the {@code IOException} to its caller\\n * while conforming to the {@code Collection} interface by wrapping the\\n * {@code IOException} in an appropriate unchecked exception.  (The\\n * specification for the persistent collection should indicate that it is\\n * capable of throwing such exceptions.)\\n *\\n * \u003cp\u003eA cause can be associated with a throwable in two ways: via a\\n * constructor that takes the cause as an argument, or via the\\n * {@link #initCause(Throwable)} method.  New throwable classes that\\n * wish to allow causes to be associated with them should provide constructors\\n * that take a cause and delegate (perhaps indirectly) to one of the\\n * {@code Throwable} constructors that takes a cause.\\n *\\n * Because the {@code initCause} method is public, it allows a cause to be\\n * associated with any throwable, even a \"legacy throwable\" whose\\n * implementation predates the addition of the exception chaining mechanism to\\n * {@code Throwable}.\\n *\\n * \u003cp\u003eBy convention, class {@code Throwable} and its subclasses have two\\n * constructors, one that takes no arguments and one that takes a\\n * {@code String} argument that can be used to produce a detail message.\\n * Further, those subclasses that might likely have a cause associated with\\n * them should have two more constructors, one that takes a\\n * {@code Throwable} (the cause), and one that takes a\\n * {@code String} (the detail message) and a {@code Throwable} (the\\n * cause).\\n *\\n * @author  Josh Bloch (Added exception chaining and programmatic access to\\n *          stack trace in 1.4.)\\n * @jls 11.2 Compile-Time Checking of Exceptions\\n * @since 1.0\\n \u0027}"}, {"color": "#97c2fc", "id": "public String getMessage()", "label": "public String getMessage()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Produce the message and include the classname, if present.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getLocalizedMessage()", "label": "public String getLocalizedMessage()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a localized description of this throwable.\\n     * Subclasses may override this method in order to produce a\\n     * locale-specific message.  For subclasses that do not override this\\n     * method, the default implementation returns the same result as\\n     * {@code getMessage()}.\\n     *\\n     * @return  The localized description of this throwable.\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "public synchronized Throwable getCause()", "label": "public synchronized Throwable getCause()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the cause of this throwable or {@code null} if the\\n     * cause is nonexistent or unknown.  (The cause is the throwable that\\n     * caused this throwable to get thrown.)\\n     *\\n     * \u003cp\u003eThis implementation returns the cause that was supplied via one of\\n     * the constructors requiring a {@code Throwable}, or that was set after\\n     * creation with the {@link #initCause(Throwable)} method.  While it is\\n     * typically unnecessary to override this method, a subclass can override\\n     * it to return a cause set by some other means.  This is appropriate for\\n     * a \"legacy chained throwable\" that predates the addition of chained\\n     * exceptions to {@code Throwable}.  Note that it is \u003ci\u003enot\u003c/i\u003e\\n     * necessary to override any of the {@code PrintStackTrace} methods,\\n     * all of which invoke the {@code getCause} method to determine the\\n     * cause of a throwable.\\n     *\\n     * @return  the cause of this throwable or {@code null} if the\\n     *          cause is nonexistent or unknown.\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "initCause(Throwable)", "label": "initCause(Throwable)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public synchronized Throwable initCause(Throwable cause)", "label": "public synchronized Throwable initCause(Throwable cause)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Initializes the \u003ci\u003ecause\u003c/i\u003e of this throwable to the specified value.\\n     * (The cause is the throwable that caused this throwable to get thrown.)\\n     *\\n     * \u003cp\u003eThis method can be called at most once.  It is generally called from\\n     * within the constructor, or immediately after creating the\\n     * throwable.  If this throwable was created\\n     * with {@link #Throwable(Throwable)} or\\n     * {@link #Throwable(String,Throwable)}, this method cannot be called\\n     * even once.\\n     *\\n     * \u003cp\u003eAn example of using this method on a legacy throwable type\\n     * without other support for setting the cause is:\\n     *\\n     * \u003cpre\u003e\\n     * try {\\n     *     lowLevelOp();\\n     * } catch (LowLevelException le) {\\n     *     throw (HighLevelException)\\n     *           new HighLevelException().initCause(le); // Legacy constructor\\n     * }\\n     * \u003c/pre\u003e\\n     *\\n     * @param  cause the cause (which is saved for later retrieval by the\\n     *         {@link #getCause()} method).  (A {@code null} value is\\n     *         permitted, and indicates that the cause is nonexistent or\\n     *         unknown.)\\n     * @return  a reference to this {@code Throwable} instance.\\n     * @throws IllegalArgumentException if {@code cause} is this\\n     *         throwable.  (A throwable cannot be its own cause.)\\n     * @throws IllegalStateException if this throwable was\\n     *         created with {@link #Throwable(Throwable)} or\\n     *         {@link #Throwable(String,Throwable)}, or this method has already\\n     *         been called on this throwable.\\n     * @since  1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "getCause()", "label": "getCause()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "Throwable(String", "label": "Throwable(String", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "Throwable(Throwable)", "label": "Throwable(Throwable)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " final void setCause(Throwable t)", "label": " final void setCause(Throwable t)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * This is called by readObject of a few exceptions such as\\n     * ClassNotFoundException and ExceptionInInitializerError to deserialize\\n     * a stream output from an older runtime version where the cause may\\n     * have set to null.\\n     \u0027}"}, {"color": "#97c2fc", "id": "getLocalizedMessage", "label": "getLocalizedMessage", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void printStackTrace()", "label": "public void printStackTrace()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Prints this throwable and its backtrace to the\\n     * standard error stream. This method prints a stack trace for this\\n     * {@code Throwable} object on the error output stream that is\\n     * the value of the field {@code System.err}. The first line of\\n     * output contains the result of the {@link #toString()} method for\\n     * this object.  Remaining lines represent data previously recorded by\\n     * the method {@link #fillInStackTrace()}. The format of this\\n     * information depends on the implementation, but the following\\n     * example may be regarded as typical:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * java.lang.NullPointerException\\n     *         at MyClass.mash(MyClass.java:9)\\n     *         at MyClass.crunch(MyClass.java:6)\\n     *         at MyClass.main(MyClass.java:3)\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * This example was produced by running the program:\\n     * \u003cpre\u003e\\n     * class MyClass {\\n     *     public static void main(String[] args) {\\n     *         crunch(null);\\n     *     }\\n     *     static void crunch(int[] a) {\\n     *         mash(a);\\n     *     }\\n     *     static void mash(int[] b) {\\n     *         System.out.println(b[0]);\\n     *     }\\n     * }\\n     * \u003c/pre\u003e\\n     * The backtrace for a throwable with an initialized, non-null cause\\n     * should generally include the backtrace for the cause.  The format\\n     * of this information depends on the implementation, but the following\\n     * example may be regarded as typical:\\n     * \u003cpre\u003e\\n     * HighLevelException: MidLevelException: LowLevelException\\n     *         at Junk.a(Junk.java:13)\\n     *         at Junk.main(Junk.java:4)\\n     * Caused by: MidLevelException: LowLevelException\\n     *         at Junk.c(Junk.java:23)\\n     *         at Junk.b(Junk.java:17)\\n     *         at Junk.a(Junk.java:11)\\n     *         ... 1 more\\n     * Caused by: LowLevelException\\n     *         at Junk.e(Junk.java:30)\\n     *         at Junk.d(Junk.java:27)\\n     *         at Junk.c(Junk.java:21)\\n     *         ... 3 more\\n     * \u003c/pre\u003e\\n     * Note the presence of lines containing the characters {@code \"...\"}.\\n     * These lines indicate that the remainder of the stack trace for this\\n     * exception matches the indicated number of frames from the bottom of the\\n     * stack trace of the exception that was caused by this exception (the\\n     * \"enclosing\" exception).  This shorthand can greatly reduce the length\\n     * of the output in the common case where a wrapped exception is thrown\\n     * from same method as the \"causative exception\" is caught.  The above\\n     * example was produced by running the program:\\n     * \u003cpre\u003e\\n     * public class Junk {\\n     *     public static void main(String args[]) {\\n     *         try {\\n     *             a();\\n     *         } catch(HighLevelException e) {\\n     *             e.printStackTrace();\\n     *         }\\n     *     }\\n     *     static void a() throws HighLevelException {\\n     *         try {\\n     *             b();\\n     *         } catch(MidLevelException e) {\\n     *             throw new HighLevelException(e);\\n     *         }\\n     *     }\\n     *     static void b() throws MidLevelException {\\n     *         c();\\n     *     }\\n     *     static void c() throws MidLevelException {\\n     *         try {\\n     *             d();\\n     *         } catch(LowLevelException e) {\\n     *             throw new MidLevelException(e);\\n     *         }\\n     *     }\\n     *     static void d() throws LowLevelException {\\n     *        e();\\n     *     }\\n     *     static void e() throws LowLevelException {\\n     *         throw new LowLevelException();\\n     *     }\\n     * }\\n     *\\n     * class HighLevelException extends Exception {\\n     *     HighLevelException(Throwable cause) { super(cause); }\\n     * }\\n     *\\n     * class MidLevelException extends Exception {\\n     *     MidLevelException(Throwable cause)  { super(cause); }\\n     * }\\n     *\\n     * class LowLevelException extends Exception {\\n     * }\\n     * \u003c/pre\u003e\\n     * As of release 7, the platform supports the notion of\\n     * \u003ci\u003esuppressed exceptions\u003c/i\u003e (in conjunction with the {@code\\n     * try}-with-resources statement). Any exceptions that were\\n     * suppressed in order to deliver an exception are printed out\\n     * beneath the stack trace.  The format of this information\\n     * depends on the implementation, but the following example may be\\n     * regarded as typical:\\n     *\\n     * \u003cpre\u003e\\n     * Exception in thread \"main\" java.lang.Exception: Something happened\\n     *  at Foo.bar(Foo.java:10)\\n     *  at Foo.main(Foo.java:5)\\n     *  Suppressed: Resource$CloseFailException: Resource ID = 0\\n     *          at Resource.close(Resource.java:26)\\n     *          at Foo.bar(Foo.java:9)\\n     *          ... 1 more\\n     * \u003c/pre\u003e\\n     * Note that the \"... n more\" notation is used on suppressed exceptions\\n     * just as it is used on causes. Unlike causes, suppressed exceptions are\\n     * indented beyond their \"containing exceptions.\"\\n     *\\n     * \u003cp\u003eAn exception can have both a cause and one or more suppressed\\n     * exceptions:\\n     * \u003cpre\u003e\\n     * Exception in thread \"main\" java.lang.Exception: Main block\\n     *  at Foo3.main(Foo3.java:7)\\n     *  Suppressed: Resource$CloseFailException: Resource ID = 2\\n     *          at Resource.close(Resource.java:26)\\n     *          at Foo3.main(Foo3.java:5)\\n     *  Suppressed: Resource$CloseFailException: Resource ID = 1\\n     *          at Resource.close(Resource.java:26)\\n     *          at Foo3.main(Foo3.java:5)\\n     * Caused by: java.lang.Exception: I did it\\n     *  at Foo3.main(Foo3.java:8)\\n     * \u003c/pre\u003e\\n     * Likewise, a suppressed exception can have a cause:\\n     * \u003cpre\u003e\\n     * Exception in thread \"main\" java.lang.Exception: Main block\\n     *  at Foo4.main(Foo4.java:6)\\n     *  Suppressed: Resource2$CloseFailException: Resource ID = 1\\n     *          at Resource2.close(Resource2.java:20)\\n     *          at Foo4.main(Foo4.java:5)\\n     *  Caused by: java.lang.Exception: Rats, you caught me\\n     *          at Resource2$CloseFailException.\u0026lt;init\u0026gt;(Resource2.java:45)\\n     *          ... 2 more\\n     * \u003c/pre\u003e\\n     \u0027}"}, {"color": "#97c2fc", "id": "fillInStackTrace()", "label": "fillInStackTrace()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void printStackTrace(PrintStream s)", "label": "public void printStackTrace(PrintStream s)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Prints this throwable and its backtrace to the specified print stream.\\n     *\\n     * @param s {@code PrintStream} to use for output\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void printEnclosedStackTrace(PrintStreamOrWriter s, StackTraceElement[] enclosingTrace, String caption, String prefix, Set\u003cThrowable\u003e dejaVu)", "label": "private void printEnclosedStackTrace(PrintStreamOrWriter s, StackTraceElement[] enclosingTrace, String caption, String prefix, Set\u003cThrowable\u003e dejaVu)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Print our stack trace as an enclosed exception for the specified\\n     * stack trace.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void printStackTrace(PrintWriter s)", "label": "public void printStackTrace(PrintWriter s)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Prints this throwable and its backtrace to the specified\\n     * print writer.\\n     *\\n     * @param s {@code PrintWriter} to use for output\\n     * @since   1.1\\n     \u0027}"}, {"color": "#97c2fc", "id": "public synchronized Throwable fillInStackTrace()", "label": "public synchronized Throwable fillInStackTrace()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-changed: Add @NeverInline to keep code size low.\u0027}"}, {"color": "#97c2fc", "id": "private static native Object nativeFillInStackTrace()", "label": "private static native Object nativeFillInStackTrace()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 private native Throwable fillInStackTrace(int dummy);\u0027}"}, {"color": "#97c2fc", "id": "public StackTraceElement[] getStackTrace()", "label": "public StackTraceElement[] getStackTrace()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an array of stack trace elements representing the stack dump\\n     * of this thread.  This method will return a zero-length array if\\n     * this thread has not started, has started but has not yet been\\n     * scheduled to run by the system, or has terminated.\\n     * If the returned array is of non-zero length then the first element of\\n     * the array represents the top of the stack, which is the most recent\\n     * method invocation in the sequence.  The last element of the array\\n     * represents the bottom of the stack, which is the least recent method\\n     * invocation in the sequence.\\n     *\\n     * \u003cp\u003eIf there is a security manager, and this thread is not\\n     * the current thread, then the security manager\\\u0027s\\n     * {@code checkPermission} method is called with a\\n     * {@code RuntimePermission(\"getStackTrace\")} permission\\n     * to see if it\\\u0027s ok to get the stack trace.\\n     *\\n     * \u003cp\u003eSome virtual machines may, under some circumstances, omit one\\n     * or more stack frames from the stack trace.  In the extreme case,\\n     * a virtual machine that has no stack trace information concerning\\n     * this thread is permitted to return a zero-length array from this\\n     * method.\\n     *\\n     * @return an array of {@code StackTraceElement},\\n     * each represents one stack frame.\\n     *\\n     * @throws SecurityException\\n     *        if a security manager exists and its\\n     *        {@code checkPermission} method doesn\\\u0027t allow\\n     *        getting the stack trace of thread.\\n     * @see SecurityManager#checkPermission\\n     * @see RuntimePermission\\n     * @see Throwable#getStackTrace\\n     *\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "printStackTrace()", "label": "printStackTrace()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void setStackTrace(StackTraceElement[] stackTrace)", "label": "public void setStackTrace(StackTraceElement[] stackTrace)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Sets the stack trace elements that will be returned by\\n     * {@link #getStackTrace()} and printed by {@link #printStackTrace()}\\n     * and related methods.\\n     *\\n     * This method, which is designed for use by RPC frameworks and other\\n     * advanced systems, allows the client to override the default\\n     * stack trace that is either generated by {@link #fillInStackTrace()}\\n     * when a throwable is constructed or deserialized when a throwable is\\n     * read from a serialization stream.\\n     *\\n     * \u003cp\u003eIf the stack trace of this {@code Throwable} {@linkplain\\n     * Throwable#Throwable(String, Throwable, boolean, boolean) is not\\n     * writable}, calling this method has no effect other than\\n     * validating its argument.\\n     *\\n     * @param   stackTrace the stack trace elements to be associated with\\n     * this {@code Throwable}.  The specified array is copied by this\\n     * call; changes in the specified array after the method invocation\\n     * returns will have no affect on this {@code Throwable}\u0027s stack\\n     * trace.\\n     *\\n     * @throws NullPointerException if {@code stackTrace} is\\n     *         {@code null} or if any of the elements of\\n     *         {@code stackTrace} are {@code null}\\n     *\\n     * @since  1.4\\n     \"}"}, {"color": "#97c2fc", "id": "getStackTrace()", "label": "getStackTrace()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "private static native StackTraceElement[] nativeGetStackTrace(Object stackState)", "label": "private static native StackTraceElement[] nativeGetStackTrace(Object stackState)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 native StackTraceElement getStackTraceElement(int index);\u0027}"}, {"color": "#97c2fc", "id": "private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException", "label": "private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Called to read the object from a stream.\\n     *\\n     * @param  s the {@code ObjectInputStream} from which data is read\\n     * @throws IOException if an I/O error occurs\\n     * @throws ClassNotFoundException if a serialized class cannot be loaded\\n     * @throws  InvalidObjectException\\n     *          if the object is invalid or has a cause that is not\\n     *          an {@code IOException}\\n     \u0027}"}, {"color": "#97c2fc", "id": "private synchronized void writeObject(ObjectOutputStream s) throws IOException", "label": "private synchronized void writeObject(ObjectOutputStream s) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Write a {@code Throwable} object to a stream.\\n     *\\n     * A {@code null} stack trace field is represented in the serial\\n     * form as a one-element array whose element is equal to {@code\\n     * new StackTraceElement(\"\", \"\", null, Integer.MIN_VALUE)}.\\n     *\\n     * @param  s the {@code ObjectOutputStream} to which data is written\\n     * @throws IOException if an I/O error occurs\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final synchronized void addSuppressed(Throwable exception)", "label": "public final synchronized void addSuppressed(Throwable exception)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Appends the specified exception to the exceptions that were\\n     * suppressed in order to deliver this exception. This method is\\n     * thread-safe and typically called (automatically and implicitly)\\n     * by the {@code try}-with-resources statement.\\n     *\\n     * \u003cp\u003eThe suppression behavior is enabled \u003cem\u003eunless\u003c/em\u003e disabled\\n     * {@linkplain #Throwable(String, Throwable, boolean, boolean) via\\n     * a constructor}.  When suppression is disabled, this method does\\n     * nothing other than to validate its argument.\\n     *\\n     * \u003cp\u003eNote that when one exception {@linkplain\\n     * #initCause(Throwable) causes} another exception, the first\\n     * exception is usually caught and then the second exception is\\n     * thrown in response.  In other words, there is a causal\\n     * connection between the two exceptions.\\n     *\\n     * In contrast, there are situations where two independent\\n     * exceptions can be thrown in sibling code blocks, in particular\\n     * in the {@code try} block of a {@code try}-with-resources\\n     * statement and the compiler-generated {@code finally} block\\n     * which closes the resource.\\n     *\\n     * In these situations, only one of the thrown exceptions can be\\n     * propagated.  In the {@code try}-with-resources statement, when\\n     * there are two such exceptions, the exception originating from\\n     * the {@code try} block is propagated and the exception from the\\n     * {@code finally} block is added to the list of exceptions\\n     * suppressed by the exception from the {@code try} block.  As an\\n     * exception unwinds the stack, it can accumulate multiple\\n     * suppressed exceptions.\\n     *\\n     * \u003cp\u003eAn exception may have suppressed exceptions while also being\\n     * caused by another exception.  Whether or not an exception has a\\n     * cause is semantically known at the time of its creation, unlike\\n     * whether or not an exception will suppress other exceptions\\n     * which is typically only determined after an exception is\\n     * thrown.\\n     *\\n     * \u003cp\u003eNote that programmer written code is also able to take\\n     * advantage of calling this method in situations where there are\\n     * multiple sibling exceptions and only one can be propagated.\\n     *\\n     * @param exception the exception to be added to the list of\\n     *        suppressed exceptions\\n     * @throws IllegalArgumentException if {@code exception} is this\\n     *         throwable; a throwable cannot suppress itself.\\n     * @throws NullPointerException if {@code exception} is {@code null}\\n     * @since 1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final synchronized Throwable[] getSuppressed()", "label": "public final synchronized Throwable[] getSuppressed()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an array containing all of the exceptions that were\\n     * suppressed, typically by the {@code try}-with-resources\\n     * statement, in order to deliver this exception.\\n     *\\n     * If no exceptions were suppressed or {@linkplain\\n     * #Throwable(String, Throwable, boolean, boolean) suppression is\\n     * disabled}, an empty array is returned.  This method is\\n     * thread-safe.  Writes to the returned array do not affect future\\n     * calls to this method.\\n     *\\n     * @return an array containing all of the exceptions that were\\n     *         suppressed to deliver this exception.\\n     * @since 1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "Thread.UncaughtExceptionHandler", "label": "Thread.UncaughtExceptionHandler", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "java.lang.ThreadDeath", "label": "java.lang.ThreadDeath", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public final void join(long millis) throws InterruptedException", "label": "public final void join(long millis) throws InterruptedException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 public final synchronized void join(long millis)\u0027}"}, {"color": "#97c2fc", "id": "public final void join(long millis, int nanos) throws InterruptedException", "label": "public final void join(long millis, int nanos) throws InterruptedException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 public final synchronized void join(long millis, int nanos)\u0027}"}, {"color": "#97c2fc", "id": "public final void join() throws InterruptedException", "label": "public final void join() throws InterruptedException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Waits for this thread to die.\\n     *\\n     * \u003cp\u003e An invocation of this method behaves in exactly the same\\n     * way as the invocation\\n     *\\n     * \u003cblockquote\u003e\\n     * {@linkplain #join(long) join}{@code (0)}\\n     * \u003c/blockquote\u003e\\n     *\\n     * @throws  InterruptedException\\n     *          if any thread has interrupted the current thread. The\\n     *          \u003ci\u003einterrupted status\u003c/i\u003e of the current thread is\\n     *          cleared when this exception is thrown.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void dumpStack()", "label": "public static void dumpStack()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Prints a stack trace of the current thread to the standard error stream.\\n     * This method is used only for debugging.\\n     *\\n     * @see     Throwable#printStackTrace()\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final void setDaemon(boolean on)", "label": "public final void setDaemon(boolean on)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Marks this thread as either a {@linkplain #isDaemon daemon} thread\\n     * or a user thread. The Java Virtual Machine exits when the only\\n     * threads running are all daemon threads.\\n     *\\n     * \u003cp\u003e This method must be invoked before the thread is started.\\n     *\\n     * @param  on\\n     *         if {@code true}, marks this thread as a daemon thread\\n     *\\n     * @throws  IllegalThreadStateException\\n     *          if this thread is {@linkplain #isAlive alive}\\n     *\\n     * @throws  SecurityException\\n     *          if {@link #checkAccess} determines that the current\\n     *          thread cannot modify this thread\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ClassLoader getContextClassLoader()", "label": "public ClassLoader getContextClassLoader()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the context {@code ClassLoader} for this thread. The context\\n     * {@code ClassLoader} is provided by the creator of the thread for use\\n     * by code running in this thread when loading classes and resources.\\n     * If not {@linkplain #setContextClassLoader set}, the default is the\\n     * {@code ClassLoader} context of the parent thread. The context\\n     * {@code ClassLoader} of the\\n     * primordial thread is typically set to the class loader used to load the\\n     * application.\\n     *\\n     *\\n     * @return  the context {@code ClassLoader} for this thread, or {@code null}\\n     *          indicating the system class loader (or, failing that, the\\n     *          bootstrap class loader)\\n     *\\n     * @throws  SecurityException\\n     *          if the current thread cannot get the context ClassLoader\\n     *\\n     * @since 1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void setContextClassLoader(ClassLoader cl)", "label": "public void setContextClassLoader(ClassLoader cl)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the context ClassLoader for this Thread. The context\\n     * ClassLoader can be set when a thread is created, and allows\\n     * the creator of the thread to provide the appropriate class loader,\\n     * through {@code getContextClassLoader}, to code running in the thread\\n     * when loading classes and resources.\\n     *\\n     * \u003cp\u003eIf a security manager is present, its {@link\\n     * SecurityManager#checkPermission(java.security.Permission) checkPermission}\\n     * method is invoked with a {@link RuntimePermission RuntimePermission}{@code\\n     * (\"setContextClassLoader\")} permission to see if setting the context\\n     * ClassLoader is permitted.\\n     *\\n     * @param  cl\\n     *         the context ClassLoader for this Thread, or null  indicating the\\n     *         system class loader (or, failing that, the bootstrap class loader)\\n     *\\n     * @throws  SecurityException\\n     *          if the current thread cannot set the context ClassLoader\\n     *\\n     * @since 1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static native boolean holdsLock(Object obj)", "label": "public static native boolean holdsLock(Object obj)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if and only if the current thread holds the\\n     * monitor lock on the specified object.\\n     *\\n     * \u003cp\u003eThis method is designed to allow a program to assert that\\n     * the current thread already holds a specified lock:\\n     * \u003cpre\u003e\\n     *     assert Thread.holdsLock(obj);\\n     * \u003c/pre\u003e\\n     *\\n     * @param  obj the object on which to test lock ownership\\n     * @throws NullPointerException if obj is {@code null}\\n     * @return {@code true} if the current thread holds the monitor lock on\\n     *         the specified object.\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Map\u003cThread, StackTraceElement[]\u003e getAllStackTraces()", "label": "public static Map\u003cThread, StackTraceElement[]\u003e getAllStackTraces()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a map of stack traces for all live threads.\\n     * The map keys are threads and each map value is an array of\\n     * {@code StackTraceElement} that represents the stack dump\\n     * of the corresponding {@code Thread}.\\n     * The returned stack traces are in the format specified for\\n     * the {@link #getStackTrace getStackTrace} method.\\n     *\\n     * \u003cp\u003eThe threads may be executing while this method is called.\\n     * The stack trace of each thread only represents a snapshot and\\n     * each stack trace may be obtained at different time.  A zero-length\\n     * array will be returned in the map value if the virtual machine has\\n     * no stack trace information about a thread.\\n     *\\n     * @return a {@code Map} from {@code Thread} to an array of\\n     * {@code StackTraceElement} that represents the stack trace of\\n     * the corresponding thread.\\n     *\\n     * @see #getStackTrace\\n     * @see SecurityManager#checkPermission\\n     * @see RuntimePermission\\n     * @see Throwable#getStackTrace\\n     *\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "getStackTrace", "label": "getStackTrace", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "private static boolean isCCLOverridden(Class\u003c?\u003e cl)", "label": "private static boolean isCCLOverridden(Class\u003c?\u003e cl)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Verifies that this (possibly subclass) instance can be constructed\\n     * without violating security constraints: the subclass must not override\\n     * security-sensitive non-final methods, or else the\\n     * \"enableContextClassLoaderOverride\" RuntimePermission is checked.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static boolean auditSubclass(final Class\u003c?\u003e subcl)", "label": "private static boolean auditSubclass(final Class\u003c?\u003e subcl)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs reflective checks on given subclass to verify that it doesn\\\u0027t\\n     * override security-sensitive non-final methods.  Returns true if subclass\\n     * is \"safe\", false otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public long getId()", "label": "public long getId()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the identifier of this Thread.  The thread ID is a positive\\n     * {@code long} number generated when this thread was created.\\n     * The thread ID is unique and remains unchanged during its lifetime.\\n     * When a thread is terminated, this thread ID may be reused.\\n     *\\n     * @return this thread\u0027s ID.\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": "public State getState()", "label": "public State getState()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the state of this thread.\\n     * This method is designed for use in monitoring of the system state,\\n     * not for synchronization control.\\n     *\\n     * @return this thread\u0027s state.\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": "public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh)", "label": "public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Set the default handler invoked when a thread abruptly terminates\\n     * due to an uncaught exception, and no other handler has been defined\\n     * for that thread.\\n     *\\n     * \u003cp\u003eUncaught exception handling is controlled first by the thread, then\\n     * by the thread\u0027s {@link ThreadGroup} object and finally by the default\\n     * uncaught exception handler. If the thread does not have an explicit\\n     * uncaught exception handler set, and the thread\u0027s thread group\\n     * (including parent thread groups)  does not specialize its\\n     * {@code uncaughtException} method, then the default handler\u0027s\\n     * {@code uncaughtException} method will be invoked.\\n     * \u003cp\u003eBy setting the default uncaught exception handler, an application\\n     * can change the way in which uncaught exceptions are handled (such as\\n     * logging to a specific device, or file) for those threads that would\\n     * already accept whatever \u0026quot;default\u0026quot; behavior the system\\n     * provided.\\n     *\\n     * \u003cp\u003eNote that the default uncaught exception handler should not usually\\n     * defer to the thread\u0027s {@code ThreadGroup} object, as that could cause\\n     * infinite recursion.\\n     *\\n     * @param eh the object to use as the default uncaught exception handler.\\n     * If {@code null} then there is no default handler.\\n     *\\n     * @see #setUncaughtExceptionHandler\\n     * @see #getUncaughtExceptionHandler\\n     * @see ThreadGroup#uncaughtException\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": "public static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()", "label": "public static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the default handler invoked when a thread abruptly terminates\\n     * due to an uncaught exception. If the returned value is {@code null},\\n     * there is no default.\\n     * @since 1.5\\n     * @see #setDefaultUncaughtExceptionHandler\\n     * @return the default uncaught exception handler for all threads\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void setUncaughtExceptionHandler(UncaughtExceptionHandler eh)", "label": "public void setUncaughtExceptionHandler(UncaughtExceptionHandler eh)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Set the handler invoked when this thread abruptly terminates\\n     * due to an uncaught exception.\\n     * \u003cp\u003eA thread can take full control of how it responds to uncaught\\n     * exceptions by having its uncaught exception handler explicitly set.\\n     * If no such handler is set then the thread\u0027s {@code ThreadGroup}\\n     * object acts as its handler.\\n     * @param eh the object to use as this thread\u0027s uncaught exception\\n     * handler. If {@code null} then this thread has no explicit handler.\\n     * @throws  SecurityException  if the current thread is not allowed to\\n     *          modify this thread.\\n     * @see #setDefaultUncaughtExceptionHandler\\n     * @see ThreadGroup#uncaughtException\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": "public final void dispatchUncaughtException(Throwable e)", "label": "public final void dispatchUncaughtException(Throwable e)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-changed: Make dispatchUncaughtException() public, for use by tests.\u0027}"}, {"color": "#97c2fc", "id": " static void processQueue(ReferenceQueue\u003cClass\u003c?\u003e\u003e queue, ConcurrentMap\u003c? extends WeakReference\u003cClass\u003c?\u003e\u003e, ?\u003e map)", "label": " static void processQueue(ReferenceQueue\u003cClass\u003c?\u003e\u003e queue, ConcurrentMap\u003c? extends WeakReference\u003cClass\u003c?\u003e\u003e, ?\u003e map)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Removes from the specified map any keys that have been enqueued\\n     * on the specified reference queue.\\n     \u0027}"}, {"color": "#97c2fc", "id": " native void setPriority0(int newPriority)", "label": " native void setPriority0(int newPriority)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Android-changed: Make accessible to Daemons.java for internal use.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private native int nativeGetStatus(boolean hasBeenStarted)", "label": "private native int nativeGetStatus(boolean hasBeenStarted)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-added: Android specific nativeGetStatus() method.\u0027}"}, {"color": "#97c2fc", "id": "InterruptedException", "label": "InterruptedException", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public static boolean setCurrentTimeMillis(long millis)", "label": "public static boolean setCurrentTimeMillis(long millis)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the current wall time, in milliseconds.  Requires the calling\\n     * process to have appropriate permissions.\\n     *\\n     * @return if the clock was successfully set to the specified time.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static native long uptimeMillis()", "label": "public static native long uptimeMillis()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns milliseconds since boot, not counting time spent in deep sleep.\\n     *\\n     * @return milliseconds of non-sleep uptime since boot.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static native long uptimeNanos()", "label": "public static native long uptimeNanos()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns nanoseconds since boot, not counting time spent in deep sleep.\\n     *\\n     * @return nanoseconds of non-sleep uptime since boot.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static native long elapsedRealtime()", "label": "public static native long elapsedRealtime()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns milliseconds since boot, including time spent in sleep.\\n     *\\n     * @return elapsed milliseconds since boot.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static native long elapsedRealtimeNanos()", "label": "public static native long elapsedRealtimeNanos()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns nanoseconds since boot, including time spent in sleep.\\n     *\\n     * @return elapsed nanoseconds since boot.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static native long currentThreadTimeMillis()", "label": "public static native long currentThreadTimeMillis()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns milliseconds running in the current thread.\\n     *\\n     * @return elapsed milliseconds in the thread\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Clock currentNetworkTimeClock()", "label": "public static Clock currentNetworkTimeClock()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@link Clock} that starts at January 1, 1970 00:00:00.0 UTC,\\n     * synchronized using a remote network source outside the device.\\n     * \u003cp\u003e\\n     * While the time returned by {@link System#currentTimeMillis()} can be\\n     * adjusted by the user, the time returned by this method cannot be adjusted\\n     * by the user.\\n     * \u003cp\u003e\\n     * This performs no blocking network operations and returns values based on\\n     * a recent successful synchronization event; it will either return a valid\\n     * time or throw.\\n     * \u003cp\u003e\\n     * Note that synchronization may occur using an insecure network protocol,\\n     * so the returned time should not be used for security purposes.\\n     * The device may resynchronize with the same or different network source\\n     * at any time. Due to network delays, variations between servers, or local\\n     * (client side) clock drift, the accuracy of the returned times cannot be\\n     * guaranteed. In extreme cases, consecutive calls to {@link\\n     * Clock#millis()} on the returned {@link Clock}could return times that are\\n     * out of order.\\n     *\\n     * @throws DateTimeException when no network time can be provided.\\n     \u0027}"}, {"color": "#97c2fc", "id": "millis()", "label": "millis()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.time.Clock", "label": "java.time.Clock", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public static Clock currentGnssTimeClock()", "label": "public static Clock currentGnssTimeClock()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a {@link Clock} that starts at January 1, 1970 00:00:00.0 UTC,\\n     * synchronized using the device\u0027s location provider.\\n     *\\n     * @throws DateTimeException when the location provider has not had a location fix since boot.\\n     \"}"}, {"color": "#97c2fc", "id": "public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)", "label": "public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies an array from the specified source array, beginning at the\\n     * specified position, to the specified position of the destination array.\\n     * A subsequence of array components are copied from the source\\n     * array referenced by \u003ccode\u003esrc\u003c/code\u003e to the destination array\\n     * referenced by \u003ccode\u003edest\u003c/code\u003e. The number of components copied is\\n     * equal to the \u003ccode\u003elength\u003c/code\u003e argument. The components at\\n     * positions \u003ccode\u003esrcPos\u003c/code\u003e through\\n     * \u003ccode\u003esrcPos+length-1\u003c/code\u003e in the source array are copied into\\n     * positions \u003ccode\u003edestPos\u003c/code\u003e through\\n     * \u003ccode\u003edestPos+length-1\u003c/code\u003e, respectively, of the destination\\n     * array.\\n     * \u003cp\u003e\\n     * If the \u003ccode\u003esrc\u003c/code\u003e and \u003ccode\u003edest\u003c/code\u003e arguments refer to the\\n     * same array object, then the copying is performed as if the\\n     * components at positions \u003ccode\u003esrcPos\u003c/code\u003e through\\n     * \u003ccode\u003esrcPos+length-1\u003c/code\u003e were first copied to a temporary\\n     * array with \u003ccode\u003elength\u003c/code\u003e components and then the contents of\\n     * the temporary array were copied into positions\\n     * \u003ccode\u003edestPos\u003c/code\u003e through \u003ccode\u003edestPos+length-1\u003c/code\u003e of the\\n     * destination array.\\n     * \u003cp\u003e\\n     * If \u003ccode\u003edest\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e, then a\\n     * \u003ccode\u003eNullPointerException\u003c/code\u003e is thrown.\\n     * \u003cp\u003e\\n     * If \u003ccode\u003esrc\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e, then a\\n     * \u003ccode\u003eNullPointerException\u003c/code\u003e is thrown and the destination\\n     * array is not modified.\\n     * \u003cp\u003e\\n     * Otherwise, if any of the following is true, an\\n     * \u003ccode\u003eArrayStoreException\u003c/code\u003e is thrown and the destination is\\n     * not modified:\\n     * \u003cul\u003e\\n     * \u003cli\u003eThe \u003ccode\u003esrc\u003c/code\u003e argument refers to an object that is not an\\n     *     array.\\n     * \u003cli\u003eThe \u003ccode\u003edest\u003c/code\u003e argument refers to an object that is not an\\n     *     array.\\n     * \u003cli\u003eThe \u003ccode\u003esrc\u003c/code\u003e argument and \u003ccode\u003edest\u003c/code\u003e argument refer\\n     *     to arrays whose component types are different primitive types.\\n     * \u003cli\u003eThe \u003ccode\u003esrc\u003c/code\u003e argument refers to an array with a primitive\\n     *    component type and the \u003ccode\u003edest\u003c/code\u003e argument refers to an array\\n     *     with a reference component type.\\n     * \u003cli\u003eThe \u003ccode\u003esrc\u003c/code\u003e argument refers to an array with a reference\\n     *    component type and the \u003ccode\u003edest\u003c/code\u003e argument refers to an array\\n     *     with a primitive component type.\\n     * \u003c/ul\u003e\\n     * \u003cp\u003e\\n     * Otherwise, if any of the following is true, an\\n     * \u003ccode\u003eIndexOutOfBoundsException\u003c/code\u003e is\\n     * thrown and the destination is not modified:\\n     * \u003cul\u003e\\n     * \u003cli\u003eThe \u003ccode\u003esrcPos\u003c/code\u003e argument is negative.\\n     * \u003cli\u003eThe \u003ccode\u003edestPos\u003c/code\u003e argument is negative.\\n     * \u003cli\u003eThe \u003ccode\u003elength\u003c/code\u003e argument is negative.\\n     * \u003cli\u003e\u003ccode\u003esrcPos+length\u003c/code\u003e is greater than\\n     *     \u003ccode\u003esrc.length\u003c/code\u003e, the length of the source array.\\n     * \u003cli\u003e\u003ccode\u003edestPos+length\u003c/code\u003e is greater than\\n     *     \u003ccode\u003edest.length\u003c/code\u003e, the length of the destination array.\\n     * \u003c/ul\u003e\\n     * \u003cp\u003e\\n     * Otherwise, if any actual component of the source array from\\n     * position \u003ccode\u003esrcPos\u003c/code\u003e through\\n     * \u003ccode\u003esrcPos+length-1\u003c/code\u003e cannot be converted to the component\\n     * type of the destination array by assignment conversion, an\\n     * \u003ccode\u003eArrayStoreException\u003c/code\u003e is thrown. In this case, let\\n     * \u003cb\u003e\u003ci\u003ek\u003c/i\u003e\u003c/b\u003e be the smallest nonnegative integer less than\\n     * length such that \u003ccode\u003esrc[srcPos+\u003c/code\u003e\u003ci\u003ek\u003c/i\u003e\u003ccode\u003e]\u003c/code\u003e\\n     * cannot be converted to the component type of the destination\\n     * array; when the exception is thrown, source array components from\\n     * positions \u003ccode\u003esrcPos\u003c/code\u003e through\\n     * \u003ccode\u003esrcPos+\u003c/code\u003e\u003ci\u003ek\u003c/i\u003e\u003ccode\u003e-1\u003c/code\u003e\\n     * will already have been copied to destination array positions\\n     * \u003ccode\u003edestPos\u003c/code\u003e through\\n     * \u003ccode\u003edestPos+\u003c/code\u003e\u003ci\u003ek\u003c/I\u003e\u003ccode\u003e-1\u003c/code\u003e and no other\\n     * positions of the destination array will have been modified.\\n     * (Because of the restrictions already itemized, this\\n     * paragraph effectively applies only to the situation where both\\n     * arrays have component types that are reference types.)\\n     *\\n     * @param      src      the source array.\\n     * @param      srcPos   starting position in the source array.\\n     * @param      dest     the destination array.\\n     * @param      destPos  starting position in the destination data.\\n     * @param      length   the number of array elements to be copied.\\n     * @exception  IndexOutOfBoundsException  if copying would cause\\n     *               access of data outside array bounds.\\n     * @exception  ArrayStoreException  if an element in the \u003ccode\u003esrc\u003c/code\u003e\\n     *               array could not be stored into the \u003ccode\u003edest\u003c/code\u003e array\\n     *               because of a type mismatch.\\n     * @exception  NullPointerException if either \u003ccode\u003esrc\u003c/code\u003e or\\n     *               \u003ccode\u003edest\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static void arraycopy(char[] src, int srcPos, char[] dst, int dstPos, int length)", "label": "private static void arraycopy(char[] src, int srcPos, char[] dst, int dstPos, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The char[] specialized version of arraycopy().\\n     * Note: This method is required for runtime ART compiler optimizations.\\n     * Do not remove or change the signature.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static native void arraycopyCharUnchecked(char[] src, int srcPos, char[] dst, int dstPos, int length)", "label": "private static native void arraycopyCharUnchecked(char[] src, int srcPos, char[] dst, int dstPos, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The char[] specialized, unchecked, native version of\\n     * arraycopy(). This assumes error checking has been done.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static void arraycopy(byte[] src, int srcPos, byte[] dst, int dstPos, int length)", "label": "private static void arraycopy(byte[] src, int srcPos, byte[] dst, int dstPos, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The byte[] specialized version of arraycopy().\\n     * Note: This method is required for runtime ART compiler optimizations.\\n     * Do not remove or change the signature.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static native void arraycopyByteUnchecked(byte[] src, int srcPos, byte[] dst, int dstPos, int length)", "label": "private static native void arraycopyByteUnchecked(byte[] src, int srcPos, byte[] dst, int dstPos, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The byte[] specialized, unchecked, native version of\\n     * arraycopy(). This assumes error checking has been done.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static void arraycopy(short[] src, int srcPos, short[] dst, int dstPos, int length)", "label": "private static void arraycopy(short[] src, int srcPos, short[] dst, int dstPos, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The short[] specialized version of arraycopy().\\n     * Note: This method is required for runtime ART compiler optimizations.\\n     * Do not remove or change the signature.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static native void arraycopyShortUnchecked(short[] src, int srcPos, short[] dst, int dstPos, int length)", "label": "private static native void arraycopyShortUnchecked(short[] src, int srcPos, short[] dst, int dstPos, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The short[] specialized, unchecked, native version of\\n     * arraycopy(). This assumes error checking has been done.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static void arraycopy(int[] src, int srcPos, int[] dst, int dstPos, int length)", "label": "private static void arraycopy(int[] src, int srcPos, int[] dst, int dstPos, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The int[] specialized version of arraycopy().\\n     * Note: This method is required for runtime ART compiler optimizations.\\n     * Do not remove or change the signature.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static native void arraycopyIntUnchecked(int[] src, int srcPos, int[] dst, int dstPos, int length)", "label": "private static native void arraycopyIntUnchecked(int[] src, int srcPos, int[] dst, int dstPos, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The int[] specialized, unchecked, native version of\\n     * arraycopy(). This assumes error checking has been done.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static void arraycopy(long[] src, int srcPos, long[] dst, int dstPos, int length)", "label": "private static void arraycopy(long[] src, int srcPos, long[] dst, int dstPos, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The long[] specialized version of arraycopy().\\n     * Note: This method is required for runtime ART compiler optimizations.\\n     * Do not remove or change the signature.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static native void arraycopyLongUnchecked(long[] src, int srcPos, long[] dst, int dstPos, int length)", "label": "private static native void arraycopyLongUnchecked(long[] src, int srcPos, long[] dst, int dstPos, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The long[] specialized, unchecked, native version of\\n     * arraycopy(). This assumes error checking has been done.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static void arraycopy(float[] src, int srcPos, float[] dst, int dstPos, int length)", "label": "private static void arraycopy(float[] src, int srcPos, float[] dst, int dstPos, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The float[] specialized version of arraycopy().\\n     * Note: This method is required for runtime ART compiler optimizations.\\n     * Do not remove or change the signature.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static native void arraycopyFloatUnchecked(float[] src, int srcPos, float[] dst, int dstPos, int length)", "label": "private static native void arraycopyFloatUnchecked(float[] src, int srcPos, float[] dst, int dstPos, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The float[] specialized, unchecked, native version of\\n     * arraycopy(). This assumes error checking has been done.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static void arraycopy(double[] src, int srcPos, double[] dst, int dstPos, int length)", "label": "private static void arraycopy(double[] src, int srcPos, double[] dst, int dstPos, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The double[] specialized version of arraycopy().\\n     * Note: This method is required for runtime ART compiler optimizations.\\n     * Do not remove or change the signature.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static native void arraycopyDoubleUnchecked(double[] src, int srcPos, double[] dst, int dstPos, int length)", "label": "private static native void arraycopyDoubleUnchecked(double[] src, int srcPos, double[] dst, int dstPos, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The double[] specialized, unchecked, native version of\\n     * arraycopy(). This assumes error checking has been done.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static void arraycopy(boolean[] src, int srcPos, boolean[] dst, int dstPos, int length)", "label": "private static void arraycopy(boolean[] src, int srcPos, boolean[] dst, int dstPos, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The boolean[] specialized version of arraycopy().\\n     * Note: This method is required for runtime ART compiler optimizations.\\n     * Do not remove or change the signature.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static native void arraycopyBooleanUnchecked(boolean[] src, int srcPos, boolean[] dst, int dstPos, int length)", "label": "private static native void arraycopyBooleanUnchecked(boolean[] src, int srcPos, boolean[] dst, int dstPos, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The boolean[] specialized, unchecked, native version of\\n     * arraycopy(). This assumes error checking has been done.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int identityHashCode(Object x)", "label": "public static int identityHashCode(Object x)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the same hash code for the given object as\\n     * would be returned by the default method hashCode(),\\n     * whether or not the given object\u0027s class overrides\\n     * hashCode().\\n     * The hash code for the null reference is zero.\\n     *\\n     * @param x object for which the hashCode is to be calculated\\n     * @return  the hashCode\\n     * @since   JDK1.1\\n     \"}"}, {"color": "#97c2fc", "id": "public static Properties getProperties()", "label": "public static Properties getProperties()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines the current system properties.\\n     *\\n     *\\n     * \u003cp\u003eThe following properties are always provided by the Dalvik VM:\u003c/p\u003e\\n     * \u003cp\u003e\u003ctable BORDER=\"1\" WIDTH=\"100%\" CELLPADDING=\"3\" CELLSPACING=\"0\" SUMMARY=\"\"\u003e\\n     * \u003ctr BGCOLOR=\"#CCCCFF\" CLASS=\"TableHeadingColor\"\u003e\\n     *     \u003ctd\u003e\u003cb\u003eName\u003c/b\u003e\u003c/td\u003e        \u003ctd\u003e\u003cb\u003eMeaning\u003c/b\u003e\u003c/td\u003e                    \u003ctd\u003e\u003cb\u003eExample\u003c/b\u003e\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003ctd\u003efile.separator\u003c/td\u003e     \u003ctd\u003e{@link java.io.File#separator}\u003c/td\u003e    \u003ctd\u003e{@code /}\u003c/td\u003e\u003c/tr\u003e\\n     *\\n     * \u003ctr\u003e\u003ctd\u003ejava.class.path\u003c/td\u003e    \u003ctd\u003eSystem class path\u003c/td\u003e                 \u003ctd\u003e{@code .}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003ctd\u003ejava.class.version\u003c/td\u003e \u003ctd\u003e(Not useful on Android)\u003c/td\u003e           \u003ctd\u003e{@code 50.0}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003ctd\u003ejava.compiler\u003c/td\u003e      \u003ctd\u003e(Not useful on Android)\u003c/td\u003e           \u003ctd\u003eEmpty\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003ctd\u003ejava.ext.dirs\u003c/td\u003e      \u003ctd\u003e(Not useful on Android)\u003c/td\u003e           \u003ctd\u003eEmpty\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003ctd\u003ejava.home\u003c/td\u003e          \u003ctd\u003eLocation of the VM on the file system\u003c/td\u003e \u003ctd\u003e{@code /apex/com.android.art/}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003ctd\u003ejava.io.tmpdir\u003c/td\u003e     \u003ctd\u003eLocation of a temporary directory.\u003cbr\u003eThe location varies by application.\u003cbr\u003eSee {@link java.io.File#createTempFile}\u003c/td\u003e \u003ctd\u003e{@code /data/user/0/com.android.app/cache}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003ctd\u003ejava.library.path\u003c/td\u003e  \u003ctd\u003eSearch path for JNI libraries\u003c/td\u003e     \u003ctd\u003e{@code /vendor/lib:/system/lib}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003ctd\u003ejava.vendor\u003c/td\u003e        \u003ctd\u003eHuman-readable VM vendor\u003c/td\u003e          \u003ctd\u003e{@code The Android Project}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003ctd\u003ejava.vendor.url\u003c/td\u003e    \u003ctd\u003eURL for VM vendor\\\u0027s web site\u003c/td\u003e      \u003ctd\u003e{@code http://www.android.com/}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003ctd\u003ejava.version\u003c/td\u003e       \u003ctd\u003e(Not useful on Android)\u003c/td\u003e           \u003ctd\u003e{@code 0}\u003c/td\u003e\u003c/tr\u003e\\n     *\\n     * \u003ctr\u003e\u003ctd\u003ejava.specification.version\u003c/td\u003e    \u003ctd\u003eVM libraries version\u003c/td\u003e        \u003ctd\u003e{@code 0.9}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003ctd\u003ejava.specification.vendor\u003c/td\u003e     \u003ctd\u003eVM libraries vendor\u003c/td\u003e         \u003ctd\u003e{@code The Android Project}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003ctd\u003ejava.specification.name\u003c/td\u003e       \u003ctd\u003eVM libraries name\u003c/td\u003e           \u003ctd\u003e{@code Dalvik Core Library}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003ctd\u003ejava.vm.version\u003c/td\u003e               \u003ctd\u003eVM implementation version\u003c/td\u003e   \u003ctd\u003e{@code 1.2.0}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003ctd\u003ejava.vm.vendor\u003c/td\u003e                \u003ctd\u003eVM implementation vendor\u003c/td\u003e    \u003ctd\u003e{@code The Android Project}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003ctd\u003ejava.vm.name\u003c/td\u003e                  \u003ctd\u003eVM implementation name\u003c/td\u003e      \u003ctd\u003e{@code Dalvik}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003ctd\u003ejava.vm.specification.version\u003c/td\u003e \u003ctd\u003eVM specification version\u003c/td\u003e    \u003ctd\u003e{@code 0.9}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003ctd\u003ejava.vm.specification.vendor\u003c/td\u003e  \u003ctd\u003eVM specification vendor\u003c/td\u003e     \u003ctd\u003e{@code The Android Project}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003ctd\u003ejava.vm.specification.name\u003c/td\u003e    \u003ctd\u003eVM specification name\u003c/td\u003e       \u003ctd\u003e{@code Dalvik Virtual Machine Specification}\u003c/td\u003e\u003c/tr\u003e\\n     *\\n     * \u003ctr\u003e\u003ctd\u003eline.separator\u003c/td\u003e     \u003ctd\u003eThe system line separator\u003c/td\u003e         \u003ctd\u003e{@code \\\\n}\u003c/td\u003e\u003c/tr\u003e\\n     *\\n     * \u003ctr\u003e\u003ctd\u003eos.arch\u003c/td\u003e            \u003ctd\u003eOS architecture\u003c/td\u003e                   \u003ctd\u003e{@code aarch64}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003ctd\u003eos.name\u003c/td\u003e            \u003ctd\u003eOS (kernel) name\u003c/td\u003e                  \u003ctd\u003e{@code Linux}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003ctd\u003eos.version\u003c/td\u003e         \u003ctd\u003eOS (kernel) version\u003c/td\u003e               \u003ctd\u003e{@code 5.10.98-g6ea688a79989}\u003c/td\u003e\u003c/tr\u003e\\n     *\\n     * \u003ctr\u003e\u003ctd\u003epath.separator\u003c/td\u003e     \u003ctd\u003eSee {@link java.io.File#pathSeparator}\u003c/td\u003e \u003ctd\u003e{@code :}\u003c/td\u003e\u003c/tr\u003e\\n     *\\n     * \u003ctr\u003e\u003ctd\u003euser.dir\u003c/td\u003e           \u003ctd\u003eBase of non-absolute paths\u003c/td\u003e        \u003ctd\u003e{@code /}\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003ctd\u003euser.home\u003c/td\u003e          \u003ctd\u003e(Not useful on Android)\u003c/td\u003e           \u003ctd\u003eEmpty\u003c/td\u003e\u003c/tr\u003e\\n     * \u003ctr\u003e\u003ctd\u003euser.name\u003c/td\u003e          \u003ctd\u003e(Not useful on Android)\u003c/td\u003e           \u003ctd\u003eEmpty\u003c/td\u003e\u003c/tr\u003e\\n     *\\n     * \u003c/table\u003e\\n     * \u003cp\u003e\\n     * Multiple paths in a system property value are separated by the path\\n     * separator character of the platform.\\n     * \u003cp\u003e\\n     * Note that even if the security manager does not permit the\\n     * \u003ccode\u003egetProperties\u003c/code\u003e operation, it may choose to permit the\\n     * {@link #getProperty(String)} operation.\\n     *\\n     * @return     the system properties\\n     * @exception  SecurityException  if a security manager exists and its\\n     *             \u003ccode\u003echeckPropertiesAccess\u003c/code\u003e method doesn\\\u0027t allow access\\n     *              to the system properties.\\n     * @see        #setProperties\\n     * @see        java.lang.SecurityException\\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\\n     * @see        java.util.Properties\\n     \u0027}"}, {"color": "#97c2fc", "id": "createTempFile", "label": "createTempFile", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.io.File", "label": "java.io.File", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": " final boolean isInvalid()", "label": " final boolean isInvalid()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Check if the file has an invalid path. Currently, the inspection of\\n     * a file path is very limited, and it only covers Nul character check.\\n     * Returning true means the path is definitely invalid/garbage. But\\n     * returning false does not guarantee that the path is valid.\\n     *\\n     * @return true if the file path is invalid.\\n     \u0027}"}, {"color": "#97c2fc", "id": " int getPrefixLength()", "label": " int getPrefixLength()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the length of this abstract pathname\u0027s prefix.\\n     * For use by FileSystem classes.\\n     \"}"}, {"color": "#97c2fc", "id": "public String getName()", "label": "public String getName()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the name of the file or directory denoted by this abstract\\n     * pathname.  This is just the last name in the pathname\u0027s name\\n     * sequence.  If the pathname\u0027s name sequence is empty, then the empty\\n     * string is returned.\\n     *\\n     * @return  The name of the file or directory denoted by this abstract\\n     *          pathname, or the empty string if this pathname\u0027s name sequence\\n     *          is empty\\n     \"}"}, {"color": "#97c2fc", "id": "public String getParent()", "label": "public String getParent()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the pathname string of this abstract pathname\u0027s parent, or\\n     * \u003ccode\u003enull\u003c/code\u003e if this pathname does not name a parent directory.\\n     *\\n     * \u003cp\u003e The \u003cem\u003eparent\u003c/em\u003e of an abstract pathname consists of the\\n     * pathname\u0027s prefix, if any, and each name in the pathname\u0027s name\\n     * sequence except for the last.  If the name sequence is empty then\\n     * the pathname does not name a parent directory.\\n     *\\n     * @return  The pathname string of the parent directory named by this\\n     *          abstract pathname, or \u003ccode\u003enull\u003c/code\u003e if this pathname\\n     *          does not name a parent\\n     \"}"}, {"color": "#97c2fc", "id": "public File getParentFile()", "label": "public File getParentFile()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the abstract pathname of this abstract pathname\u0027s parent,\\n     * or \u003ccode\u003enull\u003c/code\u003e if this pathname does not name a parent\\n     * directory.\\n     *\\n     * \u003cp\u003e The \u003cem\u003eparent\u003c/em\u003e of an abstract pathname consists of the\\n     * pathname\u0027s prefix, if any, and each name in the pathname\u0027s name\\n     * sequence except for the last.  If the name sequence is empty then\\n     * the pathname does not name a parent directory.\\n     *\\n     * @return  The abstract pathname of the parent directory named by this\\n     *          abstract pathname, or \u003ccode\u003enull\u003c/code\u003e if this pathname\\n     *          does not name a parent\\n     *\\n     * @since 1.2\\n     \"}"}, {"color": "#97c2fc", "id": "public String getPath()", "label": "public String getPath()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the decoded path component of this URI.\\n     *\\n     * \u003cp\u003e The string returned by this method is equal to that returned by the\\n     * {@link #getRawPath() getRawPath} method except that all sequences of\\n     * escaped octets are \u003ca href=\"#decode\"\u003edecoded\u003c/a\u003e.  \u003c/p\u003e\\n     *\\n     * @return  The decoded path component of this URI,\\n     *          or {@code null} if the path is undefined\\n     \u0027}"}, {"color": "#97c2fc", "id": "separator", "label": "separator", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public boolean isAbsolute()", "label": "public boolean isAbsolute()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this URI is absolute.\\n     *\\n     * \u003cp\u003e A URI is absolute if, and only if, it has a scheme component. \u003c/p\u003e\\n     *\\n     * @return  {@code true} if, and only if, this URI is absolute\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getAbsolutePath()", "label": "public String getAbsolutePath()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the absolute path of this file. An absolute path is a path that starts at a root\\n     * of the file system. On Android, there is only one root: {@code /}.\\n     *\\n     * \u003cp\u003eA common use for absolute paths is when passing paths to a {@code Process} as\\n     * command-line arguments, to remove the requirement implied by relative paths, that the\\n     * child must have the same working directory as its parent.\\n     *\\n     * @return  The absolute pathname string denoting the same file or\\n     *          directory as this abstract pathname\\n     *\\n     * @see     java.io.File#isAbsolute()\\n     \u0027}"}, {"color": "#97c2fc", "id": "public File getAbsoluteFile()", "label": "public File getAbsoluteFile()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the absolute form of this abstract pathname.  Equivalent to\\n     * \u003ccode\u003enew\u0026nbsp;File(this.{@link #getAbsolutePath})\u003c/code\u003e.\\n     *\\n     * @return  The absolute abstract pathname denoting the same file or\\n     *          directory as this abstract pathname\\n     *\\n     * @throws  SecurityException\\n     *          If a required system property value cannot be accessed.\\n     *\\n     * @since 1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "getAbsolutePath", "label": "getAbsolutePath", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public String getCanonicalPath() throws IOException", "label": "public String getCanonicalPath() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the canonical pathname string of this abstract pathname.\\n     *\\n     * \u003cp\u003e A canonical pathname is both absolute and unique.  The precise\\n     * definition of canonical form is system-dependent.  This method first\\n     * converts this pathname to absolute form if necessary, as if by invoking the\\n     * {@link #getAbsolutePath} method, and then maps it to its unique form in a\\n     * system-dependent way.  This typically involves removing redundant names\\n     * such as \u003ctt\u003e\".\"\u003c/tt\u003e and \u003ctt\u003e\"..\"\u003c/tt\u003e from the pathname, resolving\\n     * symbolic links (on UNIX platforms), and converting drive letters to a\\n     * standard case (on Microsoft Windows platforms).\\n     *\\n     * \u003cp\u003e Every pathname that denotes an existing file or directory has a\\n     * unique canonical form.  Every pathname that denotes a nonexistent file\\n     * or directory also has a unique canonical form.  The canonical form of\\n     * the pathname of a nonexistent file or directory may be different from\\n     * the canonical form of the same pathname after the file or directory is\\n     * created.  Similarly, the canonical form of the pathname of an existing\\n     * file or directory may be different from the canonical form of the same\\n     * pathname after the file or directory is deleted.\\n     *\\n     * @return  The canonical pathname string denoting the same file or\\n     *          directory as this abstract pathname\\n     *\\n     * @throws  IOException\\n     *          If an I/O error occurs, which is possible because the\\n     *          construction of the canonical pathname may require\\n     *          filesystem queries\\n     *\\n     * @throws  SecurityException\\n     *          If a required system property value cannot be accessed, or\\n     *          if a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkRead}\u003c/code\u003e method denies\\n     *          read access to the file\\n     *\\n     * @since   JDK1.1\\n     * @see     Path#toRealPath\\n     \u0027}"}, {"color": "#97c2fc", "id": "public File getCanonicalFile() throws IOException", "label": "public File getCanonicalFile() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the canonical form of this abstract pathname.  Equivalent to\\n     * \u003ccode\u003enew\u0026nbsp;File(this.{@link #getCanonicalPath})\u003c/code\u003e.\\n     *\\n     * @return  The canonical pathname string denoting the same file or\\n     *          directory as this abstract pathname\\n     *\\n     * @throws  IOException\\n     *          If an I/O error occurs, which is possible because the\\n     *          construction of the canonical pathname may require\\n     *          filesystem queries\\n     *\\n     * @throws  SecurityException\\n     *          If a required system property value cannot be accessed, or\\n     *          if a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkRead}\u003c/code\u003e method denies\\n     *          read access to the file\\n     *\\n     * @since 1.2\\n     * @see     Path#toRealPath\\n     \u0027}"}, {"color": "#97c2fc", "id": "getCanonicalPath", "label": "getCanonicalPath", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public URI toURI()", "label": "public URI toURI()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Constructs a \u003ctt\u003efile:\u003c/tt\u003e URI that represents this abstract pathname.\\n     *\\n     * \u003cp\u003e The exact form of the URI is system-dependent.  If it can be\\n     * determined that the file denoted by this abstract pathname is a\\n     * directory, then the resulting URI will end with a slash.\\n     *\\n     * \u003cp\u003e For a given abstract pathname \u003ci\u003ef\u003c/i\u003e, it is guaranteed that\\n     *\\n     * \u003cblockquote\u003e\u003ctt\u003e\\n     * new {@link #File(java.net.URI) File}(\u003c/tt\u003e\u003ci\u003e\u0026nbsp;f\u003c/i\u003e\u003ctt\u003e.toURI()).equals(\u003c/tt\u003e\u003ci\u003e\u0026nbsp;f\u003c/i\u003e\u003ctt\u003e.{@link #getAbsoluteFile() getAbsoluteFile}())\\n     * \u003c/tt\u003e\u003c/blockquote\u003e\\n     *\\n     * so long as the original abstract pathname, the URI, and the new abstract\\n     * pathname are all created in (possibly different invocations of) the same\\n     * Java virtual machine.  Due to the system-dependent nature of abstract\\n     * pathnames, however, this relationship typically does not hold when a\\n     * \u003ctt\u003efile:\u003c/tt\u003e URI that is created in a virtual machine on one operating\\n     * system is converted into an abstract pathname in a virtual machine on a\\n     * different operating system.\\n     *\\n     * \u003cp\u003e Note that when this abstract pathname represents a UNC pathname then\\n     * all components of the UNC (including the server name component) are encoded\\n     * in the {@code URI} path. The authority component is undefined, meaning\\n     * that it is represented as {@code null}. The {@link Path} class defines the\\n     * {@link Path#toUri toUri} method to encode the server name in the authority\\n     * component of the resulting {@code URI}. The {@link #toPath toPath} method\\n     * may be used to obtain a {@code Path} representing this abstract pathname.\\n     *\\n     * @return  An absolute, hierarchical URI with a scheme equal to\\n     *          \u003ctt\u003e\"file\"\u003c/tt\u003e, a path representing this abstract pathname,\\n     *          and undefined authority, query, and fragment components\\n     * @throws SecurityException If a required system property value cannot\\n     * be accessed.\\n     *\\n     * @see #File(java.net.URI)\\n     * @see java.net.URI\\n     * @see java.net.URI#toURL()\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "File(java.net.URI)", "label": "File(java.net.URI)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "getAbsoluteFile()", "label": "getAbsoluteFile()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.Path", "label": "java.nio.file.Path", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public static Path of(String first, String... more)", "label": "public static Path of(String first, String... more)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Path} by converting a path string, or a sequence of\\n     * strings that when joined form a path string. If {@code more} does not\\n     * specify any elements then the value of the {@code first} parameter is\\n     * the path string to convert. If {@code more} specifies one or more\\n     * elements then each non-empty string, including {@code first}, is\\n     * considered to be a sequence of name elements and is joined to form a\\n     * path string. The details as to how the Strings are joined is provider\\n     * specific but typically they will be joined using the\\n     * {@link FileSystem#getSeparator name-separator} as the separator.\\n     * For example, if the name separator is \"{@code /}\" and\\n     * {@code getPath(\"/foo\",\"bar\",\"gus\")} is invoked, then the path string\\n     * {@code \"/foo/bar/gus\"} is converted to a {@code Path}. A {@code Path}\\n     * representing an empty path is returned if {@code first} is the empty\\n     * string and {@code more} does not contain any non-empty strings.\\n     *\\n     * \u003cp\u003e The {@code Path} is obtained by invoking the {@link FileSystem#getPath\\n     * getPath} method of the {@link FileSystems#getDefault default} {@link\\n     * FileSystem}.\\n     *\\n     * \u003cp\u003e Note that while this method is very convenient, using it will imply\\n     * an assumed reference to the default {@code FileSystem} and limit the\\n     * utility of the calling code. Hence it should not be used in library code\\n     * intended for flexible reuse. A more flexible alternative is to use an\\n     * existing {@code Path} instance as an anchor, such as:\\n     * \u003cpre\u003e{@code\\n     *     Path dir = ...\\n     *     Path path = dir.resolve(\"file\");\\n     * }\u003c/pre\u003e\\n     *\\n     * @param   first\\n     *          the path string or initial part of the path string\\n     * @param   more\\n     *          additional strings to be joined to form the path string\\n     *\\n     * @return  the resulting {@code Path}\\n     *\\n     * @throws  InvalidPathException\\n     *          if the path string cannot be converted to a {@code Path}\\n     *\\n     * @see FileSystem#getPath\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "getDefault", "label": "getDefault", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.FileSystems", "label": "java.nio.file.FileSystems", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public static FileSystem getDefault()", "label": "public static FileSystem getDefault()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the default {@code FileSystem}. The default file system creates\\n     * objects that provide access to the file systems accessible to the Java\\n     * virtual machine. The \u003cem\u003eworking directory\u003c/em\u003e of the file system is\\n     * the current user directory, named by the system property {@code user.dir}.\\n     * This allows for interoperability with the {@link java.io.File java.io.File}\\n     * class.\\n     *\\n     * \u003cp\u003e The first invocation of any of the methods defined by this class\\n     * locates the default {@link FileSystemProvider provider} object. Where the\\n     * system property {@code java.nio.file.spi.DefaultFileSystemProvider} is\\n     * not defined then the default provider is a system-default provider that\\n     * is invoked to create the default file system.\\n     *\\n     * \u003cp\u003e If the system property {@code java.nio.file.spi.DefaultFileSystemProvider}\\n     * is defined then it is taken to be a list of one or more fully-qualified\\n     * names of concrete provider classes identified by the URI scheme\\n     * {@code \"file\"}. Where the property is a list of more than one name then\\n     * the names are separated by a comma. Each class is loaded, using the system\\n     * class loader, and instantiated by invoking a one argument constructor\\n     * whose formal parameter type is {@code FileSystemProvider}. The providers\\n     * are loaded and instantiated in the order they are listed in the property.\\n     * If this process fails or a provider\\\u0027s scheme is not equal to {@code \"file\"}\\n     * then an unspecified error is thrown. URI schemes are normally compared\\n     * without regard to case but for the default provider, the scheme is\\n     * required to be {@code \"file\"}. The first provider class is instantiated\\n     * by invoking it with a reference to the system-default provider.\\n     * The second provider class is instantiated by invoking it with a reference\\n     * to the first provider instance. The third provider class is instantiated\\n     * by invoking it with a reference to the second instance, and so on. The\\n     * last provider to be instantiated becomes the default provider; its {@code\\n     * getFileSystem} method is invoked with the URI {@code \"file:///\"} to\\n     * get a reference to the default file system.\\n     *\\n     * \u003cp\u003e Subsequent invocations of this method return the file system that was\\n     * returned by the first invocation.\\n     *\\n     * @return  the default file system\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.spi.FileSystemProvider", "label": "java.nio.file.spi.FileSystemProvider", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "private static List\u003cFileSystemProvider\u003e loadInstalledProviders()", "label": "private static List\u003cFileSystemProvider\u003e loadInstalledProviders()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 loads all installed providers\u0027}"}, {"color": "#97c2fc", "id": "public static List\u003cFileSystemProvider\u003e installedProviders()", "label": "public static List\u003cFileSystemProvider\u003e installedProviders()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a list of the installed file system providers.\\n     *\\n     * \u003cp\u003e The first invocation of this method causes the default provider to be\\n     * initialized (if not already initialized) and loads any other installed\\n     * providers as described by the {@link FileSystems} class.\\n     *\\n     * @return  An unmodifiable list of the installed file system providers. The\\n     *          list contains at least one element, that is the default file\\n     *          system provider\\n     *\\n     * @throws  ServiceConfigurationError\\n     *          When an error occurs while loading a service provider\\n     \u0027}"}, {"color": "#97c2fc", "id": "FileSystems", "label": "FileSystems", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public abstract String getScheme()", "label": "public abstract String getScheme()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the URI scheme that identifies this provider.\\n     *\\n     * @return  The URI scheme\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract FileSystem newFileSystem(URI uri, Map\u003cString, ?\u003e env) throws IOException", "label": "public abstract FileSystem newFileSystem(URI uri, Map\u003cString, ?\u003e env) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Constructs a new {@code FileSystem} object identified by a URI. This\\n     * method is invoked by the {@link FileSystems#newFileSystem(URI,Map)}\\n     * method to open a new file system identified by a URI.\\n     *\\n     * \u003cp\u003e The {@code uri} parameter is an absolute, hierarchical URI, with a\\n     * scheme equal (without regard to case) to the scheme supported by this\\n     * provider. The exact form of the URI is highly provider dependent. The\\n     * {@code env} parameter is a map of provider specific properties to configure\\n     * the file system.\\n     *\\n     * \u003cp\u003e This method throws {@link FileSystemAlreadyExistsException} if the\\n     * file system already exists because it was previously created by an\\n     * invocation of this method. Once a file system is {@link\\n     * java.nio.file.FileSystem#close closed} it is provider-dependent if the\\n     * provider allows a new file system to be created with the same URI as a\\n     * file system it previously created.\\n     *\\n     * @param   uri\\n     *          URI reference\\n     * @param   env\\n     *          A map of provider specific properties to configure the file system;\\n     *          may be empty\\n     *\\n     * @return  A new file system\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the pre-conditions for the {@code uri} parameter aren\u0027t met,\\n     *          or the {@code env} parameter does not contain properties required\\n     *          by the provider, or a property value is invalid\\n     * @throws  IOException\\n     *          An I/O error occurs creating the file system\\n     * @throws  SecurityException\\n     *          If a security manager is installed and it denies an unspecified\\n     *          permission required by the file system provider implementation\\n     * @throws  FileSystemAlreadyExistsException\\n     *          If the file system has already been created\\n     \"}"}, {"color": "#97c2fc", "id": "newFileSystem(URI", "label": "newFileSystem(URI", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.FileSystem", "label": "java.nio.file.FileSystem", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public abstract FileSystemProvider provider()", "label": "public abstract FileSystemProvider provider()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the provider that created this file system.\\n     *\\n     * @return  The provider that created this file system.\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.DirectoryStream", "label": "java.nio.file.DirectoryStream", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.WatchService", "label": "java.nio.file.WatchService", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": " void close() throws IOException", "label": " void close() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Closes this watch service.\\n     *\\n     * \u003cp\u003e If a thread is currently blocked in the {@link #take take} or {@link\\n     * #poll(long,TimeUnit) poll} methods waiting for a key to be queued then\\n     * it immediately receives a {@link ClosedWatchServiceException}. Any\\n     * valid keys associated with this watch service are {@link WatchKey#isValid\\n     * invalidated}.\\n     *\\n     * \u003cp\u003e After a watch service is closed, any further attempt to invoke\\n     * operations upon it will throw {@link ClosedWatchServiceException}.\\n     * If this watch service is already closed then invoking this method\\n     * has no effect.\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     \u0027}"}, {"color": "#97c2fc", "id": "poll(long", "label": "poll(long", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.ClosedWatchServiceException", "label": "java.nio.file.ClosedWatchServiceException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "isValidinvalidated", "label": "isValidinvalidated", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.WatchKey", "label": "java.nio.file.WatchKey", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": " boolean isValid()", "label": " boolean isValid()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this watch key is valid.\\n     *\\n     * \u003cp\u003e A watch key is valid upon creation and remains until it is cancelled,\\n     * or its watch service is closed.\\n     *\\n     * @return  {@code true} if, and only if, this watch key is valid\\n     \u0027}"}, {"color": "#97c2fc", "id": " List\u003cWatchEvent\u003c?\u003e\u003e pollEvents()", "label": " List\u003cWatchEvent\u003c?\u003e\u003e pollEvents()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Retrieves and removes all pending events for this watch key, returning\\n     * a {@code List} of the events that were retrieved.\\n     *\\n     * \u003cp\u003e Note that this method does not wait if there are no events pending.\\n     *\\n     * @return  the list of the events retrieved; may be empty\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean reset()", "label": " boolean reset()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Resets this watch key.\\n     *\\n     * \u003cp\u003e If this watch key has been cancelled or this watch key is already in\\n     * the ready state then invoking this method has no effect. Otherwise\\n     * if there are pending events for the object then this watch key is\\n     * immediately re-queued to the watch service. If there are no pending\\n     * events then the watch key is put into the ready state and will remain in\\n     * that state until an event is detected or the watch key is cancelled.\\n     *\\n     * @return  {@code true} if the watch key is valid and has been reset, and\\n     *          {@code false} if the watch key could not be reset because it is\\n     *          no longer {@link #isValid valid}\\n     \u0027}"}, {"color": "#97c2fc", "id": "isValid", "label": "isValid", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " void cancel()", "label": " void cancel()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Cancels the registration with the watch service. Upon return the watch key\\n     * will be invalid. If the watch key is enqueued, waiting to be retrieved\\n     * from the watch service, then it will remain in the queue until it is\\n     * removed. Pending events, if any, remain pending and may be retrieved by\\n     * invoking the {@link #pollEvents pollEvents} method after the key is\\n     * cancelled.\\n     *\\n     * \u003cp\u003e If this watch key has already been cancelled then invoking this\\n     * method has no effect.  Once cancelled, a watch key remains forever invalid.\\n     \u0027}"}, {"color": "#97c2fc", "id": "pollEvents", "label": "pollEvents", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " Watchable watchable()", "label": " Watchable watchable()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the object for which this watch key was created. This method will\\n     * continue to return the object even after the key is cancelled.\\n     *\\n     * \u003cp\u003e As the {@code WatchService} is intended to map directly on to the\\n     * native file event notification facility (where available) then many of\\n     * details on how registered objects are watched is highly implementation\\n     * specific. When watching a directory for changes for example, and the\\n     * directory is moved or renamed in the file system, there is no guarantee\\n     * that the watch key will be cancelled and so the object returned by this\\n     * method may no longer be a valid path to the directory.\\n     *\\n     * @return the object for which this watch key was created\\n     \u0027}"}, {"color": "#97c2fc", "id": "take", "label": "take", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " WatchKey poll()", "label": " WatchKey poll()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Retrieves and removes the next watch key, or {@code null} if none are\\n     * present.\\n     *\\n     * @return  the next watch key, or {@code null}\\n     *\\n     * @throws  ClosedWatchServiceException\\n     *          if this watch service is closed\\n     \u0027}"}, {"color": "#97c2fc", "id": " WatchKey poll(long timeout, TimeUnit unit) throws InterruptedException", "label": " WatchKey poll(long timeout, TimeUnit unit) throws InterruptedException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Retrieves and removes the next watch key, waiting if necessary up to the\\n     * specified wait time if none are yet present.\\n     *\\n     * @param   timeout\\n     *          how to wait before giving up, in units of unit\\n     * @param   unit\\n     *          a {@code TimeUnit} determining how to interpret the timeout\\n     *          parameter\\n     *\\n     * @return  the next watch key, or {@code null}\\n     *\\n     * @throws  ClosedWatchServiceException\\n     *          if this watch service is closed, or it is closed while waiting\\n     *          for the next key\\n     * @throws  InterruptedException\\n     *          if interrupted while waiting\\n     \u0027}"}, {"color": "#97c2fc", "id": " WatchKey take() throws InterruptedException", "label": " WatchKey take() throws InterruptedException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Retrieves and removes next watch key, waiting if none are yet present.\\n     *\\n     * @return  the next watch key\\n     *\\n     * @throws  ClosedWatchServiceException\\n     *          if this watch service is closed, or it is closed while waiting\\n     *          for the next key\\n     * @throws  InterruptedException\\n     *          if interrupted while waiting\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.ClosedFileSystemException", "label": "java.nio.file.ClosedFileSystemException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public abstract String getSeparator()", "label": "public abstract String getSeparator()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the name separator, represented as a string.\\n     *\\n     * \u003cp\u003e The name separator is used to separate names in a path string. An\\n     * implementation may support multiple name separators in which case this\\n     * method returns an implementation specific \u003cem\u003edefault\u003c/em\u003e name separator.\\n     * This separator is used when creating path strings by invoking the {@link\\n     * Path#toString() toString()} method.\\n     *\\n     * \u003cp\u003e In the case of the default provider, this method returns the same\\n     * separator as {@link java.io.File#separator}.\\n     *\\n     * @return  The name separator\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract Iterable\u003cPath\u003e getRootDirectories()", "label": "public abstract Iterable\u003cPath\u003e getRootDirectories()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an object to iterate over the paths of the root directories.\\n     *\\n     * \u003cp\u003e A file system provides access to a file store that may be composed\\n     * of a number of distinct file hierarchies, each with its own top-level\\n     * root directory. Unless denied by the security manager, each element in\\n     * the returned iterator corresponds to the root directory of a distinct\\n     * file hierarchy. The order of the elements is not defined. The file\\n     * hierarchies may change during the lifetime of the Java virtual machine.\\n     * For example, in some implementations, the insertion of removable media\\n     * may result in the creation of a new file hierarchy with its own\\n     * top-level directory.\\n     *\\n     * \u003cp\u003e When a security manager is installed, it is invoked to check access\\n     * to the each root directory. If denied, the root directory is not returned\\n     * by the iterator. In the case of the default provider, the {@link\\n     * SecurityManager#checkRead(String)} method is invoked to check read access\\n     * to each root directory. It is system dependent if the permission checks\\n     * are done when the iterator is obtained or during iteration.\\n     *\\n     * @return  An object to iterate over the root directories\\n     \u0027}"}, {"color": "#97c2fc", "id": "checkRead(String)", "label": "checkRead(String)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract Iterable\u003cFileStore\u003e getFileStores()", "label": "public abstract Iterable\u003cFileStore\u003e getFileStores()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an object to iterate over the underlying file stores.\\n     *\\n     * \u003cp\u003e The elements of the returned iterator are the {@link\\n     * FileStore FileStores} for this file system. The order of the elements is\\n     * not defined and the file stores may change during the lifetime of the\\n     * Java virtual machine. When an I/O error occurs, perhaps because a file\\n     * store is not accessible, then it is not returned by the iterator.\\n     *\\n     * \u003cp\u003e In the case of the default provider, and a security manager is\\n     * installed, the security manager is invoked to check {@link\\n     * RuntimePermission}{@code (\"getFileStoreAttributes\")}. If denied, then\\n     * no file stores are returned by the iterator. In addition, the security\\n     * manager\\\u0027s {@link SecurityManager#checkRead(String)} method is invoked to\\n     * check read access to the file store\\\u0027s \u003cem\u003etop-most\u003c/em\u003e directory. If\\n     * denied, the file store is not returned by the iterator. It is system\\n     * dependent if the permission checks are done when the iterator is obtained\\n     * or during iteration.\\n     *\\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\\n     * Suppose we want to print the space usage for all file stores:\\n     * \u003cpre\u003e\\n     *     for (FileStore store: FileSystems.getDefault().getFileStores()) {\\n     *         long total = store.getTotalSpace() / 1024;\\n     *         long used = (store.getTotalSpace() - store.getUnallocatedSpace()) / 1024;\\n     *         long avail = store.getUsableSpace() / 1024;\\n     *         System.out.format(\"%-20s %12d %12d %12d%n\", store, total, used, avail);\\n     *     }\\n     * \u003c/pre\u003e\\n     *\\n     * @return  An object to iterate over the backing file stores\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.FileStore", "label": "java.nio.file.FileStore", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public abstract String name()", "label": "public abstract String name()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the name of this file store. The format of the name is highly\\n     * implementation specific. It will typically be the name of the storage\\n     * pool or volume.\\n     *\\n     * \u003cp\u003e The string returned by this method may differ from the string\\n     * returned by the {@link Object#toString() toString} method.\\n     *\\n     * @return  the name of this file store\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract String type()", "label": "public abstract String type()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the \u003cem\u003etype\u003c/em\u003e of this file store. The format of the string\\n     * returned by this method is highly implementation specific. It may\\n     * indicate, for example, the format used or if the file store is local\\n     * or remote.\\n     *\\n     * @return  a string representing the type of this file store\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract long getTotalSpace() throws IOException", "label": "public abstract long getTotalSpace() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the size, in bytes, of the file store.\\n     *\\n     * @return  the size of the file store, in bytes\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract long getUsableSpace() throws IOException", "label": "public abstract long getUsableSpace() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the number of bytes available to this Java virtual machine on the\\n     * file store.\\n     *\\n     * \u003cp\u003e The returned number of available bytes is a hint, but not a\\n     * guarantee, that it is possible to use most or any of these bytes.  The\\n     * number of usable bytes is most likely to be accurate immediately\\n     * after the space attributes are obtained. It is likely to be made inaccurate\\n     * by any external I/O operations including those made on the system outside\\n     * of this Java virtual machine.\\n     *\\n     * @return  the number of bytes available\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     \u0027}"}, {"color": "#97c2fc", "id": "public long getBlockSize() throws IOException", "label": "public long getBlockSize() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the number of bytes per block in this file store.\\n     *\\n     * \u003cp\u003e File storage is typically organized into discrete sequences of bytes\\n     * called \u003ci\u003eblocks\u003c/i\u003e. A block is the smallest storage unit of a file store.\\n     * Every read and write operation is performed on a multiple of blocks.\\n     *\\n     * @implSpec The implementation in this class throws an\\n     *         {@code UnsupportedOperationException}.\\n     *\\n     * @return  a positive value representing the block size of this file store,\\n     *          in bytes\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if the operation is not supported\\n     *\\n     * @since 10\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract long getUnallocatedSpace() throws IOException", "label": "public abstract long getUnallocatedSpace() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the number of unallocated bytes in the file store.\\n     *\\n     * \u003cp\u003e The returned number of unallocated bytes is a hint, but not a\\n     * guarantee, that it is possible to use most or any of these bytes.  The\\n     * number of unallocated bytes is most likely to be accurate immediately\\n     * after the space attributes are obtained. It is likely to be\\n     * made inaccurate by any external I/O operations including those made on\\n     * the system outside of this virtual machine.\\n     *\\n     * @return  the number of unallocated bytes\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract boolean supportsFileAttributeView(Class\u003c? extends FileAttributeView\u003e type)", "label": "public abstract boolean supportsFileAttributeView(Class\u003c? extends FileAttributeView\u003e type)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this file store supports the file attributes\\n     * identified by the given file attribute view.\\n     *\\n     * \u003cp\u003e Invoking this method to test if the file store supports {@link\\n     * BasicFileAttributeView} will always return {@code true}. In the case of\\n     * the default provider, this method cannot guarantee to give the correct\\n     * result when the file store is not a local storage device. The reasons for\\n     * this are implementation specific and therefore unspecified.\\n     *\\n     * @param   type\\n     *          the file attribute view type\\n     *\\n     * @return  {@code true} if, and only if, the file attribute view is\\n     *          supported\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.BasicFileAttributeView", "label": "java.nio.file.BasicFileAttributeView", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public abstract boolean supportsFileAttributeView(String name)", "label": "public abstract boolean supportsFileAttributeView(String name)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this file store supports the file attributes\\n     * identified by the given file attribute view.\\n     *\\n     * \u003cp\u003e Invoking this method to test if the file store supports {@link\\n     * BasicFileAttributeView}, identified by the name \"{@code basic}\" will\\n     * always return {@code true}. In the case of the default provider, this\\n     * method cannot guarantee to give the correct result when the file store is\\n     * not a local storage device. The reasons for this are implementation\\n     * specific and therefore unspecified.\\n     *\\n     * @param   name\\n     *          the {@link FileAttributeView#name name} of file attribute view\\n     *\\n     * @return  {@code true} if, and only if, the file attribute view is\\n     *          supported\\n     \u0027}"}, {"color": "#97c2fc", "id": "name", "label": "name", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract V getFileStoreAttributeView(Class\u003cV\u003e type)", "label": "public abstract V getFileStoreAttributeView(Class\u003cV\u003e type)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code FileStoreAttributeView} of the given type.\\n     *\\n     * \u003cp\u003e This method is intended to be used where the file store attribute\\n     * view defines type-safe methods to read or update the file store attributes.\\n     * The {@code type} parameter is the type of the attribute view required and\\n     * the method returns an instance of that type if supported.\\n     *\\n     * @param   \u003cV\u003e\\n     *          The {@code FileStoreAttributeView} type\\n     * @param   type\\n     *          the {@code Class} object corresponding to the attribute view\\n     *\\n     * @return  a file store attribute view of the specified type or\\n     *          {@code null} if the attribute view is not available\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract Object getAttribute(String attribute) throws IOException", "label": "public abstract Object getAttribute(String attribute) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads the value of a file store attribute.\\n     *\\n     * \u003cp\u003e The {@code attribute} parameter identifies the attribute to be read\\n     * and takes the form:\\n     * \u003cblockquote\u003e\\n     * \u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e\u003ci\u003eattribute-name\u003c/i\u003e\\n     * \u003c/blockquote\u003e\\n     * where the character {@code \\\u0027:\\\u0027} stands for itself.\\n     *\\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileStoreAttributeView#name name} of\\n     * a {@link FileStore AttributeView} that identifies a set of file attributes.\\n     * \u003ci\u003eattribute-name\u003c/i\u003e is the name of the attribute.\\n     *\\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\\n     * Suppose we want to know if ZFS compression is enabled (assuming the \"zfs\"\\n     * view is supported):\\n     * \u003cpre\u003e\\n     *    boolean compression = (Boolean)fs.getAttribute(\"zfs:compression\");\\n     * \u003c/pre\u003e\\n     *\\n     * @param   attribute\\n     *          the attribute to read\\n\\n     * @return  the attribute value; {@code null} may be valid for some\\n     *          attributes\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if the attribute view is not available or it does not support\\n     *          reading the attribute\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract Set\u003cString\u003e supportedFileAttributeViews()", "label": "public abstract Set\u003cString\u003e supportedFileAttributeViews()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the set of the {@link FileAttributeView#name names} of the file\\n     * attribute views supported by this {@code FileSystem}.\\n     *\\n     * \u003cp\u003e The {@link BasicFileAttributeView} is required to be supported and\\n     * therefore the set contains at least one element, \"basic\".\\n     *\\n     * \u003cp\u003e The {@link FileStore#supportsFileAttributeView(String)\\n     * supportsFileAttributeView(String)} method may be used to test if an\\n     * underlying {@link FileStore} supports the file attributes identified by a\\n     * file attribute view.\\n     *\\n     * @return  An unmodifiable set of the names of the supported file attribute\\n     *          views\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract Path getPath(String first, String... more)", "label": "public abstract Path getPath(String first, String... more)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Converts a path string, or a sequence of strings that when joined form\\n     * a path string, to a {@code Path}. If {@code more} does not specify any\\n     * elements then the value of the {@code first} parameter is the path string\\n     * to convert. If {@code more} specifies one or more elements then each\\n     * non-empty string, including {@code first}, is considered to be a sequence\\n     * of name elements (see {@link Path}) and is joined to form a path string.\\n     * The details as to how the Strings are joined is provider specific but\\n     * typically they will be joined using the {@link #getSeparator\\n     * name-separator} as the separator. For example, if the name separator is\\n     * \"{@code /}\" and {@code getPath(\"/foo\",\"bar\",\"gus\")} is invoked, then the\\n     * path string {@code \"/foo/bar/gus\"} is converted to a {@code Path}.\\n     * A {@code Path} representing an empty path is returned if {@code first}\\n     * is the empty string and {@code more} does not contain any non-empty\\n     * strings.\\n     *\\n     * \u003cp\u003e The parsing and conversion to a path object is inherently\\n     * implementation dependent. In the simplest case, the path string is rejected,\\n     * and {@link InvalidPathException} thrown, if the path string contains\\n     * characters that cannot be converted to characters that are \u003cem\u003elegal\u003c/em\u003e\\n     * to the file store. For example, on UNIX systems, the NUL (\u0026#92;u0000)\\n     * character is not allowed to be present in a path. An implementation may\\n     * choose to reject path strings that contain names that are longer than those\\n     * allowed by any file store, and where an implementation supports a complex\\n     * path syntax, it may choose to reject path strings that are \u003cem\u003ebadly\\n     * formed\u003c/em\u003e.\\n     *\\n     * \u003cp\u003e In the case of the default provider, path strings are parsed based\\n     * on the definition of paths at the platform or virtual file system level.\\n     * For example, an operating system may not allow specific characters to be\\n     * present in a file name, but a specific underlying file store may impose\\n     * different or additional restrictions on the set of legal\\n     * characters.\\n     *\\n     * \u003cp\u003e This method throws {@link InvalidPathException} when the path string\\n     * cannot be converted to a path. Where possible, and where applicable,\\n     * the exception is created with an {@link InvalidPathException#getIndex\\n     * index} value indicating the first position in the {@code path} parameter\\n     * that caused the path string to be rejected.\\n     *\\n     * @param   first\\n     *          the path string or initial part of the path string\\n     * @param   more\\n     *          additional strings to be joined to form the path string\\n     *\\n     * @return  the resulting {@code Path}\\n     *\\n     * @throws  InvalidPathException\\n     *          If the path string cannot be converted\\n     \u0027}"}, {"color": "#97c2fc", "id": "getSeparatorname", "label": "getSeparatorname", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.InvalidPathException", "label": "java.nio.file.InvalidPathException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public String getInput()", "label": "public String getInput()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the input string.\\n     *\\n     * @return  The input string\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getReason()", "label": "public String getReason()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a string explaining why the input string could not be parsed.\\n     *\\n     * @return  The reason string\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getIndex()", "label": "public int getIndex()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an index into the input string of the position at which the\\n     * parse error occurred, or {@code -1} if this position is not known.\\n     *\\n     * @return  The error index\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract PathMatcher getPathMatcher(String syntaxAndPattern)", "label": "public abstract PathMatcher getPathMatcher(String syntaxAndPattern)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code PathMatcher} that performs match operations on the\\n     * {@code String} representation of {@link Path} objects by interpreting a\\n     * given pattern.\\n     *\\n     * The {@code syntaxAndPattern} parameter identifies the syntax and the\\n     * pattern and takes the form:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * \u003ci\u003esyntax\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e\u003ci\u003epattern\u003c/i\u003e\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * where {@code \\\u0027:\\\u0027} stands for itself.\\n     *\\n     * \u003cp\u003e A {@code FileSystem} implementation supports the \"{@code glob}\" and\\n     * \"{@code regex}\" syntaxes, and may support others. The value of the syntax\\n     * component is compared without regard to case.\\n     *\\n     * \u003cp\u003e When the syntax is \"{@code glob}\" then the {@code String}\\n     * representation of the path is matched using a limited pattern language\\n     * that resembles regular expressions but with a simpler syntax. For example:\\n     *\\n     * \u003ctable class=\"striped\" style=\"text-align:left; margin-left:2em\"\u003e\\n     * \u003ccaption style=\"display:none\"\u003ePattern Language\u003c/caption\u003e\\n     * \u003cthead\u003e\\n     * \u003ctr\u003e\\n     *   \u003cth scope=\"col\"\u003eExample\\n     *   \u003cth scope=\"col\"\u003eDescription\\n     * \u003c/tr\u003e\\n     * \u003c/thead\u003e\\n     * \u003ctbody\u003e\\n     * \u003ctr\u003e\\n     *   \u003cth scope=\"row\"\u003e{@code *.java}\u003c/th\u003e\\n     *   \u003ctd\u003eMatches a path that represents a file name ending in {@code .java}\u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003cth scope=\"row\"\u003e{@code *.*}\u003c/th\u003e\\n     *   \u003ctd\u003eMatches file names containing a dot\u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003cth scope=\"row\"\u003e{@code *.{java,class}}\u003c/th\u003e\\n     *   \u003ctd\u003eMatches file names ending with {@code .java} or {@code .class}\u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003cth scope=\"row\"\u003e{@code foo.?}\u003c/th\u003e\\n     *   \u003ctd\u003eMatches file names starting with {@code foo.} and a single\\n     *   character extension\u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003cth scope=\"row\"\u003e\u003ccode\u003e\u0026#47;home\u0026#47;*\u0026#47;*\u003c/code\u003e\\n     *   \u003ctd\u003eMatches \u003ccode\u003e\u0026#47;home\u0026#47;gus\u0026#47;data\u003c/code\u003e\u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003cth scope=\"row\"\u003e\u003ccode\u003e\u0026#47;home\u0026#47;**\u003c/code\u003e\\n     *   \u003ctd\u003eMatches \u003ccode\u003e\u0026#47;home\u0026#47;gus\u003c/code\u003e and\\n     *   \u003ccode\u003e\u0026#47;home\u0026#47;gus\u0026#47;data\u003c/code\u003e\u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003c/tbody\u003e\\n     * \u003c/table\u003e\\n     *\\n     * \u003cp\u003e The following rules are used to interpret glob patterns:\\n     *\\n     * \u003cul\u003e\\n     *   \u003cli\u003e\u003cp\u003e The {@code *} character matches zero or more {@link Character\\n     *   characters} of a {@link Path#getName(int) name} component without\\n     *   crossing directory boundaries. \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e The {@code **} characters matches zero or more {@link Character\\n     *   characters} crossing directory boundaries. \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e The {@code ?} character matches exactly one character of a\\n     *   name component.\u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e The backslash character ({@code \\\\}) is used to escape characters\\n     *   that would otherwise be interpreted as special characters. The expression\\n     *   {@code \\\\\\\\} matches a single backslash and \"\\\\{\" matches a left brace\\n     *   for example.  \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e The {@code [ ]} characters are a \u003ci\u003ebracket expression\u003c/i\u003e that\\n     *   match a single character of a name component out of a set of characters.\\n     *   For example, {@code [abc]} matches {@code \"a\"}, {@code \"b\"}, or {@code \"c\"}.\\n     *   The hyphen ({@code -}) may be used to specify a range so {@code [a-z]}\\n     *   specifies a range that matches from {@code \"a\"} to {@code \"z\"} (inclusive).\\n     *   These forms can be mixed so [abce-g] matches {@code \"a\"}, {@code \"b\"},\\n     *   {@code \"c\"}, {@code \"e\"}, {@code \"f\"} or {@code \"g\"}. If the character\\n     *   after the {@code [} is a {@code !} then it is used for negation so {@code\\n     *   [!a-c]} matches any character except {@code \"a\"}, {@code \"b\"}, or {@code\\n     *   \"c\"}.\\n     *   \u003cp\u003e Within a bracket expression the {@code *}, {@code ?} and {@code \\\\}\\n     *   characters match themselves. The ({@code -}) character matches itself if\\n     *   it is the first character within the brackets, or the first character\\n     *   after the {@code !} if negating.\u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e The {@code { }} characters are a group of subpatterns, where\\n     *   the group matches if any subpattern in the group matches. The {@code \",\"}\\n     *   character is used to separate the subpatterns. Groups cannot be nested.\\n     *   \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e Leading period\u003ccode\u003e\u0026#47;\u003c/code\u003edot characters in file name are\\n     *   treated as regular characters in match operations. For example,\\n     *   the {@code \"*\"} glob pattern matches file name {@code \".login\"}.\\n     *   The {@link Files#isHidden} method may be used to test whether a file\\n     *   is considered hidden.\\n     *   \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e All other characters match themselves in an implementation\\n     *   dependent manner. This includes characters representing any {@link\\n     *   FileSystem#getSeparator name-separators}. \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e The matching of {@link Path#getRoot root} components is highly\\n     *   implementation-dependent and is not specified. \u003c/p\u003e\u003c/li\u003e\\n     *\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003e When the syntax is \"{@code regex}\" then the pattern component is a\\n     * regular expression as defined by the {@link java.util.regex.Pattern}\\n     * class.\\n     *\\n     * \u003cp\u003e  For both the glob and regex syntaxes, the matching details, such as\\n     * whether the matching is case sensitive, are implementation-dependent\\n     * and therefore not specified.\\n     *\\n     * @param   syntaxAndPattern\\n     *          The syntax and pattern\\n     *\\n     * @return  A path matcher that may be used to match paths against the pattern\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the parameter does not take the form: {@code syntax:pattern}\\n     * @throws  java.util.regex.PatternSyntaxException\\n     *          If the pattern is invalid\\n     * @throws  UnsupportedOperationException\\n     *          If the pattern syntax is not known to the implementation\\n     *\\n     * @see Files#newDirectoryStream(Path,String)\\n     \u0027}"}, {"color": "#97c2fc", "id": "isHidden", "label": "isHidden", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.Files", "label": "java.nio.file.Files", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "private static FileSystemProvider provider(Path path)", "label": "private static FileSystemProvider provider(Path path)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the {@code FileSystemProvider} to delegate to.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static Runnable asUncheckedRunnable(Closeable c)", "label": "private static Runnable asUncheckedRunnable(Closeable c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Convert a Closeable to a Runnable by converting checked IOException\\n     * to UncheckedIOException\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static InputStream newInputStream(Path path, OpenOption... options) throws IOException", "label": "public static InputStream newInputStream(Path path, OpenOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens a file, returning an input stream to read from the file. The stream\\n     * will not be buffered, and is not required to support the {@link\\n     * InputStream#mark mark} or {@link InputStream#reset reset} methods. The\\n     * stream will be safe for access by multiple concurrent threads. Reading\\n     * commences at the beginning of the file. Whether the returned stream is\\n     * \u003ci\u003easynchronously closeable\u003c/i\u003e and/or \u003ci\u003einterruptible\u003c/i\u003e is highly\\n     * file system provider specific and therefore not specified.\\n     *\\n     * \u003cp\u003e The {@code options} parameter determines how the file is opened.\\n     * If no options are present then it is equivalent to opening the file with\\n     * the {@link StandardOpenOption#READ READ} option. In addition to the {@code\\n     * READ} option, an implementation may also support additional implementation\\n     * specific options.\\n     *\\n     * @param   path\\n     *          the path to the file to open\\n     * @param   options\\n     *          options specifying how the file is opened\\n     *\\n     * @return  a new input stream\\n     *\\n     * @throws  IllegalArgumentException\\n     *          if an invalid combination of options is specified\\n     * @throws  UnsupportedOperationException\\n     *          if an unsupported option is specified\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "READ", "label": "READ", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static OutputStream newOutputStream(Path path, OpenOption... options) throws IOException", "label": "public static OutputStream newOutputStream(Path path, OpenOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Opens or creates a file, returning an output stream that may be used to\\n     * write bytes to the file. The resulting stream will not be buffered. The\\n     * stream will be safe for access by multiple concurrent threads. Whether\\n     * the returned stream is \u003ci\u003easynchronously closeable\u003c/i\u003e and/or\\n     * \u003ci\u003einterruptible\u003c/i\u003e is highly file system provider specific and\\n     * therefore not specified.\\n     *\\n     * \u003cp\u003e This method opens or creates a file in exactly the manner specified\\n     * by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}\\n     * method with the exception that the {@link StandardOpenOption#READ READ}\\n     * option may not be present in the array of options. If no options are\\n     * present then this method works as if the {@link StandardOpenOption#CREATE\\n     * CREATE}, {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING},\\n     * and {@link StandardOpenOption#WRITE WRITE} options are present. In other\\n     * words, it opens the file for writing, creating the file if it doesn\u0027t\\n     * exist, or initially truncating an existing {@link #isRegularFile\\n     * regular-file} to a size of {@code 0} if it exists.\\n     *\\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\\n     * \u003cpre\u003e\\n     *     Path path = ...\\n     *\\n     *     // truncate and overwrite an existing file, or create the file if\\n     *     // it doesn\u0027t initially exist\\n     *     OutputStream out = Files.newOutputStream(path);\\n     *\\n     *     // append to an existing file, fail if the file does not exist\\n     *     out = Files.newOutputStream(path, APPEND);\\n     *\\n     *     // append to an existing file, create file if it doesn\u0027t initially exist\\n     *     out = Files.newOutputStream(path, CREATE, APPEND);\\n     *\\n     *     // always create new file, failing if it already exists\\n     *     out = Files.newOutputStream(path, CREATE_NEW);\\n     * \u003c/pre\u003e\\n     *\\n     * @param   path\\n     *          the path to the file to open or create\\n     * @param   options\\n     *          options specifying how the file is opened\\n     *\\n     * @return  a new output stream\\n     *\\n     * @throws  IllegalArgumentException\\n     *          if {@code options} contains an invalid combination of options\\n     * @throws  UnsupportedOperationException\\n     *          if an unsupported option is specified\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method is invoked to check write access to the file. The {@link\\n     *          SecurityManager#checkDelete(String) checkDelete} method is\\n     *          invoked to check delete access if the file is opened with the\\n     *          {@code DELETE_ON_CLOSE} option.\\n     \"}"}, {"color": "#97c2fc", "id": "newByteChannel(Path", "label": "newByteChannel(Path", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "WRITE", "label": "WRITE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "CREATECREATE", "label": "CREATECREATE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "checkDelete(String)", "label": "checkDelete(String)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "TRUNCATE_EXISTING", "label": "TRUNCATE_EXISTING", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "isRegularFileregular", "label": "isRegularFileregular", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "checkWrite(String)", "label": "checkWrite(String)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "label": "public static SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens or creates a file, returning a seekable byte channel to access the\\n     * file.\\n     *\\n     * \u003cp\u003e The {@code options} parameter determines how the file is opened.\\n     * The {@link StandardOpenOption#READ READ} and {@link\\n     * StandardOpenOption#WRITE WRITE} options determine if the file should be\\n     * opened for reading and/or writing. If neither option (or the {@link\\n     * StandardOpenOption#APPEND APPEND} option) is present then the file is\\n     * opened for reading. By default reading or writing commence at the\\n     * beginning of the file.\\n     *\\n     * \u003cp\u003e In the addition to {@code READ} and {@code WRITE}, the following\\n     * options may be present:\\n     *\\n     * \u003ctable border=1 cellpadding=5 summary=\"Options\"\u003e\\n     * \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e {@link StandardOpenOption#APPEND APPEND} \u003c/td\u003e\\n     *   \u003ctd\u003e If this option is present then the file is opened for writing and\\n     *     each invocation of the channel\\\u0027s {@code write} method first advances\\n     *     the position to the end of the file and then writes the requested\\n     *     data. Whether the advancement of the position and the writing of the\\n     *     data are done in a single atomic operation is system-dependent and\\n     *     therefore unspecified. This option may not be used in conjunction\\n     *     with the {@code READ} or {@code TRUNCATE_EXISTING} options. \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} \u003c/td\u003e\\n     *   \u003ctd\u003e If this option is present then the existing file is truncated to\\n     *   a size of 0 bytes. This option is ignored when the file is opened only\\n     *   for reading. \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e {@link StandardOpenOption#CREATE_NEW CREATE_NEW} \u003c/td\u003e\\n     *   \u003ctd\u003e If this option is present then a new file is created, failing if\\n     *   the file already exists or is a symbolic link. When creating a file the\\n     *   check for the existence of the file and the creation of the file if it\\n     *   does not exist is atomic with respect to other file system operations.\\n     *   This option is ignored when the file is opened only for reading. \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd \u003e {@link StandardOpenOption#CREATE CREATE} \u003c/td\u003e\\n     *   \u003ctd\u003e If this option is present then an existing file is opened if it\\n     *   exists, otherwise a new file is created. This option is ignored if the\\n     *   {@code CREATE_NEW} option is also present or the file is opened only\\n     *   for reading. \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd \u003e {@link StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} \u003c/td\u003e\\n     *   \u003ctd\u003e When this option is present then the implementation makes a\\n     *   \u003cem\u003ebest effort\u003c/em\u003e attempt to delete the file when closed by the\\n     *   {@link SeekableByteChannel#close close} method. If the {@code close}\\n     *   method is not invoked then a \u003cem\u003ebest effort\u003c/em\u003e attempt is made to\\n     *   delete the file when the Java virtual machine terminates. \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e{@link StandardOpenOption#SPARSE SPARSE} \u003c/td\u003e\\n     *   \u003ctd\u003e When creating a new file this option is a \u003cem\u003ehint\u003c/em\u003e that the\\n     *   new file will be sparse. This option is ignored when not creating\\n     *   a new file. \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e {@link StandardOpenOption#SYNC SYNC} \u003c/td\u003e\\n     *   \u003ctd\u003e Requires that every update to the file\\\u0027s content or metadata be\\n     *   written synchronously to the underlying storage device. (see \u003ca\\n     *   href=\"package-summary.html#integrity\"\u003e Synchronized I/O file\\n     *   integrity\u003c/a\u003e). \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e {@link StandardOpenOption#DSYNC DSYNC} \u003c/td\u003e\\n     *   \u003ctd\u003e Requires that every update to the file\\\u0027s content be written\\n     *   synchronously to the underlying storage device. (see \u003ca\\n     *   href=\"package-summary.html#integrity\"\u003e Synchronized I/O file\\n     *   integrity\u003c/a\u003e). \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003c/table\u003e\\n     *\\n     * \u003cp\u003e An implementation may also support additional implementation specific\\n     * options.\\n     *\\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\\n     * file-attributes} to set atomically when a new file is created.\\n     *\\n     * \u003cp\u003e In the case of the default provider, the returned seekable byte channel\\n     * is a {@link java.nio.channels.FileChannel}.\\n     *\\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\\n     * \u003cpre\u003e\\n     *     Path path = ...\\n     *\\n     *     // open file for reading\\n     *     ReadableByteChannel rbc = Files.newByteChannel(path, EnumSet.of(READ)));\\n     *\\n     *     // open file for writing to the end of an existing file, creating\\n     *     // the file if it doesn\\\u0027t already exist\\n     *     WritableByteChannel wbc = Files.newByteChannel(path, EnumSet.of(CREATE,APPEND));\\n     *\\n     *     // create file with initial permissions, opening it for both reading and writing\\n     *     {@code FileAttribute\u003cSet\u003cPosixFilePermission\u003e\u003e perms = ...}\\n     *     SeekableByteChannel sbc = Files.newByteChannel(path, EnumSet.of(CREATE_NEW,READ,WRITE), perms);\\n     * \u003c/pre\u003e\\n     *\\n     * @param   path\\n     *          the path to the file to open or create\\n     * @param   options\\n     *          options specifying how the file is opened\\n     * @param   attrs\\n     *          an optional list of file attributes to set atomically when\\n     *          creating the file\\n     *\\n     * @return  a new seekable byte channel\\n     *\\n     * @throws  IllegalArgumentException\\n     *          if the set contains an invalid combination of options\\n     * @throws  UnsupportedOperationException\\n     *          if an unsupported open option is specified or the array contains\\n     *          attributes that cannot be set atomically when creating the file\\n     * @throws  FileAlreadyExistsException\\n     *          if a file of that name already exists and the {@link\\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the path if the file is\\n     *          opened for reading. The {@link SecurityManager#checkWrite(String)\\n     *          checkWrite} method is invoked to check write access to the path\\n     *          if the file is opened for writing. The {@link\\n     *          SecurityManager#checkDelete(String) checkDelete} method is\\n     *          invoked to check delete access if the file is opened with the\\n     *          {@code DELETE_ON_CLOSE} option.\\n     *\\n     * @see java.nio.channels.FileChannel#open(Path,Set,FileAttribute[])\\n     \u0027}"}, {"color": "#97c2fc", "id": "SPARSE", "label": "SPARSE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "SYNC", "label": "SYNC", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "DSYNC", "label": "DSYNC", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "CREATE", "label": "CREATE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "APPEND", "label": "APPEND", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "DELETE_ON_CLOSE", "label": "DELETE_ON_CLOSE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.channels.SeekableByteChannel", "label": "java.nio.channels.SeekableByteChannel", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": " int read(ByteBuffer dst) throws IOException", "label": " int read(ByteBuffer dst) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reads a sequence of bytes from this channel into the given buffer.\\n     *\\n     * \u003cp\u003e Bytes are read starting at this channel\u0027s current position, and\\n     * then the position is updated with the number of bytes actually read.\\n     * Otherwise this method behaves exactly as specified in the {@link\\n     * ReadableByteChannel} interface.\\n     \"}"}, {"color": "#97c2fc", "id": " int write(ByteBuffer src) throws IOException", "label": " int write(ByteBuffer src) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Writes a sequence of bytes to this channel from the given buffer.\\n     *\\n     * \u003cp\u003e Bytes are written starting at this channel\u0027s current position, unless\\n     * the channel is connected to an entity such as a file that is opened with\\n     * the {@link java.nio.file.StandardOpenOption#APPEND APPEND} option, in\\n     * which case the position is first advanced to the end. The entity to which\\n     * the channel is connected is grown, if necessary, to accommodate the\\n     * written bytes, and then the position is updated with the number of bytes\\n     * actually written. Otherwise this method behaves exactly as specified by\\n     * the {@link WritableByteChannel} interface.\\n     \"}"}, {"color": "#97c2fc", "id": " long position() throws IOException", "label": " long position() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns this channel\u0027s position.\\n     *\\n     * @return  This channel\u0027s position,\\n     *          a non-negative integer counting the number of bytes\\n     *          from the beginning of the entity to the current position\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": " SeekableByteChannel position(long newPosition) throws IOException", "label": " SeekableByteChannel position(long newPosition) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Sets this channel\u0027s position.\\n     *\\n     * \u003cp\u003e Setting the position to a value that is greater than the current size\\n     * is legal but does not change the size of the entity.  A later attempt to\\n     * read bytes at such a position will immediately return an end-of-file\\n     * indication.  A later attempt to write bytes at such a position will cause\\n     * the entity to grow to accommodate the new bytes; the values of any bytes\\n     * between the previous end-of-file and the newly-written bytes are\\n     * unspecified.\\n     *\\n     * \u003cp\u003e Setting the channel\u0027s position is not recommended when connected to\\n     * an entity, typically a file, that is opened with the {@link\\n     * java.nio.file.StandardOpenOption#APPEND APPEND} option. When opened for\\n     * append, the position is first advanced to the end before writing.\\n     *\\n     * @param  newPosition\\n     *         The new position, a non-negative integer counting\\n     *         the number of bytes from the beginning of the entity\\n     *\\n     * @return  This channel\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     * @throws  IllegalArgumentException\\n     *          If the new position is negative\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": " long size() throws IOException", "label": " long size() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the current size of entity to which this channel is connected.\\n     *\\n     * @return  The current size, measured in bytes\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \u0027}"}, {"color": "#97c2fc", "id": " SeekableByteChannel truncate(long size) throws IOException", "label": " SeekableByteChannel truncate(long size) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Truncates the entity, to which this channel is connected, to the given\\n     * size.\\n     *\\n     * \u003cp\u003e If the given size is less than the current size then the entity is\\n     * truncated, discarding any bytes beyond the new end. If the given size is\\n     * greater than or equal to the current size then the entity is not modified.\\n     * In either case, if the current position is greater than the given size\\n     * then it is set to that size.\\n     *\\n     * \u003cp\u003e An implementation of this interface may prohibit truncation when\\n     * connected to an entity, typically a file, opened with the {@link\\n     * java.nio.file.StandardOpenOption#APPEND APPEND} option.\\n     *\\n     * @param  size\\n     *         The new size, a non-negative byte count\\n     *\\n     * @return  This channel\\n     *\\n     * @throws  NonWritableChannelException\\n     *          If this channel was not opened for writing\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     * @throws  IllegalArgumentException\\n     *          If the new size is negative\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \u0027}"}, {"color": "#97c2fc", "id": "CREATE_NEW", "label": "CREATE_NEW", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "FileAttributefile", "label": "FileAttributefile", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "java.nio.channels.FileChannel", "label": "java.nio.channels.FileChannel", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public static FileChannel open(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "label": "public static FileChannel open(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens or creates a file, returning a file channel to access the file.\\n     *\\n     * \u003cp\u003e The {@code options} parameter determines how the file is opened.\\n     * The {@link StandardOpenOption#READ READ} and {@link StandardOpenOption#WRITE\\n     * WRITE} options determine if the file should be opened for reading and/or\\n     * writing. If neither option (or the {@link StandardOpenOption#APPEND APPEND}\\n     * option) is contained in the array then the file is opened for reading.\\n     * By default reading or writing commences at the beginning of the file.\\n     *\\n     * \u003cp\u003e In the addition to {@code READ} and {@code WRITE}, the following\\n     * options may be present:\\n     *\\n     * \u003ctable class=\"striped\"\u003e\\n     * \u003ccaption style=\"display:none\"\u003eadditional options\u003c/caption\u003e\\n     * \u003cthead\u003e\\n     * \u003ctr\u003e \u003cth scope=\"col\"\u003eOption\u003c/th\u003e \u003cth scope=\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\\n     * \u003c/thead\u003e\\n     * \u003ctbody\u003e\\n     * \u003ctr\u003e\\n     *   \u003cth scope=\"row\"\u003e {@link StandardOpenOption#APPEND APPEND} \u003c/th\u003e\\n     *   \u003ctd\u003e If this option is present then the file is opened for writing and\\n     *     each invocation of the channel\\\u0027s {@code write} method first advances\\n     *     the position to the end of the file and then writes the requested\\n     *     data. Whether the advancement of the position and the writing of the\\n     *     data are done in a single atomic operation is system-dependent and\\n     *     therefore unspecified. This option may not be used in conjunction\\n     *     with the {@code READ} or {@code TRUNCATE_EXISTING} options. \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003cth scope=\"row\"\u003e {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} \u003c/th\u003e\\n     *   \u003ctd\u003e If this option is present then the existing file is truncated to\\n     *   a size of 0 bytes. This option is ignored when the file is opened only\\n     *   for reading. \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003cth scope=\"row\"\u003e {@link StandardOpenOption#CREATE_NEW CREATE_NEW} \u003c/th\u003e\\n     *   \u003ctd\u003e If this option is present then a new file is created, failing if\\n     *   the file already exists. When creating a file the check for the\\n     *   existence of the file and the creation of the file if it does not exist\\n     *   is atomic with respect to other file system operations. This option is\\n     *   ignored when the file is opened only for reading. \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003cth scope=\"row\" \u003e {@link StandardOpenOption#CREATE CREATE} \u003c/th\u003e\\n     *   \u003ctd\u003e If this option is present then an existing file is opened if it\\n     *   exists, otherwise a new file is created. When creating a file the check\\n     *   for the existence of the file and the creation of the file if it does\\n     *   not exist is atomic with respect to other file system operations. This\\n     *   option is ignored if the {@code CREATE_NEW} option is also present or\\n     *   the file is opened only for reading. \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003cth scope=\"row\" \u003e {@link StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} \u003c/th\u003e\\n     *   \u003ctd\u003e When this option is present then the implementation makes a\\n     *   \u003cem\u003ebest effort\u003c/em\u003e attempt to delete the file when closed by\\n     *   the {@link #close close} method. If the {@code close} method is not\\n     *   invoked then a \u003cem\u003ebest effort\u003c/em\u003e attempt is made to delete the file\\n     *   when the Java virtual machine terminates. \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003cth scope=\"row\"\u003e{@link StandardOpenOption#SPARSE SPARSE} \u003c/th\u003e\\n     *   \u003ctd\u003e When creating a new file this option is a \u003cem\u003ehint\u003c/em\u003e that the\\n     *   new file will be sparse. This option is ignored when not creating\\n     *   a new file. \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003cth scope=\"row\"\u003e {@link StandardOpenOption#SYNC SYNC} \u003c/th\u003e\\n     *   \u003ctd\u003e Requires that every update to the file\\\u0027s content or metadata be\\n     *   written synchronously to the underlying storage device. (see \u003ca\\n     *   href=\"../file/package-summary.html#integrity\"\u003e Synchronized I/O file\\n     *   integrity\u003c/a\u003e). \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003cth scope=\"row\"\u003e {@link StandardOpenOption#DSYNC DSYNC} \u003c/th\u003e\\n     *   \u003ctd\u003e Requires that every update to the file\\\u0027s content be written\\n     *   synchronously to the underlying storage device. (see \u003ca\\n     *   href=\"../file/package-summary.html#integrity\"\u003e Synchronized I/O file\\n     *   integrity\u003c/a\u003e). \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003c/tbody\u003e\\n     * \u003c/table\u003e\\n     *\\n     * \u003cp\u003e An implementation may also support additional options.\\n     *\\n     * \u003cp\u003e The {@code attrs} parameter is an optional array of file {@link\\n     * FileAttribute file-attributes} to set atomically when creating the file.\\n     *\\n     * \u003cp\u003e The new channel is created by invoking the {@link\\n     * FileSystemProvider#newFileChannel newFileChannel} method on the\\n     * provider that created the {@code Path}.\\n     *\\n     * @param   path\\n     *          The path of the file to open or create\\n     * @param   options\\n     *          Options specifying how the file is opened\\n     * @param   attrs\\n     *          An optional list of file attributes to set atomically when\\n     *          creating the file\\n     *\\n     * @return  A new file channel\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the set contains an invalid combination of options\\n     * @throws  UnsupportedOperationException\\n     *          If the {@code path} is associated with a provider that does not\\n     *          support creating file channels, or an unsupported open option is\\n     *          specified, or the array contains an attribute that cannot be set\\n     *          atomically when creating the file\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     * @throws  SecurityException\\n     *          If a security manager is installed and it denies an\\n     *          unspecified permission required by the implementation.\\n     *          In the case of the default provider, the {@link\\n     *          SecurityManager#checkRead(String)} method is invoked to check\\n     *          read access if the file is opened for reading. The {@link\\n     *          SecurityManager#checkWrite(String)} method is invoked to check\\n     *          write access if the file is opened for writing\\n     *\\n     * @since   1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.attribute.FileAttribute", "label": "java.nio.file.attribute.FileAttribute", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": " T value()", "label": " T value()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the attribute value.\\n     *\\n     * @return The attribute value\\n     \u0027}"}, {"color": "#97c2fc", "id": "WRITEWRITE", "label": "WRITEWRITE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "newFileChannel", "label": "newFileChannel", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static FileChannel open(Path path, OpenOption... options) throws IOException", "label": "public static FileChannel open(Path path, OpenOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens or creates a file, returning a file channel to access the file.\\n     *\\n     * \u003cp\u003e An invocation of this method behaves in exactly the same way as the\\n     * invocation\\n     * \u003cpre\u003e\\n     *     fc.{@link #open(Path,Set,FileAttribute[]) open}(file, opts, new FileAttribute\u0026lt;?\u0026gt;[0]);\\n     * \u003c/pre\u003e\\n     * where {@code opts} is a set of the options specified in the {@code\\n     * options} array.\\n     *\\n     * @param   path\\n     *          The path of the file to open or create\\n     * @param   options\\n     *          Options specifying how the file is opened\\n     *\\n     * @return  A new file channel\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the set contains an invalid combination of options\\n     * @throws  UnsupportedOperationException\\n     *          If the {@code path} is associated with a provider that does not\\n     *          support creating file channels, or an unsupported open option is\\n     *          specified\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     * @throws  SecurityException\\n     *          If a security manager is installed and it denies an\\n     *          unspecified permission required by the implementation.\\n     *          In the case of the default provider, the {@link\\n     *          SecurityManager#checkRead(String)} method is invoked to check\\n     *          read access if the file is opened for reading. The {@link\\n     *          SecurityManager#checkWrite(String)} method is invoked to check\\n     *          write access if the file is opened for writing\\n     *\\n     * @since   1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "open(Path", "label": "open(Path", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract long position() throws IOException", "label": "public abstract long position() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns this channel\u0027s file position.\\n     *\\n     * @return  This channel\u0027s file position,\\n     *          a non-negative integer counting the number of bytes\\n     *          from the beginning of the file to the current position\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract FileChannel position(long newPosition) throws IOException", "label": "public abstract FileChannel position(long newPosition) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Sets this channel\u0027s file position.\\n     *\\n     * \u003cp\u003e Setting the position to a value that is greater than the file\u0027s\\n     * current size is legal but does not change the size of the file.  A later\\n     * attempt to read bytes at such a position will immediately return an\\n     * end-of-file indication.  A later attempt to write bytes at such a\\n     * position will cause the file to be grown to accommodate the new bytes;\\n     * the values of any bytes between the previous end-of-file and the\\n     * newly-written bytes are unspecified.  \u003c/p\u003e\\n     *\\n     * @param  newPosition\\n     *         The new position, a non-negative integer counting\\n     *         the number of bytes from the beginning of the file\\n     *\\n     * @return  This file channel\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the new position is negative\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract long size() throws IOException", "label": "public abstract long size() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the current size of this channel\u0027s file.\\n     *\\n     * @return  The current size of this channel\u0027s file,\\n     *          measured in bytes\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract FileChannel truncate(long size) throws IOException", "label": "public abstract FileChannel truncate(long size) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Truncates this channel\u0027s file to the given size.\\n     *\\n     * \u003cp\u003e If the given size is less than the file\u0027s current size then the file\\n     * is truncated, discarding any bytes beyond the new end of the file.  If\\n     * the given size is greater than or equal to the file\u0027s current size then\\n     * the file is not modified.  In either case, if this channel\u0027s file\\n     * position is greater than the given size then it is set to that size.\\n     * \u003c/p\u003e\\n     *\\n     * @param  size\\n     *         The new size, a non-negative byte count\\n     *\\n     * @return  This file channel\\n     *\\n     * @throws  NonWritableChannelException\\n     *          If this channel was not opened for writing\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the new size is negative\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract void force(boolean metaData) throws IOException", "label": "public abstract void force(boolean metaData) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Forces any updates to this channel\u0027s file to be written to the storage\\n     * device that contains it.\\n     *\\n     * \u003cp\u003e If this channel\u0027s file resides on a local storage device then when\\n     * this method returns it is guaranteed that all changes made to the file\\n     * since this channel was created, or since this method was last invoked,\\n     * will have been written to that device.  This is useful for ensuring that\\n     * critical information is not lost in the event of a system crash.\\n     *\\n     * \u003cp\u003e If the file does not reside on a local device then no such guarantee\\n     * is made.\\n     *\\n     * \u003cp\u003e The {@code metaData} parameter can be used to limit the number of\\n     * I/O operations that this method is required to perform.  Passing\\n     * {@code false} for this parameter indicates that only updates to the\\n     * file\u0027s content need be written to storage; passing {@code true}\\n     * indicates that updates to both the file\u0027s content and metadata must be\\n     * written, which generally requires at least one more I/O operation.\\n     * Whether this parameter actually has any effect is dependent upon the\\n     * underlying operating system and is therefore unspecified.\\n     *\\n     * \u003cp\u003e Invoking this method may cause an I/O operation to occur even if the\\n     * channel was only opened for reading.  Some operating systems, for\\n     * example, maintain a last-access time as part of a file\u0027s metadata, and\\n     * this time is updated whenever the file is read.  Whether or not this is\\n     * actually done is system-dependent and is therefore unspecified.\\n     *\\n     * \u003cp\u003e This method is only guaranteed to force changes that were made to\\n     * this channel\u0027s file via the methods defined in this class.  It may or\\n     * may not force changes that were made by modifying the content of a\\n     * {@link MappedByteBuffer \u003ci\u003emapped byte buffer\u003c/i\u003e} obtained by\\n     * invoking the {@link #map map} method.  Invoking the {@link\\n     * MappedByteBuffer#force force} method of the mapped byte buffer will\\n     * force changes made to the buffer\u0027s content to be written.  \u003c/p\u003e\\n     *\\n     * @param   metaData\\n     *          If {@code true} then this method is required to force changes\\n     *          to both the file\u0027s content and metadata to be written to\\n     *          storage; otherwise, it need only force content changes to be\\n     *          written\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "map", "label": "map", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "force", "label": "force", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.MappedByteBuffer", "label": "java.nio.MappedByteBuffer", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": " final boolean isSync()", "label": " final boolean isSync()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether this buffer was mapped against a non-volatile\\n     * memory device by passing one of the sync map modes {@link\\n     * jdk.nio.mapmode.ExtendedMapMode#READ_ONLY_SYNC\\n     * ExtendedMapModeMapMode#READ_ONLY_SYNC} or {@link\\n     * jdk.nio.mapmode.ExtendedMapMode#READ_ONLY_SYNC\\n     * ExtendedMapMode#READ_WRITE_SYNC} in the call to {@link\\n     * java.nio.channels.FileChannel#map FileChannel.map} or was\\n     * mapped by passing one of the other map modes.\\n     *\\n     * @return true if the file was mapped using one of the sync map\\n     * modes, otherwise false.\\n     \u0027}"}, {"color": "#97c2fc", "id": "READ_ONLY_SYNCExtendedMapModeMapMode", "label": "READ_ONLY_SYNCExtendedMapModeMapMode", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "READ_ONLY_SYNCExtendedMapMode", "label": "READ_ONLY_SYNCExtendedMapMode", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " final FileDescriptor fileDescriptor()", "label": " final FileDescriptor fileDescriptor()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the {@code FileDescriptor} associated with this\\n     * {@code MappedByteBuffer}.\\n     *\\n     * @return the buffer\u0027s file descriptor; may be {@code null}\\n     \"}"}, {"color": "#97c2fc", "id": "private void checkMapped()", "label": "private void checkMapped()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \" Android-added: Added checkMapped as Android doesn\u0027t allow null fd in DirectByteBuffer.\"}"}, {"color": "#97c2fc", "id": "private long mappingOffset()", "label": "private long mappingOffset()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 of the mapping. Computed each time to avoid storing in every direct buffer.\u0027}"}, {"color": "#97c2fc", "id": "public final boolean isLoaded()", "label": "public final boolean isLoaded()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Tells whether or not this buffer\u0027s content is resident in physical\\n     * memory.\\n     *\\n     * \u003cp\u003e A return value of {@code true} implies that it is highly likely\\n     * that all of the data in this buffer is resident in physical memory and\\n     * may therefore be accessed without incurring any virtual-memory page\\n     * faults or I/O operations.  A return value of {@code false} does not\\n     * necessarily imply that the buffer\u0027s content is not resident in physical\\n     * memory.\\n     *\\n     * \u003cp\u003e The returned value is a hint, rather than a guarantee, because the\\n     * underlying operating system may have paged out some of the buffer\u0027s data\\n     * by the time that an invocation of this method returns.  \u003c/p\u003e\\n     *\\n     * @return  {@code true} if it is likely that this buffer\u0027s content\\n     *          is resident in physical memory\\n     \"}"}, {"color": "#97c2fc", "id": "public final MappedByteBuffer load()", "label": "public final MappedByteBuffer load()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Loads this buffer\u0027s content into physical memory.\\n     *\\n     * \u003cp\u003e This method makes a best effort to ensure that, when it returns,\\n     * this buffer\u0027s content is resident in physical memory.  Invoking this\\n     * method may cause some number of page faults and I/O operations to\\n     * occur. \u003c/p\u003e\\n     *\\n     * @return  This buffer\\n     \"}"}, {"color": "#97c2fc", "id": "public final MappedByteBuffer force()", "label": "public final MappedByteBuffer force()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Forces any changes made to this buffer\u0027s content to be written to the\\n     * storage device containing the mapped file.  The region starts at index\\n     * zero in this buffer and is {@code capacity()} bytes.\\n     *\\n     * \u003cp\u003e If the file mapped into this buffer resides on a local storage\\n     * device then when this method returns it is guaranteed that all changes\\n     * made to the buffer since it was created, or since this method was last\\n     * invoked, will have been written to that device.\\n     *\\n     * \u003cp\u003e If the file does not reside on a local device then no such guarantee\\n     * is made.\\n     *\\n     * \u003cp\u003e If this buffer was not mapped in read/write mode ({@link\\n     * java.nio.channels.FileChannel.MapMode#READ_WRITE}) then\\n     * invoking this method may have no effect. In particular, the\\n     * method has no effect for buffers mapped in read-only or private\\n     * mapping modes. This method may or may not have an effect for\\n     * implementation-specific mapping modes. \u003c/p\u003e\\n     *\\n     * @throws UncheckedIOException\\n     *         If an I/O error occurs writing the buffer\u0027s content to the\\n     *         storage device containing the mapped file\\n     *\\n     * @return  This buffer\\n     \"}"}, {"color": "#97c2fc", "id": "READ_WRITE", "label": "READ_WRITE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public final MappedByteBuffer force(int index, int length)", "label": "public final MappedByteBuffer force(int index, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Forces any changes made to a region of this buffer\u0027s content to\\n     * be written to the storage device containing the mapped\\n     * file. The region starts at the given {@code index} in this\\n     * buffer and is {@code length} bytes.\\n     *\\n     * \u003cp\u003e If the file mapped into this buffer resides on a local\\n     * storage device then when this method returns it is guaranteed\\n     * that all changes made to the selected region buffer since it\\n     * was created, or since this method was last invoked, will have\\n     * been written to that device. The force operation is free to\\n     * write bytes that lie outside the specified region, for example\\n     * to ensure that data blocks of some device-specific granularity\\n     * are transferred in their entirety.\\n     *\\n     * \u003cp\u003e If the file does not reside on a local device then no such\\n     * guarantee is made.\\n     *\\n     * \u003cp\u003e If this buffer was not mapped in read/write mode ({@link\\n     * java.nio.channels.FileChannel.MapMode#READ_WRITE}) then\\n     * invoking this method may have no effect. In particular, the\\n     * method has no effect for buffers mapped in read-only or private\\n     * mapping modes. This method may or may not have an effect for\\n     * implementation-specific mapping modes. \u003c/p\u003e\\n     *\\n     * @param  index\\n     *         The index of the first byte in the buffer region that is\\n     *         to be written back to storage; must be non-negative\\n     *         and less than {@code capacity()}\\n     *\\n     * @param  length\\n     *         The length of the region in bytes; must be non-negative\\n     *         and no larger than {@code capacity() - index}\\n     *\\n     * @throws IndexOutOfBoundsException\\n     *         if the preconditions on the index and length do not\\n     *         hold.\\n     *\\n     * @throws UncheckedIOException\\n     *         If an I/O error occurs writing the buffer\u0027s content to the\\n     *         storage device containing the mapped file\\n     *\\n     * @return  This buffer\\n     *\\n     * @since 13\\n     \"}"}, {"color": "#97c2fc", "id": "public final Buffer position(int newPosition)", "label": "public final Buffer position(int newPosition)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-changed: covariant overloads of *Buffer methods that return this.\u0027}"}, {"color": "#97c2fc", "id": "public final Buffer limit(int newLimit)", "label": "public final Buffer limit(int newLimit)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-changed: covariant overloads of *Buffer methods that return this.\u0027}"}, {"color": "#97c2fc", "id": "public final Buffer mark()", "label": "public final Buffer mark()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-changed: covariant overloads of *Buffer methods that return this.\u0027}"}, {"color": "#97c2fc", "id": "public final Buffer reset()", "label": "public final Buffer reset()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-changed: covariant overloads of *Buffer methods that return this.\u0027}"}, {"color": "#97c2fc", "id": "public final Buffer clear()", "label": "public final Buffer clear()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-changed: covariant overloads of *Buffer methods that return this.\u0027}"}, {"color": "#97c2fc", "id": "public final Buffer flip()", "label": "public final Buffer flip()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-changed: covariant overloads of *Buffer methods that return this.\u0027}"}, {"color": "#97c2fc", "id": "public final Buffer rewind()", "label": "public final Buffer rewind()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Android-changed: covariant overloads of *Buffer methods that return this.\u0027}"}, {"color": "#97c2fc", "id": "public abstract MappedByteBuffer slice(int index, int length)", "label": "public abstract MappedByteBuffer slice(int index, int length)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * {@inheritDoc}\\n     *\\n     * \u003cp\u003e Reading bytes into physical memory by invoking {@code load()} on the\\n     * returned buffer, or writing bytes to the storage device by invoking\\n     * {@code force()} on the returned buffer, will only act on the sub-range\\n     * of this buffer that the returned buffer represents, namely\\n     * {@code [index,index+length)}, where {@code index} and {@code length} are\\n     * assumed to satisfy the preconditions.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract long transferTo(long position, long count, WritableByteChannel target) throws IOException", "label": "public abstract long transferTo(long position, long count, WritableByteChannel target) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Transfers bytes from this channel\u0027s file to the given writable byte\\n     * channel.\\n     *\\n     * \u003cp\u003e An attempt is made to read up to {@code count} bytes starting at\\n     * the given {@code position} in this channel\u0027s file and write them to the\\n     * target channel.  An invocation of this method may or may not transfer\\n     * all of the requested bytes; whether or not it does so depends upon the\\n     * natures and states of the channels.  Fewer than the requested number of\\n     * bytes are transferred if this channel\u0027s file contains fewer than\\n     * {@code count} bytes starting at the given {@code position}, or if the\\n     * target channel is non-blocking and it has fewer than {@code count}\\n     * bytes free in its output buffer.\\n     *\\n     * \u003cp\u003e This method does not modify this channel\u0027s position.  If the given\\n     * position is greater than the file\u0027s current size then no bytes are\\n     * transferred.  If the target channel has a position then bytes are\\n     * written starting at that position and then the position is incremented\\n     * by the number of bytes written.\\n     *\\n     * \u003cp\u003e This method is potentially much more efficient than a simple loop\\n     * that reads from this channel and writes to the target channel.  Many\\n     * operating systems can transfer bytes directly from the filesystem cache\\n     * to the target channel without actually copying them.  \u003c/p\u003e\\n     *\\n     * @param  position\\n     *         The position within the file at which the transfer is to begin;\\n     *         must be non-negative\\n     *\\n     * @param  count\\n     *         The maximum number of bytes to be transferred; must be\\n     *         non-negative\\n     *\\n     * @param  target\\n     *         The target channel\\n     *\\n     * @return  The number of bytes, possibly zero,\\n     *          that were actually transferred\\n     *\\n     * @throws IllegalArgumentException\\n     *         If the preconditions on the parameters do not hold\\n     *\\n     * @throws  NonReadableChannelException\\n     *          If this channel was not opened for reading\\n     *\\n     * @throws  NonWritableChannelException\\n     *          If the target channel was not opened for writing\\n     *\\n     * @throws  ClosedChannelException\\n     *          If either this channel or the target channel is closed\\n     *\\n     * @throws  AsynchronousCloseException\\n     *          If another thread closes either channel\\n     *          while the transfer is in progress\\n     *\\n     * @throws  ClosedByInterruptException\\n     *          If another thread interrupts the current thread while the\\n     *          transfer is in progress, thereby closing both channels and\\n     *          setting the current thread\u0027s interrupt status\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract long transferFrom(ReadableByteChannel src, long position, long count) throws IOException", "label": "public abstract long transferFrom(ReadableByteChannel src, long position, long count) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Transfers bytes into this channel\u0027s file from the given readable byte\\n     * channel.\\n     *\\n     * \u003cp\u003e An attempt is made to read up to {@code count} bytes from the\\n     * source channel and write them to this channel\u0027s file starting at the\\n     * given {@code position}.  An invocation of this method may or may not\\n     * transfer all of the requested bytes; whether or not it does so depends\\n     * upon the natures and states of the channels.  Fewer than the requested\\n     * number of bytes will be transferred if the source channel has fewer than\\n     * {@code count} bytes remaining, or if the source channel is non-blocking\\n     * and has fewer than {@code count} bytes immediately available in its\\n     * input buffer.\\n     *\\n     * \u003cp\u003e This method does not modify this channel\u0027s position.  If the given\\n     * position is greater than the file\u0027s current size then no bytes are\\n     * transferred.  If the source channel has a position then bytes are read\\n     * starting at that position and then the position is incremented by the\\n     * number of bytes read.\\n     *\\n     * \u003cp\u003e This method is potentially much more efficient than a simple loop\\n     * that reads from the source channel and writes to this channel.  Many\\n     * operating systems can transfer bytes directly from the source channel\\n     * into the filesystem cache without actually copying them.  \u003c/p\u003e\\n     *\\n     * @param  src\\n     *         The source channel\\n     *\\n     * @param  position\\n     *         The position within the file at which the transfer is to begin;\\n     *         must be non-negative\\n     *\\n     * @param  count\\n     *         The maximum number of bytes to be transferred; must be\\n     *         non-negative\\n     *\\n     * @return  The number of bytes, possibly zero,\\n     *          that were actually transferred\\n     *\\n     * @throws IllegalArgumentException\\n     *         If the preconditions on the parameters do not hold\\n     *\\n     * @throws  NonReadableChannelException\\n     *          If the source channel was not opened for reading\\n     *\\n     * @throws  NonWritableChannelException\\n     *          If this channel was not opened for writing\\n     *\\n     * @throws  ClosedChannelException\\n     *          If either this channel or the source channel is closed\\n     *\\n     * @throws  AsynchronousCloseException\\n     *          If another thread closes either channel\\n     *          while the transfer is in progress\\n     *\\n     * @throws  ClosedByInterruptException\\n     *          If another thread interrupts the current thread while the\\n     *          transfer is in progress, thereby closing both channels and\\n     *          setting the current thread\u0027s interrupt status\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract int read(ByteBuffer dst, long position) throws IOException", "label": "public abstract int read(ByteBuffer dst, long position) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reads a sequence of bytes from this channel into the given buffer,\\n     * starting at the given file position.\\n     *\\n     * \u003cp\u003e This method works in the same manner as the {@link\\n     * #read(ByteBuffer)} method, except that bytes are read starting at the\\n     * given file position rather than at the channel\u0027s current position.  This\\n     * method does not modify this channel\u0027s position.  If the given position\\n     * is greater than the file\u0027s current size then no bytes are read.  \u003c/p\u003e\\n     *\\n     * @param  dst\\n     *         The buffer into which bytes are to be transferred\\n     *\\n     * @param  position\\n     *         The file position at which the transfer is to begin;\\n     *         must be non-negative\\n     *\\n     * @return  The number of bytes read, possibly zero, or {@code -1} if the\\n     *          given position is greater than or equal to the file\u0027s current\\n     *          size\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the position is negative\\n     *\\n     * @throws  NonReadableChannelException\\n     *          If this channel was not opened for reading\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     *\\n     * @throws  AsynchronousCloseException\\n     *          If another thread closes this channel\\n     *          while the read operation is in progress\\n     *\\n     * @throws  ClosedByInterruptException\\n     *          If another thread interrupts the current thread\\n     *          while the read operation is in progress, thereby\\n     *          closing the channel and setting the current thread\u0027s\\n     *          interrupt status\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "read(ByteBuffer)", "label": "read(ByteBuffer)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract int write(ByteBuffer src, long position) throws IOException", "label": "public abstract int write(ByteBuffer src, long position) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Writes a sequence of bytes to this channel from the given buffer,\\n     * starting at the given file position.\\n     *\\n     * \u003cp\u003e This method works in the same manner as the {@link\\n     * #write(ByteBuffer)} method, except that bytes are written starting at\\n     * the given file position rather than at the channel\u0027s current position.\\n     * This method does not modify this channel\u0027s position.  If the given\\n     * position is greater than the file\u0027s current size then the file will be\\n     * grown to accommodate the new bytes; the values of any bytes between the\\n     * previous end-of-file and the newly-written bytes are unspecified.  \u003c/p\u003e\\n     *\\n     * @param  src\\n     *         The buffer from which bytes are to be transferred\\n     *\\n     * @param  position\\n     *         The file position at which the transfer is to begin;\\n     *         must be non-negative\\n     *\\n     * @return  The number of bytes written, possibly zero\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the position is negative\\n     *\\n     * @throws  NonWritableChannelException\\n     *          If this channel was not opened for writing\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     *\\n     * @throws  AsynchronousCloseException\\n     *          If another thread closes this channel\\n     *          while the write operation is in progress\\n     *\\n     * @throws  ClosedByInterruptException\\n     *          If another thread interrupts the current thread\\n     *          while the write operation is in progress, thereby\\n     *          closing the channel and setting the current thread\u0027s\\n     *          interrupt status\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "write(ByteBuffer)", "label": "write(ByteBuffer)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract MappedByteBuffer map(MapMode mode, long position, long size) throws IOException", "label": "public abstract MappedByteBuffer map(MapMode mode, long position, long size) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Maps a region of this channel\u0027s file directly into memory.\\n     *\\n     * \u003cp\u003e A region of a file may be mapped into memory in one of three modes:\\n     * \u003c/p\u003e\\n     *\\n     * \u003cul\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e \u003ci\u003eRead-only:\u003c/i\u003e Any attempt to modify the resulting buffer\\n     *   will cause a {@link java.nio.ReadOnlyBufferException} to be thrown.\\n     *   ({@link MapMode#READ_ONLY MapMode.READ_ONLY}) \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e \u003ci\u003eRead/write:\u003c/i\u003e Changes made to the resulting buffer will\\n     *   eventually be propagated to the file; they may or may not be made\\n     *   visible to other programs that have mapped the same file.  ({@link\\n     *   MapMode#READ_WRITE MapMode.READ_WRITE}) \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e \u003ci\u003ePrivate:\u003c/i\u003e Changes made to the resulting buffer will not\\n     *   be propagated to the file and will not be visible to other programs\\n     *   that have mapped the same file; instead, they will cause private\\n     *   copies of the modified portions of the buffer to be created.  ({@link\\n     *   MapMode#PRIVATE MapMode.PRIVATE}) \u003c/p\u003e\u003c/li\u003e\\n     *\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003e For a read-only mapping, this channel must have been opened for\\n     * reading; for a read/write or private mapping, this channel must have\\n     * been opened for both reading and writing.\\n     *\\n     * \u003cp\u003e The {@link MappedByteBuffer \u003ci\u003emapped byte buffer\u003c/i\u003e}\\n     * returned by this method will have a position of zero and a limit and\\n     * capacity of {@code size}; its mark will be undefined.  The buffer and\\n     * the mapping that it represents will remain valid until the buffer itself\\n     * is garbage-collected.\\n     *\\n     * \u003cp\u003e A mapping, once established, is not dependent upon the file channel\\n     * that was used to create it.  Closing the channel, in particular, has no\\n     * effect upon the validity of the mapping.\\n     *\\n     * \u003cp\u003e Many of the details of memory-mapped files are inherently dependent\\n     * upon the underlying operating system and are therefore unspecified.  The\\n     * behavior of this method when the requested region is not completely\\n     * contained within this channel\u0027s file is unspecified.  Whether changes\\n     * made to the content or size of the underlying file, by this program or\\n     * another, are propagated to the buffer is unspecified.  The rate at which\\n     * changes to the buffer are propagated to the file is unspecified.\\n     *\\n     * \u003cp\u003e For most operating systems, mapping a file into memory is more\\n     * expensive than reading or writing a few tens of kilobytes of data via\\n     * the usual {@link #read read} and {@link #write write} methods.  From the\\n     * standpoint of performance it is generally only worth mapping relatively\\n     * large files into memory.  \u003c/p\u003e\\n     *\\n     * @param  mode\\n     *         One of the constants {@link MapMode#READ_ONLY READ_ONLY}, {@link\\n     *         MapMode#READ_WRITE READ_WRITE}, or {@link MapMode#PRIVATE\\n     *         PRIVATE} defined in the {@link MapMode} class, according to\\n     *         whether the file is to be mapped read-only, read/write, or\\n     *         privately (copy-on-write), respectively\\n     *\\n     * @param  position\\n     *         The position within the file at which the mapped region\\n     *         is to start; must be non-negative\\n     *\\n     * @param  size\\n     *         The size of the region to be mapped; must be non-negative and\\n     *         no greater than {@link java.lang.Integer#MAX_VALUE}\\n     *\\n     * @return  The mapped byte buffer\\n     *\\n     * @throws NonReadableChannelException\\n     *         If the {@code mode} is {@link MapMode#READ_ONLY READ_ONLY} but\\n     *         this channel was not opened for reading\\n     *\\n     * @throws NonWritableChannelException\\n     *         If the {@code mode} is {@link MapMode#READ_WRITE READ_WRITE} or\\n     *         {@link MapMode#PRIVATE PRIVATE} but this channel was not opened\\n     *         for both reading and writing\\n     *\\n     * @throws IllegalArgumentException\\n     *         If the preconditions on the parameters do not hold\\n     *\\n     * @throws IOException\\n     *         If some other I/O error occurs\\n     *\\n     * @see java.nio.channels.FileChannel.MapMode\\n     * @see java.nio.MappedByteBuffer\\n     \"}"}, {"color": "#97c2fc", "id": "PRIVATE", "label": "PRIVATE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "READ_ONLY", "label": "READ_ONLY", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "write", "label": "write", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "PRIVATEPRIVATE", "label": "PRIVATEPRIVATE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "MapMode", "label": "MapMode", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "java.nio.ReadOnlyBufferException", "label": "java.nio.ReadOnlyBufferException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public abstract FileLock lock(long position, long size, boolean shared) throws IOException", "label": "public abstract FileLock lock(long position, long size, boolean shared) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Acquires a lock on the given region of this channel\u0027s file.\\n     *\\n     * \u003cp\u003e An invocation of this method will block until the region can be\\n     * locked, this channel is closed, or the invoking thread is interrupted,\\n     * whichever comes first.\\n     *\\n     * \u003cp\u003e If this channel is closed by another thread during an invocation of\\n     * this method then an {@link AsynchronousCloseException} will be thrown.\\n     *\\n     * \u003cp\u003e If the invoking thread is interrupted while waiting to acquire the\\n     * lock then its interrupt status will be set and a {@link\\n     * FileLockInterruptionException} will be thrown.  If the invoker\u0027s\\n     * interrupt status is set when this method is invoked then that exception\\n     * will be thrown immediately; the thread\u0027s interrupt status will not be\\n     * changed.\\n     *\\n     * \u003cp\u003e The region specified by the {@code position} and {@code size}\\n     * parameters need not be contained within, or even overlap, the actual\\n     * underlying file.  Lock regions are fixed in size; if a locked region\\n     * initially contains the end of the file and the file grows beyond the\\n     * region then the new portion of the file will not be covered by the lock.\\n     * If a file is expected to grow in size and a lock on the entire file is\\n     * required then a region starting at zero, and no smaller than the\\n     * expected maximum size of the file, should be locked.  The zero-argument\\n     * {@link #lock()} method simply locks a region of size {@link\\n     * Long#MAX_VALUE}.\\n     *\\n     * \u003cp\u003e Some operating systems do not support shared locks, in which case a\\n     * request for a shared lock is automatically converted into a request for\\n     * an exclusive lock.  Whether the newly-acquired lock is shared or\\n     * exclusive may be tested by invoking the resulting lock object\u0027s {@link\\n     * FileLock#isShared() isShared} method.\\n     *\\n     * \u003cp\u003e File locks are held on behalf of the entire Java virtual machine.\\n     * They are not suitable for controlling access to a file by multiple\\n     * threads within the same virtual machine.  \u003c/p\u003e\\n     *\\n     * @param  position\\n     *         The position at which the locked region is to start; must be\\n     *         non-negative\\n     *\\n     * @param  size\\n     *         The size of the locked region; must be non-negative, and the sum\\n     *         {@code position}\u0026nbsp;+\u0026nbsp;{@code size} must be non-negative\\n     *\\n     * @param  shared\\n     *         {@code true} to request a shared lock, in which case this\\n     *         channel must be open for reading (and possibly writing);\\n     *         {@code false} to request an exclusive lock, in which case this\\n     *         channel must be open for writing (and possibly reading)\\n     *\\n     * @return  A lock object representing the newly-acquired lock\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the preconditions on the parameters do not hold\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     *\\n     * @throws  AsynchronousCloseException\\n     *          If another thread closes this channel while the invoking\\n     *          thread is blocked in this method\\n     *\\n     * @throws  FileLockInterruptionException\\n     *          If the invoking thread is interrupted while blocked in this\\n     *          method\\n     *\\n     * @throws  OverlappingFileLockException\\n     *          If a lock that overlaps the requested region is already held by\\n     *          this Java virtual machine, or if another thread is already\\n     *          blocked in this method and is attempting to lock an overlapping\\n     *          region\\n     *\\n     * @throws  NonReadableChannelException\\n     *          If {@code shared} is {@code true} this channel was not\\n     *          opened for reading\\n     *\\n     * @throws  NonWritableChannelException\\n     *          If {@code shared} is {@code false} but this channel was not\\n     *          opened for writing\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     *\\n     * @see     #lock()\\n     * @see     #tryLock()\\n     * @see     #tryLock(long,long,boolean)\\n     \"}"}, {"color": "#97c2fc", "id": "java.nio.channels.FileLockInterruptionException", "label": "java.nio.channels.FileLockInterruptionException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "isShared()", "label": "isShared()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.channels.FileLock", "label": "java.nio.channels.FileLock", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public final FileChannel channel()", "label": "public final FileChannel channel()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the file channel upon whose file this lock was acquired.\\n     *\\n     * \u003cp\u003e This method has been superseded by the {@link #acquiredBy acquiredBy}\\n     * method.\\n     *\\n     * @return  The file channel, or {@code null} if the file lock was not\\n     *          acquired by a file channel.\\n     \u0027}"}, {"color": "#97c2fc", "id": "acquiredBy", "label": "acquiredBy", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public Channel acquiredBy()", "label": "public Channel acquiredBy()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the channel upon whose file this lock was acquired.\\n     *\\n     * @return  The channel upon whose file this lock was acquired.\\n     *\\n     * @since 1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final long position()", "label": "public final long position()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the position within the file of the first byte of the locked\\n     * region.\\n     *\\n     * \u003cp\u003e A locked region need not be contained within, or even overlap, the\\n     * actual underlying file, so the value returned by this method may exceed\\n     * the file\u0027s current size.  \u003c/p\u003e\\n     *\\n     * @return  The position\\n     \"}"}, {"color": "#97c2fc", "id": "public final long size()", "label": "public final long size()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the size of the locked region in bytes.\\n     *\\n     * \u003cp\u003e A locked region need not be contained within, or even overlap, the\\n     * actual underlying file, so the value returned by this method may exceed\\n     * the file\u0027s current size.  \u003c/p\u003e\\n     *\\n     * @return  The size of the locked region\\n     \"}"}, {"color": "#97c2fc", "id": "public final boolean isShared()", "label": "public final boolean isShared()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether this lock is shared.\\n     *\\n     * @return {@code true} if lock is shared,\\n     *         {@code false} if it is exclusive\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final boolean overlaps(long position, long size)", "label": "public final boolean overlaps(long position, long size)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not this lock overlaps the given lock range.\\n     *\\n     * @param   position\\n     *          The starting position of the lock range\\n     * @param   size\\n     *          The size of the lock range\\n     *\\n     * @return  {@code true} if, and only if, this lock and the given lock\\n     *          range overlap by at least one byte\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract void release() throws IOException", "label": "public abstract void release() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Releases this lock.\\n     *\\n     * \u003cp\u003e If this lock object is valid then invoking this method releases the\\n     * lock and renders the object invalid.  If this lock object is invalid\\n     * then invoking this method has no effect.  \u003c/p\u003e\\n     *\\n     * @throws  ClosedChannelException\\n     *          If the channel that was used to acquire this lock\\n     *          is no longer open\\n     *\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final void close() throws IOException", "label": "public final void close() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * This method invokes the {@link #release} method. It was added\\n     * to the class so that it could be used in conjunction with the\\n     * automatic resource management block construct.\\n     *\\n     * @since 1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "release", "label": "release", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "lock()", "label": "lock()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public final FileLock lock() throws IOException", "label": "public final FileLock lock() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Acquires an exclusive lock on this channel\u0027s file.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form {@code fc.lock()} behaves\\n     * in exactly the same way as the invocation\\n     *\\n     * \u003cpre\u003e\\n     *     fc.{@link #lock(long,long,boolean) lock}(0L, Long.MAX_VALUE, false) \u003c/pre\u003e\\n     *\\n     * @return  A lock object representing the newly-acquired lock\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     *\\n     * @throws  AsynchronousCloseException\\n     *          If another thread closes this channel while the invoking\\n     *          thread is blocked in this method\\n     *\\n     * @throws  FileLockInterruptionException\\n     *          If the invoking thread is interrupted while blocked in this\\n     *          method\\n     *\\n     * @throws  OverlappingFileLockException\\n     *          If a lock that overlaps the requested region is already held by\\n     *          this Java virtual machine, or if another thread is already\\n     *          blocked in this method and is attempting to lock an overlapping\\n     *          region of the same file\\n     *\\n     * @throws  NonWritableChannelException\\n     *          If this channel was not opened for writing\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     *\\n     * @see     #lock(long,long,boolean)\\n     * @see     #tryLock()\\n     * @see     #tryLock(long,long,boolean)\\n     \"}"}, {"color": "#97c2fc", "id": "lock(long", "label": "lock(long", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract FileLock tryLock(long position, long size, boolean shared) throws IOException", "label": "public abstract FileLock tryLock(long position, long size, boolean shared) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Attempts to acquire a lock on the given region of this channel\u0027s file.\\n     *\\n     * \u003cp\u003e This method does not block.  An invocation always returns\\n     * immediately, either having acquired a lock on the requested region or\\n     * having failed to do so.  If it fails to acquire a lock because an\\n     * overlapping lock is held by another program then it returns\\n     * {@code null}.  If it fails to acquire a lock for any other reason then\\n     * an appropriate exception is thrown.\\n     *\\n     * \u003cp\u003e The region specified by the {@code position} and {@code size}\\n     * parameters need not be contained within, or even overlap, the actual\\n     * underlying file.  Lock regions are fixed in size; if a locked region\\n     * initially contains the end of the file and the file grows beyond the\\n     * region then the new portion of the file will not be covered by the lock.\\n     * If a file is expected to grow in size and a lock on the entire file is\\n     * required then a region starting at zero, and no smaller than the\\n     * expected maximum size of the file, should be locked.  The zero-argument\\n     * {@link #tryLock()} method simply locks a region of size {@link\\n     * Long#MAX_VALUE}.\\n     *\\n     * \u003cp\u003e Some operating systems do not support shared locks, in which case a\\n     * request for a shared lock is automatically converted into a request for\\n     * an exclusive lock.  Whether the newly-acquired lock is shared or\\n     * exclusive may be tested by invoking the resulting lock object\u0027s {@link\\n     * FileLock#isShared() isShared} method.\\n     *\\n     * \u003cp\u003e File locks are held on behalf of the entire Java virtual machine.\\n     * They are not suitable for controlling access to a file by multiple\\n     * threads within the same virtual machine.  \u003c/p\u003e\\n     *\\n     * @param  position\\n     *         The position at which the locked region is to start; must be\\n     *         non-negative\\n     *\\n     * @param  size\\n     *         The size of the locked region; must be non-negative, and the sum\\n     *         {@code position}\u0026nbsp;+\u0026nbsp;{@code size} must be non-negative\\n     *\\n     * @param  shared\\n     *         {@code true} to request a shared lock,\\n     *         {@code false} to request an exclusive lock\\n     *\\n     * @return  A lock object representing the newly-acquired lock,\\n     *          or {@code null} if the lock could not be acquired\\n     *          because another program holds an overlapping lock\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the preconditions on the parameters do not hold\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     *\\n     * @throws  OverlappingFileLockException\\n     *          If a lock that overlaps the requested region is already held by\\n     *          this Java virtual machine, or if another thread is already\\n     *          blocked in this method and is attempting to lock an overlapping\\n     *          region of the same file\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     *\\n     * @see     #lock()\\n     * @see     #lock(long,long,boolean)\\n     * @see     #tryLock()\\n     \"}"}, {"color": "#97c2fc", "id": "tryLock()", "label": "tryLock()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public final FileLock tryLock() throws IOException", "label": "public final FileLock tryLock() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Attempts to acquire an exclusive lock on this channel\u0027s file.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form {@code fc.tryLock()}\\n     * behaves in exactly the same way as the invocation\\n     *\\n     * \u003cpre\u003e\\n     *     fc.{@link #tryLock(long,long,boolean) tryLock}(0L, Long.MAX_VALUE, false) \u003c/pre\u003e\\n     *\\n     * @return  A lock object representing the newly-acquired lock,\\n     *          or {@code null} if the lock could not be acquired\\n     *          because another program holds an overlapping lock\\n     *\\n     * @throws  ClosedChannelException\\n     *          If this channel is closed\\n     *\\n     * @throws  OverlappingFileLockException\\n     *          If a lock that overlaps the requested region is already held by\\n     *          this Java virtual machine, or if another thread is already\\n     *          blocked in this method and is attempting to lock an overlapping\\n     *          region\\n     *\\n     * @throws  IOException\\n     *          If some other I/O error occurs\\n     *\\n     * @see     #lock()\\n     * @see     #lock(long,long,boolean)\\n     * @see     #tryLock(long,long,boolean)\\n     \"}"}, {"color": "#97c2fc", "id": "tryLock(long", "label": "tryLock(long", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static SeekableByteChannel newByteChannel(Path path, OpenOption... options) throws IOException", "label": "public static SeekableByteChannel newByteChannel(Path path, OpenOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens or creates a file, returning a seekable byte channel to access the\\n     * file.\\n     *\\n     * \u003cp\u003e This method opens or creates a file in exactly the manner specified\\n     * by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}\\n     * method.\\n     *\\n     * @param   path\\n     *          the path to the file to open or create\\n     * @param   options\\n     *          options specifying how the file is opened\\n     *\\n     * @return  a new seekable byte channel\\n     *\\n     * @throws  IllegalArgumentException\\n     *          if the set contains an invalid combination of options\\n     * @throws  UnsupportedOperationException\\n     *          if an unsupported open option is specified\\n     * @throws  FileAlreadyExistsException\\n     *          if a file of that name already exists and the {@link\\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the path if the file is\\n     *          opened for reading. The {@link SecurityManager#checkWrite(String)\\n     *          checkWrite} method is invoked to check write access to the path\\n     *          if the file is opened for writing. The {@link\\n     *          SecurityManager#checkDelete(String) checkDelete} method is\\n     *          invoked to check delete access if the file is opened with the\\n     *          {@code DELETE_ON_CLOSE} option.\\n     *\\n     * @see java.nio.channels.FileChannel#open(Path,OpenOption[])\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir) throws IOException", "label": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\\n     * all entries in the directory. The elements returned by the directory\\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\\n     * Path}, each one representing an entry in the directory. The {@code Path}\\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\\n     * name of the directory entry against {@code dir}.\\n     *\\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\\n     * stream\u0027s {@code close} method should be invoked after iteration is\\n     * completed so as to free any resources held for the open directory.\\n     *\\n     * \u003cp\u003e When an implementation supports operations on entries in the\\n     * directory that execute in a race-free manner then the returned directory\\n     * stream is a {@link SecureDirectoryStream}.\\n     *\\n     * @param   dir\\n     *          the path to the directory\\n     *\\n     * @return  a new and open {@code DirectoryStream} object\\n     *\\n     * @throws  NotDirectoryException\\n     *          if the file could not otherwise be opened because it is not\\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the directory.\\n     \"}"}, {"color": "#97c2fc", "id": "java.nio.file.SecureDirectoryStream", "label": "java.nio.file.SecureDirectoryStream", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": " SecureDirectoryStream\u003cT\u003e newDirectoryStream(T path, LinkOption... options) throws IOException", "label": " SecureDirectoryStream\u003cT\u003e newDirectoryStream(T path, LinkOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens the directory identified by the given path, returning a {@code\\n     * SecureDirectoryStream} to iterate over the entries in the directory.\\n     *\\n     * \u003cp\u003e This method works in exactly the manner specified by the {@link\\n     * Files#newDirectoryStream(Path) newDirectoryStream} method for the case that\\n     * the {@code path} parameter is an {@link Path#isAbsolute absolute} path.\\n     * When the parameter is a relative path then the directory to open is\\n     * relative to this open directory. The {@link\\n     * LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} option may be used to\\n     * ensure that this method fails if the file is a symbolic link.\\n     *\\n     * \u003cp\u003e The new directory stream, once created, is not dependent upon the\\n     * directory stream used to create it. Closing this directory stream has no\\n     * effect upon newly created directory stream.\\n     *\\n     * @param   path\\n     *          the path to the directory to open\\n     * @param   options\\n     *          options indicating how symbolic links are handled\\n     *\\n     * @return  a new and open {@code SecureDirectoryStream} object\\n     *\\n     * @throws  ClosedDirectoryStreamException\\n     *          if the directory stream is closed\\n     * @throws  NotDirectoryException\\n     *          if the file could not otherwise be opened because it is not\\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the directory.\\n     \u0027}"}, {"color": "#97c2fc", "id": "NOFOLLOW_LINKS", "label": "NOFOLLOW_LINKS", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " SeekableByteChannel newByteChannel(T path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "label": " SeekableByteChannel newByteChannel(T path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens or creates a file in this directory, returning a seekable byte\\n     * channel to access the file.\\n     *\\n     * \u003cp\u003e This method works in exactly the manner specified by the {@link\\n     * Files#newByteChannel Files.newByteChannel} method for the\\n     * case that the {@code path} parameter is an {@link Path#isAbsolute absolute}\\n     * path. When the parameter is a relative path then the file to open or\\n     * create is relative to this open directory. In addition to the options\\n     * defined by the {@code Files.newByteChannel} method, the {@link\\n     * LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} option may be used to\\n     * ensure that this method fails if the file is a symbolic link.\\n     *\\n     * \u003cp\u003e The channel, once created, is not dependent upon the directory stream\\n     * used to create it. Closing this directory stream has no effect upon the\\n     * channel.\\n     *\\n     * @param   path\\n     *          the path of the file to open or create\\n     * @param   options\\n     *          options specifying how the file is opened\\n     * @param   attrs\\n     *          an optional list of attributes to set atomically when creating\\n     *          the file\\n     *\\n     * @return  the seekable byte channel\\n     *\\n     * @throws  ClosedDirectoryStreamException\\n     *          if the directory stream is closed\\n     * @throws  IllegalArgumentException\\n     *          if the set contains an invalid combination of options\\n     * @throws  UnsupportedOperationException\\n     *          if an unsupported open option is specified or the array contains\\n     *          attributes that cannot be set atomically when creating the file\\n     * @throws  FileAlreadyExistsException\\n     *          if a file of that name already exists and the {@link\\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the path if the file\\n     *          is opened for reading. The {@link SecurityManager#checkWrite(String)\\n     *          checkWrite} method is invoked to check write access to the path\\n     *          if the file is opened for writing.\\n     \u0027}"}, {"color": "#97c2fc", "id": " void deleteFile(T path) throws IOException", "label": " void deleteFile(T path) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Deletes a file.\\n     *\\n     * \u003cp\u003e Unlike the {@link Files#delete delete()} method, this method does\\n     * not first examine the file to determine if the file is a directory.\\n     * Whether a directory is deleted by this method is system dependent and\\n     * therefore not specified. If the file is a symbolic link, then the link\\n     * itself, not the final target of the link, is deleted. When the\\n     * parameter is a relative path then the file to delete is relative to\\n     * this open directory.\\n     *\\n     * @param   path\\n     *          the path of the file to delete\\n     *\\n     * @throws  ClosedDirectoryStreamException\\n     *          if the directory stream is closed\\n     * @throws  NoSuchFileException\\n     *          if the file does not exist \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkDelete(String) checkDelete}\\n     *          method is invoked to check delete access to the file\\n     \u0027}"}, {"color": "#97c2fc", "id": " void deleteDirectory(T path) throws IOException", "label": " void deleteDirectory(T path) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Deletes a directory.\\n     *\\n     * \u003cp\u003e Unlike the {@link Files#delete delete()} method, this method\\n     * does not first examine the file to determine if the file is a directory.\\n     * Whether non-directories are deleted by this method is system dependent and\\n     * therefore not specified. When the parameter is a relative path then the\\n     * directory to delete is relative to this open directory.\\n     *\\n     * @param   path\\n     *          the path of the directory to delete\\n     *\\n     * @throws  ClosedDirectoryStreamException\\n     *          if the directory stream is closed\\n     * @throws  NoSuchFileException\\n     *          if the directory does not exist \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  DirectoryNotEmptyException\\n     *          if the directory could not otherwise be deleted because it is\\n     *          not empty \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkDelete(String) checkDelete}\\n     *          method is invoked to check delete access to the directory\\n     \u0027}"}, {"color": "#97c2fc", "id": " void move(T srcpath, SecureDirectoryStream\u003cT\u003e targetdir, T targetpath) throws IOException", "label": " void move(T srcpath, SecureDirectoryStream\u003cT\u003e targetdir, T targetpath) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Move a file from this directory to another directory.\\n     *\\n     * \u003cp\u003e This method works in a similar manner to {@link Files#move move}\\n     * method when the {@link StandardCopyOption#ATOMIC_MOVE ATOMIC_MOVE} option\\n     * is specified. That is, this method moves a file as an atomic file system\\n     * operation. If the {@code srcpath} parameter is an {@link Path#isAbsolute\\n     * absolute} path then it locates the source file. If the parameter is a\\n     * relative path then it is located relative to this open directory. If\\n     * the {@code targetpath} parameter is absolute then it locates the target\\n     * file (the {@code targetdir} parameter is ignored). If the parameter is\\n     * a relative path it is located relative to the open directory identified\\n     * by the {@code targetdir} parameter. In all cases, if the target file\\n     * exists then it is implementation specific if it is replaced or this\\n     * method fails.\\n     *\\n     * @param   srcpath\\n     *          the name of the file to move\\n     * @param   targetdir\\n     *          the destination directory\\n     * @param   targetpath\\n     *          the name to give the file in the destination directory\\n     *\\n     * @throws  ClosedDirectoryStreamException\\n     *          if this or the target directory stream is closed\\n     * @throws  FileAlreadyExistsException\\n     *          if the file already exists in the target directory and cannot\\n     *          be replaced \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  AtomicMoveNotSupportedException\\n     *          if the file cannot be moved as an atomic file system operation\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method is invoked to check write access to both the source and\\n     *          target file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "ATOMIC_MOVE", "label": "ATOMIC_MOVE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " V getFileAttributeView(Class\u003cV\u003e type)", "label": " V getFileAttributeView(Class\u003cV\u003e type)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a new file attribute view to access the file attributes of this\\n     * directory.\\n     *\\n     * \u003cp\u003e The resulting file attribute view can be used to read or update the\\n     * attributes of this (open) directory. The {@code type} parameter specifies\\n     * the type of the attribute view and the method returns an instance of that\\n     * type if supported. Invoking this method to obtain a {@link\\n     * BasicFileAttributeView} always returns an instance of that class that is\\n     * bound to this open directory.\\n     *\\n     * \u003cp\u003e The state of resulting file attribute view is intimately connected\\n     * to this directory stream. Once the directory stream is {@link #close closed},\\n     * then all methods to read or update attributes will throw {@link\\n     * ClosedDirectoryStreamException ClosedDirectoryStreamException}.\\n     *\\n     * @param   \u003cV\u003e\\n     *          The {@code FileAttributeView} type\\n     * @param   type\\n     *          the {@code Class} object corresponding to the file attribute view\\n     *\\n     * @return  a new file attribute view of the specified type bound to\\n     *          this directory stream, or {@code null} if the attribute view\\n     *          type is not available\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.ClosedDirectoryStreamException", "label": "java.nio.file.ClosedDirectoryStreamException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": " V getFileAttributeView(T path, Class\u003cV\u003e type, LinkOption... options)", "label": " V getFileAttributeView(T path, Class\u003cV\u003e type, LinkOption... options)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a new file attribute view to access the file attributes of a file\\n     * in this directory.\\n     *\\n     * \u003cp\u003e The resulting file attribute view can be used to read or update the\\n     * attributes of file in this directory. The {@code type} parameter specifies\\n     * the type of the attribute view and the method returns an instance of that\\n     * type if supported. Invoking this method to obtain a {@link\\n     * BasicFileAttributeView} always returns an instance of that class that is\\n     * bound to the file in the directory.\\n     *\\n     * \u003cp\u003e The state of resulting file attribute view is intimately connected\\n     * to this directory stream. Once the directory stream {@link #close closed},\\n     * then all methods to read or update attributes will throw {@link\\n     * ClosedDirectoryStreamException ClosedDirectoryStreamException}. The\\n     * file is not required to exist at the time that the file attribute view\\n     * is created but methods to read or update attributes of the file will\\n     * fail when invoked and the file does not exist.\\n     *\\n     * @param   \u003cV\u003e\\n     *          The {@code FileAttributeView} type\\n     * @param   path\\n     *          the path of the file\\n     * @param   type\\n     *          the {@code Class} object corresponding to the file attribute view\\n     * @param   options\\n     *          options indicating how symbolic links are handled\\n     *\\n     * @return  a new file attribute view of the specified type bound to a\\n     *          this directory stream, or {@code null} if the attribute view\\n     *          type is not available\\n     *\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, String glob) throws IOException", "label": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, String glob) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\\n     * the entries in the directory. The elements returned by the directory\\n     * stream\\\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\\n     * Path}, each one representing an entry in the directory. The {@code Path}\\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\\n     * name of the directory entry against {@code dir}. The entries returned by\\n     * the iterator are filtered by matching the {@code String} representation\\n     * of their file names against the given \u003cem\u003eglobbing\u003c/em\u003e pattern.\\n     *\\n     * \u003cp\u003e For example, suppose we want to iterate over the files ending with\\n     * \".java\" in a directory:\\n     * \u003cpre\u003e\\n     *     Path dir = ...\\n     *     try (DirectoryStream\u0026lt;Path\u0026gt; stream = Files.newDirectoryStream(dir, \"*.java\")) {\\n     *         :\\n     *     }\\n     * \u003c/pre\u003e\\n     *\\n     * \u003cp\u003e The globbing pattern is specified by the {@link\\n     * FileSystem#getPathMatcher getPathMatcher} method.\\n     *\\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\\n     * stream\\\u0027s {@code close} method should be invoked after iteration is\\n     * completed so as to free any resources held for the open directory.\\n     *\\n     * \u003cp\u003e When an implementation supports operations on entries in the\\n     * directory that execute in a race-free manner then the returned directory\\n     * stream is a {@link SecureDirectoryStream}.\\n     *\\n     * @param   dir\\n     *          the path to the directory\\n     * @param   glob\\n     *          the glob pattern\\n     *\\n     * @return  a new and open {@code DirectoryStream} object\\n     *\\n     * @throws  java.util.regex.PatternSyntaxException\\n     *          if the pattern is invalid\\n     * @throws  NotDirectoryException\\n     *          if the file could not otherwise be opened because it is not\\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the directory.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, DirectoryStream.Filter\u003c? super Path\u003e filter) throws IOException", "label": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, DirectoryStream.Filter\u003c? super Path\u003e filter) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\\n     * the entries in the directory. The elements returned by the directory\\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\\n     * Path}, each one representing an entry in the directory. The {@code Path}\\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\\n     * name of the directory entry against {@code dir}. The entries returned by\\n     * the iterator are filtered by the given {@link DirectoryStream.Filter\\n     * filter}.\\n     *\\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\\n     * stream\u0027s {@code close} method should be invoked after iteration is\\n     * completed so as to free any resources held for the open directory.\\n     *\\n     * \u003cp\u003e Where the filter terminates due to an uncaught error or runtime\\n     * exception then it is propagated to the {@link Iterator#hasNext()\\n     * hasNext} or {@link Iterator#next() next} method. Where an {@code\\n     * IOException} is thrown, it results in the {@code hasNext} or {@code\\n     * next} method throwing a {@link DirectoryIteratorException} with the\\n     * {@code IOException} as the cause.\\n     *\\n     * \u003cp\u003e When an implementation supports operations on entries in the\\n     * directory that execute in a race-free manner then the returned directory\\n     * stream is a {@link SecureDirectoryStream}.\\n     *\\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\\n     * Suppose we want to iterate over the files in a directory that are\\n     * larger than 8K.\\n     * \u003cpre\u003e\\n     *     DirectoryStream.Filter\u0026lt;Path\u0026gt; filter = new DirectoryStream.Filter\u0026lt;Path\u0026gt;() {\\n     *         public boolean accept(Path file) throws IOException {\\n     *             return (Files.size(file) \u0026gt; 8192L);\\n     *         }\\n     *     };\\n     *     Path dir = ...\\n     *     try (DirectoryStream\u0026lt;Path\u0026gt; stream = Files.newDirectoryStream(dir, filter)) {\\n     *         :\\n     *     }\\n     * \u003c/pre\u003e\\n     *\\n     * @param   dir\\n     *          the path to the directory\\n     * @param   filter\\n     *          the directory stream filter\\n     *\\n     * @return  a new and open {@code DirectoryStream} object\\n     *\\n     * @throws  NotDirectoryException\\n     *          if the file could not otherwise be opened because it is not\\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the directory.\\n     \"}"}, {"color": "#97c2fc", "id": "DirectoryStream.Filterfilter", "label": "DirectoryStream.Filterfilter", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "java.nio.file.DirectoryIteratorException", "label": "java.nio.file.DirectoryIteratorException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public IOException getCause()", "label": "public IOException getCause()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the cause of this exception.\\n     *\\n     * @return  the {@code IOException} which is the cause of this exception.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Path createFile(Path path, FileAttribute\u003c?\u003e... attrs) throws IOException", "label": "public static Path createFile(Path path, FileAttribute\u003c?\u003e... attrs) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a new and empty file, failing if the file already exists. The\\n     * check for the existence of the file and the creation of the new file if\\n     * it does not exist are a single operation that is atomic with respect to\\n     * all other filesystem activities that might affect the directory.\\n     *\\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\\n     * file-attributes} to set atomically when creating the file. Each attribute\\n     * is identified by its {@link FileAttribute#name name}. If more than one\\n     * attribute of the same name is included in the array then all but the last\\n     * occurrence is ignored.\\n     *\\n     * @param   path\\n     *          the path to the file to create\\n     * @param   attrs\\n     *          an optional list of file attributes to set atomically when\\n     *          creating the file\\n     *\\n     * @return  the file\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if the array contains an attribute that cannot be set atomically\\n     *          when creating the file\\n     * @throws  FileAlreadyExistsException\\n     *          if a file of that name already exists\\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs or the parent directory does not exist\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method is invoked to check write access to the new file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Path createDirectory(Path dir, FileAttribute\u003c?\u003e... attrs) throws IOException", "label": "public static Path createDirectory(Path dir, FileAttribute\u003c?\u003e... attrs) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a new directory. The check for the existence of the file and the\\n     * creation of the directory if it does not exist are a single operation\\n     * that is atomic with respect to all other filesystem activities that might\\n     * affect the directory. The {@link #createDirectories createDirectories}\\n     * method should be used where it is required to create all nonexistent\\n     * parent directories first.\\n     *\\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\\n     * file-attributes} to set atomically when creating the directory. Each\\n     * attribute is identified by its {@link FileAttribute#name name}. If more\\n     * than one attribute of the same name is included in the array then all but\\n     * the last occurrence is ignored.\\n     *\\n     * @param   dir\\n     *          the directory to create\\n     * @param   attrs\\n     *          an optional list of file attributes to set atomically when\\n     *          creating the directory\\n     *\\n     * @return  the directory\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if the array contains an attribute that cannot be set atomically\\n     *          when creating the directory\\n     * @throws  FileAlreadyExistsException\\n     *          if a directory could not otherwise be created because a file of\\n     *          that name already exists \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs or the parent directory does not exist\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method is invoked to check write access to the new directory.\\n     \u0027}"}, {"color": "#97c2fc", "id": "createDirectories", "label": "createDirectories", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static Path createDirectories(Path dir, FileAttribute\u003c?\u003e... attrs) throws IOException", "label": "public static Path createDirectories(Path dir, FileAttribute\u003c?\u003e... attrs) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a directory by creating all nonexistent parent directories first.\\n     * Unlike the {@link #createDirectory createDirectory} method, an exception\\n     * is not thrown if the directory could not be created because it already\\n     * exists.\\n     *\\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\\n     * file-attributes} to set atomically when creating the nonexistent\\n     * directories. Each file attribute is identified by its {@link\\n     * FileAttribute#name name}. If more than one attribute of the same name is\\n     * included in the array then all but the last occurrence is ignored.\\n     *\\n     * \u003cp\u003e If this method fails, then it may do so after creating some, but not\\n     * all, of the parent directories.\\n     *\\n     * @param   dir\\n     *          the directory to create\\n     *\\n     * @param   attrs\\n     *          an optional list of file attributes to set atomically when\\n     *          creating the directory\\n     *\\n     * @return  the directory\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if the array contains an attribute that cannot be set atomically\\n     *          when creating the directory\\n     * @throws  FileAlreadyExistsException\\n     *          if {@code dir} exists but is not a directory \u003ci\u003e(optional specific\\n     *          exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          in the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method is invoked prior to attempting to create a directory and\\n     *          its {@link SecurityManager#checkRead(String) checkRead} is\\n     *          invoked for each parent directory that is checked. If {@code\\n     *          dir} is not an absolute path then its {@link Path#toAbsolutePath\\n     *          toAbsolutePath} may need to be invoked to get its absolute path.\\n     *          This may invoke the security manager\u0027s {@link\\n     *          SecurityManager#checkPropertyAccess(String) checkPropertyAccess}\\n     *          method to check access to the system property {@code user.dir}\\n     \"}"}, {"color": "#97c2fc", "id": "createDirectory", "label": "createDirectory", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "checkPropertyAccess(String)", "label": "checkPropertyAccess(String)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "private static void createAndCheckIsDirectory(Path dir, FileAttribute\u003c?\u003e... attrs) throws IOException", "label": "private static void createAndCheckIsDirectory(Path dir, FileAttribute\u003c?\u003e... attrs) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Used by createDirectories to attempt to create a directory. A no-op\\n     * if the directory already exists.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Path createTempFile(Path dir, String prefix, String suffix, FileAttribute\u003c?\u003e... attrs) throws IOException", "label": "public static Path createTempFile(Path dir, String prefix, String suffix, FileAttribute\u003c?\u003e... attrs) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a new empty file in the specified directory, using the given\\n     * prefix and suffix strings to generate its name. The resulting\\n     * {@code Path} is associated with the same {@code FileSystem} as the given\\n     * directory.\\n     *\\n     * \u003cp\u003e The details as to how the name of the file is constructed is\\n     * implementation dependent and therefore not specified. Where possible\\n     * the {@code prefix} and {@code suffix} are used to construct candidate\\n     * names in the same manner as the {@link\\n     * java.io.File#createTempFile(String,String,File)} method.\\n     *\\n     * \u003cp\u003e As with the {@code File.createTempFile} methods, this method is only\\n     * part of a temporary-file facility. Where used as a \u003cem\u003ework files\u003c/em\u003e,\\n     * the resulting file may be opened using the {@link\\n     * StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} option so that the\\n     * file is deleted when the appropriate {@code close} method is invoked.\\n     * Alternatively, a {@link Runtime#addShutdownHook shutdown-hook}, or the\\n     * {@link java.io.File#deleteOnExit} mechanism may be used to delete the\\n     * file automatically.\\n     *\\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\\n     * file-attributes} to set atomically when creating the file. Each attribute\\n     * is identified by its {@link FileAttribute#name name}. If more than one\\n     * attribute of the same name is included in the array then all but the last\\n     * occurrence is ignored. When no file attributes are specified, then the\\n     * resulting file may have more restrictive access permissions to files\\n     * created by the {@link java.io.File#createTempFile(String,String,File)}\\n     * method.\\n     *\\n     * @param   dir\\n     *          the path to directory in which to create the file\\n     * @param   prefix\\n     *          the prefix string to be used in generating the file\\\u0027s name;\\n     *          may be {@code null}\\n     * @param   suffix\\n     *          the suffix string to be used in generating the file\\\u0027s name;\\n     *          may be {@code null}, in which case \"{@code .tmp}\" is used\\n     * @param   attrs\\n     *          an optional list of file attributes to set atomically when\\n     *          creating the file\\n     *\\n     * @return  the path to the newly created file that did not exist before\\n     *          this method was invoked\\n     *\\n     * @throws  IllegalArgumentException\\n     *          if the prefix or suffix parameters cannot be used to generate\\n     *          a candidate file name\\n     * @throws  UnsupportedOperationException\\n     *          if the array contains an attribute that cannot be set atomically\\n     *          when creating the directory\\n     * @throws  IOException\\n     *          if an I/O error occurs or {@code dir} does not exist\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method is invoked to check write access to the file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "addShutdownHook", "label": "addShutdownHook", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static Path createTempFile(String prefix, String suffix, FileAttribute\u003c?\u003e... attrs) throws IOException", "label": "public static Path createTempFile(String prefix, String suffix, FileAttribute\u003c?\u003e... attrs) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates an empty file in the default temporary-file directory, using\\n     * the given prefix and suffix to generate its name. The resulting {@code\\n     * Path} is associated with the default {@code FileSystem}.\\n     *\\n     * \u003cp\u003e This method works in exactly the manner specified by the\\n     * {@link #createTempFile(Path,String,String,FileAttribute[])} method for\\n     * the case that the {@code dir} parameter is the temporary-file directory.\\n     *\\n     * @param   prefix\\n     *          the prefix string to be used in generating the file\\\u0027s name;\\n     *          may be {@code null}\\n     * @param   suffix\\n     *          the suffix string to be used in generating the file\\\u0027s name;\\n     *          may be {@code null}, in which case \"{@code .tmp}\" is used\\n     * @param   attrs\\n     *          an optional list of file attributes to set atomically when\\n     *          creating the file\\n     *\\n     * @return  the path to the newly created file that did not exist before\\n     *          this method was invoked\\n     *\\n     * @throws  IllegalArgumentException\\n     *          if the prefix or suffix parameters cannot be used to generate\\n     *          a candidate file name\\n     * @throws  UnsupportedOperationException\\n     *          if the array contains an attribute that cannot be set atomically\\n     *          when creating the directory\\n     * @throws  IOException\\n     *          if an I/O error occurs or the temporary-file directory does not\\n     *          exist\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method is invoked to check write access to the file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "createTempFile(Path", "label": "createTempFile(Path", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static Path createTempDirectory(Path dir, String prefix, FileAttribute\u003c?\u003e... attrs) throws IOException", "label": "public static Path createTempDirectory(Path dir, String prefix, FileAttribute\u003c?\u003e... attrs) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a new directory in the specified directory, using the given\\n     * prefix to generate its name.  The resulting {@code Path} is associated\\n     * with the same {@code FileSystem} as the given directory.\\n     *\\n     * \u003cp\u003e The details as to how the name of the directory is constructed is\\n     * implementation dependent and therefore not specified. Where possible\\n     * the {@code prefix} is used to construct candidate names.\\n     *\\n     * \u003cp\u003e As with the {@code createTempFile} methods, this method is only\\n     * part of a temporary-file facility. A {@link Runtime#addShutdownHook\\n     * shutdown-hook}, or the {@link java.io.File#deleteOnExit} mechanism may be\\n     * used to delete the directory automatically.\\n     *\\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\\n     * file-attributes} to set atomically when creating the directory. Each\\n     * attribute is identified by its {@link FileAttribute#name name}. If more\\n     * than one attribute of the same name is included in the array then all but\\n     * the last occurrence is ignored.\\n     *\\n     * @param   dir\\n     *          the path to directory in which to create the directory\\n     * @param   prefix\\n     *          the prefix string to be used in generating the directory\u0027s name;\\n     *          may be {@code null}\\n     * @param   attrs\\n     *          an optional list of file attributes to set atomically when\\n     *          creating the directory\\n     *\\n     * @return  the path to the newly created directory that did not exist before\\n     *          this method was invoked\\n     *\\n     * @throws  IllegalArgumentException\\n     *          if the prefix cannot be used to generate a candidate directory name\\n     * @throws  UnsupportedOperationException\\n     *          if the array contains an attribute that cannot be set atomically\\n     *          when creating the directory\\n     * @throws  IOException\\n     *          if an I/O error occurs or {@code dir} does not exist\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method is invoked to check write access when creating the\\n     *          directory.\\n     \"}"}, {"color": "#97c2fc", "id": "addShutdownHookshutdown", "label": "addShutdownHookshutdown", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static Path createTempDirectory(String prefix, FileAttribute\u003c?\u003e... attrs) throws IOException", "label": "public static Path createTempDirectory(String prefix, FileAttribute\u003c?\u003e... attrs) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a new directory in the default temporary-file directory, using\\n     * the given prefix to generate its name. The resulting {@code Path} is\\n     * associated with the default {@code FileSystem}.\\n     *\\n     * \u003cp\u003e This method works in exactly the manner specified by {@link\\n     * #createTempDirectory(Path,String,FileAttribute[])} method for the case\\n     * that the {@code dir} parameter is the temporary-file directory.\\n     *\\n     * @param   prefix\\n     *          the prefix string to be used in generating the directory\u0027s name;\\n     *          may be {@code null}\\n     * @param   attrs\\n     *          an optional list of file attributes to set atomically when\\n     *          creating the directory\\n     *\\n     * @return  the path to the newly created directory that did not exist before\\n     *          this method was invoked\\n     *\\n     * @throws  IllegalArgumentException\\n     *          if the prefix cannot be used to generate a candidate directory name\\n     * @throws  UnsupportedOperationException\\n     *          if the array contains an attribute that cannot be set atomically\\n     *          when creating the directory\\n     * @throws  IOException\\n     *          if an I/O error occurs or the temporary-file directory does not\\n     *          exist\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method is invoked to check write access when creating the\\n     *          directory.\\n     \"}"}, {"color": "#97c2fc", "id": "createTempDirectory(Path", "label": "createTempDirectory(Path", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static Path createSymbolicLink(Path link, Path target, FileAttribute\u003c?\u003e... attrs) throws IOException", "label": "public static Path createSymbolicLink(Path link, Path target, FileAttribute\u003c?\u003e... attrs) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a symbolic link to a target \u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e The {@code target} parameter is the target of the link. It may be an\\n     * {@link Path#isAbsolute absolute} or relative path and may not exist. When\\n     * the target is a relative path then file system operations on the resulting\\n     * link are relative to the path of the link.\\n     *\\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\\n     * attributes} to set atomically when creating the link. Each attribute is\\n     * identified by its {@link FileAttribute#name name}. If more than one attribute\\n     * of the same name is included in the array then all but the last occurrence\\n     * is ignored.\\n     *\\n     * \u003cp\u003e Where symbolic links are supported, but the underlying {@link FileStore}\\n     * does not support symbolic links, then this may fail with an {@link\\n     * IOException}. Additionally, some operating systems may require that the\\n     * Java virtual machine be started with implementation specific privileges to\\n     * create symbolic links, in which case this method may throw {@code IOException}.\\n     *\\n     * @param   link\\n     *          the path of the symbolic link to create\\n     * @param   target\\n     *          the target of the symbolic link\\n     * @param   attrs\\n     *          the array of attributes to set atomically when creating the\\n     *          symbolic link\\n     *\\n     * @return  the path to the symbolic link\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if the implementation does not support symbolic links or the\\n     *          array contains an attribute that cannot be set atomically when\\n     *          creating the symbolic link\\n     * @throws  FileAlreadyExistsException\\n     *          if a file with the name already exists \u003ci\u003e(optional specific\\n     *          exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager\\n     *          is installed, it denies {@link LinkPermission}\u003ctt\u003e(\"symbolic\")\u003c/tt\u003e\\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method denies write access to the path of the symbolic link.\\n     \u0027}"}, {"color": "#97c2fc", "id": "FileAttributeattributes", "label": "FileAttributeattributes", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "java.nio.file.LinkPermission", "label": "java.nio.file.LinkPermission", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * The {@code Permission} class for link creation operations.\\n *\\n * \u003cp\u003e The following table provides a summary description of what the permission\\n * allows, and discusses the risks of granting code the permission.\\n *\\n * \u003ctable class=\"striped\"\u003e\\n * \u003ccaption style=\"display:none\"\u003eTable shows permission target name, what the permission allows, and associated risks\u003c/caption\u003e\\n * \u003cthead\u003e\\n * \u003ctr\u003e\\n * \u003cth scope=\"col\"\u003ePermission Target Name\u003c/th\u003e\\n * \u003cth scope=\"col\"\u003eWhat the Permission Allows\u003c/th\u003e\\n * \u003cth scope=\"col\"\u003eRisks of Allowing this Permission\u003c/th\u003e\\n * \u003c/tr\u003e\\n * \u003c/thead\u003e\\n * \u003ctbody\u003e\\n * \u003ctr\u003e\\n *   \u003cth scope=\"row\"\u003ehard\u003c/th\u003e\\n *   \u003ctd\u003e Ability to add an existing file to a directory. This is sometimes\\n *   known as creating a link, or hard link. \u003c/td\u003e\\n *   \u003ctd\u003e Extreme care should be taken when granting this permission. It allows\\n *   linking to any file or directory in the file system thus allowing the\\n *   attacker access to all files. \u003c/td\u003e\\n * \u003c/tr\u003e\\n * \u003ctr\u003e\\n *   \u003cth scope=\"row\"\u003esymbolic\u003c/th\u003e\\n *   \u003ctd\u003e Ability to create symbolic links. \u003c/td\u003e\\n *   \u003ctd\u003e Extreme care should be taken when granting this permission. It allows\\n *   linking to any file or directory in the file system thus allowing the\\n *   attacker to access to all files. \u003c/td\u003e\\n * \u003c/tr\u003e\\n * \u003c/tbody\u003e\\n * \u003c/table\u003e\\n *\\n * @since 1.7\\n *\\n * @see Files#createLink\\n * @see Files#createSymbolicLink\\n \u0027}"}, {"color": "#97c2fc", "id": "public static Path createLink(Path link, Path existing) throws IOException", "label": "public static Path createLink(Path link, Path existing) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a new link (directory entry) for an existing file \u003ci\u003e(optional\\n     * operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e The {@code link} parameter locates the directory entry to create.\\n     * The {@code existing} parameter is the path to an existing file. This\\n     * method creates a new directory entry for the file so that it can be\\n     * accessed using {@code link} as the path. On some file systems this is\\n     * known as creating a \"hard link\". Whether the file attributes are\\n     * maintained for the file or for each directory entry is file system\\n     * specific and therefore not specified. Typically, a file system requires\\n     * that all links (directory entries) for a file be on the same file system.\\n     * Furthermore, on some platforms, the Java virtual machine may require to\\n     * be started with implementation specific privileges to create hard links\\n     * or to create links to directories.\\n     *\\n     * @param   link\\n     *          the link (directory entry) to create\\n     * @param   existing\\n     *          a path to an existing file\\n     *\\n     * @return  the path to the link (directory entry)\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if the implementation does not support adding an existing file\\n     *          to a directory\\n     * @throws  FileAlreadyExistsException\\n     *          if the entry could not otherwise be created because a file of\\n     *          that name already exists \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager\\n     *          is installed, it denies {@link LinkPermission}\u003ctt\u003e(\"hard\")\u003c/tt\u003e\\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method denies write access to either the link or the\\n     *          existing file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void delete(Path path) throws IOException", "label": "public static void delete(Path path) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Deletes a file.\\n     *\\n     * \u003cp\u003e An implementation may require to examine the file to determine if the\\n     * file is a directory. Consequently this method may not be atomic with respect\\n     * to other file system operations.  If the file is a symbolic link then the\\n     * symbolic link itself, not the final target of the link, is deleted.\\n     *\\n     * \u003cp\u003e If the file is a directory then the directory must be empty. In some\\n     * implementations a directory has entries for special files or links that\\n     * are created when the directory is created. In such implementations a\\n     * directory is considered empty when only the special entries exist.\\n     * This method can be used with the {@link #walkFileTree walkFileTree}\\n     * method to delete a directory and all entries in the directory, or an\\n     * entire \u003ci\u003efile-tree\u003c/i\u003e where required.\\n     *\\n     * \u003cp\u003e On some operating systems it may not be possible to remove a file when\\n     * it is open and in use by this Java virtual machine or other programs.\\n     *\\n     * @param   path\\n     *          the path to the file to delete\\n     *\\n     * @throws  NoSuchFileException\\n     *          if the file does not exist \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  DirectoryNotEmptyException\\n     *          if the file is a directory and could not otherwise be deleted\\n     *          because the directory is not empty \u003ci\u003e(optional specific\\n     *          exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkDelete(String)} method\\n     *          is invoked to check delete access to the file\\n     \u0027}"}, {"color": "#97c2fc", "id": "walkFileTree", "label": "walkFileTree", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean deleteIfExists(Path path) throws IOException", "label": "public static boolean deleteIfExists(Path path) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Deletes a file if it exists.\\n     *\\n     * \u003cp\u003e As with the {@link #delete(Path) delete(Path)} method, an\\n     * implementation may need to examine the file to determine if the file is a\\n     * directory. Consequently this method may not be atomic with respect to\\n     * other file system operations.  If the file is a symbolic link, then the\\n     * symbolic link itself, not the final target of the link, is deleted.\\n     *\\n     * \u003cp\u003e If the file is a directory then the directory must be empty. In some\\n     * implementations a directory has entries for special files or links that\\n     * are created when the directory is created. In such implementations a\\n     * directory is considered empty when only the special entries exist.\\n     *\\n     * \u003cp\u003e On some operating systems it may not be possible to remove a file when\\n     * it is open and in use by this Java virtual machine or other programs.\\n     *\\n     * @param   path\\n     *          the path to the file to delete\\n     *\\n     * @return  {@code true} if the file was deleted by this method; {@code\\n     *          false} if the file could not be deleted because it did not\\n     *          exist\\n     *\\n     * @throws  DirectoryNotEmptyException\\n     *          if the file is a directory and could not otherwise be deleted\\n     *          because the directory is not empty \u003ci\u003e(optional specific\\n     *          exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkDelete(String)} method\\n     *          is invoked to check delete access to the file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "delete(Path)", "label": "delete(Path)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static Path copy(Path source, Path target, CopyOption... options) throws IOException", "label": "public static Path copy(Path source, Path target, CopyOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copy a file to a target file.\\n     *\\n     * \u003cp\u003e This method copies a file to the target file with the {@code\\n     * options} parameter specifying how the copy is performed. By default, the\\n     * copy fails if the target file already exists or is a symbolic link,\\n     * except if the source and target are the {@link #isSameFile same} file, in\\n     * which case the method completes without copying the file. File attributes\\n     * are not required to be copied to the target file. If symbolic links are\\n     * supported, and the file is a symbolic link, then the final target of the\\n     * link is copied. If the file is a directory then it creates an empty\\n     * directory in the target location (entries in the directory are not\\n     * copied). This method can be used with the {@link #walkFileTree\\n     * walkFileTree} method to copy a directory and all entries in the directory,\\n     * or an entire \u003ci\u003efile-tree\u003c/i\u003e where required.\\n     *\\n     * \u003cp\u003e The {@code options} parameter may include any of the following:\\n     *\\n     * \u003ctable border=1 cellpadding=5 summary=\"\"\u003e\\n     * \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} \u003c/td\u003e\\n     *   \u003ctd\u003e If the target file exists, then the target file is replaced if it\\n     *     is not a non-empty directory. If the target file exists and is a\\n     *     symbolic link, then the symbolic link itself, not the target of\\n     *     the link, is replaced. \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e {@link StandardCopyOption#COPY_ATTRIBUTES COPY_ATTRIBUTES} \u003c/td\u003e\\n     *   \u003ctd\u003e Attempts to copy the file attributes associated with this file to\\n     *     the target file. The exact file attributes that are copied is platform\\n     *     and file system dependent and therefore unspecified. Minimally, the\\n     *     {@link BasicFileAttributes#lastModifiedTime last-modified-time} is\\n     *     copied to the target file if supported by both the source and target\\n     *     file stores. Copying of file timestamps may result in precision\\n     *     loss. \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} \u003c/td\u003e\\n     *   \u003ctd\u003e Symbolic links are not followed. If the file is a symbolic link,\\n     *     then the symbolic link itself, not the target of the link, is copied.\\n     *     It is implementation specific if file attributes can be copied to the\\n     *     new link. In other words, the {@code COPY_ATTRIBUTES} option may be\\n     *     ignored when copying a symbolic link. \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003c/table\u003e\\n     *\\n     * \u003cp\u003e An implementation of this interface may support additional\\n     * implementation specific options.\\n     *\\n     * \u003cp\u003e Copying a file is not an atomic operation. If an {@link IOException}\\n     * is thrown, then it is possible that the target file is incomplete or some\\n     * of its file attributes have not been copied from the source file. When\\n     * the {@code REPLACE_EXISTING} option is specified and the target file\\n     * exists, then the target file is replaced. The check for the existence of\\n     * the file and the creation of the new file may not be atomic with respect\\n     * to other file system activities.\\n     *\\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\\n     * Suppose we want to copy a file into a directory, giving it the same file\\n     * name as the source file:\\n     * \u003cpre\u003e\\n     *     Path source = ...\\n     *     Path newdir = ...\\n     *     Files.copy(source, newdir.resolve(source.getFileName());\\n     * \u003c/pre\u003e\\n     *\\n     * @param   source\\n     *          the path to the file to copy\\n     * @param   target\\n     *          the path to the target file (may be associated with a different\\n     *          provider to the source path)\\n     * @param   options\\n     *          options specifying how the copy should be done\\n     *\\n     * @return  the path to the target file\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if the array contains a copy option that is not supported\\n     * @throws  FileAlreadyExistsException\\n     *          if the target file exists but cannot be replaced because the\\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\\n     *          specific exception)\u003c/i\u003e\\n     * @throws  DirectoryNotEmptyException\\n     *          the {@code REPLACE_EXISTING} option is specified but the file\\n     *          cannot be replaced because it is a non-empty directory\\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the source file, the\\n     *          {@link SecurityManager#checkWrite(String) checkWrite} is invoked\\n     *          to check write access to the target file. If a symbolic link is\\n     *          copied the security manager is invoked to check {@link\\n     *          LinkPermission}{@code (\"symbolic\")}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "lastModifiedTime", "label": "lastModifiedTime", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.attribute.BasicFileAttributes", "label": "java.nio.file.attribute.BasicFileAttributes", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": " FileTime lastModifiedTime()", "label": " FileTime lastModifiedTime()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the time of last modification.\\n     *\\n     * \u003cp\u003e If the file system implementation does not support a time stamp\\n     * to indicate the time of last modification then this method returns an\\n     * implementation specific default value, typically a {@code FileTime}\\n     * representing the epoch (1970-01-01T00:00:00Z).\\n     *\\n     * @return  a {@code FileTime} representing the time the file was last\\n     *          modified\\n     \u0027}"}, {"color": "#97c2fc", "id": " FileTime lastAccessTime()", "label": " FileTime lastAccessTime()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the time of last access.\\n     *\\n     * \u003cp\u003e If the file system implementation does not support a time stamp\\n     * to indicate the time of last access then this method returns\\n     * an implementation specific default value, typically the {@link\\n     * #lastModifiedTime() last-modified-time} or a {@code FileTime}\\n     * representing the epoch (1970-01-01T00:00:00Z).\\n     *\\n     * @return  a {@code FileTime} representing the time of last access\\n     \u0027}"}, {"color": "#97c2fc", "id": "lastModifiedTime()", "label": "lastModifiedTime()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " FileTime creationTime()", "label": " FileTime creationTime()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the creation time. The creation time is the time that the file\\n     * was created.\\n     *\\n     * \u003cp\u003e If the file system implementation does not support a time stamp\\n     * to indicate the time when the file was created then this method returns\\n     * an implementation specific default value, typically the {@link\\n     * #lastModifiedTime() last-modified-time} or a {@code FileTime}\\n     * representing the epoch (1970-01-01T00:00:00Z).\\n     *\\n     * @return   a {@code FileTime} representing the time the file was created\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean isRegularFile()", "label": " boolean isRegularFile()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether the file is a regular file with opaque content.\\n     *\\n     * @return {@code true} if the file is a regular file with opaque content\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean isDirectory()", "label": " boolean isDirectory()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether the file is a directory.\\n     *\\n     * @return {@code true} if the file is a directory\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean isSymbolicLink()", "label": " boolean isSymbolicLink()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether the file is a symbolic link.\\n     *\\n     * @return {@code true} if the file is a symbolic link\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean isOther()", "label": " boolean isOther()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether the file is something other than a regular file, directory,\\n     * or symbolic link.\\n     *\\n     * @return {@code true} if the file something other than a regular file,\\n     *         directory or symbolic link\\n     \u0027}"}, {"color": "#97c2fc", "id": " long size()", "label": " long size()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the size of the file (in bytes). The size may differ from the\\n     * actual size on the file system due to compression, support for sparse\\n     * files, or other reasons. The size of files that are not {@link\\n     * #isRegularFile regular} files is implementation specific and\\n     * therefore unspecified.\\n     *\\n     * @return  the file size, in bytes\\n     \u0027}"}, {"color": "#97c2fc", "id": "isRegularFile", "label": "isRegularFile", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " Object fileKey()", "label": " Object fileKey()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an object that uniquely identifies the given file, or {@code\\n     * null} if a file key is not available. On some platforms or file systems\\n     * it is possible to use an identifier, or a combination of identifiers to\\n     * uniquely identify a file. Such identifiers are important for operations\\n     * such as file tree traversal in file systems that support \u003ca\\n     * href=\"../package-summary.html#links\"\u003esymbolic links\u003c/a\u003e or file systems\\n     * that allow a file to be an entry in more than one directory. On UNIX file\\n     * systems, for example, the \u003cem\u003edevice ID\u003c/em\u003e and \u003cem\u003einode\u003c/em\u003e are\\n     * commonly used for such purposes.\\n     *\\n     * \u003cp\u003e The file key returned by this method can only be guaranteed to be\\n     * unique if the file system and files remain static. Whether a file system\\n     * re-uses identifiers after a file is deleted is implementation dependent and\\n     * therefore unspecified.\\n     *\\n     * \u003cp\u003e File keys returned by this method can be compared for equality and are\\n     * suitable for use in collections. If the file system and files remain static,\\n     * and two files are the {@link java.nio.file.Files#isSameFile same} with\\n     * non-{@code null} file keys, then their file keys are equal.\\n     *\\n     * @return an object that uniquely identifies the given file, or {@code null}\\n     *\\n     * @see java.nio.file.Files#walkFileTree\\n     \u0027}"}, {"color": "#97c2fc", "id": "REPLACE_EXISTING", "label": "REPLACE_EXISTING", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "walkFileTreewalkFileTree", "label": "walkFileTreewalkFileTree", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "COPY_ATTRIBUTES", "label": "COPY_ATTRIBUTES", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "isSameFile", "label": "isSameFile", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static Path move(Path source, Path target, CopyOption... options) throws IOException", "label": "public static Path move(Path source, Path target, CopyOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Move or rename a file to a target file.\\n     *\\n     * \u003cp\u003e By default, this method attempts to move the file to the target\\n     * file, failing if the target file exists except if the source and\\n     * target are the {@link #isSameFile same} file, in which case this method\\n     * has no effect. If the file is a symbolic link then the symbolic link\\n     * itself, not the target of the link, is moved. This method may be\\n     * invoked to move an empty directory. In some implementations a directory\\n     * has entries for special files or links that are created when the\\n     * directory is created. In such implementations a directory is considered\\n     * empty when only the special entries exist. When invoked to move a\\n     * directory that is not empty then the directory is moved if it does not\\n     * require moving the entries in the directory.  For example, renaming a\\n     * directory on the same {@link FileStore} will usually not require moving\\n     * the entries in the directory. When moving a directory requires that its\\n     * entries be moved then this method fails (by throwing an {@code\\n     * IOException}). To move a \u003ci\u003efile tree\u003c/i\u003e may involve copying rather\\n     * than moving directories and this can be done using the {@link\\n     * #copy copy} method in conjunction with the {@link\\n     * #walkFileTree Files.walkFileTree} utility method.\\n     *\\n     * \u003cp\u003e The {@code options} parameter may include any of the following:\\n     *\\n     * \u003ctable border=1 cellpadding=5 summary=\"\"\u003e\\n     * \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} \u003c/td\u003e\\n     *   \u003ctd\u003e If the target file exists, then the target file is replaced if it\\n     *     is not a non-empty directory. If the target file exists and is a\\n     *     symbolic link, then the symbolic link itself, not the target of\\n     *     the link, is replaced. \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e {@link StandardCopyOption#ATOMIC_MOVE ATOMIC_MOVE} \u003c/td\u003e\\n     *   \u003ctd\u003e The move is performed as an atomic file system operation and all\\n     *     other options are ignored. If the target file exists then it is\\n     *     implementation specific if the existing file is replaced or this method\\n     *     fails by throwing an {@link IOException}. If the move cannot be\\n     *     performed as an atomic file system operation then {@link\\n     *     AtomicMoveNotSupportedException} is thrown. This can arise, for\\n     *     example, when the target location is on a different {@code FileStore}\\n     *     and would require that the file be copied, or target location is\\n     *     associated with a different provider to this object. \u003c/td\u003e\\n     * \u003c/table\u003e\\n     *\\n     * \u003cp\u003e An implementation of this interface may support additional\\n     * implementation specific options.\\n     *\\n     * \u003cp\u003e Moving a file will copy the {@link\\n     * BasicFileAttributes#lastModifiedTime last-modified-time} to the target\\n     * file if supported by both source and target file stores. Copying of file\\n     * timestamps may result in precision loss. An implementation may also\\n     * attempt to copy other file attributes but is not required to fail if the\\n     * file attributes cannot be copied. When the move is performed as\\n     * a non-atomic operation, and an {@code IOException} is thrown, then the\\n     * state of the files is not defined. The original file and the target file\\n     * may both exist, the target file may be incomplete or some of its file\\n     * attributes may not been copied from the original file.\\n     *\\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\\n     * Suppose we want to rename a file to \"newname\", keeping the file in the\\n     * same directory:\\n     * \u003cpre\u003e\\n     *     Path source = ...\\n     *     Files.move(source, source.resolveSibling(\"newname\"));\\n     * \u003c/pre\u003e\\n     * Alternatively, suppose we want to move a file to new directory, keeping\\n     * the same file name, and replacing any existing file of that name in the\\n     * directory:\\n     * \u003cpre\u003e\\n     *     Path source = ...\\n     *     Path newdir = ...\\n     *     Files.move(source, newdir.resolve(source.getFileName()), REPLACE_EXISTING);\\n     * \u003c/pre\u003e\\n     *\\n     * @param   source\\n     *          the path to the file to move\\n     * @param   target\\n     *          the path to the target file (may be associated with a different\\n     *          provider to the source path)\\n     * @param   options\\n     *          options specifying how the move should be done\\n     *\\n     * @return  the path to the target file\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if the array contains a copy option that is not supported\\n     * @throws  FileAlreadyExistsException\\n     *          if the target file exists but cannot be replaced because the\\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\\n     *          specific exception)\u003c/i\u003e\\n     * @throws  DirectoryNotEmptyException\\n     *          the {@code REPLACE_EXISTING} option is specified but the file\\n     *          cannot be replaced because it is a non-empty directory\\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  AtomicMoveNotSupportedException\\n     *          if the options array contains the {@code ATOMIC_MOVE} option but\\n     *          the file cannot be moved as an atomic file system operation.\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method is invoked to check write access to both the source and\\n     *          target file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "copy", "label": "copy", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.AtomicMoveNotSupportedException", "label": "java.nio.file.AtomicMoveNotSupportedException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public static Path readSymbolicLink(Path link) throws IOException", "label": "public static Path readSymbolicLink(Path link) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads the target of a symbolic link \u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e If the file system supports \u003ca href=\"package-summary.html#links\"\u003esymbolic\\n     * links\u003c/a\u003e then this method is used to read the target of the link, failing\\n     * if the file is not a symbolic link. The target of the link need not exist.\\n     * The returned {@code Path} object will be associated with the same file\\n     * system as {@code link}.\\n     *\\n     * @param   link\\n     *          the path to the symbolic link\\n     *\\n     * @return  a {@code Path} object representing the target of the link\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if the implementation does not support symbolic links\\n     * @throws  NotLinkException\\n     *          if the target could otherwise not be read because the file\\n     *          is not a symbolic link \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager\\n     *          is installed, it checks that {@code FilePermission} has been\\n     *          granted with the \"{@code readlink}\" action to read the link.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static FileStore getFileStore(Path path) throws IOException", "label": "public static FileStore getFileStore(Path path) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the {@link FileStore} representing the file store where a file\\n     * is located.\\n     *\\n     * \u003cp\u003e Once a reference to the {@code FileStore} is obtained it is\\n     * implementation specific if operations on the returned {@code FileStore},\\n     * or {@link FileStoreAttributeView} objects obtained from it, continue\\n     * to depend on the existence of the file. In particular the behavior is not\\n     * defined for the case that the file is deleted or moved to a different\\n     * file store.\\n     *\\n     * @param   path\\n     *          the path to the file\\n     *\\n     * @return  the file store where the file is stored\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the file, and in\\n     *          addition it checks {@link RuntimePermission}\u003ctt\u003e\\n     *          (\"getFileStoreAttributes\")\u003c/tt\u003e\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.attribute.FileStoreAttributeView", "label": "java.nio.file.attribute.FileStoreAttributeView", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isSameFile(Path path, Path path2) throws IOException", "label": "public static boolean isSameFile(Path path, Path path2) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests if two paths locate the same file.\\n     *\\n     * \u003cp\u003e If both {@code Path} objects are {@link Path#equals(Object) equal}\\n     * then this method returns {@code true} without checking if the file exists.\\n     * If the two {@code Path} objects are associated with different providers\\n     * then this method returns {@code false}. Otherwise, this method checks if\\n     * both {@code Path} objects locate the same file, and depending on the\\n     * implementation, may require to open or access both files.\\n     *\\n     * \u003cp\u003e If the file system and files remain static, then this method implements\\n     * an equivalence relation for non-null {@code Paths}.\\n     * \u003cul\u003e\\n     * \u003cli\u003eIt is \u003ci\u003ereflexive\u003c/i\u003e: for {@code Path} {@code f},\\n     *     {@code isSameFile(f,f)} should return {@code true}.\\n     * \u003cli\u003eIt is \u003ci\u003esymmetric\u003c/i\u003e: for two {@code Paths} {@code f} and {@code g},\\n     *     {@code isSameFile(f,g)} will equal {@code isSameFile(g,f)}.\\n     * \u003cli\u003eIt is \u003ci\u003etransitive\u003c/i\u003e: for three {@code Paths}\\n     *     {@code f}, {@code g}, and {@code h}, if {@code isSameFile(f,g)} returns\\n     *     {@code true} and {@code isSameFile(g,h)} returns {@code true}, then\\n     *     {@code isSameFile(f,h)} will return return {@code true}.\\n     * \u003c/ul\u003e\\n     *\\n     * @param   path\\n     *          one path to the file\\n     * @param   path2\\n     *          the other path\\n     *\\n     * @return  {@code true} if, and only if, the two paths locate the same file\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to both files.\\n     *\\n     * @see java.nio.file.attribute.BasicFileAttributes#fileKey\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isHidden(Path path) throws IOException", "label": "public static boolean isHidden(Path path) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Tells whether or not a file is considered \u003cem\u003ehidden\u003c/em\u003e. The exact\\n     * definition of hidden is platform or provider dependent. On UNIX for\\n     * example a file is considered to be hidden if its name begins with a\\n     * period character (\u0027.\u0027). On Windows a file is considered hidden if it\\n     * isn\u0027t a directory and the DOS {@link DosFileAttributes#isHidden hidden}\\n     * attribute is set.\\n     *\\n     * \u003cp\u003e Depending on the implementation this method may require to access\\n     * the file system to determine if the file is considered hidden.\\n     *\\n     * @param   path\\n     *          the path to the file to test\\n     *\\n     * @return  {@code true} if the file is considered hidden\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the file.\\n     \"}"}, {"color": "#97c2fc", "id": "java.nio.file.attribute.DosFileAttributes", "label": "java.nio.file.attribute.DosFileAttributes", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": " boolean isReadOnly()", "label": " boolean isReadOnly()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value of the read-only attribute.\\n     *\\n     * \u003cp\u003e This attribute is often used as a simple access control mechanism\\n     * to prevent files from being deleted or updated. Whether the file system\\n     * or platform does any enforcement to prevent \u003cem\u003eread-only\u003c/em\u003e files\\n     * from being updated is implementation specific.\\n     *\\n     * @return  the value of the read-only attribute\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean isHidden()", "label": " boolean isHidden()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value of the hidden attribute.\\n     *\\n     * \u003cp\u003e This attribute is often used to indicate if the file is visible to\\n     * users.\\n     *\\n     * @return  the value of the hidden attribute\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean isArchive()", "label": " boolean isArchive()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value of the archive attribute.\\n     *\\n     * \u003cp\u003e This attribute is typically used by backup programs.\\n     *\\n     * @return  the value of the archive attribute\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean isSystem()", "label": " boolean isSystem()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value of the system attribute.\\n     *\\n     * \u003cp\u003e This attribute is often used to indicate that the file is a component\\n     * of the operating system.\\n     *\\n     * @return  the value of the system attribute\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String probeContentType(Path path) throws IOException", "label": "public static String probeContentType(Path path) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Probes the content type of a file.\\n     *\\n     * \u003cp\u003e This method uses the installed {@link FileTypeDetector} implementations\\n     * to probe the given file to determine its content type. Each file type\\n     * detector\\\u0027s {@link FileTypeDetector#probeContentType probeContentType} is\\n     * invoked, in turn, to probe the file type. If the file is recognized then\\n     * the content type is returned. If the file is not recognized by any of the\\n     * installed file type detectors then a system-default file type detector is\\n     * invoked to guess the content type.\\n     *\\n     * \u003cp\u003e A given invocation of the Java virtual machine maintains a system-wide\\n     * list of file type detectors. Installed file type detectors are loaded\\n     * using the service-provider loading facility defined by the {@link ServiceLoader}\\n     * class. Installed file type detectors are loaded using the system class\\n     * loader. If the system class loader cannot be found then the extension class\\n     * loader is used; If the extension class loader cannot be found then the\\n     * bootstrap class loader is used. File type detectors are typically installed\\n     * by placing them in a JAR file on the application class path or in the\\n     * extension directory, the JAR file contains a provider-configuration file\\n     * named {@code java.nio.file.spi.FileTypeDetector} in the resource directory\\n     * {@code META-INF/services}, and the file lists one or more fully-qualified\\n     * names of concrete subclass of {@code FileTypeDetector } that have a zero\\n     * argument constructor. If the process of locating or instantiating the\\n     * installed file type detectors fails then an unspecified error is thrown.\\n     * The ordering that installed providers are located is implementation\\n     * specific.\\n     *\\n     * \u003cp\u003e The return value of this method is the string form of the value of a\\n     * Multipurpose Internet Mail Extension (MIME) content type as\\n     * defined by \u003ca href=\"http://www.ietf.org/rfc/rfc2045.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;2045:\\n     * Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet\\n     * Message Bodies\u003c/i\u003e\u003c/a\u003e. The string is guaranteed to be parsable according\\n     * to the grammar in the RFC.\\n     *\\n     * @param   path\\n     *          the path to the file to probe\\n     *\\n     * @return  The content type of the file, or {@code null} if the content\\n     *          type cannot be determined\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          If a security manager is installed and it denies an unspecified\\n     *          permission required by a file type detector implementation.\\n     \u0027}"}, {"color": "#97c2fc", "id": "probeContentType", "label": "probeContentType", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.spi.FileTypeDetector", "label": "java.nio.file.spi.FileTypeDetector", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public abstract String probeContentType(Path path) throws IOException", "label": "public abstract String probeContentType(Path path) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Probes the given file to guess its content type.\\n     *\\n     * \u003cp\u003e The means by which this method determines the file type is highly\\n     * implementation specific. It may simply examine the file name, it may use\\n     * a file \u003ca href=\"../attribute/package-summary.html\"\u003eattribute\u003c/a\u003e,\\n     * or it may examines bytes in the file.\\n     *\\n     * \u003cp\u003e The probe result is the string form of the value of a\\n     * Multipurpose Internet Mail Extension (MIME) content type as\\n     * defined by \u003ca href=\"http://www.ietf.org/rfc/rfc2045.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;2045:\\n     * Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet\\n     * Message Bodies\u003c/i\u003e\u003c/a\u003e. The string must be parsable according to the\\n     * grammar in the RFC 2045.\\n     *\\n     * @param   path\\n     *          the path to the file to probe\\n     *\\n     * @return  The content type or {@code null} if the file type is not\\n     *          recognized\\n     *\\n     * @throws  IOException\\n     *          An I/O error occurs\\n     * @throws  SecurityException\\n     *          If the implementation requires to access the file, and a\\n     *          security manager is installed, and it denies an unspecified\\n     *          permission required by a file system provider implementation.\\n     *          If the file reference is associated with the default file system\\n     *          provider then the {@link SecurityManager#checkRead(String)} method\\n     *          is invoked to check read access to the file.\\n     *\\n     * @see java.nio.file.Files#probeContentType\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.util.ServiceLoader", "label": "java.util.ServiceLoader", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public static V getFileAttributeView(Path path, Class\u003cV\u003e type, LinkOption... options)", "label": "public static V getFileAttributeView(Path path, Class\u003cV\u003e type, LinkOption... options)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a file attribute view of a given type.\\n     *\\n     * \u003cp\u003e A file attribute view provides a read-only or updatable view of a\\n     * set of file attributes. This method is intended to be used where the file\\n     * attribute view defines type-safe methods to read or update the file\\n     * attributes. The {@code type} parameter is the type of the attribute view\\n     * required and the method returns an instance of that type if supported.\\n     * The {@link BasicFileAttributeView} type supports access to the basic\\n     * attributes of a file. Invoking this method to select a file attribute\\n     * view of that type will always return an instance of that class.\\n     *\\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\\n     * are handled by the resulting file attribute view for the case that the\\n     * file is a symbolic link. By default, symbolic links are followed. If the\\n     * option {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} is present then\\n     * symbolic links are not followed. This option is ignored by implementations\\n     * that do not support symbolic links.\\n     *\\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\\n     * Suppose we want read or set a file\u0027s ACL, if supported:\\n     * \u003cpre\u003e\\n     *     Path path = ...\\n     *     AclFileAttributeView view = Files.getFileAttributeView(path, AclFileAttributeView.class);\\n     *     if (view != null) {\\n     *         List\u0026lt;AclEntry\u0026gt; acl = view.getAcl();\\n     *         :\\n     *     }\\n     * \u003c/pre\u003e\\n     *\\n     * @param   \u003cV\u003e\\n     *          The {@code FileAttributeView} type\\n     * @param   path\\n     *          the path to the file\\n     * @param   type\\n     *          the {@code Class} object corresponding to the file attribute view\\n     * @param   options\\n     *          options indicating how symbolic links are handled\\n     *\\n     * @return  a file attribute view of the specified type, or {@code null} if\\n     *          the attribute view type is not available\\n     \"}"}, {"color": "#97c2fc", "id": "java.nio.file.attribute.BasicFileAttributeView", "label": "java.nio.file.attribute.BasicFileAttributeView", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": " BasicFileAttributes readAttributes() throws IOException", "label": " BasicFileAttributes readAttributes() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads the basic file attributes as a bulk operation.\\n     *\\n     * \u003cp\u003e It is implementation specific if all file attributes are read as an\\n     * atomic operation with respect to other file system operations.\\n     *\\n     * @return  the file attributes\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, a security manager is\\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the file\\n     \u0027}"}, {"color": "#97c2fc", "id": " void setTimes(FileTime lastModifiedTime, FileTime lastAccessTime, FileTime createTime) throws IOException", "label": " void setTimes(FileTime lastModifiedTime, FileTime lastAccessTime, FileTime createTime) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Updates any or all of the file\u0027s last modified time, last access time,\\n     * and create time attributes.\\n     *\\n     * \u003cp\u003e This method updates the file\u0027s timestamp attributes. The values are\\n     * converted to the epoch and precision supported by the file system.\\n     * Converting from finer to coarser granularities result in precision loss.\\n     * The behavior of this method when attempting to set a timestamp that is\\n     * not supported or to a value that is outside the range supported by the\\n     * underlying file store is not defined. It may or not fail by throwing an\\n     * {@code IOException}.\\n     *\\n     * \u003cp\u003e If any of the {@code lastModifiedTime}, {@code lastAccessTime},\\n     * or {@code createTime} parameters has the value {@code null} then the\\n     * corresponding timestamp is not changed. An implementation may require to\\n     * read the existing values of the file attributes when only some, but not\\n     * all, of the timestamp attributes are updated. Consequently, this method\\n     * may not be an atomic operation with respect to other file system\\n     * operations. Reading and re-writing existing values may also result in\\n     * precision loss. If all of the {@code lastModifiedTime}, {@code\\n     * lastAccessTime} and {@code createTime} parameters are {@code null} then\\n     * this method has no effect.\\n     *\\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\\n     * Suppose we want to change a file\u0027s last access time.\\n     * \u003cpre\u003e\\n     *    Path path = ...\\n     *    FileTime time = ...\\n     *    Files.getFileAttributeView(path, BasicFileAttributeView.class).setTimes(null, time, null);\\n     * \u003c/pre\u003e\\n     *\\n     * @param   lastModifiedTime\\n     *          the new last modified time, or {@code null} to not change the\\n     *          value\\n     * @param   lastAccessTime\\n     *          the last access time, or {@code null} to not change the value\\n     * @param   createTime\\n     *          the file\u0027s create time, or {@code null} to not change the value\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, a security manager is\\n     *          installed, its  {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method is invoked to check write access to the file\\n     *\\n     * @see java.nio.file.Files#setLastModifiedTime\\n     \"}"}, {"color": "#97c2fc", "id": "public static A readAttributes(Path path, Class\u003cA\u003e type, LinkOption... options) throws IOException", "label": "public static A readAttributes(Path path, Class\u003cA\u003e type, LinkOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reads a file\u0027s attributes as a bulk operation.\\n     *\\n     * \u003cp\u003e The {@code type} parameter is the type of the attributes required\\n     * and this method returns an instance of that type if supported. All\\n     * implementations support a basic set of file attributes and so invoking\\n     * this method with a  {@code type} parameter of {@code\\n     * BasicFileAttributes.class} will not throw {@code\\n     * UnsupportedOperationException}.\\n     *\\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\\n     * are handled for the case that the file is a symbolic link. By default,\\n     * symbolic links are followed and the file attribute of the final target\\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\\n     *\\n     * \u003cp\u003e It is implementation specific if all file attributes are read as an\\n     * atomic operation with respect to other file system operations.\\n     *\\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\\n     * Suppose we want to read a file\u0027s attributes in bulk:\\n     * \u003cpre\u003e\\n     *    Path path = ...\\n     *    BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);\\n     * \u003c/pre\u003e\\n     * Alternatively, suppose we want to read file\u0027s POSIX attributes without\\n     * following symbolic links:\\n     * \u003cpre\u003e\\n     *    PosixFileAttributes attrs = Files.readAttributes(path, PosixFileAttributes.class, NOFOLLOW_LINKS);\\n     * \u003c/pre\u003e\\n     *\\n     * @param   \u003cA\u003e\\n     *          The {@code BasicFileAttributes} type\\n     * @param   path\\n     *          the path to the file\\n     * @param   type\\n     *          the {@code Class} of the file attributes required\\n     *          to read\\n     * @param   options\\n     *          options indicating how symbolic links are handled\\n     *\\n     * @return  the file attributes\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if an attributes of the given type are not supported\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, a security manager is\\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the file. If this\\n     *          method is invoked to read security sensitive attributes then the\\n     *          security manager may be invoke to check for additional permissions.\\n     \"}"}, {"color": "#97c2fc", "id": "NOFOLLOW_LINKSNOFOLLOW_LINKS", "label": "NOFOLLOW_LINKSNOFOLLOW_LINKS", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static Path setAttribute(Path path, String attribute, Object value, LinkOption... options) throws IOException", "label": "public static Path setAttribute(Path path, String attribute, Object value, LinkOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the value of a file attribute.\\n     *\\n     * \u003cp\u003e The {@code attribute} parameter identifies the attribute to be set\\n     * and takes the form:\\n     * \u003cblockquote\u003e\\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-name\u003c/i\u003e\\n     * \u003c/blockquote\u003e\\n     * where square brackets [...] delineate an optional component and the\\n     * character {@code \\\u0027:\\\u0027} stands for itself.\\n     *\\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\\n     * FileAttributeView} that identifies a set of file attributes. If not\\n     * specified then it defaults to {@code \"basic\"}, the name of the file\\n     * attribute view that identifies the basic set of file attributes common to\\n     * many file systems. \u003ci\u003eattribute-name\u003c/i\u003e is the name of the attribute\\n     * within the set.\\n     *\\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\\n     * are handled for the case that the file is a symbolic link. By default,\\n     * symbolic links are followed and the file attribute of the final target\\n     * of the link is set. If the option {@link LinkOption#NOFOLLOW_LINKS\\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\\n     *\\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\\n     * Suppose we want to set the DOS \"hidden\" attribute:\\n     * \u003cpre\u003e\\n     *    Path path = ...\\n     *    Files.setAttribute(path, \"dos:hidden\", true);\\n     * \u003c/pre\u003e\\n     *\\n     * @param   path\\n     *          the path to the file\\n     * @param   attribute\\n     *          the attribute to set\\n     * @param   value\\n     *          the attribute value\\n     * @param   options\\n     *          options indicating how symbolic links are handled\\n     *\\n     * @return  the {@code path} parameter\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if the attribute view is not available\\n     * @throws  IllegalArgumentException\\n     *          if the attribute name is not specified, or is not recognized, or\\n     *          the attribute value is of the correct type but has an\\n     *          inappropriate value\\n     * @throws  ClassCastException\\n     *          if the attribute value is not of the expected type or is a\\n     *          collection containing elements that are not of the expected\\n     *          type\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, its {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method denies write access to the file. If this method is invoked\\n     *          to set security sensitive attributes then the security manager\\n     *          may be invoked to check for additional permissions.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Object getAttribute(Path path, String attribute, LinkOption... options) throws IOException", "label": "public static Object getAttribute(Path path, String attribute, LinkOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads the value of a file attribute.\\n     *\\n     * \u003cp\u003e The {@code attribute} parameter identifies the attribute to be read\\n     * and takes the form:\\n     * \u003cblockquote\u003e\\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-name\u003c/i\u003e\\n     * \u003c/blockquote\u003e\\n     * where square brackets [...] delineate an optional component and the\\n     * character {@code \\\u0027:\\\u0027} stands for itself.\\n     *\\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\\n     * FileAttributeView} that identifies a set of file attributes. If not\\n     * specified then it defaults to {@code \"basic\"}, the name of the file\\n     * attribute view that identifies the basic set of file attributes common to\\n     * many file systems. \u003ci\u003eattribute-name\u003c/i\u003e is the name of the attribute.\\n     *\\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\\n     * are handled for the case that the file is a symbolic link. By default,\\n     * symbolic links are followed and the file attribute of the final target\\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\\n     *\\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\\n     * Suppose we require the user ID of the file owner on a system that\\n     * supports a \"{@code unix}\" view:\\n     * \u003cpre\u003e\\n     *    Path path = ...\\n     *    int uid = (Integer)Files.getAttribute(path, \"unix:uid\");\\n     * \u003c/pre\u003e\\n     *\\n     * @param   path\\n     *          the path to the file\\n     * @param   attribute\\n     *          the attribute to read\\n     * @param   options\\n     *          options indicating how symbolic links are handled\\n     *\\n     * @return  the attribute value\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if the attribute view is not available\\n     * @throws  IllegalArgumentException\\n     *          if the attribute name is not specified or is not recognized\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\\n     *          method denies read access to the file. If this method is invoked\\n     *          to read security sensitive attributes then the security manager\\n     *          may be invoked to check for additional permissions.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Map\u003cString, Object\u003e readAttributes(Path path, String attributes, LinkOption... options) throws IOException", "label": "public static Map\u003cString, Object\u003e readAttributes(Path path, String attributes, LinkOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads a set of file attributes as a bulk operation.\\n     *\\n     * \u003cp\u003e The {@code attributes} parameter identifies the attributes to be read\\n     * and takes the form:\\n     * \u003cblockquote\u003e\\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-list\u003c/i\u003e\\n     * \u003c/blockquote\u003e\\n     * where square brackets [...] delineate an optional component and the\\n     * character {@code \\\u0027:\\\u0027} stands for itself.\\n     *\\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\\n     * FileAttributeView} that identifies a set of file attributes. If not\\n     * specified then it defaults to {@code \"basic\"}, the name of the file\\n     * attribute view that identifies the basic set of file attributes common to\\n     * many file systems.\\n     *\\n     * \u003cp\u003e The \u003ci\u003eattribute-list\u003c/i\u003e component is a comma separated list of\\n     * zero or more names of attributes to read. If the list contains the value\\n     * {@code \"*\"} then all attributes are read. Attributes that are not supported\\n     * are ignored and will not be present in the returned map. It is\\n     * implementation specific if all attributes are read as an atomic operation\\n     * with respect to other file system operations.\\n     *\\n     * \u003cp\u003e The following examples demonstrate possible values for the {@code\\n     * attributes} parameter:\\n     *\\n     * \u003cblockquote\u003e\\n     * \u003ctable border=\"0\" summary=\"Possible values\"\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e {@code \"*\"} \u003c/td\u003e\\n     *   \u003ctd\u003e Read all {@link BasicFileAttributes basic-file-attributes}. \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e {@code \"size,lastModifiedTime,lastAccessTime\"} \u003c/td\u003e\\n     *   \u003ctd\u003e Reads the file size, last modified time, and last access time\\n     *     attributes. \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e {@code \"posix:*\"} \u003c/td\u003e\\n     *   \u003ctd\u003e Read all {@link PosixFileAttributes POSIX-file-attributes}. \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e {@code \"posix:permissions,owner,size\"} \u003c/td\u003e\\n     *   \u003ctd\u003e Reads the POSX file permissions, owner, and file size. \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003c/table\u003e\\n     * \u003c/blockquote\u003e\\n     *\\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\\n     * are handled for the case that the file is a symbolic link. By default,\\n     * symbolic links are followed and the file attribute of the final target\\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\\n     *\\n     * @param   path\\n     *          the path to the file\\n     * @param   attributes\\n     *          the attributes to read\\n     * @param   options\\n     *          options indicating how symbolic links are handled\\n     *\\n     * @return  a map of the attributes returned; The map\\\u0027s keys are the\\n     *          attribute names, its values are the attribute values\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if the attribute view is not available\\n     * @throws  IllegalArgumentException\\n     *          if no attributes are specified or an unrecognized attributes is\\n     *          specified\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\\n     *          method denies read access to the file. If this method is invoked\\n     *          to read security sensitive attributes then the security manager\\n     *          may be invoke to check for additional permissions.\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.attribute.PosixFileAttributes", "label": "java.nio.file.attribute.PosixFileAttributes", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": " UserPrincipal owner()", "label": " UserPrincipal owner()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the owner of the file.\\n     *\\n     * @return  the file owner\\n     *\\n     * @see PosixFileAttributeView#setOwner\\n     \u0027}"}, {"color": "#97c2fc", "id": " GroupPrincipal group()", "label": " GroupPrincipal group()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the group owner of the file.\\n     *\\n     * @return  the file group owner\\n     *\\n     * @see PosixFileAttributeView#setGroup\\n     \u0027}"}, {"color": "#97c2fc", "id": " Set\u003cPosixFilePermission\u003e permissions()", "label": " Set\u003cPosixFilePermission\u003e permissions()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the permissions of the file. The file permissions are returned\\n     * as a set of {@link PosixFilePermission} elements. The returned set is a\\n     * copy of the file permissions and is modifiable. This allows the result\\n     * to be modified and passed to the {@link PosixFileAttributeView#setPermissions\\n     * setPermissions} method to update the file\u0027s permissions.\\n     *\\n     * @return  the file permissions\\n     *\\n     * @see PosixFileAttributeView#setPermissions\\n     \"}"}, {"color": "#97c2fc", "id": "java.nio.file.attribute.PosixFilePermission", "label": "java.nio.file.attribute.PosixFilePermission", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "setPermissionssetPermissions", "label": "setPermissionssetPermissions", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.attribute.PosixFileAttributeView", "label": "java.nio.file.attribute.PosixFileAttributeView", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": " PosixFileAttributes readAttributes() throws IOException", "label": " PosixFileAttributes readAttributes() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * @throws  IOException                {@inheritDoc}\\n     * @throws  SecurityException\\n     *          In the case of the default provider, a security manager is\\n     *          installed, and it denies\\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\\n     *          or its {@link SecurityManager#checkRead(String) checkRead} method\\n     *          denies read access to the file.\\n     \u0027}"}, {"color": "#97c2fc", "id": " void setPermissions(Set\u003cPosixFilePermission\u003e perms) throws IOException", "label": " void setPermissions(Set\u003cPosixFilePermission\u003e perms) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Updates the file permissions.\\n     *\\n     * @param   perms\\n     *          the new set of permissions\\n     *\\n     * @throws  ClassCastException\\n     *          if the sets contains elements that are not of type {@code\\n     *          PosixFilePermission}\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, a security manager is\\n     *          installed, and it denies\\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method denies write access to the file.\\n     \u0027}"}, {"color": "#97c2fc", "id": " void setGroup(GroupPrincipal group) throws IOException", "label": " void setGroup(GroupPrincipal group) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Updates the file group-owner.\\n     *\\n     * @param   group\\n     *          the new file group-owner\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, it denies\\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method denies write access to the file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Set\u003cPosixFilePermission\u003e getPosixFilePermissions(Path path, LinkOption... options) throws IOException", "label": "public static Set\u003cPosixFilePermission\u003e getPosixFilePermissions(Path path, LinkOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a file\\\u0027s POSIX file permissions.\\n     *\\n     * \u003cp\u003e The {@code path} parameter is associated with a {@code FileSystem}\\n     * that supports the {@link PosixFileAttributeView}. This attribute view\\n     * provides access to file attributes commonly associated with files on file\\n     * systems used by operating systems that implement the Portable Operating\\n     * System Interface (POSIX) family of standards.\\n     *\\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\\n     * are handled for the case that the file is a symbolic link. By default,\\n     * symbolic links are followed and the file attribute of the final target\\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\\n     *\\n     * @param   path\\n     *          the path to the file\\n     * @param   options\\n     *          options indicating how symbolic links are handled\\n     *\\n     * @return  the file permissions\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if the associated file system does not support the {@code\\n     *          PosixFileAttributeView}\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, a security manager is\\n     *          installed, and it denies {@link RuntimePermission}\u003ctt\u003e(\"accessUserInformation\")\u003c/tt\u003e\\n     *          or its {@link SecurityManager#checkRead(String) checkRead} method\\n     *          denies read access to the file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Path setPosixFilePermissions(Path path, Set\u003cPosixFilePermission\u003e perms) throws IOException", "label": "public static Path setPosixFilePermissions(Path path, Set\u003cPosixFilePermission\u003e perms) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets a file\\\u0027s POSIX permissions.\\n     *\\n     * \u003cp\u003e The {@code path} parameter is associated with a {@code FileSystem}\\n     * that supports the {@link PosixFileAttributeView}. This attribute view\\n     * provides access to file attributes commonly associated with files on file\\n     * systems used by operating systems that implement the Portable Operating\\n     * System Interface (POSIX) family of standards.\\n     *\\n     * @param   path\\n     *          The path to the file\\n     * @param   perms\\n     *          The new set of permissions\\n     *\\n     * @return  The path\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if the associated file system does not support the {@code\\n     *          PosixFileAttributeView}\\n     * @throws  ClassCastException\\n     *          if the sets contains elements that are not of type {@code\\n     *          PosixFilePermission}\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, it denies {@link RuntimePermission}\u003ctt\u003e(\"accessUserInformation\")\u003c/tt\u003e\\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method denies write access to the file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static UserPrincipal getOwner(Path path, LinkOption... options) throws IOException", "label": "public static UserPrincipal getOwner(Path path, LinkOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the owner of a file.\\n     *\\n     * \u003cp\u003e The {@code path} parameter is associated with a file system that\\n     * supports {@link FileOwnerAttributeView}. This file attribute view provides\\n     * access to a file attribute that is the owner of the file.\\n     *\\n     * @param   path\\n     *          The path to the file\\n     * @param   options\\n     *          options indicating how symbolic links are handled\\n     *\\n     * @return  A user principal representing the owner of the file\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if the associated file system does not support the {@code\\n     *          FileOwnerAttributeView}\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, it denies {@link RuntimePermission}\u003ctt\u003e(\"accessUserInformation\")\u003c/tt\u003e\\n     *          or its {@link SecurityManager#checkRead(String) checkRead} method\\n     *          denies read access to the file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.attribute.FileOwnerAttributeView", "label": "java.nio.file.attribute.FileOwnerAttributeView", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": " UserPrincipal getOwner() throws IOException", "label": " UserPrincipal getOwner() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Read the file owner.\\n     *\\n     * \u003cp\u003e It is implementation specific if the file owner can be a {@link\\n     * GroupPrincipal group}.\\n     *\\n     * @return  the file owner\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, a security manager is\\n     *          installed, and it denies {@link\\n     *          RuntimePermission}{@code (\"accessUserInformation\")} or its\\n     *          {@link SecurityManager#checkRead(String) checkRead} method\\n     *          denies read access to the file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.attribute.GroupPrincipal", "label": "java.nio.file.attribute.GroupPrincipal", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": " void setOwner(UserPrincipal owner) throws IOException", "label": " void setOwner(UserPrincipal owner) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Updates the file owner.\\n     *\\n     * \u003cp\u003e It is implementation specific if the file owner can be a {@link\\n     * GroupPrincipal group}. To ensure consistent and correct behavior\\n     * across platforms it is recommended that this method should only be used\\n     * to set the file owner to a user principal that is not a group.\\n     *\\n     * @param   owner\\n     *          the new file owner\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs, or the {@code owner} parameter is a\\n     *          group and this implementation does not support setting the owner\\n     *          to a group\\n     * @throws  SecurityException\\n     *          In the case of the default provider, a security manager is\\n     *          installed, and it denies {@link\\n     *          RuntimePermission}{@code (\"accessUserInformation\")} or its\\n     *          {@link SecurityManager#checkWrite(String) checkWrite} method\\n     *          denies write access to the file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Path setOwner(Path path, UserPrincipal owner) throws IOException", "label": "public static Path setOwner(Path path, UserPrincipal owner) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Updates the file owner.\\n     *\\n     * \u003cp\u003e The {@code path} parameter is associated with a file system that\\n     * supports {@link FileOwnerAttributeView}. This file attribute view provides\\n     * access to a file attribute that is the owner of the file.\\n     *\\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\\n     * Suppose we want to make \"joe\" the owner of a file:\\n     * \u003cpre\u003e\\n     *     Path path = ...\\n     *     UserPrincipalLookupService lookupService =\\n     *         provider(path).getUserPrincipalLookupService();\\n     *     UserPrincipal joe = lookupService.lookupPrincipalByName(\"joe\");\\n     *     Files.setOwner(path, joe);\\n     * \u003c/pre\u003e\\n     *\\n     * @param   path\\n     *          The path to the file\\n     * @param   owner\\n     *          The new file owner\\n     *\\n     * @return  The path\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if the associated file system does not support the {@code\\n     *          FileOwnerAttributeView}\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, it denies {@link RuntimePermission}\u003ctt\u003e(\"accessUserInformation\")\u003c/tt\u003e\\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method denies write access to the file.\\n     *\\n     * @see FileSystem#getUserPrincipalLookupService\\n     * @see java.nio.file.attribute.UserPrincipalLookupService\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isSymbolicLink(Path path)", "label": "public static boolean isSymbolicLink(Path path)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests whether a file is a symbolic link.\\n     *\\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\\n     * that the file is not a symbolic link then the file attributes can be\\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\\n     * readAttributes} method and the file type tested with the {@link\\n     * BasicFileAttributes#isSymbolicLink} method.\\n     *\\n     * @param   path  The path to the file\\n     *\\n     * @return  {@code true} if the file is a symbolic link; {@code false} if\\n     *          the file does not exist, is not a symbolic link, or it cannot\\n     *          be determined if the file is a symbolic link or not.\\n     *\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\\n     *          method denies read access to the file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "readAttributes(Path", "label": "readAttributes(Path", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static boolean isDirectory(Path path, LinkOption... options)", "label": "public static boolean isDirectory(Path path, LinkOption... options)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests whether a file is a directory.\\n     *\\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\\n     * are handled for the case that the file is a symbolic link. By default,\\n     * symbolic links are followed and the file attribute of the final target\\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\\n     *\\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\\n     * that the file is not a directory then the file attributes can be\\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\\n     * readAttributes} method and the file type tested with the {@link\\n     * BasicFileAttributes#isDirectory} method.\\n     *\\n     * @param   path\\n     *          the path to the file to test\\n     * @param   options\\n     *          options indicating how symbolic links are handled\\n     *\\n     * @return  {@code true} if the file is a directory; {@code false} if\\n     *          the file does not exist, is not a directory, or it cannot\\n     *          be determined if the file is a directory or not.\\n     *\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\\n     *          method denies read access to the file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isRegularFile(Path path, LinkOption... options)", "label": "public static boolean isRegularFile(Path path, LinkOption... options)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests whether a file is a regular file with opaque content.\\n     *\\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\\n     * are handled for the case that the file is a symbolic link. By default,\\n     * symbolic links are followed and the file attribute of the final target\\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\\n     *\\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\\n     * that the file is not a regular file then the file attributes can be\\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\\n     * readAttributes} method and the file type tested with the {@link\\n     * BasicFileAttributes#isRegularFile} method.\\n     *\\n     * @param   path\\n     *          the path to the file\\n     * @param   options\\n     *          options indicating how symbolic links are handled\\n     *\\n     * @return  {@code true} if the file is a regular file; {@code false} if\\n     *          the file does not exist, is not a regular file, or it\\n     *          cannot be determined if the file is a regular file or not.\\n     *\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\\n     *          method denies read access to the file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static FileTime getLastModifiedTime(Path path, LinkOption... options) throws IOException", "label": "public static FileTime getLastModifiedTime(Path path, LinkOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a file\u0027s last modified time.\\n     *\\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\\n     * are handled for the case that the file is a symbolic link. By default,\\n     * symbolic links are followed and the file attribute of the final target\\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\\n     *\\n     * @param   path\\n     *          the path to the file\\n     * @param   options\\n     *          options indicating how symbolic links are handled\\n     *\\n     * @return  a {@code FileTime} representing the time the file was last\\n     *          modified, or an implementation specific default when a time\\n     *          stamp to indicate the time of last modification is not supported\\n     *          by the file system\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\\n     *          method denies read access to the file.\\n     *\\n     * @see BasicFileAttributes#lastModifiedTime\\n     \"}"}, {"color": "#97c2fc", "id": "public static Path setLastModifiedTime(Path path, FileTime time) throws IOException", "label": "public static Path setLastModifiedTime(Path path, FileTime time) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Updates a file\u0027s last modified time attribute. The file time is converted\\n     * to the epoch and precision supported by the file system. Converting from\\n     * finer to coarser granularities result in precision loss. The behavior of\\n     * this method when attempting to set the last modified time when it is not\\n     * supported by the file system or is outside the range supported by the\\n     * underlying file store is not defined. It may or not fail by throwing an\\n     * {@code IOException}.\\n     *\\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\\n     * Suppose we want to set the last modified time to the current time:\\n     * \u003cpre\u003e\\n     *    Path path = ...\\n     *    FileTime now = FileTime.fromMillis(System.currentTimeMillis());\\n     *    Files.setLastModifiedTime(path, now);\\n     * \u003c/pre\u003e\\n     *\\n     * @param   path\\n     *          the path to the file\\n     * @param   time\\n     *          the new last modified time\\n     *\\n     * @return  the path\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, the security manager\u0027s {@link\\n     *          SecurityManager#checkWrite(String) checkWrite} method is invoked\\n     *          to check write access to file\\n     *\\n     * @see BasicFileAttributeView#setTimes\\n     \"}"}, {"color": "#97c2fc", "id": "public static long size(Path path) throws IOException", "label": "public static long size(Path path) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the size of a file (in bytes). The size may differ from the\\n     * actual size on the file system due to compression, support for sparse\\n     * files, or other reasons. The size of files that are not {@link\\n     * #isRegularFile regular} files is implementation specific and\\n     * therefore unspecified.\\n     *\\n     * @param   path\\n     *          the path to the file\\n     *\\n     * @return  the file size, in bytes\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\\n     *          method denies read access to the file.\\n     *\\n     * @see BasicFileAttributes#size\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static boolean followLinks(LinkOption... options)", "label": "private static boolean followLinks(LinkOption... options)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code false} if NOFOLLOW_LINKS is present.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean exists(Path path, LinkOption... options)", "label": "public static boolean exists(Path path, LinkOption... options)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests whether a file exists.\\n     *\\n     * \u003cp\u003e The {@code options} parameter may be used to indicate how symbolic links\\n     * are handled for the case that the file is a symbolic link. By default,\\n     * symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS\\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\\n     *\\n     * \u003cp\u003e Note that the result of this method is immediately outdated. If this\\n     * method indicates the file exists then there is no guarantee that a\\n     * subsequence access will succeed. Care should be taken when using this\\n     * method in security sensitive applications.\\n     *\\n     * @param   path\\n     *          the path to the file to test\\n     * @param   options\\n     *          options indicating how symbolic links are handled\\n     * .\\n     * @return  {@code true} if the file exists; {@code false} if the file does\\n     *          not exist or its existence cannot be determined.\\n     *\\n     * @throws  SecurityException\\n     *          In the case of the default provider, the {@link\\n     *          SecurityManager#checkRead(String)} is invoked to check\\n     *          read access to the file.\\n     *\\n     * @see #notExists\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean notExists(Path path, LinkOption... options)", "label": "public static boolean notExists(Path path, LinkOption... options)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests whether the file located by this path does not exist. This method\\n     * is intended for cases where it is required to take action when it can be\\n     * confirmed that a file does not exist.\\n     *\\n     * \u003cp\u003e The {@code options} parameter may be used to indicate how symbolic links\\n     * are handled for the case that the file is a symbolic link. By default,\\n     * symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS\\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\\n     *\\n     * \u003cp\u003e Note that this method is not the complement of the {@link #exists\\n     * exists} method. Where it is not possible to determine if a file exists\\n     * or not then both methods return {@code false}. As with the {@code exists}\\n     * method, the result of this method is immediately outdated. If this\\n     * method indicates the file does exist then there is no guarantee that a\\n     * subsequence attempt to create the file will succeed. Care should be taken\\n     * when using this method in security sensitive applications.\\n     *\\n     * @param   path\\n     *          the path to the file to test\\n     * @param   options\\n     *          options indicating how symbolic links are handled\\n     *\\n     * @return  {@code true} if the file does not exist; {@code false} if the\\n     *          file exists or its existence cannot be determined\\n     *\\n     * @throws  SecurityException\\n     *          In the case of the default provider, the {@link\\n     *          SecurityManager#checkRead(String)} is invoked to check\\n     *          read access to the file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "existsexists", "label": "existsexists", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "private static boolean isAccessible(Path path, AccessMode... modes)", "label": "private static boolean isAccessible(Path path, AccessMode... modes)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Used by isReadbale, isWritable, isExecutable to test access to a file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isReadable(Path path)", "label": "public static boolean isReadable(Path path)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests whether a file is readable. This method checks that a file exists\\n     * and that this Java virtual machine has appropriate privileges that would\\n     * allow it open the file for reading. Depending on the implementation, this\\n     * method may require to read file permissions, access control lists, or\\n     * other file attributes in order to check the effective access to the file.\\n     * Consequently, this method may not be atomic with respect to other file\\n     * system operations.\\n     *\\n     * \u003cp\u003e Note that the result of this method is immediately outdated, there is\\n     * no guarantee that a subsequent attempt to open the file for reading will\\n     * succeed (or even that it will access the same file). Care should be taken\\n     * when using this method in security sensitive applications.\\n     *\\n     * @param   path\\n     *          the path to the file to check\\n     *\\n     * @return  {@code true} if the file exists and is readable; {@code false}\\n     *          if the file does not exist, read access would be denied because\\n     *          the Java virtual machine has insufficient privileges, or access\\n     *          cannot be determined\\n     *\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          is invoked to check read access to the file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isWritable(Path path)", "label": "public static boolean isWritable(Path path)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests whether a file is writable. This method checks that a file exists\\n     * and that this Java virtual machine has appropriate privileges that would\\n     * allow it open the file for writing. Depending on the implementation, this\\n     * method may require to read file permissions, access control lists, or\\n     * other file attributes in order to check the effective access to the file.\\n     * Consequently, this method may not be atomic with respect to other file\\n     * system operations.\\n     *\\n     * \u003cp\u003e Note that result of this method is immediately outdated, there is no\\n     * guarantee that a subsequent attempt to open the file for writing will\\n     * succeed (or even that it will access the same file). Care should be taken\\n     * when using this method in security sensitive applications.\\n     *\\n     * @param   path\\n     *          the path to the file to check\\n     *\\n     * @return  {@code true} if the file exists and is writable; {@code false}\\n     *          if the file does not exist, write access would be denied because\\n     *          the Java virtual machine has insufficient privileges, or access\\n     *          cannot be determined\\n     *\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          is invoked to check write access to the file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isExecutable(Path path)", "label": "public static boolean isExecutable(Path path)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests whether a file is executable. This method checks that a file exists\\n     * and that this Java virtual machine has appropriate privileges to {@link\\n     * Runtime#exec execute} the file. The semantics may differ when checking\\n     * access to a directory. For example, on UNIX systems, checking for\\n     * execute access checks that the Java virtual machine has permission to\\n     * search the directory in order to access file or subdirectories.\\n     *\\n     * \u003cp\u003e Depending on the implementation, this method may require to read file\\n     * permissions, access control lists, or other file attributes in order to\\n     * check the effective access to the file. Consequently, this method may not\\n     * be atomic with respect to other file system operations.\\n     *\\n     * \u003cp\u003e Note that the result of this method is immediately outdated, there is\\n     * no guarantee that a subsequent attempt to execute the file will succeed\\n     * (or even that it will access the same file). Care should be taken when\\n     * using this method in security sensitive applications.\\n     *\\n     * @param   path\\n     *          the path to the file to check\\n     *\\n     * @return  {@code true} if the file exists and is executable; {@code false}\\n     *          if the file does not exist, execute access would be denied because\\n     *          the Java virtual machine has insufficient privileges, or access\\n     *          cannot be determined\\n     *\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkExec(String)\\n     *          checkExec} is invoked to check execute access to the file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "checkExec(String)", "label": "checkExec(String)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "exec", "label": "exec", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static Path walkFileTree(Path start, Set\u003cFileVisitOption\u003e options, int maxDepth, FileVisitor\u003c? super Path\u003e visitor) throws IOException", "label": "public static Path walkFileTree(Path start, Set\u003cFileVisitOption\u003e options, int maxDepth, FileVisitor\u003c? super Path\u003e visitor) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Walks a file tree.\\n     *\\n     * \u003cp\u003e This method walks a file tree rooted at a given starting file. The\\n     * file tree traversal is \u003cem\u003edepth-first\u003c/em\u003e with the given {@link\\n     * FileVisitor} invoked for each file encountered. File tree traversal\\n     * completes when all accessible files in the tree have been visited, or a\\n     * visit method returns a result of {@link FileVisitResult#TERMINATE\\n     * TERMINATE}. Where a visit method terminates due an {@code IOException},\\n     * an uncaught error, or runtime exception, then the traversal is terminated\\n     * and the error or exception is propagated to the caller of this method.\\n     *\\n     * \u003cp\u003e For each file encountered this method attempts to read its {@link\\n     * java.nio.file.attribute.BasicFileAttributes}. If the file is not a\\n     * directory then the {@link FileVisitor#visitFile visitFile} method is\\n     * invoked with the file attributes. If the file attributes cannot be read,\\n     * due to an I/O exception, then the {@link FileVisitor#visitFileFailed\\n     * visitFileFailed} method is invoked with the I/O exception.\\n     *\\n     * \u003cp\u003e Where the file is a directory, and the directory could not be opened,\\n     * then the {@code visitFileFailed} method is invoked with the I/O exception,\\n     * after which, the file tree walk continues, by default, at the next\\n     * \u003cem\u003esibling\u003c/em\u003e of the directory.\\n     *\\n     * \u003cp\u003e Where the directory is opened successfully, then the entries in the\\n     * directory, and their \u003cem\u003edescendants\u003c/em\u003e are visited. When all entries\\n     * have been visited, or an I/O error occurs during iteration of the\\n     * directory, then the directory is closed and the visitor\u0027s {@link\\n     * FileVisitor#postVisitDirectory postVisitDirectory} method is invoked.\\n     * The file tree walk then continues, by default, at the next \u003cem\u003esibling\u003c/em\u003e\\n     * of the directory.\\n     *\\n     * \u003cp\u003e By default, symbolic links are not automatically followed by this\\n     * method. If the {@code options} parameter contains the {@link\\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are\\n     * followed. When following links, and the attributes of the target cannot\\n     * be read, then this method attempts to get the {@code BasicFileAttributes}\\n     * of the link. If they can be read then the {@code visitFile} method is\\n     * invoked with the attributes of the link (otherwise the {@code visitFileFailed}\\n     * method is invoked as specified above).\\n     *\\n     * \u003cp\u003e If the {@code options} parameter contains the {@link\\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then this method keeps\\n     * track of directories visited so that cycles can be detected. A cycle\\n     * arises when there is an entry in a directory that is an ancestor of the\\n     * directory. Cycle detection is done by recording the {@link\\n     * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,\\n     * or if file keys are not available, by invoking the {@link #isSameFile\\n     * isSameFile} method to test if a directory is the same file as an\\n     * ancestor. When a cycle is detected it is treated as an I/O error, and the\\n     * {@link FileVisitor#visitFileFailed visitFileFailed} method is invoked with\\n     * an instance of {@link FileSystemLoopException}.\\n     *\\n     * \u003cp\u003e The {@code maxDepth} parameter is the maximum number of levels of\\n     * directories to visit. A value of {@code 0} means that only the starting\\n     * file is visited, unless denied by the security manager. A value of\\n     * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all\\n     * levels should be visited. The {@code visitFile} method is invoked for all\\n     * files, including directories, encountered at {@code maxDepth}, unless the\\n     * basic file attributes cannot be read, in which case the {@code\\n     * visitFileFailed} method is invoked.\\n     *\\n     * \u003cp\u003e If a visitor returns a result of {@code null} then {@code\\n     * NullPointerException} is thrown.\\n     *\\n     * \u003cp\u003e When a security manager is installed and it denies access to a file\\n     * (or directory), then it is ignored and the visitor is not invoked for\\n     * that file (or directory).\\n     *\\n     * @param   start\\n     *          the starting file\\n     * @param   options\\n     *          options to configure the traversal\\n     * @param   maxDepth\\n     *          the maximum number of directory levels to visit\\n     * @param   visitor\\n     *          the file visitor to invoke for each file\\n     *\\n     * @return  the starting file\\n     *\\n     * @throws  IllegalArgumentException\\n     *          if the {@code maxDepth} parameter is negative\\n     * @throws  SecurityException\\n     *          If the security manager denies access to the starting file.\\n     *          In the case of the default provider, the {@link\\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\\n     *          to check read access to the directory.\\n     * @throws  IOException\\n     *          if an I/O error is thrown by a visitor method\\n     \"}"}, {"color": "#97c2fc", "id": "java.nio.file.FileVisitor", "label": "java.nio.file.FileVisitor", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": " FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs) throws IOException", "label": " FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Invoked for a directory before entries in the directory are visited.\\n     *\\n     * \u003cp\u003e If this method returns {@link FileVisitResult#CONTINUE CONTINUE},\\n     * then entries in the directory are visited. If this method returns {@link\\n     * FileVisitResult#SKIP_SUBTREE SKIP_SUBTREE} or {@link\\n     * FileVisitResult#SKIP_SIBLINGS SKIP_SIBLINGS} then entries in the\\n     * directory (and any descendants) will not be visited.\\n     *\\n     * @param   dir\\n     *          a reference to the directory\\n     * @param   attrs\\n     *          the directory\u0027s basic attributes\\n     *\\n     * @return  the visit result\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "CONTINUE", "label": "CONTINUE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "SKIP_SIBLINGS", "label": "SKIP_SIBLINGS", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "SKIP_SUBTREE", "label": "SKIP_SUBTREE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " FileVisitResult visitFile(T file, BasicFileAttributes attrs) throws IOException", "label": " FileVisitResult visitFile(T file, BasicFileAttributes attrs) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Invoked for a file in a directory.\\n     *\\n     * @param   file\\n     *          a reference to the file\\n     * @param   attrs\\n     *          the file\u0027s basic attributes\\n     *\\n     * @return  the visit result\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": " FileVisitResult visitFileFailed(T file, IOException exc) throws IOException", "label": " FileVisitResult visitFileFailed(T file, IOException exc) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Invoked for a file that could not be visited. This method is invoked\\n     * if the file\u0027s attributes could not be read, the file is a directory\\n     * that could not be opened, and other reasons.\\n     *\\n     * @param   file\\n     *          a reference to the file\\n     * @param   exc\\n     *          the I/O exception that prevented the file from being visited\\n     *\\n     * @return  the visit result\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": " FileVisitResult postVisitDirectory(T dir, IOException exc) throws IOException", "label": " FileVisitResult postVisitDirectory(T dir, IOException exc) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Invoked for a directory after entries in the directory, and all of their\\n     * descendants, have been visited. This method is also invoked when iteration\\n     * of the directory completes prematurely (by a {@link #visitFile visitFile}\\n     * method returning {@link FileVisitResult#SKIP_SIBLINGS SKIP_SIBLINGS},\\n     * or an I/O error when iterating over the directory).\\n     *\\n     * @param   dir\\n     *          a reference to the directory\\n     * @param   exc\\n     *          {@code null} if the iteration of the directory completes without\\n     *          an error; otherwise the I/O exception that caused the iteration\\n     *          of the directory to complete prematurely\\n     *\\n     * @return  the visit result\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     \u0027}"}, {"color": "#97c2fc", "id": "visitFile", "label": "visitFile", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "TERMINATETERMINATE", "label": "TERMINATETERMINATE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "FOLLOW_LINKS", "label": "FOLLOW_LINKS", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.FileSystemLoopException", "label": "java.nio.file.FileSystemLoopException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "isSameFileisSameFile", "label": "isSameFileisSameFile", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static Path walkFileTree(Path start, FileVisitor\u003c? super Path\u003e visitor) throws IOException", "label": "public static Path walkFileTree(Path start, FileVisitor\u003c? super Path\u003e visitor) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Walks a file tree.\\n     *\\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\\n     * expression:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * In other words, it does not follow symbolic links, and visits all levels\\n     * of the file tree.\\n     *\\n     * @param   start\\n     *          the starting file\\n     * @param   visitor\\n     *          the file visitor to invoke for each file\\n     *\\n     * @return  the starting file\\n     *\\n     * @throws  SecurityException\\n     *          If the security manager denies access to the starting file.\\n     *          In the case of the default provider, the {@link\\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\\n     *          to check read access to the directory.\\n     * @throws  IOException\\n     *          if an I/O error is thrown by a visitor method\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static BufferedReader newBufferedReader(Path path, Charset cs) throws IOException", "label": "public static BufferedReader newBufferedReader(Path path, Charset cs) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens a file for reading, returning a {@code BufferedReader} that may be\\n     * used to read text from the file in an efficient manner. Bytes from the\\n     * file are decoded into characters using the specified charset. Reading\\n     * commences at the beginning of the file.\\n     *\\n     * \u003cp\u003e The {@code Reader} methods that read from the file throw {@code\\n     * IOException} if a malformed or unmappable byte sequence is read.\\n     *\\n     * @param   path\\n     *          the path to the file\\n     * @param   cs\\n     *          the charset to use for decoding\\n     *\\n     * @return  a new buffered reader, with default buffer size, to read text\\n     *          from the file\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs opening the file\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the file.\\n     *\\n     * @see #readAllLines\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static BufferedReader newBufferedReader(Path path) throws IOException", "label": "public static BufferedReader newBufferedReader(Path path) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens a file for reading, returning a {@code BufferedReader} to read text\\n     * from the file in an efficient manner. Bytes from the file are decoded into\\n     * characters using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset\\n     * charset}.\\n     *\\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\\n     * expression:\\n     * \u003cpre\u003e{@code\\n     * Files.newBufferedReader(path, StandardCharsets.UTF_8)\\n     * }\u003c/pre\u003e\\n     *\\n     * @param   path\\n     *          the path to the file\\n     *\\n     * @return  a new buffered reader, with default buffer size, to read text\\n     *          from the file\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs opening the file\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the file.\\n     *\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "Charsetcharset", "label": "Charsetcharset", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "UTF_8", "label": "UTF_8", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.charset.StandardCharsets", "label": "java.nio.charset.StandardCharsets", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Constant definitions for the standard {@link Charset Charsets}. These\\n * charsets are guaranteed to be available on every implementation of the Java\\n * platform.\\n *\\n * @see \u003ca href=\"Charset.html#standard\"\u003eStandard Charsets\u003c/a\u003e\\n * @since 1.7\\n \u0027}"}, {"color": "#97c2fc", "id": "public static BufferedWriter newBufferedWriter(Path path, Charset cs, OpenOption... options) throws IOException", "label": "public static BufferedWriter newBufferedWriter(Path path, Charset cs, OpenOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Opens or creates a file for writing, returning a {@code BufferedWriter}\\n     * that may be used to write text to the file in an efficient manner.\\n     * The {@code options} parameter specifies how the the file is created or\\n     * opened. If no options are present then this method works as if the {@link\\n     * StandardOpenOption#CREATE CREATE}, {@link\\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\\n     * initially truncating an existing {@link #isRegularFile regular-file} to\\n     * a size of {@code 0} if it exists.\\n     *\\n     * \u003cp\u003e The {@code Writer} methods to write text throw {@code IOException}\\n     * if the text cannot be encoded using the specified charset.\\n     *\\n     * @param   path\\n     *          the path to the file\\n     * @param   cs\\n     *          the charset to use for encoding\\n     * @param   options\\n     *          options specifying how the file is opened\\n     *\\n     * @return  a new buffered writer, with default buffer size, to write text\\n     *          to the file\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs opening or creating the file\\n     * @throws  UnsupportedOperationException\\n     *          if an unsupported option is specified\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method is invoked to check write access to the file.\\n     *\\n     * @see #write(Path,Iterable,Charset,OpenOption[])\\n     \"}"}, {"color": "#97c2fc", "id": "public static BufferedWriter newBufferedWriter(Path path, OpenOption... options) throws IOException", "label": "public static BufferedWriter newBufferedWriter(Path path, OpenOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens or creates a file for writing, returning a {@code BufferedWriter}\\n     * to write text to the file in an efficient manner. The text is encoded\\n     * into bytes for writing using the {@link StandardCharsets#UTF_8 UTF-8}\\n     * {@link Charset charset}.\\n     *\\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\\n     * expression:\\n     * \u003cpre\u003e{@code\\n     * Files.newBufferedWriter(path, StandardCharsets.UTF_8, options)\\n     * }\u003c/pre\u003e\\n     *\\n     * @param   path\\n     *          the path to the file\\n     * @param   options\\n     *          options specifying how the file is opened\\n     *\\n     * @return  a new buffered writer, with default buffer size, to write text\\n     *          to the file\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs opening or creating the file\\n     * @throws  UnsupportedOperationException\\n     *          if an unsupported option is specified\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method is invoked to check write access to the file.\\n     *\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static long copy(InputStream source, OutputStream sink) throws IOException", "label": "private static long copy(InputStream source, OutputStream sink) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads all bytes from an input stream and writes them to an output stream.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static long copy(InputStream in, Path target, CopyOption... options) throws IOException", "label": "public static long copy(InputStream in, Path target, CopyOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies all bytes from an input stream to a file. On return, the input\\n     * stream will be at end of stream.\\n     *\\n     * \u003cp\u003e By default, the copy fails if the target file already exists or is a\\n     * symbolic link. If the {@link StandardCopyOption#REPLACE_EXISTING\\n     * REPLACE_EXISTING} option is specified, and the target file already exists,\\n     * then it is replaced if it is not a non-empty directory. If the target\\n     * file exists and is a symbolic link, then the symbolic link is replaced.\\n     * In this release, the {@code REPLACE_EXISTING} option is the only option\\n     * required to be supported by this method. Additional options may be\\n     * supported in future releases.\\n     *\\n     * \u003cp\u003e  If an I/O error occurs reading from the input stream or writing to\\n     * the file, then it may do so after the target file has been created and\\n     * after some bytes have been read or written. Consequently the input\\n     * stream may not be at end of stream and may be in an inconsistent state.\\n     * It is strongly recommended that the input stream be promptly closed if an\\n     * I/O error occurs.\\n     *\\n     * \u003cp\u003e This method may block indefinitely reading from the input stream (or\\n     * writing to the file). The behavior for the case that the input stream is\\n     * \u003ci\u003easynchronously closed\u003c/i\u003e or the thread interrupted during the copy is\\n     * highly input stream and file system provider specific and therefore not\\n     * specified.\\n     *\\n     * \u003cp\u003e \u003cb\u003eUsage example\u003c/b\u003e: Suppose we want to capture a web page and save\\n     * it to a file:\\n     * \u003cpre\u003e\\n     *     Path path = ...\\n     *     URI u = URI.create(\"http://java.sun.com/\");\\n     *     try (InputStream in = u.toURL().openStream()) {\\n     *         Files.copy(in, path);\\n     *     }\\n     * \u003c/pre\u003e\\n     *\\n     * @param   in\\n     *          the input stream to read from\\n     * @param   target\\n     *          the path to the file\\n     * @param   options\\n     *          options specifying how the copy should be done\\n     *\\n     * @return  the number of bytes read or written\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs when reading or writing\\n     * @throws  FileAlreadyExistsException\\n     *          if the target file exists but cannot be replaced because the\\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\\n     *          specific exception)\u003c/i\u003e\\n     * @throws  DirectoryNotEmptyException\\n     *          the {@code REPLACE_EXISTING} option is specified but the file\\n     *          cannot be replaced because it is a non-empty directory\\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e     *\\n     * @throws  UnsupportedOperationException\\n     *          if {@code options} contains a copy option that is not supported\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method is invoked to check write access to the file. Where the\\n     *          {@code REPLACE_EXISTING} option is specified, the security\\n     *          manager\\\u0027s {@link SecurityManager#checkDelete(String) checkDelete}\\n     *          method is invoked to check that an existing file can be deleted.\\n     \u0027}"}, {"color": "#97c2fc", "id": "REPLACE_EXISTINGREPLACE_EXISTING", "label": "REPLACE_EXISTINGREPLACE_EXISTING", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static long copy(Path source, OutputStream out) throws IOException", "label": "public static long copy(Path source, OutputStream out) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copies all bytes from a file to an output stream.\\n     *\\n     * \u003cp\u003e If an I/O error occurs reading from the file or writing to the output\\n     * stream, then it may do so after some bytes have been read or written.\\n     * Consequently the output stream may be in an inconsistent state. It is\\n     * strongly recommended that the output stream be promptly closed if an I/O\\n     * error occurs.\\n     *\\n     * \u003cp\u003e This method may block indefinitely writing to the output stream (or\\n     * reading from the file). The behavior for the case that the output stream\\n     * is \u003ci\u003easynchronously closed\u003c/i\u003e or the thread interrupted during the copy\\n     * is highly output stream and file system provider specific and therefore\\n     * not specified.\\n     *\\n     * \u003cp\u003e Note that if the given output stream is {@link java.io.Flushable}\\n     * then its {@link java.io.Flushable#flush flush} method may need to invoked\\n     * after this method completes so as to flush any buffered output.\\n     *\\n     * @param   source\\n     *          the  path to the file\\n     * @param   out\\n     *          the output stream to write to\\n     *\\n     * @return  the number of bytes read or written\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs when reading or writing\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.io.Flushable", "label": "java.io.Flushable", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * A {@code Flushable} is a destination of data that can be flushed.  The\\n * flush method is invoked to write any buffered output to the underlying\\n * stream.\\n *\\n * @since 1.5\\n \u0027}"}, {"color": "#97c2fc", "id": " void flush() throws IOException", "label": " void flush() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Flushes this stream by writing any buffered output to the underlying\\n     * stream.\\n     *\\n     * @throws IOException If an I/O error occurs\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static byte[] read(InputStream source, int initialSize) throws IOException", "label": "private static byte[] read(InputStream source, int initialSize) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads all the bytes from an input stream. Uses {@code initialSize} as a hint\\n     * about how many bytes the stream will have.\\n     *\\n     * @param   source\\n     *          the input stream to read from\\n     * @param   initialSize\\n     *          the initial size of the byte array to allocate\\n     *\\n     * @return  a byte array containing the bytes read from the file\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs reading from the stream\\n     * @throws  OutOfMemoryError\\n     *          if an array of the required size cannot be allocated\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static byte[] readAllBytes(Path path) throws IOException", "label": "public static byte[] readAllBytes(Path path) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads all the bytes from a file. The method ensures that the file is\\n     * closed when all bytes have been read or an I/O error, or other runtime\\n     * exception, is thrown.\\n     *\\n     * \u003cp\u003e Note that this method is intended for simple cases where it is\\n     * convenient to read all bytes into a byte array. It is not intended for\\n     * reading in large files.\\n     *\\n     * @param   path\\n     *          the path to the file\\n     *\\n     * @return  a byte array containing the bytes read from the file\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs reading from the stream\\n     * @throws  OutOfMemoryError\\n     *          if an array of the required size cannot be allocated, for\\n     *          example the file is larger that {@code 2GB}\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static List\u003cString\u003e readAllLines(Path path, Charset cs) throws IOException", "label": "public static List\u003cString\u003e readAllLines(Path path, Charset cs) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Read all lines from a file. This method ensures that the file is\\n     * closed when all bytes have been read or an I/O error, or other runtime\\n     * exception, is thrown. Bytes from the file are decoded into characters\\n     * using the specified charset.\\n     *\\n     * \u003cp\u003e This method recognizes the following as line terminators:\\n     * \u003cul\u003e\\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000D\u003c/code\u003e followed by \u003ccode\u003e\u0026#92;u000A\u003c/code\u003e,\\n     *     CARRIAGE RETURN followed by LINE FEED \u003c/li\u003e\\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000A\u003c/code\u003e, LINE FEED \u003c/li\u003e\\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000D\u003c/code\u003e, CARRIAGE RETURN \u003c/li\u003e\\n     * \u003c/ul\u003e\\n     * \u003cp\u003e Additional Unicode line terminators may be recognized in future\\n     * releases.\\n     *\\n     * \u003cp\u003e Note that this method is intended for simple cases where it is\\n     * convenient to read all lines in a single operation. It is not intended\\n     * for reading in large files.\\n     *\\n     * @param   path\\n     *          the path to the file\\n     * @param   cs\\n     *          the charset to use for decoding\\n     *\\n     * @return  the lines from the file as a {@code List}; whether the {@code\\n     *          List} is modifiable or not is implementation dependent and\\n     *          therefore not specified\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs reading from the file or a malformed or\\n     *          unmappable byte sequence is read\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the file.\\n     *\\n     * @see #newBufferedReader\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static List\u003cString\u003e readAllLines(Path path) throws IOException", "label": "public static List\u003cString\u003e readAllLines(Path path) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Read all lines from a file. Bytes from the file are decoded into characters\\n     * using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\\n     *\\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\\n     * expression:\\n     * \u003cpre\u003e{@code\\n     * Files.readAllLines(path, StandardCharsets.UTF_8)\\n     * }\u003c/pre\u003e\\n     *\\n     * @param   path\\n     *          the path to the file\\n     *\\n     * @return  the lines from the file as a {@code List}; whether the {@code\\n     *          List} is modifiable or not is implementation dependent and\\n     *          therefore not specified\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs reading from the file or a malformed or\\n     *          unmappable byte sequence is read\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the file.\\n     *\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Path write(Path path, byte[] bytes, OpenOption... options) throws IOException", "label": "public static Path write(Path path, byte[] bytes, OpenOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Writes bytes to a file. The {@code options} parameter specifies how the\\n     * the file is created or opened. If no options are present then this method\\n     * works as if the {@link StandardOpenOption#CREATE CREATE}, {@link\\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\\n     * initially truncating an existing {@link #isRegularFile regular-file} to\\n     * a size of {@code 0}. All bytes in the byte array are written to the file.\\n     * The method ensures that the file is closed when all bytes have been\\n     * written (or an I/O error or other runtime exception is thrown). If an I/O\\n     * error occurs then it may do so after the file has created or truncated,\\n     * or after some bytes have been written to the file.\\n     *\\n     * \u003cp\u003e \u003cb\u003eUsage example\u003c/b\u003e: By default the method creates a new file or\\n     * overwrites an existing file. Suppose you instead want to append bytes\\n     * to an existing file:\\n     * \u003cpre\u003e\\n     *     Path path = ...\\n     *     byte[] bytes = ...\\n     *     Files.write(path, bytes, StandardOpenOption.APPEND);\\n     * \u003c/pre\u003e\\n     *\\n     * @param   path\\n     *          the path to the file\\n     * @param   bytes\\n     *          the byte array with the bytes to write\\n     * @param   options\\n     *          options specifying how the file is opened\\n     *\\n     * @return  the path\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs writing to or creating the file\\n     * @throws  UnsupportedOperationException\\n     *          if an unsupported option is specified\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method is invoked to check write access to the file.\\n     \"}"}, {"color": "#97c2fc", "id": "public static Path write(Path path, Iterable\u003c? extends CharSequence\u003e lines, Charset cs, OpenOption... options) throws IOException", "label": "public static Path write(Path path, Iterable\u003c? extends CharSequence\u003e lines, Charset cs, OpenOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Write lines of text to a file. Each line is a char sequence and is\\n     * written to the file in sequence with each line terminated by the\\n     * platform\u0027s line separator, as defined by the system property {@code\\n     * line.separator}. Characters are encoded into bytes using the specified\\n     * charset.\\n     *\\n     * \u003cp\u003e The {@code options} parameter specifies how the the file is created\\n     * or opened. If no options are present then this method works as if the\\n     * {@link StandardOpenOption#CREATE CREATE}, {@link\\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\\n     * initially truncating an existing {@link #isRegularFile regular-file} to\\n     * a size of {@code 0}. The method ensures that the file is closed when all\\n     * lines have been written (or an I/O error or other runtime exception is\\n     * thrown). If an I/O error occurs then it may do so after the file has\\n     * created or truncated, or after some bytes have been written to the file.\\n     *\\n     * @param   path\\n     *          the path to the file\\n     * @param   lines\\n     *          an object to iterate over the char sequences\\n     * @param   cs\\n     *          the charset to use for encoding\\n     * @param   options\\n     *          options specifying how the file is opened\\n     *\\n     * @return  the path\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs writing to or creating the file, or the\\n     *          text cannot be encoded using the specified charset\\n     * @throws  UnsupportedOperationException\\n     *          if an unsupported option is specified\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method is invoked to check write access to the file.\\n     \"}"}, {"color": "#97c2fc", "id": "public static Path write(Path path, Iterable\u003c? extends CharSequence\u003e lines, OpenOption... options) throws IOException", "label": "public static Path write(Path path, Iterable\u003c? extends CharSequence\u003e lines, OpenOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Write lines of text to a file. Characters are encoded into bytes using\\n     * the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\\n     *\\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\\n     * expression:\\n     * \u003cpre\u003e{@code\\n     * Files.write(path, lines, StandardCharsets.UTF_8, options);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param   path\\n     *          the path to the file\\n     * @param   lines\\n     *          an object to iterate over the char sequences\\n     * @param   options\\n     *          options specifying how the file is opened\\n     *\\n     * @return  the path\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs writing to or creating the file, or the\\n     *          text cannot be encoded as {@code UTF-8}\\n     * @throws  UnsupportedOperationException\\n     *          if an unsupported option is specified\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method is invoked to check write access to the file.\\n     *\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Stream\u003cPath\u003e list(Path dir) throws IOException", "label": "public static Stream\u003cPath\u003e list(Path dir) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Return a lazily populated {@code Stream}, the elements of\\n     * which are the entries in the directory.  The listing is not recursive.\\n     *\\n     * \u003cp\u003e The elements of the stream are {@link Path} objects that are\\n     * obtained as if by {@link Path#resolve(Path) resolving} the name of the\\n     * directory entry against {@code dir}. Some file systems maintain special\\n     * links to the directory itself and the directory\u0027s parent directory.\\n     * Entries representing these links are not included.\\n     *\\n     * \u003cp\u003e The stream is \u003ci\u003eweakly consistent\u003c/i\u003e. It is thread safe but does\\n     * not freeze the directory while iterating, so it may (or may not)\\n     * reflect updates to the directory that occur after returning from this\\n     * method.\\n     *\\n     * \u003cp\u003e The returned stream encapsulates a {@link DirectoryStream}.\\n     * If timely disposal of file system resources is required, the\\n     * {@code try}-with-resources construct should be used to ensure that the\\n     * stream\u0027s {@link Stream#close close} method is invoked after the stream\\n     * operations are completed.\\n     *\\n     * \u003cp\u003e Operating on a closed stream behaves as if the end of stream\\n     * has been reached. Due to read-ahead, one or more elements may be\\n     * returned after the stream has been closed.\\n     *\\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\\n     * after this method has returned, it is wrapped in an {@link\\n     * UncheckedIOException} which will be thrown from the method that caused\\n     * the access to take place.\\n     *\\n     * @param   dir  The path to the directory\\n     *\\n     * @return  The {@code Stream} describing the content of the\\n     *          directory\\n     *\\n     * @throws  NotDirectoryException\\n     *          if the file could not otherwise be opened because it is not\\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs when opening the directory\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the directory.\\n     *\\n     * @see     #newDirectoryStream(Path)\\n     * @since   1.8\\n     \"}"}, {"color": "#97c2fc", "id": "java.io.UncheckedIOException", "label": "java.io.UncheckedIOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Wraps an {@link IOException} with an unchecked exception.\\n *\\n * @since   1.8\\n \u0027}"}, {"color": "#97c2fc", "id": "public static Stream\u003cPath\u003e walk(Path start, int maxDepth, FileVisitOption... options) throws IOException", "label": "public static Stream\u003cPath\u003e walk(Path start, int maxDepth, FileVisitOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Return a {@code Stream} that is lazily populated with {@code\\n     * Path} by walking the file tree rooted at a given starting file.  The\\n     * file tree is traversed \u003cem\u003edepth-first\u003c/em\u003e, the elements in the stream\\n     * are {@link Path} objects that are obtained as if by {@link\\n     * Path#resolve(Path) resolving} the relative path against {@code start}.\\n     *\\n     * \u003cp\u003e The {@code stream} walks the file tree as elements are consumed.\\n     * The {@code Stream} returned is guaranteed to have at least one\\n     * element, the starting file itself. For each file visited, the stream\\n     * attempts to read its {@link BasicFileAttributes}. If the file is a\\n     * directory and can be opened successfully, entries in the directory, and\\n     * their \u003cem\u003edescendants\u003c/em\u003e will follow the directory in the stream as\\n     * they are encountered. When all entries have been visited, then the\\n     * directory is closed. The file tree walk then continues at the next\\n     * \u003cem\u003esibling\u003c/em\u003e of the directory.\\n     *\\n     * \u003cp\u003e The stream is \u003ci\u003eweakly consistent\u003c/i\u003e. It does not freeze the\\n     * file tree while iterating, so it may (or may not) reflect updates to\\n     * the file tree that occur after returned from this method.\\n     *\\n     * \u003cp\u003e By default, symbolic links are not automatically followed by this\\n     * method. If the {@code options} parameter contains the {@link\\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are\\n     * followed. When following links, and the attributes of the target cannot\\n     * be read, then this method attempts to get the {@code BasicFileAttributes}\\n     * of the link.\\n     *\\n     * \u003cp\u003e If the {@code options} parameter contains the {@link\\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then the stream keeps\\n     * track of directories visited so that cycles can be detected. A cycle\\n     * arises when there is an entry in a directory that is an ancestor of the\\n     * directory. Cycle detection is done by recording the {@link\\n     * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,\\n     * or if file keys are not available, by invoking the {@link #isSameFile\\n     * isSameFile} method to test if a directory is the same file as an\\n     * ancestor. When a cycle is detected it is treated as an I/O error with\\n     * an instance of {@link FileSystemLoopException}.\\n     *\\n     * \u003cp\u003e The {@code maxDepth} parameter is the maximum number of levels of\\n     * directories to visit. A value of {@code 0} means that only the starting\\n     * file is visited, unless denied by the security manager. A value of\\n     * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all\\n     * levels should be visited.\\n     *\\n     * \u003cp\u003e When a security manager is installed and it denies access to a file\\n     * (or directory), then it is ignored and not included in the stream.\\n     *\\n     * \u003cp\u003e The returned stream encapsulates one or more {@link DirectoryStream}s.\\n     * If timely disposal of file system resources is required, the\\n     * {@code try}-with-resources construct should be used to ensure that the\\n     * stream\u0027s {@link Stream#close close} method is invoked after the stream\\n     * operations are completed.  Operating on a closed stream will result in an\\n     * {@link java.lang.IllegalStateException}.\\n     *\\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\\n     * after this method has returned, it is wrapped in an {@link\\n     * UncheckedIOException} which will be thrown from the method that caused\\n     * the access to take place.\\n     *\\n     * @param   start\\n     *          the starting file\\n     * @param   maxDepth\\n     *          the maximum number of directory levels to visit\\n     * @param   options\\n     *          options to configure the traversal\\n     *\\n     * @return  the {@link Stream} of {@link Path}\\n     *\\n     * @throws  IllegalArgumentException\\n     *          if the {@code maxDepth} parameter is negative\\n     * @throws  SecurityException\\n     *          If the security manager denies access to the starting file.\\n     *          In the case of the default provider, the {@link\\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\\n     *          to check read access to the directory.\\n     * @throws  IOException\\n     *          if an I/O error is thrown when accessing the starting file.\\n     * @since   1.8\\n     \"}"}, {"color": "#97c2fc", "id": "java.lang.IllegalStateException", "label": "java.lang.IllegalStateException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Signals that a method has been invoked at an illegal or\\n * inappropriate time.  In other words, the Java environment or\\n * Java application is not in an appropriate state for the requested\\n * operation.\\n *\\n * @author  Jonni Kanerva\\n * @since   1.1\\n \u0027}"}, {"color": "#97c2fc", "id": "public static Stream\u003cPath\u003e walk(Path start, FileVisitOption... options) throws IOException", "label": "public static Stream\u003cPath\u003e walk(Path start, FileVisitOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Return a {@code Stream} that is lazily populated with {@code\\n     * Path} by walking the file tree rooted at a given starting file.  The\\n     * file tree is traversed \u003cem\u003edepth-first\u003c/em\u003e, the elements in the stream\\n     * are {@link Path} objects that are obtained as if by {@link\\n     * Path#resolve(Path) resolving} the relative path against {@code start}.\\n     *\\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\\n     * expression:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * walk(start, Integer.MAX_VALUE, options)\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * In other words, it visits all levels of the file tree.\\n     *\\n     * \u003cp\u003e The returned stream encapsulates one or more {@link DirectoryStream}s.\\n     * If timely disposal of file system resources is required, the\\n     * {@code try}-with-resources construct should be used to ensure that the\\n     * stream\u0027s {@link Stream#close close} method is invoked after the stream\\n     * operations are completed.  Operating on a closed stream will result in an\\n     * {@link java.lang.IllegalStateException}.\\n     *\\n     * @param   start\\n     *          the starting file\\n     * @param   options\\n     *          options to configure the traversal\\n     *\\n     * @return  the {@link Stream} of {@link Path}\\n     *\\n     * @throws  SecurityException\\n     *          If the security manager denies access to the starting file.\\n     *          In the case of the default provider, the {@link\\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\\n     *          to check read access to the directory.\\n     * @throws  IOException\\n     *          if an I/O error is thrown when accessing the starting file.\\n     *\\n     * @see     #walk(Path, int, FileVisitOption...)\\n     * @since   1.8\\n     \"}"}, {"color": "#97c2fc", "id": "public static Stream\u003cPath\u003e find(Path start, int maxDepth, BiPredicate\u003cPath, BasicFileAttributes\u003e matcher, FileVisitOption... options) throws IOException", "label": "public static Stream\u003cPath\u003e find(Path start, int maxDepth, BiPredicate\u003cPath, BasicFileAttributes\u003e matcher, FileVisitOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Return a {@code Stream} that is lazily populated with {@code\\n     * Path} by searching for files in a file tree rooted at a given starting\\n     * file.\\n     *\\n     * \u003cp\u003e This method walks the file tree in exactly the manner specified by\\n     * the {@link #walk walk} method. For each file encountered, the given\\n     * {@link BiPredicate} is invoked with its {@link Path} and {@link\\n     * BasicFileAttributes}. The {@code Path} object is obtained as if by\\n     * {@link Path#resolve(Path) resolving} the relative path against {@code\\n     * start} and is only included in the returned {@link Stream} if\\n     * the {@code BiPredicate} returns true. Compare to calling {@link\\n     * java.util.stream.Stream#filter filter} on the {@code Stream}\\n     * returned by {@code walk} method, this method may be more efficient by\\n     * avoiding redundant retrieval of the {@code BasicFileAttributes}.\\n     *\\n     * \u003cp\u003e The returned stream encapsulates one or more {@link DirectoryStream}s.\\n     * If timely disposal of file system resources is required, the\\n     * {@code try}-with-resources construct should be used to ensure that the\\n     * stream\u0027s {@link Stream#close close} method is invoked after the stream\\n     * operations are completed.  Operating on a closed stream will result in an\\n     * {@link java.lang.IllegalStateException}.\\n     *\\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\\n     * after returned from this method, it is wrapped in an {@link\\n     * UncheckedIOException} which will be thrown from the method that caused\\n     * the access to take place.\\n     *\\n     * @param   start\\n     *          the starting file\\n     * @param   maxDepth\\n     *          the maximum number of directory levels to search\\n     * @param   matcher\\n     *          the function used to decide whether a file should be included\\n     *          in the returned stream\\n     * @param   options\\n     *          options to configure the traversal\\n     *\\n     * @return  the {@link Stream} of {@link Path}\\n     *\\n     * @throws  IllegalArgumentException\\n     *          if the {@code maxDepth} parameter is negative\\n     * @throws  SecurityException\\n     *          If the security manager denies access to the starting file.\\n     *          In the case of the default provider, the {@link\\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\\n     *          to check read access to the directory.\\n     * @throws  IOException\\n     *          if an I/O error is thrown when accessing the starting file.\\n     *\\n     * @see     #walk(Path, int, FileVisitOption...)\\n     * @since   1.8\\n     \"}"}, {"color": "#97c2fc", "id": "walk", "label": "walk", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.util.function.BiPredicate", "label": "java.util.function.BiPredicate", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Represents a predicate (boolean-valued function) of two arguments.  This is\\n * the two-arity specialization of {@link Predicate}.\\n *\\n * \u003cp\u003eThis is a \u003ca href=\"package-summary.html\"\u003efunctional interface\u003c/a\u003e\\n * whose functional method is {@link #test(Object, Object)}.\\n *\\n * @param \u003cT\u003e the type of the first argument to the predicate\\n * @param \u003cU\u003e the type of the second argument the predicate\\n *\\n * @see Predicate\\n * @since 1.8\\n \u0027}"}, {"color": "#97c2fc", "id": " boolean test(T t, U u)", "label": " boolean test(T t, U u)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Evaluates this predicate on the given arguments.\\n     *\\n     * @param t the first input argument\\n     * @param u the second input argument\\n     * @return {@code true} if the input arguments match the predicate,\\n     * otherwise {@code false}\\n     \u0027}"}, {"color": "#97c2fc", "id": " BiPredicate\u003cT, U\u003e and(BiPredicate\u003c? super T, ? super U\u003e other)", "label": " BiPredicate\u003cT, U\u003e and(BiPredicate\u003c? super T, ? super U\u003e other)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a composed predicate that represents a short-circuiting logical\\n     * AND of this predicate and another.  When evaluating the composed\\n     * predicate, if this predicate is {@code false}, then the {@code other}\\n     * predicate is not evaluated.\\n     *\\n     * \u003cp\u003eAny exceptions thrown during evaluation of either predicate are relayed\\n     * to the caller; if evaluation of this predicate throws an exception, the\\n     * {@code other} predicate will not be evaluated.\\n     *\\n     * @param other a predicate that will be logically-ANDed with this\\n     *              predicate\\n     * @return a composed predicate that represents the short-circuiting logical\\n     * AND of this predicate and the {@code other} predicate\\n     * @throws NullPointerException if other is null\\n     \u0027}"}, {"color": "#97c2fc", "id": " BiPredicate\u003cT, U\u003e negate()", "label": " BiPredicate\u003cT, U\u003e negate()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a predicate that represents the logical negation of this\\n     * predicate.\\n     *\\n     * @return a predicate that represents the logical negation of this\\n     * predicate\\n     \u0027}"}, {"color": "#97c2fc", "id": " BiPredicate\u003cT, U\u003e or(BiPredicate\u003c? super T, ? super U\u003e other)", "label": " BiPredicate\u003cT, U\u003e or(BiPredicate\u003c? super T, ? super U\u003e other)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a composed predicate that represents a short-circuiting logical\\n     * OR of this predicate and another.  When evaluating the composed\\n     * predicate, if this predicate is {@code true}, then the {@code other}\\n     * predicate is not evaluated.\\n     *\\n     * \u003cp\u003eAny exceptions thrown during evaluation of either predicate are relayed\\n     * to the caller; if evaluation of this predicate throws an exception, the\\n     * {@code other} predicate will not be evaluated.\\n     *\\n     * @param other a predicate that will be logically-ORed with this\\n     *              predicate\\n     * @return a composed predicate that represents the short-circuiting logical\\n     * OR of this predicate and the {@code other} predicate\\n     * @throws NullPointerException if other is null\\n     \u0027}"}, {"color": "#97c2fc", "id": "filter", "label": "filter", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.util.stream.Stream", "label": "java.util.stream.Stream", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * A sequence of elements supporting sequential and parallel aggregate\\n * operations.  The following example illustrates an aggregate operation using\\n * {@link Stream} and {@link IntStream}:\\n *\\n * \u003cpre\u003e{@code\\n *     int sum = widgets.stream()\\n *                      .filter(w -\u003e w.getColor() == RED)\\n *                      .mapToInt(w -\u003e w.getWeight())\\n *                      .sum();\\n * }\u003c/pre\u003e\\n *\\n * In this example, {@code widgets} is a {@code Collection\u003cWidget\u003e}.  We create\\n * a stream of {@code Widget} objects via {@link Collection#stream Collection.stream()},\\n * filter it to produce a stream containing only the red widgets, and then\\n * transform it into a stream of {@code int} values representing the weight of\\n * each red widget. Then this stream is summed to produce a total weight.\\n *\\n * \u003cp\u003eIn addition to {@code Stream}, which is a stream of object references,\\n * there are primitive specializations for {@link IntStream}, {@link LongStream},\\n * and {@link DoubleStream}, all of which are referred to as \"streams\" and\\n * conform to the characteristics and restrictions described here.\\n *\\n * \u003cp\u003eTo perform a computation, stream\\n * \u003ca href=\"package-summary.html#StreamOps\"\u003eoperations\u003c/a\u003e are composed into a\\n * \u003cem\u003estream pipeline\u003c/em\u003e.  A stream pipeline consists of a source (which\\n * might be an array, a collection, a generator function, an I/O channel,\\n * etc), zero or more \u003cem\u003eintermediate operations\u003c/em\u003e (which transform a\\n * stream into another stream, such as {@link Stream#filter(Predicate)}), and a\\n * \u003cem\u003eterminal operation\u003c/em\u003e (which produces a result or side-effect, such\\n * as {@link Stream#count()} or {@link Stream#forEach(Consumer)}).\\n * Streams are lazy; computation on the source data is only performed when the\\n * terminal operation is initiated, and source elements are consumed only\\n * as needed.\\n *\\n * \u003cp\u003eA stream implementation is permitted significant latitude in optimizing\\n * the computation of the result.  For example, a stream implementation is free\\n * to elide operations (or entire stages) from a stream pipeline -- and\\n * therefore elide invocation of behavioral parameters -- if it can prove that\\n * it would not affect the result of the computation.  This means that\\n * side-effects of behavioral parameters may not always be executed and should\\n * not be relied upon, unless otherwise specified (such as by the terminal\\n * operations {@code forEach} and {@code forEachOrdered}). (For a specific\\n * example of such an optimization, see the API note documented on the\\n * {@link #count} operation.  For more detail, see the\\n * \u003ca href=\"package-summary.html#SideEffects\"\u003eside-effects\u003c/a\u003e section of the\\n * stream package documentation.)\\n *\\n * \u003cp\u003eCollections and streams, while bearing some superficial similarities,\\n * have different goals.  Collections are primarily concerned with the efficient\\n * management of, and access to, their elements.  By contrast, streams do not\\n * provide a means to directly access or manipulate their elements, and are\\n * instead concerned with declaratively describing their source and the\\n * computational operations which will be performed in aggregate on that source.\\n * However, if the provided stream operations do not offer the desired\\n * functionality, the {@link #iterator()} and {@link #spliterator()} operations\\n * can be used to perform a controlled traversal.\\n *\\n * \u003cp\u003eA stream pipeline, like the \"widgets\" example above, can be viewed as\\n * a \u003cem\u003equery\u003c/em\u003e on the stream source.  Unless the source was explicitly\\n * designed for concurrent modification (such as a {@link ConcurrentHashMap}),\\n * unpredictable or erroneous behavior may result from modifying the stream\\n * source while it is being queried.\\n *\\n * \u003cp\u003eMost stream operations accept parameters that describe user-specified\\n * behavior, such as the lambda expression {@code w -\u003e w.getWeight()} passed to\\n * {@code mapToInt} in the example above.  To preserve correct behavior,\\n * these \u003cem\u003ebehavioral parameters\u003c/em\u003e:\\n * \u003cul\u003e\\n * \u003cli\u003emust be \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e\\n * (they do not modify the stream source); and\u003c/li\u003e\\n * \u003cli\u003ein most cases must be \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n * (their result should not depend on any state that might change during execution\\n * of the stream pipeline).\u003c/li\u003e\\n * \u003c/ul\u003e\\n *\\n * \u003cp\u003eSuch parameters are always instances of a\\n * \u003ca href=\"../function/package-summary.html\"\u003efunctional interface\u003c/a\u003e such\\n * as {@link java.util.function.Function}, and are often lambda expressions or\\n * method references.  Unless otherwise specified these parameters must be\\n * \u003cem\u003enon-null\u003c/em\u003e.\\n *\\n * \u003cp\u003eA stream should be operated on (invoking an intermediate or terminal stream\\n * operation) only once.  This rules out, for example, \"forked\" streams, where\\n * the same source feeds two or more pipelines, or multiple traversals of the\\n * same stream.  A stream implementation may throw {@link IllegalStateException}\\n * if it detects that the stream is being reused. However, since some stream\\n * operations may return their receiver rather than a new stream object, it may\\n * not be possible to detect reuse in all cases.\\n *\\n * \u003cp\u003eStreams have a {@link #close()} method and implement {@link AutoCloseable}.\\n * Operating on a stream after it has been closed will throw {@link IllegalStateException}.\\n * Most stream instances do not actually need to be closed after use, as they\\n * are backed by collections, arrays, or generating functions, which require no\\n * special resource management. Generally, only streams whose source is an IO channel,\\n * such as those returned by {@link Files#lines(Path)}, will require closing. If a\\n * stream does require closing, it must be opened as a resource within a try-with-resources\\n * statement or similar control structure to ensure that it is closed promptly after its\\n * operations have completed.\\n *\\n * \u003cp\u003eStream pipelines may execute either sequentially or in\\n * \u003ca href=\"package-summary.html#Parallelism\"\u003eparallel\u003c/a\u003e.  This\\n * execution mode is a property of the stream.  Streams are created\\n * with an initial choice of sequential or parallel execution.  (For example,\\n * {@link Collection#stream() Collection.stream()} creates a sequential stream,\\n * and {@link Collection#parallelStream() Collection.parallelStream()} creates\\n * a parallel one.)  This choice of execution mode may be modified by the\\n * {@link #sequential()} or {@link #parallel()} methods, and may be queried with\\n * the {@link #isParallel()} method.\\n *\\n * @param \u003cT\u003e the type of the stream elements\\n * @since 1.8\\n * @see IntStream\\n * @see LongStream\\n * @see DoubleStream\\n * @see \u003ca href=\"package-summary.html\"\u003ejava.util.stream\u003c/a\u003e\\n \u0027}"}, {"color": "#97c2fc", "id": " Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)", "label": " Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the elements of this stream that match\\n     * the given predicate.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param predicate a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                  \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                  predicate to apply to each element to determine if it\\n     *                  should be included\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " Stream\u003cR\u003e map(Function\u003c? super T, ? extends R\u003e mapper)", "label": " Stream\u003cR\u003e map(Function\u003c? super T, ? extends R\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the results of applying the given\\n     * function to the elements of this stream.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param \u003cR\u003e The element type of the new stream\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function to apply to each element\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " IntStream mapToInt(ToIntFunction\u003c? super T\u003e mapper)", "label": " IntStream mapToInt(ToIntFunction\u003c? super T\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@code IntStream} consisting of the results of applying the\\n     * given function to the elements of this stream.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003e\\n     *     intermediate operation\u003c/a\u003e.\\n     *\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function to apply to each element\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " LongStream mapToLong(ToLongFunction\u003c? super T\u003e mapper)", "label": " LongStream mapToLong(ToLongFunction\u003c? super T\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code LongStream} consisting of the results of applying the\\n     * given function to the elements of this stream.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function to apply to each element\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " DoubleStream mapToDouble(ToDoubleFunction\u003c? super T\u003e mapper)", "label": " DoubleStream mapToDouble(ToDoubleFunction\u003c? super T\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code DoubleStream} consisting of the results of applying the\\n     * given function to the elements of this stream.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function to apply to each element\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " Stream\u003cR\u003e flatMap(Function\u003c? super T, ? extends Stream\u003c? extends R\u003e\u003e mapper)", "label": " Stream\u003cR\u003e flatMap(Function\u003c? super T, ? extends Stream\u003c? extends R\u003e\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the results of replacing each element of\\n     * this stream with the contents of a mapped stream produced by applying\\n     * the provided mapping function to each element.  Each mapped stream is\\n     * {@link java.util.stream.BaseStream#close() closed} after its contents\\n     * have been placed into this stream.  (If a mapped stream is {@code null}\\n     * an empty stream is used, instead.)\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @apiNote\\n     * The {@code flatMap()} operation has the effect of applying a one-to-many\\n     * transformation to the elements of the stream, and then flattening the\\n     * resulting elements into a new stream.\\n     *\\n     * \u003cp\u003e\u003cb\u003eExamples.\u003c/b\u003e\\n     *\\n     * \u003cp\u003eIf {@code orders} is a stream of purchase orders, and each purchase\\n     * order contains a collection of line items, then the following produces a\\n     * stream containing all the line items in all the orders:\\n     * \u003cpre\u003e{@code\\n     *     orders.flatMap(order -\u003e order.getLineItems().stream())...\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eIf {@code path} is the path to a file, then the following produces a\\n     * stream of the {@code words} contained in that file:\\n     * \u003cpre\u003e{@code\\n     *     Stream\u003cString\u003e lines = Files.lines(path, StandardCharsets.UTF_8);\\n     *     Stream\u003cString\u003e words = lines.flatMap(line -\u003e Stream.of(line.split(\" +\")));\\n     * }\u003c/pre\u003e\\n     * The {@code mapper} function passed to {@code flatMap} splits a line,\\n     * using a simple regular expression, into an array of words, and then\\n     * creates a stream of words from that array.\\n     *\\n     * @param \u003cR\u003e The element type of the new stream\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function to apply to each element which produces a stream\\n     *               of new values\\n     * @return the new stream\\n     * @see #mapMulti\\n     \u0027}"}, {"color": "#97c2fc", "id": " IntStream flatMapToInt(Function\u003c? super T, ? extends IntStream\u003e mapper)", "label": " IntStream flatMapToInt(Function\u003c? super T, ? extends IntStream\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@code IntStream} consisting of the results of replacing each\\n     * element of this stream with the contents of a mapped stream produced by\\n     * applying the provided mapping function to each element.  Each mapped\\n     * stream is {@link java.util.stream.BaseStream#close() closed} after its\\n     * contents have been placed into this stream.  (If a mapped stream is\\n     * {@code null} an empty stream is used, instead.)\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function to apply to each element which produces a stream\\n     *               of new values\\n     * @return the new stream\\n     * @see #flatMap(Function)\\n     \u0027}"}, {"color": "#97c2fc", "id": " LongStream flatMapToLong(Function\u003c? super T, ? extends LongStream\u003e mapper)", "label": " LongStream flatMapToLong(Function\u003c? super T, ? extends LongStream\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@code LongStream} consisting of the results of replacing each\\n     * element of this stream with the contents of a mapped stream produced by\\n     * applying the provided mapping function to each element.  Each mapped\\n     * stream is {@link java.util.stream.BaseStream#close() closed} after its\\n     * contents have been placed into this stream.  (If a mapped stream is\\n     * {@code null} an empty stream is used, instead.)\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function to apply to each element which produces a stream\\n     *               of new values\\n     * @return the new stream\\n     * @see #flatMap(Function)\\n     \u0027}"}, {"color": "#97c2fc", "id": " DoubleStream flatMapToDouble(Function\u003c? super T, ? extends DoubleStream\u003e mapper)", "label": " DoubleStream flatMapToDouble(Function\u003c? super T, ? extends DoubleStream\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@code DoubleStream} consisting of the results of replacing\\n     * each element of this stream with the contents of a mapped stream produced\\n     * by applying the provided mapping function to each element.  Each mapped\\n     * stream is {@link java.util.stream.BaseStream#close() closed} after its\\n     * contents have placed been into this stream.  (If a mapped stream is\\n     * {@code null} an empty stream is used, instead.)\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function to apply to each element which produces a stream\\n     *               of new values\\n     * @return the new stream\\n     * @see #flatMap(Function)\\n     \u0027}"}, {"color": "#97c2fc", "id": " Stream\u003cR\u003e mapMulti(BiConsumer\u003c? super T, ? super Consumer\u003cR\u003e\u003e mapper)", "label": " Stream\u003cR\u003e mapMulti(BiConsumer\u003c? super T, ? super Consumer\u003cR\u003e\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the results of replacing each element of\\n     * this stream with multiple elements, specifically zero or more elements.\\n     * Replacement is performed by applying the provided mapping function to each\\n     * element in conjunction with a {@linkplain Consumer consumer} argument\\n     * that accepts replacement elements. The mapping function calls the consumer\\n     * zero or more times to provide the replacement elements.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eIf the {@linkplain Consumer consumer} argument is used outside the scope of\\n     * its application to the mapping function, the results are undefined.\\n     *\\n     * @implSpec\\n     * The default implementation invokes {@link #flatMap flatMap} on this stream,\\n     * passing a function that behaves as follows. First, it calls the mapper function\\n     * with a {@code Consumer} that accumulates replacement elements into a newly created\\n     * internal buffer. When the mapper function returns, it creates a stream from the\\n     * internal buffer. Finally, it returns this stream to {@code flatMap}.\\n     *\\n     * @apiNote\\n     * This method is similar to {@link #flatMap flatMap} in that it applies a one-to-many\\n     * transformation to the elements of the stream and flattens the result elements\\n     * into a new stream. This method is preferable to {@code flatMap} in the following\\n     * circumstances:\\n     * \u003cul\u003e\\n     * \u003cli\u003eWhen replacing each stream element with a small (possibly zero) number of\\n     * elements. Using this method avoids the overhead of creating a new Stream instance\\n     * for every group of result elements, as required by {@code flatMap}.\u003c/li\u003e\\n     * \u003cli\u003eWhen it is easier to use an imperative approach for generating result\\n     * elements than it is to return them in the form of a Stream.\u003c/li\u003e\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003eIf a lambda expression is provided as the mapper function argument, additional type\\n     * information may be necessary for proper inference of the element type {@code \u003cR\u003e} of\\n     * the returned stream. This can be provided in the form of explicit type declarations for\\n     * the lambda parameters or as an explicit type argument to the {@code mapMulti} call.\\n     *\\n     * \u003cp\u003e\u003cb\u003eExamples\u003c/b\u003e\\n     *\\n     * \u003cp\u003eGiven a stream of {@code Number} objects, the following\\n     * produces a list containing only the {@code Integer} objects:\\n     * \u003cpre\u003e{@code\\n     *     Stream\u003cNumber\u003e numbers = ... ;\\n     *     List\u003cInteger\u003e integers = numbers.\u003cInteger\u003emapMulti((number, consumer) -\u003e {\\n     *             if (number instanceof Integer i)\\n     *                 consumer.accept(i);\\n     *         })\\n     *         .collect(Collectors.toList());\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eIf we have an {@code Iterable\u003cObject\u003e} and need to recursively expand its elements\\n     * that are themselves of type {@code Iterable}, we can use {@code mapMulti} as follows:\\n     * \u003cpre\u003e{@code\\n     * class C {\\n     *     static void expandIterable(Object e, Consumer\u003cObject\u003e c) {\\n     *         if (e instanceof Iterable\u003c?\u003e elements) {\\n     *             for (Object ie : elements) {\\n     *                 expandIterable(ie, c);\\n     *             }\\n     *         } else if (e != null) {\\n     *             c.accept(e);\\n     *         }\\n     *     }\\n     *\\n     *     public static void main(String[] args) {\\n     *         var nestedList = List.of(1, List.of(2, List.of(3, 4)), 5);\\n     *         Stream\u003cObject\u003e expandedStream = nestedList.stream().mapMulti(C::expandIterable);\\n     *     }\\n     * }\\n     * }\u003c/pre\u003e\\n     *\\n     * @param \u003cR\u003e The element type of the new stream\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function that generates replacement elements\\n     * @return the new stream\\n     * @see #flatMap flatMap\\n     * @since 16\\n     \u0027}"}, {"color": "#97c2fc", "id": " IntStream mapMultiToInt(BiConsumer\u003c? super T, ? super IntConsumer\u003e mapper)", "label": " IntStream mapMultiToInt(BiConsumer\u003c? super T, ? super IntConsumer\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@code IntStream} consisting of the results of replacing each\\n     * element of this stream with multiple elements, specifically zero or more\\n     * elements.\\n     * Replacement is performed by applying the provided mapping function to each\\n     * element in conjunction with a {@linkplain IntConsumer consumer} argument\\n     * that accepts replacement elements. The mapping function calls the consumer\\n     * zero or more times to provide the replacement elements.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eIf the {@linkplain IntConsumer consumer} argument is used outside the scope of\\n     * its application to the mapping function, the results are undefined.\\n     *\\n     * @implSpec\\n     * The default implementation invokes {@link #flatMapToInt flatMapToInt} on this stream,\\n     * passing a function that behaves as follows. First, it calls the mapper function\\n     * with an {@code IntConsumer} that accumulates replacement elements into a newly created\\n     * internal buffer. When the mapper function returns, it creates an {@code IntStream} from\\n     * the internal buffer. Finally, it returns this stream to {@code flatMapToInt}.\\n     *\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function that generates replacement elements\\n     * @return the new stream\\n     * @see #mapMulti mapMulti\\n     * @since 16\\n     \u0027}"}, {"color": "#97c2fc", "id": "flatMapToInt", "label": "flatMapToInt", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " LongStream mapMultiToLong(BiConsumer\u003c? super T, ? super LongConsumer\u003e mapper)", "label": " LongStream mapMultiToLong(BiConsumer\u003c? super T, ? super LongConsumer\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code LongStream} consisting of the results of replacing each\\n     * element of this stream with multiple elements, specifically zero or more\\n     * elements.\\n     * Replacement is performed by applying the provided mapping function to each\\n     * element in conjunction with a {@linkplain LongConsumer consumer} argument\\n     * that accepts replacement elements. The mapping function calls the consumer\\n     * zero or more times to provide the replacement elements.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eIf the {@linkplain LongConsumer consumer} argument is used outside the scope of\\n     * its application to the mapping function, the results are undefined.\\n     *\\n     * @implSpec\\n     * The default implementation invokes {@link #flatMapToLong flatMapToLong} on this stream,\\n     * passing a function that behaves as follows. First, it calls the mapper function\\n     * with a {@code LongConsumer} that accumulates replacement elements into a newly created\\n     * internal buffer. When the mapper function returns, it creates a {@code LongStream} from\\n     * the internal buffer. Finally, it returns this stream to {@code flatMapToLong}.\\n     *\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function that generates replacement elements\\n     * @return the new stream\\n     * @see #mapMulti mapMulti\\n     * @since 16\\n     \u0027}"}, {"color": "#97c2fc", "id": "flatMapToLong", "label": "flatMapToLong", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " DoubleStream mapMultiToDouble(BiConsumer\u003c? super T, ? super DoubleConsumer\u003e mapper)", "label": " DoubleStream mapMultiToDouble(BiConsumer\u003c? super T, ? super DoubleConsumer\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code DoubleStream} consisting of the results of replacing each\\n     * element of this stream with multiple elements, specifically zero or more\\n     * elements.\\n     * Replacement is performed by applying the provided mapping function to each\\n     * element in conjunction with a {@linkplain DoubleConsumer consumer} argument\\n     * that accepts replacement elements. The mapping function calls the consumer\\n     * zero or more times to provide the replacement elements.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eIf the {@linkplain DoubleConsumer consumer} argument is used outside the scope of\\n     * its application to the mapping function, the results are undefined.\\n     *\\n     * @implSpec\\n     * The default implementation invokes {@link #flatMapToDouble flatMapToDouble} on this stream,\\n     * passing a function that behaves as follows. First, it calls the mapper function\\n     * with an {@code DoubleConsumer} that accumulates replacement elements into a newly created\\n     * internal buffer. When the mapper function returns, it creates a {@code DoubleStream} from\\n     * the internal buffer. Finally, it returns this stream to {@code flatMapToDouble}.\\n     *\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function that generates replacement elements\\n     * @return the new stream\\n     * @see #mapMulti mapMulti\\n     * @since 16\\n     \u0027}"}, {"color": "#97c2fc", "id": "flatMapToDouble", "label": "flatMapToDouble", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " Stream\u003cT\u003e distinct()", "label": " Stream\u003cT\u003e distinct()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the distinct elements (according to\\n     * {@link Object#equals(Object)}) of this stream.\\n     *\\n     * \u003cp\u003eFor ordered streams, the selection of distinct elements is stable\\n     * (for duplicated elements, the element appearing first in the encounter\\n     * order is preserved.)  For unordered streams, no stability guarantees\\n     * are made.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003estateful\\n     * intermediate operation\u003c/a\u003e.\\n     *\\n     * @apiNote\\n     * Preserving stability for {@code distinct()} in parallel pipelines is\\n     * relatively expensive (requires that the operation act as a full barrier,\\n     * with substantial buffering overhead), and stability is often not needed.\\n     * Using an unordered stream source (such as {@link #generate(Supplier)})\\n     * or removing the ordering constraint with {@link #unordered()} may result\\n     * in significantly more efficient execution for {@code distinct()} in parallel\\n     * pipelines, if the semantics of your situation permit.  If consistency\\n     * with encounter order is required, and you are experiencing poor performance\\n     * or memory utilization with {@code distinct()} in parallel pipelines,\\n     * switching to sequential execution with {@link #sequential()} may improve\\n     * performance.\\n     *\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "generate(Supplier)", "label": "generate(Supplier)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "unordered()", "label": "unordered()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "sequential()", "label": "sequential()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " Stream\u003cT\u003e sorted()", "label": " Stream\u003cT\u003e sorted()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the elements of this stream, sorted\\n     * according to natural order.  If the elements of this stream are not\\n     * {@code Comparable}, a {@code java.lang.ClassCastException} may be thrown\\n     * when the terminal operation is executed.\\n     *\\n     * \u003cp\u003eFor ordered streams, the sort is stable.  For unordered streams, no\\n     * stability guarantees are made.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003estateful\\n     * intermediate operation\u003c/a\u003e.\\n     *\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " Stream\u003cT\u003e sorted(Comparator\u003c? super T\u003e comparator)", "label": " Stream\u003cT\u003e sorted(Comparator\u003c? super T\u003e comparator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the elements of this stream, sorted\\n     * according to the provided {@code Comparator}.\\n     *\\n     * \u003cp\u003eFor ordered streams, the sort is stable.  For unordered streams, no\\n     * stability guarantees are made.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003estateful\\n     * intermediate operation\u003c/a\u003e.\\n     *\\n     * @param comparator a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                   \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                   {@code Comparator} to be used to compare stream elements\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " Stream\u003cT\u003e peek(Consumer\u003c? super T\u003e action)", "label": " Stream\u003cT\u003e peek(Consumer\u003c? super T\u003e action)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the elements of this stream, additionally\\n     * performing the provided action on each element as elements are consumed\\n     * from the resulting stream.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eFor parallel stream pipelines, the action may be called at\\n     * whatever time and in whatever thread the element is made available by the\\n     * upstream operation.  If the action modifies shared state,\\n     * it is responsible for providing the required synchronization.\\n     *\\n     * @apiNote This method exists mainly to support debugging, where you want\\n     * to see the elements as they flow past a certain point in a pipeline:\\n     * \u003cpre\u003e{@code\\n     *     Stream.of(\"one\", \"two\", \"three\", \"four\")\\n     *         .filter(e -\u003e e.length() \u003e 3)\\n     *         .peek(e -\u003e System.out.println(\"Filtered value: \" + e))\\n     *         .map(String::toUpperCase)\\n     *         .peek(e -\u003e System.out.println(\"Mapped value: \" + e))\\n     *         .collect(Collectors.toList());\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eIn cases where the stream implementation is able to optimize away the\\n     * production of some or all the elements (such as with short-circuiting\\n     * operations like {@code findFirst}, or in the example described in\\n     * {@link #count}), the action will not be invoked for those elements.\\n     *\\n     * @param action a \u003ca href=\"package-summary.html#NonInterference\"\u003e\\n     *                 non-interfering\u003c/a\u003e action to perform on the elements as\\n     *                 they are consumed from the stream\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "count", "label": "count", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " Stream\u003cT\u003e limit(long maxSize)", "label": " Stream\u003cT\u003e limit(long maxSize)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the elements of this stream, truncated\\n     * to be no longer than {@code maxSize} in length.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * stateful intermediate operation\u003c/a\u003e.\\n     *\\n     * @apiNote\\n     * While {@code limit()} is generally a cheap operation on sequential\\n     * stream pipelines, it can be quite expensive on ordered parallel pipelines,\\n     * especially for large values of {@code maxSize}, since {@code limit(n)}\\n     * is constrained to return not just any \u003cem\u003en\u003c/em\u003e elements, but the\\n     * \u003cem\u003efirst n\u003c/em\u003e elements in the encounter order.  Using an unordered\\n     * stream source (such as {@link #generate(Supplier)}) or removing the\\n     * ordering constraint with {@link #unordered()} may result in significant\\n     * speedups of {@code limit()} in parallel pipelines, if the semantics of\\n     * your situation permit.  If consistency with encounter order is required,\\n     * and you are experiencing poor performance or memory utilization with\\n     * {@code limit()} in parallel pipelines, switching to sequential execution\\n     * with {@link #sequential()} may improve performance.\\n     *\\n     * @param maxSize the number of elements the stream should be limited to\\n     * @return the new stream\\n     * @throws IllegalArgumentException if {@code maxSize} is negative\\n     \u0027}"}, {"color": "#97c2fc", "id": " Stream\u003cT\u003e skip(long n)", "label": " Stream\u003cT\u003e skip(long n)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the remaining elements of this stream\\n     * after discarding the first {@code n} elements of the stream.\\n     * If this stream contains fewer than {@code n} elements then an\\n     * empty stream will be returned.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003estateful\\n     * intermediate operation\u003c/a\u003e.\\n     *\\n     * @apiNote\\n     * While {@code skip()} is generally a cheap operation on sequential\\n     * stream pipelines, it can be quite expensive on ordered parallel pipelines,\\n     * especially for large values of {@code n}, since {@code skip(n)}\\n     * is constrained to skip not just any \u003cem\u003en\u003c/em\u003e elements, but the\\n     * \u003cem\u003efirst n\u003c/em\u003e elements in the encounter order.  Using an unordered\\n     * stream source (such as {@link #generate(Supplier)}) or removing the\\n     * ordering constraint with {@link #unordered()} may result in significant\\n     * speedups of {@code skip()} in parallel pipelines, if the semantics of\\n     * your situation permit.  If consistency with encounter order is required,\\n     * and you are experiencing poor performance or memory utilization with\\n     * {@code skip()} in parallel pipelines, switching to sequential execution\\n     * with {@link #sequential()} may improve performance.\\n     *\\n     * @param n the number of leading elements to skip\\n     * @return the new stream\\n     * @throws IllegalArgumentException if {@code n} is negative\\n     \u0027}"}, {"color": "#97c2fc", "id": " Stream\u003cT\u003e takeWhile(Predicate\u003c? super T\u003e predicate)", "label": " Stream\u003cT\u003e takeWhile(Predicate\u003c? super T\u003e predicate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns, if this stream is ordered, a stream consisting of the longest\\n     * prefix of elements taken from this stream that match the given predicate.\\n     * Otherwise returns, if this stream is unordered, a stream consisting of a\\n     * subset of elements taken from this stream that match the given predicate.\\n     *\\n     * \u003cp\u003eIf this stream is ordered then the longest prefix is a contiguous\\n     * sequence of elements of this stream that match the given predicate.  The\\n     * first element of the sequence is the first element of this stream, and\\n     * the element immediately following the last element of the sequence does\\n     * not match the given predicate.\\n     *\\n     * \u003cp\u003eIf this stream is unordered, and some (but not all) elements of this\\n     * stream match the given predicate, then the behavior of this operation is\\n     * nondeterministic; it is free to take any subset of matching elements\\n     * (which includes the empty set).\\n     *\\n     * \u003cp\u003eIndependent of whether this stream is ordered or unordered if all\\n     * elements of this stream match the given predicate then this operation\\n     * takes all elements (the result is the same as the input), or if no\\n     * elements of the stream match the given predicate then no elements are\\n     * taken (the result is an empty stream).\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * stateful intermediate operation\u003c/a\u003e.\\n     *\\n     * @implSpec\\n     * The default implementation obtains the {@link #spliterator() spliterator}\\n     * of this stream, wraps that spliterator so as to support the semantics\\n     * of this operation on traversal, and returns a new stream associated with\\n     * the wrapped spliterator.  The returned stream preserves the execution\\n     * characteristics of this stream (namely parallel or sequential execution\\n     * as per {@link #isParallel()}) but the wrapped spliterator may choose to\\n     * not support splitting.  When the returned stream is closed, the close\\n     * handlers for both the returned and this stream are invoked.\\n     *\\n     * @apiNote\\n     * While {@code takeWhile()} is generally a cheap operation on sequential\\n     * stream pipelines, it can be quite expensive on ordered parallel\\n     * pipelines, since the operation is constrained to return not just any\\n     * valid prefix, but the longest prefix of elements in the encounter order.\\n     * Using an unordered stream source (such as {@link #generate(Supplier)}) or\\n     * removing the ordering constraint with {@link #unordered()} may result in\\n     * significant speedups of {@code takeWhile()} in parallel pipelines, if the\\n     * semantics of your situation permit.  If consistency with encounter order\\n     * is required, and you are experiencing poor performance or memory\\n     * utilization with {@code takeWhile()} in parallel pipelines, switching to\\n     * sequential execution with {@link #sequential()} may improve performance.\\n     *\\n     * @param predicate a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                  \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                  predicate to apply to elements to determine the longest\\n     *                  prefix of elements.\\n     * @return the new stream\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "spliterator()", "label": "spliterator()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "isParallel()", "label": "isParallel()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " Stream\u003cT\u003e dropWhile(Predicate\u003c? super T\u003e predicate)", "label": " Stream\u003cT\u003e dropWhile(Predicate\u003c? super T\u003e predicate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns, if this stream is ordered, a stream consisting of the remaining\\n     * elements of this stream after dropping the longest prefix of elements\\n     * that match the given predicate.  Otherwise returns, if this stream is\\n     * unordered, a stream consisting of the remaining elements of this stream\\n     * after dropping a subset of elements that match the given predicate.\\n     *\\n     * \u003cp\u003eIf this stream is ordered then the longest prefix is a contiguous\\n     * sequence of elements of this stream that match the given predicate.  The\\n     * first element of the sequence is the first element of this stream, and\\n     * the element immediately following the last element of the sequence does\\n     * not match the given predicate.\\n     *\\n     * \u003cp\u003eIf this stream is unordered, and some (but not all) elements of this\\n     * stream match the given predicate, then the behavior of this operation is\\n     * nondeterministic; it is free to drop any subset of matching elements\\n     * (which includes the empty set).\\n     *\\n     * \u003cp\u003eIndependent of whether this stream is ordered or unordered if all\\n     * elements of this stream match the given predicate then this operation\\n     * drops all elements (the result is an empty stream), or if no elements of\\n     * the stream match the given predicate then no elements are dropped (the\\n     * result is the same as the input).\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003estateful\\n     * intermediate operation\u003c/a\u003e.\\n     *\\n     * @implSpec\\n     * The default implementation obtains the {@link #spliterator() spliterator}\\n     * of this stream, wraps that spliterator so as to support the semantics\\n     * of this operation on traversal, and returns a new stream associated with\\n     * the wrapped spliterator.  The returned stream preserves the execution\\n     * characteristics of this stream (namely parallel or sequential execution\\n     * as per {@link #isParallel()}) but the wrapped spliterator may choose to\\n     * not support splitting.  When the returned stream is closed, the close\\n     * handlers for both the returned and this stream are invoked.\\n     *\\n     * @apiNote\\n     * While {@code dropWhile()} is generally a cheap operation on sequential\\n     * stream pipelines, it can be quite expensive on ordered parallel\\n     * pipelines, since the operation is constrained to return not just any\\n     * valid prefix, but the longest prefix of elements in the encounter order.\\n     * Using an unordered stream source (such as {@link #generate(Supplier)}) or\\n     * removing the ordering constraint with {@link #unordered()} may result in\\n     * significant speedups of {@code dropWhile()} in parallel pipelines, if the\\n     * semantics of your situation permit.  If consistency with encounter order\\n     * is required, and you are experiencing poor performance or memory\\n     * utilization with {@code dropWhile()} in parallel pipelines, switching to\\n     * sequential execution with {@link #sequential()} may improve performance.\\n     *\\n     * @param predicate a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                  \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                  predicate to apply to elements to determine the longest\\n     *                  prefix of elements.\\n     * @return the new stream\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " void forEach(Consumer\u003c? super T\u003e action)", "label": " void forEach(Consumer\u003c? super T\u003e action)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs an action for each element of this stream.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eThe behavior of this operation is explicitly nondeterministic.\\n     * For parallel stream pipelines, this operation does \u003cem\u003enot\u003c/em\u003e\\n     * guarantee to respect the encounter order of the stream, as doing so\\n     * would sacrifice the benefit of parallelism.  For any given element, the\\n     * action may be performed at whatever time and in whatever thread the\\n     * library chooses.  If the action accesses shared state, it is\\n     * responsible for providing the required synchronization.\\n     *\\n     * @param action a \u003ca href=\"package-summary.html#NonInterference\"\u003e\\n     *               non-interfering\u003c/a\u003e action to perform on the elements\\n     \u0027}"}, {"color": "#97c2fc", "id": " void forEachOrdered(Consumer\u003c? super T\u003e action)", "label": " void forEachOrdered(Consumer\u003c? super T\u003e action)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs an action for each element of this stream, in the encounter\\n     * order of the stream if the stream has a defined encounter order.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eThis operation processes the elements one at a time, in encounter\\n     * order if one exists.  Performing the action for one element\\n     * \u003ca href=\"../concurrent/package-summary.html#MemoryVisibility\"\u003e\u003ci\u003ehappens-before\u003c/i\u003e\u003c/a\u003e\\n     * performing the action for subsequent elements, but for any given element,\\n     * the action may be performed in whatever thread the library chooses.\\n     *\\n     * @param action a \u003ca href=\"package-summary.html#NonInterference\"\u003e\\n     *               non-interfering\u003c/a\u003e action to perform on the elements\\n     * @see #forEach(Consumer)\\n     \u0027}"}, {"color": "#97c2fc", "id": " A[] toArray(IntFunction\u003cA[]\u003e generator)", "label": " A[] toArray(IntFunction\u003cA[]\u003e generator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an array containing the elements of this stream, using the\\n     * provided {@code generator} function to allocate the returned array, as\\n     * well as any additional arrays that might be required for a partitioned\\n     * execution or for resizing.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @apiNote\\n     * The generator function takes an integer, which is the size of the\\n     * desired array, and produces an array of the desired size.  This can be\\n     * concisely expressed with an array constructor reference:\\n     * \u003cpre\u003e{@code\\n     *     Person[] men = people.stream()\\n     *                          .filter(p -\u003e p.getGender() == MALE)\\n     *                          .toArray(Person[]::new);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param \u003cA\u003e the component type of the resulting array\\n     * @param generator a function which produces a new array of the desired\\n     *                  type and the provided length\\n     * @return an array containing the elements in this stream\\n     * @throws ArrayStoreException if the runtime type of any element of this\\n     *         stream is not assignable to the {@linkplain Class#getComponentType\\n     *         runtime component type} of the generated array\\n     \u0027}"}, {"color": "#97c2fc", "id": " T reduce(T identity, BinaryOperator\u003cT\u003e accumulator)", "label": " T reduce(T identity, BinaryOperator\u003cT\u003e accumulator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs a \u003ca href=\"package-summary.html#Reduction\"\u003ereduction\u003c/a\u003e on the\\n     * elements of this stream, using the provided identity value and an\\n     * \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e\\n     * accumulation function, and returns the reduced value.  This is equivalent\\n     * to:\\n     * \u003cpre\u003e{@code\\n     *     T result = identity;\\n     *     for (T element : this stream)\\n     *         result = accumulator.apply(result, element)\\n     *     return result;\\n     * }\u003c/pre\u003e\\n     *\\n     * but is not constrained to execute sequentially.\\n     *\\n     * \u003cp\u003eThe {@code identity} value must be an identity for the accumulator\\n     * function. This means that for all {@code t},\\n     * {@code accumulator.apply(identity, t)} is equal to {@code t}.\\n     * The {@code accumulator} function must be an\\n     * \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e function.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @apiNote Sum, min, max, average, and string concatenation are all special\\n     * cases of reduction. Summing a stream of numbers can be expressed as:\\n     *\\n     * \u003cpre\u003e{@code\\n     *     Integer sum = integers.reduce(0, (a, b) -\u003e a+b);\\n     * }\u003c/pre\u003e\\n     *\\n     * or:\\n     *\\n     * \u003cpre\u003e{@code\\n     *     Integer sum = integers.reduce(0, Integer::sum);\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eWhile this may seem a more roundabout way to perform an aggregation\\n     * compared to simply mutating a running total in a loop, reduction\\n     * operations parallelize more gracefully, without needing additional\\n     * synchronization and with greatly reduced risk of data races.\\n     *\\n     * @param identity the identity value for the accumulating function\\n     * @param accumulator an \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e,\\n     *                    \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                    \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                    function for combining two values\\n     * @return the result of the reduction\\n     \u0027}"}, {"color": "#97c2fc", "id": " Optional\u003cT\u003e reduce(BinaryOperator\u003cT\u003e accumulator)", "label": " Optional\u003cT\u003e reduce(BinaryOperator\u003cT\u003e accumulator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs a \u003ca href=\"package-summary.html#Reduction\"\u003ereduction\u003c/a\u003e on the\\n     * elements of this stream, using an\\n     * \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e accumulation\\n     * function, and returns an {@code Optional} describing the reduced value,\\n     * if any. This is equivalent to:\\n     * \u003cpre\u003e{@code\\n     *     boolean foundAny = false;\\n     *     T result = null;\\n     *     for (T element : this stream) {\\n     *         if (!foundAny) {\\n     *             foundAny = true;\\n     *             result = element;\\n     *         }\\n     *         else\\n     *             result = accumulator.apply(result, element);\\n     *     }\\n     *     return foundAny ? Optional.of(result) : Optional.empty();\\n     * }\u003c/pre\u003e\\n     *\\n     * but is not constrained to execute sequentially.\\n     *\\n     * \u003cp\u003eThe {@code accumulator} function must be an\\n     * \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e function.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param accumulator an \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e,\\n     *                    \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                    \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                    function for combining two values\\n     * @return an {@link Optional} describing the result of the reduction\\n     * @throws NullPointerException if the result of the reduction is null\\n     * @see #reduce(Object, BinaryOperator)\\n     * @see #min(Comparator)\\n     * @see #max(Comparator)\\n     \u0027}"}, {"color": "#97c2fc", "id": "Optional", "label": "Optional", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": " U reduce(U identity, BiFunction\u003cU, ? super T, U\u003e accumulator, BinaryOperator\u003cU\u003e combiner)", "label": " U reduce(U identity, BiFunction\u003cU, ? super T, U\u003e accumulator, BinaryOperator\u003cU\u003e combiner)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs a \u003ca href=\"package-summary.html#Reduction\"\u003ereduction\u003c/a\u003e on the\\n     * elements of this stream, using the provided identity, accumulation and\\n     * combining functions.  This is equivalent to:\\n     * \u003cpre\u003e{@code\\n     *     U result = identity;\\n     *     for (T element : this stream)\\n     *         result = accumulator.apply(result, element)\\n     *     return result;\\n     * }\u003c/pre\u003e\\n     *\\n     * but is not constrained to execute sequentially.\\n     *\\n     * \u003cp\u003eThe {@code identity} value must be an identity for the combiner\\n     * function.  This means that for all {@code u}, {@code combiner(identity, u)}\\n     * is equal to {@code u}.  Additionally, the {@code combiner} function\\n     * must be compatible with the {@code accumulator} function; for all\\n     * {@code u} and {@code t}, the following must hold:\\n     * \u003cpre\u003e{@code\\n     *     combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @apiNote Many reductions using this form can be represented more simply\\n     * by an explicit combination of {@code map} and {@code reduce} operations.\\n     * The {@code accumulator} function acts as a fused mapper and accumulator,\\n     * which can sometimes be more efficient than separate mapping and reduction,\\n     * such as when knowing the previously reduced value allows you to avoid\\n     * some computation.\\n     *\\n     * @param \u003cU\u003e The type of the result\\n     * @param identity the identity value for the combiner function\\n     * @param accumulator an \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e,\\n     *                    \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                    \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                    function for incorporating an additional element into a result\\n     * @param combiner an \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e,\\n     *                    \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                    \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                    function for combining two values, which must be\\n     *                    compatible with the accumulator function\\n     * @return the result of the reduction\\n     * @see #reduce(BinaryOperator)\\n     * @see #reduce(Object, BinaryOperator)\\n     \u0027}"}, {"color": "#97c2fc", "id": " R collect(Supplier\u003cR\u003e supplier, BiConsumer\u003cR, ? super T\u003e accumulator, BiConsumer\u003cR, R\u003e combiner)", "label": " R collect(Supplier\u003cR\u003e supplier, BiConsumer\u003cR, ? super T\u003e accumulator, BiConsumer\u003cR, R\u003e combiner)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs a \u003ca href=\"package-summary.html#MutableReduction\"\u003emutable\\n     * reduction\u003c/a\u003e operation on the elements of this stream.  A mutable\\n     * reduction is one in which the reduced value is a mutable result container,\\n     * such as an {@code ArrayList}, and elements are incorporated by updating\\n     * the state of the result rather than by replacing the result.  This\\n     * produces a result equivalent to:\\n     * \u003cpre\u003e{@code\\n     *     R result = supplier.get();\\n     *     for (T element : this stream)\\n     *         accumulator.accept(result, element);\\n     *     return result;\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eLike {@link #reduce(Object, BinaryOperator)}, {@code collect} operations\\n     * can be parallelized without requiring additional synchronization.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @apiNote There are many existing classes in the JDK whose signatures are\\n     * well-suited for use with method references as arguments to {@code collect()}.\\n     * For example, the following will accumulate strings into an {@code ArrayList}:\\n     * \u003cpre\u003e{@code\\n     *     List\u003cString\u003e asList = stringStream.collect(ArrayList::new, ArrayList::add,\\n     *                                                ArrayList::addAll);\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eThe following will take a stream of strings and concatenates them into a\\n     * single string:\\n     * \u003cpre\u003e{@code\\n     *     String concat = stringStream.collect(StringBuilder::new, StringBuilder::append,\\n     *                                          StringBuilder::append)\\n     *                                 .toString();\\n     * }\u003c/pre\u003e\\n     *\\n     * @param \u003cR\u003e the type of the mutable result container\\n     * @param supplier a function that creates a new mutable result container.\\n     *                 For a parallel execution, this function may be called\\n     *                 multiple times and must return a fresh value each time.\\n     * @param accumulator an \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e,\\n     *                    \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                    \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                    function that must fold an element into a result\\n     *                    container.\\n     * @param combiner an \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e,\\n     *                    \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                    \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                    function that accepts two partial result containers\\n     *                    and merges them, which must be compatible with the\\n     *                    accumulator function.  The combiner function must fold\\n     *                    the elements from the second result container into the\\n     *                    first result container.\\n     * @return the result of the reduction\\n     \u0027}"}, {"color": "#97c2fc", "id": "reduce(Object", "label": "reduce(Object", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " R collect(Collector\u003c? super T, A, R\u003e collector)", "label": " R collect(Collector\u003c? super T, A, R\u003e collector)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs a \u003ca href=\"package-summary.html#MutableReduction\"\u003emutable\\n     * reduction\u003c/a\u003e operation on the elements of this stream using a\\n     * {@code Collector}.  A {@code Collector}\\n     * encapsulates the functions used as arguments to\\n     * {@link #collect(Supplier, BiConsumer, BiConsumer)}, allowing for reuse of\\n     * collection strategies and composition of collect operations such as\\n     * multiple-level grouping or partitioning.\\n     *\\n     * \u003cp\u003eIf the stream is parallel, and the {@code Collector}\\n     * is {@link Collector.Characteristics#CONCURRENT concurrent}, and\\n     * either the stream is unordered or the collector is\\n     * {@link Collector.Characteristics#UNORDERED unordered},\\n     * then a concurrent reduction will be performed (see {@link Collector} for\\n     * details on concurrent reduction.)\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eWhen executed in parallel, multiple intermediate results may be\\n     * instantiated, populated, and merged so as to maintain isolation of\\n     * mutable data structures.  Therefore, even when executed in parallel\\n     * with non-thread-safe data structures (such as {@code ArrayList}), no\\n     * additional synchronization is needed for a parallel reduction.\\n     *\\n     * @apiNote\\n     * The following will accumulate strings into a List:\\n     * \u003cpre\u003e{@code\\n     *     List\u003cString\u003e asList = stringStream.collect(Collectors.toList());\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eThe following will classify {@code Person} objects by city:\\n     * \u003cpre\u003e{@code\\n     *     Map\u003cString, List\u003cPerson\u003e\u003e peopleByCity\\n     *         = personStream.collect(Collectors.groupingBy(Person::getCity));\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eThe following will classify {@code Person} objects by state and city,\\n     * cascading two {@code Collector}s together:\\n     * \u003cpre\u003e{@code\\n     *     Map\u003cString, Map\u003cString, List\u003cPerson\u003e\u003e\u003e peopleByStateAndCity\\n     *         = personStream.collect(Collectors.groupingBy(Person::getState,\\n     *                                                      Collectors.groupingBy(Person::getCity)));\\n     * }\u003c/pre\u003e\\n     *\\n     * @param \u003cR\u003e the type of the result\\n     * @param \u003cA\u003e the intermediate accumulation type of the {@code Collector}\\n     * @param collector the {@code Collector} describing the reduction\\n     * @return the result of the reduction\\n     * @see #collect(Supplier, BiConsumer, BiConsumer)\\n     * @see Collectors\\n     \u0027}"}, {"color": "#97c2fc", "id": "UNORDERED", "label": "UNORDERED", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.util.stream.Collector", "label": "java.util.stream.Collector", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * A \u003ca href=\"package-summary.html#Reduction\"\u003emutable reduction operation\u003c/a\u003e that\\n * accumulates input elements into a mutable result container, optionally transforming\\n * the accumulated result into a final representation after all input elements\\n * have been processed.  Reduction operations can be performed either sequentially\\n * or in parallel.\\n *\\n * \u003cp\u003eExamples of mutable reduction operations include:\\n * accumulating elements into a {@code Collection}; concatenating\\n * strings using a {@code StringBuilder}; computing summary information about\\n * elements such as sum, min, max, or average; computing \"pivot table\" summaries\\n * such as \"maximum valued transaction by seller\", etc.  The class {@link Collectors}\\n * provides implementations of many common mutable reductions.\\n *\\n * \u003cp\u003eA {@code Collector} is specified by four functions that work together to\\n * accumulate entries into a mutable result container, and optionally perform\\n * a final transform on the result.  They are: \u003cul\u003e\\n *     \u003cli\u003ecreation of a new result container ({@link #supplier()})\u003c/li\u003e\\n *     \u003cli\u003eincorporating a new data element into a result container ({@link #accumulator()})\u003c/li\u003e\\n *     \u003cli\u003ecombining two result containers into one ({@link #combiner()})\u003c/li\u003e\\n *     \u003cli\u003eperforming an optional final transform on the container ({@link #finisher()})\u003c/li\u003e\\n * \u003c/ul\u003e\\n *\\n * \u003cp\u003eCollectors also have a set of characteristics, such as\\n * {@link Characteristics#CONCURRENT}, that provide hints that can be used by a\\n * reduction implementation to provide better performance.\\n *\\n * \u003cp\u003eA sequential implementation of a reduction using a collector would\\n * create a single result container using the supplier function, and invoke the\\n * accumulator function once for each input element.  A parallel implementation\\n * would partition the input, create a result container for each partition,\\n * accumulate the contents of each partition into a subresult for that partition,\\n * and then use the combiner function to merge the subresults into a combined\\n * result.\\n *\\n * \u003cp\u003eTo ensure that sequential and parallel executions produce equivalent\\n * results, the collector functions must satisfy an \u003cem\u003eidentity\u003c/em\u003e and an\\n * \u003ca href=\"package-summary.html#Associativity\"\u003eassociativity\u003c/a\u003e constraints.\\n *\\n * \u003cp\u003eThe identity constraint says that for any partially accumulated result,\\n * combining it with an empty result container must produce an equivalent\\n * result.  That is, for a partially accumulated result {@code a} that is the\\n * result of any series of accumulator and combiner invocations, {@code a} must\\n * be equivalent to {@code combiner.apply(a, supplier.get())}.\\n *\\n * \u003cp\u003eThe associativity constraint says that splitting the computation must\\n * produce an equivalent result.  That is, for any input elements {@code t1}\\n * and {@code t2}, the results {@code r1} and {@code r2} in the computation\\n * below must be equivalent:\\n * \u003cpre\u003e{@code\\n *     A a1 = supplier.get();\\n *     accumulator.accept(a1, t1);\\n *     accumulator.accept(a1, t2);\\n *     R r1 = finisher.apply(a1);  // result without splitting\\n *\\n *     A a2 = supplier.get();\\n *     accumulator.accept(a2, t1);\\n *     A a3 = supplier.get();\\n *     accumulator.accept(a3, t2);\\n *     R r2 = finisher.apply(combiner.apply(a2, a3));  // result with splitting\\n * } \u003c/pre\u003e\\n *\\n * \u003cp\u003eFor collectors that do not have the {@code UNORDERED} characteristic,\\n * two accumulated results {@code a1} and {@code a2} are equivalent if\\n * {@code finisher.apply(a1).equals(finisher.apply(a2))}.  For unordered\\n * collectors, equivalence is relaxed to allow for non-equality related to\\n * differences in order.  (For example, an unordered collector that accumulated\\n * elements to a {@code List} would consider two lists equivalent if they\\n * contained the same elements, ignoring order.)\\n *\\n * \u003cp\u003eLibraries that implement reduction based on {@code Collector}, such as\\n * {@link Stream#collect(Collector)}, must adhere to the following constraints:\\n * \u003cul\u003e\\n *     \u003cli\u003eThe first argument passed to the accumulator function, both\\n *     arguments passed to the combiner function, and the argument passed to the\\n *     finisher function must be the result of a previous invocation of the\\n *     result supplier, accumulator, or combiner functions.\u003c/li\u003e\\n *     \u003cli\u003eThe implementation should not do anything with the result of any of\\n *     the result supplier, accumulator, or combiner functions other than to\\n *     pass them again to the accumulator, combiner, or finisher functions,\\n *     or return them to the caller of the reduction operation.\u003c/li\u003e\\n *     \u003cli\u003eIf a result is passed to the combiner or finisher\\n *     function, and the same object is not returned from that function, it is\\n *     never used again.\u003c/li\u003e\\n *     \u003cli\u003eOnce a result is passed to the combiner or finisher function, it\\n *     is never passed to the accumulator function again.\u003c/li\u003e\\n *     \u003cli\u003eFor non-concurrent collectors, any result returned from the result\\n *     supplier, accumulator, or combiner functions must be serially\\n *     thread-confined.  This enables collection to occur in parallel without\\n *     the {@code Collector} needing to implement any additional synchronization.\\n *     The reduction implementation must manage that the input is properly\\n *     partitioned, that partitions are processed in isolation, and combining\\n *     happens only after accumulation is complete.\u003c/li\u003e\\n *     \u003cli\u003eFor concurrent collectors, an implementation is free to (but not\\n *     required to) implement reduction concurrently.  A concurrent reduction\\n *     is one where the accumulator function is called concurrently from\\n *     multiple threads, using the same concurrently-modifiable result container,\\n *     rather than keeping the result isolated during accumulation.\\n *     A concurrent reduction should only be applied if the collector has the\\n *     {@link Characteristics#UNORDERED} characteristics or if the\\n *     originating data is unordered.\u003c/li\u003e\\n * \u003c/ul\u003e\\n *\\n * \u003cp\u003eIn addition to the predefined implementations in {@link Collectors}, the\\n * static factory methods {@link #of(Supplier, BiConsumer, BinaryOperator, Characteristics...)}\\n * can be used to construct collectors.  For example, you could create a collector\\n * that accumulates widgets into a {@code TreeSet} with:\\n *\\n * \u003cpre\u003e{@code\\n *     Collector\u003cWidget, ?, TreeSet\u003cWidget\u003e\u003e intoSet =\\n *         Collector.of(TreeSet::new, TreeSet::add,\\n *                      (left, right) -\u003e { left.addAll(right); return left; });\\n * }\u003c/pre\u003e\\n *\\n * (This behavior is also implemented by the predefined collector\\n * {@link Collectors#toCollection(Supplier)}).\\n *\\n * @apiNote\\n * Performing a reduction operation with a {@code Collector} should produce a\\n * result equivalent to:\\n * \u003cpre\u003e{@code\\n *     A container = collector.supplier().get();\\n *     for (T t : data)\\n *         collector.accumulator().accept(container, t);\\n *     return collector.finisher().apply(container);\\n * }\u003c/pre\u003e\\n *\\n * \u003cp\u003eHowever, the library is free to partition the input, perform the reduction\\n * on the partitions, and then use the combiner function to combine the partial\\n * results to achieve a parallel reduction.  (Depending on the specific reduction\\n * operation, this may perform better or worse, depending on the relative cost\\n * of the accumulator and combiner functions.)\\n *\\n * \u003cp\u003eCollectors are designed to be \u003cem\u003ecomposed\u003c/em\u003e; many of the methods\\n * in {@link Collectors} are functions that take a collector and produce\\n * a new collector.  For example, given the following collector that computes\\n * the sum of the salaries of a stream of employees:\\n *\\n * \u003cpre\u003e{@code\\n *     Collector\u003cEmployee, ?, Integer\u003e summingSalaries\\n *         = Collectors.summingInt(Employee::getSalary))\\n * }\u003c/pre\u003e\\n *\\n * If we wanted to create a collector to tabulate the sum of salaries by\\n * department, we could reuse the \"sum of salaries\" logic using\\n * {@link Collectors#groupingBy(Function, Collector)}:\\n *\\n * \u003cpre\u003e{@code\\n *     Collector\u003cEmployee, ?, Map\u003cDepartment, Integer\u003e\u003e summingSalariesByDept\\n *         = Collectors.groupingBy(Employee::getDepartment, summingSalaries);\\n * }\u003c/pre\u003e\\n *\\n * @see Stream#collect(Collector)\\n * @see Collectors\\n *\\n * @param \u003cT\u003e the type of input elements to the reduction operation\\n * @param \u003cA\u003e the mutable accumulation type of the reduction operation (often\\n *            hidden as an implementation detail)\\n * @param \u003cR\u003e the result type of the reduction operation\\n * @since 1.8\\n \u0027}"}, {"color": "#97c2fc", "id": " Supplier\u003cA\u003e supplier()", "label": " Supplier\u003cA\u003e supplier()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * A function that creates and returns a new mutable result container.\\n     *\\n     * @return a function which returns a new, mutable result container\\n     \u0027}"}, {"color": "#97c2fc", "id": " BiConsumer\u003cA, T\u003e accumulator()", "label": " BiConsumer\u003cA, T\u003e accumulator()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * A function that folds a value into a mutable result container.\\n     *\\n     * @return a function which folds a value into a mutable result container\\n     \u0027}"}, {"color": "#97c2fc", "id": " BinaryOperator\u003cA\u003e combiner()", "label": " BinaryOperator\u003cA\u003e combiner()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * A function that accepts two partial results and merges them.  The\\n     * combiner function may fold state from one argument into the other and\\n     * return that, or may return a new result container.\\n     *\\n     * @return a function which combines two partial results into a combined\\n     * result\\n     \u0027}"}, {"color": "#97c2fc", "id": " Function\u003cA, R\u003e finisher()", "label": " Function\u003cA, R\u003e finisher()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Perform the final transformation from the intermediate accumulation type\\n     * {@code A} to the final result type {@code R}.\\n     *\\n     * \u003cp\u003eIf the characteristic {@code IDENTITY_FINISH} is\\n     * set, this function may be presumed to be an identity transform with an\\n     * unchecked cast from {@code A} to {@code R}.\\n     *\\n     * @return a function which transforms the intermediate result to the final\\n     * result\\n     \u0027}"}, {"color": "#97c2fc", "id": " Set\u003cCharacteristics\u003e characteristics()", "label": " Set\u003cCharacteristics\u003e characteristics()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Set} of {@code Collector.Characteristics} indicating\\n     * the characteristics of this Collector.  This set should be immutable.\\n     *\\n     * @return an immutable set of collector characteristics\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, R, R\u003e of(Supplier\u003cR\u003e supplier, BiConsumer\u003cR, T\u003e accumulator, BinaryOperator\u003cR\u003e combiner, Characteristics... characteristics)", "label": "public static Collector\u003cT, R, R\u003e of(Supplier\u003cR\u003e supplier, BiConsumer\u003cR, T\u003e accumulator, BinaryOperator\u003cR\u003e combiner, Characteristics... characteristics)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a new {@code Collector} described by the given {@code supplier},\\n     * {@code accumulator}, and {@code combiner} functions.  The resulting\\n     * {@code Collector} has the {@code Collector.Characteristics.IDENTITY_FINISH}\\n     * characteristic.\\n     *\\n     * @param supplier The supplier function for the new collector\\n     * @param accumulator The accumulator function for the new collector\\n     * @param combiner The combiner function for the new collector\\n     * @param characteristics The collector characteristics for the new\\n     *                        collector\\n     * @param \u003cT\u003e The type of input elements for the new collector\\n     * @param \u003cR\u003e The type of intermediate accumulation result, and final result,\\n     *           for the new collector\\n     * @throws NullPointerException if any argument is null\\n     * @return the new {@code Collector}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, A, R\u003e of(Supplier\u003cA\u003e supplier, BiConsumer\u003cA, T\u003e accumulator, BinaryOperator\u003cA\u003e combiner, Function\u003cA, R\u003e finisher, Characteristics... characteristics)", "label": "public static Collector\u003cT, A, R\u003e of(Supplier\u003cA\u003e supplier, BiConsumer\u003cA, T\u003e accumulator, BinaryOperator\u003cA\u003e combiner, Function\u003cA, R\u003e finisher, Characteristics... characteristics)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a new {@code Collector} described by the given {@code supplier},\\n     * {@code accumulator}, {@code combiner}, and {@code finisher} functions.\\n     *\\n     * @param supplier The supplier function for the new collector\\n     * @param accumulator The accumulator function for the new collector\\n     * @param combiner The combiner function for the new collector\\n     * @param finisher The finisher function for the new collector\\n     * @param characteristics The collector characteristics for the new\\n     *                        collector\\n     * @param \u003cT\u003e The type of input elements for the new collector\\n     * @param \u003cA\u003e The intermediate accumulation type of the new collector\\n     * @param \u003cR\u003e The final result type of the new collector\\n     * @throws NullPointerException if any argument is null\\n     * @return the new {@code Collector}\\n     \u0027}"}, {"color": "#97c2fc", "id": "collect(Supplier", "label": "collect(Supplier", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " List\u003cT\u003e toList()", "label": " List\u003cT\u003e toList()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Accumulates the elements of this stream into a {@code List}. The elements in\\n     * the list will be in this stream\\\u0027s encounter order, if one exists. The returned List\\n     * is unmodifiable; calls to any mutator method will always cause\\n     * {@code UnsupportedOperationException} to be thrown. There are no\\n     * guarantees on the implementation type or serializability of the returned List.\\n     *\\n     * \u003cp\u003eThe returned instance may be \u003ca href=\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e.\\n     * Callers should make no assumptions about the identity of the returned instances.\\n     * Identity-sensitive operations on these instances (reference equality ({@code ==}),\\n     * identity hash code, and synchronization) are unreliable and should be avoided.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal operation\u003c/a\u003e.\\n     *\\n     * @apiNote If more control over the returned object is required, use\\n     * {@link Collectors#toCollection(Supplier)}.\\n     *\\n     * @implSpec The implementation in this interface returns a List produced as if by the following:\\n     * \u003cpre\u003e{@code\\n     * Collections.unmodifiableList(new ArrayList\u003c\u003e(Arrays.asList(this.toArray())))\\n     * }\u003c/pre\u003e\\n     *\\n     * @implNote Most instances of Stream will override this method and provide an implementation\\n     * that is highly optimized compared to the implementation in this interface.\\n     *\\n     * @return a List containing the stream elements\\n     *\\n     * @since 16\\n     \u0027}"}, {"color": "#97c2fc", "id": "toCollection(Supplier)", "label": "toCollection(Supplier)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.util.stream.Collectors", "label": "java.util.stream.Collectors", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Implementations of {@link Collector} that implement various useful reduction\\n * operations, such as accumulating elements into collections, summarizing\\n * elements according to various criteria, etc.\\n *\\n * \u003cp\u003eThe following are examples of using the predefined collectors to perform\\n * common mutable reduction tasks:\\n *\\n * \u003cpre\u003e{@code\\n * // Accumulate names into a List\\n * List\u003cString\u003e list = people.stream()\\n *   .map(Person::getName)\\n *   .collect(Collectors.toList());\\n *\\n * // Accumulate names into a TreeSet\\n * Set\u003cString\u003e set = people.stream()\\n *   .map(Person::getName)\\n *   .collect(Collectors.toCollection(TreeSet::new));\\n *\\n * // Convert elements to strings and concatenate them, separated by commas\\n * String joined = things.stream()\\n *   .map(Object::toString)\\n *   .collect(Collectors.joining(\", \"));\\n *\\n * // Compute sum of salaries of employee\\n * int total = employees.stream()\\n *   .collect(Collectors.summingInt(Employee::getSalary));\\n *\\n * // Group employees by department\\n * Map\u003cDepartment, List\u003cEmployee\u003e\u003e byDept = employees.stream()\\n *   .collect(Collectors.groupingBy(Employee::getDepartment));\\n *\\n * // Compute sum of salaries by department\\n * Map\u003cDepartment, Integer\u003e totalByDept = employees.stream()\\n *   .collect(Collectors.groupingBy(Employee::getDepartment,\\n *                                  Collectors.summingInt(Employee::getSalary)));\\n *\\n * // Partition students into passing and failing\\n * Map\u003cBoolean, List\u003cStudent\u003e\u003e passingFailing = students.stream()\\n *   .collect(Collectors.partitioningBy(s -\u003e s.getGrade() \u003e= PASS_THRESHOLD));\\n *\\n * }\u003c/pre\u003e\\n *\\n * @since 1.8\\n \u0027}"}, {"color": "#97c2fc", "id": "private static IllegalStateException duplicateKeyException(Object k, Object u, Object v)", "label": "private static IllegalStateException duplicateKeyException(Object k, Object u, Object v)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Construct an {@code IllegalStateException} with appropriate message.\\n     *\\n     * @param k the duplicate key\\n     * @param u 1st value to be accumulated/merged\\n     * @param v 2nd value to be accumulated/merged\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static BinaryOperator\u003cM\u003e uniqKeysMapMerger()", "label": "private static BinaryOperator\u003cM\u003e uniqKeysMapMerger()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * {@code BinaryOperator\u003cMap\u003e} that merges the contents of its right\\n     * argument into its left argument, throwing {@code IllegalStateException}\\n     * if duplicate keys are encountered.\\n     *\\n     * @param \u003cK\u003e type of the map keys\\n     * @param \u003cV\u003e type of the map values\\n     * @param \u003cM\u003e type of the map\\n     * @return a merge function for two maps\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static BiConsumer\u003cMap\u003cK, V\u003e, T\u003e uniqKeysMapAccumulator(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends V\u003e valueMapper)", "label": "private static BiConsumer\u003cMap\u003cK, V\u003e, T\u003e uniqKeysMapAccumulator(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends V\u003e valueMapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * {@code BiConsumer\u003cMap, T\u003e} that accumulates (key, value) pairs\\n     * extracted from elements into the map, throwing {@code IllegalStateException}\\n     * if duplicate keys are encountered.\\n     *\\n     * @param keyMapper a function that maps an element into a key\\n     * @param valueMapper a function that maps an element into a value\\n     * @param \u003cT\u003e type of elements\\n     * @param \u003cK\u003e type of map keys\\n     * @param \u003cV\u003e type of map values\\n     * @return an accumulating consumer\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, C\u003e toCollection(Supplier\u003cC\u003e collectionFactory)", "label": "public static Collector\u003cT, ?, C\u003e toCollection(Supplier\u003cC\u003e collectionFactory)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} that accumulates the input elements into a\\n     * new {@code Collection}, in encounter order.  The {@code Collection} is\\n     * created by the provided factory.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param \u003cC\u003e the type of the resulting {@code Collection}\\n     * @param collectionFactory a supplier providing a new empty {@code Collection}\\n     *                          into which the results will be inserted\\n     * @return a {@code Collector} which collects all the input elements into a\\n     * {@code Collection}, in encounter order\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, List\u003cT\u003e\u003e toList()", "label": "public static Collector\u003cT, ?, List\u003cT\u003e\u003e toList()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} that accumulates the input elements into a\\n     * new {@code List}. There are no guarantees on the type, mutability,\\n     * serializability, or thread-safety of the {@code List} returned; if more\\n     * control over the returned {@code List} is required, use {@link #toCollection(Supplier)}.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @return a {@code Collector} which collects all the input elements into a\\n     * {@code List}, in encounter order\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, List\u003cT\u003e\u003e toUnmodifiableList()", "label": "public static Collector\u003cT, ?, List\u003cT\u003e\u003e toUnmodifiableList()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} that accumulates the input elements into an\\n     * \u003ca href=\"../List.html#unmodifiable\"\u003eunmodifiable List\u003c/a\u003e in encounter\\n     * order. The returned Collector disallows null values and will throw\\n     * {@code NullPointerException} if it is presented with a null value.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @return a {@code Collector} that accumulates the input elements into an\\n     * \u003ca href=\"../List.html#unmodifiable\"\u003eunmodifiable List\u003c/a\u003e in encounter order\\n     * @since 10\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, Set\u003cT\u003e\u003e toSet()", "label": "public static Collector\u003cT, ?, Set\u003cT\u003e\u003e toSet()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} that accumulates the input elements into a\\n     * new {@code Set}. There are no guarantees on the type, mutability,\\n     * serializability, or thread-safety of the {@code Set} returned; if more\\n     * control over the returned {@code Set} is required, use\\n     * {@link #toCollection(Supplier)}.\\n     *\\n     * \u003cp\u003eThis is an {@link Collector.Characteristics#UNORDERED unordered}\\n     * Collector.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @return a {@code Collector} which collects all the input elements into a\\n     * {@code Set}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, Set\u003cT\u003e\u003e toUnmodifiableSet()", "label": "public static Collector\u003cT, ?, Set\u003cT\u003e\u003e toUnmodifiableSet()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} that accumulates the input elements into an\\n     * \u003ca href=\"../Set.html#unmodifiable\"\u003eunmodifiable Set\u003c/a\u003e. The returned\\n     * Collector disallows null values and will throw {@code NullPointerException}\\n     * if it is presented with a null value. If the input contains duplicate elements,\\n     * an arbitrary element of the duplicates is preserved.\\n     *\\n     * \u003cp\u003eThis is an {@link Collector.Characteristics#UNORDERED unordered}\\n     * Collector.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @return a {@code Collector} that accumulates the input elements into an\\n     * \u003ca href=\"../Set.html#unmodifiable\"\u003eunmodifiable Set\u003c/a\u003e\\n     * @since 10\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cCharSequence, ?, String\u003e joining()", "label": "public static Collector\u003cCharSequence, ?, String\u003e joining()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} that concatenates the input elements into a\\n     * {@code String}, in encounter order.\\n     *\\n     * @return a {@code Collector} that concatenates the input elements into a\\n     * {@code String}, in encounter order\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cCharSequence, ?, String\u003e joining(CharSequence delimiter)", "label": "public static Collector\u003cCharSequence, ?, String\u003e joining(CharSequence delimiter)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} that concatenates the input elements,\\n     * separated by the specified delimiter, in encounter order.\\n     *\\n     * @param delimiter the delimiter to be used between each element\\n     * @return A {@code Collector} which concatenates CharSequence elements,\\n     * separated by the specified delimiter, in encounter order\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cCharSequence, ?, String\u003e joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)", "label": "public static Collector\u003cCharSequence, ?, String\u003e joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} that concatenates the input elements,\\n     * separated by the specified delimiter, with the specified prefix and\\n     * suffix, in encounter order.\\n     *\\n     * @param delimiter the delimiter to be used between each element\\n     * @param  prefix the sequence of characters to be used at the beginning\\n     *                of the joined result\\n     * @param  suffix the sequence of characters to be used at the end\\n     *                of the joined result\\n     * @return A {@code Collector} which concatenates CharSequence elements,\\n     * separated by the specified delimiter, in encounter order\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static BinaryOperator\u003cM\u003e mapMerger(BinaryOperator\u003cV\u003e mergeFunction)", "label": "private static BinaryOperator\u003cM\u003e mapMerger(BinaryOperator\u003cV\u003e mergeFunction)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * {@code BinaryOperator\u003cMap\u003e} that merges the contents of its right\\n     * argument into its left argument, using the provided merge function to\\n     * handle duplicate keys.\\n     *\\n     * @param \u003cK\u003e type of the map keys\\n     * @param \u003cV\u003e type of the map values\\n     * @param \u003cM\u003e type of the map\\n     * @param mergeFunction A merge function suitable for\\n     * {@link Map#merge(Object, Object, BiFunction) Map.merge()}\\n     * @return a merge function for two maps\\n     \u0027}"}, {"color": "#97c2fc", "id": "merge(Object", "label": "merge(Object", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, R\u003e mapping(Function\u003c? super T, ? extends U\u003e mapper, Collector\u003c? super U, A, R\u003e downstream)", "label": "public static Collector\u003cT, ?, R\u003e mapping(Function\u003c? super T, ? extends U\u003e mapper, Collector\u003c? super U, A, R\u003e downstream)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Adapts a {@code Collector} accepting elements of type {@code U} to one\\n     * accepting elements of type {@code T} by applying a mapping function to\\n     * each input element before accumulation.\\n     *\\n     * @apiNote\\n     * The {@code mapping()} collectors are most useful when used in a\\n     * multi-level reduction, such as downstream of a {@code groupingBy} or\\n     * {@code partitioningBy}.  For example, given a stream of\\n     * {@code Person}, to accumulate the set of last names in each city:\\n     * \u003cpre\u003e{@code\\n     * Map\u003cCity, Set\u003cString\u003e\u003e lastNamesByCity\\n     *   = people.stream().collect(\\n     *     groupingBy(Person::getCity,\\n     *                mapping(Person::getLastName,\\n     *                        toSet())));\\n     * }\u003c/pre\u003e\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param \u003cU\u003e type of elements accepted by downstream collector\\n     * @param \u003cA\u003e intermediate accumulation type of the downstream collector\\n     * @param \u003cR\u003e result type of collector\\n     * @param mapper a function to be applied to the input elements\\n     * @param downstream a collector which will accept mapped values\\n     * @return a collector which applies the mapping function to the input\\n     * elements and provides the mapped results to the downstream collector\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, R\u003e flatMapping(Function\u003c? super T, ? extends Stream\u003c? extends U\u003e\u003e mapper, Collector\u003c? super U, A, R\u003e downstream)", "label": "public static Collector\u003cT, ?, R\u003e flatMapping(Function\u003c? super T, ? extends Stream\u003c? extends U\u003e\u003e mapper, Collector\u003c? super U, A, R\u003e downstream)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Adapts a {@code Collector} accepting elements of type {@code U} to one\\n     * accepting elements of type {@code T} by applying a flat mapping function\\n     * to each input element before accumulation.  The flat mapping function\\n     * maps an input element to a {@link Stream stream} covering zero or more\\n     * output elements that are then accumulated downstream.  Each mapped stream\\n     * is {@link java.util.stream.BaseStream#close() closed} after its contents\\n     * have been placed downstream.  (If a mapped stream is {@code null}\\n     * an empty stream is used, instead.)\\n     *\\n     * @apiNote\\n     * The {@code flatMapping()} collectors are most useful when used in a\\n     * multi-level reduction, such as downstream of a {@code groupingBy} or\\n     * {@code partitioningBy}.  For example, given a stream of\\n     * {@code Order}, to accumulate the set of line items for each customer:\\n     * \u003cpre\u003e{@code\\n     * Map\u003cString, Set\u003cLineItem\u003e\u003e itemsByCustomerName\\n     *   = orders.stream().collect(\\n     *     groupingBy(Order::getCustomerName,\\n     *                flatMapping(order -\u003e order.getLineItems().stream(),\\n     *                            toSet())));\\n     * }\u003c/pre\u003e\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param \u003cU\u003e type of elements accepted by downstream collector\\n     * @param \u003cA\u003e intermediate accumulation type of the downstream collector\\n     * @param \u003cR\u003e result type of collector\\n     * @param mapper a function to be applied to the input elements, which\\n     * returns a stream of results\\n     * @param downstream a collector which will receive the elements of the\\n     * stream returned by mapper\\n     * @return a collector which applies the mapping function to the input\\n     * elements and provides the flat mapped results to the downstream collector\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, R\u003e filtering(Predicate\u003c? super T\u003e predicate, Collector\u003c? super T, A, R\u003e downstream)", "label": "public static Collector\u003cT, ?, R\u003e filtering(Predicate\u003c? super T\u003e predicate, Collector\u003c? super T, A, R\u003e downstream)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Adapts a {@code Collector} to one accepting elements of the same type\\n     * {@code T} by applying the predicate to each input element and only\\n     * accumulating if the predicate returns {@code true}.\\n     *\\n     * @apiNote\\n     * The {@code filtering()} collectors are most useful when used in a\\n     * multi-level reduction, such as downstream of a {@code groupingBy} or\\n     * {@code partitioningBy}.  For example, given a stream of\\n     * {@code Employee}, to accumulate the employees in each department that have a\\n     * salary above a certain threshold:\\n     * \u003cpre\u003e{@code\\n     * Map\u003cDepartment, Set\u003cEmployee\u003e\u003e wellPaidEmployeesByDepartment\\n     *   = employees.stream().collect(\\n     *     groupingBy(Employee::getDepartment,\\n     *                filtering(e -\u003e e.getSalary() \u003e 2000,\\n     *                          toSet())));\\n     * }\u003c/pre\u003e\\n     * A filtering collector differs from a stream\u0027s {@code filter()} operation.\\n     * In this example, suppose there are no employees whose salary is above the\\n     * threshold in some department.  Using a filtering collector as shown above\\n     * would result in a mapping from that department to an empty {@code Set}.\\n     * If a stream {@code filter()} operation were done instead, there would be\\n     * no mapping for that department at all.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param \u003cA\u003e intermediate accumulation type of the downstream collector\\n     * @param \u003cR\u003e result type of collector\\n     * @param predicate a predicate to be applied to the input elements\\n     * @param downstream a collector which will accept values that match the\\n     * predicate\\n     * @return a collector which applies the predicate to the input elements\\n     * and provides matching elements to the downstream collector\\n     * @since 9\\n     \"}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, A, RR\u003e collectingAndThen(Collector\u003cT, A, R\u003e downstream, Function\u003cR, RR\u003e finisher)", "label": "public static Collector\u003cT, A, RR\u003e collectingAndThen(Collector\u003cT, A, R\u003e downstream, Function\u003cR, RR\u003e finisher)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Adapts a {@code Collector} to perform an additional finishing\\n     * transformation.  For example, one could adapt the {@link #toList()}\\n     * collector to always produce an immutable list with:\\n     * \u003cpre\u003e{@code\\n     * List\u003cString\u003e list = people.stream().collect(\\n     *   collectingAndThen(toList(),\\n     *                     Collections::unmodifiableList));\\n     * }\u003c/pre\u003e\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param \u003cA\u003e intermediate accumulation type of the downstream collector\\n     * @param \u003cR\u003e result type of the downstream collector\\n     * @param \u003cRR\u003e result type of the resulting collector\\n     * @param downstream a collector\\n     * @param finisher a function to be applied to the final result of the downstream collector\\n     * @return a collector which performs the action of the downstream collector,\\n     * followed by an additional finishing step\\n     \u0027}"}, {"color": "#97c2fc", "id": "toList()", "label": "toList()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, Long\u003e counting()", "label": "public static Collector\u003cT, ?, Long\u003e counting()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} accepting elements of type {@code T} that\\n     * counts the number of input elements.  If no elements are present, the\\n     * result is 0.\\n     *\\n     * @implSpec\\n     * This produces a result equivalent to:\\n     * \u003cpre\u003e{@code\\n     *     reducing(0L, e -\u003e 1L, Long::sum)\\n     * }\u003c/pre\u003e\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @return a {@code Collector} that counts the input elements\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, Optional\u003cT\u003e\u003e minBy(Comparator\u003c? super T\u003e comparator)", "label": "public static Collector\u003cT, ?, Optional\u003cT\u003e\u003e minBy(Comparator\u003c? super T\u003e comparator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} that produces the minimal element according\\n     * to a given {@code Comparator}, described as an {@code Optional\u003cT\u003e}.\\n     *\\n     * @implSpec\\n     * This produces a result equivalent to:\\n     * \u003cpre\u003e{@code\\n     *     reducing(BinaryOperator.minBy(comparator))\\n     * }\u003c/pre\u003e\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param comparator a {@code Comparator} for comparing elements\\n     * @return a {@code Collector} that produces the minimal value\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, Optional\u003cT\u003e\u003e maxBy(Comparator\u003c? super T\u003e comparator)", "label": "public static Collector\u003cT, ?, Optional\u003cT\u003e\u003e maxBy(Comparator\u003c? super T\u003e comparator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} that produces the maximal element according\\n     * to a given {@code Comparator}, described as an {@code Optional\u003cT\u003e}.\\n     *\\n     * @implSpec\\n     * This produces a result equivalent to:\\n     * \u003cpre\u003e{@code\\n     *     reducing(BinaryOperator.maxBy(comparator))\\n     * }\u003c/pre\u003e\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param comparator a {@code Comparator} for comparing elements\\n     * @return a {@code Collector} that produces the maximal value\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, Integer\u003e summingInt(ToIntFunction\u003c? super T\u003e mapper)", "label": "public static Collector\u003cT, ?, Integer\u003e summingInt(ToIntFunction\u003c? super T\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} that produces the sum of a integer-valued\\n     * function applied to the input elements.  If no elements are present,\\n     * the result is 0.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param mapper a function extracting the property to be summed\\n     * @return a {@code Collector} that produces the sum of a derived property\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, Long\u003e summingLong(ToLongFunction\u003c? super T\u003e mapper)", "label": "public static Collector\u003cT, ?, Long\u003e summingLong(ToLongFunction\u003c? super T\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} that produces the sum of a long-valued\\n     * function applied to the input elements.  If no elements are present,\\n     * the result is 0.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param mapper a function extracting the property to be summed\\n     * @return a {@code Collector} that produces the sum of a derived property\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, Double\u003e summingDouble(ToDoubleFunction\u003c? super T\u003e mapper)", "label": "public static Collector\u003cT, ?, Double\u003e summingDouble(ToDoubleFunction\u003c? super T\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} that produces the sum of a double-valued\\n     * function applied to the input elements.  If no elements are present,\\n     * the result is 0.\\n     *\\n     * \u003cp\u003eThe sum returned can vary depending upon the order in which\\n     * values are recorded, due to accumulated rounding error in\\n     * addition of values of differing magnitudes. Values sorted by increasing\\n     * absolute magnitude tend to yield more accurate results.  If any recorded\\n     * value is a {@code NaN} or the sum is at any point a {@code NaN} then the\\n     * sum will be {@code NaN}.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param mapper a function extracting the property to be summed\\n     * @return a {@code Collector} that produces the sum of a derived property\\n     \u0027}"}, {"color": "#97c2fc", "id": " static double[] sumWithCompensation(double[] intermediateSum, double value)", "label": " static double[] sumWithCompensation(double[] intermediateSum, double value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Incorporate a new double value using Kahan summation /\\n     * compensation summation.\\n     *\\n     * High-order bits of the sum are in intermediateSum[0], low-order\\n     * bits of the sum are in intermediateSum[1], any additional\\n     * elements are application-specific.\\n     *\\n     * @param intermediateSum the high-order and low-order words of the intermediate sum\\n     * @param value the name value to be included in the running sum\\n     \u0027}"}, {"color": "#97c2fc", "id": " static double computeFinalSum(double[] summands)", "label": " static double computeFinalSum(double[] summands)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * If the compensated sum is spuriously NaN from accumulating one\\n     * or more same-signed infinite values, return the\\n     * correctly-signed infinity stored in the simple sum.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, Double\u003e averagingInt(ToIntFunction\u003c? super T\u003e mapper)", "label": "public static Collector\u003cT, ?, Double\u003e averagingInt(ToIntFunction\u003c? super T\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} that produces the arithmetic mean of an integer-valued\\n     * function applied to the input elements.  If no elements are present,\\n     * the result is 0.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param mapper a function extracting the property to be averaged\\n     * @return a {@code Collector} that produces the arithmetic mean of a\\n     * derived property\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, Double\u003e averagingLong(ToLongFunction\u003c? super T\u003e mapper)", "label": "public static Collector\u003cT, ?, Double\u003e averagingLong(ToLongFunction\u003c? super T\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} that produces the arithmetic mean of a long-valued\\n     * function applied to the input elements.  If no elements are present,\\n     * the result is 0.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param mapper a function extracting the property to be averaged\\n     * @return a {@code Collector} that produces the arithmetic mean of a\\n     * derived property\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, Double\u003e averagingDouble(ToDoubleFunction\u003c? super T\u003e mapper)", "label": "public static Collector\u003cT, ?, Double\u003e averagingDouble(ToDoubleFunction\u003c? super T\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} that produces the arithmetic mean of a double-valued\\n     * function applied to the input elements.  If no elements are present,\\n     * the result is 0.\\n     *\\n     * \u003cp\u003eThe average returned can vary depending upon the order in which\\n     * values are recorded, due to accumulated rounding error in\\n     * addition of values of differing magnitudes. Values sorted by increasing\\n     * absolute magnitude tend to yield more accurate results.  If any recorded\\n     * value is a {@code NaN} or the sum is at any point a {@code NaN} then the\\n     * average will be {@code NaN}.\\n     *\\n     * @implNote The {@code double} format can represent all\\n     * consecutive integers in the range -2\u003csup\u003e53\u003c/sup\u003e to\\n     * 2\u003csup\u003e53\u003c/sup\u003e. If the pipeline has more than 2\u003csup\u003e53\u003c/sup\u003e\\n     * values, the divisor in the average computation will saturate at\\n     * 2\u003csup\u003e53\u003c/sup\u003e, leading to additional numerical errors.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param mapper a function extracting the property to be averaged\\n     * @return a {@code Collector} that produces the arithmetic mean of a\\n     * derived property\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, T\u003e reducing(T identity, BinaryOperator\u003cT\u003e op)", "label": "public static Collector\u003cT, ?, T\u003e reducing(T identity, BinaryOperator\u003cT\u003e op)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} which performs a reduction of its\\n     * input elements under a specified {@code BinaryOperator} using the\\n     * provided identity.\\n     *\\n     * @apiNote\\n     * The {@code reducing()} collectors are most useful when used in a\\n     * multi-level reduction, downstream of {@code groupingBy} or\\n     * {@code partitioningBy}.  To perform a simple reduction on a stream,\\n     * use {@link Stream#reduce(Object, BinaryOperator)}} instead.\\n     *\\n     * @param \u003cT\u003e element type for the input and output of the reduction\\n     * @param identity the identity value for the reduction (also, the value\\n     *                 that is returned when there are no input elements)\\n     * @param op a {@code BinaryOperator\u003cT\u003e} used to reduce the input elements\\n     * @return a {@code Collector} which implements the reduction operation\\n     *\\n     * @see #reducing(BinaryOperator)\\n     * @see #reducing(Object, Function, BinaryOperator)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, Optional\u003cT\u003e\u003e reducing(BinaryOperator\u003cT\u003e op)", "label": "public static Collector\u003cT, ?, Optional\u003cT\u003e\u003e reducing(BinaryOperator\u003cT\u003e op)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} which performs a reduction of its\\n     * input elements under a specified {@code BinaryOperator}.  The result\\n     * is described as an {@code Optional\u003cT\u003e}.\\n     *\\n     * @apiNote\\n     * The {@code reducing()} collectors are most useful when used in a\\n     * multi-level reduction, downstream of {@code groupingBy} or\\n     * {@code partitioningBy}.  To perform a simple reduction on a stream,\\n     * use {@link Stream#reduce(BinaryOperator)} instead.\\n     *\\n     * \u003cp\u003eFor example, given a stream of {@code Person}, to calculate tallest\\n     * person in each city:\\n     * \u003cpre\u003e{@code\\n     * Comparator\u003cPerson\u003e byHeight = Comparator.comparing(Person::getHeight);\\n     * Map\u003cCity, Optional\u003cPerson\u003e\u003e tallestByCity\\n     *   = people.stream().collect(\\n     *     groupingBy(Person::getCity,\\n     *                reducing(BinaryOperator.maxBy(byHeight))));\\n     * }\u003c/pre\u003e\\n     *\\n     * @param \u003cT\u003e element type for the input and output of the reduction\\n     * @param op a {@code BinaryOperator\u003cT\u003e} used to reduce the input elements\\n     * @return a {@code Collector} which implements the reduction operation\\n     *\\n     * @see #reducing(Object, BinaryOperator)\\n     * @see #reducing(Object, Function, BinaryOperator)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, U\u003e reducing(U identity, Function\u003c? super T, ? extends U\u003e mapper, BinaryOperator\u003cU\u003e op)", "label": "public static Collector\u003cT, ?, U\u003e reducing(U identity, Function\u003c? super T, ? extends U\u003e mapper, BinaryOperator\u003cU\u003e op)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} which performs a reduction of its\\n     * input elements under a specified mapping function and\\n     * {@code BinaryOperator}. This is a generalization of\\n     * {@link #reducing(Object, BinaryOperator)} which allows a transformation\\n     * of the elements before reduction.\\n     *\\n     * @apiNote\\n     * The {@code reducing()} collectors are most useful when used in a\\n     * multi-level reduction, downstream of {@code groupingBy} or\\n     * {@code partitioningBy}.  To perform a simple map-reduce on a stream,\\n     * use {@link Stream#map(Function)} and {@link Stream#reduce(Object, BinaryOperator)}\\n     * instead.\\n     *\\n     * \u003cp\u003eFor example, given a stream of {@code Person}, to calculate the longest\\n     * last name of residents in each city:\\n     * \u003cpre\u003e{@code\\n     * Comparator\u003cString\u003e byLength = Comparator.comparing(String::length);\\n     * Map\u003cCity, String\u003e longestLastNameByCity\\n     *   = people.stream().collect(\\n     *     groupingBy(Person::getCity,\\n     *                reducing(\"\",\\n     *                         Person::getLastName,\\n     *                         BinaryOperator.maxBy(byLength))));\\n     * }\u003c/pre\u003e\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param \u003cU\u003e the type of the mapped values\\n     * @param identity the identity value for the reduction (also, the value\\n     *                 that is returned when there are no input elements)\\n     * @param mapper a mapping function to apply to each input value\\n     * @param op a {@code BinaryOperator\u003cU\u003e} used to reduce the mapped values\\n     * @return a {@code Collector} implementing the map-reduce operation\\n     *\\n     * @see #reducing(Object, BinaryOperator)\\n     * @see #reducing(BinaryOperator)\\n     \u0027}"}, {"color": "#97c2fc", "id": "reducing(Object", "label": "reducing(Object", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, Map\u003cK, List\u003cT\u003e\u003e\u003e groupingBy(Function\u003c? super T, ? extends K\u003e classifier)", "label": "public static Collector\u003cT, ?, Map\u003cK, List\u003cT\u003e\u003e\u003e groupingBy(Function\u003c? super T, ? extends K\u003e classifier)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} implementing a \"group by\" operation on\\n     * input elements of type {@code T}, grouping elements according to a\\n     * classification function, and returning the results in a {@code Map}.\\n     *\\n     * \u003cp\u003eThe classification function maps elements to some key type {@code K}.\\n     * The collector produces a {@code Map\u003cK, List\u003cT\u003e\u003e} whose keys are the\\n     * values resulting from applying the classification function to the input\\n     * elements, and whose corresponding values are {@code List}s containing the\\n     * input elements which map to the associated key under the classification\\n     * function.\\n     *\\n     * \u003cp\u003eThere are no guarantees on the type, mutability, serializability, or\\n     * thread-safety of the {@code Map} or {@code List} objects returned.\\n     * @implSpec\\n     * This produces a result similar to:\\n     * \u003cpre\u003e{@code\\n     *     groupingBy(classifier, toList());\\n     * }\u003c/pre\u003e\\n     *\\n     * @implNote\\n     * The returned {@code Collector} is not concurrent.  For parallel stream\\n     * pipelines, the {@code combiner} function operates by merging the keys\\n     * from one map into another, which can be an expensive operation.  If\\n     * preservation of the order in which elements appear in the resulting {@code Map}\\n     * collector is not required, using {@link #groupingByConcurrent(Function)}\\n     * may offer better parallel performance.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param \u003cK\u003e the type of the keys\\n     * @param classifier the classifier function mapping input elements to keys\\n     * @return a {@code Collector} implementing the group-by operation\\n     *\\n     * @see #groupingBy(Function, Collector)\\n     * @see #groupingBy(Function, Supplier, Collector)\\n     * @see #groupingByConcurrent(Function)\\n     \u0027}"}, {"color": "#97c2fc", "id": "groupingByConcurrent(Function)", "label": "groupingByConcurrent(Function)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, Map\u003cK, D\u003e\u003e groupingBy(Function\u003c? super T, ? extends K\u003e classifier, Collector\u003c? super T, A, D\u003e downstream)", "label": "public static Collector\u003cT, ?, Map\u003cK, D\u003e\u003e groupingBy(Function\u003c? super T, ? extends K\u003e classifier, Collector\u003c? super T, A, D\u003e downstream)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} implementing a cascaded \"group by\" operation\\n     * on input elements of type {@code T}, grouping elements according to a\\n     * classification function, and then performing a reduction operation on\\n     * the values associated with a given key using the specified downstream\\n     * {@code Collector}.\\n     *\\n     * \u003cp\u003eThe classification function maps elements to some key type {@code K}.\\n     * The downstream collector operates on elements of type {@code T} and\\n     * produces a result of type {@code D}. The resulting collector produces a\\n     * {@code Map\u003cK, D\u003e}.\\n     *\\n     * \u003cp\u003eThere are no guarantees on the type, mutability,\\n     * serializability, or thread-safety of the {@code Map} returned.\\n     *\\n     * \u003cp\u003eFor example, to compute the set of last names of people in each city:\\n     * \u003cpre\u003e{@code\\n     * Map\u003cCity, Set\u003cString\u003e\u003e namesByCity\\n     *   = people.stream().collect(\\n     *     groupingBy(Person::getCity,\\n     *                mapping(Person::getLastName,\\n     *                        toSet())));\\n     * }\u003c/pre\u003e\\n     *\\n     * @implNote\\n     * The returned {@code Collector} is not concurrent.  For parallel stream\\n     * pipelines, the {@code combiner} function operates by merging the keys\\n     * from one map into another, which can be an expensive operation.  If\\n     * preservation of the order in which elements are presented to the downstream\\n     * collector is not required, using {@link #groupingByConcurrent(Function, Collector)}\\n     * may offer better parallel performance.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param \u003cK\u003e the type of the keys\\n     * @param \u003cA\u003e the intermediate accumulation type of the downstream collector\\n     * @param \u003cD\u003e the result type of the downstream reduction\\n     * @param classifier a classifier function mapping input elements to keys\\n     * @param downstream a {@code Collector} implementing the downstream reduction\\n     * @return a {@code Collector} implementing the cascaded group-by operation\\n     * @see #groupingBy(Function)\\n     *\\n     * @see #groupingBy(Function, Supplier, Collector)\\n     * @see #groupingByConcurrent(Function, Collector)\\n     \u0027}"}, {"color": "#97c2fc", "id": "groupingByConcurrent(Function", "label": "groupingByConcurrent(Function", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, M\u003e groupingBy(Function\u003c? super T, ? extends K\u003e classifier, Supplier\u003cM\u003e mapFactory, Collector\u003c? super T, A, D\u003e downstream)", "label": "public static Collector\u003cT, ?, M\u003e groupingBy(Function\u003c? super T, ? extends K\u003e classifier, Supplier\u003cM\u003e mapFactory, Collector\u003c? super T, A, D\u003e downstream)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} implementing a cascaded \"group by\" operation\\n     * on input elements of type {@code T}, grouping elements according to a\\n     * classification function, and then performing a reduction operation on\\n     * the values associated with a given key using the specified downstream\\n     * {@code Collector}.  The {@code Map} produced by the Collector is created\\n     * with the supplied factory function.\\n     *\\n     * \u003cp\u003eThe classification function maps elements to some key type {@code K}.\\n     * The downstream collector operates on elements of type {@code T} and\\n     * produces a result of type {@code D}. The resulting collector produces a\\n     * {@code Map\u003cK, D\u003e}.\\n     *\\n     * \u003cp\u003eFor example, to compute the set of last names of people in each city,\\n     * where the city names are sorted:\\n     * \u003cpre\u003e{@code\\n     * Map\u003cCity, Set\u003cString\u003e\u003e namesByCity\\n     *   = people.stream().collect(\\n     *     groupingBy(Person::getCity,\\n     *                TreeMap::new,\\n     *                mapping(Person::getLastName,\\n     *                        toSet())));\\n     * }\u003c/pre\u003e\\n     *\\n     * @implNote\\n     * The returned {@code Collector} is not concurrent.  For parallel stream\\n     * pipelines, the {@code combiner} function operates by merging the keys\\n     * from one map into another, which can be an expensive operation.  If\\n     * preservation of the order in which elements are presented to the downstream\\n     * collector is not required, using {@link #groupingByConcurrent(Function, Supplier, Collector)}\\n     * may offer better parallel performance.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param \u003cK\u003e the type of the keys\\n     * @param \u003cA\u003e the intermediate accumulation type of the downstream collector\\n     * @param \u003cD\u003e the result type of the downstream reduction\\n     * @param \u003cM\u003e the type of the resulting {@code Map}\\n     * @param classifier a classifier function mapping input elements to keys\\n     * @param downstream a {@code Collector} implementing the downstream reduction\\n     * @param mapFactory a supplier providing a new empty {@code Map}\\n     *                   into which the results will be inserted\\n     * @return a {@code Collector} implementing the cascaded group-by operation\\n     *\\n     * @see #groupingBy(Function, Collector)\\n     * @see #groupingBy(Function)\\n     * @see #groupingByConcurrent(Function, Supplier, Collector)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, ConcurrentMap\u003cK, List\u003cT\u003e\u003e\u003e groupingByConcurrent(Function\u003c? super T, ? extends K\u003e classifier)", "label": "public static Collector\u003cT, ?, ConcurrentMap\u003cK, List\u003cT\u003e\u003e\u003e groupingByConcurrent(Function\u003c? super T, ? extends K\u003e classifier)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a concurrent {@code Collector} implementing a \"group by\"\\n     * operation on input elements of type {@code T}, grouping elements\\n     * according to a classification function.\\n     *\\n     * \u003cp\u003eThis is a {@link Collector.Characteristics#CONCURRENT concurrent} and\\n     * {@link Collector.Characteristics#UNORDERED unordered} Collector.\\n     *\\n     * \u003cp\u003eThe classification function maps elements to some key type {@code K}.\\n     * The collector produces a {@code ConcurrentMap\u003cK, List\u003cT\u003e\u003e} whose keys are the\\n     * values resulting from applying the classification function to the input\\n     * elements, and whose corresponding values are {@code List}s containing the\\n     * input elements which map to the associated key under the classification\\n     * function.\\n     *\\n     * \u003cp\u003eThere are no guarantees on the type, mutability, or serializability\\n     * of the {@code ConcurrentMap} or {@code List} objects returned, or of the\\n     * thread-safety of the {@code List} objects returned.\\n     * @implSpec\\n     * This produces a result similar to:\\n     * \u003cpre\u003e{@code\\n     *     groupingByConcurrent(classifier, toList());\\n     * }\u003c/pre\u003e\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param \u003cK\u003e the type of the keys\\n     * @param classifier a classifier function mapping input elements to keys\\n     * @return a concurrent, unordered {@code Collector} implementing the group-by operation\\n     *\\n     * @see #groupingBy(Function)\\n     * @see #groupingByConcurrent(Function, Collector)\\n     * @see #groupingByConcurrent(Function, Supplier, Collector)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, ConcurrentMap\u003cK, D\u003e\u003e groupingByConcurrent(Function\u003c? super T, ? extends K\u003e classifier, Collector\u003c? super T, A, D\u003e downstream)", "label": "public static Collector\u003cT, ?, ConcurrentMap\u003cK, D\u003e\u003e groupingByConcurrent(Function\u003c? super T, ? extends K\u003e classifier, Collector\u003c? super T, A, D\u003e downstream)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a concurrent {@code Collector} implementing a cascaded \"group by\"\\n     * operation on input elements of type {@code T}, grouping elements\\n     * according to a classification function, and then performing a reduction\\n     * operation on the values associated with a given key using the specified\\n     * downstream {@code Collector}.\\n     *\\n     * \u003cp\u003eThis is a {@link Collector.Characteristics#CONCURRENT concurrent} and\\n     * {@link Collector.Characteristics#UNORDERED unordered} Collector.\\n     *\\n     * \u003cp\u003eThe classification function maps elements to some key type {@code K}.\\n     * The downstream collector operates on elements of type {@code T} and\\n     * produces a result of type {@code D}. The resulting collector produces a\\n     * {@code ConcurrentMap\u003cK, D\u003e}.\\n     *\\n     * \u003cp\u003eThere are no guarantees on the type, mutability, or serializability\\n     * of the {@code ConcurrentMap} returned.\\n     *\\n     * \u003cp\u003eFor example, to compute the set of last names of people in each city,\\n     * where the city names are sorted:\\n     * \u003cpre\u003e{@code\\n     * ConcurrentMap\u003cCity, Set\u003cString\u003e\u003e namesByCity\\n     *   = people.stream().collect(\\n     *     groupingByConcurrent(Person::getCity,\\n     *                          mapping(Person::getLastName,\\n     *                                  toSet())));\\n     * }\u003c/pre\u003e\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param \u003cK\u003e the type of the keys\\n     * @param \u003cA\u003e the intermediate accumulation type of the downstream collector\\n     * @param \u003cD\u003e the result type of the downstream reduction\\n     * @param classifier a classifier function mapping input elements to keys\\n     * @param downstream a {@code Collector} implementing the downstream reduction\\n     * @return a concurrent, unordered {@code Collector} implementing the cascaded group-by operation\\n     *\\n     * @see #groupingBy(Function, Collector)\\n     * @see #groupingByConcurrent(Function)\\n     * @see #groupingByConcurrent(Function, Supplier, Collector)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, M\u003e groupingByConcurrent(Function\u003c? super T, ? extends K\u003e classifier, Supplier\u003cM\u003e mapFactory, Collector\u003c? super T, A, D\u003e downstream)", "label": "public static Collector\u003cT, ?, M\u003e groupingByConcurrent(Function\u003c? super T, ? extends K\u003e classifier, Supplier\u003cM\u003e mapFactory, Collector\u003c? super T, A, D\u003e downstream)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a concurrent {@code Collector} implementing a cascaded \"group by\"\\n     * operation on input elements of type {@code T}, grouping elements\\n     * according to a classification function, and then performing a reduction\\n     * operation on the values associated with a given key using the specified\\n     * downstream {@code Collector}.  The {@code ConcurrentMap} produced by the\\n     * Collector is created with the supplied factory function.\\n     *\\n     * \u003cp\u003eThis is a {@link Collector.Characteristics#CONCURRENT concurrent} and\\n     * {@link Collector.Characteristics#UNORDERED unordered} Collector.\\n     *\\n     * \u003cp\u003eThe classification function maps elements to some key type {@code K}.\\n     * The downstream collector operates on elements of type {@code T} and\\n     * produces a result of type {@code D}. The resulting collector produces a\\n     * {@code ConcurrentMap\u003cK, D\u003e}.\\n     *\\n     * \u003cp\u003eFor example, to compute the set of last names of people in each city,\\n     * where the city names are sorted:\\n     * \u003cpre\u003e{@code\\n     * ConcurrentMap\u003cCity, Set\u003cString\u003e\u003e namesByCity\\n     *   = people.stream().collect(\\n     *     groupingByConcurrent(Person::getCity,\\n     *                          ConcurrentSkipListMap::new,\\n     *                          mapping(Person::getLastName,\\n     *                                  toSet())));\\n     * }\u003c/pre\u003e\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param \u003cK\u003e the type of the keys\\n     * @param \u003cA\u003e the intermediate accumulation type of the downstream collector\\n     * @param \u003cD\u003e the result type of the downstream reduction\\n     * @param \u003cM\u003e the type of the resulting {@code ConcurrentMap}\\n     * @param classifier a classifier function mapping input elements to keys\\n     * @param downstream a {@code Collector} implementing the downstream reduction\\n     * @param mapFactory a supplier providing a new empty {@code ConcurrentMap}\\n     *                   into which the results will be inserted\\n     * @return a concurrent, unordered {@code Collector} implementing the cascaded group-by operation\\n     *\\n     * @see #groupingByConcurrent(Function)\\n     * @see #groupingByConcurrent(Function, Collector)\\n     * @see #groupingBy(Function, Supplier, Collector)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, Map\u003cBoolean, List\u003cT\u003e\u003e\u003e partitioningBy(Predicate\u003c? super T\u003e predicate)", "label": "public static Collector\u003cT, ?, Map\u003cBoolean, List\u003cT\u003e\u003e\u003e partitioningBy(Predicate\u003c? super T\u003e predicate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} which partitions the input elements according\\n     * to a {@code Predicate}, and organizes them into a\\n     * {@code Map\u003cBoolean, List\u003cT\u003e\u003e}.\\n     *\\n     * The returned {@code Map} always contains mappings for both\\n     * {@code false} and {@code true} keys.\\n     * There are no guarantees on the type, mutability,\\n     * serializability, or thread-safety of the {@code Map} or {@code List}\\n     * returned.\\n     *\\n     * @apiNote\\n     * If a partition has no elements, its value in the result Map will be\\n     * an empty List.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param predicate a predicate used for classifying input elements\\n     * @return a {@code Collector} implementing the partitioning operation\\n     *\\n     * @see #partitioningBy(Predicate, Collector)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, Map\u003cBoolean, D\u003e\u003e partitioningBy(Predicate\u003c? super T\u003e predicate, Collector\u003c? super T, A, D\u003e downstream)", "label": "public static Collector\u003cT, ?, Map\u003cBoolean, D\u003e\u003e partitioningBy(Predicate\u003c? super T\u003e predicate, Collector\u003c? super T, A, D\u003e downstream)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a {@code Collector} which partitions the input elements according\\n     * to a {@code Predicate}, reduces the values in each partition according to\\n     * another {@code Collector}, and organizes them into a\\n     * {@code Map\u003cBoolean, D\u003e} whose values are the result of the downstream\\n     * reduction.\\n     *\\n     * \u003cp\u003e\\n     * The returned {@code Map} always contains mappings for both\\n     * {@code false} and {@code true} keys.\\n     * There are no guarantees on the type, mutability,\\n     * serializability, or thread-safety of the {@code Map} returned.\\n     *\\n     * @apiNote\\n     * If a partition has no elements, its value in the result Map will be\\n     * obtained by calling the downstream collector\u0027s supplier function and then\\n     * applying the finisher function.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param \u003cA\u003e the intermediate accumulation type of the downstream collector\\n     * @param \u003cD\u003e the result type of the downstream reduction\\n     * @param predicate a predicate used for classifying input elements\\n     * @param downstream a {@code Collector} implementing the downstream\\n     *                   reduction\\n     * @return a {@code Collector} implementing the cascaded partitioning\\n     *         operation\\n     *\\n     * @see #partitioningBy(Predicate)\\n     \"}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, Map\u003cK, U\u003e\u003e toMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper)", "label": "public static Collector\u003cT, ?, Map\u003cK, U\u003e\u003e toMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} that accumulates elements into a\\n     * {@code Map} whose keys and values are the result of applying the provided\\n     * mapping functions to the input elements.\\n     *\\n     * \u003cp\u003eIf the mapped keys contain duplicates (according to\\n     * {@link Object#equals(Object)}), an {@code IllegalStateException} is\\n     * thrown when the collection operation is performed.  If the mapped keys\\n     * might have duplicates, use {@link #toMap(Function, Function, BinaryOperator)}\\n     * instead.\\n     *\\n     * \u003cp\u003eThere are no guarantees on the type, mutability, serializability,\\n     * or thread-safety of the {@code Map} returned.\\n     *\\n     * @apiNote\\n     * It is common for either the key or the value to be the input elements.\\n     * In this case, the utility method\\n     * {@link java.util.function.Function#identity()} may be helpful.\\n     * For example, the following produces a {@code Map} mapping\\n     * students to their grade point average:\\n     * \u003cpre\u003e{@code\\n     * Map\u003cStudent, Double\u003e studentToGPA\\n     *   = students.stream().collect(\\n     *     toMap(Function.identity(),\\n     *           student -\u003e computeGPA(student)));\\n     * }\u003c/pre\u003e\\n     * And the following produces a {@code Map} mapping a unique identifier to\\n     * students:\\n     * \u003cpre\u003e{@code\\n     * Map\u003cString, Student\u003e studentIdToStudent\\n     *   = students.stream().collect(\\n     *     toMap(Student::getId,\\n     *           Function.identity()));\\n     * }\u003c/pre\u003e\\n     *\\n     * @implNote\\n     * The returned {@code Collector} is not concurrent.  For parallel stream\\n     * pipelines, the {@code combiner} function operates by merging the keys\\n     * from one map into another, which can be an expensive operation.  If it is\\n     * not required that results are inserted into the {@code Map} in encounter\\n     * order, using {@link #toConcurrentMap(Function, Function)}\\n     * may offer better parallel performance.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param \u003cK\u003e the output type of the key mapping function\\n     * @param \u003cU\u003e the output type of the value mapping function\\n     * @param keyMapper a mapping function to produce keys\\n     * @param valueMapper a mapping function to produce values\\n     * @return a {@code Collector} which collects elements into a {@code Map}\\n     * whose keys and values are the result of applying mapping functions to\\n     * the input elements\\n     *\\n     * @see #toMap(Function, Function, BinaryOperator)\\n     * @see #toMap(Function, Function, BinaryOperator, Supplier)\\n     * @see #toConcurrentMap(Function, Function)\\n     \u0027}"}, {"color": "#97c2fc", "id": "toMap(Function", "label": "toMap(Function", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "identity()", "label": "identity()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.util.function.Function", "label": "java.util.function.Function", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Represents a function that accepts one argument and produces a result.\\n *\\n * \u003cp\u003eThis is a \u003ca href=\"package-summary.html\"\u003efunctional interface\u003c/a\u003e\\n * whose functional method is {@link #apply(Object)}.\\n *\\n * @param \u003cT\u003e the type of the input to the function\\n * @param \u003cR\u003e the type of the result of the function\\n *\\n * @since 1.8\\n \u0027}"}, {"color": "#97c2fc", "id": " R apply(T t)", "label": " R apply(T t)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Applies this function to the given argument.\\n     *\\n     * @param t the function argument\\n     * @return the function result\\n     \u0027}"}, {"color": "#97c2fc", "id": " Function\u003cV, R\u003e compose(Function\u003c? super V, ? extends T\u003e before)", "label": " Function\u003cV, R\u003e compose(Function\u003c? super V, ? extends T\u003e before)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a composed function that first applies the {@code before}\\n     * function to its input, and then applies this function to the result.\\n     * If evaluation of either function throws an exception, it is relayed to\\n     * the caller of the composed function.\\n     *\\n     * @param \u003cV\u003e the type of input to the {@code before} function, and to the\\n     *           composed function\\n     * @param before the function to apply before this function is applied\\n     * @return a composed function that first applies the {@code before}\\n     * function and then applies this function\\n     * @throws NullPointerException if before is null\\n     *\\n     * @see #andThen(Function)\\n     \u0027}"}, {"color": "#97c2fc", "id": " Function\u003cT, V\u003e andThen(Function\u003c? super R, ? extends V\u003e after)", "label": " Function\u003cT, V\u003e andThen(Function\u003c? super R, ? extends V\u003e after)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a composed function that first applies this function to\\n     * its input, and then applies the {@code after} function to the result.\\n     * If evaluation of either function throws an exception, it is relayed to\\n     * the caller of the composed function.\\n     *\\n     * @param \u003cV\u003e the type of output of the {@code after} function, and of the\\n     *           composed function\\n     * @param after the function to apply after this function is applied\\n     * @return a composed function that first applies this function and then\\n     * applies the {@code after} function\\n     * @throws NullPointerException if after is null\\n     *\\n     * @see #compose(Function)\\n     \u0027}"}, {"color": "#97c2fc", "id": " static Function\u003cT, T\u003e identity()", "label": " static Function\u003cT, T\u003e identity()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a function that always returns its input argument.\\n     *\\n     * @param \u003cT\u003e the type of the input and output objects to the function\\n     * @return a function that always returns its input argument\\n     \u0027}"}, {"color": "#97c2fc", "id": "toConcurrentMap(Function", "label": "toConcurrentMap(Function", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, Map\u003cK, U\u003e\u003e toUnmodifiableMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper)", "label": "public static Collector\u003cT, ?, Map\u003cK, U\u003e\u003e toUnmodifiableMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} that accumulates the input elements into an\\n     * \u003ca href=\"../Map.html#unmodifiable\"\u003eunmodifiable Map\u003c/a\u003e,\\n     * whose keys and values are the result of applying the provided\\n     * mapping functions to the input elements.\\n     *\\n     * \u003cp\u003eIf the mapped keys contain duplicates (according to\\n     * {@link Object#equals(Object)}), an {@code IllegalStateException} is\\n     * thrown when the collection operation is performed.  If the mapped keys\\n     * might have duplicates, use {@link #toUnmodifiableMap(Function, Function, BinaryOperator)}\\n     * to handle merging of the values.\\n     *\\n     * \u003cp\u003eThe returned Collector disallows null keys and values. If either mapping function\\n     * returns null, {@code NullPointerException} will be thrown.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param \u003cK\u003e the output type of the key mapping function\\n     * @param \u003cU\u003e the output type of the value mapping function\\n     * @param keyMapper a mapping function to produce keys, must be non-null\\n     * @param valueMapper a mapping function to produce values, must be non-null\\n     * @return a {@code Collector} that accumulates the input elements into an\\n     * \u003ca href=\"../Map.html#unmodifiable\"\u003eunmodifiable Map\u003c/a\u003e, whose keys and values\\n     * are the result of applying the provided mapping functions to the input elements\\n     * @throws NullPointerException if either keyMapper or valueMapper is null\\n     *\\n     * @see #toUnmodifiableMap(Function, Function, BinaryOperator)\\n     * @since 10\\n     \u0027}"}, {"color": "#97c2fc", "id": "toUnmodifiableMap(Function", "label": "toUnmodifiableMap(Function", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, Map\u003cK, U\u003e\u003e toMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction)", "label": "public static Collector\u003cT, ?, Map\u003cK, U\u003e\u003e toMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} that accumulates elements into a\\n     * {@code Map} whose keys and values are the result of applying the provided\\n     * mapping functions to the input elements.\\n     *\\n     * \u003cp\u003eIf the mapped\\n     * keys contain duplicates (according to {@link Object#equals(Object)}),\\n     * the value mapping function is applied to each equal element, and the\\n     * results are merged using the provided merging function.\\n     *\\n     * \u003cp\u003eThere are no guarantees on the type, mutability, serializability,\\n     * or thread-safety of the {@code Map} returned.\\n     *\\n     * @apiNote\\n     * There are multiple ways to deal with collisions between multiple elements\\n     * mapping to the same key.  The other forms of {@code toMap} simply use\\n     * a merge function that throws unconditionally, but you can easily write\\n     * more flexible merge policies.  For example, if you have a stream\\n     * of {@code Person}, and you want to produce a \"phone book\" mapping name to\\n     * address, but it is possible that two persons have the same name, you can\\n     * do as follows to gracefully deal with these collisions, and produce a\\n     * {@code Map} mapping names to a concatenated list of addresses:\\n     * \u003cpre\u003e{@code\\n     * Map\u003cString, String\u003e phoneBook\\n     *   = people.stream().collect(\\n     *     toMap(Person::getName,\\n     *           Person::getAddress,\\n     *           (s, a) -\u003e s + \", \" + a));\\n     * }\u003c/pre\u003e\\n     *\\n     * @implNote\\n     * The returned {@code Collector} is not concurrent.  For parallel stream\\n     * pipelines, the {@code combiner} function operates by merging the keys\\n     * from one map into another, which can be an expensive operation.  If it is\\n     * not required that results are merged into the {@code Map} in encounter\\n     * order, using {@link #toConcurrentMap(Function, Function, BinaryOperator)}\\n     * may offer better parallel performance.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param \u003cK\u003e the output type of the key mapping function\\n     * @param \u003cU\u003e the output type of the value mapping function\\n     * @param keyMapper a mapping function to produce keys\\n     * @param valueMapper a mapping function to produce values\\n     * @param mergeFunction a merge function, used to resolve collisions between\\n     *                      values associated with the same key, as supplied\\n     *                      to {@link Map#merge(Object, Object, BiFunction)}\\n     * @return a {@code Collector} which collects elements into a {@code Map}\\n     * whose keys are the result of applying a key mapping function to the input\\n     * elements, and whose values are the result of applying a value mapping\\n     * function to all input elements equal to the key and combining them\\n     * using the merge function\\n     *\\n     * @see #toMap(Function, Function)\\n     * @see #toMap(Function, Function, BinaryOperator, Supplier)\\n     * @see #toConcurrentMap(Function, Function, BinaryOperator)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, Map\u003cK, U\u003e\u003e toUnmodifiableMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction)", "label": "public static Collector\u003cT, ?, Map\u003cK, U\u003e\u003e toUnmodifiableMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} that accumulates the input elements into an\\n     * \u003ca href=\"../Map.html#unmodifiable\"\u003eunmodifiable Map\u003c/a\u003e,\\n     * whose keys and values are the result of applying the provided\\n     * mapping functions to the input elements.\\n     *\\n     * \u003cp\u003eIf the mapped\\n     * keys contain duplicates (according to {@link Object#equals(Object)}),\\n     * the value mapping function is applied to each equal element, and the\\n     * results are merged using the provided merging function.\\n     *\\n     * \u003cp\u003eThe returned Collector disallows null keys and values. If either mapping function\\n     * returns null, {@code NullPointerException} will be thrown.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param \u003cK\u003e the output type of the key mapping function\\n     * @param \u003cU\u003e the output type of the value mapping function\\n     * @param keyMapper a mapping function to produce keys, must be non-null\\n     * @param valueMapper a mapping function to produce values, must be non-null\\n     * @param mergeFunction a merge function, used to resolve collisions between\\n     *                      values associated with the same key, as supplied\\n     *                      to {@link Map#merge(Object, Object, BiFunction)},\\n     *                      must be non-null\\n     * @return a {@code Collector} that accumulates the input elements into an\\n     * \u003ca href=\"../Map.html#unmodifiable\"\u003eunmodifiable Map\u003c/a\u003e, whose keys and values\\n     * are the result of applying the provided mapping functions to the input elements\\n     * @throws NullPointerException if the keyMapper, valueMapper, or mergeFunction is null\\n     *\\n     * @see #toUnmodifiableMap(Function, Function)\\n     * @since 10\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, M\u003e toMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction, Supplier\u003cM\u003e mapFactory)", "label": "public static Collector\u003cT, ?, M\u003e toMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction, Supplier\u003cM\u003e mapFactory)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} that accumulates elements into a\\n     * {@code Map} whose keys and values are the result of applying the provided\\n     * mapping functions to the input elements.\\n     *\\n     * \u003cp\u003eIf the mapped\\n     * keys contain duplicates (according to {@link Object#equals(Object)}),\\n     * the value mapping function is applied to each equal element, and the\\n     * results are merged using the provided merging function.  The {@code Map}\\n     * is created by a provided supplier function.\\n     *\\n     * @implNote\\n     * The returned {@code Collector} is not concurrent.  For parallel stream\\n     * pipelines, the {@code combiner} function operates by merging the keys\\n     * from one map into another, which can be an expensive operation.  If it is\\n     * not required that results are merged into the {@code Map} in encounter\\n     * order, using {@link #toConcurrentMap(Function, Function, BinaryOperator, Supplier)}\\n     * may offer better parallel performance.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param \u003cK\u003e the output type of the key mapping function\\n     * @param \u003cU\u003e the output type of the value mapping function\\n     * @param \u003cM\u003e the type of the resulting {@code Map}\\n     * @param keyMapper a mapping function to produce keys\\n     * @param valueMapper a mapping function to produce values\\n     * @param mergeFunction a merge function, used to resolve collisions between\\n     *                      values associated with the same key, as supplied\\n     *                      to {@link Map#merge(Object, Object, BiFunction)}\\n     * @param mapFactory a supplier providing a new empty {@code Map}\\n     *                   into which the results will be inserted\\n     * @return a {@code Collector} which collects elements into a {@code Map}\\n     * whose keys are the result of applying a key mapping function to the input\\n     * elements, and whose values are the result of applying a value mapping\\n     * function to all input elements equal to the key and combining them\\n     * using the merge function\\n     *\\n     * @see #toMap(Function, Function)\\n     * @see #toMap(Function, Function, BinaryOperator)\\n     * @see #toConcurrentMap(Function, Function, BinaryOperator, Supplier)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, ConcurrentMap\u003cK, U\u003e\u003e toConcurrentMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper)", "label": "public static Collector\u003cT, ?, ConcurrentMap\u003cK, U\u003e\u003e toConcurrentMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a concurrent {@code Collector} that accumulates elements into a\\n     * {@code ConcurrentMap} whose keys and values are the result of applying\\n     * the provided mapping functions to the input elements.\\n     *\\n     * \u003cp\u003eIf the mapped keys contain duplicates (according to\\n     * {@link Object#equals(Object)}), an {@code IllegalStateException} is\\n     * thrown when the collection operation is performed.  If the mapped keys\\n     * may have duplicates, use\\n     * {@link #toConcurrentMap(Function, Function, BinaryOperator)} instead.\\n     *\\n     * \u003cp\u003eThere are no guarantees on the type, mutability, or serializability\\n     * of the {@code ConcurrentMap} returned.\\n     *\\n     * @apiNote\\n     * It is common for either the key or the value to be the input elements.\\n     * In this case, the utility method\\n     * {@link java.util.function.Function#identity()} may be helpful.\\n     * For example, the following produces a {@code ConcurrentMap} mapping\\n     * students to their grade point average:\\n     * \u003cpre\u003e{@code\\n     * ConcurrentMap\u003cStudent, Double\u003e studentToGPA\\n     *   = students.stream().collect(\\n     *     toConcurrentMap(Function.identity(),\\n     *                     student -\u003e computeGPA(student)));\\n     * }\u003c/pre\u003e\\n     * And the following produces a {@code ConcurrentMap} mapping a\\n     * unique identifier to students:\\n     * \u003cpre\u003e{@code\\n     * ConcurrentMap\u003cString, Student\u003e studentIdToStudent\\n     *   = students.stream().collect(\\n     *     toConcurrentMap(Student::getId,\\n     *                     Function.identity()));\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eThis is a {@link Collector.Characteristics#CONCURRENT concurrent} and\\n     * {@link Collector.Characteristics#UNORDERED unordered} Collector.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param \u003cK\u003e the output type of the key mapping function\\n     * @param \u003cU\u003e the output type of the value mapping function\\n     * @param keyMapper the mapping function to produce keys\\n     * @param valueMapper the mapping function to produce values\\n     * @return a concurrent, unordered {@code Collector} which collects elements into a\\n     * {@code ConcurrentMap} whose keys are the result of applying a key mapping\\n     * function to the input elements, and whose values are the result of\\n     * applying a value mapping function to the input elements\\n     *\\n     * @see #toMap(Function, Function)\\n     * @see #toConcurrentMap(Function, Function, BinaryOperator)\\n     * @see #toConcurrentMap(Function, Function, BinaryOperator, Supplier)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, ConcurrentMap\u003cK, U\u003e\u003e toConcurrentMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction)", "label": "public static Collector\u003cT, ?, ConcurrentMap\u003cK, U\u003e\u003e toConcurrentMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a concurrent {@code Collector} that accumulates elements into a\\n     * {@code ConcurrentMap} whose keys and values are the result of applying\\n     * the provided mapping functions to the input elements.\\n     *\\n     * \u003cp\u003eIf the mapped keys contain duplicates (according to {@link Object#equals(Object)}),\\n     * the value mapping function is applied to each equal element, and the\\n     * results are merged using the provided merging function.\\n     *\\n     * \u003cp\u003eThere are no guarantees on the type, mutability, or serializability\\n     * of the {@code ConcurrentMap} returned.\\n     *\\n     * @apiNote\\n     * There are multiple ways to deal with collisions between multiple elements\\n     * mapping to the same key.  The other forms of {@code toConcurrentMap} simply use\\n     * a merge function that throws unconditionally, but you can easily write\\n     * more flexible merge policies.  For example, if you have a stream\\n     * of {@code Person}, and you want to produce a \"phone book\" mapping name to\\n     * address, but it is possible that two persons have the same name, you can\\n     * do as follows to gracefully deal with these collisions, and produce a\\n     * {@code ConcurrentMap} mapping names to a concatenated list of addresses:\\n     * \u003cpre\u003e{@code\\n     * ConcurrentMap\u003cString, String\u003e phoneBook\\n     *   = people.stream().collect(\\n     *     toConcurrentMap(Person::getName,\\n     *                     Person::getAddress,\\n     *                     (s, a) -\u003e s + \", \" + a));\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eThis is a {@link Collector.Characteristics#CONCURRENT concurrent} and\\n     * {@link Collector.Characteristics#UNORDERED unordered} Collector.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param \u003cK\u003e the output type of the key mapping function\\n     * @param \u003cU\u003e the output type of the value mapping function\\n     * @param keyMapper a mapping function to produce keys\\n     * @param valueMapper a mapping function to produce values\\n     * @param mergeFunction a merge function, used to resolve collisions between\\n     *                      values associated with the same key, as supplied\\n     *                      to {@link Map#merge(Object, Object, BiFunction)}\\n     * @return a concurrent, unordered {@code Collector} which collects elements into a\\n     * {@code ConcurrentMap} whose keys are the result of applying a key mapping\\n     * function to the input elements, and whose values are the result of\\n     * applying a value mapping function to all input elements equal to the key\\n     * and combining them using the merge function\\n     *\\n     * @see #toConcurrentMap(Function, Function)\\n     * @see #toConcurrentMap(Function, Function, BinaryOperator, Supplier)\\n     * @see #toMap(Function, Function, BinaryOperator)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, M\u003e toConcurrentMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction, Supplier\u003cM\u003e mapFactory)", "label": "public static Collector\u003cT, ?, M\u003e toConcurrentMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction, Supplier\u003cM\u003e mapFactory)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a concurrent {@code Collector} that accumulates elements into a\\n     * {@code ConcurrentMap} whose keys and values are the result of applying\\n     * the provided mapping functions to the input elements.\\n     *\\n     * \u003cp\u003eIf the mapped keys contain duplicates (according to {@link Object#equals(Object)}),\\n     * the value mapping function is applied to each equal element, and the\\n     * results are merged using the provided merging function.  The\\n     * {@code ConcurrentMap} is created by a provided supplier function.\\n     *\\n     * \u003cp\u003eThis is a {@link Collector.Characteristics#CONCURRENT concurrent} and\\n     * {@link Collector.Characteristics#UNORDERED unordered} Collector.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param \u003cK\u003e the output type of the key mapping function\\n     * @param \u003cU\u003e the output type of the value mapping function\\n     * @param \u003cM\u003e the type of the resulting {@code ConcurrentMap}\\n     * @param keyMapper a mapping function to produce keys\\n     * @param valueMapper a mapping function to produce values\\n     * @param mergeFunction a merge function, used to resolve collisions between\\n     *                      values associated with the same key, as supplied\\n     *                      to {@link Map#merge(Object, Object, BiFunction)}\\n     * @param mapFactory a supplier providing a new empty {@code ConcurrentMap}\\n     *                   into which the results will be inserted\\n     * @return a concurrent, unordered {@code Collector} which collects elements into a\\n     * {@code ConcurrentMap} whose keys are the result of applying a key mapping\\n     * function to the input elements, and whose values are the result of\\n     * applying a value mapping function to all input elements equal to the key\\n     * and combining them using the merge function\\n     *\\n     * @see #toConcurrentMap(Function, Function)\\n     * @see #toConcurrentMap(Function, Function, BinaryOperator)\\n     * @see #toMap(Function, Function, BinaryOperator, Supplier)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, IntSummaryStatistics\u003e summarizingInt(ToIntFunction\u003c? super T\u003e mapper)", "label": "public static Collector\u003cT, ?, IntSummaryStatistics\u003e summarizingInt(ToIntFunction\u003c? super T\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} which applies an {@code int}-producing\\n     * mapping function to each input element, and returns summary statistics\\n     * for the resulting values.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param mapper a mapping function to apply to each element\\n     * @return a {@code Collector} implementing the summary-statistics reduction\\n     *\\n     * @see #summarizingDouble(ToDoubleFunction)\\n     * @see #summarizingLong(ToLongFunction)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, LongSummaryStatistics\u003e summarizingLong(ToLongFunction\u003c? super T\u003e mapper)", "label": "public static Collector\u003cT, ?, LongSummaryStatistics\u003e summarizingLong(ToLongFunction\u003c? super T\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} which applies an {@code long}-producing\\n     * mapping function to each input element, and returns summary statistics\\n     * for the resulting values.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param mapper the mapping function to apply to each element\\n     * @return a {@code Collector} implementing the summary-statistics reduction\\n     *\\n     * @see #summarizingDouble(ToDoubleFunction)\\n     * @see #summarizingInt(ToIntFunction)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, DoubleSummaryStatistics\u003e summarizingDouble(ToDoubleFunction\u003c? super T\u003e mapper)", "label": "public static Collector\u003cT, ?, DoubleSummaryStatistics\u003e summarizingDouble(ToDoubleFunction\u003c? super T\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Collector} which applies an {@code double}-producing\\n     * mapping function to each input element, and returns summary statistics\\n     * for the resulting values.\\n     *\\n     * @param \u003cT\u003e the type of the input elements\\n     * @param mapper a mapping function to apply to each element\\n     * @return a {@code Collector} implementing the summary-statistics reduction\\n     *\\n     * @see #summarizingLong(ToLongFunction)\\n     * @see #summarizingInt(ToIntFunction)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Collector\u003cT, ?, R\u003e teeing(Collector\u003c? super T, ?, R1\u003e downstream1, Collector\u003c? super T, ?, R2\u003e downstream2, BiFunction\u003c? super R1, ? super R2, R\u003e merger)", "label": "public static Collector\u003cT, ?, R\u003e teeing(Collector\u003c? super T, ?, R1\u003e downstream1, Collector\u003c? super T, ?, R2\u003e downstream2, BiFunction\u003c? super R1, ? super R2, R\u003e merger)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a {@code Collector} that is a composite of two downstream collectors.\\n     * Every element passed to the resulting collector is processed by both downstream\\n     * collectors, then their results are merged using the specified merge function\\n     * into the final result.\\n     *\\n     * \u003cp\u003eThe resulting collector functions do the following:\\n     *\\n     * \u003cul\u003e\\n     * \u003cli\u003esupplier: creates a result container that contains result containers\\n     * obtained by calling each collector\u0027s supplier\\n     * \u003cli\u003eaccumulator: calls each collector\u0027s accumulator with its result container\\n     * and the input element\\n     * \u003cli\u003ecombiner: calls each collector\u0027s combiner with two result containers\\n     * \u003cli\u003efinisher: calls each collector\u0027s finisher with its result container,\\n     * then calls the supplied merger and returns its result.\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003eThe resulting collector is {@link Collector.Characteristics#UNORDERED} if both downstream\\n     * collectors are unordered and {@link Collector.Characteristics#CONCURRENT} if both downstream\\n     * collectors are concurrent.\\n     *\\n     * @param \u003cT\u003e         the type of the input elements\\n     * @param \u003cR1\u003e        the result type of the first collector\\n     * @param \u003cR2\u003e        the result type of the second collector\\n     * @param \u003cR\u003e         the final result type\\n     * @param downstream1 the first downstream collector\\n     * @param downstream2 the second downstream collector\\n     * @param merger      the function which merges two results into the single one\\n     * @return a {@code Collector} which aggregates the results of two supplied collectors.\\n     * @since 12\\n     \"}"}, {"color": "#97c2fc", "id": " Optional\u003cT\u003e min(Comparator\u003c? super T\u003e comparator)", "label": " Optional\u003cT\u003e min(Comparator\u003c? super T\u003e comparator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the minimum element of this stream according to the provided\\n     * {@code Comparator}.  This is a special case of a\\n     * \u003ca href=\"package-summary.html#Reduction\"\u003ereduction\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal operation\u003c/a\u003e.\\n     *\\n     * @param comparator a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                   \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                   {@code Comparator} to compare elements of this stream\\n     * @return an {@code Optional} describing the minimum element of this stream,\\n     * or an empty {@code Optional} if the stream is empty\\n     * @throws NullPointerException if the minimum element is null\\n     \u0027}"}, {"color": "#97c2fc", "id": " Optional\u003cT\u003e max(Comparator\u003c? super T\u003e comparator)", "label": " Optional\u003cT\u003e max(Comparator\u003c? super T\u003e comparator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the maximum element of this stream according to the provided\\n     * {@code Comparator}.  This is a special case of a\\n     * \u003ca href=\"package-summary.html#Reduction\"\u003ereduction\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param comparator a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                   \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                   {@code Comparator} to compare elements of this stream\\n     * @return an {@code Optional} describing the maximum element of this stream,\\n     * or an empty {@code Optional} if the stream is empty\\n     * @throws NullPointerException if the maximum element is null\\n     \u0027}"}, {"color": "#97c2fc", "id": " long count()", "label": " long count()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the count of elements in this stream.  This is a special case of\\n     * a \u003ca href=\"package-summary.html#Reduction\"\u003ereduction\u003c/a\u003e and is\\n     * equivalent to:\\n     * \u003cpre\u003e{@code\\n     *     return map(e -\u003e 1L).sum();\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal operation\u003c/a\u003e.\\n     *\\n     * @apiNote\\n     * An implementation may choose to not execute the stream pipeline (either\\n     * sequentially or in parallel) if it is capable of computing the count\\n     * directly from the stream source.  In such cases no source elements will\\n     * be traversed and no intermediate operations will be evaluated.\\n     * Behavioral parameters with side-effects, which are strongly discouraged\\n     * except for harmless cases such as debugging, may be affected.  For\\n     * example, consider the following stream:\\n     * \u003cpre\u003e{@code\\n     *     LongStream s = LongStream.of(1, 2, 3, 4);\\n     *     long count = s.peek(System.out::println).count();\\n     * }\u003c/pre\u003e\\n     * The number of elements covered by the stream source is known and the\\n     * intermediate operation, {@code peek}, does not inject into or remove\\n     * elements from the stream (as may be the case for {@code flatMap} or\\n     * {@code filter} operations).  Thus the count is 4 and there is no need to\\n     * execute the pipeline and, as a side-effect, print out the elements.\\n     *\\n     * @return the count of elements in this stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean anyMatch(Predicate\u003c? super T\u003e predicate)", "label": " boolean anyMatch(Predicate\u003c? super T\u003e predicate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns whether any elements of this stream match the provided\\n     * predicate.  May not evaluate the predicate on all elements if not\\n     * necessary for determining the result.  If the stream is empty then\\n     * {@code false} is returned and the predicate is not evaluated.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * terminal operation\u003c/a\u003e.\\n     *\\n     * @apiNote\\n     * This method evaluates the \u003cem\u003eexistential quantification\u003c/em\u003e of the\\n     * predicate over the elements of the stream (for some x P(x)).\\n     *\\n     * @param predicate a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                  \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                  predicate to apply to elements of this stream\\n     * @return {@code true} if any elements of the stream match the provided\\n     * predicate, otherwise {@code false}\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean allMatch(Predicate\u003c? super T\u003e predicate)", "label": " boolean allMatch(Predicate\u003c? super T\u003e predicate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns whether all elements of this stream match the provided predicate.\\n     * May not evaluate the predicate on all elements if not necessary for\\n     * determining the result.  If the stream is empty then {@code true} is\\n     * returned and the predicate is not evaluated.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * terminal operation\u003c/a\u003e.\\n     *\\n     * @apiNote\\n     * This method evaluates the \u003cem\u003euniversal quantification\u003c/em\u003e of the\\n     * predicate over the elements of the stream (for all x P(x)).  If the\\n     * stream is empty, the quantification is said to be \u003cem\u003evacuously\\n     * satisfied\u003c/em\u003e and is always {@code true} (regardless of P(x)).\\n     *\\n     * @param predicate a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                  \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                  predicate to apply to elements of this stream\\n     * @return {@code true} if either all elements of the stream match the\\n     * provided predicate or the stream is empty, otherwise {@code false}\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean noneMatch(Predicate\u003c? super T\u003e predicate)", "label": " boolean noneMatch(Predicate\u003c? super T\u003e predicate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns whether no elements of this stream match the provided predicate.\\n     * May not evaluate the predicate on all elements if not necessary for\\n     * determining the result.  If the stream is empty then {@code true} is\\n     * returned and the predicate is not evaluated.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * terminal operation\u003c/a\u003e.\\n     *\\n     * @apiNote\\n     * This method evaluates the \u003cem\u003euniversal quantification\u003c/em\u003e of the\\n     * negated predicate over the elements of the stream (for all x ~P(x)).  If\\n     * the stream is empty, the quantification is said to be vacuously satisfied\\n     * and is always {@code true}, regardless of P(x).\\n     *\\n     * @param predicate a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                  \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                  predicate to apply to elements of this stream\\n     * @return {@code true} if either no elements of the stream match the\\n     * provided predicate or the stream is empty, otherwise {@code false}\\n     \u0027}"}, {"color": "#97c2fc", "id": " Optional\u003cT\u003e findFirst()", "label": " Optional\u003cT\u003e findFirst()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@link Optional} describing the first element of this stream,\\n     * or an empty {@code Optional} if the stream is empty.  If the stream has\\n     * no encounter order, then any element may be returned.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * terminal operation\u003c/a\u003e.\\n     *\\n     * @return an {@code Optional} describing the first element of this stream,\\n     * or an empty {@code Optional} if the stream is empty\\n     * @throws NullPointerException if the element selected is null\\n     \u0027}"}, {"color": "#97c2fc", "id": " Optional\u003cT\u003e findAny()", "label": " Optional\u003cT\u003e findAny()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@link Optional} describing some element of the stream, or an\\n     * empty {@code Optional} if the stream is empty.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * terminal operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eThe behavior of this operation is explicitly nondeterministic; it is\\n     * free to select any element in the stream.  This is to allow for maximal\\n     * performance in parallel operations; the cost is that multiple invocations\\n     * on the same source may not return the same result.  (If a stable result\\n     * is desired, use {@link #findFirst()} instead.)\\n     *\\n     * @return an {@code Optional} describing some element of this stream, or an\\n     * empty {@code Optional} if the stream is empty\\n     * @throws NullPointerException if the element selected is null\\n     * @see #findFirst()\\n     \u0027}"}, {"color": "#97c2fc", "id": "findFirst()", "label": "findFirst()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static Builder\u003cT\u003e builder()", "label": "public static Builder\u003cT\u003e builder()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a builder for a {@code Stream}.\\n     *\\n     * @param \u003cT\u003e type of elements\\n     * @return a stream builder\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Stream\u003cT\u003e empty()", "label": "public static Stream\u003cT\u003e empty()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an empty sequential {@code Stream}.\\n     *\\n     * @param \u003cT\u003e the type of stream elements\\n     * @return an empty sequential stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Stream\u003cT\u003e of(T t)", "label": "public static Stream\u003cT\u003e of(T t)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a sequential {@code Stream} containing a single element.\\n     *\\n     * @param t the single element\\n     * @param \u003cT\u003e the type of stream elements\\n     * @return a singleton sequential stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Stream\u003cT\u003e ofNullable(T t)", "label": "public static Stream\u003cT\u003e ofNullable(T t)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a sequential {@code Stream} containing a single element, if\\n     * non-null, otherwise returns an empty {@code Stream}.\\n     *\\n     * @param t the single element\\n     * @param \u003cT\u003e the type of stream elements\\n     * @return a stream with a single element if the specified element\\n     *         is non-null, otherwise an empty stream\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Stream\u003cT\u003e of(T... values)", "label": "public static Stream\u003cT\u003e of(T... values)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a sequential ordered stream whose elements are the specified values.\\n     *\\n     * @param \u003cT\u003e the type of stream elements\\n     * @param values the elements of the new stream\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Stream\u003cT\u003e iterate(final T seed, final UnaryOperator\u003cT\u003e f)", "label": "public static Stream\u003cT\u003e iterate(final T seed, final UnaryOperator\u003cT\u003e f)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an infinite sequential ordered {@code Stream} produced by iterative\\n     * application of a function {@code f} to an initial element {@code seed},\\n     * producing a {@code Stream} consisting of {@code seed}, {@code f(seed)},\\n     * {@code f(f(seed))}, etc.\\n     *\\n     * \u003cp\u003eThe first element (position {@code 0}) in the {@code Stream} will be\\n     * the provided {@code seed}.  For {@code n \u003e 0}, the element at position\\n     * {@code n}, will be the result of applying the function {@code f} to the\\n     * element at position {@code n - 1}.\\n     *\\n     * \u003cp\u003eThe action of applying {@code f} for one element\\n     * \u003ca href=\"../concurrent/package-summary.html#MemoryVisibility\"\u003e\u003ci\u003ehappens-before\u003c/i\u003e\u003c/a\u003e\\n     * the action of applying {@code f} for subsequent elements.  For any given\\n     * element the action may be performed in whatever thread the library\\n     * chooses.\\n     *\\n     * @param \u003cT\u003e the type of stream elements\\n     * @param seed the initial element\\n     * @param f a function to be applied to the previous element to produce\\n     *          a new element\\n     * @return a new sequential {@code Stream}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Stream\u003cT\u003e iterate(T seed, Predicate\u003c? super T\u003e hasNext, UnaryOperator\u003cT\u003e next)", "label": "public static Stream\u003cT\u003e iterate(T seed, Predicate\u003c? super T\u003e hasNext, UnaryOperator\u003cT\u003e next)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a sequential ordered {@code Stream} produced by iterative\\n     * application of the given {@code next} function to an initial element,\\n     * conditioned on satisfying the given {@code hasNext} predicate.  The\\n     * stream terminates as soon as the {@code hasNext} predicate returns false.\\n     *\\n     * \u003cp\u003e{@code Stream.iterate} should produce the same sequence of elements as\\n     * produced by the corresponding for-loop:\\n     * \u003cpre\u003e{@code\\n     *     for (T index=seed; hasNext.test(index); index = next.apply(index)) {\\n     *         ...\\n     *     }\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eThe resulting sequence may be empty if the {@code hasNext} predicate\\n     * does not hold on the seed value.  Otherwise the first element will be the\\n     * supplied {@code seed} value, the next element (if present) will be the\\n     * result of applying the {@code next} function to the {@code seed} value,\\n     * and so on iteratively until the {@code hasNext} predicate indicates that\\n     * the stream should terminate.\\n     *\\n     * \u003cp\u003eThe action of applying the {@code hasNext} predicate to an element\\n     * \u003ca href=\"../concurrent/package-summary.html#MemoryVisibility\"\u003e\u003ci\u003ehappens-before\u003c/i\u003e\u003c/a\u003e\\n     * the action of applying the {@code next} function to that element.  The\\n     * action of applying the {@code next} function for one element\\n     * \u003ci\u003ehappens-before\u003c/i\u003e the action of applying the {@code hasNext}\\n     * predicate for subsequent elements.  For any given element an action may\\n     * be performed in whatever thread the library chooses.\\n     *\\n     * @param \u003cT\u003e the type of stream elements\\n     * @param seed the initial element\\n     * @param hasNext a predicate to apply to elements to determine when the\\n     *                stream must terminate.\\n     * @param next a function to be applied to the previous element to produce\\n     *             a new element\\n     * @return a new sequential {@code Stream}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Stream\u003cT\u003e generate(Supplier\u003c? extends T\u003e s)", "label": "public static Stream\u003cT\u003e generate(Supplier\u003c? extends T\u003e s)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an infinite sequential unordered stream where each element is\\n     * generated by the provided {@code Supplier}.  This is suitable for\\n     * generating constant streams, streams of random elements, etc.\\n     *\\n     * @param \u003cT\u003e the type of stream elements\\n     * @param s the {@code Supplier} of generated elements\\n     * @return a new infinite sequential unordered {@code Stream}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Stream\u003cT\u003e concat(Stream\u003c? extends T\u003e a, Stream\u003c? extends T\u003e b)", "label": "public static Stream\u003cT\u003e concat(Stream\u003c? extends T\u003e a, Stream\u003c? extends T\u003e b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a lazily concatenated stream whose elements are all the\\n     * elements of the first stream followed by all the elements of the\\n     * second stream.  The resulting stream is ordered if both\\n     * of the input streams are ordered, and parallel if either of the input\\n     * streams is parallel.  When the resulting stream is closed, the close\\n     * handlers for both input streams are invoked.\\n     *\\n     * \u003cp\u003eThis method operates on the two input streams and binds each stream\\n     * to its source.  As a result subsequent modifications to an input stream\\n     * source may not be reflected in the concatenated stream result.\\n     *\\n     * @implNote\\n     * Use caution when constructing streams from repeated concatenation.\\n     * Accessing an element of a deeply concatenated stream can result in deep\\n     * call chains, or even {@code StackOverflowError}.\\n     *\\n     * \u003cp\u003eSubsequent changes to the sequential/parallel execution mode of the\\n     * returned stream are not guaranteed to be propagated to the input streams.\\n     *\\n     * @apiNote\\n     * To preserve optimization opportunities this method binds each stream to\\n     * its source and accepts only two streams as parameters.  For example, the\\n     * exact size of the concatenated stream source can be computed if the exact\\n     * size of each input stream source is known.\\n     * To concatenate more streams without binding, or without nested calls to\\n     * this method, try creating a stream of streams and flat-mapping with the\\n     * identity function, for example:\\n     * \u003cpre\u003e{@code\\n     *     Stream\u003cT\u003e concat = Stream.of(s1, s2, s3, s4).flatMap(s -\u003e s);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param \u003cT\u003e The type of stream elements\\n     * @param a the first stream\\n     * @param b the second stream\\n     * @return the concatenation of the two input streams\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Stream\u003cString\u003e lines(Path path, Charset cs) throws IOException", "label": "public static Stream\u003cString\u003e lines(Path path, Charset cs) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Read all lines from a file as a {@code Stream}. Unlike {@link\\n     * #readAllLines(Path, Charset) readAllLines}, this method does not read\\n     * all lines into a {@code List}, but instead populates lazily as the stream\\n     * is consumed.\\n     *\\n     * \u003cp\u003e Bytes from the file are decoded into characters using the specified\\n     * charset and the same line terminators as specified by {@code\\n     * readAllLines} are supported.\\n     *\\n     * \u003cp\u003e After this method returns, then any subsequent I/O exception that\\n     * occurs while reading from the file or when a malformed or unmappable byte\\n     * sequence is read, is wrapped in an {@link UncheckedIOException} that will\\n     * be thrown from the\\n     * {@link java.util.stream.Stream} method that caused the read to take\\n     * place. In case an {@code IOException} is thrown when closing the file,\\n     * it is also wrapped as an {@code UncheckedIOException}.\\n     *\\n     * \u003cp\u003e The returned stream encapsulates a {@link Reader}.  If timely\\n     * disposal of file system resources is required, the try-with-resources\\n     * construct should be used to ensure that the stream\u0027s\\n     * {@link Stream#close close} method is invoked after the stream operations\\n     * are completed.\\n     *\\n     *\\n     * @param   path\\n     *          the path to the file\\n     * @param   cs\\n     *          the charset to use for decoding\\n     *\\n     * @return  the lines from the file as a {@code Stream}\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs opening the file\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the file.\\n     *\\n     * @see     #readAllLines(Path, Charset)\\n     * @see     #newBufferedReader(Path, Charset)\\n     * @see     java.io.BufferedReader#lines()\\n     * @since   1.8\\n     \"}"}, {"color": "#97c2fc", "id": "readAllLines(Path", "label": "readAllLines(Path", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.io.BufferedReader", "label": "java.io.BufferedReader", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "private void fill() throws IOException", "label": "private void fill() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Fills the input buffer, taking the mark into account if it is valid.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private int read1(char[] cbuf, int off, int len) throws IOException", "label": "private int read1(char[] cbuf, int off, int len) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads characters into a portion of an array, reading from the underlying\\n     * stream if necessary.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int read(char[] cbuf, int off, int len) throws IOException", "label": "public int read(char[] cbuf, int off, int len) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reads characters into a portion of an array.\\n     *\\n     * \u003cp\u003e This method implements the general contract of the corresponding\\n     * \u003ccode\u003e{@link Reader#read(char[], int, int) read}\u003c/code\u003e method of the\\n     * \u003ccode\u003e{@link Reader}\u003c/code\u003e class.  As an additional convenience, it\\n     * attempts to read as many characters as possible by repeatedly invoking\\n     * the \u003ccode\u003eread\u003c/code\u003e method of the underlying stream.  This iterated\\n     * \u003ccode\u003eread\u003c/code\u003e continues until one of the following conditions becomes\\n     * true: \u003cul\u003e\\n     *\\n     *   \u003cli\u003e The specified number of characters have been read,\\n     *\\n     *   \u003cli\u003e The \u003ccode\u003eread\u003c/code\u003e method of the underlying stream returns\\n     *   \u003ccode\u003e-1\u003c/code\u003e, indicating end-of-file, or\\n     *\\n     *   \u003cli\u003e The \u003ccode\u003eready\u003c/code\u003e method of the underlying stream\\n     *   returns \u003ccode\u003efalse\u003c/code\u003e, indicating that further input requests\\n     *   would block.\\n     *\\n     * \u003c/ul\u003e If the first \u003ccode\u003eread\u003c/code\u003e on the underlying stream returns\\n     * \u003ccode\u003e-1\u003c/code\u003e to indicate end-of-file then this method returns\\n     * \u003ccode\u003e-1\u003c/code\u003e.  Otherwise this method returns the number of characters\\n     * actually read.\\n     *\\n     * \u003cp\u003e Subclasses of this class are encouraged, but not required, to\\n     * attempt to read as many characters as possible in the same fashion.\\n     *\\n     * \u003cp\u003e Ordinarily this method takes characters from this stream\u0027s character\\n     * buffer, filling it from the underlying stream as necessary.  If,\\n     * however, the buffer is empty, the mark is not valid, and the requested\\n     * length is at least as large as the buffer, then this method will read\\n     * characters directly from the underlying stream into the given array.\\n     * Thus redundant \u003ccode\u003eBufferedReader\u003c/code\u003es will not copy data\\n     * unnecessarily.\\n     *\\n     * @param      cbuf  Destination buffer\\n     * @param      off   Offset at which to start storing characters\\n     * @param      len   Maximum number of characters to read\\n     *\\n     * @return     The number of characters read, or -1 if the end of the\\n     *             stream has been reached\\n     *\\n     * @exception  IOException  If an I/O error occurs\\n     * @exception  IndexOutOfBoundsException {@inheritDoc}\\n     \"}"}, {"color": "#97c2fc", "id": " String readLine(boolean ignoreLF) throws IOException", "label": " String readLine(boolean ignoreLF) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reads a line of text.  A line is considered to be terminated by any one\\n     * of a line feed (\u0027\\\\n\u0027), a carriage return (\u0027\\\\r\u0027), a carriage return\\n     * followed immediately by a line feed, or by reaching the end-of-file\\n     * (EOF).\\n     *\\n     * @param      ignoreLF  If true, the next \u0027\\\\n\u0027 will be skipped\\n     *\\n     * @return     A String containing the contents of the line, not including\\n     *             any line-termination characters, or null if the end of the\\n     *             stream has been reached without reading any characters\\n     *\\n     * @see        java.io.LineNumberReader#readLine()\\n     *\\n     * @exception  IOException  If an I/O error occurs\\n     \"}"}, {"color": "#97c2fc", "id": "public String readLine() throws IOException", "label": "public String readLine() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reads a line of text.  A line is considered to be terminated by any one\\n     * of a line feed (\u0027\\\\n\u0027), a carriage return (\u0027\\\\r\u0027), a carriage return\\n     * followed immediately by a line feed, or by reaching the end-of-file\\n     * (EOF).\\n     *\\n     * @return     A String containing the contents of the line, not including\\n     *             any line-termination characters, or null if the end of the\\n     *             stream has been reached without reading any characters\\n     *\\n     * @exception  IOException  If an I/O error occurs\\n     *\\n     * @see java.nio.file.Files#readAllLines\\n     \"}"}, {"color": "#97c2fc", "id": "public static Stream\u003cString\u003e lines(Path path) throws IOException", "label": "public static Stream\u003cString\u003e lines(Path path) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Read all lines from a file as a {@code Stream}. Bytes from the file are\\n     * decoded into characters using the {@link StandardCharsets#UTF_8 UTF-8}\\n     * {@link Charset charset}.\\n     *\\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\\n     * expression:\\n     * \u003cpre\u003e{@code\\n     * Files.lines(path, StandardCharsets.UTF_8)\\n     * }\u003c/pre\u003e\\n     *\\n     * @param   path\\n     *          the path to the file\\n     *\\n     * @return  the lines from the file as a {@code Stream}\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs opening the file\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the file.\\n     *\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "getSeparator", "label": "getSeparator", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "Charactercharacters", "label": "Charactercharacters", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public abstract UserPrincipalLookupService getUserPrincipalLookupService()", "label": "public abstract UserPrincipalLookupService getUserPrincipalLookupService()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the {@code UserPrincipalLookupService} for this file system\\n     * \u003ci\u003e(optional operation)\u003c/i\u003e. The resulting lookup service may be used to\\n     * lookup user or group names.\\n     *\\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\\n     * Suppose we want to make \"joe\" the owner of a file:\\n     * \u003cpre\u003e\\n     *     UserPrincipalLookupService lookupService = FileSystems.getDefault().getUserPrincipalLookupService();\\n     *     Files.setOwner(path, lookupService.lookupPrincipalByName(\"joe\"));\\n     * \u003c/pre\u003e\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          If this {@code FileSystem} does not does have a lookup service\\n     *\\n     * @return  The {@code UserPrincipalLookupService} for this file system\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract WatchService newWatchService() throws IOException", "label": "public abstract WatchService newWatchService() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Constructs a new {@link WatchService} \u003ci\u003e(optional operation)\u003c/i\u003e.\\n     *\\n     * \u003cp\u003e This method constructs a new watch service that may be used to watch\\n     * registered objects for changes and events.\\n     *\\n     * @return  a new watch service\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          If this {@code FileSystem} does not support watching file system\\n     *          objects for changes and events. This exception is not thrown\\n     *          by {@code FileSystems} created by the default provider.\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     \u0027}"}, {"color": "#97c2fc", "id": "FileSystemAlreadyExistsException", "label": "FileSystemAlreadyExistsException", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public abstract FileSystem getFileSystem(URI uri)", "label": "public abstract FileSystem getFileSystem(URI uri)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an existing {@code FileSystem} created by this provider.\\n     *\\n     * \u003cp\u003e This method returns a reference to a {@code FileSystem} that was\\n     * created by invoking the {@link #newFileSystem(URI,Map) newFileSystem(URI,Map)}\\n     * method. File systems created the {@link #newFileSystem(Path,Map)\\n     * newFileSystem(Path,Map)} method are not returned by this method.\\n     * The file system is identified by its {@code URI}. Its exact form\\n     * is highly provider dependent. In the case of the default provider the URI\\\u0027s\\n     * path component is {@code \"/\"} and the authority, query and fragment components\\n     * are undefined (Undefined components are represented by {@code null}).\\n     *\\n     * \u003cp\u003e Once a file system created by this provider is {@link\\n     * java.nio.file.FileSystem#close closed} it is provider-dependent if this\\n     * method returns a reference to the closed file system or throws {@link\\n     * FileSystemNotFoundException}. If the provider allows a new file system to\\n     * be created with the same URI as a file system it previously created then\\n     * this method throws the exception if invoked after the file system is\\n     * closed (and before a new instance is created by the {@link #newFileSystem\\n     * newFileSystem} method).\\n     *\\n     * \u003cp\u003e If a security manager is installed then a provider implementation\\n     * may require to check a permission before returning a reference to an\\n     * existing file system. In the case of the {@link FileSystems#getDefault\\n     * default} file system, no permission check is required.\\n     *\\n     * @param   uri\\n     *          URI reference\\n     *\\n     * @return  The file system\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the pre-conditions for the {@code uri} parameter aren\\\u0027t met\\n     * @throws  FileSystemNotFoundException\\n     *          If the file system does not exist\\n     * @throws  SecurityException\\n     *          If a security manager is installed and it denies an unspecified\\n     *          permission.\\n     \u0027}"}, {"color": "#97c2fc", "id": "newFileSystemnewFileSystem", "label": "newFileSystemnewFileSystem", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "FileSystemNotFoundException", "label": "FileSystemNotFoundException", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "newFileSystem(Path", "label": "newFileSystem(Path", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "getDefaultdefault", "label": "getDefaultdefault", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract Path getPath(URI uri)", "label": "public abstract Path getPath(URI uri)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Return a {@code Path} object by converting the given {@link URI}. The\\n     * resulting {@code Path} is associated with a {@link FileSystem} that\\n     * already exists or is constructed automatically.\\n     *\\n     * \u003cp\u003e The exact form of the URI is file system provider dependent. In the\\n     * case of the default provider, the URI scheme is {@code \"file\"} and the\\n     * given URI has a non-empty path component, and undefined query, and\\n     * fragment components. The resulting {@code Path} is associated with the\\n     * default {@link FileSystems#getDefault default} {@code FileSystem}.\\n     *\\n     * \u003cp\u003e If a security manager is installed then a provider implementation\\n     * may require to check a permission. In the case of the {@link\\n     * FileSystems#getDefault default} file system, no permission check is\\n     * required.\\n     *\\n     * @param   uri\\n     *          The URI to convert\\n     *\\n     * @return  The resulting {@code Path}\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the URI scheme does not identify this provider or other\\n     *          preconditions on the uri parameter do not hold\\n     * @throws  FileSystemNotFoundException\\n     *          The file system, identified by the URI, does not exist and\\n     *          cannot be created automatically\\n     * @throws  SecurityException\\n     *          If a security manager is installed and it denies an unspecified\\n     *          permission.\\n     \u0027}"}, {"color": "#97c2fc", "id": "FileSystem", "label": "FileSystem", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "java.net.URI", "label": "java.net.URI", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public static URI create(String str)", "label": "public static URI create(String str)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a URI by parsing the given string.\\n     *\\n     * \u003cp\u003e This convenience factory method works as if by invoking the {@link\\n     * #URI(String)} constructor; any {@link URISyntaxException} thrown by the\\n     * constructor is caught and wrapped in a new {@link\\n     * IllegalArgumentException} object, which is then thrown.\\n     *\\n     * \u003cp\u003e This method is provided for use in situations where it is known that\\n     * the given string is a legal URI, for example for URI constants declared\\n     * within in a program, and so it would be considered a programming error\\n     * for the string not to parse as such.  The constructors, which throw\\n     * {@link URISyntaxException} directly, should be used situations where a\\n     * URI is being constructed from user input or from some other source that\\n     * may be prone to errors.  \u003c/p\u003e\\n     *\\n     * @param  str   The string to be parsed into a URI\\n     * @return The new URI\\n     *\\n     * @throws  NullPointerException\\n     *          If {@code str} is {@code null}\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the given string violates RFC\u0026nbsp;2396\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.net.URISyntaxException", "label": "java.net.URISyntaxException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "URI(String)", "label": "URI(String)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "IllegalArgumentException", "label": "IllegalArgumentException", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public URI parseServerAuthority() throws URISyntaxException", "label": "public URI parseServerAuthority() throws URISyntaxException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Attempts to parse this URI\\\u0027s authority component, if defined, into\\n     * user-information, host, and port components.\\n     *\\n     * \u003cp\u003e If this URI\\\u0027s authority component has already been recognized as\\n     * being server-based then it will already have been parsed into\\n     * user-information, host, and port components.  In this case, or if this\\n     * URI has no authority component, this method simply returns this URI.\\n     *\\n     * \u003cp\u003e Otherwise this method attempts once more to parse the authority\\n     * component into user-information, host, and port components, and throws\\n     * an exception describing why the authority component could not be parsed\\n     * in that way.\\n     *\\n     * \u003cp\u003e This method is provided because the generic URI syntax specified in\\n     * \u003ca href=\"http://www.ietf.org/rfc/rfc2396.txt\"\u003eRFC\u0026nbsp;2396\u003c/a\u003e\\n     * cannot always distinguish a malformed server-based authority from a\\n     * legitimate registry-based authority.  It must therefore treat some\\n     * instances of the former as instances of the latter.  The authority\\n     * component in the URI string {@code \"//foo:bar\"}, for example, is not a\\n     * legal server-based authority but it is legal as a registry-based\\n     * authority.\\n     *\\n     * \u003cp\u003e In many common situations, for example when working URIs that are\\n     * known to be either URNs or URLs, the hierarchical URIs being used will\\n     * always be server-based.  They therefore must either be parsed as such or\\n     * treated as an error.  In these cases a statement such as\\n     *\\n     * \u003cblockquote\u003e\\n     * {@code URI }\u003ci\u003eu\u003c/i\u003e{@code  = new URI(str).parseServerAuthority();}\\n     * \u003c/blockquote\u003e\\n     *\\n     * \u003cp\u003e can be used to ensure that \u003ci\u003eu\u003c/i\u003e always refers to a URI that, if\\n     * it has an authority component, has a server-based authority with proper\\n     * user-information, host, and port components.  Invoking this method also\\n     * ensures that if the authority could not be parsed in that way then an\\n     * appropriate diagnostic message can be issued based upon the exception\\n     * that is thrown. \u003c/p\u003e\\n     *\\n     * @return  A URI whose authority field has been parsed\\n     *          as a server-based authority\\n     *\\n     * @throws  URISyntaxException\\n     *          If the authority component of this URI is defined\\n     *          but cannot be parsed as a server-based authority\\n     *          according to RFC\u0026nbsp;2396\\n     \u0027}"}, {"color": "#97c2fc", "id": "public URI normalize()", "label": "public URI normalize()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Normalizes this URI\\\u0027s path.\\n     *\\n     * \u003cp\u003e If this URI is opaque, or if its path is already in normal form,\\n     * then this URI is returned.  Otherwise a new URI is constructed that is\\n     * identical to this URI except that its path is computed by normalizing\\n     * this URI\\\u0027s path in a manner consistent with \u003ca\\n     * href=\"http://www.ietf.org/rfc/rfc2396.txt\"\u003eRFC\u0026nbsp;2396\u003c/a\u003e,\\n     * section\u0026nbsp;5.2, step\u0026nbsp;6, sub-steps\u0026nbsp;c through\u0026nbsp;f; that is:\\n     * \u003c/p\u003e\\n     *\\n     * \u003col\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e All {@code \".\"} segments are removed. \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e If a {@code \"..\"} segment is preceded by a non-{@code \"..\"}\\n     *   segment then both of these segments are removed.  This step is\\n     *   repeated until it is no longer applicable. \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e If the path is relative, and if its first segment contains a\\n     *   colon character ({@code \\\u0027:\\\u0027}), then a {@code \".\"} segment is\\n     *   prepended.  This prevents a relative URI with a path such as\\n     *   {@code \"a:b/c/d\"} from later being re-parsed as an opaque URI with a\\n     *   scheme of {@code \"a\"} and a scheme-specific part of {@code \"b/c/d\"}.\\n     *   \u003cb\u003e\u003ci\u003e(Deviation from RFC\u0026nbsp;2396)\u003c/i\u003e\u003c/b\u003e \u003c/p\u003e\u003c/li\u003e\\n     *\\n     * \u003c/ol\u003e\\n     *\\n     * \u003cp\u003e A normalized path will begin with one or more {@code \"..\"} segments\\n     * if there were insufficient non-{@code \"..\"} segments preceding them to\\n     * allow their removal.  A normalized path will begin with a {@code \".\"}\\n     * segment if one was inserted by step 3 above.  Otherwise, a normalized\\n     * path will not contain any {@code \".\"} or {@code \"..\"} segments. \u003c/p\u003e\\n     *\\n     * @return  A URI equivalent to this URI,\\n     *          but whose path is in normal form\\n     \u0027}"}, {"color": "#97c2fc", "id": "public URI resolve(URI uri)", "label": "public URI resolve(URI uri)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Resolves the given URI against this URI.\\n     *\\n     * \u003cp\u003e If the given URI is already absolute, or if this URI is opaque, then\\n     * the given URI is returned.\\n     *\\n     * \u003cp\u003e\u003ca name=\"resolve-frag\"\u003e\u003c/a\u003e If the given URI\\\u0027s fragment component is\\n     * defined, its path component is empty, and its scheme, authority, and\\n     * query components are undefined, then a URI with the given fragment but\\n     * with all other components equal to those of this URI is returned.  This\\n     * allows a URI representing a standalone fragment reference, such as\\n     * {@code \"#foo\"}, to be usefully resolved against a base URI.\\n     *\\n     * \u003cp\u003e Otherwise this method constructs a new hierarchical URI in a manner\\n     * consistent with \u003ca\\n     * href=\"http://www.ietf.org/rfc/rfc2396.txt\"\u003eRFC\u0026nbsp;2396\u003c/a\u003e,\\n     * section\u0026nbsp;5.2; that is: \u003c/p\u003e\\n     *\\n     * \u003col\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e A new URI is constructed with this URI\\\u0027s scheme and the given\\n     *   URI\\\u0027s query and fragment components. \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e If the given URI has an authority component then the new URI\\\u0027s\\n     *   authority and path are taken from the given URI. \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e Otherwise the new URI\\\u0027s authority component is copied from\\n     *   this URI, and its path is computed as follows: \u003c/p\u003e\\n     *\\n     *   \u003col\u003e\\n     *\\n     *     \u003cli\u003e\u003cp\u003e If the given URI\\\u0027s path is absolute then the new URI\\\u0027s path\\n     *     is taken from the given URI. \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *     \u003cli\u003e\u003cp\u003e Otherwise the given URI\\\u0027s path is relative, and so the new\\n     *     URI\\\u0027s path is computed by resolving the path of the given URI\\n     *     against the path of this URI.  This is done by concatenating all but\\n     *     the last segment of this URI\\\u0027s path, if any, with the given URI\\\u0027s\\n     *     path and then normalizing the result as if by invoking the {@link\\n     *     #normalize() normalize} method. \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003c/ol\u003e\u003c/li\u003e\\n     *\\n     * \u003c/ol\u003e\\n     *\\n     * \u003cp\u003e The result of this method is absolute if, and only if, either this\\n     * URI is absolute or the given URI is absolute.  \u003c/p\u003e\\n     *\\n     * @param  uri  The URI to be resolved against this URI\\n     * @return The resulting URI\\n     *\\n     * @throws  NullPointerException\\n     *          If {@code uri} is {@code null}\\n     \u0027}"}, {"color": "#97c2fc", "id": "normalize()", "label": "normalize()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public URI resolve(String str)", "label": "public URI resolve(String str)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Constructs a new URI by parsing the given string and then resolving it\\n     * against this URI.\\n     *\\n     * \u003cp\u003e This convenience method works as if invoking it were equivalent to\\n     * evaluating the expression {@link #resolve(java.net.URI)\\n     * resolve}{@code (URI.}{@link #create(String) create}{@code (str))}. \u003c/p\u003e\\n     *\\n     * @param  str   The string to be parsed into a URI\\n     * @return The resulting URI\\n     *\\n     * @throws  NullPointerException\\n     *          If {@code str} is {@code null}\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the given string violates RFC\u0026nbsp;2396\\n     \u0027}"}, {"color": "#97c2fc", "id": "resolve(java.net.URI)", "label": "resolve(java.net.URI)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "create(String)", "label": "create(String)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public URI relativize(URI uri)", "label": "public URI relativize(URI uri)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Relativizes the given URI against this URI.\\n     *\\n     * \u003cp\u003e The relativization of the given URI against this URI is computed as\\n     * follows: \u003c/p\u003e\\n     *\\n     * \u003col\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e If either this URI or the given URI are opaque, or if the\\n     *   scheme and authority components of the two URIs are not identical, or\\n     *   if the path of this URI is not a prefix of the path of the given URI,\\n     *   then the given URI is returned. \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e Otherwise a new relative hierarchical URI is constructed with\\n     *   query and fragment components taken from the given URI and with a path\\n     *   component computed by removing this URI\u0027s path from the beginning of\\n     *   the given URI\u0027s path. \u003c/p\u003e\u003c/li\u003e\\n     *\\n     * \u003c/ol\u003e\\n     *\\n     * @param  uri  The URI to be relativized against this URI\\n     * @return The resulting URI\\n     *\\n     * @throws  NullPointerException\\n     *          If {@code uri} is {@code null}\\n     \"}"}, {"color": "#97c2fc", "id": "public URL toURL() throws MalformedURLException", "label": "public URL toURL() throws MalformedURLException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Constructs a URL from this URI.\\n     *\\n     * \u003cp\u003e This convenience method works as if invoking it were equivalent to\\n     * evaluating the expression {@code new URL(this.toString())} after\\n     * first checking that this URI is absolute. \u003c/p\u003e\\n     *\\n     * @return  A URL constructed from this URI\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If this URL is not absolute\\n     *\\n     * @throws  MalformedURLException\\n     *          If a protocol handler for the URL could not be found,\\n     *          or if some other error occurred while constructing the URL\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getScheme()", "label": "public String getScheme()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the scheme component of this URI.\\n     *\\n     * \u003cp\u003e The scheme component of a URI, if defined, only contains characters\\n     * in the \u003ci\u003ealphanum\u003c/i\u003e category and in the string {@code \"-.+\"}.  A\\n     * scheme always starts with an \u003ci\u003ealpha\u003c/i\u003e character. \u003cp\u003e\\n     *\\n     * The scheme component of a URI cannot contain escaped octets, hence this\\n     * method does not perform any decoding.\\n     *\\n     * @return  The scheme component of this URI,\\n     *          or {@code null} if the scheme is undefined\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isOpaque()", "label": "public boolean isOpaque()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Tells whether or not this URI is opaque.\\n     *\\n     * \u003cp\u003e A URI is opaque if, and only if, it is absolute and its\\n     * scheme-specific part does not begin with a slash character (\u0027/\u0027).\\n     * An opaque URI has a scheme, a scheme-specific part, and possibly\\n     * a fragment; all other components are undefined. \u003c/p\u003e\\n     *\\n     * @return  {@code true} if, and only if, this URI is opaque\\n     \"}"}, {"color": "#97c2fc", "id": "public String getRawSchemeSpecificPart()", "label": "public String getRawSchemeSpecificPart()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the raw scheme-specific part of this URI.  The scheme-specific\\n     * part is never undefined, though it may be empty.\\n     *\\n     * \u003cp\u003e The scheme-specific part of a URI only contains legal URI\\n     * characters. \u003c/p\u003e\\n     *\\n     * @return  The raw scheme-specific part of this URI\\n     *          (never {@code null})\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getSchemeSpecificPart()", "label": "public String getSchemeSpecificPart()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the decoded scheme-specific part of this URI.\\n     *\\n     * \u003cp\u003e The string returned by this method is equal to that returned by the\\n     * {@link #getRawSchemeSpecificPart() getRawSchemeSpecificPart} method\\n     * except that all sequences of escaped octets are \u003ca\\n     * href=\"#decode\"\u003edecoded\u003c/a\u003e.  \u003c/p\u003e\\n     *\\n     * @return  The decoded scheme-specific part of this URI\\n     *          (never {@code null})\\n     \u0027}"}, {"color": "#97c2fc", "id": "getRawSchemeSpecificPart()", "label": "getRawSchemeSpecificPart()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public String getRawAuthority()", "label": "public String getRawAuthority()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the raw authority component of this URI.\\n     *\\n     * \u003cp\u003e The authority component of a URI, if defined, only contains the\\n     * commercial-at character ({@code \u0027@\u0027}) and characters in the\\n     * \u003ci\u003eunreserved\u003c/i\u003e, \u003ci\u003epunct\u003c/i\u003e, \u003ci\u003eescaped\u003c/i\u003e, and \u003ci\u003eother\u003c/i\u003e\\n     * categories.  If the authority is server-based then it is further\\n     * constrained to have valid user-information, host, and port\\n     * components. \u003c/p\u003e\\n     *\\n     * @return  The raw authority component of this URI,\\n     *          or {@code null} if the authority is undefined\\n     \"}"}, {"color": "#97c2fc", "id": "public String getAuthority()", "label": "public String getAuthority()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the decoded authority component of this URI.\\n     *\\n     * \u003cp\u003e The string returned by this method is equal to that returned by the\\n     * {@link #getRawAuthority() getRawAuthority} method except that all\\n     * sequences of escaped octets are \u003ca href=\"#decode\"\u003edecoded\u003c/a\u003e.  \u003c/p\u003e\\n     *\\n     * @return  The decoded authority component of this URI,\\n     *          or {@code null} if the authority is undefined\\n     \u0027}"}, {"color": "#97c2fc", "id": "getRawAuthority()", "label": "getRawAuthority()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public String getRawUserInfo()", "label": "public String getRawUserInfo()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the raw user-information component of this URI.\\n     *\\n     * \u003cp\u003e The user-information component of a URI, if defined, only contains\\n     * characters in the \u003ci\u003eunreserved\u003c/i\u003e, \u003ci\u003epunct\u003c/i\u003e, \u003ci\u003eescaped\u003c/i\u003e, and\\n     * \u003ci\u003eother\u003c/i\u003e categories. \u003c/p\u003e\\n     *\\n     * @return  The raw user-information component of this URI,\\n     *          or {@code null} if the user information is undefined\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getUserInfo()", "label": "public String getUserInfo()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the decoded user-information component of this URI.\\n     *\\n     * \u003cp\u003e The string returned by this method is equal to that returned by the\\n     * {@link #getRawUserInfo() getRawUserInfo} method except that all\\n     * sequences of escaped octets are \u003ca href=\"#decode\"\u003edecoded\u003c/a\u003e.  \u003c/p\u003e\\n     *\\n     * @return  The decoded user-information component of this URI,\\n     *          or {@code null} if the user information is undefined\\n     \u0027}"}, {"color": "#97c2fc", "id": "getRawUserInfo()", "label": "getRawUserInfo()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public String getHost()", "label": "public String getHost()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the host component of this URI.\\n     *\\n     * \u003cp\u003e The host component of a URI, if defined, will have one of the\\n     * following forms: \u003c/p\u003e\\n     *\\n     * \u003cul\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e A domain name consisting of one or more \u003ci\u003elabels\u003c/i\u003e\\n     *   separated by period characters ({@code \\\u0027.\\\u0027}), optionally followed by\\n     *   a period character.  Each label consists of \u003ci\u003ealphanum\u003c/i\u003e characters\\n     *   as well as hyphen characters ({@code \\\u0027-\\\u0027}), though hyphens never\\n     *   occur as the first or last characters in a label. The rightmost\\n     *   label of a domain name consisting of two or more labels, begins\\n     *   with an \u003ci\u003ealpha\u003c/i\u003e character. \u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e A dotted-quad IPv4 address of the form\\n     *   \u003ci\u003edigit\u003c/i\u003e{@code +.}\u003ci\u003edigit\u003c/i\u003e{@code +.}\u003ci\u003edigit\u003c/i\u003e{@code +.}\u003ci\u003edigit\u003c/i\u003e{@code +},\\n     *   where no \u003ci\u003edigit\u003c/i\u003e sequence is longer than three characters and no\\n     *   sequence has a value larger than 255. \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e An IPv6 address enclosed in square brackets ({@code \\\u0027[\\\u0027} and\\n     *   {@code \\\u0027]\\\u0027}) and consisting of hexadecimal digits, colon characters\\n     *   ({@code \\\u0027:\\\u0027}), and possibly an embedded IPv4 address.  The full\\n     *   syntax of IPv6 addresses is specified in \u003ca\\n     *   href=\"http://www.ietf.org/rfc/rfc2373.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;2373: IPv6\\n     *   Addressing Architecture\u003c/i\u003e\u003c/a\u003e.  \u003c/p\u003e\u003c/li\u003e\\n     *\\n     * \u003c/ul\u003e\\n     *\\n     * The host component of a URI cannot contain escaped octets, hence this\\n     * method does not perform any decoding.\\n     *\\n     * @return  The host component of this URI,\\n     *          or {@code null} if the host is undefined\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getRawPath()", "label": "public String getRawPath()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the raw path component of this URI.\\n     *\\n     * \u003cp\u003e The path component of a URI, if defined, only contains the slash\\n     * character ({@code \u0027/\u0027}), the commercial-at character ({@code \u0027@\u0027}),\\n     * and characters in the \u003ci\u003eunreserved\u003c/i\u003e, \u003ci\u003epunct\u003c/i\u003e, \u003ci\u003eescaped\u003c/i\u003e,\\n     * and \u003ci\u003eother\u003c/i\u003e categories. \u003c/p\u003e\\n     *\\n     * @return  The path component of this URI,\\n     *          or {@code null} if the path is undefined\\n     \"}"}, {"color": "#97c2fc", "id": "getRawPath()", "label": "getRawPath()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public String getRawQuery()", "label": "public String getRawQuery()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the raw query component of this URI.\\n     *\\n     * \u003cp\u003e The query component of a URI, if defined, only contains legal URI\\n     * characters. \u003c/p\u003e\\n     *\\n     * @return  The raw query component of this URI,\\n     *          or {@code null} if the query is undefined\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getQuery()", "label": "public String getQuery()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the decoded query component of this URI.\\n     *\\n     * \u003cp\u003e The string returned by this method is equal to that returned by the\\n     * {@link #getRawQuery() getRawQuery} method except that all sequences of\\n     * escaped octets are \u003ca href=\"#decode\"\u003edecoded\u003c/a\u003e.  \u003c/p\u003e\\n     *\\n     * @return  The decoded query component of this URI,\\n     *          or {@code null} if the query is undefined\\n     \u0027}"}, {"color": "#97c2fc", "id": "getRawQuery()", "label": "getRawQuery()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public String getRawFragment()", "label": "public String getRawFragment()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the raw fragment component of this URI.\\n     *\\n     * \u003cp\u003e The fragment component of a URI, if defined, only contains legal URI\\n     * characters. \u003c/p\u003e\\n     *\\n     * @return  The raw fragment component of this URI,\\n     *          or {@code null} if the fragment is undefined\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String getFragment()", "label": "public String getFragment()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the decoded fragment component of this URI.\\n     *\\n     * \u003cp\u003e The string returned by this method is equal to that returned by the\\n     * {@link #getRawFragment() getRawFragment} method except that all\\n     * sequences of escaped octets are \u003ca href=\"#decode\"\u003edecoded\u003c/a\u003e.  \u003c/p\u003e\\n     *\\n     * @return  The decoded fragment component of this URI,\\n     *          or {@code null} if the fragment is undefined\\n     \u0027}"}, {"color": "#97c2fc", "id": "getRawFragment()", "label": "getRawFragment()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public int compareTo(URI that)", "label": "public int compareTo(URI that)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares this URI to another object, which must be a URI.\\n     *\\n     * \u003cp\u003e When comparing corresponding components of two URIs, if one\\n     * component is undefined but the other is defined then the first is\\n     * considered to be less than the second.  Unless otherwise noted, string\\n     * components are ordered according to their natural, case-sensitive\\n     * ordering as defined by the {@link java.lang.String#compareTo(Object)\\n     * String.compareTo} method.  String components that are subject to\\n     * encoding are compared by comparing their raw forms rather than their\\n     * encoded forms.\\n     *\\n     * \u003cp\u003e The ordering of URIs is defined as follows: \u003c/p\u003e\\n     *\\n     * \u003cul\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e Two URIs with different schemes are ordered according the\\n     *   ordering of their schemes, without regard to case. \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e A hierarchical URI is considered to be less than an opaque URI\\n     *   with an identical scheme. \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e Two opaque URIs with identical schemes are ordered according\\n     *   to the ordering of their scheme-specific parts. \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e Two opaque URIs with identical schemes and scheme-specific\\n     *   parts are ordered according to the ordering of their\\n     *   fragments. \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e Two hierarchical URIs with identical schemes are ordered\\n     *   according to the ordering of their authority components: \u003c/p\u003e\\n     *\\n     *   \u003cul\u003e\\n     *\\n     *     \u003cli\u003e\u003cp\u003e If both authority components are server-based then the URIs\\n     *     are ordered according to their user-information components; if these\\n     *     components are identical then the URIs are ordered according to the\\n     *     ordering of their hosts, without regard to case; if the hosts are\\n     *     identical then the URIs are ordered according to the ordering of\\n     *     their ports. \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *     \u003cli\u003e\u003cp\u003e If one or both authority components are registry-based then\\n     *     the URIs are ordered according to the ordering of their authority\\n     *     components. \u003c/p\u003e\u003c/li\u003e\\n     *\\n     *   \u003c/ul\u003e\u003c/li\u003e\\n     *\\n     *   \u003cli\u003e\u003cp\u003e Finally, two hierarchical URIs with identical schemes and\\n     *   authority components are ordered according to the ordering of their\\n     *   paths; if their paths are identical then they are ordered according to\\n     *   the ordering of their queries; if the queries are identical then they\\n     *   are ordered according to the order of their fragments. \u003c/p\u003e\u003c/li\u003e\\n     *\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003e This method satisfies the general contract of the {@link\\n     * java.lang.Comparable#compareTo(Object) Comparable.compareTo}\\n     * method. \u003c/p\u003e\\n     *\\n     * @param   that\\n     *          The object to which this URI is to be compared\\n     *\\n     * @return  A negative integer, zero, or a positive integer as this URI is\\n     *          less than, equal to, or greater than the given URI\\n     *\\n     * @throws  ClassCastException\\n     *          If the given object is not a URI\\n     \u0027}"}, {"color": "#97c2fc", "id": "compareTo(Object)", "label": "compareTo(Object)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.lang.Comparable", "label": "java.lang.Comparable", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * This interface imposes a total ordering on the objects of each class that\\n * implements it.  This ordering is referred to as the class\\\u0027s \u003ci\u003enatural\\n * ordering\u003c/i\u003e, and the class\\\u0027s {@code compareTo} method is referred to as\\n * its \u003ci\u003enatural comparison method\u003c/i\u003e.\u003cp\u003e\\n *\\n * Lists (and arrays) of objects that implement this interface can be sorted\\n * automatically by {@link Collections#sort(List) Collections.sort} (and\\n * {@link Arrays#sort(Object[]) Arrays.sort}).  Objects that implement this\\n * interface can be used as keys in a {@linkplain SortedMap sorted map} or as\\n * elements in a {@linkplain SortedSet sorted set}, without the need to\\n * specify a {@linkplain Comparator comparator}.\u003cp\u003e\\n *\\n * The natural ordering for a class {@code C} is said to be \u003ci\u003econsistent\\n * with equals\u003c/i\u003e if and only if {@code e1.compareTo(e2) == 0} has\\n * the same boolean value as {@code e1.equals(e2)} for every\\n * {@code e1} and {@code e2} of class {@code C}.  Note that {@code null}\\n * is not an instance of any class, and {@code e.compareTo(null)} should\\n * throw a {@code NullPointerException} even though {@code e.equals(null)}\\n * returns {@code false}.\u003cp\u003e\\n *\\n * It is strongly recommended (though not required) that natural orderings be\\n * consistent with equals.  This is so because sorted sets (and sorted maps)\\n * without explicit comparators behave \"strangely\" when they are used with\\n * elements (or keys) whose natural ordering is inconsistent with equals.  In\\n * particular, such a sorted set (or sorted map) violates the general contract\\n * for set (or map), which is defined in terms of the {@code equals}\\n * method.\u003cp\u003e\\n *\\n * For example, if one adds two keys {@code a} and {@code b} such that\\n * {@code (!a.equals(b) \u0026\u0026 a.compareTo(b) == 0)} to a sorted\\n * set that does not use an explicit comparator, the second {@code add}\\n * operation returns false (and the size of the sorted set does not increase)\\n * because {@code a} and {@code b} are equivalent from the sorted set\\\u0027s\\n * perspective.\u003cp\u003e\\n *\\n * Virtually all Java core classes that implement {@code Comparable}\\n * have natural orderings that are consistent with equals.  One\\n * exception is {@link java.math.BigDecimal}, whose {@linkplain\\n * java.math.BigDecimal#compareTo natural ordering} equates {@code\\n * BigDecimal} objects with equal numerical values and different\\n * representations (such as 4.0 and 4.00). For {@link\\n * java.math.BigDecimal#equals BigDecimal.equals()} to return true,\\n * the representation and numerical value of the two {@code\\n * BigDecimal} objects must be the same.\u003cp\u003e\\n *\\n * For the mathematically inclined, the \u003ci\u003erelation\u003c/i\u003e that defines\\n * the natural ordering on a given class C is:\u003cpre\u003e{@code\\n *       {(x, y) such that x.compareTo(y) \u003c= 0}.\\n * }\u003c/pre\u003e The \u003ci\u003equotient\u003c/i\u003e for this total order is: \u003cpre\u003e{@code\\n *       {(x, y) such that x.compareTo(y) == 0}.\\n * }\u003c/pre\u003e\\n *\\n * It follows immediately from the contract for {@code compareTo} that the\\n * quotient is an \u003ci\u003eequivalence relation\u003c/i\u003e on {@code C}, and that the\\n * natural ordering is a \u003ci\u003etotal order\u003c/i\u003e on {@code C}.  When we say that a\\n * class\\\u0027s natural ordering is \u003ci\u003econsistent with equals\u003c/i\u003e, we mean that the\\n * quotient for the natural ordering is the equivalence relation defined by\\n * the class\\\u0027s {@link Object#equals(Object) equals(Object)} method:\u003cpre\u003e\\n *     {(x, y) such that x.equals(y)}. \u003c/pre\u003e\u003cp\u003e\\n *\\n * In other words, when a class\\\u0027s natural ordering is consistent with\\n * equals, the equivalence classes defined by the equivalence relation\\n * of the {@code equals} method and the equivalence classes defined by\\n * the quotient of the {@code compareTo} method are the same.\\n *\\n * \u003cp\u003eThis interface is a member of the\\n * \u003ca href=\"{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework\"\u003e\\n * Java Collections Framework\u003c/a\u003e.\\n *\\n * @param \u003cT\u003e the type of objects that this object may be compared to\\n *\\n * @author  Josh Bloch\\n * @see java.util.Comparator\\n * @since 1.2\\n \u0027}"}, {"color": "#97c2fc", "id": "public int compareTo(T o)", "label": "public int compareTo(T o)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares this object with the specified object for order.  Returns a\\n     * negative integer, zero, or a positive integer as this object is less\\n     * than, equal to, or greater than the specified object.\\n     *\\n     * \u003cp\u003eThe implementor must ensure {@link Integer#signum\\n     * signum}{@code (x.compareTo(y)) == -signum(y.compareTo(x))} for\\n     * all {@code x} and {@code y}.  (This implies that {@code\\n     * x.compareTo(y)} must throw an exception if and only if {@code\\n     * y.compareTo(x)} throws an exception.)\\n     *\\n     * \u003cp\u003eThe implementor must also ensure that the relation is transitive:\\n     * {@code (x.compareTo(y) \u003e 0 \u0026\u0026 y.compareTo(z) \u003e 0)} implies\\n     * {@code x.compareTo(z) \u003e 0}.\\n     *\\n     * \u003cp\u003eFinally, the implementor must ensure that {@code\\n     * x.compareTo(y)==0} implies that {@code signum(x.compareTo(z))\\n     * == signum(y.compareTo(z))}, for all {@code z}.\\n     *\\n     * @apiNote\\n     * It is strongly recommended, but \u003ci\u003enot\u003c/i\u003e strictly required that\\n     * {@code (x.compareTo(y)==0) == (x.equals(y))}.  Generally speaking, any\\n     * class that implements the {@code Comparable} interface and violates\\n     * this condition should clearly indicate this fact.  The recommended\\n     * language is \"Note: this class has a natural ordering that is\\n     * inconsistent with equals.\"\\n     *\\n     * @param   o the object to be compared.\\n     * @return  a negative integer, zero, or a positive integer as this object\\n     *          is less than, equal to, or greater than the specified object.\\n     *\\n     * @throws NullPointerException if the specified object is null\\n     * @throws ClassCastException if the specified object\\\u0027s type prevents it\\n     *         from being compared to this object.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String toASCIIString()", "label": "public String toASCIIString()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the content of this URI as a US-ASCII string.\\n     *\\n     * \u003cp\u003e If this URI does not contain any characters in the \u003ci\u003eother\u003c/i\u003e\\n     * category then an invocation of this method will return the same value as\\n     * an invocation of the {@link #toString() toString} method.  Otherwise\\n     * this method works as if by invoking that method and then \u003ca\\n     * href=\"#encode\"\u003eencoding\u003c/a\u003e the result.  \u003c/p\u003e\\n     *\\n     * @return  The string form of this URI, encoded as needed\\n     *          so that it only contains characters in the US-ASCII\\n     *          charset\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void writeObject(ObjectOutputStream os) throws IOException", "label": "private void writeObject(ObjectOutputStream os) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Saves the content of this URI to the given serial stream.\\n     *\\n     * \u003cp\u003e The only serializable field of a URI instance is its {@code string}\\n     * field.  That field is given a value, if it does not have one already,\\n     * and then the {@link java.io.ObjectOutputStream#defaultWriteObject()}\\n     * method of the given object-output stream is invoked. \u003c/p\u003e\\n     *\\n     * @param  os  The object-output stream to which this object\\n     *             is to be written\\n     \u0027}"}, {"color": "#97c2fc", "id": "defaultWriteObject()", "label": "defaultWriteObject()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.io.ObjectOutputStream", "label": "java.io.ObjectOutputStream", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * An ObjectOutputStream writes primitive data types and graphs of Java objects\\n * to an OutputStream.  The objects can be read (reconstituted) using an\\n * ObjectInputStream.  Persistent storage of objects can be accomplished by\\n * using a file for the stream.  If the stream is a network socket stream, the\\n * objects can be reconstituted on another host or in another process.\\n *\\n * \u003cp\u003eOnly objects that support the java.io.Serializable interface can be\\n * written to streams.  The class of each serializable object is encoded\\n * including the class name and signature of the class, the values of the\\n * object\\\u0027s fields and arrays, and the closure of any other objects referenced\\n * from the initial objects.\\n *\\n * \u003cp\u003eThe method writeObject is used to write an object to the stream.  Any\\n * object, including Strings and arrays, is written with writeObject. Multiple\\n * objects or primitives can be written to the stream.  The objects must be\\n * read back from the corresponding ObjectInputstream with the same types and\\n * in the same order as they were written.\\n *\\n * \u003cp\u003ePrimitive data types can also be written to the stream using the\\n * appropriate methods from DataOutput. Strings can also be written using the\\n * writeUTF method.\\n *\\n * \u003cp\u003eThe default serialization mechanism for an object writes the class of the\\n * object, the class signature, and the values of all non-transient and\\n * non-static fields.  References to other objects (except in transient or\\n * static fields) cause those objects to be written also. Multiple references\\n * to a single object are encoded using a reference sharing mechanism so that\\n * graphs of objects can be restored to the same shape as when the original was\\n * written.\\n *\\n * \u003cp\u003eFor example to write an object that can be read by the example in\\n * ObjectInputStream:\\n * \u003cbr\u003e\\n * \u003cpre\u003e\\n *      FileOutputStream fos = new FileOutputStream(\"t.tmp\");\\n *      ObjectOutputStream oos = new ObjectOutputStream(fos);\\n *\\n *      oos.writeInt(12345);\\n *      oos.writeObject(\"Today\");\\n *      oos.writeObject(new Date());\\n *\\n *      oos.close();\\n * \u003c/pre\u003e\\n *\\n * \u003cp\u003eClasses that require special handling during the serialization and\\n * deserialization process must implement special methods with these exact\\n * signatures:\\n * \u003cbr\u003e\\n * \u003cpre\u003e\\n * private void readObject(java.io.ObjectInputStream stream)\\n *     throws IOException, ClassNotFoundException;\\n * private void writeObject(java.io.ObjectOutputStream stream)\\n *     throws IOException\\n * private void readObjectNoData()\\n *     throws ObjectStreamException;\\n * \u003c/pre\u003e\\n *\\n * \u003cp\u003eThe writeObject method is responsible for writing the state of the object\\n * for its particular class so that the corresponding readObject method can\\n * restore it.  The method does not need to concern itself with the state\\n * belonging to the object\\\u0027s superclasses or subclasses.  State is saved by\\n * writing the individual fields to the ObjectOutputStream using the\\n * writeObject method or by using the methods for primitive data types\\n * supported by DataOutput.\\n *\\n * \u003cp\u003eSerialization does not write out the fields of any object that does not\\n * implement the java.io.Serializable interface.  Subclasses of Objects that\\n * are not serializable can be serializable. In this case the non-serializable\\n * class must have a no-arg constructor to allow its fields to be initialized.\\n * In this case it is the responsibility of the subclass to save and restore\\n * the state of the non-serializable class. It is frequently the case that the\\n * fields of that class are accessible (public, package, or protected) or that\\n * there are get and set methods that can be used to restore the state.\\n *\\n * \u003cp\u003eSerialization of an object can be prevented by implementing writeObject\\n * and readObject methods that throw the NotSerializableException.  The\\n * exception will be caught by the ObjectOutputStream and abort the\\n * serialization process.\\n *\\n * \u003cp\u003eImplementing the Externalizable interface allows the object to assume\\n * complete control over the contents and format of the object\\\u0027s serialized\\n * form.  The methods of the Externalizable interface, writeExternal and\\n * readExternal, are called to save and restore the objects state.  When\\n * implemented by a class they can write and read their own state using all of\\n * the methods of ObjectOutput and ObjectInput.  It is the responsibility of\\n * the objects to handle any versioning that occurs.\\n *\\n * \u003cp\u003eEnum constants are serialized differently than ordinary serializable or\\n * externalizable objects.  The serialized form of an enum constant consists\\n * solely of its name; field values of the constant are not transmitted.  To\\n * serialize an enum constant, ObjectOutputStream writes the string returned by\\n * the constant\\\u0027s name method.  Like other serializable or externalizable\\n * objects, enum constants can function as the targets of back references\\n * appearing subsequently in the serialization stream.  The process by which\\n * enum constants are serialized cannot be customized; any class-specific\\n * writeObject and writeReplace methods defined by enum types are ignored\\n * during serialization.  Similarly, any serialPersistentFields or\\n * serialVersionUID field declarations are also ignored--all enum types have a\\n * fixed serialVersionUID of 0L.\\n *\\n * \u003cp\u003ePrimitive data, excluding serializable fields and externalizable data, is\\n * written to the ObjectOutputStream in block-data records. A block data record\\n * is composed of a header and data. The block data header consists of a marker\\n * and the number of bytes to follow the header.  Consecutive primitive data\\n * writes are merged into one block-data record.  The blocking factor used for\\n * a block-data record will be 1024 bytes.  Each block-data record will be\\n * filled up to 1024 bytes, or be written whenever there is a termination of\\n * block-data mode.  Calls to the ObjectOutputStream methods writeObject,\\n * defaultWriteObject and writeFields initially terminate any existing\\n * block-data record.\\n *\\n * @author      Mike Warres\\n * @author      Roger Riggs\\n * @see java.io.DataOutput\\n * @see java.io.ObjectInputStream\\n * @see java.io.Serializable\\n * @see java.io.Externalizable\\n * @see \u003ca href=\"../../../platform/serialization/spec/output.html\"\u003eObject Serialization Specification, Section 2, Object Output Classes\u003c/a\u003e\\n * @since       JDK1.1\\n \u0027}"}, {"color": "#97c2fc", "id": "public void useProtocolVersion(int version) throws IOException", "label": "public void useProtocolVersion(int version) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Specify stream protocol version to use when writing the stream.\\n     *\\n     * \u003cp\u003eThis routine provides a hook to enable the current version of\\n     * Serialization to write in a format that is backwards compatible to a\\n     * previous version of the stream format.\\n     *\\n     * \u003cp\u003eEvery effort will be made to avoid introducing additional\\n     * backwards incompatibilities; however, sometimes there is no\\n     * other alternative.\\n     *\\n     * @param   version use ProtocolVersion from java.io.ObjectStreamConstants.\\n     * @throws  IllegalStateException if called after any objects\\n     *          have been serialized.\\n     * @throws  IllegalArgumentException if invalid version is passed in.\\n     * @throws  IOException if I/O errors occur\\n     * @see java.io.ObjectStreamConstants#PROTOCOL_VERSION_1\\n     * @see java.io.ObjectStreamConstants#PROTOCOL_VERSION_2\\n     * @since   1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final void writeObject(Object obj) throws IOException", "label": "public final void writeObject(Object obj) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Write the specified object to the ObjectOutputStream.  The class of the\\n     * object, the signature of the class, and the values of the non-transient\\n     * and non-static fields of the class and all of its supertypes are\\n     * written.  Default serialization for a class can be overridden using the\\n     * writeObject and the readObject methods.  Objects referenced by this\\n     * object are written transitively so that a complete equivalent graph of\\n     * objects can be reconstructed by an ObjectInputStream.\\n     *\\n     * \u003cp\u003eExceptions are thrown for problems with the OutputStream and for\\n     * classes that should not be serialized.  All exceptions are fatal to the\\n     * OutputStream, which is left in an indeterminate state, and it is up to\\n     * the caller to ignore or recover the stream state.\\n     *\\n     * @throws  InvalidClassException Something is wrong with a class used by\\n     *          serialization.\\n     * @throws  NotSerializableException Some object to be serialized does not\\n     *          implement the java.io.Serializable interface.\\n     * @throws  IOException Any exception thrown by the underlying\\n     *          OutputStream.\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected void writeObjectOverride(Object obj) throws IOException", "label": "protected void writeObjectOverride(Object obj) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Method used by subclasses to override the default writeObject method.\\n     * This method is called by trusted subclasses of ObjectInputStream that\\n     * constructed ObjectInputStream using the protected no-arg constructor.\\n     * The subclass is expected to provide an override method with the modifier\\n     * \"final\".\\n     *\\n     * @param   obj object to be written to the underlying stream\\n     * @throws  IOException if there are I/O errors while writing to the\\n     *          underlying stream\\n     * @see #ObjectOutputStream()\\n     * @see #writeObject(Object)\\n     * @since 1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void writeUnshared(Object obj) throws IOException", "label": "public void writeUnshared(Object obj) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes an \"unshared\" object to the ObjectOutputStream.  This method is\\n     * identical to writeObject, except that it always writes the given object\\n     * as a new, unique object in the stream (as opposed to a back-reference\\n     * pointing to a previously serialized instance).  Specifically:\\n     * \u003cul\u003e\\n     *   \u003cli\u003eAn object written via writeUnshared is always serialized in the\\n     *       same manner as a newly appearing object (an object that has not\\n     *       been written to the stream yet), regardless of whether or not the\\n     *       object has been written previously.\\n     *\\n     *   \u003cli\u003eIf writeObject is used to write an object that has been previously\\n     *       written with writeUnshared, the previous writeUnshared operation\\n     *       is treated as if it were a write of a separate object.  In other\\n     *       words, ObjectOutputStream will never generate back-references to\\n     *       object data written by calls to writeUnshared.\\n     * \u003c/ul\u003e\\n     * While writing an object via writeUnshared does not in itself guarantee a\\n     * unique reference to the object when it is deserialized, it allows a\\n     * single object to be defined multiple times in a stream, so that multiple\\n     * calls to readUnshared by the receiver will not conflict.  Note that the\\n     * rules described above only apply to the base-level object written with\\n     * writeUnshared, and not to any transitively referenced sub-objects in the\\n     * object graph to be serialized.\\n     *\\n     * \u003cp\u003eObjectOutputStream subclasses which override this method can only be\\n     * constructed in security contexts possessing the\\n     * \"enableSubclassImplementation\" SerializablePermission; any attempt to\\n     * instantiate such a subclass without this permission will cause a\\n     * SecurityException to be thrown.\\n     *\\n     * @param   obj object to write to stream\\n     * @throws  NotSerializableException if an object in the graph to be\\n     *          serialized does not implement the Serializable interface\\n     * @throws  InvalidClassException if a problem exists with the class of an\\n     *          object to be serialized\\n     * @throws  IOException if an I/O error occurs during serialization\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void defaultWriteObject() throws IOException", "label": "public void defaultWriteObject() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Write the non-static and non-transient fields of the current class to\\n     * this stream.  This may only be called from the writeObject method of the\\n     * class being serialized. It will throw the NotActiveException if it is\\n     * called otherwise.\\n     *\\n     * @throws  IOException if I/O errors occur while writing to the underlying\\n     *          \u003ccode\u003eOutputStream\u003c/code\u003e\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ObjectOutputStream.PutField putFields() throws IOException", "label": "public ObjectOutputStream.PutField putFields() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Retrieve the object used to buffer persistent fields to be written to\\n     * the stream.  The fields will be written to the stream when writeFields\\n     * method is called.\\n     *\\n     * @return  an instance of the class Putfield that holds the serializable\\n     *          fields\\n     * @throws  IOException if I/O errors occur\\n     * @since 1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void writeFields() throws IOException", "label": "public void writeFields() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Write the buffered fields to the stream.\\n     *\\n     * @throws  IOException if I/O errors occur while writing to the underlying\\n     *          stream\\n     * @throws  NotActiveException Called when a classes writeObject method was\\n     *          not called to write the state of the object.\\n     * @since 1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected void annotateClass(Class\u003c?\u003e cl) throws IOException", "label": "protected void annotateClass(Class\u003c?\u003e cl) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Subclasses may implement this method to allow class data to be stored in\\n     * the stream. By default this method does nothing.  The corresponding\\n     * method in ObjectInputStream is resolveClass.  This method is called\\n     * exactly once for each unique class in the stream.  The class name and\\n     * signature will have already been written to the stream.  This method may\\n     * make free use of the ObjectOutputStream to save any representation of\\n     * the class it deems suitable (for example, the bytes of the class file).\\n     * The resolveClass method in the corresponding subclass of\\n     * ObjectInputStream must read and use any data or objects written by\\n     * annotateClass.\\n     *\\n     * @param   cl the class to annotate custom data for\\n     * @throws  IOException Any exception thrown by the underlying\\n     *          OutputStream.\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected void annotateProxyClass(Class\u003c?\u003e cl) throws IOException", "label": "protected void annotateProxyClass(Class\u003c?\u003e cl) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Subclasses may implement this method to store custom data in the stream\\n     * along with descriptors for dynamic proxy classes.\\n     *\\n     * \u003cp\u003eThis method is called exactly once for each unique proxy class\\n     * descriptor in the stream.  The default implementation of this method in\\n     * \u003ccode\u003eObjectOutputStream\u003c/code\u003e does nothing.\\n     *\\n     * \u003cp\u003eThe corresponding method in \u003ccode\u003eObjectInputStream\u003c/code\u003e is\\n     * \u003ccode\u003eresolveProxyClass\u003c/code\u003e.  For a given subclass of\\n     * \u003ccode\u003eObjectOutputStream\u003c/code\u003e that overrides this method, the\\n     * \u003ccode\u003eresolveProxyClass\u003c/code\u003e method in the corresponding subclass of\\n     * \u003ccode\u003eObjectInputStream\u003c/code\u003e must read any data or objects written by\\n     * \u003ccode\u003eannotateProxyClass\u003c/code\u003e.\\n     *\\n     * @param   cl the proxy class to annotate custom data for\\n     * @throws  IOException any exception thrown by the underlying\\n     *          \u003ccode\u003eOutputStream\u003c/code\u003e\\n     * @see ObjectInputStream#resolveProxyClass(String[])\\n     * @since   1.3\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected Object replaceObject(Object obj) throws IOException", "label": "protected Object replaceObject(Object obj) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * This method will allow trusted subclasses of ObjectOutputStream to\\n     * substitute one object for another during serialization. Replacing\\n     * objects is disabled until enableReplaceObject is called. The\\n     * enableReplaceObject method checks that the stream requesting to do\\n     * replacement can be trusted.  The first occurrence of each object written\\n     * into the serialization stream is passed to replaceObject.  Subsequent\\n     * references to the object are replaced by the object returned by the\\n     * original call to replaceObject.  To ensure that the private state of\\n     * objects is not unintentionally exposed, only trusted streams may use\\n     * replaceObject.\\n     *\\n     * \u003cp\u003eThe ObjectOutputStream.writeObject method takes a parameter of type\\n     * Object (as opposed to type Serializable) to allow for cases where\\n     * non-serializable objects are replaced by serializable ones.\\n     *\\n     * \u003cp\u003eWhen a subclass is replacing objects it must insure that either a\\n     * complementary substitution must be made during deserialization or that\\n     * the substituted object is compatible with every field where the\\n     * reference will be stored.  Objects whose type is not a subclass of the\\n     * type of the field or array element abort the serialization by raising an\\n     * exception and the object is not be stored.\\n     *\\n     * \u003cp\u003eThis method is called only once when each object is first\\n     * encountered.  All subsequent references to the object will be redirected\\n     * to the new object. This method should return the object to be\\n     * substituted or the original object.\\n     *\\n     * \u003cp\u003eNull can be returned as the object to be substituted, but may cause\\n     * NullReferenceException in classes that contain references to the\\n     * original object since they may be expecting an object instead of\\n     * null.\\n     *\\n     * @param   obj the object to be replaced\\n     * @return  the alternate object that replaced the specified one\\n     * @throws  IOException Any exception thrown by the underlying\\n     *          OutputStream.\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected boolean enableReplaceObject(boolean enable) throws SecurityException", "label": "protected boolean enableReplaceObject(boolean enable) throws SecurityException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Enable the stream to do replacement of objects in the stream.  When\\n     * enabled, the replaceObject method is called for every object being\\n     * serialized.\\n     *\\n     * \u003cp\u003eIf \u003ccode\u003eenable\u003c/code\u003e is true, and there is a security manager\\n     * installed, this method first calls the security manager\\\u0027s\\n     * \u003ccode\u003echeckPermission\u003c/code\u003e method with a\\n     * \u003ccode\u003eSerializablePermission(\"enableSubstitution\")\u003c/code\u003e permission to\\n     * ensure it\\\u0027s ok to enable the stream to do replacement of objects in the\\n     * stream.\\n     *\\n     * @param   enable boolean parameter to enable replacement of objects\\n     * @return  the previous setting before this method was invoked\\n     * @throws  SecurityException if a security manager exists and its\\n     *          \u003ccode\u003echeckPermission\u003c/code\u003e method denies enabling the stream\\n     *          to do replacement of objects in the stream.\\n     * @see SecurityManager#checkPermission\\n     * @see java.io.SerializablePermission\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected void writeStreamHeader() throws IOException", "label": "protected void writeStreamHeader() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The writeStreamHeader method is provided so subclasses can append or\\n     * prepend their own header to the stream.  It writes the magic number and\\n     * version to the stream.\\n     *\\n     * @throws  IOException if I/O errors occur while writing to the underlying\\n     *          stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected void writeClassDescriptor(ObjectStreamClass desc) throws IOException", "label": "protected void writeClassDescriptor(ObjectStreamClass desc) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Write the specified class descriptor to the ObjectOutputStream.  Class\\n     * descriptors are used to identify the classes of objects written to the\\n     * stream.  Subclasses of ObjectOutputStream may override this method to\\n     * customize the way in which class descriptors are written to the\\n     * serialization stream.  The corresponding method in ObjectInputStream,\\n     * \u003ccode\u003ereadClassDescriptor\u003c/code\u003e, should then be overridden to\\n     * reconstitute the class descriptor from its custom stream representation.\\n     * By default, this method writes class descriptors according to the format\\n     * defined in the Object Serialization specification.\\n     *\\n     * \u003cp\u003eNote that this method will only be called if the ObjectOutputStream\\n     * is not using the old serialization stream format (set by calling\\n     * ObjectOutputStream\u0027s \u003ccode\u003euseProtocolVersion\u003c/code\u003e method).  If this\\n     * serialization stream is using the old format\\n     * (\u003ccode\u003ePROTOCOL_VERSION_1\u003c/code\u003e), the class descriptor will be written\\n     * internally in a manner that cannot be overridden or customized.\\n     *\\n     * @param   desc class descriptor to write to the stream\\n     * @throws  IOException If an I/O error has occurred.\\n     * @see java.io.ObjectInputStream#readClassDescriptor()\\n     * @see #useProtocolVersion(int)\\n     * @see java.io.ObjectStreamConstants#PROTOCOL_VERSION_1\\n     * @since 1.3\\n     \"}"}, {"color": "#97c2fc", "id": "public void write(int val) throws IOException", "label": "public void write(int val) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes a byte. This method will block until the byte is actually\\n     * written.\\n     *\\n     * @param   val the byte to be written to the stream\\n     * @throws  IOException If an I/O error has occurred.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void write(byte[] buf) throws IOException", "label": "public void write(byte[] buf) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes an array of bytes. This method will block until the bytes are\\n     * actually written.\\n     *\\n     * @param   buf the data to be written\\n     * @throws  IOException If an I/O error has occurred.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void write(byte[] buf, int off, int len) throws IOException", "label": "public void write(byte[] buf, int off, int len) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes a sub array of bytes.\\n     *\\n     * @param   buf the data to be written\\n     * @param   off the start offset in the data\\n     * @param   len the number of bytes that are written\\n     * @throws  IOException If an I/O error has occurred.\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected void drain() throws IOException", "label": "protected void drain() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Drain any buffered data in ObjectOutputStream.  Similar to flush but\\n     * does not propagate the flush to the underlying stream.\\n     *\\n     * @throws  IOException if I/O errors occur while writing to the underlying\\n     *          stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void writeBoolean(boolean val) throws IOException", "label": "public void writeBoolean(boolean val) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes a boolean.\\n     *\\n     * @param   val the boolean to be written\\n     * @throws  IOException if I/O errors occur while writing to the underlying\\n     *          stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void writeByte(int val) throws IOException", "label": "public void writeByte(int val) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes an 8 bit byte.\\n     *\\n     * @param   val the byte value to be written\\n     * @throws  IOException if I/O errors occur while writing to the underlying\\n     *          stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void writeShort(int val) throws IOException", "label": "public void writeShort(int val) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes a 16 bit short.\\n     *\\n     * @param   val the short value to be written\\n     * @throws  IOException if I/O errors occur while writing to the underlying\\n     *          stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void writeChar(int val) throws IOException", "label": "public void writeChar(int val) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes a 16 bit char.\\n     *\\n     * @param   val the char value to be written\\n     * @throws  IOException if I/O errors occur while writing to the underlying\\n     *          stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void writeInt(int val) throws IOException", "label": "public void writeInt(int val) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes a 32 bit int.\\n     *\\n     * @param   val the integer value to be written\\n     * @throws  IOException if I/O errors occur while writing to the underlying\\n     *          stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void writeLong(long val) throws IOException", "label": "public void writeLong(long val) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes a 64 bit long.\\n     *\\n     * @param   val the long value to be written\\n     * @throws  IOException if I/O errors occur while writing to the underlying\\n     *          stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void writeFloat(float val) throws IOException", "label": "public void writeFloat(float val) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes a 32 bit float.\\n     *\\n     * @param   val the float value to be written\\n     * @throws  IOException if I/O errors occur while writing to the underlying\\n     *          stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void writeDouble(double val) throws IOException", "label": "public void writeDouble(double val) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes a 64 bit double.\\n     *\\n     * @param   val the double value to be written\\n     * @throws  IOException if I/O errors occur while writing to the underlying\\n     *          stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void writeBytes(String str) throws IOException", "label": "public void writeBytes(String str) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes a String as a sequence of bytes.\\n     *\\n     * @param   str the String of bytes to be written\\n     * @throws  IOException if I/O errors occur while writing to the underlying\\n     *          stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void writeChars(String str) throws IOException", "label": "public void writeChars(String str) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes a String as a sequence of chars.\\n     *\\n     * @param   str the String of chars to be written\\n     * @throws  IOException if I/O errors occur while writing to the underlying\\n     *          stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void writeUTF(String str) throws IOException", "label": "public void writeUTF(String str) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Primitive data write of this String in\\n     * \u003ca href=\"DataInput.html#modified-utf-8\"\u003emodified UTF-8\u003c/a\u003e\\n     * format.  Note that there is a\\n     * significant difference between writing a String into the stream as\\n     * primitive data or as an Object. A String instance written by writeObject\\n     * is written into the stream as a String initially. Future writeObject()\\n     * calls write references to the string into the stream.\\n     *\\n     * @param   str the String to be written\\n     * @throws  IOException if I/O errors occur while writing to the underlying\\n     *          stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " int getProtocolVersion()", "label": " int getProtocolVersion()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns protocol version in use.\\n     \u0027}"}, {"color": "#97c2fc", "id": " void writeTypeString(String str) throws IOException", "label": " void writeTypeString(String str) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes string without allowing it to be replaced in stream.  Used by\\n     * ObjectStreamClass to write class descriptor type strings.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void verifySubclass()", "label": "private void verifySubclass()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Verifies that this (possibly subclass) instance can be constructed\\n     * without violating security constraints: the subclass must not override\\n     * security-sensitive non-final methods, or else the\\n     * \"enableSubclassImplementation\" SerializablePermission is checked.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void clear()", "label": "private void clear()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Clears internal data structures.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void writeObject0(Object obj, boolean unshared) throws IOException", "label": "private void writeObject0(Object obj, boolean unshared) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Underlying writeObject/writeUnshared implementation.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void writeNull() throws IOException", "label": "private void writeNull() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes null code to stream.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void writeHandle(int handle) throws IOException", "label": "private void writeHandle(int handle) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes given object handle to stream.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void writeClass(Class\u003c?\u003e cl, boolean unshared) throws IOException", "label": "private void writeClass(Class\u003c?\u003e cl, boolean unshared) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes representation of given class to stream.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void writeClassDesc(ObjectStreamClass desc, boolean unshared) throws IOException", "label": "private void writeClassDesc(ObjectStreamClass desc, boolean unshared) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes representation of given class descriptor to stream.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void writeProxyDesc(ObjectStreamClass desc, boolean unshared) throws IOException", "label": "private void writeProxyDesc(ObjectStreamClass desc, boolean unshared) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes class descriptor representing a dynamic proxy class to stream.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void writeNonProxyDesc(ObjectStreamClass desc, boolean unshared) throws IOException", "label": "private void writeNonProxyDesc(ObjectStreamClass desc, boolean unshared) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes class descriptor representing a standard (i.e., not a dynamic\\n     * proxy) class to stream.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void writeString(String str, boolean unshared) throws IOException", "label": "private void writeString(String str, boolean unshared) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes given string to stream, using standard or long UTF format\\n     * depending on string length.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void writeArray(Object array, ObjectStreamClass desc, boolean unshared) throws IOException", "label": "private void writeArray(Object array, ObjectStreamClass desc, boolean unshared) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes given array object to stream.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void writeEnum(Enum\u003c?\u003e en, ObjectStreamClass desc, boolean unshared) throws IOException", "label": "private void writeEnum(Enum\u003c?\u003e en, ObjectStreamClass desc, boolean unshared) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes given enum constant to stream.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void writeOrdinaryObject(Object obj, ObjectStreamClass desc, boolean unshared) throws IOException", "label": "private void writeOrdinaryObject(Object obj, ObjectStreamClass desc, boolean unshared) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes representation of a \"ordinary\" (i.e., not a String, Class,\\n     * ObjectStreamClass, array, or enum constant) serializable object to the\\n     * stream.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void writeExternalData(Externalizable obj) throws IOException", "label": "private void writeExternalData(Externalizable obj) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes externalizable data of given object by invoking its\\n     * writeExternal() method.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void writeRecordData(Object obj, ObjectStreamClass desc) throws IOException", "label": "private void writeRecordData(Object obj, ObjectStreamClass desc) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Writes the record component values for the given record object. \u0027}"}, {"color": "#97c2fc", "id": "private void writeSerialData(Object obj, ObjectStreamClass desc) throws IOException", "label": "private void writeSerialData(Object obj, ObjectStreamClass desc) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Writes instance data for each serializable class of given object, from\\n     * superclass to subclass.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void defaultWriteFields(Object obj, ObjectStreamClass desc) throws IOException", "label": "private void defaultWriteFields(Object obj, ObjectStreamClass desc) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Fetches and writes values of serializable fields of given object to\\n     * stream.  The given class descriptor specifies which field values to\\n     * write, and in which order they should be written.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void writeFatalException(IOException ex) throws IOException", "label": "private void writeFatalException(IOException ex) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Attempts to write to stream fatal IOException that has caused\\n     * serialization to abort.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static native void floatsToBytes(float[] src, int srcpos, byte[] dst, int dstpos, int nfloats)", "label": "private static native void floatsToBytes(float[] src, int srcpos, byte[] dst, int dstpos, int nfloats)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 REMIND: remove once hotspot inlines Float.floatToIntBits\u0027}"}, {"color": "#97c2fc", "id": "private static native void doublesToBytes(double[] src, int srcpos, byte[] dst, int dstpos, int ndoubles)", "label": "private static native void doublesToBytes(double[] src, int srcpos, byte[] dst, int dstpos, int ndoubles)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 REMIND: remove once hotspot inlines Double.doubleToLongBits\u0027}"}, {"color": "#97c2fc", "id": "private void readObject(ObjectInputStream is) throws ClassNotFoundException, IOException", "label": "private void readObject(ObjectInputStream is) throws ClassNotFoundException, IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reconstitutes a URI from the given serial stream.\\n     *\\n     * \u003cp\u003e The {@link java.io.ObjectInputStream#defaultReadObject()} method is\\n     * invoked to read the value of the {@code string} field.  The result is\\n     * then parsed in the usual way.\\n     *\\n     * @param  is  The object-input stream from which this object\\n     *             is being read\\n     \u0027}"}, {"color": "#97c2fc", "id": "defaultReadObject()", "label": "defaultReadObject()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.io.ObjectInputStream", "label": "java.io.ObjectInputStream", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * An ObjectInputStream deserializes primitive data and objects previously\\n * written using an ObjectOutputStream.\\n *\\n * \u003cp\u003eObjectOutputStream and ObjectInputStream can provide an application with\\n * persistent storage for graphs of objects when used with a FileOutputStream\\n * and FileInputStream respectively.  ObjectInputStream is used to recover\\n * those objects previously serialized. Other uses include passing objects\\n * between hosts using a socket stream or for marshaling and unmarshaling\\n * arguments and parameters in a remote communication system.\\n *\\n * \u003cp\u003eObjectInputStream ensures that the types of all objects in the graph\\n * created from the stream match the classes present in the Java Virtual\\n * Machine.  Classes are loaded as required using the standard mechanisms.\\n *\\n * \u003cp\u003eOnly objects that support the java.io.Serializable or\\n * java.io.Externalizable interface can be read from streams.\\n *\\n * \u003cp\u003eThe method \u003ccode\u003ereadObject\u003c/code\u003e is used to read an object from the\\n * stream.  Java\\\u0027s safe casting should be used to get the desired type.  In\\n * Java, strings and arrays are objects and are treated as objects during\\n * serialization. When read they need to be cast to the expected type.\\n *\\n * \u003cp\u003ePrimitive data types can be read from the stream using the appropriate\\n * method on DataInput.\\n *\\n * \u003cp\u003eThe default deserialization mechanism for objects restores the contents\\n * of each field to the value and type it had when it was written.  Fields\\n * declared as transient or static are ignored by the deserialization process.\\n * References to other objects cause those objects to be read from the stream\\n * as necessary.  Graphs of objects are restored correctly using a reference\\n * sharing mechanism.  New objects are always allocated when deserializing,\\n * which prevents existing objects from being overwritten.\\n *\\n * \u003cp\u003eReading an object is analogous to running the constructors of a new\\n * object.  Memory is allocated for the object and initialized to zero (NULL).\\n * No-arg constructors are invoked for the non-serializable classes and then\\n * the fields of the serializable classes are restored from the stream starting\\n * with the serializable class closest to java.lang.object and finishing with\\n * the object\\\u0027s most specific class.\\n *\\n * \u003cp\u003eFor example to read from a stream as written by the example in\\n * ObjectOutputStream:\\n * \u003cbr\u003e\\n * \u003cpre\u003e\\n *      FileInputStream fis = new FileInputStream(\"t.tmp\");\\n *      ObjectInputStream ois = new ObjectInputStream(fis);\\n *\\n *      int i = ois.readInt();\\n *      String today = (String) ois.readObject();\\n *      Date date = (Date) ois.readObject();\\n *\\n *      ois.close();\\n * \u003c/pre\u003e\\n *\\n * \u003cp\u003eClasses control how they are serialized by implementing either the\\n * java.io.Serializable or java.io.Externalizable interfaces.\\n *\\n * \u003cp\u003eImplementing the Serializable interface allows object serialization to\\n * save and restore the entire state of the object and it allows classes to\\n * evolve between the time the stream is written and the time it is read.  It\\n * automatically traverses references between objects, saving and restoring\\n * entire graphs.\\n *\\n * \u003cp\u003eSerializable classes that require special handling during the\\n * serialization and deserialization process should implement the following\\n * methods:\\n *\\n * \u003cpre\u003e\\n * private void writeObject(java.io.ObjectOutputStream stream)\\n *     throws IOException;\\n * private void readObject(java.io.ObjectInputStream stream)\\n *     throws IOException, ClassNotFoundException;\\n * private void readObjectNoData()\\n *     throws ObjectStreamException;\\n * \u003c/pre\u003e\\n *\\n * \u003cp\u003eThe readObject method is responsible for reading and restoring the state\\n * of the object for its particular class using data written to the stream by\\n * the corresponding writeObject method.  The method does not need to concern\\n * itself with the state belonging to its superclasses or subclasses.  State is\\n * restored by reading data from the ObjectInputStream for the individual\\n * fields and making assignments to the appropriate fields of the object.\\n * Reading primitive data types is supported by DataInput.\\n *\\n * \u003cp\u003eAny attempt to read object data which exceeds the boundaries of the\\n * custom data written by the corresponding writeObject method will cause an\\n * OptionalDataException to be thrown with an eof field value of true.\\n * Non-object reads which exceed the end of the allotted data will reflect the\\n * end of data in the same way that they would indicate the end of the stream:\\n * bytewise reads will return -1 as the byte read or number of bytes read, and\\n * primitive reads will throw EOFExceptions.  If there is no corresponding\\n * writeObject method, then the end of default serialized data marks the end of\\n * the allotted data.\\n *\\n * \u003cp\u003ePrimitive and object read calls issued from within a readExternal method\\n * behave in the same manner--if the stream is already positioned at the end of\\n * data written by the corresponding writeExternal method, object reads will\\n * throw OptionalDataExceptions with eof set to true, bytewise reads will\\n * return -1, and primitive reads will throw EOFExceptions.  Note that this\\n * behavior does not hold for streams written with the old\\n * \u003ccode\u003eObjectStreamConstants.PROTOCOL_VERSION_1\u003c/code\u003e protocol, in which the\\n * end of data written by writeExternal methods is not demarcated, and hence\\n * cannot be detected.\\n *\\n * \u003cp\u003eThe readObjectNoData method is responsible for initializing the state of\\n * the object for its particular class in the event that the serialization\\n * stream does not list the given class as a superclass of the object being\\n * deserialized.  This may occur in cases where the receiving party uses a\\n * different version of the deserialized instance\\\u0027s class than the sending\\n * party, and the receiver\\\u0027s version extends classes that are not extended by\\n * the sender\\\u0027s version.  This may also occur if the serialization stream has\\n * been tampered; hence, readObjectNoData is useful for initializing\\n * deserialized objects properly despite a \"hostile\" or incomplete source\\n * stream.\\n *\\n * \u003cp\u003eSerialization does not read or assign values to the fields of any object\\n * that does not implement the java.io.Serializable interface.  Subclasses of\\n * Objects that are not serializable can be serializable. In this case the\\n * non-serializable class must have a no-arg constructor to allow its fields to\\n * be initialized.  In this case it is the responsibility of the subclass to\\n * save and restore the state of the non-serializable class. It is frequently\\n * the case that the fields of that class are accessible (public, package, or\\n * protected) or that there are get and set methods that can be used to restore\\n * the state.\\n *\\n * \u003cp\u003eAny exception that occurs while deserializing an object will be caught by\\n * the ObjectInputStream and abort the reading process.\\n *\\n * \u003cp\u003eImplementing the Externalizable interface allows the object to assume\\n * complete control over the contents and format of the object\\\u0027s serialized\\n * form.  The methods of the Externalizable interface, writeExternal and\\n * readExternal, are called to save and restore the objects state.  When\\n * implemented by a class they can write and read their own state using all of\\n * the methods of ObjectOutput and ObjectInput.  It is the responsibility of\\n * the objects to handle any versioning that occurs.\\n *\\n * \u003cp\u003eEnum constants are deserialized differently than ordinary serializable or\\n * externalizable objects.  The serialized form of an enum constant consists\\n * solely of its name; field values of the constant are not transmitted.  To\\n * deserialize an enum constant, ObjectInputStream reads the constant name from\\n * the stream; the deserialized constant is then obtained by calling the static\\n * method \u003ccode\u003eEnum.valueOf(Class, String)\u003c/code\u003e with the enum constant\\\u0027s\\n * base type and the received constant name as arguments.  Like other\\n * serializable or externalizable objects, enum constants can function as the\\n * targets of back references appearing subsequently in the serialization\\n * stream.  The process by which enum constants are deserialized cannot be\\n * customized: any class-specific readObject, readObjectNoData, and readResolve\\n * methods defined by enum types are ignored during deserialization.\\n * Similarly, any serialPersistentFields or serialVersionUID field declarations\\n * are also ignored--all enum types have a fixed serialVersionUID of 0L.\\n *\\n * @author      Mike Warres\\n * @author      Roger Riggs\\n * @see java.io.DataInput\\n * @see java.io.ObjectOutputStream\\n * @see java.io.Serializable\\n * @see \u003ca href=\"../../../platform/serialization/spec/input.html\"\u003e Object Serialization Specification, Section 3, Object Input Classes\u003c/a\u003e\\n * @since   JDK1.1\\n \u0027}"}, {"color": "#97c2fc", "id": "public final Object readObject() throws IOException, ClassNotFoundException", "label": "public final Object readObject() throws IOException, ClassNotFoundException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Read an object from the ObjectInputStream.  The class of the object, the\\n     * signature of the class, and the values of the non-transient and\\n     * non-static fields of the class and all of its supertypes are read.\\n     * Default deserializing for a class can be overridden using the writeObject\\n     * and readObject methods.  Objects referenced by this object are read\\n     * transitively so that a complete equivalent graph of objects is\\n     * reconstructed by readObject.\\n     *\\n     * \u003cp\u003eThe root object is completely restored when all of its fields and the\\n     * objects it references are completely restored.  At this point the object\\n     * validation callbacks are executed in order based on their registered\\n     * priorities. The callbacks are registered by objects (in the readObject\\n     * special methods) as they are individually restored.\\n     *\\n     * \u003cp\u003eExceptions are thrown for problems with the InputStream and for\\n     * classes that should not be deserialized.  All exceptions are fatal to\\n     * the InputStream and leave it in an indeterminate state; it is up to the\\n     * caller to ignore or recover the stream state.\\n     *\\n     * @throws  ClassNotFoundException Class of a serialized object cannot be\\n     *          found.\\n     * @throws  InvalidClassException Something is wrong with a class used by\\n     *          serialization.\\n     * @throws  StreamCorruptedException Control information in the\\n     *          stream is inconsistent.\\n     * @throws  OptionalDataException Primitive data was found in the\\n     *          stream instead of objects.\\n     * @throws  IOException Any of the usual Input/Output related exceptions.\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected Object readObjectOverride() throws IOException, ClassNotFoundException", "label": "protected Object readObjectOverride() throws IOException, ClassNotFoundException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * This method is called by trusted subclasses of ObjectOutputStream that\\n     * constructed ObjectOutputStream using the protected no-arg constructor.\\n     * The subclass is expected to provide an override method with the modifier\\n     * \"final\".\\n     *\\n     * @return  the Object read from the stream.\\n     * @throws  ClassNotFoundException Class definition of a serialized object\\n     *          cannot be found.\\n     * @throws  OptionalDataException Primitive data was found in the stream\\n     *          instead of objects.\\n     * @throws  IOException if I/O errors occurred while reading from the\\n     *          underlying stream\\n     * @see #ObjectInputStream()\\n     * @see #readObject()\\n     * @since 1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Object readUnshared() throws IOException, ClassNotFoundException", "label": "public Object readUnshared() throws IOException, ClassNotFoundException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads an \"unshared\" object from the ObjectInputStream.  This method is\\n     * identical to readObject, except that it prevents subsequent calls to\\n     * readObject and readUnshared from returning additional references to the\\n     * deserialized instance obtained via this call.  Specifically:\\n     * \u003cul\u003e\\n     *   \u003cli\u003eIf readUnshared is called to deserialize a back-reference (the\\n     *       stream representation of an object which has been written\\n     *       previously to the stream), an ObjectStreamException will be\\n     *       thrown.\\n     *\\n     *   \u003cli\u003eIf readUnshared returns successfully, then any subsequent attempts\\n     *       to deserialize back-references to the stream handle deserialized\\n     *       by readUnshared will cause an ObjectStreamException to be thrown.\\n     * \u003c/ul\u003e\\n     * Deserializing an object via readUnshared invalidates the stream handle\\n     * associated with the returned object.  Note that this in itself does not\\n     * always guarantee that the reference returned by readUnshared is unique;\\n     * the deserialized object may define a readResolve method which returns an\\n     * object visible to other parties, or readUnshared may return a Class\\n     * object or enum constant obtainable elsewhere in the stream or through\\n     * external means. If the deserialized object defines a readResolve method\\n     * and the invocation of that method returns an array, then readUnshared\\n     * returns a shallow clone of that array; this guarantees that the returned\\n     * array object is unique and cannot be obtained a second time from an\\n     * invocation of readObject or readUnshared on the ObjectInputStream,\\n     * even if the underlying data stream has been manipulated.\\n     *\\n     * \u003cp\u003eObjectInputStream subclasses which override this method can only be\\n     * constructed in security contexts possessing the\\n     * \"enableSubclassImplementation\" SerializablePermission; any attempt to\\n     * instantiate such a subclass without this permission will cause a\\n     * SecurityException to be thrown.\\n     *\\n     * @return  reference to deserialized object\\n     * @throws  ClassNotFoundException if class of an object to deserialize\\n     *          cannot be found\\n     * @throws  StreamCorruptedException if control information in the stream\\n     *          is inconsistent\\n     * @throws  ObjectStreamException if object to deserialize has already\\n     *          appeared in stream\\n     * @throws  OptionalDataException if primitive data is next in stream\\n     * @throws  IOException if an I/O error occurs during deserialization\\n     * @since   1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void defaultReadObject() throws IOException, ClassNotFoundException", "label": "public void defaultReadObject() throws IOException, ClassNotFoundException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Read the non-static and non-transient fields of the current class from\\n     * this stream.  This may only be called from the readObject method of the\\n     * class being deserialized. It will throw the NotActiveException if it is\\n     * called otherwise.\\n     *\\n     * @throws  ClassNotFoundException if the class of a serialized object\\n     *          could not be found.\\n     * @throws  IOException if an I/O error occurs.\\n     * @throws  NotActiveException if the stream is not currently reading\\n     *          objects.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public ObjectInputStream.GetField readFields() throws IOException, ClassNotFoundException", "label": "public ObjectInputStream.GetField readFields() throws IOException, ClassNotFoundException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads the persistent fields from the stream and makes them available by\\n     * name.\\n     *\\n     * @return  the \u003ccode\u003eGetField\u003c/code\u003e object representing the persistent\\n     *          fields of the object being deserialized\\n     * @throws  ClassNotFoundException if the class of a serialized object\\n     *          could not be found.\\n     * @throws  IOException if an I/O error occurs.\\n     * @throws  NotActiveException if the stream is not currently reading\\n     *          objects.\\n     * @since 1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void registerValidation(ObjectInputValidation obj, int prio) throws NotActiveException, InvalidObjectException", "label": "public void registerValidation(ObjectInputValidation obj, int prio) throws NotActiveException, InvalidObjectException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Register an object to be validated before the graph is returned.  While\\n     * similar to resolveObject these validations are called after the entire\\n     * graph has been reconstituted.  Typically, a readObject method will\\n     * register the object with the stream so that when all of the objects are\\n     * restored a final set of validations can be performed.\\n     *\\n     * @param   obj the object to receive the validation callback.\\n     * @param   prio controls the order of callbacks;zero is a good default.\\n     *          Use higher numbers to be called back earlier, lower numbers for\\n     *          later callbacks. Within a priority, callbacks are processed in\\n     *          no particular order.\\n     * @throws  NotActiveException The stream is not currently reading objects\\n     *          so it is invalid to register a callback.\\n     * @throws  InvalidObjectException The validation object is null.\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected Class\u003c?\u003e resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException", "label": "protected Class\u003c?\u003e resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Load the local class equivalent of the specified stream class\\n     * description.  Subclasses may implement this method to allow classes to\\n     * be fetched from an alternate source.\\n     *\\n     * \u003cp\u003eThe corresponding method in \u003ccode\u003eObjectOutputStream\u003c/code\u003e is\\n     * \u003ccode\u003eannotateClass\u003c/code\u003e.  This method will be invoked only once for\\n     * each unique class in the stream.  This method can be implemented by\\n     * subclasses to use an alternate loading mechanism but must return a\\n     * \u003ccode\u003eClass\u003c/code\u003e object. Once returned, if the class is not an array\\n     * class, its serialVersionUID is compared to the serialVersionUID of the\\n     * serialized class, and if there is a mismatch, the deserialization fails\\n     * and an {@link InvalidClassException} is thrown.\\n     *\\n     * \u003cp\u003eThe default implementation of this method in\\n     * \u003ccode\u003eObjectInputStream\u003c/code\u003e returns the result of calling\\n     * \u003cpre\u003e\\n     *     Class.forName(desc.getName(), false, loader)\\n     * \u003c/pre\u003e\\n     * where \u003ccode\u003eloader\u003c/code\u003e is determined as follows: if there is a\\n     * method on the current thread\\\u0027s stack whose declaring class was\\n     * defined by a user-defined class loader (and was not a generated to\\n     * implement reflective invocations), then \u003ccode\u003eloader\u003c/code\u003e is class\\n     * loader corresponding to the closest such method to the currently\\n     * executing frame; otherwise, \u003ccode\u003eloader\u003c/code\u003e is\\n     * \u003ccode\u003enull\u003c/code\u003e. If this call results in a\\n     * \u003ccode\u003eClassNotFoundException\u003c/code\u003e and the name of the passed\\n     * \u003ccode\u003eObjectStreamClass\u003c/code\u003e instance is the Java language keyword\\n     * for a primitive type or void, then the \u003ccode\u003eClass\u003c/code\u003e object\\n     * representing that primitive type or void will be returned\\n     * (e.g., an \u003ccode\u003eObjectStreamClass\u003c/code\u003e with the name\\n     * \u003ccode\u003e\"int\"\u003c/code\u003e will be resolved to \u003ccode\u003eInteger.TYPE\u003c/code\u003e).\\n     * Otherwise, the \u003ccode\u003eClassNotFoundException\u003c/code\u003e will be thrown to\\n     * the caller of this method.\\n     *\\n     * @param   desc an instance of class \u003ccode\u003eObjectStreamClass\u003c/code\u003e\\n     * @return  a \u003ccode\u003eClass\u003c/code\u003e object corresponding to \u003ccode\u003edesc\u003c/code\u003e\\n     * @throws  IOException any of the usual Input/Output exceptions.\\n     * @throws  ClassNotFoundException if class of a serialized object cannot\\n     *          be found.\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.io.InvalidClassException", "label": "java.io.InvalidClassException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Thrown when the Serialization runtime detects one of the following\\n * problems with a Class.\\n * \u003cUL\u003e\\n * \u003cLI\u003e The serial version of the class does not match that of the class\\n *      descriptor read from the stream\\n * \u003cLI\u003e The class contains unknown datatypes\\n * \u003cLI\u003e The class does not have an accessible no-arg constructor\\n * \u003cLI\u003e The ObjectStreamClass of an enum constant does not represent\\n *      an enum type\\n * \u003cLI\u003e Other conditions given in the \u003ccite\u003eJava Object Serialization\\n *      Specification\u003c/cite\u003e\\n * \u003c/UL\u003e\\n *\\n * @since   1.1\\n \u0027}"}, {"color": "#97c2fc", "id": "protected Class\u003c?\u003e resolveProxyClass(String[] interfaces) throws IOException, ClassNotFoundException", "label": "protected Class\u003c?\u003e resolveProxyClass(String[] interfaces) throws IOException, ClassNotFoundException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a proxy class that implements the interfaces named in a proxy\\n     * class descriptor; subclasses may implement this method to read custom\\n     * data from the stream along with the descriptors for dynamic proxy\\n     * classes, allowing them to use an alternate loading mechanism for the\\n     * interfaces and the proxy class.\\n     *\\n     * \u003cp\u003eThis method is called exactly once for each unique proxy class\\n     * descriptor in the stream.\\n     *\\n     * \u003cp\u003eThe corresponding method in \u003ccode\u003eObjectOutputStream\u003c/code\u003e is\\n     * \u003ccode\u003eannotateProxyClass\u003c/code\u003e.  For a given subclass of\\n     * \u003ccode\u003eObjectInputStream\u003c/code\u003e that overrides this method, the\\n     * \u003ccode\u003eannotateProxyClass\u003c/code\u003e method in the corresponding subclass of\\n     * \u003ccode\u003eObjectOutputStream\u003c/code\u003e must write any data or objects read by\\n     * this method.\\n     *\\n     * \u003cp\u003eThe default implementation of this method in\\n     * \u003ccode\u003eObjectInputStream\u003c/code\u003e returns the result of calling\\n     * \u003ccode\u003eProxy.getProxyClass\u003c/code\u003e with the list of \u003ccode\u003eClass\u003c/code\u003e\\n     * objects for the interfaces that are named in the \u003ccode\u003einterfaces\u003c/code\u003e\\n     * parameter.  The \u003ccode\u003eClass\u003c/code\u003e object for each interface name\\n     * \u003ccode\u003ei\u003c/code\u003e is the value returned by calling\\n     * \u003cpre\u003e\\n     *     Class.forName(i, false, loader)\\n     * \u003c/pre\u003e\\n     * where \u003ccode\u003eloader\u003c/code\u003e is that of the first non-\u003ccode\u003enull\u003c/code\u003e\\n     * class loader up the execution stack, or \u003ccode\u003enull\u003c/code\u003e if no\\n     * non-\u003ccode\u003enull\u003c/code\u003e class loaders are on the stack (the same class\\n     * loader choice used by the \u003ccode\u003eresolveClass\u003c/code\u003e method).  Unless any\\n     * of the resolved interfaces are non-public, this same value of\\n     * \u003ccode\u003eloader\u003c/code\u003e is also the class loader passed to\\n     * \u003ccode\u003eProxy.getProxyClass\u003c/code\u003e; if non-public interfaces are present,\\n     * their class loader is passed instead (if more than one non-public\\n     * interface class loader is encountered, an\\n     * \u003ccode\u003eIllegalAccessError\u003c/code\u003e is thrown).\\n     * If \u003ccode\u003eProxy.getProxyClass\u003c/code\u003e throws an\\n     * \u003ccode\u003eIllegalArgumentException\u003c/code\u003e, \u003ccode\u003eresolveProxyClass\u003c/code\u003e\\n     * will throw a \u003ccode\u003eClassNotFoundException\u003c/code\u003e containing the\\n     * \u003ccode\u003eIllegalArgumentException\u003c/code\u003e.\\n     *\\n     * @param interfaces the list of interface names that were\\n     *                deserialized in the proxy class descriptor\\n     * @return  a proxy class for the specified interfaces\\n     * @throws        IOException any exception thrown by the underlying\\n     *                \u003ccode\u003eInputStream\u003c/code\u003e\\n     * @throws        ClassNotFoundException if the proxy class or any of the\\n     *                named interfaces could not be found\\n     * @see ObjectOutputStream#annotateProxyClass(Class)\\n     * @since 1.3\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected Object resolveObject(Object obj) throws IOException", "label": "protected Object resolveObject(Object obj) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * This method will allow trusted subclasses of ObjectInputStream to\\n     * substitute one object for another during deserialization. Replacing\\n     * objects is disabled until enableResolveObject is called. The\\n     * enableResolveObject method checks that the stream requesting to resolve\\n     * object can be trusted. Every reference to serializable objects is passed\\n     * to resolveObject.  To insure that the private state of objects is not\\n     * unintentionally exposed only trusted streams may use resolveObject.\\n     *\\n     * \u003cp\u003eThis method is called after an object has been read but before it is\\n     * returned from readObject.  The default resolveObject method just returns\\n     * the same object.\\n     *\\n     * \u003cp\u003eWhen a subclass is replacing objects it must insure that the\\n     * substituted object is compatible with every field where the reference\\n     * will be stored.  Objects whose type is not a subclass of the type of the\\n     * field or array element abort the serialization by raising an exception\\n     * and the object is not be stored.\\n     *\\n     * \u003cp\u003eThis method is called only once when each object is first\\n     * encountered.  All subsequent references to the object will be redirected\\n     * to the new object.\\n     *\\n     * @param   obj object to be substituted\\n     * @return  the substituted object\\n     * @throws  IOException Any of the usual Input/Output exceptions.\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected boolean enableResolveObject(boolean enable) throws SecurityException", "label": "protected boolean enableResolveObject(boolean enable) throws SecurityException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Enable the stream to allow objects read from the stream to be replaced.\\n     * When enabled, the resolveObject method is called for every object being\\n     * deserialized.\\n     *\\n     * \u003cp\u003eIf \u003ci\u003eenable\u003c/i\u003e is true, and there is a security manager installed,\\n     * this method first calls the security manager\\\u0027s\\n     * \u003ccode\u003echeckPermission\u003c/code\u003e method with the\\n     * \u003ccode\u003eSerializablePermission(\"enableSubstitution\")\u003c/code\u003e permission to\\n     * ensure it\\\u0027s ok to enable the stream to allow objects read from the\\n     * stream to be replaced.\\n     *\\n     * @param   enable true for enabling use of \u003ccode\u003eresolveObject\u003c/code\u003e for\\n     *          every object being deserialized\\n     * @return  the previous setting before this method was invoked\\n     * @throws  SecurityException if a security manager exists and its\\n     *          \u003ccode\u003echeckPermission\u003c/code\u003e method denies enabling the stream\\n     *          to allow objects read from the stream to be replaced.\\n     * @see SecurityManager#checkPermission\\n     * @see java.io.SerializablePermission\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected void readStreamHeader() throws IOException, StreamCorruptedException", "label": "protected void readStreamHeader() throws IOException, StreamCorruptedException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * The readStreamHeader method is provided to allow subclasses to read and\\n     * verify their own stream headers. It reads and verifies the magic number\\n     * and version number.\\n     *\\n     * @throws  IOException if there are I/O errors while reading from the\\n     *          underlying \u003ccode\u003eInputStream\u003c/code\u003e\\n     * @throws  StreamCorruptedException if control information in the stream\\n     *          is inconsistent\\n     \u0027}"}, {"color": "#97c2fc", "id": "protected ObjectStreamClass readClassDescriptor() throws IOException, ClassNotFoundException", "label": "protected ObjectStreamClass readClassDescriptor() throws IOException, ClassNotFoundException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Read a class descriptor from the serialization stream.  This method is\\n     * called when the ObjectInputStream expects a class descriptor as the next\\n     * item in the serialization stream.  Subclasses of ObjectInputStream may\\n     * override this method to read in class descriptors that have been written\\n     * in non-standard formats (by subclasses of ObjectOutputStream which have\\n     * overridden the \u003ccode\u003ewriteClassDescriptor\u003c/code\u003e method).  By default,\\n     * this method reads class descriptors according to the format defined in\\n     * the Object Serialization specification.\\n     *\\n     * @return  the class descriptor read\\n     * @throws  IOException If an I/O error has occurred.\\n     * @throws  ClassNotFoundException If the Class of a serialized object used\\n     *          in the class descriptor representation cannot be found\\n     * @see java.io.ObjectOutputStream#writeClassDescriptor(java.io.ObjectStreamClass)\\n     * @since 1.3\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int read(byte[] buf, int off, int len) throws IOException", "label": "public int read(byte[] buf, int off, int len) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reads into an array of bytes.  This method will block until some input\\n     * is available. Consider using java.io.DataInputStream.readFully to read\\n     * exactly \u0027length\u0027 bytes.\\n     *\\n     * @param   buf the buffer into which the data is read\\n     * @param   off the start offset of the data\\n     * @param   len the maximum number of bytes read\\n     * @return  the actual number of bytes read, -1 is returned when the end of\\n     *          the stream is reached.\\n     * @throws  IOException If an I/O error has occurred.\\n     * @see java.io.DataInputStream#readFully(byte[],int,int)\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean readBoolean() throws IOException", "label": "public boolean readBoolean() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads in a boolean.\\n     *\\n     * @return  the boolean read.\\n     * @throws  EOFException If end of file is reached.\\n     * @throws  IOException If other I/O error has occurred.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public byte readByte() throws IOException", "label": "public byte readByte() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads an 8 bit byte.\\n     *\\n     * @return  the 8 bit byte read.\\n     * @throws  EOFException If end of file is reached.\\n     * @throws  IOException If other I/O error has occurred.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int readUnsignedByte() throws IOException", "label": "public int readUnsignedByte() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads an unsigned 8 bit byte.\\n     *\\n     * @return  the 8 bit byte read.\\n     * @throws  EOFException If end of file is reached.\\n     * @throws  IOException If other I/O error has occurred.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public char readChar() throws IOException", "label": "public char readChar() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads a 16 bit char.\\n     *\\n     * @return  the 16 bit char read.\\n     * @throws  EOFException If end of file is reached.\\n     * @throws  IOException If other I/O error has occurred.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public short readShort() throws IOException", "label": "public short readShort() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads a 16 bit short.\\n     *\\n     * @return  the 16 bit short read.\\n     * @throws  EOFException If end of file is reached.\\n     * @throws  IOException If other I/O error has occurred.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int readUnsignedShort() throws IOException", "label": "public int readUnsignedShort() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads an unsigned 16 bit short.\\n     *\\n     * @return  the 16 bit short read.\\n     * @throws  EOFException If end of file is reached.\\n     * @throws  IOException If other I/O error has occurred.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int readInt() throws IOException", "label": "public int readInt() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads a 32 bit int.\\n     *\\n     * @return  the 32 bit integer read.\\n     * @throws  EOFException If end of file is reached.\\n     * @throws  IOException If other I/O error has occurred.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public long readLong() throws IOException", "label": "public long readLong() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads a 64 bit long.\\n     *\\n     * @return  the read 64 bit long.\\n     * @throws  EOFException If end of file is reached.\\n     * @throws  IOException If other I/O error has occurred.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public float readFloat() throws IOException", "label": "public float readFloat() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads a 32 bit float.\\n     *\\n     * @return  the 32 bit float read.\\n     * @throws  EOFException If end of file is reached.\\n     * @throws  IOException If other I/O error has occurred.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public double readDouble() throws IOException", "label": "public double readDouble() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads a 64 bit double.\\n     *\\n     * @return  the 64 bit double read.\\n     * @throws  EOFException If end of file is reached.\\n     * @throws  IOException If other I/O error has occurred.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void readFully(byte[] buf) throws IOException", "label": "public void readFully(byte[] buf) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads bytes, blocking until all bytes are read.\\n     *\\n     * @param   buf the buffer into which the data is read\\n     * @throws  EOFException If end of file is reached.\\n     * @throws  IOException If other I/O error has occurred.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void readFully(byte[] buf, int off, int len) throws IOException", "label": "public void readFully(byte[] buf, int off, int len) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads bytes, blocking until all bytes are read.\\n     *\\n     * @param   buf the buffer into which the data is read\\n     * @param   off the start offset of the data\\n     * @param   len the maximum number of bytes to read\\n     * @throws  EOFException If end of file is reached.\\n     * @throws  IOException If other I/O error has occurred.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int skipBytes(int len) throws IOException", "label": "public int skipBytes(int len) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Skips bytes.\\n     *\\n     * @param   len the number of bytes to be skipped\\n     * @return  the actual number of bytes skipped.\\n     * @throws  IOException If an I/O error has occurred.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public String readUTF() throws IOException", "label": "public String readUTF() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads a String in\\n     * \u003ca href=\"DataInput.html#modified-utf-8\"\u003emodified UTF-8\u003c/a\u003e\\n     * format.\\n     *\\n     * @return  the String.\\n     * @throws  IOException if there are I/O errors while reading from the\\n     *          underlying \u003ccode\u003eInputStream\u003c/code\u003e\\n     * @throws  UTFDataFormatException if read bytes do not represent a valid\\n     *          modified UTF-8 encoding of a string\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void checkArray(Class\u003c?\u003e arrayType, int arrayLength) throws InvalidClassException", "label": "private void checkArray(Class\u003c?\u003e arrayType, int arrayLength) throws InvalidClassException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Checks the given array type and length to ensure that creation of such\\n     * an array is permitted by this ObjectInputStream. The arrayType argument\\n     * must represent an actual array type.\\n     *\\n     * This private method is called via SharedSecrets.\\n     *\\n     * @param arrayType the array type\\n     * @param arrayLength the array length\\n     * @throws NullPointerException if arrayType is null\\n     * @throws IllegalArgumentException if arrayType isn\u0027t actually an array type\\n     * @throws NegativeArraySizeException if arrayLength is negative\\n     * @throws InvalidClassException if the filter rejects creation\\n     \"}"}, {"color": "#97c2fc", "id": "private Object readObject0(boolean unshared) throws IOException", "label": "private Object readObject0(boolean unshared) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Underlying readObject implementation.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private Object checkResolve(Object obj) throws IOException", "label": "private Object checkResolve(Object obj) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * If resolveObject has been enabled and given object does not have an\\n     * exception associated with it, calls resolveObject to determine\\n     * replacement for object, and updates handle table accordingly.  Returns\\n     * replacement object, or echoes provided object if no replacement\\n     * occurred.  Expects that passHandle is set to given object\u0027s handle prior\\n     * to calling this method.\\n     \"}"}, {"color": "#97c2fc", "id": " String readTypeString() throws IOException", "label": " String readTypeString() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads string without allowing it to be replaced in stream.  Called from\\n     * within ObjectStreamClass.read().\\n     \u0027}"}, {"color": "#97c2fc", "id": "private Object readNull() throws IOException", "label": "private Object readNull() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads in null code, sets passHandle to NULL_HANDLE and returns null.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private Object readHandle(boolean unshared) throws IOException", "label": "private Object readHandle(boolean unshared) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads in object handle, sets passHandle to the read handle, and returns\\n     * object associated with the handle.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private Class\u003c?\u003e readClass(boolean unshared) throws IOException", "label": "private Class\u003c?\u003e readClass(boolean unshared) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reads in and returns class object.  Sets passHandle to class object\u0027s\\n     * assigned handle.  Returns null if class is unresolvable (in which case a\\n     * ClassNotFoundException will be associated with the class\u0027 handle in the\\n     * handle table).\\n     \"}"}, {"color": "#97c2fc", "id": "private ObjectStreamClass readClassDesc(boolean unshared) throws IOException", "label": "private ObjectStreamClass readClassDesc(boolean unshared) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reads in and returns (possibly null) class descriptor.  Sets passHandle\\n     * to class descriptor\u0027s assigned handle.  If class descriptor cannot be\\n     * resolved to a class in the local VM, a ClassNotFoundException is\\n     * associated with the class descriptor\u0027s handle.\\n     \"}"}, {"color": "#97c2fc", "id": "private ObjectStreamClass readProxyDesc(boolean unshared) throws IOException", "label": "private ObjectStreamClass readProxyDesc(boolean unshared) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reads in and returns class descriptor for a dynamic proxy class.  Sets\\n     * passHandle to proxy class descriptor\u0027s assigned handle.  If proxy class\\n     * descriptor cannot be resolved to a class in the local VM, a\\n     * ClassNotFoundException is associated with the descriptor\u0027s handle.\\n     \"}"}, {"color": "#97c2fc", "id": "private ObjectStreamClass readNonProxyDesc(boolean unshared) throws IOException", "label": "private ObjectStreamClass readNonProxyDesc(boolean unshared) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reads in and returns class descriptor for a class that is not a dynamic\\n     * proxy class.  Sets passHandle to class descriptor\u0027s assigned handle.  If\\n     * class descriptor cannot be resolved to a class in the local VM, a\\n     * ClassNotFoundException is associated with the descriptor\u0027s handle.\\n     \"}"}, {"color": "#97c2fc", "id": "private String readString(boolean unshared) throws IOException", "label": "private String readString(boolean unshared) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reads in and returns new string.  Sets passHandle to new string\u0027s\\n     * assigned handle.\\n     \"}"}, {"color": "#97c2fc", "id": "private Object readArray(boolean unshared) throws IOException", "label": "private Object readArray(boolean unshared) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reads in and returns array object, or null if array class is\\n     * unresolvable.  Sets passHandle to array\u0027s assigned handle.\\n     \"}"}, {"color": "#97c2fc", "id": "private Enum\u003c?\u003e readEnum(boolean unshared) throws IOException", "label": "private Enum\u003c?\u003e readEnum(boolean unshared) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reads in and returns enum constant, or null if enum type is\\n     * unresolvable.  Sets passHandle to enum constant\u0027s assigned handle.\\n     \"}"}, {"color": "#97c2fc", "id": "private Object readOrdinaryObject(boolean unshared) throws IOException", "label": "private Object readOrdinaryObject(boolean unshared) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads and returns \"ordinary\" (i.e., not a String, Class,\\n     * ObjectStreamClass, array, or enum constant) object, or null if object\\\u0027s\\n     * class is unresolvable (in which case a ClassNotFoundException will be\\n     * associated with object\\\u0027s handle).  Sets passHandle to object\\\u0027s assigned\\n     * handle.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void readExternalData(Externalizable obj, ObjectStreamClass desc) throws IOException", "label": "private void readExternalData(Externalizable obj, ObjectStreamClass desc) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * If obj is non-null, reads externalizable data by invoking readExternal()\\n     * method of obj; otherwise, attempts to skip over externalizable data.\\n     * Expects that passHandle is set to obj\u0027s handle before this method is\\n     * called.\\n     \"}"}, {"color": "#97c2fc", "id": "private Object readRecord(ObjectStreamClass desc) throws IOException", "label": "private Object readRecord(ObjectStreamClass desc) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Reads a record. \u0027}"}, {"color": "#97c2fc", "id": "private void readSerialData(Object obj, ObjectStreamClass desc) throws IOException", "label": "private void readSerialData(Object obj, ObjectStreamClass desc) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reads (or attempts to skip, if obj is null or is tagged with a\\n     * ClassNotFoundException) instance data for each serializable class of\\n     * object in stream, from superclass to subclass.  Expects that passHandle\\n     * is set to obj\u0027s handle before this method is called.\\n     \"}"}, {"color": "#97c2fc", "id": "private void skipCustomData() throws IOException", "label": "private void skipCustomData() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Skips over all block data and objects until TC_ENDBLOCKDATA is\\n     * encountered.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void defaultReadFields(Object obj, ObjectStreamClass desc) throws IOException", "label": "private void defaultReadFields(Object obj, ObjectStreamClass desc) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reads in values of serializable fields declared by given class\\n     * descriptor.  If obj is non-null, sets field values in obj.  Expects that\\n     * passHandle is set to obj\u0027s handle before this method is called.\\n     \"}"}, {"color": "#97c2fc", "id": "private IOException readFatalException() throws IOException", "label": "private IOException readFatalException() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reads in and returns IOException that caused serialization to abort.\\n     * All stream state is discarded prior to reading in fatal exception.  Sets\\n     * passHandle to fatal exception\u0027s handle.\\n     \"}"}, {"color": "#97c2fc", "id": "private void handleReset() throws StreamCorruptedException", "label": "private void handleReset() throws StreamCorruptedException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * If recursion depth is 0, clears internal data structures; otherwise,\\n     * throws a StreamCorruptedException.  This method is called when a\\n     * TC_RESET typecode is encountered.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static native void bytesToFloats(byte[] src, int srcpos, float[] dst, int dstpos, int nfloats)", "label": "private static native void bytesToFloats(byte[] src, int srcpos, float[] dst, int dstpos, int nfloats)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 REMIND: remove once hotspot inlines Float.intBitsToFloat\u0027}"}, {"color": "#97c2fc", "id": "private static native void bytesToDoubles(byte[] src, int srcpos, double[] dst, int dstpos, int ndoubles)", "label": "private static native void bytesToDoubles(byte[] src, int srcpos, double[] dst, int dstpos, int ndoubles)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 REMIND: remove once hotspot inlines Double.longBitsToDouble\u0027}"}, {"color": "#97c2fc", "id": "private static ClassLoader latestUserDefinedLoader()", "label": "private static ClassLoader latestUserDefinedLoader()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the first non-null class loader (not counting class loaders of\\n     * generated reflection implementation classes) up the execution stack, or\\n     * null if only code from the null class loader is on the stack.  This\\n     * method is also called via reflection by the following RMI-IIOP class:\\n     *\\n     *     com.sun.corba.se.internal.util.JDKClassLoader\\n     *\\n     * This method should not be removed or its signature changed without\\n     * corresponding modifications to the above class.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static Object cloneArray(Object array)", "label": "private static Object cloneArray(Object array)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Method for cloning arrays in case of using unsharing reading\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static int toLower(char c)", "label": "private static int toLower(char c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 US-ASCII only\u0027}"}, {"color": "#97c2fc", "id": "private static int toUpper(char c)", "label": "private static int toUpper(char c)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 US-ASCII only\u0027}"}, {"color": "#97c2fc", "id": "private static boolean equalIgnoringCase(String s, String t)", "label": "private static boolean equalIgnoringCase(String s, String t)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 US-ASCII only\u0027}"}, {"color": "#97c2fc", "id": "private static int hashIgnoringCase(int hash, String s)", "label": "private static int hashIgnoringCase(int hash, String s)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 US-ASCII only\u0027}"}, {"color": "#97c2fc", "id": "private static int compareIgnoringCase(String s, String t)", "label": "private static int compareIgnoringCase(String s, String t)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 US-ASCII only\u0027}"}, {"color": "#97c2fc", "id": "private static String resolvePath(String base, String child, boolean absolute)", "label": "private static String resolvePath(String base, String child, boolean absolute)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 RFC2396 5.2 (6)\u0027}"}, {"color": "#97c2fc", "id": "private static URI resolve(URI base, URI child)", "label": "private static URI resolve(URI base, URI child)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 RFC2396 5.2\u0027}"}, {"color": "#97c2fc", "id": "private static void removeDots(char[] path, int[] segs, boolean removeLeading)", "label": "private static void removeDots(char[] path, int[] segs, boolean removeLeading)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 private static void removeDots(char[] path, int[] segs) {\u0027}"}, {"color": "#97c2fc", "id": "private static long lowMask(String chars)", "label": "private static long lowMask(String chars)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Compute the low-order mask for the characters in the given string\u0027}"}, {"color": "#97c2fc", "id": "private static long highMask(String chars)", "label": "private static long highMask(String chars)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Compute the high-order mask for the characters in the given string\u0027}"}, {"color": "#97c2fc", "id": "private static long lowMask(char first, char last)", "label": "private static long lowMask(char first, char last)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 between first and last, inclusive\u0027}"}, {"color": "#97c2fc", "id": "private static long highMask(char first, char last)", "label": "private static long highMask(char first, char last)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 between first and last, inclusive\u0027}"}, {"color": "#97c2fc", "id": "private static boolean match(char c, long lowMask, long highMask)", "label": "private static boolean match(char c, long lowMask, long highMask)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027 Tell whether the given character is permitted by the given mask pair\u0027}"}, {"color": "#97c2fc", "id": "public FileSystem newFileSystem(Path path, Map\u003cString, ?\u003e env) throws IOException", "label": "public FileSystem newFileSystem(Path path, Map\u003cString, ?\u003e env) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Constructs a new {@code FileSystem} to access the contents of a file as a\\n     * file system.\\n     *\\n     * \u003cp\u003e This method is intended for specialized providers of pseudo file\\n     * systems where the contents of one or more files is treated as a file\\n     * system. The {@code env} parameter is a map of provider specific properties\\n     * to configure the file system.\\n     *\\n     * \u003cp\u003e If this provider does not support the creation of such file systems\\n     * or if the provider does not recognize the file type of the given file then\\n     * it throws {@code UnsupportedOperationException}. The default implementation\\n     * of this method throws {@code UnsupportedOperationException}.\\n     *\\n     * @param   path\\n     *          The path to the file\\n     * @param   env\\n     *          A map of provider specific properties to configure the file system;\\n     *          may be empty\\n     *\\n     * @return  A new file system\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          If this provider does not support access to the contents as a\\n     *          file system or it does not recognize the file type of the\\n     *          given file\\n     * @throws  IllegalArgumentException\\n     *          If the {@code env} parameter does not contain properties required\\n     *          by the provider, or a property value is invalid\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     * @throws  SecurityException\\n     *          If a security manager is installed and it denies an unspecified\\n     *          permission.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public InputStream newInputStream(Path path, OpenOption... options) throws IOException", "label": "public InputStream newInputStream(Path path, OpenOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens a file, returning an input stream to read from the file. This\\n     * method works in exactly the manner specified by the {@link\\n     * Files#newInputStream} method.\\n     *\\n     * \u003cp\u003e The default implementation of this method opens a channel to the file\\n     * as if by invoking the {@link #newByteChannel} method and constructs a\\n     * stream that reads bytes from the channel. This method should be overridden\\n     * where appropriate.\\n     *\\n     * @param   path\\n     *          the path to the file to open\\n     * @param   options\\n     *          options specifying how the file is opened\\n     *\\n     * @return  a new input stream\\n     *\\n     * @throws  IllegalArgumentException\\n     *          if an invalid combination of options is specified\\n     * @throws  UnsupportedOperationException\\n     *          if an unsupported option is specified\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "newInputStream", "label": "newInputStream", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "newByteChannel", "label": "newByteChannel", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public OutputStream newOutputStream(Path path, OpenOption... options) throws IOException", "label": "public OutputStream newOutputStream(Path path, OpenOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens or creates a file, returning an output stream that may be used to\\n     * write bytes to the file. This method works in exactly the manner\\n     * specified by the {@link Files#newOutputStream} method.\\n     *\\n     * \u003cp\u003e The default implementation of this method opens a channel to the file\\n     * as if by invoking the {@link #newByteChannel} method and constructs a\\n     * stream that writes bytes to the channel. This method should be overridden\\n     * where appropriate.\\n     *\\n     * @param   path\\n     *          the path to the file to open or create\\n     * @param   options\\n     *          options specifying how the file is opened\\n     *\\n     * @return  a new output stream\\n     *\\n     * @throws  IllegalArgumentException\\n     *          if {@code options} contains an invalid combination of options\\n     * @throws  UnsupportedOperationException\\n     *          if an unsupported option is specified\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method is invoked to check write access to the file. The {@link\\n     *          SecurityManager#checkDelete(String) checkDelete} method is\\n     *          invoked to check delete access if the file is opened with the\\n     *          {@code DELETE_ON_CLOSE} option.\\n     \u0027}"}, {"color": "#97c2fc", "id": "newOutputStream", "label": "newOutputStream", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public FileChannel newFileChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "label": "public FileChannel newFileChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens or creates a file for reading and/or writing, returning a file\\n     * channel to access the file. This method works in exactly the manner\\n     * specified by the {@link FileChannel#open(Path,Set,FileAttribute[])\\n     * FileChannel.open} method. A provider that does not support all the\\n     * features required to construct a file channel throws {@code\\n     * UnsupportedOperationException}. The default provider is required to\\n     * support the creation of file channels. When not overridden, the default\\n     * implementation throws {@code UnsupportedOperationException}.\\n     *\\n     * @param   path\\n     *          the path of the file to open or create\\n     * @param   options\\n     *          options specifying how the file is opened\\n     * @param   attrs\\n     *          an optional list of file attributes to set atomically when\\n     *          creating the file\\n     *\\n     * @return  a new file channel\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the set contains an invalid combination of options\\n     * @throws  UnsupportedOperationException\\n     *          If this provider that does not support creating file channels,\\n     *          or an unsupported open option or file attribute is specified\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default file system, the {@link\\n     *          SecurityManager#checkRead(String)} method is invoked to check\\n     *          read access if the file is opened for reading. The {@link\\n     *          SecurityManager#checkWrite(String)} method is invoked to check\\n     *          write access if the file is opened for writing\\n     \u0027}"}, {"color": "#97c2fc", "id": "public AsynchronousFileChannel newAsynchronousFileChannel(Path path, Set\u003c? extends OpenOption\u003e options, ExecutorService executor, FileAttribute\u003c?\u003e... attrs) throws IOException", "label": "public AsynchronousFileChannel newAsynchronousFileChannel(Path path, Set\u003c? extends OpenOption\u003e options, ExecutorService executor, FileAttribute\u003c?\u003e... attrs) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens or creates a file for reading and/or writing, returning an\\n     * asynchronous file channel to access the file. This method works in\\n     * exactly the manner specified by the {@link\\n     * AsynchronousFileChannel#open(Path,Set,ExecutorService,FileAttribute[])\\n     * AsynchronousFileChannel.open} method.\\n     * A provider that does not support all the features required to construct\\n     * an asynchronous file channel throws {@code UnsupportedOperationException}.\\n     * The default provider is required to support the creation of asynchronous\\n     * file channels. When not overridden, the default implementation of this\\n     * method throws {@code UnsupportedOperationException}.\\n     *\\n     * @param   path\\n     *          the path of the file to open or create\\n     * @param   options\\n     *          options specifying how the file is opened\\n     * @param   executor\\n     *          the thread pool or {@code null} to associate the channel with\\n     *          the default thread pool\\n     * @param   attrs\\n     *          an optional list of file attributes to set atomically when\\n     *          creating the file\\n     *\\n     * @return  a new asynchronous file channel\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the set contains an invalid combination of options\\n     * @throws  UnsupportedOperationException\\n     *          If this provider that does not support creating asynchronous file\\n     *          channels, or an unsupported open option or file attribute is\\n     *          specified\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default file system, the {@link\\n     *          SecurityManager#checkRead(String)} method is invoked to check\\n     *          read access if the file is opened for reading. The {@link\\n     *          SecurityManager#checkWrite(String)} method is invoked to check\\n     *          write access if the file is opened for writing\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "label": "public abstract SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens or creates a file, returning a seekable byte channel to access the\\n     * file. This method works in exactly the manner specified by the {@link\\n     * Files#newByteChannel(Path,Set,FileAttribute[])} method.\\n     *\\n     * @param   path\\n     *          the path to the file to open or create\\n     * @param   options\\n     *          options specifying how the file is opened\\n     * @param   attrs\\n     *          an optional list of file attributes to set atomically when\\n     *          creating the file\\n     *\\n     * @return  a new seekable byte channel\\n     *\\n     * @throws  IllegalArgumentException\\n     *          if the set contains an invalid combination of options\\n     * @throws  UnsupportedOperationException\\n     *          if an unsupported open option is specified or the array contains\\n     *          attributes that cannot be set atomically when creating the file\\n     * @throws  FileAlreadyExistsException\\n     *          if a file of that name already exists and the {@link\\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the path if the file is\\n     *          opened for reading. The {@link SecurityManager#checkWrite(String)\\n     *          checkWrite} method is invoked to check write access to the path\\n     *          if the file is opened for writing. The {@link\\n     *          SecurityManager#checkDelete(String) checkDelete} method is\\n     *          invoked to check delete access if the file is opened with the\\n     *          {@code DELETE_ON_CLOSE} option.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, DirectoryStream.Filter\u003c? super Path\u003e filter) throws IOException", "label": "public abstract DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, DirectoryStream.Filter\u003c? super Path\u003e filter) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Opens a directory, returning a {@code DirectoryStream} to iterate over\\n     * the entries in the directory. This method works in exactly the manner\\n     * specified by the {@link\\n     * Files#newDirectoryStream(java.nio.file.Path, java.nio.file.DirectoryStream.Filter)}\\n     * method.\\n     *\\n     * @param   dir\\n     *          the path to the directory\\n     * @param   filter\\n     *          the directory stream filter\\n     *\\n     * @return  a new and open {@code DirectoryStream} object\\n     *\\n     * @throws  NotDirectoryException\\n     *          if the file could not otherwise be opened because it is not\\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the directory.\\n     \u0027}"}, {"color": "#97c2fc", "id": "newDirectoryStream(java.nio.file.Path", "label": "newDirectoryStream(java.nio.file.Path", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract void createDirectory(Path dir, FileAttribute\u003c?\u003e... attrs) throws IOException", "label": "public abstract void createDirectory(Path dir, FileAttribute\u003c?\u003e... attrs) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a new directory. This method works in exactly the manner\\n     * specified by the {@link Files#createDirectory} method.\\n     *\\n     * @param   dir\\n     *          the directory to create\\n     * @param   attrs\\n     *          an optional list of file attributes to set atomically when\\n     *          creating the directory\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if the array contains an attribute that cannot be set atomically\\n     *          when creating the directory\\n     * @throws  FileAlreadyExistsException\\n     *          if a directory could not otherwise be created because a file of\\n     *          that name already exists \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs or the parent directory does not exist\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method is invoked to check write access to the new directory.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void createSymbolicLink(Path link, Path target, FileAttribute\u003c?\u003e... attrs) throws IOException", "label": "public void createSymbolicLink(Path link, Path target, FileAttribute\u003c?\u003e... attrs) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a symbolic link to a target. This method works in exactly the\\n     * manner specified by the {@link Files#createSymbolicLink} method.\\n     *\\n     * \u003cp\u003e The default implementation of this method throws {@code\\n     * UnsupportedOperationException}.\\n     *\\n     * @param   link\\n     *          the path of the symbolic link to create\\n     * @param   target\\n     *          the target of the symbolic link\\n     * @param   attrs\\n     *          the array of attributes to set atomically when creating the\\n     *          symbolic link\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if the implementation does not support symbolic links or the\\n     *          array contains an attribute that cannot be set atomically when\\n     *          creating the symbolic link\\n     * @throws  FileAlreadyExistsException\\n     *          if a file with the name already exists \u003ci\u003e(optional specific\\n     *          exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager\\n     *          is installed, it denies {@link LinkPermission}\u003ctt\u003e(\"symbolic\")\u003c/tt\u003e\\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method denies write access to the path of the symbolic link.\\n     \u0027}"}, {"color": "#97c2fc", "id": "createSymbolicLink", "label": "createSymbolicLink", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "LinkPermission", "label": "LinkPermission", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public void createLink(Path link, Path existing) throws IOException", "label": "public void createLink(Path link, Path existing) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a new link (directory entry) for an existing file. This method\\n     * works in exactly the manner specified by the {@link Files#createLink}\\n     * method.\\n     *\\n     * \u003cp\u003e The default implementation of this method throws {@code\\n     * UnsupportedOperationException}.\\n     *\\n     * @param   link\\n     *          the link (directory entry) to create\\n     * @param   existing\\n     *          a path to an existing file\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if the implementation does not support adding an existing file\\n     *          to a directory\\n     * @throws  FileAlreadyExistsException\\n     *          if the entry could not otherwise be created because a file of\\n     *          that name already exists \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager\\n     *          is installed, it denies {@link LinkPermission}\u003ctt\u003e(\"hard\")\u003c/tt\u003e\\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method denies write access to either the  link or the\\n     *          existing file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "createLink", "label": "createLink", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract void delete(Path path) throws IOException", "label": "public abstract void delete(Path path) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Deletes a file. This method works in exactly the  manner specified by the\\n     * {@link Files#delete} method.\\n     *\\n     * @param   path\\n     *          the path to the file to delete\\n     *\\n     * @throws  NoSuchFileException\\n     *          if the file does not exist \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  DirectoryNotEmptyException\\n     *          if the file is a directory and could not otherwise be deleted\\n     *          because the directory is not empty \u003ci\u003e(optional specific\\n     *          exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkDelete(String)} method\\n     *          is invoked to check delete access to the file\\n     \u0027}"}, {"color": "#97c2fc", "id": "delete", "label": "delete", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public boolean deleteIfExists(Path path) throws IOException", "label": "public boolean deleteIfExists(Path path) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Deletes a file if it exists. This method works in exactly the manner\\n     * specified by the {@link Files#deleteIfExists} method.\\n     *\\n     * \u003cp\u003e The default implementation of this method simply invokes {@link\\n     * #delete} ignoring the {@code NoSuchFileException} when the file does not\\n     * exist. It may be overridden where appropriate.\\n     *\\n     * @param   path\\n     *          the path to the file to delete\\n     *\\n     * @return  {@code true} if the file was deleted by this method; {@code\\n     *          false} if the file could not be deleted because it did not\\n     *          exist\\n     *\\n     * @throws  DirectoryNotEmptyException\\n     *          if the file is a directory and could not otherwise be deleted\\n     *          because the directory is not empty \u003ci\u003e(optional specific\\n     *          exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkDelete(String)} method\\n     *          is invoked to check delete access to the file\\n     \u0027}"}, {"color": "#97c2fc", "id": "deleteIfExists", "label": "deleteIfExists", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public Path readSymbolicLink(Path link) throws IOException", "label": "public Path readSymbolicLink(Path link) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Reads the target of a symbolic link. This method works in exactly the\\n     * manner specified by the {@link Files#readSymbolicLink} method.\\n     *\\n     * \u003cp\u003e The default implementation of this method throws {@code\\n     * UnsupportedOperationException}.\\n     *\\n     * @param   link\\n     *          the path to the symbolic link\\n     *\\n     * @return  The target of the symbolic link\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if the implementation does not support symbolic links\\n     * @throws  NotLinkException\\n     *          if the target could otherwise not be read because the file\\n     *          is not a symbolic link \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager\\n     *          is installed, it checks that {@code FilePermission} has been\\n     *          granted with the \"{@code readlink}\" action to read the link.\\n     \u0027}"}, {"color": "#97c2fc", "id": "readSymbolicLink", "label": "readSymbolicLink", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract void copy(Path source, Path target, CopyOption... options) throws IOException", "label": "public abstract void copy(Path source, Path target, CopyOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Copy a file to a target file. This method works in exactly the manner\\n     * specified by the {@link Files#copy(Path,Path,CopyOption[])} method\\n     * except that both the source and target paths must be associated with\\n     * this provider.\\n     *\\n     * @param   source\\n     *          the path to the file to copy\\n     * @param   target\\n     *          the path to the target file\\n     * @param   options\\n     *          options specifying how the copy should be done\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if the array contains a copy option that is not supported\\n     * @throws  FileAlreadyExistsException\\n     *          if the target file exists but cannot be replaced because the\\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\\n     *          specific exception)\u003c/i\u003e\\n     * @throws  DirectoryNotEmptyException\\n     *          the {@code REPLACE_EXISTING} option is specified but the file\\n     *          cannot be replaced because it is a non-empty directory\\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the source file, the\\n     *          {@link SecurityManager#checkWrite(String) checkWrite} is invoked\\n     *          to check write access to the target file. If a symbolic link is\\n     *          copied the security manager is invoked to check {@link\\n     *          LinkPermission}{@code (\"symbolic\")}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "copy(Path", "label": "copy(Path", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract void move(Path source, Path target, CopyOption... options) throws IOException", "label": "public abstract void move(Path source, Path target, CopyOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Move or rename a file to a target file. This method works in exactly the\\n     * manner specified by the {@link Files#move} method except that both the\\n     * source and target paths must be associated with this provider.\\n     *\\n     * @param   source\\n     *          the path to the file to move\\n     * @param   target\\n     *          the path to the target file\\n     * @param   options\\n     *          options specifying how the move should be done\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if the array contains a copy option that is not supported\\n     * @throws  FileAlreadyExistsException\\n     *          if the target file exists but cannot be replaced because the\\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\\n     *          specific exception)\u003c/i\u003e\\n     * @throws  DirectoryNotEmptyException\\n     *          the {@code REPLACE_EXISTING} option is specified but the file\\n     *          cannot be replaced because it is a non-empty directory\\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  AtomicMoveNotSupportedException\\n     *          if the options array contains the {@code ATOMIC_MOVE} option but\\n     *          the file cannot be moved as an atomic file system operation.\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method is invoked to check write access to both the source and\\n     *          target file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "move", "label": "move", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract boolean isSameFile(Path path, Path path2) throws IOException", "label": "public abstract boolean isSameFile(Path path, Path path2) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests if two paths locate the same file. This method works in exactly the\\n     * manner specified by the {@link Files#isSameFile} method.\\n     *\\n     * @param   path\\n     *          one path to the file\\n     * @param   path2\\n     *          the other path\\n     *\\n     * @return  {@code true} if, and only if, the two paths locate the same file\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to both files.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract boolean isHidden(Path path) throws IOException", "label": "public abstract boolean isHidden(Path path) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tells whether or not a file is considered \u003cem\u003ehidden\u003c/em\u003e. This method\\n     * works in exactly the manner specified by the {@link Files#isHidden}\\n     * method.\\n     *\\n     * \u003cp\u003e This method is invoked by the {@link Files#isHidden isHidden} method.\\n     *\\n     * @param   path\\n     *          the path to the file to test\\n     *\\n     * @return  {@code true} if the file is considered hidden\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract FileStore getFileStore(Path path) throws IOException", "label": "public abstract FileStore getFileStore(Path path) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the {@link FileStore} representing the file store where a file\\n     * is located. This method works in exactly the manner specified by the\\n     * {@link Files#getFileStore} method.\\n     *\\n     * @param   path\\n     *          the path to the file\\n     *\\n     * @return  the file store where the file is stored\\n     *\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the file, and in\\n     *          addition it checks {@link RuntimePermission}\u003ctt\u003e\\n     *          (\"getFileStoreAttributes\")\u003c/tt\u003e\\n     \u0027}"}, {"color": "#97c2fc", "id": "FileStore", "label": "FileStore", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "getFileStore", "label": "getFileStore", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract void checkAccess(Path path, AccessMode... modes) throws IOException", "label": "public abstract void checkAccess(Path path, AccessMode... modes) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Checks the existence, and optionally the accessibility, of a file.\\n     *\\n     * \u003cp\u003e This method may be used by the {@link Files#isReadable isReadable},\\n     * {@link Files#isWritable isWritable} and {@link Files#isExecutable\\n     * isExecutable} methods to check the accessibility of a file.\\n     *\\n     * \u003cp\u003e This method checks the existence of a file and that this Java virtual\\n     * machine has appropriate privileges that would allow it access the file\\n     * according to all of access modes specified in the {@code modes} parameter\\n     * as follows:\\n     *\\n     * \u003ctable border=1 cellpadding=5 summary=\"\"\u003e\\n     * \u003ctr\u003e \u003cth\u003eValue\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e {@link AccessMode#READ READ} \u003c/td\u003e\\n     *   \u003ctd\u003e Checks that the file exists and that the Java virtual machine has\\n     *     permission to read the file. \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e {@link AccessMode#WRITE WRITE} \u003c/td\u003e\\n     *   \u003ctd\u003e Checks that the file exists and that the Java virtual machine has\\n     *     permission to write to the file, \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003ctr\u003e\\n     *   \u003ctd\u003e {@link AccessMode#EXECUTE EXECUTE} \u003c/td\u003e\\n     *   \u003ctd\u003e Checks that the file exists and that the Java virtual machine has\\n     *     permission to {@link Runtime#exec execute} the file. The semantics\\n     *     may differ when checking access to a directory. For example, on UNIX\\n     *     systems, checking for {@code EXECUTE} access checks that the Java\\n     *     virtual machine has permission to search the directory in order to\\n     *     access file or subdirectories. \u003c/td\u003e\\n     * \u003c/tr\u003e\\n     * \u003c/table\u003e\\n     *\\n     * \u003cp\u003e If the {@code modes} parameter is of length zero, then the existence\\n     * of the file is checked.\\n     *\\n     * \u003cp\u003e This method follows symbolic links if the file referenced by this\\n     * object is a symbolic link. Depending on the implementation, this method\\n     * may require to read file permissions, access control lists, or other\\n     * file attributes in order to check the effective access to the file. To\\n     * determine the effective access to a file may require access to several\\n     * attributes and so in some implementations this method may not be atomic\\n     * with respect to other file system operations.\\n     *\\n     * @param   path\\n     *          the path to the file to check\\n     * @param   modes\\n     *          The access modes to check; may have zero elements\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          an implementation is required to support checking for\\n     *          {@code READ}, {@code WRITE}, and {@code EXECUTE} access. This\\n     *          exception is specified to allow for the {@code Access} enum to\\n     *          be extended in future releases.\\n     * @throws  NoSuchFileException\\n     *          if a file does not exist \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  AccessDeniedException\\n     *          the requested access would be denied or the access cannot be\\n     *          determined because the Java virtual machine has insufficient\\n     *          privileges or other reasons. \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          is invoked when checking read access to the file or only the\\n     *          existence of the file, the {@link SecurityManager#checkWrite(String)\\n     *          checkWrite} is invoked when checking write access to the file,\\n     *          and {@link SecurityManager#checkExec(String) checkExec} is invoked\\n     *          when checking execute access.\\n     \u0027}"}, {"color": "#97c2fc", "id": "isReadable", "label": "isReadable", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "isWritable", "label": "isWritable", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "isExecutableisExecutable", "label": "isExecutableisExecutable", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "EXECUTE", "label": "EXECUTE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract V getFileAttributeView(Path path, Class\u003cV\u003e type, LinkOption... options)", "label": "public abstract V getFileAttributeView(Path path, Class\u003cV\u003e type, LinkOption... options)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a file attribute view of a given type. This method works in\\n     * exactly the manner specified by the {@link Files#getFileAttributeView}\\n     * method.\\n     *\\n     * @param   \u003cV\u003e\\n     *          The {@code FileAttributeView} type\\n     * @param   path\\n     *          the path to the file\\n     * @param   type\\n     *          the {@code Class} object corresponding to the file attribute view\\n     * @param   options\\n     *          options indicating how symbolic links are handled\\n     *\\n     * @return  a file attribute view of the specified type, or {@code null} if\\n     *          the attribute view type is not available\\n     \u0027}"}, {"color": "#97c2fc", "id": "getFileAttributeView", "label": "getFileAttributeView", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public abstract A readAttributes(Path path, Class\u003cA\u003e type, LinkOption... options) throws IOException", "label": "public abstract A readAttributes(Path path, Class\u003cA\u003e type, LinkOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reads a file\u0027s attributes as a bulk operation. This method works in\\n     * exactly the manner specified by the {@link\\n     * Files#readAttributes(Path,Class,LinkOption[])} method.\\n     *\\n     * @param   \u003cA\u003e\\n     *          The {@code BasicFileAttributes} type\\n     * @param   path\\n     *          the path to the file\\n     * @param   type\\n     *          the {@code Class} of the file attributes required\\n     *          to read\\n     * @param   options\\n     *          options indicating how symbolic links are handled\\n     *\\n     * @return  the file attributes\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if an attributes of the given type are not supported\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, a security manager is\\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the file\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract Map\u003cString, Object\u003e readAttributes(Path path, String attributes, LinkOption... options) throws IOException", "label": "public abstract Map\u003cString, Object\u003e readAttributes(Path path, String attributes, LinkOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Reads a set of file attributes as a bulk operation. This method works in\\n     * exactly the manner specified by the {@link\\n     * Files#readAttributes(Path,String,LinkOption[])} method.\\n     *\\n     * @param   path\\n     *          the path to the file\\n     * @param   attributes\\n     *          the attributes to read\\n     * @param   options\\n     *          options indicating how symbolic links are handled\\n     *\\n     * @return  a map of the attributes returned; may be empty. The map\u0027s keys\\n     *          are the attribute names, its values are the attribute values\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if the attribute view is not available\\n     * @throws  IllegalArgumentException\\n     *          if no attributes are specified or an unrecognized attributes is\\n     *          specified\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\\n     *          method denies read access to the file. If this method is invoked\\n     *          to read security sensitive attributes then the security manager\\n     *          may be invoke to check for additional permissions.\\n     \"}"}, {"color": "#97c2fc", "id": "public abstract void setAttribute(Path path, String attribute, Object value, LinkOption... options) throws IOException", "label": "public abstract void setAttribute(Path path, String attribute, Object value, LinkOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the value of a file attribute. This method works in exactly the\\n     * manner specified by the {@link Files#setAttribute} method.\\n     *\\n     * @param   path\\n     *          the path to the file\\n     * @param   attribute\\n     *          the attribute to set\\n     * @param   value\\n     *          the attribute value\\n     * @param   options\\n     *          options indicating how symbolic links are handled\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if the attribute view is not available\\n     * @throws  IllegalArgumentException\\n     *          if the attribute name is not specified, or is not recognized, or\\n     *          the attribute value is of the correct type but has an\\n     *          inappropriate value\\n     * @throws  ClassCastException\\n     *          If the attribute value is not of the expected type or is a\\n     *          collection containing elements that are not of the expected\\n     *          type\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, its {@link SecurityManager#checkWrite(String) checkWrite}\\n     *          method denies write access to the file. If this method is invoked\\n     *          to set security sensitive attributes then the security manager\\n     *          may be invoked to check for additional permissions.\\n     \u0027}"}, {"color": "#97c2fc", "id": "setAttribute", "label": "setAttribute", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static FileSystem getFileSystem(URI uri)", "label": "public static FileSystem getFileSystem(URI uri)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a reference to an existing {@code FileSystem}.\\n     *\\n     * \u003cp\u003e This method iterates over the {@link FileSystemProvider#installedProviders()\\n     * installed} providers to locate the provider that is identified by the URI\\n     * {@link URI#getScheme scheme} of the given URI. URI schemes are compared\\n     * without regard to case. The exact form of the URI is highly provider\\n     * dependent. If found, the provider\u0027s {@link FileSystemProvider#getFileSystem\\n     * getFileSystem} method is invoked to obtain a reference to the {@code\\n     * FileSystem}.\\n     *\\n     * \u003cp\u003e Once a file system created by this provider is {@link FileSystem#close\\n     * closed} it is provider-dependent if this method returns a reference to\\n     * the closed file system or throws {@link FileSystemNotFoundException}.\\n     * If the provider allows a new file system to be created with the same URI\\n     * as a file system it previously created then this method throws the\\n     * exception if invoked after the file system is closed (and before a new\\n     * instance is created by the {@link #newFileSystem newFileSystem} method).\\n     *\\n     * \u003cp\u003e If a security manager is installed then a provider implementation\\n     * may require to check a permission before returning a reference to an\\n     * existing file system. In the case of the {@link FileSystems#getDefault\\n     * default} file system, no permission check is required.\\n     *\\n     * @param   uri  the URI to locate the file system\\n     *\\n     * @return  the reference to the file system\\n     *\\n     * @throws  IllegalArgumentException\\n     *          if the pre-conditions for the {@code uri} parameter are not met\\n     * @throws  FileSystemNotFoundException\\n     *          if the file system, identified by the URI, does not exist\\n     * @throws  ProviderNotFoundException\\n     *          if a provider supporting the URI scheme is not installed\\n     * @throws  SecurityException\\n     *          if a security manager is installed and it denies an unspecified\\n     *          permission\\n     \"}"}, {"color": "#97c2fc", "id": "java.nio.file.FileSystemNotFoundException", "label": "java.nio.file.FileSystemNotFoundException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "newFileSystem", "label": "newFileSystem", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static FileSystem newFileSystem(URI uri, Map\u003cString, ?\u003e env) throws IOException", "label": "public static FileSystem newFileSystem(URI uri, Map\u003cString, ?\u003e env) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Constructs a new file system that is identified by a {@link URI}\\n     *\\n     * \u003cp\u003e This method iterates over the {@link FileSystemProvider#installedProviders()\\n     * installed} providers to locate the provider that is identified by the URI\\n     * {@link URI#getScheme scheme} of the given URI. URI schemes are compared\\n     * without regard to case. The exact form of the URI is highly provider\\n     * dependent. If found, the provider\\\u0027s {@link FileSystemProvider#newFileSystem(URI,Map)\\n     * newFileSystem(URI,Map)} method is invoked to construct the new file system.\\n     *\\n     * \u003cp\u003e Once a file system is {@link FileSystem#close closed} it is\\n     * provider-dependent if the provider allows a new file system to be created\\n     * with the same URI as a file system it previously created.\\n     *\\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\\n     * Suppose there is a provider identified by the scheme {@code \"memory\"}\\n     * installed:\\n     * \u003cpre\u003e\\n     *   Map\u0026lt;String,String\u0026gt; env = new HashMap\u0026lt;\u0026gt;();\\n     *   env.put(\"capacity\", \"16G\");\\n     *   env.put(\"blockSize\", \"4k\");\\n     *   FileSystem fs = FileSystems.newFileSystem(URI.create(\"memory:///?name=logfs\"), env);\\n     * \u003c/pre\u003e\\n     *\\n     * @param   uri\\n     *          the URI identifying the file system\\n     * @param   env\\n     *          a map of provider specific properties to configure the file system;\\n     *          may be empty\\n     *\\n     * @return  a new file system\\n     *\\n     * @throws  IllegalArgumentException\\n     *          if the pre-conditions for the {@code uri} parameter are not met,\\n     *          or the {@code env} parameter does not contain properties required\\n     *          by the provider, or a property value is invalid\\n     * @throws  FileSystemAlreadyExistsException\\n     *          if the file system has already been created\\n     * @throws  ProviderNotFoundException\\n     *          if a provider supporting the URI scheme is not installed\\n     * @throws  IOException\\n     *          if an I/O error occurs creating the file system\\n     * @throws  SecurityException\\n     *          if a security manager is installed and it denies an unspecified\\n     *          permission required by the file system provider implementation\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static FileSystem newFileSystem(URI uri, Map\u003cString, ?\u003e env, ClassLoader loader) throws IOException", "label": "public static FileSystem newFileSystem(URI uri, Map\u003cString, ?\u003e env, ClassLoader loader) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Constructs a new file system that is identified by a {@link URI}\\n     *\\n     * \u003cp\u003e This method first attempts to locate an installed provider in exactly\\n     * the same manner as the {@link #newFileSystem(URI,Map) newFileSystem(URI,Map)}\\n     * method. If none of the installed providers support the URI scheme then an\\n     * attempt is made to locate the provider using the given class loader. If a\\n     * provider supporting the URI scheme is located then its {@link\\n     * FileSystemProvider#newFileSystem(URI,Map) newFileSystem(URI,Map)} is\\n     * invoked to construct the new file system.\\n     *\\n     * @param   uri\\n     *          the URI identifying the file system\\n     * @param   env\\n     *          a map of provider specific properties to configure the file system;\\n     *          may be empty\\n     * @param   loader\\n     *          the class loader to locate the provider or {@code null} to only\\n     *          attempt to locate an installed provider\\n     *\\n     * @return  a new file system\\n     *\\n     * @throws  IllegalArgumentException\\n     *          if the pre-conditions for the {@code uri} parameter are not met,\\n     *          or the {@code env} parameter does not contain properties required\\n     *          by the provider, or a property value is invalid\\n     * @throws  FileSystemAlreadyExistsException\\n     *          if the URI scheme identifies an installed provider and the file\\n     *          system has already been created\\n     * @throws  ProviderNotFoundException\\n     *          if a provider supporting the URI scheme is not found\\n     * @throws  ServiceConfigurationError\\n     *          when an error occurs while loading a service provider\\n     * @throws  IOException\\n     *          an I/O error occurs creating the file system\\n     * @throws  SecurityException\\n     *          if a security manager is installed and it denies an unspecified\\n     *          permission required by the file system provider implementation\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static FileSystem newFileSystem(Path path, ClassLoader loader) throws IOException", "label": "public static FileSystem newFileSystem(Path path, ClassLoader loader) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Constructs a new {@code FileSystem} to access the contents of a file as a\\n     * file system.\\n     *\\n     * \u003cp\u003e This method makes use of specialized providers that create pseudo file\\n     * systems where the contents of one or more files is treated as a file\\n     * system.\\n     *\\n     * \u003cp\u003e This method iterates over the {@link FileSystemProvider#installedProviders()\\n     * installed} providers. It invokes, in turn, each provider\u0027s {@link\\n     * FileSystemProvider#newFileSystem(Path,Map) newFileSystem(Path,Map)} method\\n     * with an empty map. If a provider returns a file system then the iteration\\n     * terminates and the file system is returned. If none of the installed\\n     * providers return a {@code FileSystem} then an attempt is made to locate\\n     * the provider using the given class loader. If a provider returns a file\\n     * system then the lookup terminates and the file system is returned.\\n     *\\n     * @param   path\\n     *          the path to the file\\n     * @param   loader\\n     *          the class loader to locate the provider or {@code null} to only\\n     *          attempt to locate an installed provider\\n     *\\n     * @return  a new file system\\n     *\\n     * @throws  ProviderNotFoundException\\n     *          if a provider supporting this file type cannot be located\\n     * @throws  ServiceConfigurationError\\n     *          when an error occurs while loading a service provider\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          if a security manager is installed and it denies an unspecified\\n     *          permission\\n     \"}"}, {"color": "#97c2fc", "id": "public static Path of(URI uri)", "label": "public static Path of(URI uri)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Path} by converting a URI.\\n     *\\n     * \u003cp\u003e This method iterates over the {@link FileSystemProvider#installedProviders()\\n     * installed} providers to locate the provider that is identified by the\\n     * URI {@link URI#getScheme scheme} of the given URI. URI schemes are\\n     * compared without regard to case. If the provider is found then its {@link\\n     * FileSystemProvider#getPath getPath} method is invoked to convert the\\n     * URI.\\n     *\\n     * \u003cp\u003e In the case of the default provider, identified by the URI scheme\\n     * \"file\", the given URI has a non-empty path component, and undefined query\\n     * and fragment components. Whether the authority component may be present\\n     * is platform specific. The returned {@code Path} is associated with the\\n     * {@link FileSystems#getDefault default} file system.\\n     *\\n     * \u003cp\u003e The default provider provides a similar \u003cem\u003eround-trip\u003c/em\u003e guarantee\\n     * to the {@link java.io.File} class. For a given {@code Path} \u003ci\u003ep\u003c/i\u003e it\\n     * is guaranteed that\\n     * \u003cblockquote\u003e{@code\\n     * Path.of(}\u003ci\u003ep\u003c/i\u003e{@code .}{@link Path#toUri() toUri}{@code ()).equals(}\\n     * \u003ci\u003ep\u003c/i\u003e{@code .}{@link Path#toAbsolutePath() toAbsolutePath}{@code ())}\\n     * \u003c/blockquote\u003e\\n     * so long as the original {@code Path}, the {@code URI}, and the new {@code\\n     * Path} are all created in (possibly different invocations of) the same\\n     * Java virtual machine. Whether other providers make any guarantees is\\n     * provider specific and therefore unspecified.\\n     *\\n     * @param   uri\\n     *          the URI to convert\\n     *\\n     * @return  the resulting {@code Path}\\n     *\\n     * @throws  IllegalArgumentException\\n     *          if preconditions on the {@code uri} parameter do not hold. The\\n     *          format of the URI is provider specific.\\n     * @throws  FileSystemNotFoundException\\n     *          The file system, identified by the URI, does not exist and\\n     *          cannot be created automatically, or the provider identified by\\n     *          the URI\\\u0027s scheme component is not installed\\n     * @throws  SecurityException\\n     *          if a security manager is installed and it denies an unspecified\\n     *          permission to access the file system\\n     *\\n     * @since 11\\n     \u0027}"}, {"color": "#97c2fc", "id": "toAbsolutePath()", "label": "toAbsolutePath()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "toUri()", "label": "toUri()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " FileSystem getFileSystem()", "label": " FileSystem getFileSystem()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the file system that created this object.\\n     *\\n     * @return  the file system that created this object\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean isAbsolute()", "label": " boolean isAbsolute()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Tells whether or not this path is absolute.\\n     *\\n     * \u003cp\u003e An absolute path is complete in that it doesn\u0027t need to be combined\\n     * with other path information in order to locate a file.\\n     *\\n     * @return  {@code true} if, and only if, this path is absolute\\n     \"}"}, {"color": "#97c2fc", "id": " Path getRoot()", "label": " Path getRoot()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the root component of this path as a {@code Path} object,\\n     * or {@code null} if this path does not have a root component.\\n     *\\n     * @return  a path representing the root component of this path,\\n     *          or {@code null}\\n     \u0027}"}, {"color": "#97c2fc", "id": " Path getFileName()", "label": " Path getFileName()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the name of the file or directory denoted by this path as a\\n     * {@code Path} object. The file name is the \u003cem\u003efarthest\u003c/em\u003e element from\\n     * the root in the directory hierarchy.\\n     *\\n     * @return  a path representing the name of the file or directory, or\\n     *          {@code null} if this path has zero elements\\n     \u0027}"}, {"color": "#97c2fc", "id": " Path getParent()", "label": " Path getParent()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the \u003cem\u003eparent path\u003c/em\u003e, or {@code null} if this path does not\\n     * have a parent.\\n     *\\n     * \u003cp\u003e The parent of this path object consists of this path\\\u0027s root\\n     * component, if any, and each element in the path except for the\\n     * \u003cem\u003efarthest\u003c/em\u003e from the root in the directory hierarchy. This method\\n     * does not access the file system; the path or its parent may not exist.\\n     * Furthermore, this method does not eliminate special names such as \".\"\\n     * and \"..\" that may be used in some implementations. On UNIX for example,\\n     * the parent of \"{@code /a/b/c}\" is \"{@code /a/b}\", and the parent of\\n     * {@code \"x/y/.}\" is \"{@code x/y}\". This method may be used with the {@link\\n     * #normalize normalize} method, to eliminate redundant names, for cases where\\n     * \u003cem\u003eshell-like\u003c/em\u003e navigation is required.\\n     *\\n     * \u003cp\u003e If this path has one or more elements, and no root component, then\\n     * this method is equivalent to evaluating the expression:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * subpath(0,\u0026nbsp;getNameCount()-1);\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @return  a path representing the path\\\u0027s parent\\n     \u0027}"}, {"color": "#97c2fc", "id": "normalize", "label": "normalize", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " int getNameCount()", "label": " int getNameCount()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the number of name elements in the path.\\n     *\\n     * @return  the number of elements in the path, or {@code 0} if this path\\n     *          only represents a root component\\n     \u0027}"}, {"color": "#97c2fc", "id": " Path getName(int index)", "label": " Path getName(int index)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a name element of this path as a {@code Path} object.\\n     *\\n     * \u003cp\u003e The {@code index} parameter is the index of the name element to return.\\n     * The element that is \u003cem\u003eclosest\u003c/em\u003e to the root in the directory hierarchy\\n     * has index {@code 0}. The element that is \u003cem\u003efarthest\u003c/em\u003e from the root\\n     * has index {@link #getNameCount count}{@code -1}.\\n     *\\n     * @param   index\\n     *          the index of the element\\n     *\\n     * @return  the name element\\n     *\\n     * @throws  IllegalArgumentException\\n     *          if {@code index} is negative, {@code index} is greater than or\\n     *          equal to the number of elements, or this path has zero name\\n     *          elements\\n     \u0027}"}, {"color": "#97c2fc", "id": "getNameCount", "label": "getNameCount", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " Path subpath(int beginIndex, int endIndex)", "label": " Path subpath(int beginIndex, int endIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a relative {@code Path} that is a subsequence of the name\\n     * elements of this path.\\n     *\\n     * \u003cp\u003e The {@code beginIndex} and {@code endIndex} parameters specify the\\n     * subsequence of name elements. The name that is \u003cem\u003eclosest\u003c/em\u003e to the root\\n     * in the directory hierarchy has index {@code 0}. The name that is\\n     * \u003cem\u003efarthest\u003c/em\u003e from the root has index {@link #getNameCount\\n     * count}{@code -1}. The returned {@code Path} object has the name elements\\n     * that begin at {@code beginIndex} and extend to the element at index {@code\\n     * endIndex-1}.\\n     *\\n     * @param   beginIndex\\n     *          the index of the first element, inclusive\\n     * @param   endIndex\\n     *          the index of the last element, exclusive\\n     *\\n     * @return  a new {@code Path} object that is a subsequence of the name\\n     *          elements in this {@code Path}\\n     *\\n     * @throws  IllegalArgumentException\\n     *          if {@code beginIndex} is negative, or greater than or equal to\\n     *          the number of elements. If {@code endIndex} is less than or\\n     *          equal to {@code beginIndex}, or larger than the number of elements.\\n     \u0027}"}, {"color": "#97c2fc", "id": "getNameCountcount", "label": "getNameCountcount", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " boolean startsWith(Path other)", "label": " boolean startsWith(Path other)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Tests if this path starts with the given path.\\n     *\\n     * \u003cp\u003e This path \u003cem\u003estarts\u003c/em\u003e with the given path if this path\u0027s root\\n     * component \u003cem\u003estarts\u003c/em\u003e with the root component of the given path,\\n     * and this path starts with the same name elements as the given path.\\n     * If the given path has more name elements than this path then {@code false}\\n     * is returned.\\n     *\\n     * \u003cp\u003e Whether or not the root component of this path starts with the root\\n     * component of the given path is file system specific. If this path does\\n     * not have a root component and the given path has a root component then\\n     * this path does not start with the given path.\\n     *\\n     * \u003cp\u003e If the given path is associated with a different {@code FileSystem}\\n     * to this path then {@code false} is returned.\\n     *\\n     * @param   other\\n     *          the given path\\n     *\\n     * @return  {@code true} if this path starts with the given path; otherwise\\n     *          {@code false}\\n     \"}"}, {"color": "#97c2fc", "id": " boolean startsWith(String other)", "label": " boolean startsWith(String other)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests if this path starts with a {@code Path}, constructed by converting\\n     * the given path string, in exactly the manner specified by the {@link\\n     * #startsWith(Path) startsWith(Path)} method. On UNIX for example, the path\\n     * \"{@code foo/bar}\" starts with \"{@code foo}\" and \"{@code foo/bar}\". It\\n     * does not start with \"{@code f}\" or \"{@code fo}\".\\n     *\\n     * @param   other\\n     *          the given path string\\n     *\\n     * @return  {@code true} if this path starts with the given path; otherwise\\n     *          {@code false}\\n     *\\n     * @throws  InvalidPathException\\n     *          If the path string cannot be converted to a Path.\\n     \u0027}"}, {"color": "#97c2fc", "id": "startsWith(Path)", "label": "startsWith(Path)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " boolean endsWith(Path other)", "label": " boolean endsWith(Path other)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests if this path ends with the given path.\\n     *\\n     * \u003cp\u003e If the given path has \u003cem\u003eN\u003c/em\u003e elements, and no root component,\\n     * and this path has \u003cem\u003eN\u003c/em\u003e or more elements, then this path ends with\\n     * the given path if the last \u003cem\u003eN\u003c/em\u003e elements of each path, starting at\\n     * the element farthest from the root, are equal.\\n     *\\n     * \u003cp\u003e If the given path has a root component then this path ends with the\\n     * given path if the root component of this path \u003cem\u003eends with\u003c/em\u003e the root\\n     * component of the given path, and the corresponding elements of both paths\\n     * are equal. Whether or not the root component of this path ends with the\\n     * root component of the given path is file system specific. If this path\\n     * does not have a root component and the given path has a root component\\n     * then this path does not end with the given path.\\n     *\\n     * \u003cp\u003e If the given path is associated with a different {@code FileSystem}\\n     * to this path then {@code false} is returned.\\n     *\\n     * @param   other\\n     *          the given path\\n     *\\n     * @return  {@code true} if this path ends with the given path; otherwise\\n     *          {@code false}\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean endsWith(String other)", "label": " boolean endsWith(String other)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests if this path ends with a {@code Path}, constructed by converting\\n     * the given path string, in exactly the manner specified by the {@link\\n     * #endsWith(Path) endsWith(Path)} method. On UNIX for example, the path\\n     * \"{@code foo/bar}\" ends with \"{@code foo/bar}\" and \"{@code bar}\". It does\\n     * not end with \"{@code r}\" or \"{@code /bar}\". Note that trailing separators\\n     * are not taken into account, and so invoking this method on the {@code\\n     * Path}\"{@code foo/bar}\" with the {@code String} \"{@code bar/}\" returns\\n     * {@code true}.\\n     *\\n     * @param   other\\n     *          the given path string\\n     *\\n     * @return  {@code true} if this path ends with the given path; otherwise\\n     *          {@code false}\\n     *\\n     * @throws  InvalidPathException\\n     *          If the path string cannot be converted to a Path.\\n     \u0027}"}, {"color": "#97c2fc", "id": "endsWith(Path)", "label": "endsWith(Path)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " Path normalize()", "label": " Path normalize()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a path that is this path with redundant name elements eliminated.\\n     *\\n     * \u003cp\u003e The precise definition of this method is implementation dependent but\\n     * in general it derives from this path, a path that does not contain\\n     * \u003cem\u003eredundant\u003c/em\u003e name elements. In many file systems, the \"{@code .}\"\\n     * and \"{@code ..}\" are special names used to indicate the current directory\\n     * and parent directory. In such file systems all occurrences of \"{@code .}\"\\n     * are considered redundant. If a \"{@code ..}\" is preceded by a\\n     * non-\"{@code ..}\" name then both names are considered redundant (the\\n     * process to identify such names is repeated until it is no longer\\n     * applicable).\\n     *\\n     * \u003cp\u003e This method does not access the file system; the path may not locate\\n     * a file that exists. Eliminating \"{@code ..}\" and a preceding name from a\\n     * path may result in the path that locates a different file than the original\\n     * path. This can arise when the preceding name is a symbolic link.\\n     *\\n     * @return  the resulting path or this path if it does not contain\\n     *          redundant name elements; an empty path is returned if this path\\n     *          does have a root component and all name elements are redundant\\n     *\\n     * @see #getParent\\n     * @see #toRealPath\\n     \u0027}"}, {"color": "#97c2fc", "id": " Path resolve(Path other)", "label": " Path resolve(Path other)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Resolve the given path against this path.\\n     *\\n     * \u003cp\u003e If the {@code other} parameter is an {@link #isAbsolute() absolute}\\n     * path then this method trivially returns {@code other}. If {@code other}\\n     * is an \u003ci\u003eempty path\u003c/i\u003e then this method trivially returns this path.\\n     * Otherwise this method considers this path to be a directory and resolves\\n     * the given path against this path. In the simplest case, the given path\\n     * does not have a {@link #getRoot root} component, in which case this method\\n     * \u003cem\u003ejoins\u003c/em\u003e the given path to this path and returns a resulting path\\n     * that {@link #endsWith ends} with the given path. Where the given path has\\n     * a root component then resolution is highly implementation dependent and\\n     * therefore unspecified.\\n     *\\n     * @param   other\\n     *          the path to resolve against this path\\n     *\\n     * @return  the resulting path\\n     *\\n     * @see #relativize\\n     \u0027}"}, {"color": "#97c2fc", "id": "endsWith", "label": "endsWith", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "getRoot", "label": "getRoot", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "isAbsolute()", "label": "isAbsolute()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " Path resolve(String other)", "label": " Path resolve(String other)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Converts a given path string to a {@code Path} and resolves it against\\n     * this {@code Path} in exactly the manner specified by the {@link\\n     * #resolve(Path) resolve} method. For example, suppose that the name\\n     * separator is \"{@code /}\" and a path represents \"{@code foo/bar}\", then\\n     * invoking this method with the path string \"{@code gus}\" will result in\\n     * the {@code Path} \"{@code foo/bar/gus}\".\\n     *\\n     * @param   other\\n     *          the path string to resolve against this path\\n     *\\n     * @return  the resulting path\\n     *\\n     * @throws  InvalidPathException\\n     *          if the path string cannot be converted to a Path.\\n     *\\n     * @see FileSystem#getPath\\n     \u0027}"}, {"color": "#97c2fc", "id": "resolve(Path)", "label": "resolve(Path)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " Path resolveSibling(Path other)", "label": " Path resolveSibling(Path other)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Resolves the given path against this path\\\u0027s {@link #getParent parent}\\n     * path. This is useful where a file name needs to be \u003ci\u003ereplaced\u003c/i\u003e with\\n     * another file name. For example, suppose that the name separator is\\n     * \"{@code /}\" and a path represents \"{@code dir1/dir2/foo}\", then invoking\\n     * this method with the {@code Path} \"{@code bar}\" will result in the {@code\\n     * Path} \"{@code dir1/dir2/bar}\". If this path does not have a parent path,\\n     * or {@code other} is {@link #isAbsolute() absolute}, then this method\\n     * returns {@code other}. If {@code other} is an empty path then this method\\n     * returns this path\\\u0027s parent, or where this path doesn\\\u0027t have a parent, the\\n     * empty path.\\n     *\\n     * @param   other\\n     *          the path to resolve against this path\\\u0027s parent\\n     *\\n     * @return  the resulting path\\n     *\\n     * @see #resolve(Path)\\n     \u0027}"}, {"color": "#97c2fc", "id": "getParent", "label": "getParent", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " Path resolveSibling(String other)", "label": " Path resolveSibling(String other)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Converts a given path string to a {@code Path} and resolves it against\\n     * this path\u0027s {@link #getParent parent} path in exactly the manner\\n     * specified by the {@link #resolveSibling(Path) resolveSibling} method.\\n     *\\n     * @param   other\\n     *          the path string to resolve against this path\u0027s parent\\n     *\\n     * @return  the resulting path\\n     *\\n     * @throws  InvalidPathException\\n     *          if the path string cannot be converted to a Path.\\n     *\\n     * @see FileSystem#getPath\\n     \"}"}, {"color": "#97c2fc", "id": "resolveSibling(Path)", "label": "resolveSibling(Path)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " Path relativize(Path other)", "label": " Path relativize(Path other)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Constructs a relative path between this path and a given path.\\n     *\\n     * \u003cp\u003e Relativization is the inverse of {@link #resolve(Path) resolution}.\\n     * This method attempts to construct a {@link #isAbsolute relative} path\\n     * that when {@link #resolve(Path) resolved} against this path, yields a\\n     * path that locates the same file as the given path. For example, on UNIX,\\n     * if this path is {@code \"/a/b\"} and the given path is {@code \"/a/b/c/d\"}\\n     * then the resulting relative path would be {@code \"c/d\"}. Where this\\n     * path and the given path do not have a {@link #getRoot root} component,\\n     * then a relative path can be constructed. A relative path cannot be\\n     * constructed if only one of the paths have a root component. Where both\\n     * paths have a root component then it is implementation dependent if a\\n     * relative path can be constructed. If this path and the given path are\\n     * {@link #equals equal} then an \u003ci\u003eempty path\u003c/i\u003e is returned.\\n     *\\n     * \u003cp\u003e For any two {@link #normalize normalized} paths \u003ci\u003ep\u003c/i\u003e and\\n     * \u003ci\u003eq\u003c/i\u003e, where \u003ci\u003eq\u003c/i\u003e does not have a root component,\\n     * \u003cblockquote\u003e\\n     *   \u003ci\u003ep\u003c/i\u003e\u003ctt\u003e.relativize(\u003c/tt\u003e\u003ci\u003ep\u003c/i\u003e\u003ctt\u003e.resolve(\u003c/tt\u003e\u003ci\u003eq\u003c/i\u003e\u003ctt\u003e)).equals(\u003c/tt\u003e\u003ci\u003eq\u003c/i\u003e\u003ctt\u003e)\u003c/tt\u003e\\n     * \u003c/blockquote\u003e\\n     *\\n     * \u003cp\u003e When symbolic links are supported, then whether the resulting path,\\n     * when resolved against this path, yields a path that can be used to locate\\n     * the {@link Files#isSameFile same} file as {@code other} is implementation\\n     * dependent. For example, if this path is  {@code \"/a/b\"} and the given\\n     * path is {@code \"/a/x\"} then the resulting relative path may be {@code\\n     * \"../x\"}. If {@code \"b\"} is a symbolic link then is implementation\\n     * dependent if {@code \"a/b/../x\"} would locate the same file as {@code \"/a/x\"}.\\n     *\\n     * @param   other\\n     *          the path to relativize against this path\\n     *\\n     * @return  the resulting relative path, or an empty path if both paths are\\n     *          equal\\n     *\\n     * @throws  IllegalArgumentException\\n     *          if {@code other} is not a {@code Path} that can be relativized\\n     *          against this path\\n     \u0027}"}, {"color": "#97c2fc", "id": "equals", "label": "equals", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "isAbsolute", "label": "isAbsolute", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " URI toUri()", "label": " URI toUri()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a URI to represent this path.\\n     *\\n     * \u003cp\u003e This method constructs an absolute {@link URI} with a {@link\\n     * URI#getScheme() scheme} equal to the URI scheme that identifies the\\n     * provider. The exact form of the scheme specific part is highly provider\\n     * dependent.\\n     *\\n     * \u003cp\u003e In the case of the default provider, the URI is hierarchical with\\n     * a {@link URI#getPath() path} component that is absolute. The query and\\n     * fragment components are undefined. Whether the authority component is\\n     * defined or not is implementation dependent. There is no guarantee that\\n     * the {@code URI} may be used to construct a {@link java.io.File java.io.File}.\\n     * In particular, if this path represents a Universal Naming Convention (UNC)\\n     * path, then the UNC server name may be encoded in the authority component\\n     * of the resulting URI. In the case of the default provider, and the file\\n     * exists, and it can be determined that the file is a directory, then the\\n     * resulting {@code URI} will end with a slash.\\n     *\\n     * \u003cp\u003e The default provider provides a similar \u003cem\u003eround-trip\u003c/em\u003e guarantee\\n     * to the {@link java.io.File} class. For a given {@code Path} \u003ci\u003ep\u003c/i\u003e it\\n     * is guaranteed that\\n     * \u003cblockquote\u003e\u003ctt\u003e\\n     * {@link Paths#get(URI) Paths.get}(\u003c/tt\u003e\u003ci\u003ep\u003c/i\u003e\u003ctt\u003e.toUri()).equals(\u003c/tt\u003e\u003ci\u003ep\u003c/i\u003e\\n     * \u003ctt\u003e.{@link #toAbsolutePath() toAbsolutePath}())\u003c/tt\u003e\\n     * \u003c/blockquote\u003e\\n     * so long as the original {@code Path}, the {@code URI}, and the new {@code\\n     * Path} are all created in (possibly different invocations of) the same\\n     * Java virtual machine. Whether other providers make any guarantees is\\n     * provider specific and therefore unspecified.\\n     *\\n     * \u003cp\u003e When a file system is constructed to access the contents of a file\\n     * as a file system then it is highly implementation specific if the returned\\n     * URI represents the given path in the file system or it represents a\\n     * \u003cem\u003ecompound\u003c/em\u003e URI that encodes the URI of the enclosing file system.\\n     * A format for compound URIs is not defined in this release; such a scheme\\n     * may be added in a future release.\\n     *\\n     * @return  the URI representing this path\\n     *\\n     * @throws  java.io.IOError\\n     *          if an I/O error occurs obtaining the absolute path, or where a\\n     *          file system is constructed to access the contents of a file as\\n     *          a file system, and the URI of the enclosing file system cannot be\\n     *          obtained\\n     *\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager\\n     *          is installed, the {@link #toAbsolutePath toAbsolutePath} method\\n     *          throws a security exception.\\n     \u0027}"}, {"color": "#97c2fc", "id": "get(URI)", "label": "get(URI)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.Paths", "label": "java.nio.file.Paths", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "public static Path get(String first, String... more)", "label": "public static Path get(String first, String... more)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Converts a path string, or a sequence of strings that when joined form\\n     * a path string, to a {@code Path}. If {@code more} does not specify any\\n     * elements then the value of the {@code first} parameter is the path string\\n     * to convert. If {@code more} specifies one or more elements then each\\n     * non-empty string, including {@code first}, is considered to be a sequence\\n     * of name elements (see {@link Path}) and is joined to form a path string.\\n     * The details as to how the Strings are joined is provider specific but\\n     * typically they will be joined using the {@link FileSystem#getSeparator\\n     * name-separator} as the separator. For example, if the name separator is\\n     * \"{@code /}\" and {@code getPath(\"/foo\",\"bar\",\"gus\")} is invoked, then the\\n     * path string {@code \"/foo/bar/gus\"} is converted to a {@code Path}.\\n     * A {@code Path} representing an empty path is returned if {@code first}\\n     * is the empty string and {@code more} does not contain any non-empty\\n     * strings.\\n     *\\n     * \u003cp\u003e The {@code Path} is obtained by invoking the {@link FileSystem#getPath\\n     * getPath} method of the {@link FileSystems#getDefault default} {@link\\n     * FileSystem}.\\n     *\\n     * \u003cp\u003e Note that while this method is very convenient, using it will imply\\n     * an assumed reference to the default {@code FileSystem} and limit the\\n     * utility of the calling code. Hence it should not be used in library code\\n     * intended for flexible reuse. A more flexible alternative is to use an\\n     * existing {@code Path} instance as an anchor, such as:\\n     * \u003cpre\u003e\\n     *     Path dir = ...\\n     *     Path path = dir.resolve(\"file\");\\n     * \u003c/pre\u003e\\n     *\\n     * @param   first\\n     *          the path string or initial part of the path string\\n     * @param   more\\n     *          additional strings to be joined to form the path string\\n     *\\n     * @return  the resulting {@code Path}\\n     *\\n     * @throws  InvalidPathException\\n     *          if the path string cannot be converted to a {@code Path}\\n     *\\n     * @see FileSystem#getPath\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Path get(URI uri)", "label": "public static Path get(URI uri)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Converts the given URI to a {@link Path} object.\\n     *\\n     * \u003cp\u003e This method iterates over the {@link FileSystemProvider#installedProviders()\\n     * installed} providers to locate the provider that is identified by the\\n     * URI {@link URI#getScheme scheme} of the given URI. URI schemes are\\n     * compared without regard to case. If the provider is found then its {@link\\n     * FileSystemProvider#getPath getPath} method is invoked to convert the\\n     * URI.\\n     *\\n     * \u003cp\u003e In the case of the default provider, identified by the URI scheme\\n     * \"file\", the given URI has a non-empty path component, and undefined query\\n     * and fragment components. Whether the authority component may be present\\n     * is platform specific. The returned {@code Path} is associated with the\\n     * {@link FileSystems#getDefault default} file system.\\n     *\\n     * \u003cp\u003e The default provider provides a similar \u003cem\u003eround-trip\u003c/em\u003e guarantee\\n     * to the {@link java.io.File} class. For a given {@code Path} \u003ci\u003ep\u003c/i\u003e it\\n     * is guaranteed that\\n     * \u003cblockquote\u003e\u003ctt\u003e\\n     * Paths.get(\u003c/tt\u003e\u003ci\u003ep\u003c/i\u003e\u003ctt\u003e.{@link Path#toUri() toUri}()).equals(\u003c/tt\u003e\\n     * \u003ci\u003ep\u003c/i\u003e\u003ctt\u003e.{@link Path#toAbsolutePath() toAbsolutePath}())\u003c/tt\u003e\\n     * \u003c/blockquote\u003e\\n     * so long as the original {@code Path}, the {@code URI}, and the new {@code\\n     * Path} are all created in (possibly different invocations of) the same\\n     * Java virtual machine. Whether other providers make any guarantees is\\n     * provider specific and therefore unspecified.\\n     *\\n     * @param   uri\\n     *          the URI to convert\\n     *\\n     * @return  the resulting {@code Path}\\n     *\\n     * @throws  IllegalArgumentException\\n     *          if preconditions on the {@code uri} parameter do not hold. The\\n     *          format of the URI is provider specific.\\n     * @throws  FileSystemNotFoundException\\n     *          The file system, identified by the URI, does not exist and\\n     *          cannot be created automatically, or the provider identified by\\n     *          the URI\\\u0027s scheme component is not installed\\n     * @throws  SecurityException\\n     *          if a security manager is installed and it denies an unspecified\\n     *          permission to access the file system\\n     \u0027}"}, {"color": "#97c2fc", "id": "toAbsolutePath", "label": "toAbsolutePath", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " Path toAbsolutePath()", "label": " Path toAbsolutePath()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a {@code Path} object representing the absolute path of this\\n     * path.\\n     *\\n     * \u003cp\u003e If this path is already {@link Path#isAbsolute absolute} then this\\n     * method simply returns this path. Otherwise, this method resolves the path\\n     * in an implementation dependent manner, typically by resolving the path\\n     * against a file system default directory. Depending on the implementation,\\n     * this method may throw an I/O error if the file system is not accessible.\\n     *\\n     * @return  a {@code Path} object representing the absolute path\\n     *\\n     * @throws  java.io.IOError\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, a security manager\\n     *          is installed, and this path is not absolute, then the security\\n     *          manager\u0027s {@link SecurityManager#checkPropertyAccess(String)\\n     *          checkPropertyAccess} method is invoked to check access to the\\n     *          system property {@code user.dir}\\n     \"}"}, {"color": "#97c2fc", "id": " Path toRealPath(LinkOption... options) throws IOException", "label": " Path toRealPath(LinkOption... options) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the \u003cem\u003ereal\u003c/em\u003e path of an existing file.\\n     *\\n     * \u003cp\u003e The precise definition of this method is implementation dependent but\\n     * in general it derives from this path, an {@link #isAbsolute absolute}\\n     * path that locates the {@link Files#isSameFile same} file as this path, but\\n     * with name elements that represent the actual name of the directories\\n     * and the file. For example, where filename comparisons on a file system\\n     * are case insensitive then the name elements represent the names in their\\n     * actual case. Additionally, the resulting path has redundant name\\n     * elements removed.\\n     *\\n     * \u003cp\u003e If this path is relative then its absolute path is first obtained,\\n     * as if by invoking the {@link #toAbsolutePath toAbsolutePath} method.\\n     *\\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\\n     * are handled. By default, symbolic links are resolved to their final\\n     * target. If the option {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} is\\n     * present then this method does not resolve symbolic links.\\n     *\\n     * Some implementations allow special names such as \"{@code ..}\" to refer to\\n     * the parent directory. When deriving the \u003cem\u003ereal path\u003c/em\u003e, and a\\n     * \"{@code ..}\" (or equivalent) is preceded by a non-\"{@code ..}\" name then\\n     * an implementation will typically cause both names to be removed. When\\n     * not resolving symbolic links and the preceding name is a symbolic link\\n     * then the names are only removed if it guaranteed that the resulting path\\n     * will locate the same file as this path.\\n     *\\n     * @param   options\\n     *          options indicating how symbolic links are handled\\n     *\\n     * @return  an absolute path represent the \u003cem\u003ereal\u003c/em\u003e path of the file\\n     *          located by this object\\n     *\\n     * @throws  IOException\\n     *          if the file does not exist or an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager\\n     *          is installed, its {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the file, and where\\n     *          this path is not absolute, its {@link SecurityManager#checkPropertyAccess(String)\\n     *          checkPropertyAccess} method is invoked to check access to the\\n     *          system property {@code user.dir}\\n     \u0027}"}, {"color": "#97c2fc", "id": " File toFile()", "label": " File toFile()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@link File} object representing this path. Where this {@code\\n     * Path} is associated with the default provider, then this method is\\n     * equivalent to returning a {@code File} object constructed with the\\n     * {@code String} representation of this path.\\n     *\\n     * \u003cp\u003e If this path was created by invoking the {@code File} {@link\\n     * File#toPath toPath} method then there is no guarantee that the {@code\\n     * File} object returned by this method is {@link #equals equal} to the\\n     * original {@code File}.\\n     *\\n     * @return  a {@code File} object representing this path\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if this {@code Path} is not associated with the default provider\\n     \u0027}"}, {"color": "#97c2fc", "id": " WatchKey register(WatchService watcher, WatchEvent.Kind\u003c?\u003e[] events, WatchEvent.Modifier... modifiers) throws IOException", "label": " WatchKey register(WatchService watcher, WatchEvent.Kind\u003c?\u003e[] events, WatchEvent.Modifier... modifiers) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Registers the file located by this path with a watch service.\\n     *\\n     * \u003cp\u003e In this release, this path locates a directory that exists. The\\n     * directory is registered with the watch service so that entries in the\\n     * directory can be watched. The {@code events} parameter is the events to\\n     * register and may contain the following events:\\n     * \u003cul\u003e\\n     *   \u003cli\u003e{@link StandardWatchEventKinds#ENTRY_CREATE ENTRY_CREATE} -\\n     *       entry created or moved into the directory\u003c/li\u003e\\n     *   \u003cli\u003e{@link StandardWatchEventKinds#ENTRY_DELETE ENTRY_DELETE} -\\n     *        entry deleted or moved out of the directory\u003c/li\u003e\\n     *   \u003cli\u003e{@link StandardWatchEventKinds#ENTRY_MODIFY ENTRY_MODIFY} -\\n     *        entry in directory was modified\u003c/li\u003e\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003e The {@link WatchEvent#context context} for these events is the\\n     * relative path between the directory located by this path, and the path\\n     * that locates the directory entry that is created, deleted, or modified.\\n     *\\n     * \u003cp\u003e The set of events may include additional implementation specific\\n     * event that are not defined by the enum {@link StandardWatchEventKinds}\\n     *\\n     * \u003cp\u003e The {@code modifiers} parameter specifies \u003cem\u003emodifiers\u003c/em\u003e that\\n     * qualify how the directory is registered. This release does not define any\\n     * \u003cem\u003estandard\u003c/em\u003e modifiers. It may contain implementation specific\\n     * modifiers.\\n     *\\n     * \u003cp\u003e Where a file is registered with a watch service by means of a symbolic\\n     * link then it is implementation specific if the watch continues to depend\\n     * on the existence of the symbolic link after it is registered.\\n     *\\n     * @param   watcher\\n     *          the watch service to which this object is to be registered\\n     * @param   events\\n     *          the events for which this object should be registered\\n     * @param   modifiers\\n     *          the modifiers, if any, that modify how the object is registered\\n     *\\n     * @return  a key representing the registration of this object with the\\n     *          given watch service\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          if unsupported events or modifiers are specified\\n     * @throws  IllegalArgumentException\\n     *          if an invalid combination of events or modifiers is specified\\n     * @throws  ClosedWatchServiceException\\n     *          if the watch service is closed\\n     * @throws  NotDirectoryException\\n     *          if the file is registered to watch the entries in a directory\\n     *          and the file is not a directory  \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          if an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "ENTRY_CREATE", "label": "ENTRY_CREATE", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.StandardWatchEventKinds", "label": "java.nio.file.StandardWatchEventKinds", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": "context", "label": "context", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.nio.file.WatchEvent", "label": "java.nio.file.WatchEvent", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\u0027}"}, {"color": "#97c2fc", "id": " Kind\u003cT\u003e kind()", "label": " Kind\u003cT\u003e kind()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the event kind.\\n     *\\n     * @return  the event kind\\n     \u0027}"}, {"color": "#97c2fc", "id": " int count()", "label": " int count()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the event count. If the event count is greater than {@code 1}\\n     * then this is a repeated event.\\n     *\\n     * @return  the event count\\n     \u0027}"}, {"color": "#97c2fc", "id": " T context()", "label": " T context()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the context for the event.\\n     *\\n     * \u003cp\u003e In the case of {@link StandardWatchEventKinds#ENTRY_CREATE ENTRY_CREATE},\\n     * {@link StandardWatchEventKinds#ENTRY_DELETE ENTRY_DELETE}, and {@link\\n     * StandardWatchEventKinds#ENTRY_MODIFY ENTRY_MODIFY} events the context is\\n     * a {@code Path} that is the {@link Path#relativize relative} path between\\n     * the directory registered with the watch service, and the entry that is\\n     * created, deleted, or modified.\\n     *\\n     * @return  the event context; may be {@code null}\\n     \u0027}"}, {"color": "#97c2fc", "id": " WatchKey register(WatchService watcher, WatchEvent.Kind\u003c?\u003e... events) throws IOException", "label": " WatchKey register(WatchService watcher, WatchEvent.Kind\u003c?\u003e... events) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Registers the file located by this path with a watch service.\\n     *\\n     * \u003cp\u003e An invocation of this method behaves in exactly the same way as the\\n     * invocation\\n     * \u003cpre\u003e\\n     *     watchable.{@link #register(WatchService,WatchEvent.Kind[],WatchEvent.Modifier[]) register}(watcher, events, new WatchEvent.Modifier[0]);\\n     * \u003c/pre\u003e\\n     *\\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\\n     * Suppose we wish to register a directory for entry create, delete, and modify\\n     * events:\\n     * \u003cpre\u003e\\n     *     Path dir = ...\\n     *     WatchService watcher = ...\\n     *\\n     *     WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\\n     * \u003c/pre\u003e\\n     * @param   watcher\\n     *          The watch service to which this object is to be registered\\n     * @param   events\\n     *          The events for which this object should be registered\\n     *\\n     * @return  A key representing the registration of this object with the\\n     *          given watch service\\n     *\\n     * @throws  UnsupportedOperationException\\n     *          If unsupported events are specified\\n     * @throws  IllegalArgumentException\\n     *          If an invalid combination of events is specified\\n     * @throws  ClosedWatchServiceException\\n     *          If the watch service is closed\\n     * @throws  NotDirectoryException\\n     *          If the file is registered to watch the entries in a directory\\n     *          and the file is not a directory  \u003ci\u003e(optional specific exception)\u003c/i\u003e\\n     * @throws  IOException\\n     *          If an I/O error occurs\\n     * @throws  SecurityException\\n     *          In the case of the default provider, and a security manager is\\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\\n     *          method is invoked to check read access to the file.\\n     \u0027}"}, {"color": "#97c2fc", "id": "register(WatchService", "label": "register(WatchService", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " Iterator\u003cPath\u003e iterator()", "label": " Iterator\u003cPath\u003e iterator()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an iterator over the name elements of this path.\\n     *\\n     * \u003cp\u003e The first element returned by the iterator represents the name\\n     * element that is closest to the root in the directory hierarchy, the\\n     * second element is the next closest, and so on. The last element returned\\n     * is the name of the file or directory denoted by this path. The {@link\\n     * #getRoot root} component, if present, is not returned by the iterator.\\n     *\\n     * @return  an iterator over the name elements of this path.\\n     \u0027}"}, {"color": "#97c2fc", "id": " int compareTo(Path other)", "label": " int compareTo(Path other)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two abstract paths lexicographically. The ordering defined by\\n     * this method is provider specific, and in the case of the default\\n     * provider, platform specific. This method does not access the file system\\n     * and neither file is required to exist.\\n     *\\n     * \u003cp\u003e This method may not be used to compare paths that are associated\\n     * with different file system providers.\\n     *\\n     * @param   other  the path compared to this path.\\n     *\\n     * @return  zero if the argument is {@link #equals equal} to this path, a\\n     *          value less than zero if this path is lexicographically less than\\n     *          the argument, or a value greater than zero if this path is\\n     *          lexicographically greater than the argument\\n     *\\n     * @throws  ClassCastException\\n     *          if the paths are associated with different providers\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean equals(Object other)", "label": " boolean equals(Object other)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests this path for equality with the given object.\\n     *\\n     * \u003cp\u003e If the given object is not a Path, or is a Path associated with a\\n     * different {@code FileSystem}, then this method returns {@code false}.\\n     *\\n     * \u003cp\u003e Whether or not two path are equal depends on the file system\\n     * implementation. In some cases the paths are compared without regard\\n     * to case, and others are case sensitive. This method does not access the\\n     * file system and the file is not required to exist. Where required, the\\n     * {@link Files#isSameFile isSameFile} method may be used to check if two\\n     * paths locate the same file.\\n     *\\n     * \u003cp\u003e This method satisfies the general contract of the {@link\\n     * java.lang.Object#equals(Object) Object.equals} method. \u003c/p\u003e\\n     *\\n     * @param   other\\n     *          the object to which this object is to be compared\\n     *\\n     * @return  {@code true} if, and only if, the given object is a {@code Path}\\n     *          that is identical to this {@code Path}\\n     \u0027}"}, {"color": "#97c2fc", "id": "hashCodeObject.hashCode", "label": "hashCodeObject.hashCode", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " String toString()", "label": " String toString()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the string representation of this path.\\n     *\\n     * \u003cp\u003e If this path was created by converting a path string using the\\n     * {@link FileSystem#getPath getPath} method then the path string returned\\n     * by this method may differ from the original String used to create the path.\\n     *\\n     * \u003cp\u003e The returned path string uses the default name {@link\\n     * FileSystem#getSeparator separator} to separate names in the path.\\n     *\\n     * @return  the string representation of this path\\n     \u0027}"}, {"color": "#97c2fc", "id": "toPath", "label": "toPath", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public boolean canRead()", "label": "public boolean canRead()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests whether the application can read the file denoted by this\\n     * abstract pathname.\\n     *\\n     * @return  \u003ccode\u003etrue\u003c/code\u003e if and only if the file specified by this\\n     *          abstract pathname exists \u003cem\u003eand\u003c/em\u003e can be read by the\\n     *          application; \u003ccode\u003efalse\u003c/code\u003e otherwise\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkRead(java.lang.String)}\u003c/code\u003e\\n     *          method denies read access to the file\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean canWrite()", "label": "public boolean canWrite()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests whether the application can modify the file denoted by this\\n     * abstract pathname.\\n     *\\n     * @return  \u003ccode\u003etrue\u003c/code\u003e if and only if the file system actually\\n     *          contains a file denoted by this abstract pathname \u003cem\u003eand\u003c/em\u003e\\n     *          the application is allowed to write to the file;\\n     *          \u003ccode\u003efalse\u003c/code\u003e otherwise.\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}\u003c/code\u003e\\n     *          method denies write access to the file\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean exists()", "label": "public boolean exists()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests whether the file or directory denoted by this abstract pathname\\n     * exists.\\n     *\\n     * @return  \u003ccode\u003etrue\u003c/code\u003e if and only if the file or directory denoted\\n     *          by this abstract pathname exists; \u003ccode\u003efalse\u003c/code\u003e otherwise\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkRead(java.lang.String)}\u003c/code\u003e\\n     *          method denies read access to the file or directory\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isDirectory()", "label": "public boolean isDirectory()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests whether the file denoted by this abstract pathname is a\\n     * directory.\\n     *\\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\\n     * that the file is not a directory, or where several attributes of the\\n     * same file are required at the same time, then the {@link\\n     * java.nio.file.Files#readAttributes(Path,Class,LinkOption[])\\n     * Files.readAttributes} method may be used.\\n     *\\n     * @return \u003ccode\u003etrue\u003c/code\u003e if and only if the file denoted by this\\n     *          abstract pathname exists \u003cem\u003eand\u003c/em\u003e is a directory;\\n     *          \u003ccode\u003efalse\u003c/code\u003e otherwise\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkRead(java.lang.String)}\u003c/code\u003e\\n     *          method denies read access to the file\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isFile()", "label": "public boolean isFile()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests whether the file denoted by this abstract pathname is a normal\\n     * file.  A file is \u003cem\u003enormal\u003c/em\u003e if it is not a directory and, in\\n     * addition, satisfies other system-dependent criteria.  Any non-directory\\n     * file created by a Java application is guaranteed to be a normal file.\\n     *\\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\\n     * that the file is not a normal file, or where several attributes of the\\n     * same file are required at the same time, then the {@link\\n     * java.nio.file.Files#readAttributes(Path,Class,LinkOption[])\\n     * Files.readAttributes} method may be used.\\n     *\\n     * @return  \u003ccode\u003etrue\u003c/code\u003e if and only if the file denoted by this\\n     *          abstract pathname exists \u003cem\u003eand\u003c/em\u003e is a normal file;\\n     *          \u003ccode\u003efalse\u003c/code\u003e otherwise\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkRead(java.lang.String)}\u003c/code\u003e\\n     *          method denies read access to the file\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isHidden()", "label": "public boolean isHidden()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Tests whether the file named by this abstract pathname is a hidden\\n     * file.  The exact definition of \u003cem\u003ehidden\u003c/em\u003e is system-dependent.  On\\n     * UNIX systems, a file is considered to be hidden if its name begins with\\n     * a period character (\u003ccode\u003e\u0027.\u0027\u003c/code\u003e).  On Microsoft Windows systems, a file is\\n     * considered to be hidden if it has been marked as such in the filesystem.\\n     *\\n     * @return  \u003ccode\u003etrue\u003c/code\u003e if and only if the file denoted by this\\n     *          abstract pathname is hidden according to the conventions of the\\n     *          underlying platform\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkRead(java.lang.String)}\u003c/code\u003e\\n     *          method denies read access to the file\\n     *\\n     * @since 1.2\\n     \"}"}, {"color": "#97c2fc", "id": "public long lastModified()", "label": "public long lastModified()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the time that the file denoted by this abstract pathname was\\n     * last modified.\\n     *\\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\\n     * where {@code 0L} is returned, or where several attributes of the\\n     * same file are required at the same time, or where the time of last\\n     * access or the creation time are required, then the {@link\\n     * java.nio.file.Files#readAttributes(Path,Class,LinkOption[])\\n     * Files.readAttributes} method may be used.\\n     *\\n     * @return  A \u003ccode\u003elong\u003c/code\u003e value representing the time the file was\\n     *          last modified, measured in milliseconds since the epoch\\n     *          (00:00:00 GMT, January 1, 1970), or \u003ccode\u003e0L\u003c/code\u003e if the\\n     *          file does not exist or if an I/O error occurs\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkRead(java.lang.String)}\u003c/code\u003e\\n     *          method denies read access to the file\\n     \u0027}"}, {"color": "#97c2fc", "id": "public long length()", "label": "public long length()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the length of the file denoted by this abstract pathname.\\n     * The return value is unspecified if this pathname denotes a directory.\\n     *\\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\\n     * that {@code 0L} is returned, or where several attributes of the same file\\n     * are required at the same time, then the {@link\\n     * java.nio.file.Files#readAttributes(Path,Class,LinkOption[])\\n     * Files.readAttributes} method may be used.\\n     *\\n     * @return  The length, in bytes, of the file denoted by this abstract\\n     *          pathname, or \u003ccode\u003e0L\u003c/code\u003e if the file does not exist.  Some\\n     *          operating systems may return \u003ccode\u003e0L\u003c/code\u003e for pathnames\\n     *          denoting system-dependent entities such as devices or pipes.\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkRead(java.lang.String)}\u003c/code\u003e\\n     *          method denies read access to the file\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean createNewFile() throws IOException", "label": "public boolean createNewFile() throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Atomically creates a new, empty file named by this abstract pathname if\\n     * and only if a file with this name does not yet exist.  The check for the\\n     * existence of the file and the creation of the file if it does not exist\\n     * are a single operation that is atomic with respect to all other\\n     * filesystem activities that might affect the file.\\n     * \u003cP\u003e\\n     * Note: this method should \u003ci\u003enot\u003c/i\u003e be used for file-locking, as\\n     * the resulting protocol cannot be made to work reliably. The\\n     * {@link java.nio.channels.FileLock FileLock}\\n     * facility should be used instead.\\n     *\\n     * @return  \u003ccode\u003etrue\u003c/code\u003e if the named file does not exist and was\\n     *          successfully created; \u003ccode\u003efalse\u003c/code\u003e if the named file\\n     *          already exists\\n     *\\n     * @throws  IOException\\n     *          If an I/O error occurred\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}\u003c/code\u003e\\n     *          method denies write access to the file\\n     *\\n     * @since 1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean delete()", "label": "public boolean delete()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Deletes the file or directory denoted by this abstract pathname.  If\\n     * this pathname denotes a directory, then the directory must be empty in\\n     * order to be deleted.\\n     *\\n     * \u003cp\u003e Note that the {@link java.nio.file.Files} class defines the {@link\\n     * java.nio.file.Files#delete(Path) delete} method to throw an {@link IOException}\\n     * when a file cannot be deleted. This is useful for error reporting and to\\n     * diagnose why a file cannot be deleted.\\n     *\\n     * @return  \u003ccode\u003etrue\u003c/code\u003e if and only if the file or directory is\\n     *          successfully deleted; \u003ccode\u003efalse\u003c/code\u003e otherwise\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkDelete}\u003c/code\u003e method denies\\n     *          delete access to the file\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void deleteOnExit()", "label": "public void deleteOnExit()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Requests that the file or directory denoted by this abstract\\n     * pathname be deleted when the virtual machine terminates.\\n     * Files (or directories) are deleted in the reverse order that\\n     * they are registered. Invoking this method to delete a file or\\n     * directory that is already registered for deletion has no effect.\\n     * Deletion will be attempted only for normal termination of the\\n     * virtual machine, as defined by the Java Language Specification.\\n     *\\n     * \u003cp\u003e Once deletion has been requested, it is not possible to cancel the\\n     * request.  This method should therefore be used with care.\\n     *\\n     * \u003cP\u003e\\n     * Note: this method should \u003ci\u003enot\u003c/i\u003e be used for file-locking, as\\n     * the resulting protocol cannot be made to work reliably. The\\n     * {@link java.nio.channels.FileLock FileLock}\\n     * facility should be used instead.\\n     *\\n     * \u003cp\u003e\u003ci\u003eNote that on Android, the application lifecycle does not include VM termination,\\n     * so calling this method will not ensure that files are deleted\u003c/i\u003e. Instead, you should\\n     * use the most appropriate out of:\\n     * \u003cul\u003e\\n     * \u003cli\u003eUse a {@code finally} clause to manually invoke {@link #delete}.\\n     * \u003cli\u003eMaintain your own set of files to delete, and process it at an appropriate point\\n     * in your application\u0027s lifecycle.\\n     * \u003cli\u003eUse the Unix trick of deleting the file as soon as all readers and writers have\\n     * opened it. No new readers/writers will be able to access the file, but all existing\\n     * ones will still have access until the last one closes the file.\\n     * \u003c/ul\u003e\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkDelete}\u003c/code\u003e method denies\\n     *          delete access to the file\\n     *\\n     * @see #delete\\n     *\\n     * @since 1.2\\n     \"}"}, {"color": "#97c2fc", "id": "public String[] list()", "label": "public String[] list()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns an array of strings naming the files and directories in the\\n     * directory denoted by this abstract pathname.\\n     *\\n     * \u003cp\u003e If this abstract pathname does not denote a directory, then this\\n     * method returns {@code null}.  Otherwise an array of strings is\\n     * returned, one for each file or directory in the directory.  Names\\n     * denoting the directory itself and the directory\u0027s parent directory are\\n     * not included in the result.  Each string is a file name rather than a\\n     * complete path.\\n     *\\n     * \u003cp\u003e There is no guarantee that the name strings in the resulting array\\n     * will appear in any specific order; they are not, in particular,\\n     * guaranteed to appear in alphabetical order.\\n     *\\n     * \u003cp\u003e Note that the {@link java.nio.file.Files} class defines the {@link\\n     * java.nio.file.Files#newDirectoryStream(Path) newDirectoryStream} method to\\n     * open a directory and iterate over the names of the files in the directory.\\n     * This may use less resources when working with very large directories, and\\n     * may be more responsive when working with remote directories.\\n     *\\n     * @return  An array of strings naming the files and directories in the\\n     *          directory denoted by this abstract pathname.  The array will be\\n     *          empty if the directory is empty.  Returns {@code null} if\\n     *          this abstract pathname does not denote a directory, or if an\\n     *          I/O error occurs.\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its {@link\\n     *          SecurityManager#checkRead(String)} method denies read access to\\n     *          the directory\\n     \"}"}, {"color": "#97c2fc", "id": "public String[] list(FilenameFilter filter)", "label": "public String[] list(FilenameFilter filter)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an array of strings naming the files and directories in the\\n     * directory denoted by this abstract pathname that satisfy the specified\\n     * filter.  The behavior of this method is the same as that of the\\n     * {@link #list()} method, except that the strings in the returned array\\n     * must satisfy the filter.  If the given {@code filter} is {@code null}\\n     * then all names are accepted.  Otherwise, a name satisfies the filter if\\n     * and only if the value {@code true} results when the {@link\\n     * FilenameFilter#accept FilenameFilter.accept(File,\u0026nbsp;String)} method\\n     * of the filter is invoked on this abstract pathname and the name of a\\n     * file or directory in the directory that it denotes.\\n     *\\n     * @param  filter\\n     *         A filename filter\\n     *\\n     * @return  An array of strings naming the files and directories in the\\n     *          directory denoted by this abstract pathname that were accepted\\n     *          by the given {@code filter}.  The array will be empty if the\\n     *          directory is empty or if no names were accepted by the filter.\\n     *          Returns {@code null} if this abstract pathname does not denote\\n     *          a directory, or if an I/O error occurs.\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its {@link\\n     *          SecurityManager#checkRead(String)} method denies read access to\\n     *          the directory\\n     *\\n     * @see java.nio.file.Files#newDirectoryStream(Path,String)\\n     \u0027}"}, {"color": "#97c2fc", "id": "list()", "label": "list()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.io.FilenameFilter", "label": "java.io.FilenameFilter", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \"\\n * Instances of classes that implement this interface are used to\\n * filter filenames. These instances are used to filter directory\\n * listings in the \u003ccode\u003elist\u003c/code\u003e method of class\\n * \u003ccode\u003eFile\u003c/code\u003e, and by the Abstract Window Toolkit\u0027s file\\n * dialog component.\\n *\\n * @author  Arthur van Hoff\\n * @author  Jonathan Payne\\n * @see     java.io.File\\n * @see     java.io.File#list(java.io.FilenameFilter)\\n * @since   1.0\\n \"}"}, {"color": "#97c2fc", "id": " boolean accept(File dir, String name)", "label": " boolean accept(File dir, String name)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests if a specified file should be included in a file list.\\n     *\\n     * @param   dir    the directory in which the file was found.\\n     * @param   name   the name of the file.\\n     * @return  \u003ccode\u003etrue\u003c/code\u003e if and only if the name should be\\n     * included in the file list; \u003ccode\u003efalse\u003c/code\u003e otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public File[] listFiles()", "label": "public File[] listFiles()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns an array of abstract pathnames denoting the files in the\\n     * directory denoted by this abstract pathname.\\n     *\\n     * \u003cp\u003e If this abstract pathname does not denote a directory, then this\\n     * method returns {@code null}.  Otherwise an array of {@code File} objects\\n     * is returned, one for each file or directory in the directory.  Pathnames\\n     * denoting the directory itself and the directory\u0027s parent directory are\\n     * not included in the result.  Each resulting abstract pathname is\\n     * constructed from this abstract pathname using the {@link #File(File,\\n     * String) File(File,\u0026nbsp;String)} constructor.  Therefore if this\\n     * pathname is absolute then each resulting pathname is absolute; if this\\n     * pathname is relative then each resulting pathname will be relative to\\n     * the same directory.\\n     *\\n     * \u003cp\u003e There is no guarantee that the name strings in the resulting array\\n     * will appear in any specific order; they are not, in particular,\\n     * guaranteed to appear in alphabetical order.\\n     *\\n     * \u003cp\u003e Note that the {@link java.nio.file.Files} class defines the {@link\\n     * java.nio.file.Files#newDirectoryStream(Path) newDirectoryStream} method\\n     * to open a directory and iterate over the names of the files in the\\n     * directory. This may use less resources when working with very large\\n     * directories.\\n     *\\n     * @return  An array of abstract pathnames denoting the files and\\n     *          directories in the directory denoted by this abstract pathname.\\n     *          The array will be empty if the directory is empty.  Returns\\n     *          {@code null} if this abstract pathname does not denote a\\n     *          directory, or if an I/O error occurs.\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its {@link\\n     *          SecurityManager#checkRead(String)} method denies read access to\\n     *          the directory\\n     *\\n     * @since  1.2\\n     \"}"}, {"color": "#97c2fc", "id": "File(File", "label": "File(File", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public File[] listFiles(FilenameFilter filter)", "label": "public File[] listFiles(FilenameFilter filter)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an array of abstract pathnames denoting the files and\\n     * directories in the directory denoted by this abstract pathname that\\n     * satisfy the specified filter.  The behavior of this method is the same\\n     * as that of the {@link #listFiles()} method, except that the pathnames in\\n     * the returned array must satisfy the filter.  If the given {@code filter}\\n     * is {@code null} then all pathnames are accepted.  Otherwise, a pathname\\n     * satisfies the filter if and only if the value {@code true} results when\\n     * the {@link FilenameFilter#accept\\n     * FilenameFilter.accept(File,\u0026nbsp;String)} method of the filter is\\n     * invoked on this abstract pathname and the name of a file or directory in\\n     * the directory that it denotes.\\n     *\\n     * @param  filter\\n     *         A filename filter\\n     *\\n     * @return  An array of abstract pathnames denoting the files and\\n     *          directories in the directory denoted by this abstract pathname.\\n     *          The array will be empty if the directory is empty.  Returns\\n     *          {@code null} if this abstract pathname does not denote a\\n     *          directory, or if an I/O error occurs.\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its {@link\\n     *          SecurityManager#checkRead(String)} method denies read access to\\n     *          the directory\\n     *\\n     * @since  1.2\\n     * @see java.nio.file.Files#newDirectoryStream(Path,String)\\n     \u0027}"}, {"color": "#97c2fc", "id": "listFiles()", "label": "listFiles()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public File[] listFiles(FileFilter filter)", "label": "public File[] listFiles(FileFilter filter)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an array of abstract pathnames denoting the files and\\n     * directories in the directory denoted by this abstract pathname that\\n     * satisfy the specified filter.  The behavior of this method is the same\\n     * as that of the {@link #listFiles()} method, except that the pathnames in\\n     * the returned array must satisfy the filter.  If the given {@code filter}\\n     * is {@code null} then all pathnames are accepted.  Otherwise, a pathname\\n     * satisfies the filter if and only if the value {@code true} results when\\n     * the {@link FileFilter#accept FileFilter.accept(File)} method of the\\n     * filter is invoked on the pathname.\\n     *\\n     * @param  filter\\n     *         A file filter\\n     *\\n     * @return  An array of abstract pathnames denoting the files and\\n     *          directories in the directory denoted by this abstract pathname.\\n     *          The array will be empty if the directory is empty.  Returns\\n     *          {@code null} if this abstract pathname does not denote a\\n     *          directory, or if an I/O error occurs.\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its {@link\\n     *          SecurityManager#checkRead(String)} method denies read access to\\n     *          the directory\\n     *\\n     * @since  1.2\\n     * @see java.nio.file.Files#newDirectoryStream(Path,java.nio.file.DirectoryStream.Filter)\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.io.FileFilter", "label": "java.io.FileFilter", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * A filter for abstract pathnames.\\n *\\n * \u003cp\u003e Instances of this interface may be passed to the \u003ccode\u003e{@link\\n * File#listFiles(java.io.FileFilter) listFiles(FileFilter)}\u003c/code\u003e method\\n * of the \u003ccode\u003e{@link java.io.File}\u003c/code\u003e class.\\n *\\n * @since 1.2\\n \u0027}"}, {"color": "#97c2fc", "id": " boolean accept(File pathname)", "label": " boolean accept(File pathname)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests whether or not the specified abstract pathname should be\\n     * included in a pathname list.\\n     *\\n     * @param  pathname  The abstract pathname to be tested\\n     * @return  \u003ccode\u003etrue\u003c/code\u003e if and only if \u003ccode\u003epathname\u003c/code\u003e\\n     *          should be included\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean mkdir()", "label": "public boolean mkdir()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates the directory named by this abstract pathname.\\n     *\\n     * @return  \u003ccode\u003etrue\u003c/code\u003e if and only if the directory was\\n     *          created; \u003ccode\u003efalse\u003c/code\u003e otherwise\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}\u003c/code\u003e\\n     *          method does not permit the named directory to be created\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean mkdirs()", "label": "public boolean mkdirs()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates the directory named by this abstract pathname, including any\\n     * necessary but nonexistent parent directories.  Note that if this\\n     * operation fails it may have succeeded in creating some of the necessary\\n     * parent directories.\\n     *\\n     * @return  \u003ccode\u003etrue\u003c/code\u003e if and only if the directory was created,\\n     *          along with all necessary parent directories; \u003ccode\u003efalse\u003c/code\u003e\\n     *          otherwise\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkRead(java.lang.String)}\u003c/code\u003e\\n     *          method does not permit verification of the existence of the\\n     *          named directory and all necessary parent directories; or if\\n     *          the \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}\u003c/code\u003e\\n     *          method does not permit the named directory and all necessary\\n     *          parent directories to be created\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean renameTo(File dest)", "label": "public boolean renameTo(File dest)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Renames the file denoted by this abstract pathname.\\n     *\\n     * \u003cp\u003eMany failures are possible. Some of the more likely failures include:\\n     * \u003cul\u003e\\n     * \u003cli\u003eWrite permission is required on the directories containing both the source and\\n     * destination paths.\\n     * \u003cli\u003eSearch permission is required for all parents of both paths.\\n     * \u003cli\u003eBoth paths be on the same mount point. On Android, applications are most likely to hit\\n     * this restriction when attempting to copy between internal storage and an SD card.\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003eThe return value should always be checked to make sure\\n     * that the rename operation was successful.\\n     *\\n     * \u003cp\u003e Note that the {@link java.nio.file.Files} class defines the {@link\\n     * java.nio.file.Files#move move} method to move or rename a file in a\\n     * platform independent manner.\\n     *\\n     * @param  dest  The new abstract pathname for the named file\\n     *\\n     * @return  \u003ccode\u003etrue\u003c/code\u003e if and only if the renaming succeeded;\\n     *          \u003ccode\u003efalse\u003c/code\u003e otherwise\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}\u003c/code\u003e\\n     *          method denies write access to either the old or new pathnames\\n     *\\n     * @throws  NullPointerException\\n     *          If parameter \u003ccode\u003edest\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean setLastModified(long time)", "label": "public boolean setLastModified(long time)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the last-modified time of the file or directory named by this\\n     * abstract pathname.\\n     *\\n     * \u003cp\u003e All platforms support file-modification times to the nearest second,\\n     * but some provide more precision.  The argument will be truncated to fit\\n     * the supported precision.  If the operation succeeds and no intervening\\n     * operations on the file take place, then the next invocation of the\\n     * \u003ccode\u003e{@link #lastModified}\u003c/code\u003e method will return the (possibly\\n     * truncated) \u003ccode\u003etime\u003c/code\u003e argument that was passed to this method.\\n     *\\n     * @param  time  The new last-modified time, measured in milliseconds since\\n     *               the epoch (00:00:00 GMT, January 1, 1970)\\n     *\\n     * @return \u003ccode\u003etrue\u003c/code\u003e if and only if the operation succeeded;\\n     *          \u003ccode\u003efalse\u003c/code\u003e otherwise\\n     *\\n     * @throws  IllegalArgumentException  If the argument is negative\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}\u003c/code\u003e\\n     *          method denies write access to the named file\\n     *\\n     * @since 1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "lastModified", "label": "lastModified", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public boolean setReadOnly()", "label": "public boolean setReadOnly()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Marks the file or directory named by this abstract pathname so that\\n     * only read operations are allowed. After invoking this method the file\\n     * or directory will not change until it is either deleted or marked\\n     * to allow write access. Whether or not a read-only file or\\n     * directory may be deleted depends upon the underlying system.\\n     *\\n     * @return \u003ccode\u003etrue\u003c/code\u003e if and only if the operation succeeded;\\n     *          \u003ccode\u003efalse\u003c/code\u003e otherwise\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}\u003c/code\u003e\\n     *          method denies write access to the named file\\n     *\\n     * @since 1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean setWritable(boolean writable, boolean ownerOnly)", "label": "public boolean setWritable(boolean writable, boolean ownerOnly)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Sets the owner\u0027s or everybody\u0027s write permission for this abstract\\n     * pathname.\\n     *\\n     * \u003cp\u003e The {@link java.nio.file.Files} class defines methods that operate on\\n     * file attributes including file permissions. This may be used when finer\\n     * manipulation of file permissions is required.\\n     *\\n     * @param   writable\\n     *          If \u003ccode\u003etrue\u003c/code\u003e, sets the access permission to allow write\\n     *          operations; if \u003ccode\u003efalse\u003c/code\u003e to disallow write operations\\n     *\\n     * @param   ownerOnly\\n     *          If \u003ccode\u003etrue\u003c/code\u003e, the write permission applies only to the\\n     *          owner\u0027s write permission; otherwise, it applies to everybody.  If\\n     *          the underlying file system can not distinguish the owner\u0027s write\\n     *          permission from that of others, then the permission will apply to\\n     *          everybody, regardless of this value.\\n     *\\n     * @return  \u003ccode\u003etrue\u003c/code\u003e if and only if the operation succeeded. The\\n     *          operation will fail if the user does not have permission to change\\n     *          the access permissions of this abstract pathname.\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}\u003c/code\u003e\\n     *          method denies write access to the named file\\n     *\\n     * @since 1.6\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean setWritable(boolean writable)", "label": "public boolean setWritable(boolean writable)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * A convenience method to set the owner\u0027s write permission for this abstract\\n     * pathname.\\n     *\\n     * \u003cp\u003e An invocation of this method of the form \u003ctt\u003efile.setWritable(arg)\u003c/tt\u003e\\n     * behaves in exactly the same way as the invocation\\n     *\\n     * \u003cpre\u003e\\n     *     file.setWritable(arg, true) \u003c/pre\u003e\\n     *\\n     * @param   writable\\n     *          If \u003ccode\u003etrue\u003c/code\u003e, sets the access permission to allow write\\n     *          operations; if \u003ccode\u003efalse\u003c/code\u003e to disallow write operations\\n     *\\n     * @return  \u003ccode\u003etrue\u003c/code\u003e if and only if the operation succeeded.  The\\n     *          operation will fail if the user does not have permission to\\n     *          change the access permissions of this abstract pathname.\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}\u003c/code\u003e\\n     *          method denies write access to the file\\n     *\\n     * @since 1.6\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean setReadable(boolean readable, boolean ownerOnly)", "label": "public boolean setReadable(boolean readable, boolean ownerOnly)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Sets the owner\u0027s or everybody\u0027s read permission for this abstract\\n     * pathname.\\n     *\\n     * \u003cp\u003e The {@link java.nio.file.Files} class defines methods that operate on\\n     * file attributes including file permissions. This may be used when finer\\n     * manipulation of file permissions is required.\\n     *\\n     * @param   readable\\n     *          If \u003ccode\u003etrue\u003c/code\u003e, sets the access permission to allow read\\n     *          operations; if \u003ccode\u003efalse\u003c/code\u003e to disallow read operations\\n     *\\n     * @param   ownerOnly\\n     *          If \u003ccode\u003etrue\u003c/code\u003e, the read permission applies only to the\\n     *          owner\u0027s read permission; otherwise, it applies to everybody.  If\\n     *          the underlying file system can not distinguish the owner\u0027s read\\n     *          permission from that of others, then the permission will apply to\\n     *          everybody, regardless of this value.\\n     *\\n     * @return  \u003ccode\u003etrue\u003c/code\u003e if and only if the operation succeeded.  The\\n     *          operation will fail if the user does not have permission to\\n     *          change the access permissions of this abstract pathname.  If\\n     *          \u003ccode\u003ereadable\u003c/code\u003e is \u003ccode\u003efalse\u003c/code\u003e and the underlying\\n     *          file system does not implement a read permission, then the\\n     *          operation will fail.\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}\u003c/code\u003e\\n     *          method denies write access to the file\\n     *\\n     * @since 1.6\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean setReadable(boolean readable)", "label": "public boolean setReadable(boolean readable)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * A convenience method to set the owner\u0027s read permission for this abstract\\n     * pathname.\\n     *\\n     * \u003cp\u003eAn invocation of this method of the form \u003ctt\u003efile.setReadable(arg)\u003c/tt\u003e\\n     * behaves in exactly the same way as the invocation\\n     *\\n     * \u003cpre\u003e\\n     *     file.setReadable(arg, true) \u003c/pre\u003e\\n     *\\n     * @param  readable\\n     *          If \u003ccode\u003etrue\u003c/code\u003e, sets the access permission to allow read\\n     *          operations; if \u003ccode\u003efalse\u003c/code\u003e to disallow read operations\\n     *\\n     * @return  \u003ccode\u003etrue\u003c/code\u003e if and only if the operation succeeded.  The\\n     *          operation will fail if the user does not have permission to\\n     *          change the access permissions of this abstract pathname.  If\\n     *          \u003ccode\u003ereadable\u003c/code\u003e is \u003ccode\u003efalse\u003c/code\u003e and the underlying\\n     *          file system does not implement a read permission, then the\\n     *          operation will fail.\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}\u003c/code\u003e\\n     *          method denies write access to the file\\n     *\\n     * @since 1.6\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean setExecutable(boolean executable, boolean ownerOnly)", "label": "public boolean setExecutable(boolean executable, boolean ownerOnly)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Sets the owner\u0027s or everybody\u0027s execute permission for this abstract\\n     * pathname.\\n     *\\n     * \u003cp\u003e The {@link java.nio.file.Files} class defines methods that operate on\\n     * file attributes including file permissions. This may be used when finer\\n     * manipulation of file permissions is required.\\n     *\\n     * @param   executable\\n     *          If \u003ccode\u003etrue\u003c/code\u003e, sets the access permission to allow execute\\n     *          operations; if \u003ccode\u003efalse\u003c/code\u003e to disallow execute operations\\n     *\\n     * @param   ownerOnly\\n     *          If \u003ccode\u003etrue\u003c/code\u003e, the execute permission applies only to the\\n     *          owner\u0027s execute permission; otherwise, it applies to everybody.\\n     *          If the underlying file system can not distinguish the owner\u0027s\\n     *          execute permission from that of others, then the permission will\\n     *          apply to everybody, regardless of this value.\\n     *\\n     * @return  \u003ccode\u003etrue\u003c/code\u003e if and only if the operation succeeded.  The\\n     *          operation will fail if the user does not have permission to\\n     *          change the access permissions of this abstract pathname.  If\\n     *          \u003ccode\u003eexecutable\u003c/code\u003e is \u003ccode\u003efalse\u003c/code\u003e and the underlying\\n     *          file system does not implement an execute permission, then the\\n     *          operation will fail.\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}\u003c/code\u003e\\n     *          method denies write access to the file\\n     *\\n     * @since 1.6\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean setExecutable(boolean executable)", "label": "public boolean setExecutable(boolean executable)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * A convenience method to set the owner\u0027s execute permission for this\\n     * abstract pathname.\\n     *\\n     * \u003cp\u003eAn invocation of this method of the form \u003ctt\u003efile.setExcutable(arg)\u003c/tt\u003e\\n     * behaves in exactly the same way as the invocation\\n     *\\n     * \u003cpre\u003e\\n     *     file.setExecutable(arg, true) \u003c/pre\u003e\\n     *\\n     * @param   executable\\n     *          If \u003ccode\u003etrue\u003c/code\u003e, sets the access permission to allow execute\\n     *          operations; if \u003ccode\u003efalse\u003c/code\u003e to disallow execute operations\\n     *\\n     * @return   \u003ccode\u003etrue\u003c/code\u003e if and only if the operation succeeded.  The\\n     *           operation will fail if the user does not have permission to\\n     *           change the access permissions of this abstract pathname.  If\\n     *           \u003ccode\u003eexecutable\u003c/code\u003e is \u003ccode\u003efalse\u003c/code\u003e and the underlying\\n     *           file system does not implement an execute permission, then the\\n     *           operation will fail.\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}\u003c/code\u003e\\n     *          method denies write access to the file\\n     *\\n     * @since 1.6\\n     \"}"}, {"color": "#97c2fc", "id": "public boolean canExecute()", "label": "public boolean canExecute()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Tests whether the application can execute the file denoted by this\\n     * abstract pathname.\\n     *\\n     * @return  \u003ccode\u003etrue\u003c/code\u003e if and only if the abstract pathname exists\\n     *          \u003cem\u003eand\u003c/em\u003e the application is allowed to execute the file\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkExec(java.lang.String)}\u003c/code\u003e\\n     *          method denies execute access to the file\\n     *\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static File[] listRoots()", "label": "public static File[] listRoots()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the file system roots. On Android and other Unix systems, there is\\n     * a single root, {@code /}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public long getTotalSpace()", "label": "public long getTotalSpace()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the size of the partition \u003ca href=\"#partName\"\u003enamed\u003c/a\u003e by this\\n     * abstract pathname.\\n     *\\n     * @return  The size, in bytes, of the partition or \u003ctt\u003e0L\u003c/tt\u003e if this\\n     *          abstract pathname does not name a partition\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager has been installed and it denies\\n     *          {@link RuntimePermission}\u003ctt\u003e(\"getFileSystemAttributes\")\u003c/tt\u003e\\n     *          or its {@link SecurityManager#checkRead(String)} method denies\\n     *          read access to the file named by this abstract pathname\\n     *\\n     * @since  1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "public long getFreeSpace()", "label": "public long getFreeSpace()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the number of unallocated bytes in the partition \u003ca\\n     * href=\"#partName\"\u003enamed\u003c/a\u003e by this abstract path name.\\n     *\\n     * \u003cp\u003e The returned number of unallocated bytes is a hint, but not\\n     * a guarantee, that it is possible to use most or any of these\\n     * bytes.  The number of unallocated bytes is most likely to be\\n     * accurate immediately after this call.  It is likely to be made\\n     * inaccurate by any external I/O operations including those made\\n     * on the system outside of this virtual machine.  This method\\n     * makes no guarantee that write operations to this file system\\n     * will succeed.\\n     *\\n     * @return  The number of unallocated bytes on the partition or \u003ctt\u003e0L\u003c/tt\u003e\\n     *          if the abstract pathname does not name a partition.  This\\n     *          value will be less than or equal to the total file system size\\n     *          returned by {@link #getTotalSpace}.\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager has been installed and it denies\\n     *          {@link RuntimePermission}\u003ctt\u003e(\"getFileSystemAttributes\")\u003c/tt\u003e\\n     *          or its {@link SecurityManager#checkRead(String)} method denies\\n     *          read access to the file named by this abstract pathname\\n     *\\n     * @since  1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "getTotalSpace", "label": "getTotalSpace", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public long getUsableSpace()", "label": "public long getUsableSpace()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the number of bytes available to this virtual machine on the\\n     * partition \u003ca href=\"#partName\"\u003enamed\u003c/a\u003e by this abstract pathname.  When\\n     * possible, this method checks for write permissions and other operating\\n     * system restrictions and will therefore usually provide a more accurate\\n     * estimate of how much new data can actually be written than {@link\\n     * #getFreeSpace}.\\n     *\\n     * \u003cp\u003e The returned number of available bytes is a hint, but not a\\n     * guarantee, that it is possible to use most or any of these bytes.  The\\n     * number of unallocated bytes is most likely to be accurate immediately\\n     * after this call.  It is likely to be made inaccurate by any external\\n     * I/O operations including those made on the system outside of this\\n     * virtual machine.  This method makes no guarantee that write operations\\n     * to this file system will succeed.\\n     *\\n     * \u003cp\u003e On Android (and other Unix-based systems), this method returns the number of free bytes\\n     * available to non-root users, regardless of whether you\\\u0027re actually running as root,\\n     * and regardless of any quota or other restrictions that might apply to the user.\\n     * (The {@code getFreeSpace} method returns the number of bytes potentially available to root.)\\n     *\\n     * @return  The number of available bytes on the partition or \u003ctt\u003e0L\u003c/tt\u003e\\n     *          if the abstract pathname does not name a partition.  On\\n     *          systems where this information is not available, this method\\n     *          will be equivalent to a call to {@link #getFreeSpace}.\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager has been installed and it denies\\n     *          {@link RuntimePermission}\u003ctt\u003e(\"getFileSystemAttributes\")\u003c/tt\u003e\\n     *          or its {@link SecurityManager#checkRead(String)} method denies\\n     *          read access to the file named by this abstract pathname\\n     *\\n     * @since  1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "getFreeSpace", "label": "getFreeSpace", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static File createTempFile(String prefix, String suffix, File directory) throws IOException", "label": "public static File createTempFile(String prefix, String suffix, File directory) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * \u003cp\u003e Creates a new empty file in the specified directory, using the\\n     * given prefix and suffix strings to generate its name.  If this method\\n     * returns successfully then it is guaranteed that:\\n     *\\n     * \u003col\u003e\\n     * \u003cli\u003e The file denoted by the returned abstract pathname did not exist\\n     *      before this method was invoked, and\\n     * \u003cli\u003e Neither this method nor any of its variants will return the same\\n     *      abstract pathname again in the current invocation of the virtual\\n     *      machine.\\n     * \u003c/ol\u003e\\n     *\\n     * This method provides only part of a temporary-file facility.  To arrange\\n     * for a file created by this method to be deleted automatically, use the\\n     * \u003ccode\u003e{@link #deleteOnExit}\u003c/code\u003e method.\\n     *\\n     * \u003cp\u003e The \u003ccode\u003eprefix\u003c/code\u003e argument must be at least three characters\\n     * long.  It is recommended that the prefix be a short, meaningful string\\n     * such as \u003ccode\u003e\"hjb\"\u003c/code\u003e or \u003ccode\u003e\"mail\"\u003c/code\u003e.  The\\n     * \u003ccode\u003esuffix\u003c/code\u003e argument may be \u003ccode\u003enull\u003c/code\u003e, in which case the\\n     * suffix \u003ccode\u003e\".tmp\"\u003c/code\u003e will be used.\\n     *\\n     * \u003cp\u003e To create the new file, the prefix and the suffix may first be\\n     * adjusted to fit the limitations of the underlying platform.  If the\\n     * prefix is too long then it will be truncated, but its first three\\n     * characters will always be preserved.  If the suffix is too long then it\\n     * too will be truncated, but if it begins with a period character\\n     * (\u003ccode\u003e\\\u0027.\\\u0027\u003c/code\u003e) then the period and the first three characters\\n     * following it will always be preserved.  Once these adjustments have been\\n     * made the name of the new file will be generated by concatenating the\\n     * prefix, five or more internally-generated characters, and the suffix.\\n     *\\n     * \u003cp\u003e If the \u003ccode\u003edirectory\u003c/code\u003e argument is \u003ccode\u003enull\u003c/code\u003e then the\\n     * system-dependent default temporary-file directory will be used.  The\\n     * default temporary-file directory is specified by the system property\\n     * \u003ccode\u003ejava.io.tmpdir\u003c/code\u003e.  On UNIX systems the default value of this\\n     * property is typically \u003ccode\u003e\"/tmp\"\u003c/code\u003e or \u003ccode\u003e\"/var/tmp\"\u003c/code\u003e; on\\n     * Microsoft Windows systems it is typically \u003ccode\u003e\"C:\\\\\\\\WINNT\\\\\\\\TEMP\"\u003c/code\u003e.  A different\\n     * value may be given to this system property when the Java virtual machine\\n     * is invoked, but programmatic changes to this property are not guaranteed\\n     * to have any effect upon the temporary directory used by this method.\\n     *\\n     * @param  prefix     The prefix string to be used in generating the file\\\u0027s\\n     *                    name; must be at least three characters long\\n     *\\n     * @param  suffix     The suffix string to be used in generating the file\\\u0027s\\n     *                    name; may be \u003ccode\u003enull\u003c/code\u003e, in which case the\\n     *                    suffix \u003ccode\u003e\".tmp\"\u003c/code\u003e will be used\\n     *\\n     * @param  directory  The directory in which the file is to be created, or\\n     *                    \u003ccode\u003enull\u003c/code\u003e if the default temporary-file\\n     *                    directory is to be used\\n     *\\n     * @return  An abstract pathname denoting a newly-created empty file\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the \u003ccode\u003eprefix\u003c/code\u003e argument contains fewer than three\\n     *          characters\\n     *\\n     * @throws  IOException  If a file could not be created\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}\u003c/code\u003e\\n     *          method does not allow a file to be created\\n     *\\n     * @since 1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "deleteOnExit", "label": "deleteOnExit", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static File createTempFile(String prefix, String suffix) throws IOException", "label": "public static File createTempFile(String prefix, String suffix) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates an empty file in the default temporary-file directory, using\\n     * the given prefix and suffix to generate its name. Invoking this method\\n     * is equivalent to invoking \u003ccode\u003e{@link #createTempFile(java.lang.String,\\n     * java.lang.String, java.io.File)\\n     * createTempFile(prefix,\u0026nbsp;suffix,\u0026nbsp;null)}\u003c/code\u003e.\\n     *\\n     * \u003cp\u003e The {@link\\n     * java.nio.file.Files#createTempFile(String,String,java.nio.file.attribute.FileAttribute[])\\n     * Files.createTempFile} method provides an alternative method to create an\\n     * empty file in the temporary-file directory. Files created by that method\\n     * may have more restrictive access permissions to files created by this\\n     * method and so may be more suited to security-sensitive applications.\\n     *\\n     * @param  prefix     The prefix string to be used in generating the file\\\u0027s\\n     *                    name; must be at least three characters long\\n     *\\n     * @param  suffix     The suffix string to be used in generating the file\\\u0027s\\n     *                    name; may be \u003ccode\u003enull\u003c/code\u003e, in which case the\\n     *                    suffix \u003ccode\u003e\".tmp\"\u003c/code\u003e will be used\\n     *\\n     * @return  An abstract pathname denoting a newly-created empty file\\n     *\\n     * @throws  IllegalArgumentException\\n     *          If the \u003ccode\u003eprefix\u003c/code\u003e argument contains fewer than three\\n     *          characters\\n     *\\n     * @throws  IOException  If a file could not be created\\n     *\\n     * @throws  SecurityException\\n     *          If a security manager exists and its \u003ccode\u003e{@link\\n     *          java.lang.SecurityManager#checkWrite(java.lang.String)}\u003c/code\u003e\\n     *          method does not allow a file to be created\\n     *\\n     * @since 1.2\\n     * @see java.nio.file.Files#createTempDirectory(String,FileAttribute[])\\n     \u0027}"}, {"color": "#97c2fc", "id": "createTempFile(java.lang.String", "label": "createTempFile(java.lang.String", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public int compareTo(File pathname)", "label": "public int compareTo(File pathname)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two abstract pathnames lexicographically.  The ordering\\n     * defined by this method depends upon the underlying system.  On UNIX\\n     * systems, alphabetic case is significant in comparing pathnames; on Microsoft Windows\\n     * systems it is not.\\n     *\\n     * @param   pathname  The abstract pathname to be compared to this abstract\\n     *                    pathname\\n     *\\n     * @return  Zero if the argument is equal to this abstract pathname, a\\n     *          value less than zero if this abstract pathname is\\n     *          lexicographically less than the argument, or a value greater\\n     *          than zero if this abstract pathname is lexicographically\\n     *          greater than the argument\\n     *\\n     * @since   1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "getPath", "label": "getPath", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "private synchronized void writeObject(java.io.ObjectOutputStream s) throws IOException", "label": "private synchronized void writeObject(java.io.ObjectOutputStream s) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * WriteObject is called to save this filename.\\n     * The separator character is saved also so it can be replaced\\n     * in case the path is reconstituted on a different host type.\\n     * \u003cp\u003e\\n     * @serialData  Default fields followed by separator character.\\n     \u0027}"}, {"color": "#97c2fc", "id": "private synchronized void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException", "label": "private synchronized void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * readObject is called to restore this filename.\\n     * The original separator character is read.  If it is different\\n     * than the separator character on this system, then the old separator\\n     * is replaced by the local separator.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Path toPath()", "label": "public Path toPath()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@link Path java.nio.file.Path} object constructed from the\\n     * this abstract path. The resulting {@code Path} is associated with the\\n     * {@link java.nio.file.FileSystems#getDefault default-filesystem}.\\n     *\\n     * \u003cp\u003e The first invocation of this method works as if invoking it were\\n     * equivalent to evaluating the expression:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * {@link java.nio.file.FileSystems#getDefault FileSystems.getDefault}().{@link\\n     * java.nio.file.FileSystem#getPath getPath}(this.{@link #getPath getPath}());\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * Subsequent invocations of this method return the same {@code Path}.\\n     *\\n     * \u003cp\u003e If this abstract pathname is the empty abstract pathname then this\\n     * method returns a {@code Path} that may be used to access the current\\n     * user directory.\\n     *\\n     * @return  a {@code Path} constructed from this abstract path\\n     *\\n     * @throws  java.nio.file.InvalidPathException\\n     *          if a {@code Path} object cannot be constructed from the abstract\\n     *          path (see {@link java.nio.file.FileSystem#getPath FileSystem.getPath})\\n     *\\n     * @since   1.7\\n     * @see Path#toFile\\n     \u0027}"}, {"color": "#97c2fc", "id": "getProperty(String)", "label": "getProperty(String)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static String lineSeparator()", "label": "public static String lineSeparator()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the system-dependent line separator string.  It always\\n     * returns the same value - the initial value of the {@linkplain\\n     * #getProperty(String) system property} {@code line.separator}.\\n     *\\n     * \u003cp\u003eOn UNIX systems, it returns {@code \"\\\\n\"}; on Microsoft\\n     * Windows systems it returns {@code \"\\\\r\\\\n\"}.\\n     *\\n     * @return the system-dependent line separator string\\n     * @since 1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void setProperties(Properties props)", "label": "public static void setProperties(Properties props)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Attempts to set all system properties. Copies all properties from\\n     * {@code p} and discards system properties that are read only and cannot\\n     * be modified. See {@link #getProperty} for a list of such properties.\\n     \u0027}"}, {"color": "#97c2fc", "id": "getProperty", "label": "getProperty", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static String getProperty(String key)", "label": "public static String getProperty(String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Gets the system property indicated by the specified key.\\n     * \u003cp\u003e\\n     * First, if there is a security manager, its\\n     * \u003ccode\u003echeckPropertyAccess\u003c/code\u003e method is called with the key as\\n     * its argument. This may result in a SecurityException.\\n     * \u003cp\u003e\\n     * If there is no current set of system properties, a set of system\\n     * properties is first created and initialized in the same manner as\\n     * for the \u003ccode\u003egetProperties\u003c/code\u003e method.\\n     *\\n     * @param      key   the name of the system property.\\n     * @return     the string value of the system property,\\n     *             or \u003ccode\u003enull\u003c/code\u003e if there is no property with that key.\\n     *\\n     * @exception  SecurityException  if a security manager exists and its\\n     *             \u003ccode\u003echeckPropertyAccess\u003c/code\u003e method doesn\u0027t allow\\n     *              access to the specified system property.\\n     * @exception  NullPointerException if \u003ccode\u003ekey\u003c/code\u003e is\\n     *             \u003ccode\u003enull\u003c/code\u003e.\\n     * @exception  IllegalArgumentException if \u003ccode\u003ekey\u003c/code\u003e is empty.\\n     * @see        #setProperty\\n     * @see        java.lang.SecurityException\\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\\n     * @see        java.lang.System#getProperties()\\n     \"}"}, {"color": "#97c2fc", "id": "public static String getProperty(String key, String def)", "label": "public static String getProperty(String key, String def)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Gets the system property indicated by the specified key.\\n     * \u003cp\u003e\\n     * First, if there is a security manager, its\\n     * \u003ccode\u003echeckPropertyAccess\u003c/code\u003e method is called with the\\n     * \u003ccode\u003ekey\u003c/code\u003e as its argument.\\n     * \u003cp\u003e\\n     * If there is no current set of system properties, a set of system\\n     * properties is first created and initialized in the same manner as\\n     * for the \u003ccode\u003egetProperties\u003c/code\u003e method.\\n     *\\n     * @param      key   the name of the system property.\\n     * @param      def   a default value.\\n     * @return     the string value of the system property,\\n     *             or the default value if there is no property with that key.\\n     *\\n     * @exception  SecurityException  if a security manager exists and its\\n     *             \u003ccode\u003echeckPropertyAccess\u003c/code\u003e method doesn\u0027t allow\\n     *             access to the specified system property.\\n     * @exception  NullPointerException if \u003ccode\u003ekey\u003c/code\u003e is\\n     *             \u003ccode\u003enull\u003c/code\u003e.\\n     * @exception  IllegalArgumentException if \u003ccode\u003ekey\u003c/code\u003e is empty.\\n     * @see        #setProperty\\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\\n     * @see        java.lang.System#getProperties()\\n     \"}"}, {"color": "#97c2fc", "id": "public static String setProperty(String key, String value)", "label": "public static String setProperty(String key, String value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the system property indicated by the specified key.\\n     * \u003cp\u003e\\n     * First, if a security manager exists, its\\n     * \u003ccode\u003eSecurityManager.checkPermission\u003c/code\u003e method\\n     * is called with a \u003ccode\u003ePropertyPermission(key, \"write\")\u003c/code\u003e\\n     * permission. This may result in a SecurityException being thrown.\\n     * If no exception is thrown, the specified property is set to the given\\n     * value.\\n     * \u003cp\u003e\\n     *\\n     * @param      key   the name of the system property.\\n     * @param      value the value of the system property.\\n     * @return     the previous value of the system property,\\n     *             or \u003ccode\u003enull\u003c/code\u003e if it did not have one.\\n     *\\n     * @exception  SecurityException  if a security manager exists and its\\n     *             \u003ccode\u003echeckPermission\u003c/code\u003e method doesn\\\u0027t allow\\n     *             setting of the specified property.\\n     * @exception  NullPointerException if \u003ccode\u003ekey\u003c/code\u003e or\\n     *             \u003ccode\u003evalue\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e.\\n     * @exception  IllegalArgumentException if \u003ccode\u003ekey\u003c/code\u003e is empty.\\n     * @see        #getProperty\\n     * @see        java.lang.System#getProperty(java.lang.String)\\n     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)\\n     * @see        java.util.PropertyPermission\\n     * @see        SecurityManager#checkPermission\\n     * @since      1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String clearProperty(String key)", "label": "public static String clearProperty(String key)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Removes the system property indicated by the specified key.\\n     * \u003cp\u003e\\n     * First, if a security manager exists, its\\n     * \u003ccode\u003eSecurityManager.checkPermission\u003c/code\u003e method\\n     * is called with a \u003ccode\u003ePropertyPermission(key, \"write\")\u003c/code\u003e\\n     * permission. This may result in a SecurityException being thrown.\\n     * If no exception is thrown, the specified property is removed.\\n     * \u003cp\u003e\\n     *\\n     * @param      key   the name of the system property to be removed.\\n     * @return     the previous string value of the system property,\\n     *             or \u003ccode\u003enull\u003c/code\u003e if there was no property with that key.\\n     *\\n     * @exception  SecurityException  if a security manager exists and its\\n     *             \u003ccode\u003echeckPropertyAccess\u003c/code\u003e method doesn\\\u0027t allow\\n     *              access to the specified system property.\\n     * @exception  NullPointerException if \u003ccode\u003ekey\u003c/code\u003e is\\n     *             \u003ccode\u003enull\u003c/code\u003e.\\n     * @exception  IllegalArgumentException if \u003ccode\u003ekey\u003c/code\u003e is empty.\\n     * @see        #getProperty\\n     * @see        #setProperty\\n     * @see        java.util.Properties\\n     * @see        java.lang.SecurityException\\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String getenv(String name)", "label": "public static String getenv(String name)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets the value of the specified environment variable. An\\n     * environment variable is a system-dependent external named\\n     * value.\\n     *\\n     * \u003cp\u003eIf a security manager exists, its\\n     * {@link SecurityManager#checkPermission checkPermission}\\n     * method is called with a\\n     * \u003ccode\u003e{@link RuntimePermission}(\"getenv.\"+name)\u003c/code\u003e\\n     * permission.  This may result in a {@link SecurityException}\\n     * being thrown.  If no exception is thrown the value of the\\n     * variable \u003ccode\u003ename\u003c/code\u003e is returned.\\n     *\\n     * \u003cp\u003e\u003ca name=\"EnvironmentVSSystemProperties\"\u003e\u003ci\u003eSystem\\n     * properties\u003c/i\u003e and \u003ci\u003eenvironment variables\u003c/i\u003e\u003c/a\u003e are both\\n     * conceptually mappings between names and values.  Both\\n     * mechanisms can be used to pass user-defined information to a\\n     * Java process.  Environment variables have a more global effect,\\n     * because they are visible to all descendants of the process\\n     * which defines them, not just the immediate Java subprocess.\\n     * They can have subtly different semantics, such as case\\n     * insensitivity, on different operating systems.  For these\\n     * reasons, environment variables are more likely to have\\n     * unintended side effects.  It is best to use system properties\\n     * where possible.  Environment variables should be used when a\\n     * global effect is desired, or when an external system interface\\n     * requires an environment variable (such as \u003ccode\u003ePATH\u003c/code\u003e).\\n     *\\n     * \u003cp\u003eOn UNIX systems the alphabetic case of \u003ccode\u003ename\u003c/code\u003e is\\n     * typically significant, while on Microsoft Windows systems it is\\n     * typically not.  For example, the expression\\n     * \u003ccode\u003eSystem.getenv(\"FOO\").equals(System.getenv(\"foo\"))\u003c/code\u003e\\n     * is likely to be true on Microsoft Windows.\\n     *\\n     * @param  name the name of the environment variable\\n     * @return the string value of the variable, or \u003ccode\u003enull\u003c/code\u003e\\n     *         if the variable is not defined in the system environment\\n     * @throws NullPointerException if \u003ccode\u003ename\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e\\n     * @throws SecurityException\\n     *         if a security manager exists and its\\n     *         {@link SecurityManager#checkPermission checkPermission}\\n     *         method doesn\\\u0027t allow access to the environment variable\\n     *         \u003ccode\u003ename\u003c/code\u003e\\n     * @see    #getenv()\\n     * @see    ProcessBuilder#environment()\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static java.util.Map\u003cString, String\u003e getenv()", "label": "public static java.util.Map\u003cString, String\u003e getenv()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable string map view of the current system environment.\\n     * The environment is a system-dependent mapping from names to\\n     * values which is passed from parent to child processes.\\n     *\\n     * \u003cp\u003eIf the system does not support environment variables, an\\n     * empty map is returned.\\n     *\\n     * \u003cp\u003eThe returned map will never contain null keys or values.\\n     * Attempting to query the presence of a null key or value will\\n     * throw a {@link NullPointerException}.  Attempting to query\\n     * the presence of a key or value which is not of type\\n     * {@link String} will throw a {@link ClassCastException}.\\n     *\\n     * \u003cp\u003eThe returned map and its collection views may not obey the\\n     * general contract of the {@link Object#equals} and\\n     * {@link Object#hashCode} methods.\\n     *\\n     * \u003cp\u003eThe returned map is typically case-sensitive on all platforms.\\n     *\\n     * \u003cp\u003eIf a security manager exists, its\\n     * {@link SecurityManager#checkPermission checkPermission}\\n     * method is called with a\\n     * \u003ccode\u003e{@link RuntimePermission}(\"getenv.*\")\u003c/code\u003e\\n     * permission.  This may result in a {@link SecurityException} being\\n     * thrown.\\n     *\\n     * \u003cp\u003eWhen passing information to a Java subprocess,\\n     * \u003ca href=#EnvironmentVSSystemProperties\u003esystem properties\u003c/a\u003e\\n     * are generally preferred over environment variables.\\n     *\\n     * @return the environment as a map of variable names to values\\n     * @throws SecurityException\\n     *         if a security manager exists and its\\n     *         {@link SecurityManager#checkPermission checkPermission}\\n     *         method doesn\\\u0027t allow access to the process environment\\n     * @see    #getenv(String)\\n     * @see    ProcessBuilder#environment()\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.lang.ClassCastException", "label": "java.lang.ClassCastException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Thrown to indicate that the code has attempted to cast an object\\n * to a subclass of which it is not an instance. For example, the\\n * following code generates a {@code ClassCastException}:\\n * \u003cblockquote\u003e\u003cpre\u003e\\n *     Object x = new Integer(0);\\n *     System.out.println((String)x);\\n * \u003c/pre\u003e\u003c/blockquote\u003e\\n *\\n * @since   1.0\\n \u0027}"}, {"color": "#97c2fc", "id": "java.lang.NullPointerException", "label": "java.lang.NullPointerException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Thrown when an application attempts to use {@code null} in a\\n * case where an object is required. These include:\\n * \u003cul\u003e\\n * \u003cli\u003eCalling the instance method of a {@code null} object.\\n * \u003cli\u003eAccessing or modifying the field of a {@code null} object.\\n * \u003cli\u003eTaking the length of {@code null} as if it were an array.\\n * \u003cli\u003eAccessing or modifying the slots of {@code null} as if it\\n *     were an array.\\n * \u003cli\u003eThrowing {@code null} as if it were a {@code Throwable}\\n *     value.\\n * \u003c/ul\u003e\\n * \u003cp\u003e\\n * Applications should throw instances of this class to indicate\\n * other illegal uses of the {@code null} object.\\n *\\n * {@code NullPointerException} objects may be constructed by the\\n * virtual machine as if {@linkplain Throwable#Throwable(String,\\n * Throwable, boolean, boolean) suppression were disabled and/or the\\n * stack trace was not writable}.\\n *\\n * @since   1.0\\n \u0027}"}, {"color": "#97c2fc", "id": "public static void exit(int status)", "label": "public static void exit(int status)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Terminates the currently running Java Virtual Machine. The\\n     * argument serves as a status code; by convention, a nonzero status\\n     * code indicates abnormal termination.\\n     * \u003cp\u003e\\n     * This method calls the \u003ccode\u003eexit\u003c/code\u003e method in class\\n     * \u003ccode\u003eRuntime\u003c/code\u003e. This method never returns normally.\\n     * \u003cp\u003e\\n     * The call \u003ccode\u003eSystem.exit(n)\u003c/code\u003e is effectively equivalent to\\n     * the call:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * Runtime.getRuntime().exit(n)\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @param      status   exit status.\\n     * @throws  SecurityException\\n     *        if a security manager exists and its \u003ccode\u003echeckExit\u003c/code\u003e\\n     *        method doesn\u0027t allow exit with the specified status.\\n     * @see        java.lang.Runtime#exit(int)\\n     \"}"}, {"color": "#97c2fc", "id": "public static void gc()", "label": "public static void gc()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Runs the garbage collector.\\n     * \u003cp\u003e\\n     * Calling the \u003ccode\u003egc\u003c/code\u003e method suggests that the Java Virtual\\n     * Machine expend effort toward recycling unused objects in order to\\n     * make the memory they currently occupy available for quick reuse.\\n     * When control returns from the method call, the Java Virtual\\n     * Machine has made a best effort to reclaim space from all discarded\\n     * objects.\\n     * \u003cp\u003e\\n     * The call \u003ccode\u003eSystem.gc()\u003c/code\u003e is effectively equivalent to the\\n     * call:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * Runtime.getRuntime().gc()\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     * At API level 34 and lower, this does nothing unless it is preceded or\\n     * followed by a runFinalization call.  Runtime.getRuntime().gc() always\\n     * attempts to reclaim space.\\n     * \u003cp\u003e\\n     * Calling this indiscriminately is likely to severely degrade performance.\\n     * Intended primarily for testing.\\n     *\\n     * @see     java.lang.Runtime#gc()\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void runFinalization()", "label": "public static void runFinalization()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Runs the finalization methods of any objects pending finalization.\\n     * \u003cp\u003e\\n     * Calling this method suggests that the Java Virtual Machine expend\\n     * effort toward running the \u003ccode\u003efinalize\u003c/code\u003e methods of objects\\n     * that have been found to be discarded but whose \u003ccode\u003efinalize\u003c/code\u003e\\n     * methods have not yet been run. When control returns from the\\n     * method call, the Java Virtual Machine has made a best effort to\\n     * complete all outstanding finalizations.\\n     * \u003cp\u003e\\n     * The call \u003ccode\u003eSystem.runFinalization()\u003c/code\u003e is effectively\\n     * equivalent to the call:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * Runtime.getRuntime().runFinalization()\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @see     java.lang.Runtime#runFinalization()\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static void load(String filename)", "label": "public static void load(String filename)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Loads the native library specified by the filename argument.  The filename\\n     * argument must be an absolute path name.\\n     *\\n     * If the filename argument, when stripped of any platform-specific library\\n     * prefix, path, and file extension, indicates a library whose name is,\\n     * for example, L, and a native library called L is statically linked\\n     * with the VM, then the JNI_OnLoad_L function exported by the library\\n     * is invoked rather than attempting to load a dynamic library.\\n     * A filename matching the argument does not have to exist in the\\n     * file system.\\n     * See the JNI Specification for more details.\\n     *\\n     * Otherwise, the filename argument is mapped to a native library image in\\n     * an implementation-dependent manner.\\n     *\\n     * \u003cp\u003e\\n     * The call \u003ccode\u003eSystem.load(name)\u003c/code\u003e is effectively equivalent\\n     * to the call:\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * Runtime.getRuntime().load(name)\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @param      filename   the file to load.\\n     * @exception  SecurityException  if a security manager exists and its\\n     *             \u003ccode\u003echeckLink\u003c/code\u003e method doesn\u0027t allow\\n     *             loading of the specified dynamic library\\n     * @exception  UnsatisfiedLinkError  if either the filename is not an\\n     *             absolute path name, the native library is not statically\\n     *             linked with the VM, or the library cannot be mapped to\\n     *             a native library image by the host system.\\n     * @exception  NullPointerException if \u003ccode\u003efilename\u003c/code\u003e is\\n     *             \u003ccode\u003enull\u003c/code\u003e\\n     * @see        java.lang.Runtime#load(java.lang.String)\\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\\n     \"}"}, {"color": "#97c2fc", "id": "public static void loadLibrary(String libname)", "label": "public static void loadLibrary(String libname)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Loads the native library specified by the \u003ccode\u003elibname\u003c/code\u003e\\n     * argument.  The \u003ccode\u003elibname\u003c/code\u003e argument must not contain any platform\\n     * specific prefix, file extension or path. If a native library\\n     * called \u003ccode\u003elibname\u003c/code\u003e is statically linked with the VM, then the\\n     * JNI_OnLoad_\u003ccode\u003elibname\u003c/code\u003e function exported by the library is invoked.\\n     * See the JNI Specification for more details.\\n     *\\n     * Otherwise, the libname argument is loaded from a system library\\n     * location and mapped to a native library image in an implementation-\\n     * dependent manner.\\n     * \u003cp\u003e\\n     * The call \u003ccode\u003eSystem.loadLibrary(name)\u003c/code\u003e is effectively\\n     * equivalent to the call\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * Runtime.getRuntime().loadLibrary(name)\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * @param      libname   the name of the library.\\n     * @exception  SecurityException  if a security manager exists and its\\n     *             \u003ccode\u003echeckLink\u003c/code\u003e method doesn\u0027t allow\\n     *             loading of the specified dynamic library\\n     * @exception  UnsatisfiedLinkError if either the libname argument\\n     *             contains a file path, the native library is not statically\\n     *             linked with the VM,  or the library cannot be mapped to a\\n     *             native library image by the host system.\\n     * @exception  NullPointerException if \u003ccode\u003elibname\u003c/code\u003e is\\n     *             \u003ccode\u003enull\u003c/code\u003e\\n     * @see        java.lang.Runtime#loadLibrary(java.lang.String)\\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\\n     \"}"}, {"color": "#97c2fc", "id": "public static native String mapLibraryName(String libname)", "label": "public static native String mapLibraryName(String libname)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Maps a library name into a platform-specific string representing\\n     * a native library.\\n     *\\n     * @param      libname the name of the library.\\n     * @return     a platform-dependent native library name.\\n     * @exception  NullPointerException if \u003ccode\u003elibname\u003c/code\u003e is\\n     *             \u003ccode\u003enull\u003c/code\u003e\\n     * @see        java.lang.System#loadLibrary(java.lang.String)\\n     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)\\n     * @since      1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "private static PrintStream newPrintStream(FileOutputStream fos, String enc)", "label": "private static PrintStream newPrintStream(FileOutputStream fos, String enc)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Create PrintStream for stdout/err based on encoding.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Integer getInteger(String nm, int val)", "label": "public static Integer getInteger(String nm, int val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Determines the integer value of the system property with the\\n     * specified name.\\n     *\\n     * \u003cp\u003eThe first argument is treated as the name of a system\\n     * property.  System properties are accessible through the {@link\\n     * java.lang.System#getProperty(java.lang.String)} method. The\\n     * string value of this property is then interpreted as an integer\\n     * value using the grammar supported by {@link Integer#decode decode} and\\n     * an {@code Integer} object representing this value is returned.\\n     *\\n     * \u003cp\u003eThe second argument is the default value. An {@code Integer} object\\n     * that represents the value of the second argument is returned if there\\n     * is no property of the specified name, if the property does not have\\n     * the correct numeric format, or if the specified name is empty or\\n     * {@code null}.\\n     *\\n     * \u003cp\u003eIn other words, this method returns an {@code Integer} object\\n     * equal to the value of:\\n     *\\n     * \u003cblockquote\u003e\\n     *  {@code getInteger(nm, new Integer(val))}\\n     * \u003c/blockquote\u003e\\n     *\\n     * but in practice it may be implemented in a manner such as:\\n     *\\n     * \u003cblockquote\u003e\u003cpre\u003e\\n     * Integer result = getInteger(nm, null);\\n     * return (result == null) ? new Integer(val) : result;\\n     * \u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * to avoid the unnecessary allocation of an {@code Integer}\\n     * object when the default value is not needed.\\n     *\\n     * @param   nm   property name.\\n     * @param   val   default value.\\n     * @return  the {@code Integer} value of the property.\\n     * @throws  SecurityException for the same reasons as\\n     *          {@link System#getProperty(String) System.getProperty}\\n     * @see     java.lang.System#getProperty(java.lang.String)\\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Integer getInteger(String nm, Integer val)", "label": "public static Integer getInteger(String nm, Integer val)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the integer value of the system property with the\\n     * specified name.  The first argument is treated as the name of a\\n     * system property.  System properties are accessible through the\\n     * {@link java.lang.System#getProperty(java.lang.String)} method.\\n     * The string value of this property is then interpreted as an\\n     * integer value, as per the {@link Integer#decode decode} method,\\n     * and an {@code Integer} object representing this value is\\n     * returned; in summary:\\n     *\\n     * \u003cul\u003e\u003cli\u003eIf the property value begins with the two ASCII characters\\n     *         {@code 0x} or the ASCII character {@code #}, not\\n     *      followed by a minus sign, then the rest of it is parsed as a\\n     *      hexadecimal integer exactly as by the method\\n     *      {@link #valueOf(java.lang.String, int)} with radix 16.\\n     * \u003cli\u003eIf the property value begins with the ASCII character\\n     *     {@code 0} followed by another character, it is parsed as an\\n     *     octal integer exactly as by the method\\n     *     {@link #valueOf(java.lang.String, int)} with radix 8.\\n     * \u003cli\u003eOtherwise, the property value is parsed as a decimal integer\\n     * exactly as by the method {@link #valueOf(java.lang.String, int)}\\n     * with radix 10.\\n     * \u003c/ul\u003e\\n     *\\n     * \u003cp\u003eThe second argument is the default value. The default value is\\n     * returned if there is no property of the specified name, if the\\n     * property does not have the correct numeric format, or if the\\n     * specified name is empty or {@code null}.\\n     *\\n     * @param   nm   property name.\\n     * @param   val   default value.\\n     * @return  the {@code Integer} value of the property.\\n     * @throws  SecurityException for the same reasons as\\n     *          {@link System#getProperty(String) System.getProperty}\\n     * @see     System#getProperty(java.lang.String)\\n     * @see     System#getProperty(java.lang.String, java.lang.String)\\n     \u0027}"}, {"color": "#97c2fc", "id": "valueOf(java.lang.String", "label": "valueOf(java.lang.String", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static Integer decode(String nm) throws NumberFormatException", "label": "public static Integer decode(String nm) throws NumberFormatException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Decodes a {@code String} into an {@code Integer}.\\n     * Accepts decimal, hexadecimal, and octal numbers given\\n     * by the following grammar:\\n     *\\n     * \u003cblockquote\u003e\\n     * \u003cdl\u003e\\n     * \u003cdt\u003e\u003ci\u003eDecodableString:\u003c/i\u003e\\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e DecimalNumeral\u003c/i\u003e\\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0x} \u003ci\u003eHexDigits\u003c/i\u003e\\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0X} \u003ci\u003eHexDigits\u003c/i\u003e\\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code #} \u003ci\u003eHexDigits\u003c/i\u003e\\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0} \u003ci\u003eOctalDigits\u003c/i\u003e\\n     *\\n     * \u003cdt\u003e\u003ci\u003eSign:\u003c/i\u003e\\n     * \u003cdd\u003e{@code -}\\n     * \u003cdd\u003e{@code +}\\n     * \u003c/dl\u003e\\n     * \u003c/blockquote\u003e\\n     *\\n     * \u003ci\u003eDecimalNumeral\u003c/i\u003e, \u003ci\u003eHexDigits\u003c/i\u003e, and \u003ci\u003eOctalDigits\u003c/i\u003e\\n     * are as defined in section {@jls 3.10.1} of\\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e,\\n     * except that underscores are not accepted between digits.\\n     *\\n     * \u003cp\u003eThe sequence of characters following an optional\\n     * sign and/or radix specifier (\"{@code 0x}\", \"{@code 0X}\",\\n     * \"{@code #}\", or leading zero) is parsed as by the {@code\\n     * Integer.parseInt} method with the indicated radix (10, 16, or\\n     * 8).  This sequence of characters must represent a positive\\n     * value or a {@link NumberFormatException} will be thrown.  The\\n     * result is negated if first character of the specified {@code\\n     * String} is the minus sign.  No whitespace characters are\\n     * permitted in the {@code String}.\\n     *\\n     * @param     nm the {@code String} to decode.\\n     * @return    an {@code Integer} object holding the {@code int}\\n     *             value represented by {@code nm}\\n     * @throws    NumberFormatException  if the {@code String} does not\\n     *            contain a parsable integer.\\n     * @see java.lang.Integer#parseInt(java.lang.String, int)\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.lang.NumberFormatException", "label": "java.lang.NumberFormatException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Thrown to indicate that the application has attempted to convert\\n * a string to one of the numeric types, but that the string does not\\n * have the appropriate format.\\n *\\n * @see     java.lang.Integer#parseInt(String)\\n * @since   1.0\\n \u0027}"}, {"color": "#97c2fc", "id": " static NumberFormatException forInputString(String s, int radix)", "label": " static NumberFormatException forInputString(String s, int radix)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Factory method for making a {@code NumberFormatException}\\n     * given the specified input which caused the error.\\n     *\\n     * @param   s   the input causing the error\\n     \u0027}"}, {"color": "#97c2fc", "id": " static NumberFormatException forCharSequence(CharSequence s, int beginIndex, int endIndex, int errorIndex)", "label": " static NumberFormatException forCharSequence(CharSequence s, int beginIndex, int endIndex, int errorIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Factory method for making a {@code NumberFormatException}\\n     * given the specified input which caused the error.\\n     *\\n     * @param   s   the input causing the error\\n     * @param   beginIndex   the beginning index, inclusive.\\n     * @param   endIndex     the ending index, exclusive.\\n     * @param   errorIndex   the index of the first error in s\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int compareTo(Integer anotherInteger)", "label": "public int compareTo(Integer anotherInteger)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code Integer} objects numerically.\\n     *\\n     * @param   anotherInteger   the {@code Integer} to be compared.\\n     * @return  the value {@code 0} if this {@code Integer} is\\n     *          equal to the argument {@code Integer}; a value less than\\n     *          {@code 0} if this {@code Integer} is numerically less\\n     *          than the argument {@code Integer}; and a value greater\\n     *          than {@code 0} if this {@code Integer} is numerically\\n     *           greater than the argument {@code Integer} (signed\\n     *           comparison).\\n     * @since   1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int compare(int x, int y)", "label": "public static int compare(int x, int y)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code int} values numerically.\\n     * The value returned is identical to what would be returned by:\\n     * \u003cpre\u003e\\n     *    Integer.valueOf(x).compareTo(Integer.valueOf(y))\\n     * \u003c/pre\u003e\\n     *\\n     * @param  x the first {@code int} to compare\\n     * @param  y the second {@code int} to compare\\n     * @return the value {@code 0} if {@code x == y};\\n     *         a value less than {@code 0} if {@code x \u003c y}; and\\n     *         a value greater than {@code 0} if {@code x \u003e y}\\n     * @since 1.7\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int compareUnsigned(int x, int y)", "label": "public static int compareUnsigned(int x, int y)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code int} values numerically treating the values\\n     * as unsigned.\\n     *\\n     * @param  x the first {@code int} to compare\\n     * @param  y the second {@code int} to compare\\n     * @return the value {@code 0} if {@code x == y}; a value less\\n     *         than {@code 0} if {@code x \u003c y} as unsigned values; and\\n     *         a value greater than {@code 0} if {@code x \u003e y} as\\n     *         unsigned values\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static long toUnsignedLong(int x)", "label": "public static long toUnsignedLong(int x)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Converts the argument to a {@code long} by an unsigned\\n     * conversion.  In an unsigned conversion to a {@code long}, the\\n     * high-order 32 bits of the {@code long} are zero and the\\n     * low-order 32 bits are equal to the bits of the integer\\n     * argument.\\n     *\\n     * Consequently, zero and positive {@code int} values are mapped\\n     * to a numerically equal {@code long} value and negative {@code\\n     * int} values are mapped to a {@code long} value equal to the\\n     * input plus 2\u003csup\u003e32\u003c/sup\u003e.\\n     *\\n     * @param  x the value to convert to an unsigned {@code long}\\n     * @return the argument converted to {@code long} by an unsigned\\n     *         conversion\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int divideUnsigned(int dividend, int divisor)", "label": "public static int divideUnsigned(int dividend, int divisor)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the unsigned quotient of dividing the first argument by\\n     * the second where each argument and the result is interpreted as\\n     * an unsigned value.\\n     *\\n     * \u003cp\u003eNote that in two\u0027s complement arithmetic, the three other\\n     * basic arithmetic operations of add, subtract, and multiply are\\n     * bit-wise identical if the two operands are regarded as both\\n     * being signed or both being unsigned.  Therefore separate {@code\\n     * addUnsigned}, etc. methods are not provided.\\n     *\\n     * @param dividend the value to be divided\\n     * @param divisor the value doing the dividing\\n     * @return the unsigned quotient of the first argument divided by\\n     * the second argument\\n     * @see #remainderUnsigned\\n     * @since 1.8\\n     \"}"}, {"color": "#97c2fc", "id": "public static int remainderUnsigned(int dividend, int divisor)", "label": "public static int remainderUnsigned(int dividend, int divisor)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the unsigned remainder from dividing the first argument\\n     * by the second where each argument and the result is interpreted\\n     * as an unsigned value.\\n     *\\n     * @param dividend the value to be divided\\n     * @param divisor the value doing the dividing\\n     * @return the unsigned remainder of the first argument divided by\\n     * the second argument\\n     * @see #divideUnsigned\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int highestOneBit(int i)", "label": "public static int highestOneBit(int i)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@code int} value with at most a single one-bit, in the\\n     * position of the highest-order (\"leftmost\") one-bit in the specified\\n     * {@code int} value.  Returns zero if the specified value has no\\n     * one-bits in its two\\\u0027s complement binary representation, that is, if it\\n     * is equal to zero.\\n     *\\n     * @param i the value whose highest one bit is to be computed\\n     * @return an {@code int} value with a single one-bit, in the position\\n     *     of the highest-order one-bit in the specified value, or zero if\\n     *     the specified value is itself equal to zero.\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int lowestOneBit(int i)", "label": "public static int lowestOneBit(int i)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@code int} value with at most a single one-bit, in the\\n     * position of the lowest-order (\"rightmost\") one-bit in the specified\\n     * {@code int} value.  Returns zero if the specified value has no\\n     * one-bits in its two\\\u0027s complement binary representation, that is, if it\\n     * is equal to zero.\\n     *\\n     * @param i the value whose lowest one bit is to be computed\\n     * @return an {@code int} value with a single one-bit, in the position\\n     *     of the lowest-order one-bit in the specified value, or zero if\\n     *     the specified value is itself equal to zero.\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int numberOfLeadingZeros(int i)", "label": "public static int numberOfLeadingZeros(int i)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the number of zero bits preceding the highest-order\\n     * (\"leftmost\") one-bit in the two\\\u0027s complement binary representation\\n     * of the specified {@code int} value.  Returns 32 if the\\n     * specified value has no one-bits in its two\\\u0027s complement representation,\\n     * in other words if it is equal to zero.\\n     *\\n     * \u003cp\u003eNote that this method is closely related to the logarithm base 2.\\n     * For all positive {@code int} values x:\\n     * \u003cul\u003e\\n     * \u003cli\u003efloor(log\u003csub\u003e2\u003c/sub\u003e(x)) = {@code 31 - numberOfLeadingZeros(x)}\\n     * \u003cli\u003eceil(log\u003csub\u003e2\u003c/sub\u003e(x)) = {@code 32 - numberOfLeadingZeros(x - 1)}\\n     * \u003c/ul\u003e\\n     *\\n     * @param i the value whose number of leading zeros is to be computed\\n     * @return the number of zero bits preceding the highest-order\\n     *     (\"leftmost\") one-bit in the two\\\u0027s complement binary representation\\n     *     of the specified {@code int} value, or 32 if the value\\n     *     is equal to zero.\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int numberOfTrailingZeros(int i)", "label": "public static int numberOfTrailingZeros(int i)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the number of zero bits following the lowest-order (\"rightmost\")\\n     * one-bit in the two\\\u0027s complement binary representation of the specified\\n     * {@code int} value.  Returns 32 if the specified value has no\\n     * one-bits in its two\\\u0027s complement representation, in other words if it is\\n     * equal to zero.\\n     *\\n     * @param i the value whose number of trailing zeros is to be computed\\n     * @return the number of zero bits following the lowest-order (\"rightmost\")\\n     *     one-bit in the two\\\u0027s complement binary representation of the\\n     *     specified {@code int} value, or 32 if the value is equal\\n     *     to zero.\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int bitCount(int i)", "label": "public static int bitCount(int i)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the number of one-bits in the two\u0027s complement binary\\n     * representation of the specified {@code int} value.  This function is\\n     * sometimes referred to as the \u003ci\u003epopulation count\u003c/i\u003e.\\n     *\\n     * @param i the value whose bits are to be counted\\n     * @return the number of one-bits in the two\u0027s complement binary\\n     *     representation of the specified {@code int} value.\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": "public static int rotateLeft(int i, int distance)", "label": "public static int rotateLeft(int i, int distance)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the value obtained by rotating the two\u0027s complement binary\\n     * representation of the specified {@code int} value left by the\\n     * specified number of bits.  (Bits shifted out of the left hand, or\\n     * high-order, side reenter on the right, or low-order.)\\n     *\\n     * \u003cp\u003eNote that left rotation with a negative distance is equivalent to\\n     * right rotation: {@code rotateLeft(val, -distance) == rotateRight(val,\\n     * distance)}.  Note also that rotation by any multiple of 32 is a\\n     * no-op, so all but the last five bits of the rotation distance can be\\n     * ignored, even if the distance is negative: {@code rotateLeft(val,\\n     * distance) == rotateLeft(val, distance \u0026 0x1F)}.\\n     *\\n     * @param i the value whose bits are to be rotated left\\n     * @param distance the number of bit positions to rotate left\\n     * @return the value obtained by rotating the two\u0027s complement binary\\n     *     representation of the specified {@code int} value left by the\\n     *     specified number of bits.\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": "public static int rotateRight(int i, int distance)", "label": "public static int rotateRight(int i, int distance)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the value obtained by rotating the two\u0027s complement binary\\n     * representation of the specified {@code int} value right by the\\n     * specified number of bits.  (Bits shifted out of the right hand, or\\n     * low-order, side reenter on the left, or high-order.)\\n     *\\n     * \u003cp\u003eNote that right rotation with a negative distance is equivalent to\\n     * left rotation: {@code rotateRight(val, -distance) == rotateLeft(val,\\n     * distance)}.  Note also that rotation by any multiple of 32 is a\\n     * no-op, so all but the last five bits of the rotation distance can be\\n     * ignored, even if the distance is negative: {@code rotateRight(val,\\n     * distance) == rotateRight(val, distance \u0026 0x1F)}.\\n     *\\n     * @param i the value whose bits are to be rotated right\\n     * @param distance the number of bit positions to rotate right\\n     * @return the value obtained by rotating the two\u0027s complement binary\\n     *     representation of the specified {@code int} value right by the\\n     *     specified number of bits.\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": "public static int reverse(int i)", "label": "public static int reverse(int i)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the value obtained by reversing the order of the bits in the\\n     * two\u0027s complement binary representation of the specified {@code int}\\n     * value.\\n     *\\n     * @param i the value to be reversed\\n     * @return the value obtained by reversing order of the bits in the\\n     *     specified {@code int} value.\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": "public static int signum(int i)", "label": "public static int signum(int i)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the signum function of the specified {@code int} value.  (The\\n     * return value is -1 if the specified value is negative; 0 if the\\n     * specified value is zero; and 1 if the specified value is positive.)\\n     *\\n     * @param i the value whose signum is to be computed\\n     * @return the signum function of the specified {@code int} value.\\n     * @since 1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int reverseBytes(int i)", "label": "public static int reverseBytes(int i)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns the value obtained by reversing the order of the bytes in the\\n     * two\u0027s complement representation of the specified {@code int} value.\\n     *\\n     * @param i the value whose bytes are to be reversed\\n     * @return the value obtained by reversing the bytes in the specified\\n     *     {@code int} value.\\n     * @since 1.5\\n     \"}"}, {"color": "#97c2fc", "id": "public static int sum(int a, int b)", "label": "public static int sum(int a, int b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Adds two integers together as per the + operator.\\n     *\\n     * @param a the first operand\\n     * @param b the second operand\\n     * @return the sum of {@code a} and {@code b}\\n     * @see java.util.function.BinaryOperator\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int max(int a, int b)", "label": "public static int max(int a, int b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the greater of two {@code int} values\\n     * as if by calling {@link Math#max(int, int) Math.max}.\\n     *\\n     * @param a the first operand\\n     * @param b the second operand\\n     * @return the greater of {@code a} and {@code b}\\n     * @see java.util.function.BinaryOperator\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "max(int", "label": "max(int", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int min(int a, int b)", "label": "public static int min(int a, int b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the smaller of two {@code int} values\\n     * as if by calling {@link Math#min(int, int) Math.min}.\\n     *\\n     * @param a the first operand\\n     * @param b the second operand\\n     * @return the smaller of {@code a} and {@code b}\\n     * @see java.util.function.BinaryOperator\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "min(int", "label": "min(int", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.text.NumberFormat", "label": "java.text.NumberFormat", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * {@code NumberFormat} is the abstract base class for all number\\n * formats. This class provides the interface for formatting and parsing\\n * numbers. {@code NumberFormat} also provides methods for determining\\n * which locales have number formats, and what their names are.\\n *\\n * \u003cp\u003e\\n * {@code NumberFormat} helps you to format and parse numbers for any locale.\\n * Your code can be completely independent of the locale conventions for\\n * decimal points, thousands-separators, or even the particular decimal\\n * digits used, or whether the number format is even decimal.\\n *\\n * \u003cp\u003e\\n * To format a number for the current Locale, use one of the factory\\n * class methods:\\n * \u003cblockquote\u003e\\n * \u003cpre\u003e{@code\\n * myString = NumberFormat.getInstance().format(myNumber);\\n * }\u003c/pre\u003e\\n * \u003c/blockquote\u003e\\n * If you are formatting multiple numbers, it is\\n * more efficient to get the format and use it multiple times so that\\n * the system doesn\\\u0027t have to fetch the information about the local\\n * language and country conventions multiple times.\\n * \u003cblockquote\u003e\\n * \u003cpre\u003e{@code\\n * NumberFormat nf = NumberFormat.getInstance();\\n * for (int i = 0; i \u003c myNumber.length; ++i) {\\n *     output.println(nf.format(myNumber[i]) + \"; \");\\n * }\\n * }\u003c/pre\u003e\\n * \u003c/blockquote\u003e\\n * To format a number for a different Locale, specify it in the\\n * call to {@code getInstance}.\\n * \u003cblockquote\u003e\\n * \u003cpre\u003e{@code\\n * NumberFormat nf = NumberFormat.getInstance(Locale.FRENCH);\\n * }\u003c/pre\u003e\\n * \u003c/blockquote\u003e\\n *\\n * \u003cp\u003eIf the locale contains \"nu\" (numbers)\\n * \u003ca href=\"../util/Locale.html#def_locale_extension\"\u003eUnicode extensions\u003c/a\u003e,\\n * the decimal digits, and/or the country used for formatting are overridden.\\n *\\n * \u003cp\u003eYou can also use a {@code NumberFormat} to parse numbers:\\n * \u003cblockquote\u003e\\n * \u003cpre\u003e{@code\\n * myNumber = nf.parse(myString);\\n * }\u003c/pre\u003e\\n * \u003c/blockquote\u003e\\n * Use {@code getInstance} or {@code getNumberInstance} to get the\\n * normal number format. Use {@code getIntegerInstance} to get an\\n * integer number format. Use {@code getCurrencyInstance} to get the\\n * currency number format. Use {@code getCompactNumberInstance} to get the\\n * compact number format to format a number in shorter form. For example,\\n * {@code 2000} can be formatted as {@code \"2K\"} in\\n * {@link java.util.Locale#US US locale}. Use {@code getPercentInstance}\\n * to get a format for displaying percentages. With this format, a fraction\\n * like 0.53 is displayed as 53%.\\n *\\n * \u003cp\u003e\\n * You can also control the display of numbers with such methods as\\n * {@code setMinimumFractionDigits}.\\n * If you want even more control over the format or parsing,\\n * or want to give your users more control,\\n * you can try casting the {@code NumberFormat} you get from the factory methods\\n * to a {@code DecimalFormat} or {@code CompactNumberFormat} depending on\\n * the factory method used. This will work for the vast majority of locales;\\n * just remember to put it in a {@code try} block in case you encounter\\n * an unusual one.\\n *\\n * \u003cp\u003e\\n * NumberFormat and DecimalFormat are designed such that some controls\\n * work for formatting and others work for parsing.  The following is\\n * the detailed description for each these control methods,\\n * \u003cp\u003e\\n * setParseIntegerOnly : only affects parsing, e.g.\\n * if true,  \"3456.78\" \u0026rarr; 3456 (and leaves the parse position just after index 6)\\n * if false, \"3456.78\" \u0026rarr; 3456.78 (and leaves the parse position just after index 8)\\n * This is independent of formatting.  If you want to not show a decimal point\\n * where there might be no digits after the decimal point, use\\n * setDecimalSeparatorAlwaysShown.\\n * \u003cp\u003e\\n * setDecimalSeparatorAlwaysShown : only affects formatting, and only where\\n * there might be no digits after the decimal point, such as with a pattern\\n * like \"#,##0.##\", e.g.,\\n * if true,  3456.00 \u0026rarr; \"3,456.\"\\n * if false, 3456.00 \u0026rarr; \"3456\"\\n * This is independent of parsing.  If you want parsing to stop at the decimal\\n * point, use setParseIntegerOnly.\\n *\\n * \u003cp\u003e\\n * You can also use forms of the {@code parse} and {@code format}\\n * methods with {@code ParsePosition} and {@code FieldPosition} to\\n * allow you to:\\n * \u003cul\u003e\\n * \u003cli\u003e progressively parse through pieces of a string\\n * \u003cli\u003e align the decimal point and other areas\\n * \u003c/ul\u003e\\n * For example, you can align numbers in two ways:\\n * \u003col\u003e\\n * \u003cli\u003e If you are using a monospaced font with spacing for alignment,\\n *      you can pass the {@code FieldPosition} in your format call, with\\n *      {@code field} = {@code INTEGER_FIELD}. On output,\\n *      {@code getEndIndex} will be set to the offset between the\\n *      last character of the integer and the decimal. Add\\n *      (desiredSpaceCount - getEndIndex) spaces at the front of the string.\\n *\\n * \u003cli\u003e If you are using proportional fonts,\\n *      instead of padding with spaces, measure the width\\n *      of the string in pixels from the start to {@code getEndIndex}.\\n *      Then move the pen by\\n *      (desiredPixelWidth - widthToAlignmentPoint) before drawing the text.\\n *      It also works where there is no decimal, but possibly additional\\n *      characters at the end, e.g., with parentheses in negative\\n *      numbers: \"(12)\" for -12.\\n * \u003c/ol\u003e\\n *\\n * \u003ch2\u003e\u003ca id=\"synchronization\"\u003eSynchronization\u003c/a\u003e\u003c/h2\u003e\\n *\\n * \u003cp\u003e\\n * Number formats are generally not synchronized.\\n * It is recommended to create separate format instances for each thread.\\n * If multiple threads access a format concurrently, it must be synchronized\\n * externally.\\n *\\n * @implSpec The {@link #format(double, StringBuffer, FieldPosition)},\\n * {@link #format(long, StringBuffer, FieldPosition)} and\\n * {@link #parse(String, ParsePosition)} methods may throw\\n * {@code NullPointerException}, if any of their parameter is {@code null}.\\n * The subclass may provide its own implementation and specification about\\n * {@code NullPointerException}.\\n *\\n * \u003cp\u003e\\n * The default implementation provides rounding modes defined\\n * in {@link java.math.RoundingMode} for formatting numbers. It\\n * uses the {@linkplain java.math.RoundingMode#HALF_EVEN\\n * round half-even algorithm}. To change the rounding mode use\\n * {@link #setRoundingMode(java.math.RoundingMode) setRoundingMode}.\\n * The {@code NumberFormat} returned by the static factory methods is\\n * configured to round floating point numbers using half-even\\n * rounding (see {@link java.math.RoundingMode#HALF_EVEN\\n * RoundingMode.HALF_EVEN}) for formatting.\\n *\\n * @see          DecimalFormat\\n * @see          ChoiceFormat\\n * @author       Mark Davis\\n * @author       Helena Shih\\n * @since 1.1\\n \u0027}"}, {"color": "#97c2fc", "id": "public StringBuffer format(Object number, StringBuffer toAppendTo, FieldPosition pos)", "label": "public StringBuffer format(Object number, StringBuffer toAppendTo, FieldPosition pos)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Formats a number and appends the resulting text to the given string\\n     * buffer.\\n     * The number can be of any subclass of {@link java.lang.Number}.\\n     * \u003cp\u003e\\n     * This implementation extracts the number\u0027s value using\\n     * {@link java.lang.Number#longValue()} for all integral type values that\\n     * can be converted to {@code long} without loss of information,\\n     * including {@code BigInteger} values with a\\n     * {@link java.math.BigInteger#bitLength() bit length} of less than 64,\\n     * and {@link java.lang.Number#doubleValue()} for all other types. It\\n     * then calls\\n     * {@link #format(long,java.lang.StringBuffer,java.text.FieldPosition)}\\n     * or {@link #format(double,java.lang.StringBuffer,java.text.FieldPosition)}.\\n     * This may result in loss of magnitude information and precision for\\n     * {@code BigInteger} and {@code BigDecimal} values.\\n     * @param number     the number to format\\n     * @param toAppendTo the {@code StringBuffer} to which the formatted\\n     *                   text is to be appended\\n     * @param pos        keeps track on the position of the field within the\\n     *                   returned string. For example, for formatting a number\\n     *                   {@code 1234567.89} in {@code Locale.US} locale,\\n     *                   if the given {@code fieldPosition} is\\n     *                   {@link NumberFormat#INTEGER_FIELD}, the begin index\\n     *                   and end index of {@code fieldPosition} will be set\\n     *                   to 0 and 9, respectively for the output string\\n     *                   {@code 1,234,567.89}.\\n     * @return           the value passed in as {@code toAppendTo}\\n     * @throws           IllegalArgumentException if {@code number} is\\n     *                   null or not an instance of {@code Number}.\\n     * @throws           NullPointerException if {@code toAppendTo} or\\n     *                   {@code pos} is null\\n     * @throws           ArithmeticException if rounding is needed with rounding\\n     *                   mode being set to RoundingMode.UNNECESSARY\\n     * @see              java.text.FieldPosition\\n     \"}"}, {"color": "#97c2fc", "id": "INTEGER_FIELD", "label": "INTEGER_FIELD", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "doubleValue()", "label": "doubleValue()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "java.lang.Number", "label": "java.lang.Number", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * The abstract class {@code Number} is the superclass of platform\\n * classes representing numeric values that are convertible to the\\n * primitive types {@code byte}, {@code double}, {@code float}, {@code\\n * int}, {@code long}, and {@code short}.\\n *\\n * The specific semantics of the conversion from the numeric value of\\n * a particular {@code Number} implementation to a given primitive\\n * type is defined by the {@code Number} implementation in question.\\n *\\n * For platform classes, the conversion is often analogous to a\\n * narrowing primitive conversion or a widening primitive conversion\\n * as defined in \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e\\n * for converting between primitive types.  Therefore, conversions may\\n * lose information about the overall magnitude of a numeric value, may\\n * lose precision, and may even return a result of a different sign\\n * than the input.\\n *\\n * See the documentation of a given {@code Number} implementation for\\n * conversion details.\\n *\\n * @author      Lee Boynton\\n * @author      Arthur van Hoff\\n * @jls 5.1.2 Widening Primitive Conversion\\n * @jls 5.1.3 Narrowing Primitive Conversion\\n * @since   1.0\\n \u0027}"}, {"color": "#97c2fc", "id": "public abstract int intValue()", "label": "public abstract int intValue()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value of the specified number as an {@code int}.\\n     *\\n     * @return  the numeric value represented by this object after conversion\\n     *          to type {@code int}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract long longValue()", "label": "public abstract long longValue()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value of the specified number as a {@code long}.\\n     *\\n     * @return  the numeric value represented by this object after conversion\\n     *          to type {@code long}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract float floatValue()", "label": "public abstract float floatValue()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value of the specified number as a {@code float}.\\n     *\\n     * @return  the numeric value represented by this object after conversion\\n     *          to type {@code float}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract double doubleValue()", "label": "public abstract double doubleValue()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the value of the specified number as a {@code double}.\\n     *\\n     * @return  the numeric value represented by this object after conversion\\n     *          to type {@code double}.\\n     \u0027}"}, {"color": "#97c2fc", "id": "intValue", "label": "intValue", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "format(long", "label": "format(long", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "bitLength()", "label": "bitLength()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "format(double", "label": "format(double", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public final Object parseObject(String source, ParsePosition pos)", "label": "public final Object parseObject(String source, ParsePosition pos)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Parses text from a string to produce a {@code Number}.\\n     * \u003cp\u003e\\n     * The method attempts to parse text starting at the index given by\\n     * {@code pos}.\\n     * If parsing succeeds, then the index of {@code pos} is updated\\n     * to the index after the last character used (parsing does not necessarily\\n     * use all characters up to the end of the string), and the parsed\\n     * number is returned. The updated {@code pos} can be used to\\n     * indicate the starting point for the next call to this method.\\n     * If an error occurs, then the index of {@code pos} is not\\n     * changed, the error index of {@code pos} is set to the index of\\n     * the character where the error occurred, and null is returned.\\n     * \u003cp\u003e\\n     * See the {@link #parse(String, ParsePosition)} method for more information\\n     * on number parsing.\\n     *\\n     * @param source A {@code String}, part of which should be parsed.\\n     * @param pos A {@code ParsePosition} object with index and error\\n     *            index information as described above.\\n     * @return A {@code Number} parsed from the string. In case of\\n     *         error, returns null.\\n     * @throws NullPointerException if {@code source} or {@code pos} is null.\\n     \u0027}"}, {"color": "#97c2fc", "id": "parse(String", "label": "parse(String", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public final String format(double number)", "label": "public final String format(double number)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Specialization of format.\\n     *\\n     * @param number the double number to format\\n     * @return the formatted String\\n     * @throws           ArithmeticException if rounding is needed with rounding\\n     *                   mode being set to RoundingMode.UNNECESSARY\\n     * @see java.text.Format#format\\n     \u0027}"}, {"color": "#97c2fc", "id": "public final String format(long number)", "label": "public final String format(long number)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Specialization of format.\\n     *\\n     * @param number the long number to format\\n     * @return the formatted String\\n     * @throws           ArithmeticException if rounding is needed with rounding\\n     *                   mode being set to RoundingMode.UNNECESSARY\\n     * @see java.text.Format#format\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract StringBuffer format(double number, StringBuffer toAppendTo, FieldPosition pos)", "label": "public abstract StringBuffer format(double number, StringBuffer toAppendTo, FieldPosition pos)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Specialization of format.\\n     *\\n     * @param number     the double number to format\\n     * @param toAppendTo the StringBuffer to which the formatted text is to be\\n     *                   appended\\n     * @param pos        keeps track on the position of the field within the\\n     *                   returned string. For example, for formatting a number\\n     *                   {@code 1234567.89} in {@code Locale.US} locale,\\n     *                   if the given {@code fieldPosition} is\\n     *                   {@link NumberFormat#INTEGER_FIELD}, the begin index\\n     *                   and end index of {@code fieldPosition} will be set\\n     *                   to 0 and 9, respectively for the output string\\n     *                   {@code 1,234,567.89}.\\n     * @return the formatted StringBuffer\\n     * @throws           ArithmeticException if rounding is needed with rounding\\n     *                   mode being set to RoundingMode.UNNECESSARY\\n     * @see java.text.Format#format\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract StringBuffer format(long number, StringBuffer toAppendTo, FieldPosition pos)", "label": "public abstract StringBuffer format(long number, StringBuffer toAppendTo, FieldPosition pos)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Specialization of format.\\n     *\\n     * @param number     the long number to format\\n     * @param toAppendTo the StringBuffer to which the formatted text is to be\\n     *                   appended\\n     * @param pos        keeps track on the position of the field within the\\n     *                   returned string. For example, for formatting a number\\n     *                   {@code 123456789} in {@code Locale.US} locale,\\n     *                   if the given {@code fieldPosition} is\\n     *                   {@link NumberFormat#INTEGER_FIELD}, the begin index\\n     *                   and end index of {@code fieldPosition} will be set\\n     *                   to 0 and 11, respectively for the output string\\n     *                   {@code 123,456,789}.\\n     * @return the formatted StringBuffer\\n     * @throws           ArithmeticException if rounding is needed with rounding\\n     *                   mode being set to RoundingMode.UNNECESSARY\\n     * @see java.text.Format#format\\n     \u0027}"}, {"color": "#97c2fc", "id": "public abstract Number parse(String source, ParsePosition parsePosition)", "label": "public abstract Number parse(String source, ParsePosition parsePosition)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a Long if possible (e.g., within the range [Long.MIN_VALUE,\\n     * Long.MAX_VALUE] and with no decimals), otherwise a Double.\\n     * If IntegerOnly is set, will stop at a decimal\\n     * point (or equivalent; e.g., for rational numbers \"1 2/3\", will stop\\n     * after the 1).\\n     * Does not throw an exception; if no object can be parsed, index is\\n     * unchanged!\\n     *\\n     * @param source the String to parse\\n     * @param parsePosition the parse position\\n     * @return the parsed value\\n     * @see java.text.NumberFormat#isParseIntegerOnly\\n     * @see java.text.Format#parseObject\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Number parse(String source) throws ParseException", "label": "public Number parse(String source) throws ParseException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Parses text from the beginning of the given string to produce a number.\\n     * The method may not use the entire text of the given string.\\n     * \u003cp\u003e\\n     * See the {@link #parse(String, ParsePosition)} method for more information\\n     * on number parsing.\\n     *\\n     * @param source A {@code String} whose beginning should be parsed.\\n     * @return A {@code Number} parsed from the string.\\n     * @throws    ParseException if the beginning of the specified string\\n     *            cannot be parsed.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isParseIntegerOnly()", "label": "public boolean isParseIntegerOnly()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns true if this format will parse numbers as integers only.\\n     * For example in the English locale, with ParseIntegerOnly true, the\\n     * string \"1234.\" would be parsed as the integer value 1234 and parsing\\n     * would stop at the \".\" character.  Of course, the exact format accepted\\n     * by the parse operation is locale dependent and determined by sub-classes\\n     * of NumberFormat.\\n     *\\n     * @return {@code true} if numbers should be parsed as integers only;\\n     *         {@code false} otherwise\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void setParseIntegerOnly(boolean value)", "label": "public void setParseIntegerOnly(boolean value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets whether or not numbers should be parsed as integers only.\\n     *\\n     * @param value {@code true} if numbers should be parsed as integers only;\\n     *              {@code false} otherwise\\n     * @see #isParseIntegerOnly\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static final NumberFormat getInstance()", "label": "public static final NumberFormat getInstance()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a general-purpose number format for the current default\\n     * {@link java.util.Locale.Category#FORMAT FORMAT} locale.\\n     * This is the same as calling\\n     * {@link #getNumberInstance() getNumberInstance()}.\\n     *\\n     * @return the {@code NumberFormat} instance for general-purpose number\\n     * formatting\\n     \u0027}"}, {"color": "#97c2fc", "id": "getNumberInstance()", "label": "getNumberInstance()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static NumberFormat getInstance(Locale inLocale)", "label": "public static NumberFormat getInstance(Locale inLocale)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a general-purpose number format for the specified locale.\\n     * This is the same as calling\\n     * {@link #getNumberInstance(java.util.Locale) getNumberInstance(inLocale)}.\\n     *\\n     * @param inLocale the desired locale\\n     * @return the {@code NumberFormat} instance for general-purpose number\\n     * formatting\\n     \u0027}"}, {"color": "#97c2fc", "id": "getNumberInstance(java.util.Locale)", "label": "getNumberInstance(java.util.Locale)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static final NumberFormat getNumberInstance()", "label": "public static final NumberFormat getNumberInstance()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a general-purpose number format for the current default\\n     * {@link java.util.Locale.Category#FORMAT FORMAT} locale.\\n     * \u003cp\u003eThis is equivalent to calling\\n     * {@link #getNumberInstance(Locale)\\n     *     getNumberInstance(Locale.getDefault(Locale.Category.FORMAT))}.\\n     *\\n     * @return the {@code NumberFormat} instance for general-purpose number\\n     * formatting\\n     * @see java.util.Locale#getDefault(java.util.Locale.Category)\\n     * @see java.util.Locale.Category#FORMAT\\n     \u0027}"}, {"color": "#97c2fc", "id": "getNumberInstance(Locale)", "label": "getNumberInstance(Locale)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static NumberFormat getNumberInstance(Locale inLocale)", "label": "public static NumberFormat getNumberInstance(Locale inLocale)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a general-purpose number format for the specified locale.\\n     *\\n     * @param inLocale the desired locale\\n     * @return the {@code NumberFormat} instance for general-purpose number\\n     * formatting\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static final NumberFormat getIntegerInstance()", "label": "public static final NumberFormat getIntegerInstance()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an integer number format for the current default\\n     * {@link java.util.Locale.Category#FORMAT FORMAT} locale. The\\n     * returned number format is configured to round floating point numbers\\n     * to the nearest integer using half-even rounding (see {@link\\n     * java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}) for formatting,\\n     * and to parse only the integer part of an input string (see {@link\\n     * #isParseIntegerOnly isParseIntegerOnly}).\\n     * \u003cp\u003eThis is equivalent to calling\\n     * {@link #getIntegerInstance(Locale)\\n     *     getIntegerInstance(Locale.getDefault(Locale.Category.FORMAT))}.\\n     *\\n     * @see #getRoundingMode()\\n     * @see java.util.Locale#getDefault(java.util.Locale.Category)\\n     * @see java.util.Locale.Category#FORMAT\\n     * @return a number format for integer values\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "isParseIntegerOnly", "label": "isParseIntegerOnly", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "getIntegerInstance(Locale)", "label": "getIntegerInstance(Locale)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "HALF_EVEN", "label": "HALF_EVEN", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static NumberFormat getIntegerInstance(Locale inLocale)", "label": "public static NumberFormat getIntegerInstance(Locale inLocale)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an integer number format for the specified locale. The\\n     * returned number format is configured to round floating point numbers\\n     * to the nearest integer using half-even rounding (see {@link\\n     * java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}) for formatting,\\n     * and to parse only the integer part of an input string (see {@link\\n     * #isParseIntegerOnly isParseIntegerOnly}).\\n     *\\n     * @param inLocale the desired locale\\n     * @see #getRoundingMode()\\n     * @return a number format for integer values\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static final NumberFormat getCurrencyInstance()", "label": "public static final NumberFormat getCurrencyInstance()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a currency format for the current default\\n     * {@link java.util.Locale.Category#FORMAT FORMAT} locale.\\n     * \u003cp\u003eThis is equivalent to calling\\n     * {@link #getCurrencyInstance(Locale)\\n     *     getCurrencyInstance(Locale.getDefault(Locale.Category.FORMAT))}.\\n     *\\n     * @return the {@code NumberFormat} instance for currency formatting\\n     * @see java.util.Locale#getDefault(java.util.Locale.Category)\\n     * @see java.util.Locale.Category#FORMAT\\n     \u0027}"}, {"color": "#97c2fc", "id": "getCurrencyInstance(Locale)", "label": "getCurrencyInstance(Locale)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static NumberFormat getCurrencyInstance(Locale inLocale)", "label": "public static NumberFormat getCurrencyInstance(Locale inLocale)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a currency format for the specified locale.\\n     *\\n     * \u003cp\u003eIf the specified locale contains the \"{@code cf}\" (\\n     * \u003ca href=\"https://www.unicode.org/reports/tr35/tr35.html#UnicodeCurrencyFormatIdentifier\"\u003e\\n     * currency format style\u003c/a\u003e)\\n     * \u003ca href=\"../util/Locale.html#def_locale_extension\"\u003eUnicode extension\u003c/a\u003e,\\n     * the returned currency format uses the style if it is available.\\n     * Otherwise, the style uses the default \"{@code standard}\" currency format.\\n     * For example, if the style designates \"{@code account}\", negative\\n     * currency amounts use a pair of parentheses in some locales.\\n     *\\n     * @param inLocale the desired locale\\n     * @return the {@code NumberFormat} instance for currency formatting\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static final NumberFormat getPercentInstance()", "label": "public static final NumberFormat getPercentInstance()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a percentage format for the current default\\n     * {@link java.util.Locale.Category#FORMAT FORMAT} locale.\\n     * \u003cp\u003eThis is equivalent to calling\\n     * {@link #getPercentInstance(Locale)\\n     *     getPercentInstance(Locale.getDefault(Locale.Category.FORMAT))}.\\n     *\\n     * @return the {@code NumberFormat} instance for percentage formatting\\n     * @see java.util.Locale#getDefault(java.util.Locale.Category)\\n     * @see java.util.Locale.Category#FORMAT\\n     \u0027}"}, {"color": "#97c2fc", "id": "getPercentInstance(Locale)", "label": "getPercentInstance(Locale)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static NumberFormat getPercentInstance(Locale inLocale)", "label": "public static NumberFormat getPercentInstance(Locale inLocale)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a percentage format for the specified locale.\\n     *\\n     * @param inLocale the desired locale\\n     * @return the {@code NumberFormat} instance for percentage formatting\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Locale[] getAvailableLocales()", "label": "public static Locale[] getAvailableLocales()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a compact number format for the default\\n     * {@link java.util.Locale.Category#FORMAT FORMAT} locale with\\n     * {@link NumberFormat.Style#SHORT \"SHORT\"} format style.\\n     *\\n     * @return A {@code NumberFormat} instance for compact number\\n     *         formatting\\n     *\\n     * @see CompactNumberFormat\\n     * @see NumberFormat.Style\\n     * @see java.util.Locale#getDefault(java.util.Locale.Category)\\n     * @see java.util.Locale.Category#FORMAT\\n     * @since 12\\n     *\\n    public static NumberFormat getCompactNumberInstance() {\\n        return getInstance(Locale.getDefault(\\n                Locale.Category.FORMAT), NumberFormat.Style.SHORT, COMPACTSTYLE);\\n    }\\n\\n    /*\\n     * Returns a compact number format for the specified {@link java.util.Locale locale}\\n     * and {@link NumberFormat.Style formatStyle}.\\n     *\\n     * @param locale the desired locale\\n     * @param formatStyle the style for formatting a number\\n     * @return A {@code NumberFormat} instance for compact number\\n     *         formatting\\n     * @throws NullPointerException if {@code locale} or {@code formatStyle}\\n     *                              is {@code null}\\n     *\\n     * @see CompactNumberFormat\\n     * @see NumberFormat.Style\\n     * @see java.util.Locale\\n     * @since 12\\n     *\\n    public static NumberFormat getCompactNumberInstance(Locale locale,\\n            NumberFormat.Style formatStyle) {\\n\\n        Objects.requireNonNull(locale);\\n        Objects.requireNonNull(formatStyle);\\n        return getInstance(locale, formatStyle, COMPACTSTYLE);\\n    }\\n    // END Android-removed: Remove unsupprted CompactNumberFormat.\\n\\n    // Android-changed: Removed reference to NumberFormatProvider.\\n    /**\\n     * Returns an array of all locales for which the\\n     * {@code get*Instance} methods of this class can return\\n     * localized instances.\\n     * It must contain at least a {@code Locale} instance equal to\\n     * {@link java.util.Locale#US Locale.US}.\\n     *\\n     * @return An array of locales for which localized\\n     *         {@code NumberFormat} instances are available.\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.util.Locale", "label": "java.util.Locale", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "NumberFormat.Style", "label": "NumberFormat.Style", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public boolean isGroupingUsed()", "label": "public boolean isGroupingUsed()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns true if grouping is used in this format. For example, in the\\n     * English locale, with grouping on, the number 1234567 might be formatted\\n     * as \"1,234,567\". The grouping separator as well as the size of each group\\n     * is locale dependent and is determined by sub-classes of NumberFormat.\\n     *\\n     * @return {@code true} if grouping is used;\\n     *         {@code false} otherwise\\n     * @see #setGroupingUsed\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void setGroupingUsed(boolean newValue)", "label": "public void setGroupingUsed(boolean newValue)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Set whether or not grouping will be used in this format.\\n     *\\n     * @param newValue {@code true} if grouping is used;\\n     *                 {@code false} otherwise\\n     * @see #isGroupingUsed\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getMaximumIntegerDigits()", "label": "public int getMaximumIntegerDigits()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the maximum number of digits allowed in the integer portion of a\\n     * number.\\n     *\\n     * @return the maximum number of digits\\n     * @see #setMaximumIntegerDigits\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void setMaximumIntegerDigits(int newValue)", "label": "public void setMaximumIntegerDigits(int newValue)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the maximum number of digits allowed in the integer portion of a\\n     * number. maximumIntegerDigits must be \u0026ge; minimumIntegerDigits.  If the\\n     * new value for maximumIntegerDigits is less than the current value\\n     * of minimumIntegerDigits, then minimumIntegerDigits will also be set to\\n     * the new value.\\n     *\\n     * @param newValue the maximum number of integer digits to be shown; if\\n     * less than zero, then zero is used. The concrete subclass may enforce an\\n     * upper limit to this value appropriate to the numeric type being formatted.\\n     * @see #getMaximumIntegerDigits\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getMinimumIntegerDigits()", "label": "public int getMinimumIntegerDigits()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the minimum number of digits allowed in the integer portion of a\\n     * number.\\n     *\\n     * @return the minimum number of digits\\n     * @see #setMinimumIntegerDigits\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void setMinimumIntegerDigits(int newValue)", "label": "public void setMinimumIntegerDigits(int newValue)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the minimum number of digits allowed in the integer portion of a\\n     * number. minimumIntegerDigits must be \u0026le; maximumIntegerDigits.  If the\\n     * new value for minimumIntegerDigits exceeds the current value\\n     * of maximumIntegerDigits, then maximumIntegerDigits will also be set to\\n     * the new value\\n     *\\n     * @param newValue the minimum number of integer digits to be shown; if\\n     * less than zero, then zero is used. The concrete subclass may enforce an\\n     * upper limit to this value appropriate to the numeric type being formatted.\\n     * @see #getMinimumIntegerDigits\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getMaximumFractionDigits()", "label": "public int getMaximumFractionDigits()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the maximum number of digits allowed in the fraction portion of a\\n     * number.\\n     *\\n     * @return the maximum number of digits.\\n     * @see #setMaximumFractionDigits\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void setMaximumFractionDigits(int newValue)", "label": "public void setMaximumFractionDigits(int newValue)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the maximum number of digits allowed in the fraction portion of a\\n     * number. maximumFractionDigits must be \u0026ge; minimumFractionDigits.  If the\\n     * new value for maximumFractionDigits is less than the current value\\n     * of minimumFractionDigits, then minimumFractionDigits will also be set to\\n     * the new value.\\n     *\\n     * @param newValue the maximum number of fraction digits to be shown; if\\n     * less than zero, then zero is used. The concrete subclass may enforce an\\n     * upper limit to this value appropriate to the numeric type being formatted.\\n     * @see #getMaximumFractionDigits\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int getMinimumFractionDigits()", "label": "public int getMinimumFractionDigits()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the minimum number of digits allowed in the fraction portion of a\\n     * number.\\n     *\\n     * @return the minimum number of digits\\n     * @see #setMinimumFractionDigits\\n     \u0027}"}, {"color": "#97c2fc", "id": "public void setMinimumFractionDigits(int newValue)", "label": "public void setMinimumFractionDigits(int newValue)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the minimum number of digits allowed in the fraction portion of a\\n     * number. minimumFractionDigits must be \u0026le; maximumFractionDigits.  If the\\n     * new value for minimumFractionDigits exceeds the current value\\n     * of maximumFractionDigits, then maximumFractionDigits will also be set to\\n     * the new value\\n     *\\n     * @param newValue the minimum number of fraction digits to be shown; if\\n     * less than zero, then zero is used. The concrete subclass may enforce an\\n     * upper limit to this value appropriate to the numeric type being formatted.\\n     * @see #getMinimumFractionDigits\\n     \u0027}"}, {"color": "#97c2fc", "id": "public Currency getCurrency()", "label": "public Currency getCurrency()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Gets the currency used by this number format when formatting\\n     * currency values. The initial value is derived in a locale dependent\\n     * way. The returned value may be null if no valid\\n     * currency could be determined and no currency has been set using\\n     * {@link #setCurrency(java.util.Currency) setCurrency}.\\n     * \u003cp\u003e\\n     * The default implementation throws\\n     * {@code UnsupportedOperationException}.\\n     *\\n     * @return the currency used by this number format, or {@code null}\\n     * @throws    UnsupportedOperationException if the number format class\\n     * doesn\u0027t implement currency formatting\\n     * @since 1.4\\n     \"}"}, {"color": "#97c2fc", "id": "setCurrency(java.util.Currency)", "label": "setCurrency(java.util.Currency)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public void setCurrency(Currency currency)", "label": "public void setCurrency(Currency currency)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Sets the currency used by this number format when formatting\\n     * currency values. This does not update the minimum or maximum\\n     * number of fraction digits used by the number format.\\n     * \u003cp\u003e\\n     * The default implementation throws\\n     * {@code UnsupportedOperationException}.\\n     *\\n     * @param currency the new currency to be used by this number format\\n     * @throws    UnsupportedOperationException if the number format class\\n     * doesn\u0027t implement currency formatting\\n     * @throws    NullPointerException if {@code currency} is null\\n     * @since 1.4\\n     \"}"}, {"color": "#97c2fc", "id": "public RoundingMode getRoundingMode()", "label": "public RoundingMode getRoundingMode()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Gets the {@link java.math.RoundingMode} used in this NumberFormat.\\n     * The default implementation of this method in NumberFormat\\n     * always throws {@link java.lang.UnsupportedOperationException}.\\n     * Subclasses which handle different rounding modes should override\\n     * this method.\\n     *\\n     * @throws    UnsupportedOperationException The default implementation\\n     *     always throws this exception\\n     * @return The {@code RoundingMode} used for this NumberFormat.\\n     * @see #setRoundingMode(RoundingMode)\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.lang.UnsupportedOperationException", "label": "java.lang.UnsupportedOperationException", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * Thrown to indicate that the requested operation is not supported.\u003cp\u003e\\n *\\n * This class is a member of the\\n * \u003ca href=\"{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework\"\u003e\\n * Java Collections Framework\u003c/a\u003e.\\n *\\n * @author  Josh Bloch\\n * @since   1.2\\n \u0027}"}, {"color": "#97c2fc", "id": "java.math.RoundingMode", "label": "java.math.RoundingMode", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "public void setRoundingMode(RoundingMode roundingMode)", "label": "public void setRoundingMode(RoundingMode roundingMode)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Sets the {@link java.math.RoundingMode} used in this NumberFormat.\\n     * The default implementation of this method in NumberFormat always\\n     * throws {@link java.lang.UnsupportedOperationException}.\\n     * Subclasses which handle different rounding modes should override\\n     * this method.\\n     *\\n     * @throws    UnsupportedOperationException The default implementation\\n     *     always throws this exception\\n     * @throws    NullPointerException if {@code roundingMode} is null\\n     * @param roundingMode The {@code RoundingMode} to be used\\n     * @see #getRoundingMode()\\n     * @since 1.6\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException", "label": "private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * First, read in the default serializable data.\\n     *\\n     * Then, if {@code serialVersionOnStream} is less than 1, indicating that\\n     * the stream was written by JDK 1.1,\\n     * set the {@code int} fields such as {@code maximumIntegerDigits}\\n     * to be equal to the {@code byte} fields such as {@code maxIntegerDigits},\\n     * since the {@code int} fields were not present in JDK 1.1.\\n     * Finally, set serialVersionOnStream back to the maximum allowed value so that\\n     * default serialization will work properly if this object is streamed out again.\\n     *\\n     * \u003cp\u003eIf {@code minimumIntegerDigits} is greater than\\n     * {@code maximumIntegerDigits} or {@code minimumFractionDigits}\\n     * is greater than {@code maximumFractionDigits}, then the stream data\\n     * is invalid and this method throws an {@code InvalidObjectException}.\\n     * In addition, if any of these values is negative, then this method throws\\n     * an {@code InvalidObjectException}.\\n     *\\n     * @since 1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "private void writeObject(ObjectOutputStream stream) throws IOException", "label": "private void writeObject(ObjectOutputStream stream) throws IOException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Write out the default serializable data, after first setting\\n     * the {@code byte} fields such as {@code maxIntegerDigits} to be\\n     * equal to the {@code int} fields such as {@code maximumIntegerDigits}\\n     * (or to {@code Byte.MAX_VALUE}, whichever is smaller), for compatibility\\n     * with the JDK 1.1 version of the stream format.\\n     *\\n     * @since 1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static String toHexString(double d)", "label": "public static String toHexString(double d)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a hexadecimal string representation of the\\n     * {@code double} argument. All characters mentioned below\\n     * are ASCII characters.\\n     *\\n     * \u003cul\u003e\\n     * \u003cli\u003eIf the argument is NaN, the result is the string\\n     *     \"{@code NaN}\".\\n     * \u003cli\u003eOtherwise, the result is a string that represents the sign\\n     * and magnitude of the argument. If the sign is negative, the\\n     * first character of the result is \\\u0027{@code -}\\\u0027\\n     * ({@code \\\u0027\\\\u005Cu002D\\\u0027}); if the sign is positive, no sign\\n     * character appears in the result. As for the magnitude \u003ci\u003em\u003c/i\u003e:\\n     *\\n     * \u003cul\u003e\\n     * \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is infinity, it is represented by the string\\n     * {@code \"Infinity\"}; thus, positive infinity produces the\\n     * result {@code \"Infinity\"} and negative infinity produces\\n     * the result {@code \"-Infinity\"}.\\n     *\\n     * \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is zero, it is represented by the string\\n     * {@code \"0x0.0p0\"}; thus, negative zero produces the result\\n     * {@code \"-0x0.0p0\"} and positive zero produces the result\\n     * {@code \"0x0.0p0\"}.\\n     *\\n     * \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is a {@code double} value with a\\n     * normalized representation, substrings are used to represent the\\n     * significand and exponent fields.  The significand is\\n     * represented by the characters {@code \"0x1.\"}\\n     * followed by a lowercase hexadecimal representation of the rest\\n     * of the significand as a fraction.  Trailing zeros in the\\n     * hexadecimal representation are removed unless all the digits\\n     * are zero, in which case a single zero is used. Next, the\\n     * exponent is represented by {@code \"p\"} followed\\n     * by a decimal string of the unbiased exponent as if produced by\\n     * a call to {@link Integer#toString(int) Integer.toString} on the\\n     * exponent value.\\n     *\\n     * \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is a {@code double} value with a subnormal\\n     * representation, the significand is represented by the\\n     * characters {@code \"0x0.\"} followed by a\\n     * hexadecimal representation of the rest of the significand as a\\n     * fraction.  Trailing zeros in the hexadecimal representation are\\n     * removed. Next, the exponent is represented by\\n     * {@code \"p-1022\"}.  Note that there must be at\\n     * least one nonzero digit in a subnormal significand.\\n     *\\n     * \u003c/ul\u003e\\n     *\\n     * \u003c/ul\u003e\\n     *\\n     * \u003ctable class=\"striped\"\u003e\\n     * \u003ccaption\u003eExamples\u003c/caption\u003e\\n     * \u003cthead\u003e\\n     * \u003ctr\u003e\u003cth scope=\"col\"\u003eFloating-point Value\u003c/th\u003e\u003cth scope=\"col\"\u003eHexadecimal String\u003c/th\u003e\\n     * \u003c/thead\u003e\\n     * \u003ctbody style=\"text-align:right\"\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\"\u003e{@code 1.0}\u003c/th\u003e \u003ctd\u003e{@code 0x1.0p0}\u003c/td\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\"\u003e{@code -1.0}\u003c/th\u003e        \u003ctd\u003e{@code -0x1.0p0}\u003c/td\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\"\u003e{@code 2.0}\u003c/th\u003e \u003ctd\u003e{@code 0x1.0p1}\u003c/td\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\"\u003e{@code 3.0}\u003c/th\u003e \u003ctd\u003e{@code 0x1.8p1}\u003c/td\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\"\u003e{@code 0.5}\u003c/th\u003e \u003ctd\u003e{@code 0x1.0p-1}\u003c/td\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\"\u003e{@code 0.25}\u003c/th\u003e        \u003ctd\u003e{@code 0x1.0p-2}\u003c/td\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\"\u003e{@code Double.MAX_VALUE}\u003c/th\u003e\\n     *     \u003ctd\u003e{@code 0x1.fffffffffffffp1023}\u003c/td\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\"\u003e{@code Minimum Normal Value}\u003c/th\u003e\\n     *     \u003ctd\u003e{@code 0x1.0p-1022}\u003c/td\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\"\u003e{@code Maximum Subnormal Value}\u003c/th\u003e\\n     *     \u003ctd\u003e{@code 0x0.fffffffffffffp-1022}\u003c/td\u003e\\n     * \u003ctr\u003e\u003cth scope=\"row\"\u003e{@code Double.MIN_VALUE}\u003c/th\u003e\\n     *     \u003ctd\u003e{@code 0x0.0000000000001p-1022}\u003c/td\u003e\\n     * \u003c/tbody\u003e\\n     * \u003c/table\u003e\\n     * @param   d   the {@code double} to be converted.\\n     * @return a hex string representation of the argument.\\n     * @since 1.5\\n     * @author Joseph D. Darcy\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Double valueOf(String s) throws NumberFormatException", "label": "public static Double valueOf(String s) throws NumberFormatException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Double} object holding the\\n     * {@code double} value represented by the argument string\\n     * {@code s}.\\n     *\\n     * \u003cp\u003eIf {@code s} is {@code null}, then a\\n     * {@code NullPointerException} is thrown.\\n     *\\n     * \u003cp\u003eLeading and trailing whitespace characters in {@code s}\\n     * are ignored.  Whitespace is removed as if by the {@link\\n     * String#trim} method; that is, both ASCII space and control\\n     * characters are removed. The rest of {@code s} should\\n     * constitute a \u003ci\u003eFloatValue\u003c/i\u003e as described by the lexical\\n     * syntax rules:\\n     *\\n     * \u003cblockquote\u003e\\n     * \u003cdl\u003e\\n     * \u003cdt\u003e\u003ci\u003eFloatValue:\u003c/i\u003e\\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code NaN}\\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code Infinity}\\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e FloatingPointLiteral\u003c/i\u003e\\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e HexFloatingPointLiteral\u003c/i\u003e\\n     * \u003cdd\u003e\u003ci\u003eSignedInteger\u003c/i\u003e\\n     * \u003c/dl\u003e\\n     *\\n     * \u003cdl\u003e\\n     * \u003cdt\u003e\u003ci\u003eHexFloatingPointLiteral\u003c/i\u003e:\\n     * \u003cdd\u003e \u003ci\u003eHexSignificand BinaryExponent FloatTypeSuffix\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e\\n     * \u003c/dl\u003e\\n     *\\n     * \u003cdl\u003e\\n     * \u003cdt\u003e\u003ci\u003eHexSignificand:\u003c/i\u003e\\n     * \u003cdd\u003e\u003ci\u003eHexNumeral\u003c/i\u003e\\n     * \u003cdd\u003e\u003ci\u003eHexNumeral\u003c/i\u003e {@code .}\\n     * \u003cdd\u003e{@code 0x} \u003ci\u003eHexDigits\u003csub\u003eopt\u003c/sub\u003e\\n     *     \u003c/i\u003e{@code .}\u003ci\u003e HexDigits\u003c/i\u003e\\n     * \u003cdd\u003e{@code 0X}\u003ci\u003e HexDigits\u003csub\u003eopt\u003c/sub\u003e\\n     *     \u003c/i\u003e{@code .} \u003ci\u003eHexDigits\u003c/i\u003e\\n     * \u003c/dl\u003e\\n     *\\n     * \u003cdl\u003e\\n     * \u003cdt\u003e\u003ci\u003eBinaryExponent:\u003c/i\u003e\\n     * \u003cdd\u003e\u003ci\u003eBinaryExponentIndicator SignedInteger\u003c/i\u003e\\n     * \u003c/dl\u003e\\n     *\\n     * \u003cdl\u003e\\n     * \u003cdt\u003e\u003ci\u003eBinaryExponentIndicator:\u003c/i\u003e\\n     * \u003cdd\u003e{@code p}\\n     * \u003cdd\u003e{@code P}\\n     * \u003c/dl\u003e\\n     *\\n     * \u003c/blockquote\u003e\\n     *\\n     * where \u003ci\u003eSign\u003c/i\u003e, \u003ci\u003eFloatingPointLiteral\u003c/i\u003e,\\n     * \u003ci\u003eHexNumeral\u003c/i\u003e, \u003ci\u003eHexDigits\u003c/i\u003e, \u003ci\u003eSignedInteger\u003c/i\u003e and\\n     * \u003ci\u003eFloatTypeSuffix\u003c/i\u003e are as defined in the lexical structure\\n     * sections of\\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e,\\n     * except that underscores are not accepted between digits.\\n     * If {@code s} does not have the form of\\n     * a \u003ci\u003eFloatValue\u003c/i\u003e, then a {@code NumberFormatException}\\n     * is thrown. Otherwise, {@code s} is regarded as\\n     * representing an exact decimal value in the usual\\n     * \"computerized scientific notation\" or as an exact\\n     * hexadecimal value; this exact numerical value is then\\n     * conceptually converted to an \"infinitely precise\"\\n     * binary value that is then rounded to type {@code double}\\n     * by the usual round-to-nearest rule of IEEE 754 floating-point\\n     * arithmetic, which includes preserving the sign of a zero\\n     * value.\\n     *\\n     * Note that the round-to-nearest rule also implies overflow and\\n     * underflow behaviour; if the exact value of {@code s} is large\\n     * enough in magnitude (greater than or equal to ({@link\\n     * #MAX_VALUE} + {@link Math#ulp(double) ulp(MAX_VALUE)}/2),\\n     * rounding to {@code double} will result in an infinity and if the\\n     * exact value of {@code s} is small enough in magnitude (less\\n     * than or equal to {@link #MIN_VALUE}/2), rounding to float will\\n     * result in a zero.\\n     *\\n     * Finally, after rounding a {@code Double} object representing\\n     * this {@code double} value is returned.\\n     *\\n     * \u003cp\u003e To interpret localized string representations of a\\n     * floating-point value, use subclasses of {@link\\n     * java.text.NumberFormat}.\\n     *\\n     * \u003cp\u003eNote that trailing format specifiers, specifiers that\\n     * determine the type of a floating-point literal\\n     * ({@code 1.0f} is a {@code float} value;\\n     * {@code 1.0d} is a {@code double} value), do\\n     * \u003cem\u003enot\u003c/em\u003e influence the results of this method.  In other\\n     * words, the numerical value of the input string is converted\\n     * directly to the target floating-point type.  The two-step\\n     * sequence of conversions, string to {@code float} followed\\n     * by {@code float} to {@code double}, is \u003cem\u003enot\u003c/em\u003e\\n     * equivalent to converting a string directly to\\n     * {@code double}. For example, the {@code float}\\n     * literal {@code 0.1f} is equal to the {@code double}\\n     * value {@code 0.10000000149011612}; the {@code float}\\n     * literal {@code 0.1f} represents a different numerical\\n     * value than the {@code double} literal\\n     * {@code 0.1}. (The numerical value 0.1 cannot be exactly\\n     * represented in a binary floating-point number.)\\n     *\\n     * \u003cp\u003eTo avoid calling this method on an invalid string and having\\n     * a {@code NumberFormatException} be thrown, the regular\\n     * expression below can be used to screen the input string:\\n     *\\n     * \u003cpre\u003e{@code\\n     *  final String Digits     = \"(\\\\\\\\p{Digit}+)\";\\n     *  final String HexDigits  = \"(\\\\\\\\p{XDigit}+)\";\\n     *  // an exponent is \\\u0027e\\\u0027 or \\\u0027E\\\u0027 followed by an optionally\\n     *  // signed decimal integer.\\n     *  final String Exp        = \"[eE][+-]?\"+Digits;\\n     *  final String fpRegex    =\\n     *      (\"[\\\\\\\\x00-\\\\\\\\x20]*\"+  // Optional leading \"whitespace\"\\n     *       \"[+-]?(\" + // Optional sign character\\n     *       \"NaN|\" +           // \"NaN\" string\\n     *       \"Infinity|\" +      // \"Infinity\" string\\n     *\\n     *       // A decimal floating-point string representing a finite positive\\n     *       // number without a leading sign has at most five basic pieces:\\n     *       // Digits . Digits ExponentPart FloatTypeSuffix\\n     *       //\\n     *       // Since this method allows integer-only strings as input\\n     *       // in addition to strings of floating-point literals, the\\n     *       // two sub-patterns below are simplifications of the grammar\\n     *       // productions from section 3.10.2 of\\n     *       // The Java Language Specification.\\n     *\\n     *       // Digits ._opt Digits_opt ExponentPart_opt FloatTypeSuffix_opt\\n     *       \"(((\"+Digits+\"(\\\\\\\\.)?(\"+Digits+\"?)(\"+Exp+\")?)|\"+\\n     *\\n     *       // . Digits ExponentPart_opt FloatTypeSuffix_opt\\n     *       \"(\\\\\\\\.(\"+Digits+\")(\"+Exp+\")?)|\"+\\n     *\\n     *       // Hexadecimal strings\\n     *       \"((\" +\\n     *        // 0[xX] HexDigits ._opt BinaryExponent FloatTypeSuffix_opt\\n     *        \"(0[xX]\" + HexDigits + \"(\\\\\\\\.)?)|\" +\\n     *\\n     *        // 0[xX] HexDigits_opt . HexDigits BinaryExponent FloatTypeSuffix_opt\\n     *        \"(0[xX]\" + HexDigits + \"?(\\\\\\\\.)\" + HexDigits + \")\" +\\n     *\\n     *        \")[pP][+-]?\" + Digits + \"))\" +\\n     *       \"[fFdD]?))\" +\\n     *       \"[\\\\\\\\x00-\\\\\\\\x20]*\");// Optional trailing \"whitespace\"\\n     *\\n     *  if (Pattern.matches(fpRegex, myString))\\n     *      Double.valueOf(myString); // Will not throw NumberFormatException\\n     *  else {\\n     *      // Perform suitable alternative action\\n     *  }\\n     * }\u003c/pre\u003e\\n     *\\n     * @param      s   the string to be parsed.\\n     * @return     a {@code Double} object holding the value\\n     *             represented by the {@code String} argument.\\n     * @throws     NumberFormatException  if the string does not contain a\\n     *             parsable number.\\n     \u0027}"}, {"color": "#97c2fc", "id": "ulp(double)", "label": "ulp(double)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static Double valueOf(double d)", "label": "public static Double valueOf(double d)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Double} instance representing the specified\\n     * {@code double} value.\\n     * If a new {@code Double} instance is not required, this method\\n     * should generally be used in preference to the constructor\\n     * {@link #Double(double)}, as this method is likely to yield\\n     * significantly better space and time performance by caching\\n     * frequently requested values.\\n     *\\n     * @param  d a double value.\\n     * @return a {@code Double} instance representing {@code d}.\\n     * @since  1.5\\n     \u0027}"}, {"color": "#97c2fc", "id": "Double(double)", "label": "Double(double)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static double parseDouble(String s) throws NumberFormatException", "label": "public static double parseDouble(String s) throws NumberFormatException", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a new {@code double} initialized to the value\\n     * represented by the specified {@code String}, as performed\\n     * by the {@code valueOf} method of class\\n     * {@code Double}.\\n     *\\n     * @param  s   the string to be parsed.\\n     * @return the {@code double} value represented by the string\\n     *         argument.\\n     * @throws NullPointerException  if the string is null\\n     * @throws NumberFormatException if the string does not contain\\n     *         a parsable {@code double}.\\n     * @see    java.lang.Double#valueOf(String)\\n     * @since 1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isNaN(double v)", "label": "public static boolean isNaN(double v)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if the specified number is a\\n     * Not-a-Number (NaN) value, {@code false} otherwise.\\n     *\\n     * @param   v   the value to be tested.\\n     * @return  {@code true} if the value of the argument is NaN;\\n     *          {@code false} otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isInfinite(double v)", "label": "public static boolean isInfinite(double v)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if the specified number is infinitely\\n     * large in magnitude, {@code false} otherwise.\\n     *\\n     * @param   v   the value to be tested.\\n     * @return  {@code true} if the value of the argument is positive\\n     *          infinity or negative infinity; {@code false} otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static boolean isFinite(double d)", "label": "public static boolean isFinite(double d)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if the argument is a finite floating-point\\n     * value; returns {@code false} otherwise (for NaN and infinity\\n     * arguments).\\n     *\\n     * @param d the {@code double} value to be tested\\n     * @return {@code true} if the argument is a finite\\n     * floating-point value, {@code false} otherwise.\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isNaN()", "label": "public boolean isNaN()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if this {@code Double} value is\\n     * a Not-a-Number (NaN), {@code false} otherwise.\\n     *\\n     * @return  {@code true} if the value represented by this object is\\n     *          NaN; {@code false} otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public boolean isInfinite()", "label": "public boolean isInfinite()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns {@code true} if this {@code Double} value is\\n     * infinitely large in magnitude, {@code false} otherwise.\\n     *\\n     * @return  {@code true} if the value represented by this object is\\n     *          positive infinity or negative infinity;\\n     *          {@code false} otherwise.\\n     \u0027}"}, {"color": "#97c2fc", "id": "doubleToLongBits(double)", "label": "doubleToLongBits(double)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int hashCode(double value)", "label": "public static int hashCode(double value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a hash code for a {@code double} value; compatible with\\n     * {@code Double.hashCode()}.\\n     *\\n     * @param value the value to hash\\n     * @return a hash code value for a {@code double} value.\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static long doubleToLongBits(double value)", "label": "public static long doubleToLongBits(double value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a representation of the specified floating-point value\\n     * according to the IEEE 754 floating-point \"double\\n     * format\" bit layout.\\n     *\\n     * \u003cp\u003eBit 63 (the bit that is selected by the mask\\n     * {@code 0x8000000000000000L}) represents the sign of the\\n     * floating-point number. Bits\\n     * 62-52 (the bits that are selected by the mask\\n     * {@code 0x7ff0000000000000L}) represent the exponent. Bits 51-0\\n     * (the bits that are selected by the mask\\n     * {@code 0x000fffffffffffffL}) represent the significand\\n     * (sometimes called the mantissa) of the floating-point number.\\n     *\\n     * \u003cp\u003eIf the argument is positive infinity, the result is\\n     * {@code 0x7ff0000000000000L}.\\n     *\\n     * \u003cp\u003eIf the argument is negative infinity, the result is\\n     * {@code 0xfff0000000000000L}.\\n     *\\n     * \u003cp\u003eIf the argument is NaN, the result is\\n     * {@code 0x7ff8000000000000L}.\\n     *\\n     * \u003cp\u003eIn all cases, the result is a {@code long} integer that, when\\n     * given to the {@link #longBitsToDouble(long)} method, will produce a\\n     * floating-point value the same as the argument to\\n     * {@code doubleToLongBits} (except all NaN values are\\n     * collapsed to a single \"canonical\" NaN value).\\n     *\\n     * @param   value   a {@code double} precision floating-point number.\\n     * @return the bits that represent the floating-point number.\\n     \u0027}"}, {"color": "#97c2fc", "id": "longBitsToDouble(long)", "label": "longBitsToDouble(long)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static native long doubleToRawLongBits(double value)", "label": "public static native long doubleToRawLongBits(double value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a representation of the specified floating-point value\\n     * according to the IEEE 754 floating-point \"double\\n     * format\" bit layout, preserving Not-a-Number (NaN) values.\\n     *\\n     * \u003cp\u003eBit 63 (the bit that is selected by the mask\\n     * {@code 0x8000000000000000L}) represents the sign of the\\n     * floating-point number. Bits\\n     * 62-52 (the bits that are selected by the mask\\n     * {@code 0x7ff0000000000000L}) represent the exponent. Bits 51-0\\n     * (the bits that are selected by the mask\\n     * {@code 0x000fffffffffffffL}) represent the significand\\n     * (sometimes called the mantissa) of the floating-point number.\\n     *\\n     * \u003cp\u003eIf the argument is positive infinity, the result is\\n     * {@code 0x7ff0000000000000L}.\\n     *\\n     * \u003cp\u003eIf the argument is negative infinity, the result is\\n     * {@code 0xfff0000000000000L}.\\n     *\\n     * \u003cp\u003eIf the argument is NaN, the result is the {@code long}\\n     * integer representing the actual NaN value.  Unlike the\\n     * {@code doubleToLongBits} method,\\n     * {@code doubleToRawLongBits} does not collapse all the bit\\n     * patterns encoding a NaN to a single \"canonical\" NaN\\n     * value.\\n     *\\n     * \u003cp\u003eIn all cases, the result is a {@code long} integer that,\\n     * when given to the {@link #longBitsToDouble(long)} method, will\\n     * produce a floating-point value the same as the argument to\\n     * {@code doubleToRawLongBits}.\\n     *\\n     * @param   value   a {@code double} precision floating-point number.\\n     * @return the bits that represent the floating-point number.\\n     * @since 1.3\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static native double longBitsToDouble(long bits)", "label": "public static native double longBitsToDouble(long bits)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the {@code double} value corresponding to a given\\n     * bit representation.\\n     * The argument is considered to be a representation of a\\n     * floating-point value according to the IEEE 754 floating-point\\n     * \"double format\" bit layout.\\n     *\\n     * \u003cp\u003eIf the argument is {@code 0x7ff0000000000000L}, the result\\n     * is positive infinity.\\n     *\\n     * \u003cp\u003eIf the argument is {@code 0xfff0000000000000L}, the result\\n     * is negative infinity.\\n     *\\n     * \u003cp\u003eIf the argument is any value in the range\\n     * {@code 0x7ff0000000000001L} through\\n     * {@code 0x7fffffffffffffffL} or in the range\\n     * {@code 0xfff0000000000001L} through\\n     * {@code 0xffffffffffffffffL}, the result is a NaN.  No IEEE\\n     * 754 floating-point operation provided by Java can distinguish\\n     * between two NaN values of the same type with different bit\\n     * patterns.  Distinct values of NaN are only distinguishable by\\n     * use of the {@code Double.doubleToRawLongBits} method.\\n     *\\n     * \u003cp\u003eIn all other cases, let \u003ci\u003es\u003c/i\u003e, \u003ci\u003ee\u003c/i\u003e, and \u003ci\u003em\u003c/i\u003e be three\\n     * values that can be computed from the argument:\\n     *\\n     * \u003cblockquote\u003e\u003cpre\u003e{@code\\n     * int s = ((bits \u003e\u003e 63) == 0) ? 1 : -1;\\n     * int e = (int)((bits \u003e\u003e 52) \u0026 0x7ffL);\\n     * long m = (e == 0) ?\\n     *                 (bits \u0026 0xfffffffffffffL) \u003c\u003c 1 :\\n     *                 (bits \u0026 0xfffffffffffffL) | 0x10000000000000L;\\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\\n     *\\n     * Then the floating-point result equals the value of the mathematical\\n     * expression \u003ci\u003es\u003c/i\u003e\u0026middot;\u003ci\u003em\u003c/i\u003e\u0026middot;2\u003csup\u003e\u003ci\u003ee\u003c/i\u003e-1075\u003c/sup\u003e.\\n     *\\n     * \u003cp\u003eNote that this method may not be able to return a\\n     * {@code double} NaN with exactly same bit pattern as the\\n     * {@code long} argument.  IEEE 754 distinguishes between two\\n     * kinds of NaNs, quiet NaNs and \u003ci\u003esignaling NaNs\u003c/i\u003e.  The\\n     * differences between the two kinds of NaN are generally not\\n     * visible in Java.  Arithmetic operations on signaling NaNs turn\\n     * them into quiet NaNs with a different, but often similar, bit\\n     * pattern.  However, on some processors merely copying a\\n     * signaling NaN also performs that conversion.  In particular,\\n     * copying a signaling NaN to return it to the calling method\\n     * may perform this conversion.  So {@code longBitsToDouble}\\n     * may not be able to return a {@code double} with a\\n     * signaling NaN bit pattern.  Consequently, for some\\n     * {@code long} values,\\n     * {@code doubleToRawLongBits(longBitsToDouble(start))} may\\n     * \u003ci\u003enot\u003c/i\u003e equal {@code start}.  Moreover, which\\n     * particular bit patterns represent signaling NaNs is platform\\n     * dependent; although all NaN bit patterns, quiet or signaling,\\n     * must be in the NaN range identified above.\\n     *\\n     * @param   bits   any {@code long} integer.\\n     * @return  the {@code double} floating-point value with the same\\n     *          bit pattern.\\n     \u0027}"}, {"color": "#97c2fc", "id": "public int compareTo(Double anotherDouble)", "label": "public int compareTo(Double anotherDouble)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code Double} objects numerically.\\n     *\\n     * This method imposes a total order on {@code Double} objects\\n     * with two differences compared to the incomplete order defined by\\n     * the Java language numerical comparison operators ({@code \u003c, \u003c=,\\n     * ==, \u003e=, \u003e}) on {@code double} values.\\n     *\\n     * \u003cul\u003e\u003cli\u003e A NaN is \u003cem\u003eunordered\u003c/em\u003e with respect to other\\n     *          values and unequal to itself under the comparison\\n     *          operators.  This method chooses to define {@code\\n     *          Double.NaN} to be equal to itself and greater than all\\n     *          other {@code double} values (including {@code\\n     *          Double.POSITIVE_INFINITY}).\\n     *\\n     *      \u003cli\u003e Positive zero and negative zero compare equal\\n     *      numerically, but are distinct and distinguishable values.\\n     *      This method chooses to define positive zero ({@code +0.0d}),\\n     *      to be greater than negative zero ({@code -0.0d}).\\n     * \u003c/ul\u003e\\n\\n     * This ensures that the \u003ci\u003enatural ordering\u003c/i\u003e of {@code Double}\\n     * objects imposed by this method is \u003ci\u003econsistent with\\n     * equals\u003c/i\u003e; see \u003ca href=\"#equivalenceRelation\"\u003ethis\\n     * discussion\u003c/a\u003e for details of floating-point comparison and\\n     * ordering.\\n     *\\n     * @param   anotherDouble   the {@code Double} to be compared.\\n     * @return  the value {@code 0} if {@code anotherDouble} is\\n     *          numerically equal to this {@code Double}; a value\\n     *          less than {@code 0} if this {@code Double}\\n     *          is numerically less than {@code anotherDouble};\\n     *          and a value greater than {@code 0} if this\\n     *          {@code Double} is numerically greater than\\n     *          {@code anotherDouble}.\\n     *\\n     * @jls 15.20.1 Numerical Comparison Operators {@code \u003c}, {@code \u003c=}, {@code \u003e}, and {@code \u003e=}\\n     * @since   1.2\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int compare(double d1, double d2)", "label": "public static int compare(double d1, double d2)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares the two specified {@code double} values. The sign\\n     * of the integer value returned is the same as that of the\\n     * integer that would be returned by the call:\\n     * \u003cpre\u003e\\n     *    new Double(d1).compareTo(new Double(d2))\\n     * \u003c/pre\u003e\\n     *\\n     * @param   d1        the first {@code double} to compare\\n     * @param   d2        the second {@code double} to compare\\n     * @return  the value {@code 0} if {@code d1} is\\n     *          numerically equal to {@code d2}; a value less than\\n     *          {@code 0} if {@code d1} is numerically less than\\n     *          {@code d2}; and a value greater than {@code 0}\\n     *          if {@code d1} is numerically greater than\\n     *          {@code d2}.\\n     * @since 1.4\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static double sum(double a, double b)", "label": "public static double sum(double a, double b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Adds two {@code double} values together as per the + operator.\\n     *\\n     * @param a the first operand\\n     * @param b the second operand\\n     * @return the sum of {@code a} and {@code b}\\n     * @jls 4.2.4 Floating-Point Operations\\n     * @see java.util.function.BinaryOperator\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static double max(double a, double b)", "label": "public static double max(double a, double b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the greater of two {@code double} values\\n     * as if by calling {@link Math#max(double, double) Math.max}.\\n     *\\n     * @param a the first operand\\n     * @param b the second operand\\n     * @return the greater of {@code a} and {@code b}\\n     * @see java.util.function.BinaryOperator\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "max(double", "label": "max(double", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static double min(double a, double b)", "label": "public static double min(double a, double b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the smaller of two {@code double} values\\n     * as if by calling {@link Math#min(double, double) Math.min}.\\n     *\\n     * @param a the first operand\\n     * @param b the second operand\\n     * @return the smaller of {@code a} and {@code b}.\\n     * @see java.util.function.BinaryOperator\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "min(double", "label": "min(double", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " DoubleStream sorted()", "label": " DoubleStream sorted()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the elements of this stream in sorted\\n     * order. The elements are compared for equality according to\\n     * {@link java.lang.Double#compare(double, double)}.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003estateful\\n     * intermediate operation\u003c/a\u003e.\\n     *\\n     * @return the result stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " DoubleStream peek(DoubleConsumer action)", "label": " DoubleStream peek(DoubleConsumer action)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the elements of this stream, additionally\\n     * performing the provided action on each element as elements are consumed\\n     * from the resulting stream.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eFor parallel stream pipelines, the action may be called at\\n     * whatever time and in whatever thread the element is made available by the\\n     * upstream operation.  If the action modifies shared state,\\n     * it is responsible for providing the required synchronization.\\n     *\\n     * @apiNote This method exists mainly to support debugging, where you want\\n     * to see the elements as they flow past a certain point in a pipeline:\\n     * \u003cpre\u003e{@code\\n     *     DoubleStream.of(1, 2, 3, 4)\\n     *         .filter(e -\u003e e \u003e 2)\\n     *         .peek(e -\u003e System.out.println(\"Filtered value: \" + e))\\n     *         .map(e -\u003e e * e)\\n     *         .peek(e -\u003e System.out.println(\"Mapped value: \" + e))\\n     *         .sum();\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eIn cases where the stream implementation is able to optimize away the\\n     * production of some or all the elements (such as with short-circuiting\\n     * operations like {@code findFirst}, or in the example described in\\n     * {@link #count}), the action will not be invoked for those elements.\\n     *\\n     * @param action a \u003ca href=\"package-summary.html#NonInterference\"\u003e\\n     *               non-interfering\u003c/a\u003e action to perform on the elements as\\n     *               they are consumed from the stream\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " DoubleStream limit(long maxSize)", "label": " DoubleStream limit(long maxSize)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the elements of this stream, truncated\\n     * to be no longer than {@code maxSize} in length.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * stateful intermediate operation\u003c/a\u003e.\\n     *\\n     * @apiNote\\n     * While {@code limit()} is generally a cheap operation on sequential\\n     * stream pipelines, it can be quite expensive on ordered parallel pipelines,\\n     * especially for large values of {@code maxSize}, since {@code limit(n)}\\n     * is constrained to return not just any \u003cem\u003en\u003c/em\u003e elements, but the\\n     * \u003cem\u003efirst n\u003c/em\u003e elements in the encounter order.  Using an unordered\\n     * stream source (such as {@link #generate(DoubleSupplier)}) or removing the\\n     * ordering constraint with {@link #unordered()} may result in significant\\n     * speedups of {@code limit()} in parallel pipelines, if the semantics of\\n     * your situation permit.  If consistency with encounter order is required,\\n     * and you are experiencing poor performance or memory utilization with\\n     * {@code limit()} in parallel pipelines, switching to sequential execution\\n     * with {@link #sequential()} may improve performance.\\n     *\\n     * @param maxSize the number of elements the stream should be limited to\\n     * @return the new stream\\n     * @throws IllegalArgumentException if {@code maxSize} is negative\\n     \u0027}"}, {"color": "#97c2fc", "id": "generate(DoubleSupplier)", "label": "generate(DoubleSupplier)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " DoubleStream skip(long n)", "label": " DoubleStream skip(long n)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the remaining elements of this stream\\n     * after discarding the first {@code n} elements of the stream.\\n     * If this stream contains fewer than {@code n} elements then an\\n     * empty stream will be returned.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003estateful\\n     * intermediate operation\u003c/a\u003e.\\n     *\\n     * @apiNote\\n     * While {@code skip()} is generally a cheap operation on sequential\\n     * stream pipelines, it can be quite expensive on ordered parallel pipelines,\\n     * especially for large values of {@code n}, since {@code skip(n)}\\n     * is constrained to skip not just any \u003cem\u003en\u003c/em\u003e elements, but the\\n     * \u003cem\u003efirst n\u003c/em\u003e elements in the encounter order.  Using an unordered\\n     * stream source (such as {@link #generate(DoubleSupplier)}) or removing the\\n     * ordering constraint with {@link #unordered()} may result in significant\\n     * speedups of {@code skip()} in parallel pipelines, if the semantics of\\n     * your situation permit.  If consistency with encounter order is required,\\n     * and you are experiencing poor performance or memory utilization with\\n     * {@code skip()} in parallel pipelines, switching to sequential execution\\n     * with {@link #sequential()} may improve performance.\\n     *\\n     * @param n the number of leading elements to skip\\n     * @return the new stream\\n     * @throws IllegalArgumentException if {@code n} is negative\\n     \u0027}"}, {"color": "#97c2fc", "id": " DoubleStream takeWhile(DoublePredicate predicate)", "label": " DoubleStream takeWhile(DoublePredicate predicate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns, if this stream is ordered, a stream consisting of the longest\\n     * prefix of elements taken from this stream that match the given predicate.\\n     * Otherwise returns, if this stream is unordered, a stream consisting of a\\n     * subset of elements taken from this stream that match the given predicate.\\n     *\\n     * \u003cp\u003eIf this stream is ordered then the longest prefix is a contiguous\\n     * sequence of elements of this stream that match the given predicate.  The\\n     * first element of the sequence is the first element of this stream, and\\n     * the element immediately following the last element of the sequence does\\n     * not match the given predicate.\\n     *\\n     * \u003cp\u003eIf this stream is unordered, and some (but not all) elements of this\\n     * stream match the given predicate, then the behavior of this operation is\\n     * nondeterministic; it is free to take any subset of matching elements\\n     * (which includes the empty set).\\n     *\\n     * \u003cp\u003eIndependent of whether this stream is ordered or unordered if all\\n     * elements of this stream match the given predicate then this operation\\n     * takes all elements (the result is the same as the input), or if no\\n     * elements of the stream match the given predicate then no elements are\\n     * taken (the result is an empty stream).\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * stateful intermediate operation\u003c/a\u003e.\\n     *\\n     * @implSpec\\n     * The default implementation obtains the {@link #spliterator() spliterator}\\n     * of this stream, wraps that spliterator so as to support the semantics\\n     * of this operation on traversal, and returns a new stream associated with\\n     * the wrapped spliterator.  The returned stream preserves the execution\\n     * characteristics of this stream (namely parallel or sequential execution\\n     * as per {@link #isParallel()}) but the wrapped spliterator may choose to\\n     * not support splitting.  When the returned stream is closed, the close\\n     * handlers for both the returned and this stream are invoked.\\n     *\\n     * @apiNote\\n     * While {@code takeWhile()} is generally a cheap operation on sequential\\n     * stream pipelines, it can be quite expensive on ordered parallel\\n     * pipelines, since the operation is constrained to return not just any\\n     * valid prefix, but the longest prefix of elements in the encounter order.\\n     * Using an unordered stream source (such as\\n     * {@link #generate(DoubleSupplier)}) or removing the ordering constraint\\n     * with {@link #unordered()} may result in significant speedups of\\n     * {@code takeWhile()} in parallel pipelines, if the semantics of your\\n     * situation permit.  If consistency with encounter order is required, and\\n     * you are experiencing poor performance or memory utilization with\\n     * {@code takeWhile()} in parallel pipelines, switching to sequential\\n     * execution with {@link #sequential()} may improve performance.\\n     *\\n     * @param predicate a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                  \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                  predicate to apply to elements to determine the longest\\n     *                  prefix of elements.\\n     * @return the new stream\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " DoubleStream dropWhile(DoublePredicate predicate)", "label": " DoubleStream dropWhile(DoublePredicate predicate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns, if this stream is ordered, a stream consisting of the remaining\\n     * elements of this stream after dropping the longest prefix of elements\\n     * that match the given predicate.  Otherwise returns, if this stream is\\n     * unordered, a stream consisting of the remaining elements of this stream\\n     * after dropping a subset of elements that match the given predicate.\\n     *\\n     * \u003cp\u003eIf this stream is ordered then the longest prefix is a contiguous\\n     * sequence of elements of this stream that match the given predicate.  The\\n     * first element of the sequence is the first element of this stream, and\\n     * the element immediately following the last element of the sequence does\\n     * not match the given predicate.\\n     *\\n     * \u003cp\u003eIf this stream is unordered, and some (but not all) elements of this\\n     * stream match the given predicate, then the behavior of this operation is\\n     * nondeterministic; it is free to drop any subset of matching elements\\n     * (which includes the empty set).\\n     *\\n     * \u003cp\u003eIndependent of whether this stream is ordered or unordered if all\\n     * elements of this stream match the given predicate then this operation\\n     * drops all elements (the result is an empty stream), or if no elements of\\n     * the stream match the given predicate then no elements are dropped (the\\n     * result is the same as the input).\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003estateful\\n     * intermediate operation\u003c/a\u003e.\\n     *\\n     * @implSpec\\n     * The default implementation obtains the {@link #spliterator() spliterator}\\n     * of this stream, wraps that spliterator so as to support the semantics\\n     * of this operation on traversal, and returns a new stream associated with\\n     * the wrapped spliterator.  The returned stream preserves the execution\\n     * characteristics of this stream (namely parallel or sequential execution\\n     * as per {@link #isParallel()}) but the wrapped spliterator may choose to\\n     * not support splitting.  When the returned stream is closed, the close\\n     * handlers for both the returned and this stream are invoked.\\n     *\\n     * @apiNote\\n     * While {@code dropWhile()} is generally a cheap operation on sequential\\n     * stream pipelines, it can be quite expensive on ordered parallel\\n     * pipelines, since the operation is constrained to return not just any\\n     * valid prefix, but the longest prefix of elements in the encounter order.\\n     * Using an unordered stream source (such as\\n     * {@link #generate(DoubleSupplier)}) or removing the ordering constraint\\n     * with {@link #unordered()} may result in significant speedups of\\n     * {@code dropWhile()} in parallel pipelines, if the semantics of your\\n     * situation permit.  If consistency with encounter order is required, and\\n     * you are experiencing poor performance or memory utilization with\\n     * {@code dropWhile()} in parallel pipelines, switching to sequential\\n     * execution with {@link #sequential()} may improve performance.\\n     *\\n     * @param predicate a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                  \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                  predicate to apply to elements to determine the longest\\n     *                  prefix of elements.\\n     * @return the new stream\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " void forEach(DoubleConsumer action)", "label": " void forEach(DoubleConsumer action)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs an action for each element of this stream.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eFor parallel stream pipelines, this operation does \u003cem\u003enot\u003c/em\u003e\\n     * guarantee to respect the encounter order of the stream, as doing so\\n     * would sacrifice the benefit of parallelism.  For any given element, the\\n     * action may be performed at whatever time and in whatever thread the\\n     * library chooses.  If the action accesses shared state, it is\\n     * responsible for providing the required synchronization.\\n     *\\n     * @param action a \u003ca href=\"package-summary.html#NonInterference\"\u003e\\n     *               non-interfering\u003c/a\u003e action to perform on the elements\\n     \u0027}"}, {"color": "#97c2fc", "id": " void forEachOrdered(DoubleConsumer action)", "label": " void forEachOrdered(DoubleConsumer action)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs an action for each element of this stream, guaranteeing that\\n     * each element is processed in encounter order for streams that have a\\n     * defined encounter order.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param action a \u003ca href=\"package-summary.html#NonInterference\"\u003e\\n     *               non-interfering\u003c/a\u003e action to perform on the elements\\n     * @see #forEach(DoubleConsumer)\\n     \u0027}"}, {"color": "#97c2fc", "id": " double[] toArray()", "label": " double[] toArray()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an array containing the elements of this stream.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @return an array containing the elements of this stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " double reduce(double identity, DoubleBinaryOperator op)", "label": " double reduce(double identity, DoubleBinaryOperator op)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs a \u003ca href=\"package-summary.html#Reduction\"\u003ereduction\u003c/a\u003e on the\\n     * elements of this stream, using the provided identity value and an\\n     * \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e\\n     * accumulation function, and returns the reduced value.  This is equivalent\\n     * to:\\n     * \u003cpre\u003e{@code\\n     *     double result = identity;\\n     *     for (double element : this stream)\\n     *         result = accumulator.applyAsDouble(result, element)\\n     *     return result;\\n     * }\u003c/pre\u003e\\n     *\\n     * but is not constrained to execute sequentially.\\n     *\\n     * \u003cp\u003eThe {@code identity} value must be an identity for the accumulator\\n     * function. This means that for all {@code x},\\n     * {@code accumulator.apply(identity, x)} is equal to {@code x}.\\n     * The {@code accumulator} function must be an\\n     * \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e function.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @apiNote Sum, min, max, and average are all special cases of reduction.\\n     * Summing a stream of numbers can be expressed as:\\n     *\\n     * \u003cpre\u003e{@code\\n     *     double sum = numbers.reduce(0, (a, b) -\u003e a+b);\\n     * }\u003c/pre\u003e\\n     *\\n     * or more compactly:\\n     *\\n     * \u003cpre\u003e{@code\\n     *     double sum = numbers.reduce(0, Double::sum);\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eWhile this may seem a more roundabout way to perform an aggregation\\n     * compared to simply mutating a running total in a loop, reduction\\n     * operations parallelize more gracefully, without needing additional\\n     * synchronization and with greatly reduced risk of data races.\\n     *\\n     * @param identity the identity value for the accumulating function\\n     * @param op an \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e,\\n     *           \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *           \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *           function for combining two values\\n     * @return the result of the reduction\\n     * @see #sum()\\n     * @see #min()\\n     * @see #max()\\n     * @see #average()\\n     \u0027}"}, {"color": "#97c2fc", "id": " OptionalDouble reduce(DoubleBinaryOperator op)", "label": " OptionalDouble reduce(DoubleBinaryOperator op)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs a \u003ca href=\"package-summary.html#Reduction\"\u003ereduction\u003c/a\u003e on the\\n     * elements of this stream, using an\\n     * \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e accumulation\\n     * function, and returns an {@code OptionalDouble} describing the reduced\\n     * value, if any. This is equivalent to:\\n     * \u003cpre\u003e{@code\\n     *     boolean foundAny = false;\\n     *     double result = null;\\n     *     for (double element : this stream) {\\n     *         if (!foundAny) {\\n     *             foundAny = true;\\n     *             result = element;\\n     *         }\\n     *         else\\n     *             result = accumulator.applyAsDouble(result, element);\\n     *     }\\n     *     return foundAny ? OptionalDouble.of(result) : OptionalDouble.empty();\\n     * }\u003c/pre\u003e\\n     *\\n     * but is not constrained to execute sequentially.\\n     *\\n     * \u003cp\u003eThe {@code accumulator} function must be an\\n     * \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e function.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param op an \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e,\\n     *           \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *           \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *           function for combining two values\\n     * @return the result of the reduction\\n     * @see #reduce(double, DoubleBinaryOperator)\\n     \u0027}"}, {"color": "#97c2fc", "id": " R collect(Supplier\u003cR\u003e supplier, ObjDoubleConsumer\u003cR\u003e accumulator, BiConsumer\u003cR, R\u003e combiner)", "label": " R collect(Supplier\u003cR\u003e supplier, ObjDoubleConsumer\u003cR\u003e accumulator, BiConsumer\u003cR, R\u003e combiner)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs a \u003ca href=\"package-summary.html#MutableReduction\"\u003emutable\\n     * reduction\u003c/a\u003e operation on the elements of this stream.  A mutable\\n     * reduction is one in which the reduced value is a mutable result container,\\n     * such as an {@code ArrayList}, and elements are incorporated by updating\\n     * the state of the result rather than by replacing the result.  This\\n     * produces a result equivalent to:\\n     * \u003cpre\u003e{@code\\n     *     R result = supplier.get();\\n     *     for (double element : this stream)\\n     *         accumulator.accept(result, element);\\n     *     return result;\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eLike {@link #reduce(double, DoubleBinaryOperator)}, {@code collect}\\n     * operations can be parallelized without requiring additional\\n     * synchronization.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param \u003cR\u003e the type of the mutable result container\\n     * @param supplier a function that creates a new mutable result container.\\n     *                 For a parallel execution, this function may be called\\n     *                 multiple times and must return a fresh value each time.\\n     * @param accumulator an \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e,\\n     *                    \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                    \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                    function that must fold an element into a result\\n     *                    container.\\n     * @param combiner an \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e,\\n     *                    \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                    \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                    function that accepts two partial result containers\\n     *                    and merges them, which must be compatible with the\\n     *                    accumulator function.  The combiner function must fold\\n     *                    the elements from the second result container into the\\n     *                    first result container.\\n     * @return the result of the reduction\\n     * @see Stream#collect(Supplier, BiConsumer, BiConsumer)\\n     \u0027}"}, {"color": "#97c2fc", "id": "reduce(double", "label": "reduce(double", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " double sum()", "label": " double sum()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the sum of elements in this stream.\\n     *\\n     * Summation is a special case of a \u003ca\\n     * href=\"package-summary.html#Reduction\"\u003ereduction\u003c/a\u003e. If\\n     * floating-point summation were exact, this method would be\\n     * equivalent to:\\n     *\\n     * \u003cpre\u003e{@code\\n     *     return reduce(0, Double::sum);\\n     * }\u003c/pre\u003e\\n     *\\n     * However, since floating-point summation is not exact, the above\\n     * code is not necessarily equivalent to the summation computation\\n     * done by this method.\\n     *\\n     * \u003cp\u003eThe value of a floating-point sum is a function both\\n     * of the input values as well as the order of addition\\n     * operations. The order of addition operations of this method is\\n     * intentionally not defined to allow for implementation\\n     * flexibility to improve the speed and accuracy of the computed\\n     * result.\\n     *\\n     * In particular, this method may be implemented using compensated\\n     * summation or other technique to reduce the error bound in the\\n     * numerical sum compared to a simple summation of {@code double}\\n     * values.\\n     *\\n     * Because of the unspecified order of operations and the\\n     * possibility of using differing summation schemes, the output of\\n     * this method may vary on the same input elements.\\n     *\\n     * \u003cp\u003eVarious conditions can result in a non-finite sum being\\n     * computed. This can occur even if the all the elements\\n     * being summed are finite. If any element is non-finite,\\n     * the sum will be non-finite:\\n     *\\n     * \u003cul\u003e\\n     *\\n     * \u003cli\u003eIf any element is a NaN, then the final sum will be\\n     * NaN.\\n     *\\n     * \u003cli\u003eIf the elements contain one or more infinities, the\\n     * sum will be infinite or NaN.\\n     *\\n     * \u003cul\u003e\\n     *\\n     * \u003cli\u003eIf the elements contain infinities of opposite sign,\\n     * the sum will be NaN.\\n     *\\n     * \u003cli\u003eIf the elements contain infinities of one sign and\\n     * an intermediate sum overflows to an infinity of the opposite\\n     * sign, the sum may be NaN.\\n     *\\n     * \u003c/ul\u003e\\n     *\\n     * \u003c/ul\u003e\\n     *\\n     * It is possible for intermediate sums of finite values to\\n     * overflow into opposite-signed infinities; if that occurs, the\\n     * final sum will be NaN even if the elements are all\\n     * finite.\\n     *\\n     * If all the elements are zero, the sign of zero is\\n     * \u003cem\u003enot\u003c/em\u003e guaranteed to be preserved in the final sum.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @apiNote Elements sorted by increasing absolute magnitude tend\\n     * to yield more accurate results.\\n     *\\n     * @return the sum of elements in this stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " OptionalDouble min()", "label": " OptionalDouble min()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@code OptionalDouble} describing the minimum element of this\\n     * stream, or an empty OptionalDouble if this stream is empty.  The minimum\\n     * element will be {@code Double.NaN} if any stream element was NaN. Unlike\\n     * the numerical comparison operators, this method considers negative zero\\n     * to be strictly smaller than positive zero. This is a special case of a\\n     * \u003ca href=\"package-summary.html#Reduction\"\u003ereduction\u003c/a\u003e and is\\n     * equivalent to:\\n     * \u003cpre\u003e{@code\\n     *     return reduce(Double::min);\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @return an {@code OptionalDouble} containing the minimum element of this\\n     * stream, or an empty optional if the stream is empty\\n     \u0027}"}, {"color": "#97c2fc", "id": " OptionalDouble max()", "label": " OptionalDouble max()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@code OptionalDouble} describing the maximum element of this\\n     * stream, or an empty OptionalDouble if this stream is empty.  The maximum\\n     * element will be {@code Double.NaN} if any stream element was NaN. Unlike\\n     * the numerical comparison operators, this method considers negative zero\\n     * to be strictly smaller than positive zero. This is a\\n     * special case of a\\n     * \u003ca href=\"package-summary.html#Reduction\"\u003ereduction\u003c/a\u003e and is\\n     * equivalent to:\\n     * \u003cpre\u003e{@code\\n     *     return reduce(Double::max);\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @return an {@code OptionalDouble} containing the maximum element of this\\n     * stream, or an empty optional if the stream is empty\\n     \u0027}"}, {"color": "#97c2fc", "id": " OptionalDouble average()", "label": " OptionalDouble average()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@code OptionalDouble} describing the arithmetic mean of elements of\\n     * this stream, or an empty optional if this stream is empty.  This is a\\n     * special case of a\\n     * \u003ca href=\"package-summary.html#Reduction\"\u003ereduction\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @return an {@code OptionalDouble} containing the average element of this\\n     * stream, or an empty optional if the stream is empty\\n     \u0027}"}, {"color": "#97c2fc", "id": "sum", "label": "sum", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " DoubleSummaryStatistics summaryStatistics()", "label": " DoubleSummaryStatistics summaryStatistics()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code DoubleSummaryStatistics} describing various summary data\\n     * about the elements of this stream.  This is a special\\n     * case of a \u003ca href=\"package-summary.html#Reduction\"\u003ereduction\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @return a {@code DoubleSummaryStatistics} describing various summary data\\n     * about the elements of this stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean anyMatch(DoublePredicate predicate)", "label": " boolean anyMatch(DoublePredicate predicate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns whether any elements of this stream match the provided\\n     * predicate.  May not evaluate the predicate on all elements if not\\n     * necessary for determining the result.  If the stream is empty then\\n     * {@code false} is returned and the predicate is not evaluated.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * terminal operation\u003c/a\u003e.\\n     *\\n     * @apiNote\\n     * This method evaluates the \u003cem\u003eexistential quantification\u003c/em\u003e of the\\n     * predicate over the elements of the stream (for some x P(x)).\\n     *\\n     * @param predicate a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                  \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                  predicate to apply to elements of this stream\\n     * @return {@code true} if any elements of the stream match the provided\\n     * predicate, otherwise {@code false}\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean allMatch(DoublePredicate predicate)", "label": " boolean allMatch(DoublePredicate predicate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns whether all elements of this stream match the provided predicate.\\n     * May not evaluate the predicate on all elements if not necessary for\\n     * determining the result.  If the stream is empty then {@code true} is\\n     * returned and the predicate is not evaluated.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * terminal operation\u003c/a\u003e.\\n     *\\n     * @apiNote\\n     * This method evaluates the \u003cem\u003euniversal quantification\u003c/em\u003e of the\\n     * predicate over the elements of the stream (for all x P(x)).  If the\\n     * stream is empty, the quantification is said to be \u003cem\u003evacuously\\n     * satisfied\u003c/em\u003e and is always {@code true} (regardless of P(x)).\\n     *\\n     * @param predicate a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                  \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                  predicate to apply to elements of this stream\\n     * @return {@code true} if either all elements of the stream match the\\n     * provided predicate or the stream is empty, otherwise {@code false}\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean noneMatch(DoublePredicate predicate)", "label": " boolean noneMatch(DoublePredicate predicate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns whether no elements of this stream match the provided predicate.\\n     * May not evaluate the predicate on all elements if not necessary for\\n     * determining the result.  If the stream is empty then {@code true} is\\n     * returned and the predicate is not evaluated.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * terminal operation\u003c/a\u003e.\\n     *\\n     * @apiNote\\n     * This method evaluates the \u003cem\u003euniversal quantification\u003c/em\u003e of the\\n     * negated predicate over the elements of the stream (for all x ~P(x)).  If\\n     * the stream is empty, the quantification is said to be vacuously satisfied\\n     * and is always {@code true}, regardless of P(x).\\n     *\\n     * @param predicate a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                  \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                  predicate to apply to elements of this stream\\n     * @return {@code true} if either no elements of the stream match the\\n     * provided predicate or the stream is empty, otherwise {@code false}\\n     \u0027}"}, {"color": "#97c2fc", "id": " OptionalDouble findFirst()", "label": " OptionalDouble findFirst()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@link OptionalDouble} describing the first element of this\\n     * stream, or an empty {@code OptionalDouble} if the stream is empty.  If\\n     * the stream has no encounter order, then any element may be returned.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * terminal operation\u003c/a\u003e.\\n     *\\n     * @return an {@code OptionalDouble} describing the first element of this\\n     * stream, or an empty {@code OptionalDouble} if the stream is empty\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.util.OptionalDouble", "label": "java.util.OptionalDouble", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": " OptionalDouble findAny()", "label": " OptionalDouble findAny()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@link OptionalDouble} describing some element of the stream,\\n     * or an empty {@code OptionalDouble} if the stream is empty.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * terminal operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eThe behavior of this operation is explicitly nondeterministic; it is\\n     * free to select any element in the stream.  This is to allow for maximal\\n     * performance in parallel operations; the cost is that multiple invocations\\n     * on the same source may not return the same result.  (If a stable result\\n     * is desired, use {@link #findFirst()} instead.)\\n     *\\n     * @return an {@code OptionalDouble} describing some element of this stream,\\n     * or an empty {@code OptionalDouble} if the stream is empty\\n     * @see #findFirst()\\n     \u0027}"}, {"color": "#97c2fc", "id": " Stream\u003cDouble\u003e boxed()", "label": " Stream\u003cDouble\u003e boxed()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Stream} consisting of the elements of this stream,\\n     * boxed to {@code Double}.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @return a {@code Stream} consistent of the elements of this stream,\\n     * each boxed to a {@code Double}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Builder builder()", "label": "public static Builder builder()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a builder for a {@code LongStream}.\\n     *\\n     * @return a stream builder\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static DoubleStream empty()", "label": "public static DoubleStream empty()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an empty sequential {@code DoubleStream}.\\n     *\\n     * @return an empty sequential stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static DoubleStream of(double t)", "label": "public static DoubleStream of(double t)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a sequential {@code DoubleStream} containing a single element.\\n     *\\n     * @param t the single element\\n     * @return a singleton sequential stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static DoubleStream of(double... values)", "label": "public static DoubleStream of(double... values)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a sequential ordered stream whose elements are the specified values.\\n     *\\n     * @param values the elements of the new stream\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static DoubleStream iterate(final double seed, final DoubleUnaryOperator f)", "label": "public static DoubleStream iterate(final double seed, final DoubleUnaryOperator f)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an infinite sequential ordered {@code DoubleStream} produced by iterative\\n     * application of a function {@code f} to an initial element {@code seed},\\n     * producing a {@code Stream} consisting of {@code seed}, {@code f(seed)},\\n     * {@code f(f(seed))}, etc.\\n     *\\n     * \u003cp\u003eThe first element (position {@code 0}) in the {@code DoubleStream}\\n     * will be the provided {@code seed}.  For {@code n \u003e 0}, the element at\\n     * position {@code n}, will be the result of applying the function {@code f}\\n     *  to the element at position {@code n - 1}.\\n     *\\n     * \u003cp\u003eThe action of applying {@code f} for one element\\n     * \u003ca href=\"../concurrent/package-summary.html#MemoryVisibility\"\u003e\u003ci\u003ehappens-before\u003c/i\u003e\u003c/a\u003e\\n     * the action of applying {@code f} for subsequent elements.  For any given\\n     * element the action may be performed in whatever thread the library\\n     * chooses.\\n     *\\n     * @param seed the initial element\\n     * @param f a function to be applied to the previous element to produce\\n     *          a new element\\n     * @return a new sequential {@code DoubleStream}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static DoubleStream iterate(double seed, DoublePredicate hasNext, DoubleUnaryOperator next)", "label": "public static DoubleStream iterate(double seed, DoublePredicate hasNext, DoubleUnaryOperator next)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a sequential ordered {@code DoubleStream} produced by iterative\\n     * application of the given {@code next} function to an initial element,\\n     * conditioned on satisfying the given {@code hasNext} predicate.  The\\n     * stream terminates as soon as the {@code hasNext} predicate returns false.\\n     *\\n     * \u003cp\u003e{@code DoubleStream.iterate} should produce the same sequence of elements as\\n     * produced by the corresponding for-loop:\\n     * \u003cpre\u003e{@code\\n     *     for (double index=seed; hasNext.test(index); index = next.applyAsDouble(index)) {\\n     *         ...\\n     *     }\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eThe resulting sequence may be empty if the {@code hasNext} predicate\\n     * does not hold on the seed value.  Otherwise the first element will be the\\n     * supplied {@code seed} value, the next element (if present) will be the\\n     * result of applying the {@code next} function to the {@code seed} value,\\n     * and so on iteratively until the {@code hasNext} predicate indicates that\\n     * the stream should terminate.\\n     *\\n     * \u003cp\u003eThe action of applying the {@code hasNext} predicate to an element\\n     * \u003ca href=\"../concurrent/package-summary.html#MemoryVisibility\"\u003e\u003ci\u003ehappens-before\u003c/i\u003e\u003c/a\u003e\\n     * the action of applying the {@code next} function to that element.  The\\n     * action of applying the {@code next} function for one element\\n     * \u003ci\u003ehappens-before\u003c/i\u003e the action of applying the {@code hasNext}\\n     * predicate for subsequent elements.  For any given element an action may\\n     * be performed in whatever thread the library chooses.\\n     *\\n     * @param seed the initial element\\n     * @param hasNext a predicate to apply to elements to determine when the\\n     *                stream must terminate.\\n     * @param next a function to be applied to the previous element to produce\\n     *             a new element\\n     * @return a new sequential {@code DoubleStream}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static DoubleStream generate(DoubleSupplier s)", "label": "public static DoubleStream generate(DoubleSupplier s)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an infinite sequential unordered stream where each element is\\n     * generated by the provided {@code DoubleSupplier}.  This is suitable for\\n     * generating constant streams, streams of random elements, etc.\\n     *\\n     * @param s the {@code DoubleSupplier} for generated elements\\n     * @return a new infinite sequential unordered {@code DoubleStream}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static DoubleStream concat(DoubleStream a, DoubleStream b)", "label": "public static DoubleStream concat(DoubleStream a, DoubleStream b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a lazily concatenated stream whose elements are all the\\n     * elements of the first stream followed by all the elements of the\\n     * second stream.  The resulting stream is ordered if both\\n     * of the input streams are ordered, and parallel if either of the input\\n     * streams is parallel.  When the resulting stream is closed, the close\\n     * handlers for both input streams are invoked.\\n     *\\n     * \u003cp\u003eThis method operates on the two input streams and binds each stream\\n     * to its source.  As a result subsequent modifications to an input stream\\n     * source may not be reflected in the concatenated stream result.\\n     *\\n     * @implNote\\n     * Use caution when constructing streams from repeated concatenation.\\n     * Accessing an element of a deeply concatenated stream can result in deep\\n     * call chains, or even {@code StackOverflowError}.\\n     *\\n     * @apiNote\\n     * To preserve optimization opportunities this method binds each stream to\\n     * its source and accepts only two streams as parameters.  For example, the\\n     * exact size of the concatenated stream source can be computed if the exact\\n     * size of each input stream source is known.\\n     * To concatenate more streams without binding, or without nested calls to\\n     * this method, try creating a stream of streams and flat-mapping with the\\n     * identity function, for example:\\n     * \u003cpre\u003e{@code\\n     *     DoubleStream concat = Stream.of(s1, s2, s3, s4).flatMapToDouble(s -\u003e s);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first stream\\n     * @param b the second stream\\n     * @return the concatenation of the two input streams\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Stream\u003cT\u003e stream(T[] array, int startInclusive, int endExclusive)", "label": "public static Stream\u003cT\u003e stream(T[] array, int startInclusive, int endExclusive)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a sequential {@link Stream} with the specified range of the\\n     * specified array as its source.\\n     *\\n     * @param \u003cT\u003e the type of the array elements\\n     * @param array the array, assumed to be unmodified during use\\n     * @param startInclusive the first index to cover, inclusive\\n     * @param endExclusive index immediately past the last index to cover\\n     * @return a {@code Stream} for the array range\\n     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is\\n     *         negative, {@code endExclusive} is less than\\n     *         {@code startInclusive}, or {@code endExclusive} is greater than\\n     *         the array size\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static IntStream stream(int[] array)", "label": "public static IntStream stream(int[] array)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a sequential {@link IntStream} with the specified array as its\\n     * source.\\n     *\\n     * @param array the array, assumed to be unmodified during use\\n     * @return an {@code IntStream} for the array\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.util.stream.IntStream", "label": "java.util.stream.IntStream", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * A sequence of primitive int-valued elements supporting sequential and parallel\\n * aggregate operations.  This is the {@code int} primitive specialization of\\n * {@link Stream}.\\n *\\n * \u003cp\u003eThe following example illustrates an aggregate operation using\\n * {@link Stream} and {@link IntStream}, computing the sum of the weights of the\\n * red widgets:\\n *\\n * \u003cpre\u003e{@code\\n *     int sum = widgets.stream()\\n *                      .filter(w -\u003e w.getColor() == RED)\\n *                      .mapToInt(w -\u003e w.getWeight())\\n *                      .sum();\\n * }\u003c/pre\u003e\\n *\\n * See the class documentation for {@link Stream} and the package documentation\\n * for \u003ca href=\"package-summary.html\"\u003ejava.util.stream\u003c/a\u003e for additional\\n * specification of streams, stream operations, stream pipelines, and\\n * parallelism.\\n *\\n * @since 1.8\\n * @see Stream\\n * @see \u003ca href=\"package-summary.html\"\u003ejava.util.stream\u003c/a\u003e\\n \u0027}"}, {"color": "#97c2fc", "id": " IntStream filter(IntPredicate predicate)", "label": " IntStream filter(IntPredicate predicate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the elements of this stream that match\\n     * the given predicate.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param predicate a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                  \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                  predicate to apply to each element to determine if it\\n     *                  should be included\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " IntStream map(IntUnaryOperator mapper)", "label": " IntStream map(IntUnaryOperator mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the results of applying the given\\n     * function to the elements of this stream.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function to apply to each element\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " Stream\u003cU\u003e mapToObj(IntFunction\u003c? extends U\u003e mapper)", "label": " Stream\u003cU\u003e mapToObj(IntFunction\u003c? extends U\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an object-valued {@code Stream} consisting of the results of\\n     * applying the given function to the elements of this stream.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003e\\n     *     intermediate operation\u003c/a\u003e.\\n     *\\n     * @param \u003cU\u003e the element type of the new stream\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function to apply to each element\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " LongStream mapToLong(IntToLongFunction mapper)", "label": " LongStream mapToLong(IntToLongFunction mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code LongStream} consisting of the results of applying the\\n     * given function to the elements of this stream.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function to apply to each element\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " DoubleStream mapToDouble(IntToDoubleFunction mapper)", "label": " DoubleStream mapToDouble(IntToDoubleFunction mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code DoubleStream} consisting of the results of applying the\\n     * given function to the elements of this stream.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function to apply to each element\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " IntStream flatMap(IntFunction\u003c? extends IntStream\u003e mapper)", "label": " IntStream flatMap(IntFunction\u003c? extends IntStream\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the results of replacing each element of\\n     * this stream with the contents of a mapped stream produced by applying\\n     * the provided mapping function to each element.  Each mapped stream is\\n     * {@link java.util.stream.BaseStream#close() closed} after its contents\\n     * have been placed into this stream.  (If a mapped stream is {@code null}\\n     * an empty stream is used, instead.)\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function to apply to each element which produces an\\n     *               {@code IntStream} of new values\\n     * @return the new stream\\n     * @see Stream#flatMap(Function)\\n     \u0027}"}, {"color": "#97c2fc", "id": " IntStream mapMulti(IntMapMultiConsumer mapper)", "label": " IntStream mapMulti(IntMapMultiConsumer mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the results of replacing each element of\\n     * this stream with multiple elements, specifically zero or more elements.\\n     * Replacement is performed by applying the provided mapping function to each\\n     * element in conjunction with a {@linkplain IntConsumer consumer} argument\\n     * that accepts replacement elements. The mapping function calls the consumer\\n     * zero or more times to provide the replacement elements.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eIf the {@linkplain IntConsumer consumer} argument is used outside the scope of\\n     * its application to the mapping function, the results are undefined.\\n     *\\n     * @implSpec\\n     * The default implementation invokes {@link #flatMap flatMap} on this stream,\\n     * passing a function that behaves as follows. First, it calls the mapper function\\n     * with an {@code IntConsumer} that accumulates replacement elements into a newly created\\n     * internal buffer. When the mapper function returns, it creates an {@code IntStream} from the\\n     * internal buffer. Finally, it returns this stream to {@code flatMap}.\\n     *\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function that generates replacement elements\\n     * @return the new stream\\n     * @see Stream#mapMulti Stream.mapMulti\\n     * @since 16\\n     \u0027}"}, {"color": "#97c2fc", "id": " IntStream distinct()", "label": " IntStream distinct()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the distinct elements of this stream.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003estateful\\n     * intermediate operation\u003c/a\u003e.\\n     *\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " IntStream sorted()", "label": " IntStream sorted()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the elements of this stream in sorted\\n     * order.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003estateful\\n     * intermediate operation\u003c/a\u003e.\\n     *\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " IntStream peek(IntConsumer action)", "label": " IntStream peek(IntConsumer action)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the elements of this stream, additionally\\n     * performing the provided action on each element as elements are consumed\\n     * from the resulting stream.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eFor parallel stream pipelines, the action may be called at\\n     * whatever time and in whatever thread the element is made available by the\\n     * upstream operation.  If the action modifies shared state,\\n     * it is responsible for providing the required synchronization.\\n     *\\n     * @apiNote This method exists mainly to support debugging, where you want\\n     * to see the elements as they flow past a certain point in a pipeline:\\n     * \u003cpre\u003e{@code\\n     *     IntStream.of(1, 2, 3, 4)\\n     *         .filter(e -\u003e e \u003e 2)\\n     *         .peek(e -\u003e System.out.println(\"Filtered value: \" + e))\\n     *         .map(e -\u003e e * e)\\n     *         .peek(e -\u003e System.out.println(\"Mapped value: \" + e))\\n     *         .sum();\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eIn cases where the stream implementation is able to optimize away the\\n     * production of some or all the elements (such as with short-circuiting\\n     * operations like {@code findFirst}, or in the example described in\\n     * {@link #count}), the action will not be invoked for those elements.\\n     *\\n     * @param action a \u003ca href=\"package-summary.html#NonInterference\"\u003e\\n     *               non-interfering\u003c/a\u003e action to perform on the elements as\\n     *               they are consumed from the stream\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " IntStream limit(long maxSize)", "label": " IntStream limit(long maxSize)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the elements of this stream, truncated\\n     * to be no longer than {@code maxSize} in length.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * stateful intermediate operation\u003c/a\u003e.\\n     *\\n     * @apiNote\\n     * While {@code limit()} is generally a cheap operation on sequential\\n     * stream pipelines, it can be quite expensive on ordered parallel pipelines,\\n     * especially for large values of {@code maxSize}, since {@code limit(n)}\\n     * is constrained to return not just any \u003cem\u003en\u003c/em\u003e elements, but the\\n     * \u003cem\u003efirst n\u003c/em\u003e elements in the encounter order.  Using an unordered\\n     * stream source (such as {@link #generate(IntSupplier)}) or removing the\\n     * ordering constraint with {@link #unordered()} may result in significant\\n     * speedups of {@code limit()} in parallel pipelines, if the semantics of\\n     * your situation permit.  If consistency with encounter order is required,\\n     * and you are experiencing poor performance or memory utilization with\\n     * {@code limit()} in parallel pipelines, switching to sequential execution\\n     * with {@link #sequential()} may improve performance.\\n     *\\n     * @param maxSize the number of elements the stream should be limited to\\n     * @return the new stream\\n     * @throws IllegalArgumentException if {@code maxSize} is negative\\n     \u0027}"}, {"color": "#97c2fc", "id": "generate(IntSupplier)", "label": "generate(IntSupplier)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " IntStream skip(long n)", "label": " IntStream skip(long n)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the remaining elements of this stream\\n     * after discarding the first {@code n} elements of the stream.\\n     * If this stream contains fewer than {@code n} elements then an\\n     * empty stream will be returned.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003estateful\\n     * intermediate operation\u003c/a\u003e.\\n     *\\n     * @apiNote\\n     * While {@code skip()} is generally a cheap operation on sequential\\n     * stream pipelines, it can be quite expensive on ordered parallel pipelines,\\n     * especially for large values of {@code n}, since {@code skip(n)}\\n     * is constrained to skip not just any \u003cem\u003en\u003c/em\u003e elements, but the\\n     * \u003cem\u003efirst n\u003c/em\u003e elements in the encounter order.  Using an unordered\\n     * stream source (such as {@link #generate(IntSupplier)}) or removing the\\n     * ordering constraint with {@link #unordered()} may result in significant\\n     * speedups of {@code skip()} in parallel pipelines, if the semantics of\\n     * your situation permit.  If consistency with encounter order is required,\\n     * and you are experiencing poor performance or memory utilization with\\n     * {@code skip()} in parallel pipelines, switching to sequential execution\\n     * with {@link #sequential()} may improve performance.\\n     *\\n     * @param n the number of leading elements to skip\\n     * @return the new stream\\n     * @throws IllegalArgumentException if {@code n} is negative\\n     \u0027}"}, {"color": "#97c2fc", "id": " IntStream takeWhile(IntPredicate predicate)", "label": " IntStream takeWhile(IntPredicate predicate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns, if this stream is ordered, a stream consisting of the longest\\n     * prefix of elements taken from this stream that match the given predicate.\\n     * Otherwise returns, if this stream is unordered, a stream consisting of a\\n     * subset of elements taken from this stream that match the given predicate.\\n     *\\n     * \u003cp\u003eIf this stream is ordered then the longest prefix is a contiguous\\n     * sequence of elements of this stream that match the given predicate.  The\\n     * first element of the sequence is the first element of this stream, and\\n     * the element immediately following the last element of the sequence does\\n     * not match the given predicate.\\n     *\\n     * \u003cp\u003eIf this stream is unordered, and some (but not all) elements of this\\n     * stream match the given predicate, then the behavior of this operation is\\n     * nondeterministic; it is free to take any subset of matching elements\\n     * (which includes the empty set).\\n     *\\n     * \u003cp\u003eIndependent of whether this stream is ordered or unordered if all\\n     * elements of this stream match the given predicate then this operation\\n     * takes all elements (the result is the same as the input), or if no\\n     * elements of the stream match the given predicate then no elements are\\n     * taken (the result is an empty stream).\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * stateful intermediate operation\u003c/a\u003e.\\n     *\\n     * @implSpec\\n     * The default implementation obtains the {@link #spliterator() spliterator}\\n     * of this stream, wraps that spliterator so as to support the semantics\\n     * of this operation on traversal, and returns a new stream associated with\\n     * the wrapped spliterator.  The returned stream preserves the execution\\n     * characteristics of this stream (namely parallel or sequential execution\\n     * as per {@link #isParallel()}) but the wrapped spliterator may choose to\\n     * not support splitting.  When the returned stream is closed, the close\\n     * handlers for both the returned and this stream are invoked.\\n     *\\n     * @apiNote\\n     * While {@code takeWhile()} is generally a cheap operation on sequential\\n     * stream pipelines, it can be quite expensive on ordered parallel\\n     * pipelines, since the operation is constrained to return not just any\\n     * valid prefix, but the longest prefix of elements in the encounter order.\\n     * Using an unordered stream source (such as {@link #generate(IntSupplier)})\\n     * or removing the ordering constraint with {@link #unordered()} may result\\n     * in significant speedups of {@code takeWhile()} in parallel pipelines, if\\n     * the semantics of your situation permit.  If consistency with encounter\\n     * order is required, and you are experiencing poor performance or memory\\n     * utilization with {@code takeWhile()} in parallel pipelines, switching to\\n     * sequential execution with {@link #sequential()} may improve performance.\\n     *\\n     * @param predicate a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                  \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                  predicate to apply to elements to determine the longest\\n     *                  prefix of elements.\\n     * @return the new stream\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " IntStream dropWhile(IntPredicate predicate)", "label": " IntStream dropWhile(IntPredicate predicate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns, if this stream is ordered, a stream consisting of the remaining\\n     * elements of this stream after dropping the longest prefix of elements\\n     * that match the given predicate.  Otherwise returns, if this stream is\\n     * unordered, a stream consisting of the remaining elements of this stream\\n     * after dropping a subset of elements that match the given predicate.\\n     *\\n     * \u003cp\u003eIf this stream is ordered then the longest prefix is a contiguous\\n     * sequence of elements of this stream that match the given predicate.  The\\n     * first element of the sequence is the first element of this stream, and\\n     * the element immediately following the last element of the sequence does\\n     * not match the given predicate.\\n     *\\n     * \u003cp\u003eIf this stream is unordered, and some (but not all) elements of this\\n     * stream match the given predicate, then the behavior of this operation is\\n     * nondeterministic; it is free to drop any subset of matching elements\\n     * (which includes the empty set).\\n     *\\n     * \u003cp\u003eIndependent of whether this stream is ordered or unordered if all\\n     * elements of this stream match the given predicate then this operation\\n     * drops all elements (the result is an empty stream), or if no elements of\\n     * the stream match the given predicate then no elements are dropped (the\\n     * result is the same as the input).\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003estateful\\n     * intermediate operation\u003c/a\u003e.\\n     *\\n     * @implSpec\\n     * The default implementation obtains the {@link #spliterator() spliterator}\\n     * of this stream, wraps that spliterator so as to support the semantics\\n     * of this operation on traversal, and returns a new stream associated with\\n     * the wrapped spliterator.  The returned stream preserves the execution\\n     * characteristics of this stream (namely parallel or sequential execution\\n     * as per {@link #isParallel()}) but the wrapped spliterator may choose to\\n     * not support splitting.  When the returned stream is closed, the close\\n     * handlers for both the returned and this stream are invoked.\\n     *\\n     * @apiNote\\n     * While {@code dropWhile()} is generally a cheap operation on sequential\\n     * stream pipelines, it can be quite expensive on ordered parallel\\n     * pipelines, since the operation is constrained to return not just any\\n     * valid prefix, but the longest prefix of elements in the encounter order.\\n     * Using an unordered stream source (such as {@link #generate(IntSupplier)})\\n     * or removing the ordering constraint with {@link #unordered()} may result\\n     * in significant speedups of {@code dropWhile()} in parallel pipelines, if\\n     * the semantics of your situation permit.  If consistency with encounter\\n     * order is required, and you are experiencing poor performance or memory\\n     * utilization with {@code dropWhile()} in parallel pipelines, switching to\\n     * sequential execution with {@link #sequential()} may improve performance.\\n     *\\n     * @param predicate a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                  \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                  predicate to apply to elements to determine the longest\\n     *                  prefix of elements.\\n     * @return the new stream\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " void forEach(IntConsumer action)", "label": " void forEach(IntConsumer action)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs an action for each element of this stream.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eFor parallel stream pipelines, this operation does \u003cem\u003enot\u003c/em\u003e\\n     * guarantee to respect the encounter order of the stream, as doing so\\n     * would sacrifice the benefit of parallelism.  For any given element, the\\n     * action may be performed at whatever time and in whatever thread the\\n     * library chooses.  If the action accesses shared state, it is\\n     * responsible for providing the required synchronization.\\n     *\\n     * @param action a \u003ca href=\"package-summary.html#NonInterference\"\u003e\\n     *               non-interfering\u003c/a\u003e action to perform on the elements\\n     \u0027}"}, {"color": "#97c2fc", "id": " void forEachOrdered(IntConsumer action)", "label": " void forEachOrdered(IntConsumer action)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs an action for each element of this stream, guaranteeing that\\n     * each element is processed in encounter order for streams that have a\\n     * defined encounter order.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param action a \u003ca href=\"package-summary.html#NonInterference\"\u003e\\n     *               non-interfering\u003c/a\u003e action to perform on the elements\\n     * @see #forEach(IntConsumer)\\n     \u0027}"}, {"color": "#97c2fc", "id": " int[] toArray()", "label": " int[] toArray()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an array containing the elements of this stream.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @return an array containing the elements of this stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " int reduce(int identity, IntBinaryOperator op)", "label": " int reduce(int identity, IntBinaryOperator op)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs a \u003ca href=\"package-summary.html#Reduction\"\u003ereduction\u003c/a\u003e on the\\n     * elements of this stream, using the provided identity value and an\\n     * \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e\\n     * accumulation function, and returns the reduced value.  This is equivalent\\n     * to:\\n     * \u003cpre\u003e{@code\\n     *     int result = identity;\\n     *     for (int element : this stream)\\n     *         result = accumulator.applyAsInt(result, element)\\n     *     return result;\\n     * }\u003c/pre\u003e\\n     *\\n     * but is not constrained to execute sequentially.\\n     *\\n     * \u003cp\u003eThe {@code identity} value must be an identity for the accumulator\\n     * function. This means that for all {@code x},\\n     * {@code accumulator.apply(identity, x)} is equal to {@code x}.\\n     * The {@code accumulator} function must be an\\n     * \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e function.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @apiNote Sum, min and max are all special cases of reduction that can be\\n     * expressed using this method.\\n     * For example, summing a stream can be expressed as:\\n     *\\n     * \u003cpre\u003e{@code\\n     *     int sum = integers.reduce(0, (a, b) -\u003e a+b);\\n     * }\u003c/pre\u003e\\n     *\\n     * or more compactly:\\n     *\\n     * \u003cpre\u003e{@code\\n     *     int sum = integers.reduce(0, Integer::sum);\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eWhile this may seem a more roundabout way to perform an aggregation\\n     * compared to simply mutating a running total in a loop, reduction\\n     * operations parallelize more gracefully, without needing additional\\n     * synchronization and with greatly reduced risk of data races.\\n     *\\n     * @param identity the identity value for the accumulating function\\n     * @param op an \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e,\\n     *           \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *           \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *           function for combining two values\\n     * @return the result of the reduction\\n     * @see #sum()\\n     * @see #min()\\n     * @see #max()\\n     * @see #average()\\n     \u0027}"}, {"color": "#97c2fc", "id": " OptionalInt reduce(IntBinaryOperator op)", "label": " OptionalInt reduce(IntBinaryOperator op)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs a \u003ca href=\"package-summary.html#Reduction\"\u003ereduction\u003c/a\u003e on the\\n     * elements of this stream, using an\\n     * \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e accumulation\\n     * function, and returns an {@code OptionalInt} describing the reduced value,\\n     * if any. This is equivalent to:\\n     * \u003cpre\u003e{@code\\n     *     boolean foundAny = false;\\n     *     int result = null;\\n     *     for (int element : this stream) {\\n     *         if (!foundAny) {\\n     *             foundAny = true;\\n     *             result = element;\\n     *         }\\n     *         else\\n     *             result = accumulator.applyAsInt(result, element);\\n     *     }\\n     *     return foundAny ? OptionalInt.of(result) : OptionalInt.empty();\\n     * }\u003c/pre\u003e\\n     *\\n     * but is not constrained to execute sequentially.\\n     *\\n     * \u003cp\u003eThe {@code accumulator} function must be an\\n     * \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e function.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param op an \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e,\\n     *           \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *           \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *           function for combining two values\\n     * @return the result of the reduction\\n     * @see #reduce(int, IntBinaryOperator)\\n     \u0027}"}, {"color": "#97c2fc", "id": " R collect(Supplier\u003cR\u003e supplier, ObjIntConsumer\u003cR\u003e accumulator, BiConsumer\u003cR, R\u003e combiner)", "label": " R collect(Supplier\u003cR\u003e supplier, ObjIntConsumer\u003cR\u003e accumulator, BiConsumer\u003cR, R\u003e combiner)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs a \u003ca href=\"package-summary.html#MutableReduction\"\u003emutable\\n     * reduction\u003c/a\u003e operation on the elements of this stream.  A mutable\\n     * reduction is one in which the reduced value is a mutable result container,\\n     * such as an {@code ArrayList}, and elements are incorporated by updating\\n     * the state of the result rather than by replacing the result.  This\\n     * produces a result equivalent to:\\n     * \u003cpre\u003e{@code\\n     *     R result = supplier.get();\\n     *     for (int element : this stream)\\n     *         accumulator.accept(result, element);\\n     *     return result;\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eLike {@link #reduce(int, IntBinaryOperator)}, {@code collect} operations\\n     * can be parallelized without requiring additional synchronization.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param \u003cR\u003e the type of the mutable result container\\n     * @param supplier a function that creates a new mutable result container.\\n     *                 For a parallel execution, this function may be called\\n     *                 multiple times and must return a fresh value each time.\\n     * @param accumulator an \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e,\\n     *                    \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                    \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                    function that must fold an element into a result\\n     *                    container.\\n     * @param combiner an \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e,\\n     *                    \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                    \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                    function that accepts two partial result containers\\n     *                    and merges them, which must be compatible with the\\n     *                    accumulator function.  The combiner function must fold\\n     *                    the elements from the second result container into the\\n     *                    first result container.\\n     * @return the result of the reduction\\n     * @see Stream#collect(Supplier, BiConsumer, BiConsumer)\\n     \u0027}"}, {"color": "#97c2fc", "id": "reduce(int", "label": "reduce(int", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " int sum()", "label": " int sum()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the sum of elements in this stream.  This is a special case\\n     * of a \u003ca href=\"package-summary.html#Reduction\"\u003ereduction\u003c/a\u003e\\n     * and is equivalent to:\\n     * \u003cpre\u003e{@code\\n     *     return reduce(0, Integer::sum);\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @return the sum of elements in this stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " OptionalInt min()", "label": " OptionalInt min()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@code OptionalInt} describing the minimum element of this\\n     * stream, or an empty optional if this stream is empty.  This is a special\\n     * case of a \u003ca href=\"package-summary.html#Reduction\"\u003ereduction\u003c/a\u003e\\n     * and is equivalent to:\\n     * \u003cpre\u003e{@code\\n     *     return reduce(Integer::min);\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal operation\u003c/a\u003e.\\n     *\\n     * @return an {@code OptionalInt} containing the minimum element of this\\n     * stream, or an empty {@code OptionalInt} if the stream is empty\\n     \u0027}"}, {"color": "#97c2fc", "id": " OptionalInt max()", "label": " OptionalInt max()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@code OptionalInt} describing the maximum element of this\\n     * stream, or an empty optional if this stream is empty.  This is a special\\n     * case of a \u003ca href=\"package-summary.html#Reduction\"\u003ereduction\u003c/a\u003e\\n     * and is equivalent to:\\n     * \u003cpre\u003e{@code\\n     *     return reduce(Integer::max);\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @return an {@code OptionalInt} containing the maximum element of this\\n     * stream, or an empty {@code OptionalInt} if the stream is empty\\n     \u0027}"}, {"color": "#97c2fc", "id": " IntSummaryStatistics summaryStatistics()", "label": " IntSummaryStatistics summaryStatistics()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@code IntSummaryStatistics} describing various\\n     * summary data about the elements of this stream.  This is a special\\n     * case of a \u003ca href=\"package-summary.html#Reduction\"\u003ereduction\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @return an {@code IntSummaryStatistics} describing various summary data\\n     * about the elements of this stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean anyMatch(IntPredicate predicate)", "label": " boolean anyMatch(IntPredicate predicate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns whether any elements of this stream match the provided\\n     * predicate.  May not evaluate the predicate on all elements if not\\n     * necessary for determining the result.  If the stream is empty then\\n     * {@code false} is returned and the predicate is not evaluated.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * terminal operation\u003c/a\u003e.\\n     *\\n     * @apiNote\\n     * This method evaluates the \u003cem\u003eexistential quantification\u003c/em\u003e of the\\n     * predicate over the elements of the stream (for some x P(x)).\\n     *\\n     * @param predicate a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                  \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                  predicate to apply to elements of this stream\\n     * @return {@code true} if any elements of the stream match the provided\\n     * predicate, otherwise {@code false}\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean allMatch(IntPredicate predicate)", "label": " boolean allMatch(IntPredicate predicate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns whether all elements of this stream match the provided predicate.\\n     * May not evaluate the predicate on all elements if not necessary for\\n     * determining the result.  If the stream is empty then {@code true} is\\n     * returned and the predicate is not evaluated.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * terminal operation\u003c/a\u003e.\\n     *\\n     * @apiNote\\n     * This method evaluates the \u003cem\u003euniversal quantification\u003c/em\u003e of the\\n     * predicate over the elements of the stream (for all x P(x)).  If the\\n     * stream is empty, the quantification is said to be \u003cem\u003evacuously\\n     * satisfied\u003c/em\u003e and is always {@code true} (regardless of P(x)).\\n     *\\n     * @param predicate a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                  \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                  predicate to apply to elements of this stream\\n     * @return {@code true} if either all elements of the stream match the\\n     * provided predicate or the stream is empty, otherwise {@code false}\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean noneMatch(IntPredicate predicate)", "label": " boolean noneMatch(IntPredicate predicate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns whether no elements of this stream match the provided predicate.\\n     * May not evaluate the predicate on all elements if not necessary for\\n     * determining the result.  If the stream is empty then {@code true} is\\n     * returned and the predicate is not evaluated.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * terminal operation\u003c/a\u003e.\\n     *\\n     * @apiNote\\n     * This method evaluates the \u003cem\u003euniversal quantification\u003c/em\u003e of the\\n     * negated predicate over the elements of the stream (for all x ~P(x)).  If\\n     * the stream is empty, the quantification is said to be vacuously satisfied\\n     * and is always {@code true}, regardless of P(x).\\n     *\\n     * @param predicate a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                  \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                  predicate to apply to elements of this stream\\n     * @return {@code true} if either no elements of the stream match the\\n     * provided predicate or the stream is empty, otherwise {@code false}\\n     \u0027}"}, {"color": "#97c2fc", "id": " OptionalInt findFirst()", "label": " OptionalInt findFirst()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@link OptionalInt} describing the first element of this\\n     * stream, or an empty {@code OptionalInt} if the stream is empty.  If the\\n     * stream has no encounter order, then any element may be returned.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * terminal operation\u003c/a\u003e.\\n     *\\n     * @return an {@code OptionalInt} describing the first element of this stream,\\n     * or an empty {@code OptionalInt} if the stream is empty\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.util.OptionalInt", "label": "java.util.OptionalInt", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": " OptionalInt findAny()", "label": " OptionalInt findAny()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@link OptionalInt} describing some element of the stream, or\\n     * an empty {@code OptionalInt} if the stream is empty.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * terminal operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eThe behavior of this operation is explicitly nondeterministic; it is\\n     * free to select any element in the stream.  This is to allow for maximal\\n     * performance in parallel operations; the cost is that multiple invocations\\n     * on the same source may not return the same result.  (If a stable result\\n     * is desired, use {@link #findFirst()} instead.)\\n     *\\n     * @return an {@code OptionalInt} describing some element of this stream, or\\n     * an empty {@code OptionalInt} if the stream is empty\\n     * @see #findFirst()\\n     \u0027}"}, {"color": "#97c2fc", "id": " LongStream asLongStream()", "label": " LongStream asLongStream()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code LongStream} consisting of the elements of this stream,\\n     * converted to {@code long}.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @return a {@code LongStream} consisting of the elements of this stream,\\n     * converted to {@code long}\\n     \u0027}"}, {"color": "#97c2fc", "id": " DoubleStream asDoubleStream()", "label": " DoubleStream asDoubleStream()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code DoubleStream} consisting of the elements of this stream,\\n     * converted to {@code double}.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @return a {@code DoubleStream} consisting of the elements of this stream,\\n     * converted to {@code double}\\n     \u0027}"}, {"color": "#97c2fc", "id": " Stream\u003cInteger\u003e boxed()", "label": " Stream\u003cInteger\u003e boxed()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Stream} consisting of the elements of this stream,\\n     * each boxed to an {@code Integer}.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @return a {@code Stream} consistent of the elements of this stream,\\n     * each boxed to an {@code Integer}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static IntStream empty()", "label": "public static IntStream empty()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an empty sequential {@code IntStream}.\\n     *\\n     * @return an empty sequential stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static IntStream of(int t)", "label": "public static IntStream of(int t)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a sequential {@code IntStream} containing a single element.\\n     *\\n     * @param t the single element\\n     * @return a singleton sequential stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static IntStream of(int... values)", "label": "public static IntStream of(int... values)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a sequential ordered stream whose elements are the specified values.\\n     *\\n     * @param values the elements of the new stream\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static IntStream iterate(final int seed, final IntUnaryOperator f)", "label": "public static IntStream iterate(final int seed, final IntUnaryOperator f)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an infinite sequential ordered {@code IntStream} produced by iterative\\n     * application of a function {@code f} to an initial element {@code seed},\\n     * producing a {@code Stream} consisting of {@code seed}, {@code f(seed)},\\n     * {@code f(f(seed))}, etc.\\n     *\\n     * \u003cp\u003eThe first element (position {@code 0}) in the {@code IntStream} will be\\n     * the provided {@code seed}.  For {@code n \u003e 0}, the element at position\\n     * {@code n}, will be the result of applying the function {@code f} to the\\n     * element at position {@code n - 1}.\\n     *\\n     * \u003cp\u003eThe action of applying {@code f} for one element\\n     * \u003ca href=\"../concurrent/package-summary.html#MemoryVisibility\"\u003e\u003ci\u003ehappens-before\u003c/i\u003e\u003c/a\u003e\\n     * the action of applying {@code f} for subsequent elements.  For any given\\n     * element the action may be performed in whatever thread the library\\n     * chooses.\\n     *\\n     * @param seed the initial element\\n     * @param f a function to be applied to the previous element to produce\\n     *          a new element\\n     * @return a new sequential {@code IntStream}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static IntStream iterate(int seed, IntPredicate hasNext, IntUnaryOperator next)", "label": "public static IntStream iterate(int seed, IntPredicate hasNext, IntUnaryOperator next)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a sequential ordered {@code IntStream} produced by iterative\\n     * application of the given {@code next} function to an initial element,\\n     * conditioned on satisfying the given {@code hasNext} predicate.  The\\n     * stream terminates as soon as the {@code hasNext} predicate returns false.\\n     *\\n     * \u003cp\u003e{@code IntStream.iterate} should produce the same sequence of elements as\\n     * produced by the corresponding for-loop:\\n     * \u003cpre\u003e{@code\\n     *     for (int index=seed; hasNext.test(index); index = next.applyAsInt(index)) {\\n     *         ...\\n     *     }\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eThe resulting sequence may be empty if the {@code hasNext} predicate\\n     * does not hold on the seed value.  Otherwise the first element will be the\\n     * supplied {@code seed} value, the next element (if present) will be the\\n     * result of applying the {@code next} function to the {@code seed} value,\\n     * and so on iteratively until the {@code hasNext} predicate indicates that\\n     * the stream should terminate.\\n     *\\n     * \u003cp\u003eThe action of applying the {@code hasNext} predicate to an element\\n     * \u003ca href=\"../concurrent/package-summary.html#MemoryVisibility\"\u003e\u003ci\u003ehappens-before\u003c/i\u003e\u003c/a\u003e\\n     * the action of applying the {@code next} function to that element.  The\\n     * action of applying the {@code next} function for one element\\n     * \u003ci\u003ehappens-before\u003c/i\u003e the action of applying the {@code hasNext}\\n     * predicate for subsequent elements.  For any given element an action may\\n     * be performed in whatever thread the library chooses.\\n     *\\n     * @param seed the initial element\\n     * @param hasNext a predicate to apply to elements to determine when the\\n     *                stream must terminate.\\n     * @param next a function to be applied to the previous element to produce\\n     *             a new element\\n     * @return a new sequential {@code IntStream}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static IntStream generate(IntSupplier s)", "label": "public static IntStream generate(IntSupplier s)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an infinite sequential unordered stream where each element is\\n     * generated by the provided {@code IntSupplier}.  This is suitable for\\n     * generating constant streams, streams of random elements, etc.\\n     *\\n     * @param s the {@code IntSupplier} for generated elements\\n     * @return a new infinite sequential unordered {@code IntStream}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static IntStream range(int startInclusive, int endExclusive)", "label": "public static IntStream range(int startInclusive, int endExclusive)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a sequential ordered {@code IntStream} from {@code startInclusive}\\n     * (inclusive) to {@code endExclusive} (exclusive) by an incremental step of\\n     * {@code 1}.\\n     *\\n     * @apiNote\\n     * \u003cp\u003eAn equivalent sequence of increasing values can be produced\\n     * sequentially using a {@code for} loop as follows:\\n     * \u003cpre\u003e{@code\\n     *     for (int i = startInclusive; i \u003c endExclusive ; i++) { ... }\\n     * }\u003c/pre\u003e\\n     *\\n     * @param startInclusive the (inclusive) initial value\\n     * @param endExclusive the exclusive upper bound\\n     * @return a sequential {@code IntStream} for the range of {@code int}\\n     *         elements\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static IntStream rangeClosed(int startInclusive, int endInclusive)", "label": "public static IntStream rangeClosed(int startInclusive, int endInclusive)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a sequential ordered {@code IntStream} from {@code startInclusive}\\n     * (inclusive) to {@code endInclusive} (inclusive) by an incremental step of\\n     * {@code 1}.\\n     *\\n     * @apiNote\\n     * \u003cp\u003eAn equivalent sequence of increasing values can be produced\\n     * sequentially using a {@code for} loop as follows:\\n     * \u003cpre\u003e{@code\\n     *     for (int i = startInclusive; i \u003c= endInclusive ; i++) { ... }\\n     * }\u003c/pre\u003e\\n     *\\n     * @param startInclusive the (inclusive) initial value\\n     * @param endInclusive the inclusive upper bound\\n     * @return a sequential {@code IntStream} for the range of {@code int}\\n     *         elements\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static IntStream concat(IntStream a, IntStream b)", "label": "public static IntStream concat(IntStream a, IntStream b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a lazily concatenated stream whose elements are all the\\n     * elements of the first stream followed by all the elements of the\\n     * second stream.  The resulting stream is ordered if both\\n     * of the input streams are ordered, and parallel if either of the input\\n     * streams is parallel.  When the resulting stream is closed, the close\\n     * handlers for both input streams are invoked.\\n     *\\n     * \u003cp\u003eThis method operates on the two input streams and binds each stream\\n     * to its source.  As a result subsequent modifications to an input stream\\n     * source may not be reflected in the concatenated stream result.\\n     *\\n     * @implNote\\n     * Use caution when constructing streams from repeated concatenation.\\n     * Accessing an element of a deeply concatenated stream can result in deep\\n     * call chains, or even {@code StackOverflowError}.\\n     *\\n     * @apiNote\\n     * To preserve optimization opportunities this method binds each stream to\\n     * its source and accepts only two streams as parameters.  For example, the\\n     * exact size of the concatenated stream source can be computed if the exact\\n     * size of each input stream source is known.\\n     * To concatenate more streams without binding, or without nested calls to\\n     * this method, try creating a stream of streams and flat-mapping with the\\n     * identity function, for example:\\n     * \u003cpre\u003e{@code\\n     *     IntStream concat = Stream.of(s1, s2, s3, s4).flatMapToInt(s -\u003e s);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first stream\\n     * @param b the second stream\\n     * @return the concatenation of the two input streams\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static IntStream stream(int[] array, int startInclusive, int endExclusive)", "label": "public static IntStream stream(int[] array, int startInclusive, int endExclusive)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a sequential {@link IntStream} with the specified range of the\\n     * specified array as its source.\\n     *\\n     * @param array the array, assumed to be unmodified during use\\n     * @param startInclusive the first index to cover, inclusive\\n     * @param endExclusive index immediately past the last index to cover\\n     * @return an {@code IntStream} for the array range\\n     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is\\n     *         negative, {@code endExclusive} is less than\\n     *         {@code startInclusive}, or {@code endExclusive} is greater than\\n     *         the array size\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static LongStream stream(long[] array)", "label": "public static LongStream stream(long[] array)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a sequential {@link LongStream} with the specified array as its\\n     * source.\\n     *\\n     * @param array the array, assumed to be unmodified during use\\n     * @return a {@code LongStream} for the array\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.util.stream.LongStream", "label": "java.util.stream.LongStream", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * A sequence of primitive long-valued elements supporting sequential and parallel\\n * aggregate operations.  This is the {@code long} primitive specialization of\\n * {@link Stream}.\\n *\\n * \u003cp\u003eThe following example illustrates an aggregate operation using\\n * {@link Stream} and {@link LongStream}, computing the sum of the weights of the\\n * red widgets:\\n *\\n * \u003cpre\u003e{@code\\n *     long sum = widgets.stream()\\n *                       .filter(w -\u003e w.getColor() == RED)\\n *                       .mapToLong(w -\u003e w.getWeight())\\n *                       .sum();\\n * }\u003c/pre\u003e\\n *\\n * See the class documentation for {@link Stream} and the package documentation\\n * for \u003ca href=\"package-summary.html\"\u003ejava.util.stream\u003c/a\u003e for additional\\n * specification of streams, stream operations, stream pipelines, and\\n * parallelism.\\n *\\n * @since 1.8\\n * @see Stream\\n * @see \u003ca href=\"package-summary.html\"\u003ejava.util.stream\u003c/a\u003e\\n \u0027}"}, {"color": "#97c2fc", "id": " LongStream filter(LongPredicate predicate)", "label": " LongStream filter(LongPredicate predicate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the elements of this stream that match\\n     * the given predicate.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param predicate a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                  \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                  predicate to apply to each element to determine if it\\n     *                  should be included\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " LongStream map(LongUnaryOperator mapper)", "label": " LongStream map(LongUnaryOperator mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the results of applying the given\\n     * function to the elements of this stream.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function to apply to each element\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " Stream\u003cU\u003e mapToObj(LongFunction\u003c? extends U\u003e mapper)", "label": " Stream\u003cU\u003e mapToObj(LongFunction\u003c? extends U\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an object-valued {@code Stream} consisting of the results of\\n     * applying the given function to the elements of this stream.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003e\\n     *     intermediate operation\u003c/a\u003e.\\n     *\\n     * @param \u003cU\u003e the element type of the new stream\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function to apply to each element\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " IntStream mapToInt(LongToIntFunction mapper)", "label": " IntStream mapToInt(LongToIntFunction mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@code IntStream} consisting of the results of applying the\\n     * given function to the elements of this stream.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function to apply to each element\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " DoubleStream mapToDouble(LongToDoubleFunction mapper)", "label": " DoubleStream mapToDouble(LongToDoubleFunction mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code DoubleStream} consisting of the results of applying the\\n     * given function to the elements of this stream.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function to apply to each element\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " LongStream flatMap(LongFunction\u003c? extends LongStream\u003e mapper)", "label": " LongStream flatMap(LongFunction\u003c? extends LongStream\u003e mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the results of replacing each element of\\n     * this stream with the contents of a mapped stream produced by applying\\n     * the provided mapping function to each element.  Each mapped stream is\\n     * {@link java.util.stream.BaseStream#close() closed} after its contents\\n     * have been placed into this stream.  (If a mapped stream is {@code null}\\n     * an empty stream is used, instead.)\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function to apply to each element which produces a\\n     *               {@code LongStream} of new values\\n     * @return the new stream\\n     * @see Stream#flatMap(Function)\\n     \u0027}"}, {"color": "#97c2fc", "id": " LongStream mapMulti(LongMapMultiConsumer mapper)", "label": " LongStream mapMulti(LongMapMultiConsumer mapper)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the results of replacing each element of\\n     * this stream with multiple elements, specifically zero or more elements.\\n     * Replacement is performed by applying the provided mapping function to each\\n     * element in conjunction with a {@linkplain LongConsumer consumer} argument\\n     * that accepts replacement elements. The mapping function calls the consumer\\n     * zero or more times to provide the replacement elements.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eIf the {@linkplain LongConsumer consumer} argument is used outside the scope of\\n     * its application to the mapping function, the results are undefined.\\n     *\\n     * @implSpec\\n     * The default implementation invokes {@link #flatMap flatMap} on this stream,\\n     * passing a function that behaves as follows. First, it calls the mapper function\\n     * with a {@code LongConsumer} that accumulates replacement elements into a newly created\\n     * internal buffer. When the mapper function returns, it creates a {@code LongStream} from the\\n     * internal buffer. Finally, it returns this stream to {@code flatMap}.\\n     *\\n     * @param mapper a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *               \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *               function that generates replacement elements\\n     * @return the new stream\\n     * @see Stream#mapMulti Stream.mapMulti\\n     * @since 16\\n     \u0027}"}, {"color": "#97c2fc", "id": " LongStream distinct()", "label": " LongStream distinct()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the distinct elements of this stream.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003estateful\\n     * intermediate operation\u003c/a\u003e.\\n     *\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " LongStream sorted()", "label": " LongStream sorted()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the elements of this stream in sorted\\n     * order.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003estateful\\n     * intermediate operation\u003c/a\u003e.\\n     *\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " LongStream peek(LongConsumer action)", "label": " LongStream peek(LongConsumer action)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the elements of this stream, additionally\\n     * performing the provided action on each element as elements are consumed\\n     * from the resulting stream.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eFor parallel stream pipelines, the action may be called at\\n     * whatever time and in whatever thread the element is made available by the\\n     * upstream operation.  If the action modifies shared state,\\n     * it is responsible for providing the required synchronization.\\n     *\\n     * @apiNote This method exists mainly to support debugging, where you want\\n     * to see the elements as they flow past a certain point in a pipeline:\\n     * \u003cpre\u003e{@code\\n     *     LongStream.of(1, 2, 3, 4)\\n     *         .filter(e -\u003e e \u003e 2)\\n     *         .peek(e -\u003e System.out.println(\"Filtered value: \" + e))\\n     *         .map(e -\u003e e * e)\\n     *         .peek(e -\u003e System.out.println(\"Mapped value: \" + e))\\n     *         .sum();\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eIn cases where the stream implementation is able to optimize away the\\n     * production of some or all the elements (such as with short-circuiting\\n     * operations like {@code findFirst}, or in the example described in\\n     * {@link #count}), the action will not be invoked for those elements.\\n     *\\n     * @param action a \u003ca href=\"package-summary.html#NonInterference\"\u003e\\n     *               non-interfering\u003c/a\u003e action to perform on the elements as\\n     *               they are consumed from the stream\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " LongStream limit(long maxSize)", "label": " LongStream limit(long maxSize)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the elements of this stream, truncated\\n     * to be no longer than {@code maxSize} in length.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * stateful intermediate operation\u003c/a\u003e.\\n     *\\n     * @apiNote\\n     * While {@code limit()} is generally a cheap operation on sequential\\n     * stream pipelines, it can be quite expensive on ordered parallel pipelines,\\n     * especially for large values of {@code maxSize}, since {@code limit(n)}\\n     * is constrained to return not just any \u003cem\u003en\u003c/em\u003e elements, but the\\n     * \u003cem\u003efirst n\u003c/em\u003e elements in the encounter order.  Using an unordered\\n     * stream source (such as {@link #generate(LongSupplier)}) or removing the\\n     * ordering constraint with {@link #unordered()} may result in significant\\n     * speedups of {@code limit()} in parallel pipelines, if the semantics of\\n     * your situation permit.  If consistency with encounter order is required,\\n     * and you are experiencing poor performance or memory utilization with\\n     * {@code limit()} in parallel pipelines, switching to sequential execution\\n     * with {@link #sequential()} may improve performance.\\n     *\\n     * @param maxSize the number of elements the stream should be limited to\\n     * @return the new stream\\n     * @throws IllegalArgumentException if {@code maxSize} is negative\\n     \u0027}"}, {"color": "#97c2fc", "id": "generate(LongSupplier)", "label": "generate(LongSupplier)", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " LongStream skip(long n)", "label": " LongStream skip(long n)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a stream consisting of the remaining elements of this stream\\n     * after discarding the first {@code n} elements of the stream.\\n     * If this stream contains fewer than {@code n} elements then an\\n     * empty stream will be returned.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003estateful\\n     * intermediate operation\u003c/a\u003e.\\n     *\\n     * @apiNote\\n     * While {@code skip()} is generally a cheap operation on sequential\\n     * stream pipelines, it can be quite expensive on ordered parallel pipelines,\\n     * especially for large values of {@code n}, since {@code skip(n)}\\n     * is constrained to skip not just any \u003cem\u003en\u003c/em\u003e elements, but the\\n     * \u003cem\u003efirst n\u003c/em\u003e elements in the encounter order.  Using an unordered\\n     * stream source (such as {@link #generate(LongSupplier)}) or removing the\\n     * ordering constraint with {@link #unordered()} may result in significant\\n     * speedups of {@code skip()} in parallel pipelines, if the semantics of\\n     * your situation permit.  If consistency with encounter order is required,\\n     * and you are experiencing poor performance or memory utilization with\\n     * {@code skip()} in parallel pipelines, switching to sequential execution\\n     * with {@link #sequential()} may improve performance.\\n     *\\n     * @param n the number of leading elements to skip\\n     * @return the new stream\\n     * @throws IllegalArgumentException if {@code n} is negative\\n     \u0027}"}, {"color": "#97c2fc", "id": " LongStream takeWhile(LongPredicate predicate)", "label": " LongStream takeWhile(LongPredicate predicate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns, if this stream is ordered, a stream consisting of the longest\\n     * prefix of elements taken from this stream that match the given predicate.\\n     * Otherwise returns, if this stream is unordered, a stream consisting of a\\n     * subset of elements taken from this stream that match the given predicate.\\n     *\\n     * \u003cp\u003eIf this stream is ordered then the longest prefix is a contiguous\\n     * sequence of elements of this stream that match the given predicate.  The\\n     * first element of the sequence is the first element of this stream, and\\n     * the element immediately following the last element of the sequence does\\n     * not match the given predicate.\\n     *\\n     * \u003cp\u003eIf this stream is unordered, and some (but not all) elements of this\\n     * stream match the given predicate, then the behavior of this operation is\\n     * nondeterministic; it is free to take any subset of matching elements\\n     * (which includes the empty set).\\n     *\\n     * \u003cp\u003eIndependent of whether this stream is ordered or unordered if all\\n     * elements of this stream match the given predicate then this operation\\n     * takes all elements (the result is the same as the input), or if no\\n     * elements of the stream match the given predicate then no elements are\\n     * taken (the result is an empty stream).\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * stateful intermediate operation\u003c/a\u003e.\\n     *\\n     * @implSpec\\n     * The default implementation obtains the {@link #spliterator() spliterator}\\n     * of this stream, wraps that spliterator so as to support the semantics\\n     * of this operation on traversal, and returns a new stream associated with\\n     * the wrapped spliterator.  The returned stream preserves the execution\\n     * characteristics of this stream (namely parallel or sequential execution\\n     * as per {@link #isParallel()}) but the wrapped spliterator may choose to\\n     * not support splitting.  When the returned stream is closed, the close\\n     * handlers for both the returned and this stream are invoked.\\n     *\\n     * @apiNote\\n     * While {@code takeWhile()} is generally a cheap operation on sequential\\n     * stream pipelines, it can be quite expensive on ordered parallel\\n     * pipelines, since the operation is constrained to return not just any\\n     * valid prefix, but the longest prefix of elements in the encounter order.\\n     * Using an unordered stream source (such as\\n     * {@link #generate(LongSupplier)}) or removing the ordering constraint with\\n     * {@link #unordered()} may result in significant speedups of\\n     * {@code takeWhile()} in parallel pipelines, if the semantics of your\\n     * situation permit.  If consistency with encounter order is required, and\\n     * you are experiencing poor performance or memory utilization with\\n     * {@code takeWhile()} in parallel pipelines, switching to sequential\\n     * execution with {@link #sequential()} may improve performance.\\n     *\\n     * @param predicate a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                  \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                  predicate to apply to elements to determine the longest\\n     *                  prefix of elements.\\n     * @return the new stream\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " LongStream dropWhile(LongPredicate predicate)", "label": " LongStream dropWhile(LongPredicate predicate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns, if this stream is ordered, a stream consisting of the remaining\\n     * elements of this stream after dropping the longest prefix of elements\\n     * that match the given predicate.  Otherwise returns, if this stream is\\n     * unordered, a stream consisting of the remaining elements of this stream\\n     * after dropping a subset of elements that match the given predicate.\\n     *\\n     * \u003cp\u003eIf this stream is ordered then the longest prefix is a contiguous\\n     * sequence of elements of this stream that match the given predicate.  The\\n     * first element of the sequence is the first element of this stream, and\\n     * the element immediately following the last element of the sequence does\\n     * not match the given predicate.\\n     *\\n     * \u003cp\u003eIf this stream is unordered, and some (but not all) elements of this\\n     * stream match the given predicate, then the behavior of this operation is\\n     * nondeterministic; it is free to drop any subset of matching elements\\n     * (which includes the empty set).\\n     *\\n     * \u003cp\u003eIndependent of whether this stream is ordered or unordered if all\\n     * elements of this stream match the given predicate then this operation\\n     * drops all elements (the result is an empty stream), or if no elements of\\n     * the stream match the given predicate then no elements are dropped (the\\n     * result is the same as the input).\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003estateful\\n     * intermediate operation\u003c/a\u003e.\\n     *\\n     * @implSpec\\n     * The default implementation obtains the {@link #spliterator() spliterator}\\n     * of this stream, wraps that spliterator so as to support the semantics\\n     * of this operation on traversal, and returns a new stream associated with\\n     * the wrapped spliterator.  The returned stream preserves the execution\\n     * characteristics of this stream (namely parallel or sequential execution\\n     * as per {@link #isParallel()}) but the wrapped spliterator may choose to\\n     * not support splitting.  When the returned stream is closed, the close\\n     * handlers for both the returned and this stream are invoked.\\n     *\\n     * @apiNote\\n     * While {@code dropWhile()} is generally a cheap operation on sequential\\n     * stream pipelines, it can be quite expensive on ordered parallel\\n     * pipelines, since the operation is constrained to return not just any\\n     * valid prefix, but the longest prefix of elements in the encounter order.\\n     * Using an unordered stream source (such as\\n     * {@link #generate(LongSupplier)}) or removing the ordering constraint with\\n     * {@link #unordered()} may result in significant speedups of\\n     * {@code dropWhile()} in parallel pipelines, if the semantics of your\\n     * situation permit.  If consistency with encounter order is required, and\\n     * you are experiencing poor performance or memory utilization with\\n     * {@code dropWhile()} in parallel pipelines, switching to sequential\\n     * execution with {@link #sequential()} may improve performance.\\n     *\\n     * @param predicate a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                  \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                  predicate to apply to elements to determine the longest\\n     *                  prefix of elements.\\n     * @return the new stream\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " void forEach(LongConsumer action)", "label": " void forEach(LongConsumer action)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs an action for each element of this stream.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eFor parallel stream pipelines, this operation does \u003cem\u003enot\u003c/em\u003e\\n     * guarantee to respect the encounter order of the stream, as doing so\\n     * would sacrifice the benefit of parallelism.  For any given element, the\\n     * action may be performed at whatever time and in whatever thread the\\n     * library chooses.  If the action accesses shared state, it is\\n     * responsible for providing the required synchronization.\\n     *\\n     * @param action a \u003ca href=\"package-summary.html#NonInterference\"\u003e\\n     *               non-interfering\u003c/a\u003e action to perform on the elements\\n     \u0027}"}, {"color": "#97c2fc", "id": " void forEachOrdered(LongConsumer action)", "label": " void forEachOrdered(LongConsumer action)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs an action for each element of this stream, guaranteeing that\\n     * each element is processed in encounter order for streams that have a\\n     * defined encounter order.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param action a \u003ca href=\"package-summary.html#NonInterference\"\u003e\\n     *               non-interfering\u003c/a\u003e action to perform on the elements\\n     * @see #forEach(LongConsumer)\\n     \u0027}"}, {"color": "#97c2fc", "id": " long[] toArray()", "label": " long[] toArray()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an array containing the elements of this stream.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @return an array containing the elements of this stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " long reduce(long identity, LongBinaryOperator op)", "label": " long reduce(long identity, LongBinaryOperator op)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs a \u003ca href=\"package-summary.html#Reduction\"\u003ereduction\u003c/a\u003e on the\\n     * elements of this stream, using the provided identity value and an\\n     * \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e\\n     * accumulation function, and returns the reduced value.  This is equivalent\\n     * to:\\n     * \u003cpre\u003e{@code\\n     *     long result = identity;\\n     *     for (long element : this stream)\\n     *         result = accumulator.applyAsLong(result, element)\\n     *     return result;\\n     * }\u003c/pre\u003e\\n     *\\n     * but is not constrained to execute sequentially.\\n     *\\n     * \u003cp\u003eThe {@code identity} value must be an identity for the accumulator\\n     * function. This means that for all {@code x},\\n     * {@code accumulator.apply(identity, x)} is equal to {@code x}.\\n     * The {@code accumulator} function must be an\\n     * \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e function.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @apiNote Sum, min, max, and average are all special cases of reduction.\\n     * Summing a stream of numbers can be expressed as:\\n     *\\n     * \u003cpre\u003e{@code\\n     *     long sum = integers.reduce(0, (a, b) -\u003e a+b);\\n     * }\u003c/pre\u003e\\n     *\\n     * or more compactly:\\n     *\\n     * \u003cpre\u003e{@code\\n     *     long sum = integers.reduce(0, Long::sum);\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eWhile this may seem a more roundabout way to perform an aggregation\\n     * compared to simply mutating a running total in a loop, reduction\\n     * operations parallelize more gracefully, without needing additional\\n     * synchronization and with greatly reduced risk of data races.\\n     *\\n     * @param identity the identity value for the accumulating function\\n     * @param op an \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e,\\n     *           \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *           \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *           function for combining two values\\n     * @return the result of the reduction\\n     * @see #sum()\\n     * @see #min()\\n     * @see #max()\\n     * @see #average()\\n     \u0027}"}, {"color": "#97c2fc", "id": " OptionalLong reduce(LongBinaryOperator op)", "label": " OptionalLong reduce(LongBinaryOperator op)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs a \u003ca href=\"package-summary.html#Reduction\"\u003ereduction\u003c/a\u003e on the\\n     * elements of this stream, using an\\n     * \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e accumulation\\n     * function, and returns an {@code OptionalLong} describing the reduced value,\\n     * if any. This is equivalent to:\\n     * \u003cpre\u003e{@code\\n     *     boolean foundAny = false;\\n     *     long result = null;\\n     *     for (long element : this stream) {\\n     *         if (!foundAny) {\\n     *             foundAny = true;\\n     *             result = element;\\n     *         }\\n     *         else\\n     *             result = accumulator.applyAsLong(result, element);\\n     *     }\\n     *     return foundAny ? OptionalLong.of(result) : OptionalLong.empty();\\n     * }\u003c/pre\u003e\\n     *\\n     * but is not constrained to execute sequentially.\\n     *\\n     * \u003cp\u003eThe {@code accumulator} function must be an\\n     * \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e function.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param op an \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e,\\n     *           \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *           \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *           function for combining two values\\n     * @return the result of the reduction\\n     * @see #reduce(long, LongBinaryOperator)\\n     \u0027}"}, {"color": "#97c2fc", "id": " R collect(Supplier\u003cR\u003e supplier, ObjLongConsumer\u003cR\u003e accumulator, BiConsumer\u003cR, R\u003e combiner)", "label": " R collect(Supplier\u003cR\u003e supplier, ObjLongConsumer\u003cR\u003e accumulator, BiConsumer\u003cR, R\u003e combiner)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Performs a \u003ca href=\"package-summary.html#MutableReduction\"\u003emutable\\n     * reduction\u003c/a\u003e operation on the elements of this stream.  A mutable\\n     * reduction is one in which the reduced value is a mutable result container,\\n     * such as an {@code ArrayList}, and elements are incorporated by updating\\n     * the state of the result rather than by replacing the result.  This\\n     * produces a result equivalent to:\\n     * \u003cpre\u003e{@code\\n     *     R result = supplier.get();\\n     *     for (long element : this stream)\\n     *         accumulator.accept(result, element);\\n     *     return result;\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eLike {@link #reduce(long, LongBinaryOperator)}, {@code collect} operations\\n     * can be parallelized without requiring additional synchronization.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @param \u003cR\u003e the type of the mutable result container\\n     * @param supplier a function that creates a new mutable result container.\\n     *                 For a parallel execution, this function may be called\\n     *                 multiple times and must return a fresh value each time.\\n     * @param accumulator an \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e,\\n     *                    \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                    \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                    function that must fold an element into a result\\n     *                    container.\\n     * @param combiner an \u003ca href=\"package-summary.html#Associativity\"\u003eassociative\u003c/a\u003e,\\n     *                    \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                    \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                    function that accepts two partial result containers\\n     *                    and merges them, which must be compatible with the\\n     *                    accumulator function.  The combiner function must fold\\n     *                    the elements from the second result container into the\\n     *                    first result container.\\n     * @return the result of the reduction\\n     * @see Stream#collect(Supplier, BiConsumer, BiConsumer)\\n     \u0027}"}, {"color": "#97c2fc", "id": "reduce(long", "label": "reduce(long", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " long sum()", "label": " long sum()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns the sum of elements in this stream.  This is a special case\\n     * of a \u003ca href=\"package-summary.html#Reduction\"\u003ereduction\u003c/a\u003e\\n     * and is equivalent to:\\n     * \u003cpre\u003e{@code\\n     *     return reduce(0, Long::sum);\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @return the sum of elements in this stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " OptionalLong min()", "label": " OptionalLong min()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@code OptionalLong} describing the minimum element of this\\n     * stream, or an empty optional if this stream is empty.  This is a special\\n     * case of a \u003ca href=\"package-summary.html#Reduction\"\u003ereduction\u003c/a\u003e\\n     * and is equivalent to:\\n     * \u003cpre\u003e{@code\\n     *     return reduce(Long::min);\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal operation\u003c/a\u003e.\\n     *\\n     * @return an {@code OptionalLong} containing the minimum element of this\\n     * stream, or an empty {@code OptionalLong} if the stream is empty\\n     \u0027}"}, {"color": "#97c2fc", "id": " OptionalLong max()", "label": " OptionalLong max()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@code OptionalLong} describing the maximum element of this\\n     * stream, or an empty optional if this stream is empty.  This is a special\\n     * case of a \u003ca href=\"package-summary.html#Reduction\"\u003ereduction\u003c/a\u003e\\n     * and is equivalent to:\\n     * \u003cpre\u003e{@code\\n     *     return reduce(Long::max);\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @return an {@code OptionalLong} containing the maximum element of this\\n     * stream, or an empty {@code OptionalLong} if the stream is empty\\n     \u0027}"}, {"color": "#97c2fc", "id": " LongSummaryStatistics summaryStatistics()", "label": " LongSummaryStatistics summaryStatistics()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code LongSummaryStatistics} describing various summary data\\n     * about the elements of this stream.  This is a special case of a\\n     * \u003ca href=\"package-summary.html#Reduction\"\u003ereduction\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eterminal\\n     * operation\u003c/a\u003e.\\n     *\\n     * @return a {@code LongSummaryStatistics} describing various summary data\\n     * about the elements of this stream\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean anyMatch(LongPredicate predicate)", "label": " boolean anyMatch(LongPredicate predicate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns whether any elements of this stream match the provided\\n     * predicate.  May not evaluate the predicate on all elements if not\\n     * necessary for determining the result.  If the stream is empty then\\n     * {@code false} is returned and the predicate is not evaluated.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * terminal operation\u003c/a\u003e.\\n     *\\n     * @apiNote\\n     * This method evaluates the \u003cem\u003eexistential quantification\u003c/em\u003e of the\\n     * predicate over the elements of the stream (for some x P(x)).\\n     *\\n     * @param predicate a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                  \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                  predicate to apply to elements of this stream\\n     * @return {@code true} if any elements of the stream match the provided\\n     * predicate, otherwise {@code false}\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean allMatch(LongPredicate predicate)", "label": " boolean allMatch(LongPredicate predicate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns whether all elements of this stream match the provided predicate.\\n     * May not evaluate the predicate on all elements if not necessary for\\n     * determining the result.  If the stream is empty then {@code true} is\\n     * returned and the predicate is not evaluated.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * terminal operation\u003c/a\u003e.\\n     *\\n     * @apiNote\\n     * This method evaluates the \u003cem\u003euniversal quantification\u003c/em\u003e of the\\n     * predicate over the elements of the stream (for all x P(x)).  If the\\n     * stream is empty, the quantification is said to be \u003cem\u003evacuously\\n     * satisfied\u003c/em\u003e and is always {@code true} (regardless of P(x)).\\n     *\\n     * @param predicate a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                  \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                  predicate to apply to elements of this stream\\n     * @return {@code true} if either all elements of the stream match the\\n     * provided predicate or the stream is empty, otherwise {@code false}\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean noneMatch(LongPredicate predicate)", "label": " boolean noneMatch(LongPredicate predicate)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns whether no elements of this stream match the provided predicate.\\n     * May not evaluate the predicate on all elements if not necessary for\\n     * determining the result.  If the stream is empty then {@code true} is\\n     * returned and the predicate is not evaluated.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * terminal operation\u003c/a\u003e.\\n     *\\n     * @apiNote\\n     * This method evaluates the \u003cem\u003euniversal quantification\u003c/em\u003e of the\\n     * negated predicate over the elements of the stream (for all x ~P(x)).  If\\n     * the stream is empty, the quantification is said to be vacuously satisfied\\n     * and is always {@code true}, regardless of P(x).\\n     *\\n     * @param predicate a \u003ca href=\"package-summary.html#NonInterference\"\u003enon-interfering\u003c/a\u003e,\\n     *                  \u003ca href=\"package-summary.html#Statelessness\"\u003estateless\u003c/a\u003e\\n     *                  predicate to apply to elements of this stream\\n     * @return {@code true} if either no elements of the stream match the\\n     * provided predicate or the stream is empty, otherwise {@code false}\\n     \u0027}"}, {"color": "#97c2fc", "id": " OptionalLong findFirst()", "label": " OptionalLong findFirst()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@link OptionalLong} describing the first element of this\\n     * stream, or an empty {@code OptionalLong} if the stream is empty.  If the\\n     * stream has no encounter order, then any element may be returned.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * terminal operation\u003c/a\u003e.\\n     *\\n     * @return an {@code OptionalLong} describing the first element of this\\n     * stream, or an empty {@code OptionalLong} if the stream is empty\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.util.OptionalLong", "label": "java.util.OptionalLong", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": " OptionalLong findAny()", "label": " OptionalLong findAny()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an {@link OptionalLong} describing some element of the stream, or\\n     * an empty {@code OptionalLong} if the stream is empty.\\n     *\\n     * \u003cp\u003eThis is a \u003ca href=\"package-summary.html#StreamOps\"\u003eshort-circuiting\\n     * terminal operation\u003c/a\u003e.\\n     *\\n     * \u003cp\u003eThe behavior of this operation is explicitly nondeterministic; it is\\n     * free to select any element in the stream.  This is to allow for maximal\\n     * performance in parallel operations; the cost is that multiple invocations\\n     * on the same source may not return the same result.  (If a stable result\\n     * is desired, use {@link #findFirst()} instead.)\\n     *\\n     * @return an {@code OptionalLong} describing some element of this stream,\\n     * or an empty {@code OptionalLong} if the stream is empty\\n     * @see #findFirst()\\n     \u0027}"}, {"color": "#97c2fc", "id": " Stream\u003cLong\u003e boxed()", "label": " Stream\u003cLong\u003e boxed()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a {@code Stream} consisting of the elements of this stream,\\n     * each boxed to a {@code Long}.\\n     *\\n     * \u003cp\u003eThis is an \u003ca href=\"package-summary.html#StreamOps\"\u003eintermediate\\n     * operation\u003c/a\u003e.\\n     *\\n     * @return a {@code Stream} consistent of the elements of this stream,\\n     * each boxed to {@code Long}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static LongStream empty()", "label": "public static LongStream empty()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an empty sequential {@code LongStream}.\\n     *\\n     * @return an empty sequential stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static LongStream of(long t)", "label": "public static LongStream of(long t)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a sequential {@code LongStream} containing a single element.\\n     *\\n     * @param t the single element\\n     * @return a singleton sequential stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static LongStream of(long... values)", "label": "public static LongStream of(long... values)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a sequential ordered stream whose elements are the specified values.\\n     *\\n     * @param values the elements of the new stream\\n     * @return the new stream\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static LongStream iterate(final long seed, final LongUnaryOperator f)", "label": "public static LongStream iterate(final long seed, final LongUnaryOperator f)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an infinite sequential ordered {@code LongStream} produced by iterative\\n     * application of a function {@code f} to an initial element {@code seed},\\n     * producing a {@code Stream} consisting of {@code seed}, {@code f(seed)},\\n     * {@code f(f(seed))}, etc.\\n     *\\n     * \u003cp\u003eThe first element (position {@code 0}) in the {@code LongStream} will\\n     * be the provided {@code seed}.  For {@code n \u003e 0}, the element at position\\n     * {@code n}, will be the result of applying the function {@code f} to the\\n     * element at position {@code n - 1}.\\n     *\\n     * \u003cp\u003eThe action of applying {@code f} for one element\\n     * \u003ca href=\"../concurrent/package-summary.html#MemoryVisibility\"\u003e\u003ci\u003ehappens-before\u003c/i\u003e\u003c/a\u003e\\n     * the action of applying {@code f} for subsequent elements.  For any given\\n     * element the action may be performed in whatever thread the library\\n     * chooses.\\n     *\\n     * @param seed the initial element\\n     * @param f a function to be applied to the previous element to produce\\n     *          a new element\\n     * @return a new sequential {@code LongStream}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static LongStream iterate(long seed, LongPredicate hasNext, LongUnaryOperator next)", "label": "public static LongStream iterate(long seed, LongPredicate hasNext, LongUnaryOperator next)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a sequential ordered {@code LongStream} produced by iterative\\n     * application of the given {@code next} function to an initial element,\\n     * conditioned on satisfying the given {@code hasNext} predicate.  The\\n     * stream terminates as soon as the {@code hasNext} predicate returns false.\\n     *\\n     * \u003cp\u003e{@code LongStream.iterate} should produce the same sequence of elements as\\n     * produced by the corresponding for-loop:\\n     * \u003cpre\u003e{@code\\n     *     for (long index=seed; hasNext.test(index); index = next.applyAsLong(index)) {\\n     *         ...\\n     *     }\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eThe resulting sequence may be empty if the {@code hasNext} predicate\\n     * does not hold on the seed value.  Otherwise the first element will be the\\n     * supplied {@code seed} value, the next element (if present) will be the\\n     * result of applying the {@code next} function to the {@code seed} value,\\n     * and so on iteratively until the {@code hasNext} predicate indicates that\\n     * the stream should terminate.\\n     *\\n     * \u003cp\u003eThe action of applying the {@code hasNext} predicate to an element\\n     * \u003ca href=\"../concurrent/package-summary.html#MemoryVisibility\"\u003e\u003ci\u003ehappens-before\u003c/i\u003e\u003c/a\u003e\\n     * the action of applying the {@code next} function to that element.  The\\n     * action of applying the {@code next} function for one element\\n     * \u003ci\u003ehappens-before\u003c/i\u003e the action of applying the {@code hasNext}\\n     * predicate for subsequent elements.  For any given element an action may\\n     * be performed in whatever thread the library chooses.\\n     *\\n     * @param seed the initial element\\n     * @param hasNext a predicate to apply to elements to determine when the\\n     *                stream must terminate.\\n     * @param next a function to be applied to the previous element to produce\\n     *             a new element\\n     * @return a new sequential {@code LongStream}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static LongStream generate(LongSupplier s)", "label": "public static LongStream generate(LongSupplier s)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an infinite sequential unordered stream where each element is\\n     * generated by the provided {@code LongSupplier}.  This is suitable for\\n     * generating constant streams, streams of random elements, etc.\\n     *\\n     * @param s the {@code LongSupplier} for generated elements\\n     * @return a new infinite sequential unordered {@code LongStream}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static LongStream range(long startInclusive, final long endExclusive)", "label": "public static LongStream range(long startInclusive, final long endExclusive)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a sequential ordered {@code LongStream} from {@code startInclusive}\\n     * (inclusive) to {@code endExclusive} (exclusive) by an incremental step of\\n     * {@code 1}.\\n     *\\n     * @apiNote\\n     * \u003cp\u003eAn equivalent sequence of increasing values can be produced\\n     * sequentially using a {@code for} loop as follows:\\n     * \u003cpre\u003e{@code\\n     *     for (long i = startInclusive; i \u003c endExclusive ; i++) { ... }\\n     * }\u003c/pre\u003e\\n     *\\n     * @param startInclusive the (inclusive) initial value\\n     * @param endExclusive the exclusive upper bound\\n     * @return a sequential {@code LongStream} for the range of {@code long}\\n     *         elements\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static LongStream rangeClosed(long startInclusive, final long endInclusive)", "label": "public static LongStream rangeClosed(long startInclusive, final long endInclusive)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a sequential ordered {@code LongStream} from {@code startInclusive}\\n     * (inclusive) to {@code endInclusive} (inclusive) by an incremental step of\\n     * {@code 1}.\\n     *\\n     * @apiNote\\n     * \u003cp\u003eAn equivalent sequence of increasing values can be produced\\n     * sequentially using a {@code for} loop as follows:\\n     * \u003cpre\u003e{@code\\n     *     for (long i = startInclusive; i \u003c= endInclusive ; i++) { ... }\\n     * }\u003c/pre\u003e\\n     *\\n     * @param startInclusive the (inclusive) initial value\\n     * @param endInclusive the inclusive upper bound\\n     * @return a sequential {@code LongStream} for the range of {@code long}\\n     *         elements\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static LongStream concat(LongStream a, LongStream b)", "label": "public static LongStream concat(LongStream a, LongStream b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a lazily concatenated stream whose elements are all the\\n     * elements of the first stream followed by all the elements of the\\n     * second stream.  The resulting stream is ordered if both\\n     * of the input streams are ordered, and parallel if either of the input\\n     * streams is parallel.  When the resulting stream is closed, the close\\n     * handlers for both input streams are invoked.\\n     *\\n     * \u003cp\u003eThis method operates on the two input streams and binds each stream\\n     * to its source.  As a result subsequent modifications to an input stream\\n     * source may not be reflected in the concatenated stream result.\\n     *\\n     * @implNote\\n     * Use caution when constructing streams from repeated concatenation.\\n     * Accessing an element of a deeply concatenated stream can result in deep\\n     * call chains, or even {@code StackOverflowError}.\\n     *\\n     * @apiNote\\n     * To preserve optimization opportunities this method binds each stream to\\n     * its source and accepts only two streams as parameters.  For example, the\\n     * exact size of the concatenated stream source can be computed if the exact\\n     * size of each input stream source is known.\\n     * To concatenate more streams without binding, or without nested calls to\\n     * this method, try creating a stream of streams and flat-mapping with the\\n     * identity function, for example:\\n     * \u003cpre\u003e{@code\\n     *     LongStream concat = Stream.of(s1, s2, s3, s4).flatMapToLong(s -\u003e s);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first stream\\n     * @param b the second stream\\n     * @return the concatenation of the two input streams\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static LongStream stream(long[] array, int startInclusive, int endExclusive)", "label": "public static LongStream stream(long[] array, int startInclusive, int endExclusive)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a sequential {@link LongStream} with the specified range of the\\n     * specified array as its source.\\n     *\\n     * @param array the array, assumed to be unmodified during use\\n     * @param startInclusive the first index to cover, inclusive\\n     * @param endExclusive index immediately past the last index to cover\\n     * @return a {@code LongStream} for the array range\\n     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is\\n     *         negative, {@code endExclusive} is less than\\n     *         {@code startInclusive}, or {@code endExclusive} is greater than\\n     *         the array size\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static DoubleStream stream(double[] array)", "label": "public static DoubleStream stream(double[] array)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a sequential {@link DoubleStream} with the specified array as its\\n     * source.\\n     *\\n     * @param array the array, assumed to be unmodified during use\\n     * @return a {@code DoubleStream} for the array\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static DoubleStream stream(double[] array, int startInclusive, int endExclusive)", "label": "public static DoubleStream stream(double[] array, int startInclusive, int endExclusive)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns a sequential {@link DoubleStream} with the specified range of the\\n     * specified array as its source.\\n     *\\n     * @param array the array, assumed to be unmodified during use\\n     * @param startInclusive the first index to cover, inclusive\\n     * @param endExclusive index immediately past the last index to cover\\n     * @return a {@code DoubleStream} for the array range\\n     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is\\n     *         negative, {@code endExclusive} is less than\\n     *         {@code startInclusive}, or {@code endExclusive} is greater than\\n     *         the array size\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int compare(boolean[] a, boolean[] b)", "label": "public static int compare(boolean[] a, boolean[] b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code boolean} arrays lexicographically.\\n     *\\n     * \u003cp\u003eIf the two arrays share a common prefix then the lexicographic\\n     * comparison is the result of comparing two elements, as if by\\n     * {@link Boolean#compare(boolean, boolean)}, at an index within the\\n     * respective arrays that is the prefix length.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two array lengths.\\n     * (See {@link #mismatch(boolean[], boolean[])} for the definition of a\\n     * common and proper prefix.)\\n     *\\n     * \u003cp\u003eA {@code null} array reference is considered lexicographically less\\n     * than a non-{@code null} array reference.  Two {@code null} array\\n     * references are considered equal.\\n     *\\n     * \u003cp\u003eThe comparison is consistent with {@link #equals(boolean[], boolean[]) equals},\\n     * more specifically the following holds for arrays {@code a} and {@code b}:\\n     * \u003cpre\u003e{@code\\n     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\\n     * }\u003c/pre\u003e\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if (for non-{@code null} array references):\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, b);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(a.length, b.length))\\n     *         return Boolean.compare(a[i], b[i]);\\n     *     return a.length - b.length;\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param b the second array to compare\\n     * @return the value {@code 0} if the first and second array are equal and\\n     *         contain the same elements in the same order;\\n     *         a value less than {@code 0} if the first array is\\n     *         lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if the first array is\\n     *         lexicographically greater than the second array\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "equals(boolean", "label": "equals(boolean", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "compare(boolean", "label": "compare(boolean", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "mismatch(boolean", "label": "mismatch(boolean", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int compare(boolean[] a, int aFromIndex, int aToIndex, boolean[] b, int bFromIndex, int bToIndex)", "label": "public static int compare(boolean[] a, int aFromIndex, int aToIndex, boolean[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code boolean} arrays lexicographically over the specified\\n     * ranges.\\n     *\\n     * \u003cp\u003eIf the two arrays, over the specified ranges, share a common prefix\\n     * then the lexicographic comparison is the result of comparing two\\n     * elements, as if by {@link Boolean#compare(boolean, boolean)}, at a\\n     * relative index within the respective arrays that is the length of the\\n     * prefix.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two range lengths.\\n     * (See {@link #mismatch(boolean[], int, int, boolean[], int, int)} for the\\n     * definition of a common and proper prefix.)\\n     *\\n     * \u003cp\u003eThe comparison is consistent with\\n     * {@link #equals(boolean[], int, int, boolean[], int, int) equals}, more\\n     * specifically the following holds for arrays {@code a} and {@code b} with\\n     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively:\\n     * \u003cpre\u003e{@code\\n     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\\n     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\\n     * }\u003c/pre\u003e\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if:\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\\n     *                             b, bFromIndex, bToIndex);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\\n     *         return Boolean.compare(a[aFromIndex + i], b[bFromIndex + i]);\\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be compared\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be compared\\n     * @param b the second array to compare\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be compared\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be compared\\n     * @return the value {@code 0} if, over the specified ranges, the first and\\n     *         second array are equal and contain the same elements in the same\\n     *         order;\\n     *         a value less than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically greater than the second array\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int compare(byte[] a, byte[] b)", "label": "public static int compare(byte[] a, byte[] b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code byte} arrays lexicographically.\\n     *\\n     * \u003cp\u003eIf the two arrays share a common prefix then the lexicographic\\n     * comparison is the result of comparing two elements, as if by\\n     * {@link Byte#compare(byte, byte)}, at an index within the respective\\n     * arrays that is the prefix length.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two array lengths.\\n     * (See {@link #mismatch(byte[], byte[])} for the definition of a common and\\n     * proper prefix.)\\n     *\\n     * \u003cp\u003eA {@code null} array reference is considered lexicographically less\\n     * than a non-{@code null} array reference.  Two {@code null} array\\n     * references are considered equal.\\n     *\\n     * \u003cp\u003eThe comparison is consistent with {@link #equals(byte[], byte[]) equals},\\n     * more specifically the following holds for arrays {@code a} and {@code b}:\\n     * \u003cpre\u003e{@code\\n     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\\n     * }\u003c/pre\u003e\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if (for non-{@code null} array references):\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, b);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(a.length, b.length))\\n     *         return Byte.compare(a[i], b[i]);\\n     *     return a.length - b.length;\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param b the second array to compare\\n     * @return the value {@code 0} if the first and second array are equal and\\n     *         contain the same elements in the same order;\\n     *         a value less than {@code 0} if the first array is\\n     *         lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if the first array is\\n     *         lexicographically greater than the second array\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "equals(byte", "label": "equals(byte", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "mismatch(byte", "label": "mismatch(byte", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int compare(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)", "label": "public static int compare(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code byte} arrays lexicographically over the specified\\n     * ranges.\\n     *\\n     * \u003cp\u003eIf the two arrays, over the specified ranges, share a common prefix\\n     * then the lexicographic comparison is the result of comparing two\\n     * elements, as if by {@link Byte#compare(byte, byte)}, at a relative index\\n     * within the respective arrays that is the length of the prefix.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two range lengths.\\n     * (See {@link #mismatch(byte[], int, int, byte[], int, int)} for the\\n     * definition of a common and proper prefix.)\\n     *\\n     * \u003cp\u003eThe comparison is consistent with\\n     * {@link #equals(byte[], int, int, byte[], int, int) equals}, more\\n     * specifically the following holds for arrays {@code a} and {@code b} with\\n     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively:\\n     * \u003cpre\u003e{@code\\n     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\\n     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\\n     * }\u003c/pre\u003e\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if:\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\\n     *                             b, bFromIndex, bToIndex);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\\n     *         return Byte.compare(a[aFromIndex + i], b[bFromIndex + i]);\\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be compared\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be compared\\n     * @param b the second array to compare\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be compared\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be compared\\n     * @return the value {@code 0} if, over the specified ranges, the first and\\n     *         second array are equal and contain the same elements in the same\\n     *         order;\\n     *         a value less than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically greater than the second array\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int compareUnsigned(byte[] a, byte[] b)", "label": "public static int compareUnsigned(byte[] a, byte[] b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code byte} arrays lexicographically, numerically treating\\n     * elements as unsigned.\\n     *\\n     * \u003cp\u003eIf the two arrays share a common prefix then the lexicographic\\n     * comparison is the result of comparing two elements, as if by\\n     * {@link Byte#compareUnsigned(byte, byte)}, at an index within the\\n     * respective arrays that is the prefix length.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two array lengths.\\n     * (See {@link #mismatch(byte[], byte[])} for the definition of a common\\n     * and proper prefix.)\\n     *\\n     * \u003cp\u003eA {@code null} array reference is considered lexicographically less\\n     * than a non-{@code null} array reference.  Two {@code null} array\\n     * references are considered equal.\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if (for non-{@code null} array references):\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, b);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(a.length, b.length))\\n     *         return Byte.compareUnsigned(a[i], b[i]);\\n     *     return a.length - b.length;\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param b the second array to compare\\n     * @return the value {@code 0} if the first and second array are\\n     *         equal and contain the same elements in the same order;\\n     *         a value less than {@code 0} if the first array is\\n     *         lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if the first array is\\n     *         lexicographically greater than the second array\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "compareUnsigned(byte", "label": "compareUnsigned(byte", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int compareUnsigned(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)", "label": "public static int compareUnsigned(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code byte} arrays lexicographically over the specified\\n     * ranges, numerically treating elements as unsigned.\\n     *\\n     * \u003cp\u003eIf the two arrays, over the specified ranges, share a common prefix\\n     * then the lexicographic comparison is the result of comparing two\\n     * elements, as if by {@link Byte#compareUnsigned(byte, byte)}, at a\\n     * relative index within the respective arrays that is the length of the\\n     * prefix.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two range lengths.\\n     * (See {@link #mismatch(byte[], int, int, byte[], int, int)} for the\\n     * definition of a common and proper prefix.)\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if:\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\\n     *                             b, bFromIndex, bToIndex);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\\n     *         return Byte.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);\\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be compared\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be compared\\n     * @param b the second array to compare\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be compared\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be compared\\n     * @return the value {@code 0} if, over the specified ranges, the first and\\n     *         second array are equal and contain the same elements in the same\\n     *         order;\\n     *         a value less than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically greater than the second array\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is null\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int compare(short[] a, short[] b)", "label": "public static int compare(short[] a, short[] b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code short} arrays lexicographically.\\n     *\\n     * \u003cp\u003eIf the two arrays share a common prefix then the lexicographic\\n     * comparison is the result of comparing two elements, as if by\\n     * {@link Short#compare(short, short)}, at an index within the respective\\n     * arrays that is the prefix length.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two array lengths.\\n     * (See {@link #mismatch(short[], short[])} for the definition of a common\\n     * and proper prefix.)\\n     *\\n     * \u003cp\u003eA {@code null} array reference is considered lexicographically less\\n     * than a non-{@code null} array reference.  Two {@code null} array\\n     * references are considered equal.\\n     *\\n     * \u003cp\u003eThe comparison is consistent with {@link #equals(short[], short[]) equals},\\n     * more specifically the following holds for arrays {@code a} and {@code b}:\\n     * \u003cpre\u003e{@code\\n     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\\n     * }\u003c/pre\u003e\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if (for non-{@code null} array references):\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, b);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(a.length, b.length))\\n     *         return Short.compare(a[i], b[i]);\\n     *     return a.length - b.length;\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param b the second array to compare\\n     * @return the value {@code 0} if the first and second array are equal and\\n     *         contain the same elements in the same order;\\n     *         a value less than {@code 0} if the first array is\\n     *         lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if the first array is\\n     *         lexicographically greater than the second array\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "compare(short", "label": "compare(short", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "equals(short", "label": "equals(short", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "mismatch(short", "label": "mismatch(short", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int compare(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)", "label": "public static int compare(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code short} arrays lexicographically over the specified\\n     * ranges.\\n     *\\n     * \u003cp\u003eIf the two arrays, over the specified ranges, share a common prefix\\n     * then the lexicographic comparison is the result of comparing two\\n     * elements, as if by {@link Short#compare(short, short)}, at a relative\\n     * index within the respective arrays that is the length of the prefix.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two range lengths.\\n     * (See {@link #mismatch(short[], int, int, short[], int, int)} for the\\n     * definition of a common and proper prefix.)\\n     *\\n     * \u003cp\u003eThe comparison is consistent with\\n     * {@link #equals(short[], int, int, short[], int, int) equals}, more\\n     * specifically the following holds for arrays {@code a} and {@code b} with\\n     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively:\\n     * \u003cpre\u003e{@code\\n     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\\n     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\\n     * }\u003c/pre\u003e\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if:\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\\n     *                             b, bFromIndex, bToIndex);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\\n     *         return Short.compare(a[aFromIndex + i], b[bFromIndex + i]);\\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be compared\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be compared\\n     * @param b the second array to compare\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be compared\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be compared\\n     * @return the value {@code 0} if, over the specified ranges, the first and\\n     *         second array are equal and contain the same elements in the same\\n     *         order;\\n     *         a value less than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically greater than the second array\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int compareUnsigned(short[] a, short[] b)", "label": "public static int compareUnsigned(short[] a, short[] b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code short} arrays lexicographically, numerically treating\\n     * elements as unsigned.\\n     *\\n     * \u003cp\u003eIf the two arrays share a common prefix then the lexicographic\\n     * comparison is the result of comparing two elements, as if by\\n     * {@link Short#compareUnsigned(short, short)}, at an index within the\\n     * respective arrays that is the prefix length.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two array lengths.\\n     * (See {@link #mismatch(short[], short[])} for the definition of a common\\n     * and proper prefix.)\\n     *\\n     * \u003cp\u003eA {@code null} array reference is considered lexicographically less\\n     * than a non-{@code null} array reference.  Two {@code null} array\\n     * references are considered equal.\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if (for non-{@code null} array references):\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, b);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(a.length, b.length))\\n     *         return Short.compareUnsigned(a[i], b[i]);\\n     *     return a.length - b.length;\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param b the second array to compare\\n     * @return the value {@code 0} if the first and second array are\\n     *         equal and contain the same elements in the same order;\\n     *         a value less than {@code 0} if the first array is\\n     *         lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if the first array is\\n     *         lexicographically greater than the second array\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "compareUnsigned(short", "label": "compareUnsigned(short", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int compareUnsigned(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)", "label": "public static int compareUnsigned(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code short} arrays lexicographically over the specified\\n     * ranges, numerically treating elements as unsigned.\\n     *\\n     * \u003cp\u003eIf the two arrays, over the specified ranges, share a common prefix\\n     * then the lexicographic comparison is the result of comparing two\\n     * elements, as if by {@link Short#compareUnsigned(short, short)}, at a\\n     * relative index within the respective arrays that is the length of the\\n     * prefix.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two range lengths.\\n     * (See {@link #mismatch(short[], int, int, short[], int, int)} for the\\n     * definition of a common and proper prefix.)\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if:\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\\n     *                             b, bFromIndex, bToIndex);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\\n     *         return Short.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);\\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be compared\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be compared\\n     * @param b the second array to compare\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be compared\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be compared\\n     * @return the value {@code 0} if, over the specified ranges, the first and\\n     *         second array are equal and contain the same elements in the same\\n     *         order;\\n     *         a value less than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically greater than the second array\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is null\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int compare(char[] a, char[] b)", "label": "public static int compare(char[] a, char[] b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code char} arrays lexicographically.\\n     *\\n     * \u003cp\u003eIf the two arrays share a common prefix then the lexicographic\\n     * comparison is the result of comparing two elements, as if by\\n     * {@link Character#compare(char, char)}, at an index within the respective\\n     * arrays that is the prefix length.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two array lengths.\\n     * (See {@link #mismatch(char[], char[])} for the definition of a common and\\n     * proper prefix.)\\n     *\\n     * \u003cp\u003eA {@code null} array reference is considered lexicographically less\\n     * than a non-{@code null} array reference.  Two {@code null} array\\n     * references are considered equal.\\n     *\\n     * \u003cp\u003eThe comparison is consistent with {@link #equals(char[], char[]) equals},\\n     * more specifically the following holds for arrays {@code a} and {@code b}:\\n     * \u003cpre\u003e{@code\\n     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\\n     * }\u003c/pre\u003e\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if (for non-{@code null} array references):\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, b);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(a.length, b.length))\\n     *         return Character.compare(a[i], b[i]);\\n     *     return a.length - b.length;\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param b the second array to compare\\n     * @return the value {@code 0} if the first and second array are equal and\\n     *         contain the same elements in the same order;\\n     *         a value less than {@code 0} if the first array is\\n     *         lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if the first array is\\n     *         lexicographically greater than the second array\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "equals(char", "label": "equals(char", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "mismatch(char", "label": "mismatch(char", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "compare(char", "label": "compare(char", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int compare(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex)", "label": "public static int compare(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code char} arrays lexicographically over the specified\\n     * ranges.\\n     *\\n     * \u003cp\u003eIf the two arrays, over the specified ranges, share a common prefix\\n     * then the lexicographic comparison is the result of comparing two\\n     * elements, as if by {@link Character#compare(char, char)}, at a relative\\n     * index within the respective arrays that is the length of the prefix.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two range lengths.\\n     * (See {@link #mismatch(char[], int, int, char[], int, int)} for the\\n     * definition of a common and proper prefix.)\\n     *\\n     * \u003cp\u003eThe comparison is consistent with\\n     * {@link #equals(char[], int, int, char[], int, int) equals}, more\\n     * specifically the following holds for arrays {@code a} and {@code b} with\\n     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively:\\n     * \u003cpre\u003e{@code\\n     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\\n     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\\n     * }\u003c/pre\u003e\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if:\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\\n     *                             b, bFromIndex, bToIndex);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\\n     *         return Character.compare(a[aFromIndex + i], b[bFromIndex + i]);\\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be compared\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be compared\\n     * @param b the second array to compare\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be compared\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be compared\\n     * @return the value {@code 0} if, over the specified ranges, the first and\\n     *         second array are equal and contain the same elements in the same\\n     *         order;\\n     *         a value less than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically greater than the second array\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int compare(int[] a, int[] b)", "label": "public static int compare(int[] a, int[] b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code int} arrays lexicographically.\\n     *\\n     * \u003cp\u003eIf the two arrays share a common prefix then the lexicographic\\n     * comparison is the result of comparing two elements, as if by\\n     * {@link Integer#compare(int, int)}, at an index within the respective\\n     * arrays that is the prefix length.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two array lengths.\\n     * (See {@link #mismatch(int[], int[])} for the definition of a common and\\n     * proper prefix.)\\n     *\\n     * \u003cp\u003eA {@code null} array reference is considered lexicographically less\\n     * than a non-{@code null} array reference.  Two {@code null} array\\n     * references are considered equal.\\n     *\\n     * \u003cp\u003eThe comparison is consistent with {@link #equals(int[], int[]) equals},\\n     * more specifically the following holds for arrays {@code a} and {@code b}:\\n     * \u003cpre\u003e{@code\\n     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\\n     * }\u003c/pre\u003e\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if (for non-{@code null} array references):\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, b);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(a.length, b.length))\\n     *         return Integer.compare(a[i], b[i]);\\n     *     return a.length - b.length;\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param b the second array to compare\\n     * @return the value {@code 0} if the first and second array are equal and\\n     *         contain the same elements in the same order;\\n     *         a value less than {@code 0} if the first array is\\n     *         lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if the first array is\\n     *         lexicographically greater than the second array\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "mismatch(int", "label": "mismatch(int", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "equals(int", "label": "equals(int", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "compare(int", "label": "compare(int", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int compare(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)", "label": "public static int compare(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code int} arrays lexicographically over the specified\\n     * ranges.\\n     *\\n     * \u003cp\u003eIf the two arrays, over the specified ranges, share a common prefix\\n     * then the lexicographic comparison is the result of comparing two\\n     * elements, as if by {@link Integer#compare(int, int)}, at a relative index\\n     * within the respective arrays that is the length of the prefix.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two range lengths.\\n     * (See {@link #mismatch(int[], int, int, int[], int, int)} for the\\n     * definition of a common and proper prefix.)\\n     *\\n     * \u003cp\u003eThe comparison is consistent with\\n     * {@link #equals(int[], int, int, int[], int, int) equals}, more\\n     * specifically the following holds for arrays {@code a} and {@code b} with\\n     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively:\\n     * \u003cpre\u003e{@code\\n     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\\n     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\\n     * }\u003c/pre\u003e\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if:\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\\n     *                             b, bFromIndex, bToIndex);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\\n     *         return Integer.compare(a[aFromIndex + i], b[bFromIndex + i]);\\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be compared\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be compared\\n     * @param b the second array to compare\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be compared\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be compared\\n     * @return the value {@code 0} if, over the specified ranges, the first and\\n     *         second array are equal and contain the same elements in the same\\n     *         order;\\n     *         a value less than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically greater than the second array\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int compareUnsigned(int[] a, int[] b)", "label": "public static int compareUnsigned(int[] a, int[] b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code int} arrays lexicographically, numerically treating\\n     * elements as unsigned.\\n     *\\n     * \u003cp\u003eIf the two arrays share a common prefix then the lexicographic\\n     * comparison is the result of comparing two elements, as if by\\n     * {@link Integer#compareUnsigned(int, int)}, at an index within the\\n     * respective arrays that is the prefix length.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two array lengths.\\n     * (See {@link #mismatch(int[], int[])} for the definition of a common\\n     * and proper prefix.)\\n     *\\n     * \u003cp\u003eA {@code null} array reference is considered lexicographically less\\n     * than a non-{@code null} array reference.  Two {@code null} array\\n     * references are considered equal.\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if (for non-{@code null} array references):\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, b);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(a.length, b.length))\\n     *         return Integer.compareUnsigned(a[i], b[i]);\\n     *     return a.length - b.length;\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param b the second array to compare\\n     * @return the value {@code 0} if the first and second array are\\n     *         equal and contain the same elements in the same order;\\n     *         a value less than {@code 0} if the first array is\\n     *         lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if the first array is\\n     *         lexicographically greater than the second array\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "compareUnsigned(int", "label": "compareUnsigned(int", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int compareUnsigned(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)", "label": "public static int compareUnsigned(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code int} arrays lexicographically over the specified\\n     * ranges, numerically treating elements as unsigned.\\n     *\\n     * \u003cp\u003eIf the two arrays, over the specified ranges, share a common prefix\\n     * then the lexicographic comparison is the result of comparing two\\n     * elements, as if by {@link Integer#compareUnsigned(int, int)}, at a\\n     * relative index within the respective arrays that is the length of the\\n     * prefix.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two range lengths.\\n     * (See {@link #mismatch(int[], int, int, int[], int, int)} for the\\n     * definition of a common and proper prefix.)\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if:\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\\n     *                             b, bFromIndex, bToIndex);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\\n     *         return Integer.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);\\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be compared\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be compared\\n     * @param b the second array to compare\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be compared\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be compared\\n     * @return the value {@code 0} if, over the specified ranges, the first and\\n     *         second array are equal and contain the same elements in the same\\n     *         order;\\n     *         a value less than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically greater than the second array\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is null\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int compare(long[] a, long[] b)", "label": "public static int compare(long[] a, long[] b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code long} arrays lexicographically.\\n     *\\n     * \u003cp\u003eIf the two arrays share a common prefix then the lexicographic\\n     * comparison is the result of comparing two elements, as if by\\n     * {@link Long#compare(long, long)}, at an index within the respective\\n     * arrays that is the prefix length.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two array lengths.\\n     * (See {@link #mismatch(long[], long[])} for the definition of a common and\\n     * proper prefix.)\\n     *\\n     * \u003cp\u003eA {@code null} array reference is considered lexicographically less\\n     * than a non-{@code null} array reference.  Two {@code null} array\\n     * references are considered equal.\\n     *\\n     * \u003cp\u003eThe comparison is consistent with {@link #equals(long[], long[]) equals},\\n     * more specifically the following holds for arrays {@code a} and {@code b}:\\n     * \u003cpre\u003e{@code\\n     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\\n     * }\u003c/pre\u003e\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if (for non-{@code null} array references):\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, b);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(a.length, b.length))\\n     *         return Long.compare(a[i], b[i]);\\n     *     return a.length - b.length;\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param b the second array to compare\\n     * @return the value {@code 0} if the first and second array are equal and\\n     *         contain the same elements in the same order;\\n     *         a value less than {@code 0} if the first array is\\n     *         lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if the first array is\\n     *         lexicographically greater than the second array\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "compare(long", "label": "compare(long", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "mismatch(long", "label": "mismatch(long", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "equals(long", "label": "equals(long", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int compare(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)", "label": "public static int compare(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code long} arrays lexicographically over the specified\\n     * ranges.\\n     *\\n     * \u003cp\u003eIf the two arrays, over the specified ranges, share a common prefix\\n     * then the lexicographic comparison is the result of comparing two\\n     * elements, as if by {@link Long#compare(long, long)}, at a relative index\\n     * within the respective arrays that is the length of the prefix.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two range lengths.\\n     * (See {@link #mismatch(long[], int, int, long[], int, int)} for the\\n     * definition of a common and proper prefix.)\\n     *\\n     * \u003cp\u003eThe comparison is consistent with\\n     * {@link #equals(long[], int, int, long[], int, int) equals}, more\\n     * specifically the following holds for arrays {@code a} and {@code b} with\\n     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively:\\n     * \u003cpre\u003e{@code\\n     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\\n     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\\n     * }\u003c/pre\u003e\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if:\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\\n     *                             b, bFromIndex, bToIndex);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\\n     *         return Long.compare(a[aFromIndex + i], b[bFromIndex + i]);\\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be compared\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be compared\\n     * @param b the second array to compare\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be compared\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be compared\\n     * @return the value {@code 0} if, over the specified ranges, the first and\\n     *         second array are equal and contain the same elements in the same\\n     *         order;\\n     *         a value less than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically greater than the second array\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int compareUnsigned(long[] a, long[] b)", "label": "public static int compareUnsigned(long[] a, long[] b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code long} arrays lexicographically, numerically treating\\n     * elements as unsigned.\\n     *\\n     * \u003cp\u003eIf the two arrays share a common prefix then the lexicographic\\n     * comparison is the result of comparing two elements, as if by\\n     * {@link Long#compareUnsigned(long, long)}, at an index within the\\n     * respective arrays that is the prefix length.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two array lengths.\\n     * (See {@link #mismatch(long[], long[])} for the definition of a common\\n     * and proper prefix.)\\n     *\\n     * \u003cp\u003eA {@code null} array reference is considered lexicographically less\\n     * than a non-{@code null} array reference.  Two {@code null} array\\n     * references are considered equal.\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if (for non-{@code null} array references):\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, b);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(a.length, b.length))\\n     *         return Long.compareUnsigned(a[i], b[i]);\\n     *     return a.length - b.length;\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param b the second array to compare\\n     * @return the value {@code 0} if the first and second array are\\n     *         equal and contain the same elements in the same order;\\n     *         a value less than {@code 0} if the first array is\\n     *         lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if the first array is\\n     *         lexicographically greater than the second array\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "compareUnsigned(long", "label": "compareUnsigned(long", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int compareUnsigned(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)", "label": "public static int compareUnsigned(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code long} arrays lexicographically over the specified\\n     * ranges, numerically treating elements as unsigned.\\n     *\\n     * \u003cp\u003eIf the two arrays, over the specified ranges, share a common prefix\\n     * then the lexicographic comparison is the result of comparing two\\n     * elements, as if by {@link Long#compareUnsigned(long, long)}, at a\\n     * relative index within the respective arrays that is the length of the\\n     * prefix.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two range lengths.\\n     * (See {@link #mismatch(long[], int, int, long[], int, int)} for the\\n     * definition of a common and proper prefix.)\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if:\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\\n     *                             b, bFromIndex, bToIndex);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\\n     *         return Long.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);\\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be compared\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be compared\\n     * @param b the second array to compare\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be compared\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be compared\\n     * @return the value {@code 0} if, over the specified ranges, the first and\\n     *         second array are equal and contain the same elements in the same\\n     *         order;\\n     *         a value less than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically greater than the second array\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is null\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int compare(float[] a, float[] b)", "label": "public static int compare(float[] a, float[] b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code float} arrays lexicographically.\\n     *\\n     * \u003cp\u003eIf the two arrays share a common prefix then the lexicographic\\n     * comparison is the result of comparing two elements, as if by\\n     * {@link Float#compare(float, float)}, at an index within the respective\\n     * arrays that is the prefix length.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two array lengths.\\n     * (See {@link #mismatch(float[], float[])} for the definition of a common\\n     * and proper prefix.)\\n     *\\n     * \u003cp\u003eA {@code null} array reference is considered lexicographically less\\n     * than a non-{@code null} array reference.  Two {@code null} array\\n     * references are considered equal.\\n     *\\n     * \u003cp\u003eThe comparison is consistent with {@link #equals(float[], float[]) equals},\\n     * more specifically the following holds for arrays {@code a} and {@code b}:\\n     * \u003cpre\u003e{@code\\n     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\\n     * }\u003c/pre\u003e\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if (for non-{@code null} array references):\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, b);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(a.length, b.length))\\n     *         return Float.compare(a[i], b[i]);\\n     *     return a.length - b.length;\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param b the second array to compare\\n     * @return the value {@code 0} if the first and second array are equal and\\n     *         contain the same elements in the same order;\\n     *         a value less than {@code 0} if the first array is\\n     *         lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if the first array is\\n     *         lexicographically greater than the second array\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "compare(float", "label": "compare(float", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "equals(float", "label": "equals(float", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "mismatch(float", "label": "mismatch(float", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int compare(float[] a, int aFromIndex, int aToIndex, float[] b, int bFromIndex, int bToIndex)", "label": "public static int compare(float[] a, int aFromIndex, int aToIndex, float[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code float} arrays lexicographically over the specified\\n     * ranges.\\n     *\\n     * \u003cp\u003eIf the two arrays, over the specified ranges, share a common prefix\\n     * then the lexicographic comparison is the result of comparing two\\n     * elements, as if by {@link Float#compare(float, float)}, at a relative\\n     * index within the respective arrays that is the length of the prefix.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two range lengths.\\n     * (See {@link #mismatch(float[], int, int, float[], int, int)} for the\\n     * definition of a common and proper prefix.)\\n     *\\n     * \u003cp\u003eThe comparison is consistent with\\n     * {@link #equals(float[], int, int, float[], int, int) equals}, more\\n     * specifically the following holds for arrays {@code a} and {@code b} with\\n     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively:\\n     * \u003cpre\u003e{@code\\n     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\\n     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\\n     * }\u003c/pre\u003e\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if:\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\\n     *                             b, bFromIndex, bToIndex);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\\n     *         return Float.compare(a[aFromIndex + i], b[bFromIndex + i]);\\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be compared\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be compared\\n     * @param b the second array to compare\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be compared\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be compared\\n     * @return the value {@code 0} if, over the specified ranges, the first and\\n     *         second array are equal and contain the same elements in the same\\n     *         order;\\n     *         a value less than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically greater than the second array\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int compare(double[] a, double[] b)", "label": "public static int compare(double[] a, double[] b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code double} arrays lexicographically.\\n     *\\n     * \u003cp\u003eIf the two arrays share a common prefix then the lexicographic\\n     * comparison is the result of comparing two elements, as if by\\n     * {@link Double#compare(double, double)}, at an index within the respective\\n     * arrays that is the prefix length.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two array lengths.\\n     * (See {@link #mismatch(double[], double[])} for the definition of a common\\n     * and proper prefix.)\\n     *\\n     * \u003cp\u003eA {@code null} array reference is considered lexicographically less\\n     * than a non-{@code null} array reference.  Two {@code null} array\\n     * references are considered equal.\\n     *\\n     * \u003cp\u003eThe comparison is consistent with {@link #equals(double[], double[]) equals},\\n     * more specifically the following holds for arrays {@code a} and {@code b}:\\n     * \u003cpre\u003e{@code\\n     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\\n     * }\u003c/pre\u003e\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if (for non-{@code null} array references):\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, b);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(a.length, b.length))\\n     *         return Double.compare(a[i], b[i]);\\n     *     return a.length - b.length;\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param b the second array to compare\\n     * @return the value {@code 0} if the first and second array are equal and\\n     *         contain the same elements in the same order;\\n     *         a value less than {@code 0} if the first array is\\n     *         lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if the first array is\\n     *         lexicographically greater than the second array\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "equals(double", "label": "equals(double", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "mismatch(double", "label": "mismatch(double", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int compare(double[] a, int aFromIndex, int aToIndex, double[] b, int bFromIndex, int bToIndex)", "label": "public static int compare(double[] a, int aFromIndex, int aToIndex, double[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code double} arrays lexicographically over the specified\\n     * ranges.\\n     *\\n     * \u003cp\u003eIf the two arrays, over the specified ranges, share a common prefix\\n     * then the lexicographic comparison is the result of comparing two\\n     * elements, as if by {@link Double#compare(double, double)}, at a relative\\n     * index within the respective arrays that is the length of the prefix.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two range lengths.\\n     * (See {@link #mismatch(double[], int, int, double[], int, int)} for the\\n     * definition of a common and proper prefix.)\\n     *\\n     * \u003cp\u003eThe comparison is consistent with\\n     * {@link #equals(double[], int, int, double[], int, int) equals}, more\\n     * specifically the following holds for arrays {@code a} and {@code b} with\\n     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively:\\n     * \u003cpre\u003e{@code\\n     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\\n     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\\n     * }\u003c/pre\u003e\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if:\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\\n     *                             b, bFromIndex, bToIndex);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\\n     *         return Double.compare(a[aFromIndex + i], b[bFromIndex + i]);\\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be compared\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be compared\\n     * @param b the second array to compare\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be compared\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be compared\\n     * @return the value {@code 0} if, over the specified ranges, the first and\\n     *         second array are equal and contain the same elements in the same\\n     *         order;\\n     *         a value less than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically greater than the second array\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int compare(T[] a, T[] b)", "label": "public static int compare(T[] a, T[] b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code Object} arrays, within comparable elements,\\n     * lexicographically.\\n     *\\n     * \u003cp\u003eIf the two arrays share a common prefix then the lexicographic\\n     * comparison is the result of comparing two elements of type {@code T} at\\n     * an index {@code i} within the respective arrays that is the prefix\\n     * length, as if by:\\n     * \u003cpre\u003e{@code\\n     *     Comparator.nullsFirst(Comparator.\u003cT\u003enaturalOrder()).\\n     *         compare(a[i], b[i])\\n     * }\u003c/pre\u003e\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two array lengths.\\n     * (See {@link #mismatch(Object[], Object[])} for the definition of a common\\n     * and proper prefix.)\\n     *\\n     * \u003cp\u003eA {@code null} array reference is considered lexicographically less\\n     * than a non-{@code null} array reference. Two {@code null} array\\n     * references are considered equal.\\n     * A {@code null} array element is considered lexicographically less than a\\n     * non-{@code null} array element. Two {@code null} array elements are\\n     * considered equal.\\n     *\\n     * \u003cp\u003eThe comparison is consistent with {@link #equals(Object[], Object[]) equals},\\n     * more specifically the following holds for arrays {@code a} and {@code b}:\\n     * \u003cpre\u003e{@code\\n     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\\n     * }\u003c/pre\u003e\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if (for non-{@code null} array references\\n     * and elements):\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, b);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(a.length, b.length))\\n     *         return a[i].compareTo(b[i]);\\n     *     return a.length - b.length;\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param b the second array to compare\\n     * @param \u003cT\u003e the type of comparable array elements\\n     * @return the value {@code 0} if the first and second array are equal and\\n     *         contain the same elements in the same order;\\n     *         a value less than {@code 0} if the first array is\\n     *         lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if the first array is\\n     *         lexicographically greater than the second array\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "mismatch(Object", "label": "mismatch(Object", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "public static int compare(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex)", "label": "public static int compare(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code Object} arrays lexicographically over the specified\\n     * ranges.\\n     *\\n     * \u003cp\u003eIf the two arrays, over the specified ranges, share a common prefix\\n     * then the lexicographic comparison is the result of comparing two\\n     * elements of type {@code T} at a relative index {@code i} within the\\n     * respective arrays that is the prefix length, as if by:\\n     * \u003cpre\u003e{@code\\n     *     Comparator.nullsFirst(Comparator.\u003cT\u003enaturalOrder()).\\n     *         compare(a[aFromIndex + i, b[bFromIndex + i])\\n     * }\u003c/pre\u003e\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two range lengths.\\n     * (See {@link #mismatch(Object[], int, int, Object[], int, int)} for the\\n     * definition of a common and proper prefix.)\\n     *\\n     * \u003cp\u003eThe comparison is consistent with\\n     * {@link #equals(Object[], int, int, Object[], int, int) equals}, more\\n     * specifically the following holds for arrays {@code a} and {@code b} with\\n     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively:\\n     * \u003cpre\u003e{@code\\n     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\\n     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\\n     * }\u003c/pre\u003e\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if (for non-{@code null} array elements):\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\\n     *                             b, bFromIndex, bToIndex);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\\n     *         return a[aFromIndex + i].compareTo(b[bFromIndex + i]);\\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be compared\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be compared\\n     * @param b the second array to compare\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be compared\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be compared\\n     * @param \u003cT\u003e the type of comparable array elements\\n     * @return the value {@code 0} if, over the specified ranges, the first and\\n     *         second array are equal and contain the same elements in the same\\n     *         order;\\n     *         a value less than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically greater than the second array\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int compare(T[] a, T[] b, Comparator\u003c? super T\u003e cmp)", "label": "public static int compare(T[] a, T[] b, Comparator\u003c? super T\u003e cmp)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code Object} arrays lexicographically using a specified\\n     * comparator.\\n     *\\n     * \u003cp\u003eIf the two arrays share a common prefix then the lexicographic\\n     * comparison is the result of comparing with the specified comparator two\\n     * elements at an index within the respective arrays that is the prefix\\n     * length.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two array lengths.\\n     * (See {@link #mismatch(Object[], Object[])} for the definition of a common\\n     * and proper prefix.)\\n     *\\n     * \u003cp\u003eA {@code null} array reference is considered lexicographically less\\n     * than a non-{@code null} array reference.  Two {@code null} array\\n     * references are considered equal.\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if (for non-{@code null} array references):\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, b, cmp);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(a.length, b.length))\\n     *         return cmp.compare(a[i], b[i]);\\n     *     return a.length - b.length;\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param b the second array to compare\\n     * @param cmp the comparator to compare array elements\\n     * @param \u003cT\u003e the type of array elements\\n     * @return the value {@code 0} if the first and second array are equal and\\n     *         contain the same elements in the same order;\\n     *         a value less than {@code 0} if the first array is\\n     *         lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if the first array is\\n     *         lexicographically greater than the second array\\n     * @throws NullPointerException if the comparator is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int compare(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator\u003c? super T\u003e cmp)", "label": "public static int compare(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator\u003c? super T\u003e cmp)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Compares two {@code Object} arrays lexicographically over the specified\\n     * ranges.\\n     *\\n     * \u003cp\u003eIf the two arrays, over the specified ranges, share a common prefix\\n     * then the lexicographic comparison is the result of comparing with the\\n     * specified comparator two elements at a relative index within the\\n     * respective arrays that is the prefix length.\\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\\n     * comparison is the result of comparing the two range lengths.\\n     * (See {@link #mismatch(Object[], int, int, Object[], int, int)} for the\\n     * definition of a common and proper prefix.)\\n     *\\n     * @apiNote\\n     * \u003cp\u003eThis method behaves as if (for non-{@code null} array elements):\\n     * \u003cpre\u003e{@code\\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\\n     *                             b, bFromIndex, bToIndex, cmp);\\n     *     if (i \u003e= 0 \u0026\u0026 i \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\\n     *         return cmp.compare(a[aFromIndex + i], b[bFromIndex + i]);\\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to compare\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be compared\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be compared\\n     * @param b the second array to compare\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be compared\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be compared\\n     * @param cmp the comparator to compare array elements\\n     * @param \u003cT\u003e the type of array elements\\n     * @return the value {@code 0} if, over the specified ranges, the first and\\n     *         second array are equal and contain the same elements in the same\\n     *         order;\\n     *         a value less than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically less than the second array; and\\n     *         a value greater than {@code 0} if, over the specified ranges, the\\n     *         first array is lexicographically greater than the second array\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array or the comparator is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int mismatch(boolean[] a, boolean[] b)", "label": "public static int mismatch(boolean[] a, boolean[] b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Finds and returns the index of the first mismatch between two\\n     * {@code boolean} arrays, otherwise return -1 if no mismatch is found.  The\\n     * index will be in the range of 0 (inclusive) up to the length (inclusive)\\n     * of the smaller array.\\n     *\\n     * \u003cp\u003eIf the two arrays share a common prefix then the returned index is the\\n     * length of the common prefix and it follows that there is a mismatch\\n     * between the two elements at that index within the respective arrays.\\n     * If one array is a proper prefix of the other then the returned index is\\n     * the length of the smaller array and it follows that the index is only\\n     * valid for the larger array.\\n     * Otherwise, there is no mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b}, share a common\\n     * prefix of length {@code pl} if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     pl \u003e= 0 \u0026\u0026\\n     *     pl \u003c Math.min(a.length, b.length) \u0026\u0026\\n     *     Arrays.equals(a, 0, pl, b, 0, pl) \u0026\u0026\\n     *     a[pl] != b[pl]\\n     * }\u003c/pre\u003e\\n     * Note that a common prefix length of {@code 0} indicates that the first\\n     * elements from each array mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b}, share a proper\\n     * prefix if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     a.length != b.length \u0026\u0026\\n     *     Arrays.equals(a, 0, Math.min(a.length, b.length),\\n     *                   b, 0, Math.min(a.length, b.length))\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to be tested for a mismatch\\n     * @param b the second array to be tested for a mismatch\\n     * @return the index of the first mismatch between the two arrays,\\n     *         otherwise {@code -1}.\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int mismatch(boolean[] a, int aFromIndex, int aToIndex, boolean[] b, int bFromIndex, int bToIndex)", "label": "public static int mismatch(boolean[] a, int aFromIndex, int aToIndex, boolean[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Finds and returns the relative index of the first mismatch between two\\n     * {@code boolean} arrays over the specified ranges, otherwise return -1 if\\n     * no mismatch is found.  The index will be in the range of 0 (inclusive) up\\n     * to the length (inclusive) of the smaller range.\\n     *\\n     * \u003cp\u003eIf the two arrays, over the specified ranges, share a common prefix\\n     * then the returned relative index is the length of the common prefix and\\n     * it follows that there is a mismatch between the two elements at that\\n     * relative index within the respective arrays.\\n     * If one array is a proper prefix of the other, over the specified ranges,\\n     * then the returned relative index is the length of the smaller range and\\n     * it follows that the relative index is only valid for the array with the\\n     * larger range.\\n     * Otherwise, there is no mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b} with specified\\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common\\n     * prefix of length {@code pl} if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     pl \u003e= 0 \u0026\u0026\\n     *     pl \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) \u0026\u0026\\n     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) \u0026\u0026\\n     *     a[aFromIndex + pl] != b[bFromIndex + pl]\\n     * }\u003c/pre\u003e\\n     * Note that a common prefix length of {@code 0} indicates that the first\\n     * elements from each array mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b} with specified\\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper\\n     * prefix if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) \u0026\u0026\\n     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\\n     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to be tested for a mismatch\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be tested\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be tested\\n     * @param b the second array to be tested for a mismatch\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be tested\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be tested\\n     * @return the relative index of the first mismatch between the two arrays\\n     *         over the specified ranges, otherwise {@code -1}.\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int mismatch(byte[] a, byte[] b)", "label": "public static int mismatch(byte[] a, byte[] b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Finds and returns the index of the first mismatch between two {@code byte}\\n     * arrays, otherwise return -1 if no mismatch is found.  The index will be\\n     * in the range of 0 (inclusive) up to the length (inclusive) of the smaller\\n     * array.\\n     *\\n     * \u003cp\u003eIf the two arrays share a common prefix then the returned index is the\\n     * length of the common prefix and it follows that there is a mismatch\\n     * between the two elements at that index within the respective arrays.\\n     * If one array is a proper prefix of the other then the returned index is\\n     * the length of the smaller array and it follows that the index is only\\n     * valid for the larger array.\\n     * Otherwise, there is no mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b}, share a common\\n     * prefix of length {@code pl} if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     pl \u003e= 0 \u0026\u0026\\n     *     pl \u003c Math.min(a.length, b.length) \u0026\u0026\\n     *     Arrays.equals(a, 0, pl, b, 0, pl) \u0026\u0026\\n     *     a[pl] != b[pl]\\n     * }\u003c/pre\u003e\\n     * Note that a common prefix length of {@code 0} indicates that the first\\n     * elements from each array mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b}, share a proper\\n     * prefix if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     a.length != b.length \u0026\u0026\\n     *     Arrays.equals(a, 0, Math.min(a.length, b.length),\\n     *                   b, 0, Math.min(a.length, b.length))\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to be tested for a mismatch\\n     * @param b the second array to be tested for a mismatch\\n     * @return the index of the first mismatch between the two arrays,\\n     *         otherwise {@code -1}.\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int mismatch(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)", "label": "public static int mismatch(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Finds and returns the relative index of the first mismatch between two\\n     * {@code byte} arrays over the specified ranges, otherwise return -1 if no\\n     * mismatch is found.  The index will be in the range of 0 (inclusive) up to\\n     * the length (inclusive) of the smaller range.\\n     *\\n     * \u003cp\u003eIf the two arrays, over the specified ranges, share a common prefix\\n     * then the returned relative index is the length of the common prefix and\\n     * it follows that there is a mismatch between the two elements at that\\n     * relative index within the respective arrays.\\n     * If one array is a proper prefix of the other, over the specified ranges,\\n     * then the returned relative index is the length of the smaller range and\\n     * it follows that the relative index is only valid for the array with the\\n     * larger range.\\n     * Otherwise, there is no mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b} with specified\\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common\\n     * prefix of length {@code pl} if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     pl \u003e= 0 \u0026\u0026\\n     *     pl \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) \u0026\u0026\\n     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) \u0026\u0026\\n     *     a[aFromIndex + pl] != b[bFromIndex + pl]\\n     * }\u003c/pre\u003e\\n     * Note that a common prefix length of {@code 0} indicates that the first\\n     * elements from each array mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b} with specified\\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper\\n     * prefix if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) \u0026\u0026\\n     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\\n     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to be tested for a mismatch\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be tested\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be tested\\n     * @param b the second array to be tested for a mismatch\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be tested\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be tested\\n     * @return the relative index of the first mismatch between the two arrays\\n     *         over the specified ranges, otherwise {@code -1}.\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int mismatch(char[] a, char[] b)", "label": "public static int mismatch(char[] a, char[] b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Finds and returns the index of the first mismatch between two {@code char}\\n     * arrays, otherwise return -1 if no mismatch is found.  The index will be\\n     * in the range of 0 (inclusive) up to the length (inclusive) of the smaller\\n     * array.\\n     *\\n     * \u003cp\u003eIf the two arrays share a common prefix then the returned index is the\\n     * length of the common prefix and it follows that there is a mismatch\\n     * between the two elements at that index within the respective arrays.\\n     * If one array is a proper prefix of the other then the returned index is\\n     * the length of the smaller array and it follows that the index is only\\n     * valid for the larger array.\\n     * Otherwise, there is no mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b}, share a common\\n     * prefix of length {@code pl} if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     pl \u003e= 0 \u0026\u0026\\n     *     pl \u003c Math.min(a.length, b.length) \u0026\u0026\\n     *     Arrays.equals(a, 0, pl, b, 0, pl) \u0026\u0026\\n     *     a[pl] != b[pl]\\n     * }\u003c/pre\u003e\\n     * Note that a common prefix length of {@code 0} indicates that the first\\n     * elements from each array mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b}, share a proper\\n     * prefix if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     a.length != b.length \u0026\u0026\\n     *     Arrays.equals(a, 0, Math.min(a.length, b.length),\\n     *                   b, 0, Math.min(a.length, b.length))\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to be tested for a mismatch\\n     * @param b the second array to be tested for a mismatch\\n     * @return the index of the first mismatch between the two arrays,\\n     *         otherwise {@code -1}.\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int mismatch(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex)", "label": "public static int mismatch(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Finds and returns the relative index of the first mismatch between two\\n     * {@code char} arrays over the specified ranges, otherwise return -1 if no\\n     * mismatch is found.  The index will be in the range of 0 (inclusive) up to\\n     * the length (inclusive) of the smaller range.\\n     *\\n     * \u003cp\u003eIf the two arrays, over the specified ranges, share a common prefix\\n     * then the returned relative index is the length of the common prefix and\\n     * it follows that there is a mismatch between the two elements at that\\n     * relative index within the respective arrays.\\n     * If one array is a proper prefix of the other, over the specified ranges,\\n     * then the returned relative index is the length of the smaller range and\\n     * it follows that the relative index is only valid for the array with the\\n     * larger range.\\n     * Otherwise, there is no mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b} with specified\\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common\\n     * prefix of length {@code pl} if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     pl \u003e= 0 \u0026\u0026\\n     *     pl \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) \u0026\u0026\\n     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) \u0026\u0026\\n     *     a[aFromIndex + pl] != b[bFromIndex + pl]\\n     * }\u003c/pre\u003e\\n     * Note that a common prefix length of {@code 0} indicates that the first\\n     * elements from each array mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b} with specified\\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper\\n     * prefix if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) \u0026\u0026\\n     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\\n     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to be tested for a mismatch\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be tested\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be tested\\n     * @param b the second array to be tested for a mismatch\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be tested\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be tested\\n     * @return the relative index of the first mismatch between the two arrays\\n     *         over the specified ranges, otherwise {@code -1}.\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int mismatch(short[] a, short[] b)", "label": "public static int mismatch(short[] a, short[] b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Finds and returns the index of the first mismatch between two {@code short}\\n     * arrays, otherwise return -1 if no mismatch is found.  The index will be\\n     * in the range of 0 (inclusive) up to the length (inclusive) of the smaller\\n     * array.\\n     *\\n     * \u003cp\u003eIf the two arrays share a common prefix then the returned index is the\\n     * length of the common prefix and it follows that there is a mismatch\\n     * between the two elements at that index within the respective arrays.\\n     * If one array is a proper prefix of the other then the returned index is\\n     * the length of the smaller array and it follows that the index is only\\n     * valid for the larger array.\\n     * Otherwise, there is no mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b}, share a common\\n     * prefix of length {@code pl} if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     pl \u003e= 0 \u0026\u0026\\n     *     pl \u003c Math.min(a.length, b.length) \u0026\u0026\\n     *     Arrays.equals(a, 0, pl, b, 0, pl) \u0026\u0026\\n     *     a[pl] != b[pl]\\n     * }\u003c/pre\u003e\\n     * Note that a common prefix length of {@code 0} indicates that the first\\n     * elements from each array mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b}, share a proper\\n     * prefix if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     a.length != b.length \u0026\u0026\\n     *     Arrays.equals(a, 0, Math.min(a.length, b.length),\\n     *                   b, 0, Math.min(a.length, b.length))\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to be tested for a mismatch\\n     * @param b the second array to be tested for a mismatch\\n     * @return the index of the first mismatch between the two arrays,\\n     *         otherwise {@code -1}.\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int mismatch(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)", "label": "public static int mismatch(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Finds and returns the relative index of the first mismatch between two\\n     * {@code short} arrays over the specified ranges, otherwise return -1 if no\\n     * mismatch is found.  The index will be in the range of 0 (inclusive) up to\\n     * the length (inclusive) of the smaller range.\\n     *\\n     * \u003cp\u003eIf the two arrays, over the specified ranges, share a common prefix\\n     * then the returned relative index is the length of the common prefix and\\n     * it follows that there is a mismatch between the two elements at that\\n     * relative index within the respective arrays.\\n     * If one array is a proper prefix of the other, over the specified ranges,\\n     * then the returned relative index is the length of the smaller range and\\n     * it follows that the relative index is only valid for the array with the\\n     * larger range.\\n     * Otherwise, there is no mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b} with specified\\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common\\n     * prefix of length {@code pl} if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     pl \u003e= 0 \u0026\u0026\\n     *     pl \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) \u0026\u0026\\n     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) \u0026\u0026\\n     *     a[aFromIndex + pl] != b[bFromIndex + pl]\\n     * }\u003c/pre\u003e\\n     * Note that a common prefix length of {@code 0} indicates that the first\\n     * elements from each array mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b} with specified\\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper\\n     * prefix if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) \u0026\u0026\\n     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\\n     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to be tested for a mismatch\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be tested\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be tested\\n     * @param b the second array to be tested for a mismatch\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be tested\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be tested\\n     * @return the relative index of the first mismatch between the two arrays\\n     *         over the specified ranges, otherwise {@code -1}.\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int mismatch(int[] a, int[] b)", "label": "public static int mismatch(int[] a, int[] b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Finds and returns the index of the first mismatch between two {@code int}\\n     * arrays, otherwise return -1 if no mismatch is found.  The index will be\\n     * in the range of 0 (inclusive) up to the length (inclusive) of the smaller\\n     * array.\\n     *\\n     * \u003cp\u003eIf the two arrays share a common prefix then the returned index is the\\n     * length of the common prefix and it follows that there is a mismatch\\n     * between the two elements at that index within the respective arrays.\\n     * If one array is a proper prefix of the other then the returned index is\\n     * the length of the smaller array and it follows that the index is only\\n     * valid for the larger array.\\n     * Otherwise, there is no mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b}, share a common\\n     * prefix of length {@code pl} if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     pl \u003e= 0 \u0026\u0026\\n     *     pl \u003c Math.min(a.length, b.length) \u0026\u0026\\n     *     Arrays.equals(a, 0, pl, b, 0, pl) \u0026\u0026\\n     *     a[pl] != b[pl]\\n     * }\u003c/pre\u003e\\n     * Note that a common prefix length of {@code 0} indicates that the first\\n     * elements from each array mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b}, share a proper\\n     * prefix if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     a.length != b.length \u0026\u0026\\n     *     Arrays.equals(a, 0, Math.min(a.length, b.length),\\n     *                   b, 0, Math.min(a.length, b.length))\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to be tested for a mismatch\\n     * @param b the second array to be tested for a mismatch\\n     * @return the index of the first mismatch between the two arrays,\\n     *         otherwise {@code -1}.\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int mismatch(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)", "label": "public static int mismatch(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Finds and returns the relative index of the first mismatch between two\\n     * {@code int} arrays over the specified ranges, otherwise return -1 if no\\n     * mismatch is found.  The index will be in the range of 0 (inclusive) up to\\n     * the length (inclusive) of the smaller range.\\n     *\\n     * \u003cp\u003eIf the two arrays, over the specified ranges, share a common prefix\\n     * then the returned relative index is the length of the common prefix and\\n     * it follows that there is a mismatch between the two elements at that\\n     * relative index within the respective arrays.\\n     * If one array is a proper prefix of the other, over the specified ranges,\\n     * then the returned relative index is the length of the smaller range and\\n     * it follows that the relative index is only valid for the array with the\\n     * larger range.\\n     * Otherwise, there is no mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b} with specified\\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common\\n     * prefix of length {@code pl} if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     pl \u003e= 0 \u0026\u0026\\n     *     pl \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) \u0026\u0026\\n     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) \u0026\u0026\\n     *     a[aFromIndex + pl] != b[bFromIndex + pl]\\n     * }\u003c/pre\u003e\\n     * Note that a common prefix length of {@code 0} indicates that the first\\n     * elements from each array mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b} with specified\\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper\\n     * prefix if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) \u0026\u0026\\n     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\\n     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to be tested for a mismatch\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be tested\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be tested\\n     * @param b the second array to be tested for a mismatch\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be tested\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be tested\\n     * @return the relative index of the first mismatch between the two arrays\\n     *         over the specified ranges, otherwise {@code -1}.\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int mismatch(long[] a, long[] b)", "label": "public static int mismatch(long[] a, long[] b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Finds and returns the index of the first mismatch between two {@code long}\\n     * arrays, otherwise return -1 if no mismatch is found.  The index will be\\n     * in the range of 0 (inclusive) up to the length (inclusive) of the smaller\\n     * array.\\n     *\\n     * \u003cp\u003eIf the two arrays share a common prefix then the returned index is the\\n     * length of the common prefix and it follows that there is a mismatch\\n     * between the two elements at that index within the respective arrays.\\n     * If one array is a proper prefix of the other then the returned index is\\n     * the length of the smaller array and it follows that the index is only\\n     * valid for the larger array.\\n     * Otherwise, there is no mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b}, share a common\\n     * prefix of length {@code pl} if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     pl \u003e= 0 \u0026\u0026\\n     *     pl \u003c Math.min(a.length, b.length) \u0026\u0026\\n     *     Arrays.equals(a, 0, pl, b, 0, pl) \u0026\u0026\\n     *     a[pl] != b[pl]\\n     * }\u003c/pre\u003e\\n     * Note that a common prefix length of {@code 0} indicates that the first\\n     * elements from each array mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b}, share a proper\\n     * prefix if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     a.length != b.length \u0026\u0026\\n     *     Arrays.equals(a, 0, Math.min(a.length, b.length),\\n     *                   b, 0, Math.min(a.length, b.length))\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to be tested for a mismatch\\n     * @param b the second array to be tested for a mismatch\\n     * @return the index of the first mismatch between the two arrays,\\n     *         otherwise {@code -1}.\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int mismatch(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)", "label": "public static int mismatch(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Finds and returns the relative index of the first mismatch between two\\n     * {@code long} arrays over the specified ranges, otherwise return -1 if no\\n     * mismatch is found.  The index will be in the range of 0 (inclusive) up to\\n     * the length (inclusive) of the smaller range.\\n     *\\n     * \u003cp\u003eIf the two arrays, over the specified ranges, share a common prefix\\n     * then the returned relative index is the length of the common prefix and\\n     * it follows that there is a mismatch between the two elements at that\\n     * relative index within the respective arrays.\\n     * If one array is a proper prefix of the other, over the specified ranges,\\n     * then the returned relative index is the length of the smaller range and\\n     * it follows that the relative index is only valid for the array with the\\n     * larger range.\\n     * Otherwise, there is no mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b} with specified\\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common\\n     * prefix of length {@code pl} if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     pl \u003e= 0 \u0026\u0026\\n     *     pl \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) \u0026\u0026\\n     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) \u0026\u0026\\n     *     a[aFromIndex + pl] != b[bFromIndex + pl]\\n     * }\u003c/pre\u003e\\n     * Note that a common prefix length of {@code 0} indicates that the first\\n     * elements from each array mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b} with specified\\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper\\n     * prefix if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) \u0026\u0026\\n     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\\n     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to be tested for a mismatch\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be tested\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be tested\\n     * @param b the second array to be tested for a mismatch\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be tested\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be tested\\n     * @return the relative index of the first mismatch between the two arrays\\n     *         over the specified ranges, otherwise {@code -1}.\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int mismatch(float[] a, float[] b)", "label": "public static int mismatch(float[] a, float[] b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Finds and returns the index of the first mismatch between two {@code float}\\n     * arrays, otherwise return -1 if no mismatch is found.  The index will be\\n     * in the range of 0 (inclusive) up to the length (inclusive) of the smaller\\n     * array.\\n     *\\n     * \u003cp\u003eIf the two arrays share a common prefix then the returned index is the\\n     * length of the common prefix and it follows that there is a mismatch\\n     * between the two elements at that index within the respective arrays.\\n     * If one array is a proper prefix of the other then the returned index is\\n     * the length of the smaller array and it follows that the index is only\\n     * valid for the larger array.\\n     * Otherwise, there is no mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b}, share a common\\n     * prefix of length {@code pl} if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     pl \u003e= 0 \u0026\u0026\\n     *     pl \u003c Math.min(a.length, b.length) \u0026\u0026\\n     *     Arrays.equals(a, 0, pl, b, 0, pl) \u0026\u0026\\n     *     Float.compare(a[pl], b[pl]) != 0\\n     * }\u003c/pre\u003e\\n     * Note that a common prefix length of {@code 0} indicates that the first\\n     * elements from each array mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b}, share a proper\\n     * prefix if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     a.length != b.length \u0026\u0026\\n     *     Arrays.equals(a, 0, Math.min(a.length, b.length),\\n     *                   b, 0, Math.min(a.length, b.length))\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to be tested for a mismatch\\n     * @param b the second array to be tested for a mismatch\\n     * @return the index of the first mismatch between the two arrays,\\n     *         otherwise {@code -1}.\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int mismatch(float[] a, int aFromIndex, int aToIndex, float[] b, int bFromIndex, int bToIndex)", "label": "public static int mismatch(float[] a, int aFromIndex, int aToIndex, float[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Finds and returns the relative index of the first mismatch between two\\n     * {@code float} arrays over the specified ranges, otherwise return -1 if no\\n     * mismatch is found.  The index will be in the range of 0 (inclusive) up to\\n     * the length (inclusive) of the smaller range.\\n     *\\n     * \u003cp\u003eIf the two arrays, over the specified ranges, share a common prefix\\n     * then the returned relative index is the length of the common prefix and\\n     * it follows that there is a mismatch between the two elements at that\\n     * relative index within the respective arrays.\\n     * If one array is a proper prefix of the other, over the specified ranges,\\n     * then the returned relative index is the length of the smaller range and\\n     * it follows that the relative index is only valid for the array with the\\n     * larger range.\\n     * Otherwise, there is no mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b} with specified\\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common\\n     * prefix of length {@code pl} if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     pl \u003e= 0 \u0026\u0026\\n     *     pl \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) \u0026\u0026\\n     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) \u0026\u0026\\n     *     Float.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0\\n     * }\u003c/pre\u003e\\n     * Note that a common prefix length of {@code 0} indicates that the first\\n     * elements from each array mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b} with specified\\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper\\n     * prefix if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) \u0026\u0026\\n     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\\n     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to be tested for a mismatch\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be tested\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be tested\\n     * @param b the second array to be tested for a mismatch\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be tested\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be tested\\n     * @return the relative index of the first mismatch between the two arrays\\n     *         over the specified ranges, otherwise {@code -1}.\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int mismatch(double[] a, double[] b)", "label": "public static int mismatch(double[] a, double[] b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Finds and returns the index of the first mismatch between two\\n     * {@code double} arrays, otherwise return -1 if no mismatch is found.  The\\n     * index will be in the range of 0 (inclusive) up to the length (inclusive)\\n     * of the smaller array.\\n     *\\n     * \u003cp\u003eIf the two arrays share a common prefix then the returned index is the\\n     * length of the common prefix and it follows that there is a mismatch\\n     * between the two elements at that index within the respective arrays.\\n     * If one array is a proper prefix of the other then the returned index is\\n     * the length of the smaller array and it follows that the index is only\\n     * valid for the larger array.\\n     * Otherwise, there is no mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b}, share a common\\n     * prefix of length {@code pl} if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     pl \u003e= 0 \u0026\u0026\\n     *     pl \u003c Math.min(a.length, b.length) \u0026\u0026\\n     *     Arrays.equals(a, 0, pl, b, 0, pl) \u0026\u0026\\n     *     Double.compare(a[pl], b[pl]) != 0\\n     * }\u003c/pre\u003e\\n     * Note that a common prefix length of {@code 0} indicates that the first\\n     * elements from each array mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b}, share a proper\\n     * prefix if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     a.length != b.length \u0026\u0026\\n     *     Arrays.equals(a, 0, Math.min(a.length, b.length),\\n     *                   b, 0, Math.min(a.length, b.length))\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to be tested for a mismatch\\n     * @param b the second array to be tested for a mismatch\\n     * @return the index of the first mismatch between the two arrays,\\n     *         otherwise {@code -1}.\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int mismatch(double[] a, int aFromIndex, int aToIndex, double[] b, int bFromIndex, int bToIndex)", "label": "public static int mismatch(double[] a, int aFromIndex, int aToIndex, double[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Finds and returns the relative index of the first mismatch between two\\n     * {@code double} arrays over the specified ranges, otherwise return -1 if\\n     * no mismatch is found.  The index will be in the range of 0 (inclusive) up\\n     * to the length (inclusive) of the smaller range.\\n     *\\n     * \u003cp\u003eIf the two arrays, over the specified ranges, share a common prefix\\n     * then the returned relative index is the length of the common prefix and\\n     * it follows that there is a mismatch between the two elements at that\\n     * relative index within the respective arrays.\\n     * If one array is a proper prefix of the other, over the specified ranges,\\n     * then the returned relative index is the length of the smaller range and\\n     * it follows that the relative index is only valid for the array with the\\n     * larger range.\\n     * Otherwise, there is no mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b} with specified\\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common\\n     * prefix of length {@code pl} if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     pl \u003e= 0 \u0026\u0026\\n     *     pl \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) \u0026\u0026\\n     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) \u0026\u0026\\n     *     Double.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0\\n     * }\u003c/pre\u003e\\n     * Note that a common prefix length of {@code 0} indicates that the first\\n     * elements from each array mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b} with specified\\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper\\n     * prefix if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) \u0026\u0026\\n     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\\n     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to be tested for a mismatch\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be tested\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be tested\\n     * @param b the second array to be tested for a mismatch\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be tested\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be tested\\n     * @return the relative index of the first mismatch between the two arrays\\n     *         over the specified ranges, otherwise {@code -1}.\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int mismatch(Object[] a, Object[] b)", "label": "public static int mismatch(Object[] a, Object[] b)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Finds and returns the index of the first mismatch between two\\n     * {@code Object} arrays, otherwise return -1 if no mismatch is found.  The\\n     * index will be in the range of 0 (inclusive) up to the length (inclusive)\\n     * of the smaller array.\\n     *\\n     * \u003cp\u003eIf the two arrays share a common prefix then the returned index is the\\n     * length of the common prefix and it follows that there is a mismatch\\n     * between the two elements at that index within the respective arrays.\\n     * If one array is a proper prefix of the other then the returned index is\\n     * the length of the smaller array and it follows that the index is only\\n     * valid for the larger array.\\n     * Otherwise, there is no mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b}, share a common\\n     * prefix of length {@code pl} if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     pl \u003e= 0 \u0026\u0026\\n     *     pl \u003c Math.min(a.length, b.length) \u0026\u0026\\n     *     Arrays.equals(a, 0, pl, b, 0, pl) \u0026\u0026\\n     *     !Objects.equals(a[pl], b[pl])\\n     * }\u003c/pre\u003e\\n     * Note that a common prefix length of {@code 0} indicates that the first\\n     * elements from each array mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b}, share a proper\\n     * prefix if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     a.length != b.length \u0026\u0026\\n     *     Arrays.equals(a, 0, Math.min(a.length, b.length),\\n     *                   b, 0, Math.min(a.length, b.length))\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to be tested for a mismatch\\n     * @param b the second array to be tested for a mismatch\\n     * @return the index of the first mismatch between the two arrays,\\n     *         otherwise {@code -1}.\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int mismatch(Object[] a, int aFromIndex, int aToIndex, Object[] b, int bFromIndex, int bToIndex)", "label": "public static int mismatch(Object[] a, int aFromIndex, int aToIndex, Object[] b, int bFromIndex, int bToIndex)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Finds and returns the relative index of the first mismatch between two\\n     * {@code Object} arrays over the specified ranges, otherwise return -1 if\\n     * no mismatch is found.  The index will be in the range of 0 (inclusive) up\\n     * to the length (inclusive) of the smaller range.\\n     *\\n     * \u003cp\u003eIf the two arrays, over the specified ranges, share a common prefix\\n     * then the returned relative index is the length of the common prefix and\\n     * it follows that there is a mismatch between the two elements at that\\n     * relative index within the respective arrays.\\n     * If one array is a proper prefix of the other, over the specified ranges,\\n     * then the returned relative index is the length of the smaller range and\\n     * it follows that the relative index is only valid for the array with the\\n     * larger range.\\n     * Otherwise, there is no mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b} with specified\\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common\\n     * prefix of length {@code pl} if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     pl \u003e= 0 \u0026\u0026\\n     *     pl \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) \u0026\u0026\\n     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) \u0026\u0026\\n     *     !Objects.equals(a[aFromIndex + pl], b[bFromIndex + pl])\\n     * }\u003c/pre\u003e\\n     * Note that a common prefix length of {@code 0} indicates that the first\\n     * elements from each array mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b} with specified\\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper\\n     * prefix if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) \u0026\u0026\\n     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\\n     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to be tested for a mismatch\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be tested\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be tested\\n     * @param b the second array to be tested for a mismatch\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be tested\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be tested\\n     * @return the relative index of the first mismatch between the two arrays\\n     *         over the specified ranges, otherwise {@code -1}.\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int mismatch(T[] a, T[] b, Comparator\u003c? super T\u003e cmp)", "label": "public static int mismatch(T[] a, T[] b, Comparator\u003c? super T\u003e cmp)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Finds and returns the index of the first mismatch between two\\n     * {@code Object} arrays, otherwise return -1 if no mismatch is found.\\n     * The index will be in the range of 0 (inclusive) up to the length\\n     * (inclusive) of the smaller array.\\n     *\\n     * \u003cp\u003eThe specified comparator is used to determine if two array elements\\n     * from the each array are not equal.\\n     *\\n     * \u003cp\u003eIf the two arrays share a common prefix then the returned index is the\\n     * length of the common prefix and it follows that there is a mismatch\\n     * between the two elements at that index within the respective arrays.\\n     * If one array is a proper prefix of the other then the returned index is\\n     * the length of the smaller array and it follows that the index is only\\n     * valid for the larger array.\\n     * Otherwise, there is no mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b}, share a common\\n     * prefix of length {@code pl} if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     pl \u003e= 0 \u0026\u0026\\n     *     pl \u003c Math.min(a.length, b.length) \u0026\u0026\\n     *     Arrays.equals(a, 0, pl, b, 0, pl, cmp)\\n     *     cmp.compare(a[pl], b[pl]) != 0\\n     * }\u003c/pre\u003e\\n     * Note that a common prefix length of {@code 0} indicates that the first\\n     * elements from each array mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b}, share a proper\\n     * prefix if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     a.length != b.length \u0026\u0026\\n     *     Arrays.equals(a, 0, Math.min(a.length, b.length),\\n     *                   b, 0, Math.min(a.length, b.length),\\n     *                   cmp)\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to be tested for a mismatch\\n     * @param b the second array to be tested for a mismatch\\n     * @param cmp the comparator to compare array elements\\n     * @param \u003cT\u003e the type of array elements\\n     * @return the index of the first mismatch between the two arrays,\\n     *         otherwise {@code -1}.\\n     * @throws NullPointerException\\n     *         if either array or the comparator is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static int mismatch(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator\u003c? super T\u003e cmp)", "label": "public static int mismatch(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator\u003c? super T\u003e cmp)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Finds and returns the relative index of the first mismatch between two\\n     * {@code Object} arrays over the specified ranges, otherwise return -1 if\\n     * no mismatch is found.  The index will be in the range of 0 (inclusive) up\\n     * to the length (inclusive) of the smaller range.\\n     *\\n     * \u003cp\u003eIf the two arrays, over the specified ranges, share a common prefix\\n     * then the returned relative index is the length of the common prefix and\\n     * it follows that there is a mismatch between the two elements at that\\n     * relative index within the respective arrays.\\n     * If one array is a proper prefix of the other, over the specified ranges,\\n     * then the returned relative index is the length of the smaller range and\\n     * it follows that the relative index is only valid for the array with the\\n     * larger range.\\n     * Otherwise, there is no mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b} with specified\\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common\\n     * prefix of length {@code pl} if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     pl \u003e= 0 \u0026\u0026\\n     *     pl \u003c Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) \u0026\u0026\\n     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl, cmp) \u0026\u0026\\n     *     cmp.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0\\n     * }\u003c/pre\u003e\\n     * Note that a common prefix length of {@code 0} indicates that the first\\n     * elements from each array mismatch.\\n     *\\n     * \u003cp\u003eTwo non-{@code null} arrays, {@code a} and {@code b} with specified\\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper\\n     * prefix if the following expression is true:\\n     * \u003cpre\u003e{@code\\n     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) \u0026\u0026\\n     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\\n     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\\n     *                   cmp)\\n     * }\u003c/pre\u003e\\n     *\\n     * @param a the first array to be tested for a mismatch\\n     * @param aFromIndex the index (inclusive) of the first element in the\\n     *                   first array to be tested\\n     * @param aToIndex the index (exclusive) of the last element in the\\n     *                 first array to be tested\\n     * @param b the second array to be tested for a mismatch\\n     * @param bFromIndex the index (inclusive) of the first element in the\\n     *                   second array to be tested\\n     * @param bToIndex the index (exclusive) of the last element in the\\n     *                 second array to be tested\\n     * @param cmp the comparator to compare array elements\\n     * @param \u003cT\u003e the type of array elements\\n     * @return the relative index of the first mismatch between the two arrays\\n     *         over the specified ranges, otherwise {@code -1}.\\n     * @throws IllegalArgumentException\\n     *         if {@code aFromIndex \u003e aToIndex} or\\n     *         if {@code bFromIndex \u003e bToIndex}\\n     * @throws ArrayIndexOutOfBoundsException\\n     *         if {@code aFromIndex \u003c 0 or aToIndex \u003e a.length} or\\n     *         if {@code bFromIndex \u003c 0 or bToIndex \u003e b.length}\\n     * @throws NullPointerException\\n     *         if either array or the comparator is {@code null}\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Spliterator\u003cT\u003e spliterator(Object[] array, int fromIndex, int toIndex, int additionalCharacteristics)", "label": "public static Spliterator\u003cT\u003e spliterator(Object[] array, int fromIndex, int toIndex, int additionalCharacteristics)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a {@code Spliterator} covering a range of elements of a given\\n     * array, using a customized set of spliterator characteristics.\\n     *\\n     * \u003cp\u003eThis method is provided as an implementation convenience for\\n     * Spliterators which store portions of their elements in arrays, and need\\n     * fine control over Spliterator characteristics.  Most other situations in\\n     * which a Spliterator for an array is needed should use\\n     * {@link Arrays#spliterator(Object[])}.\\n     *\\n     * \u003cp\u003eThe returned spliterator always reports the characteristics\\n     * {@code SIZED} and {@code SUBSIZED}.  The caller may provide additional\\n     * characteristics for the spliterator to report; it is common to\\n     * additionally specify {@code IMMUTABLE} and {@code ORDERED}.\\n     *\\n     * @param \u003cT\u003e Type of elements\\n     * @param array The array, assumed to be unmodified during use\\n     * @param fromIndex The least index (inclusive) to cover\\n     * @param toIndex One past the greatest index to cover\\n     * @param additionalCharacteristics Additional spliterator characteristics\\n     *        of this spliterator\u0027s source or elements beyond {@code SIZED} and\\n     *        {@code SUBSIZED} which are always reported\\n     * @return A spliterator for an array\\n     * @throws NullPointerException if the given array is {@code null}\\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex} is negative,\\n     *         {@code toIndex} is less than {@code fromIndex}, or\\n     *         {@code toIndex} is greater than the array size\\n     * @see Arrays#spliterator(Object[], int, int)\\n     \"}"}, {"color": "#97c2fc", "id": "public static Spliterator.OfInt spliterator(int[] array, int additionalCharacteristics)", "label": "public static Spliterator.OfInt spliterator(int[] array, int additionalCharacteristics)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a {@code Spliterator.OfInt} covering the elements of a given array,\\n     * using a customized set of spliterator characteristics.\\n     *\\n     * \u003cp\u003eThis method is provided as an implementation convenience for\\n     * Spliterators which store portions of their elements in arrays, and need\\n     * fine control over Spliterator characteristics.  Most other situations in\\n     * which a Spliterator for an array is needed should use\\n     * {@link Arrays#spliterator(int[])}.\\n     *\\n     * \u003cp\u003eThe returned spliterator always reports the characteristics\\n     * {@code SIZED} and {@code SUBSIZED}.  The caller may provide additional\\n     * characteristics for the spliterator to report; it is common to\\n     * additionally specify {@code IMMUTABLE} and {@code ORDERED}.\\n     *\\n     * @param array The array, assumed to be unmodified during use\\n     * @param additionalCharacteristics Additional spliterator characteristics\\n     *        of this spliterator\u0027s source or elements beyond {@code SIZED} and\\n     *        {@code SUBSIZED} which are always reported\\n     * @return A spliterator for an array\\n     * @throws NullPointerException if the given array is {@code null}\\n     * @see Arrays#spliterator(int[])\\n     \"}"}, {"color": "#97c2fc", "id": "public static Spliterator.OfInt spliterator(int[] array, int fromIndex, int toIndex, int additionalCharacteristics)", "label": "public static Spliterator.OfInt spliterator(int[] array, int fromIndex, int toIndex, int additionalCharacteristics)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a {@code Spliterator.OfInt} covering a range of elements of a\\n     * given array, using a customized set of spliterator characteristics.\\n     *\\n     * \u003cp\u003eThis method is provided as an implementation convenience for\\n     * Spliterators which store portions of their elements in arrays, and need\\n     * fine control over Spliterator characteristics.  Most other situations in\\n     * which a Spliterator for an array is needed should use\\n     * {@link Arrays#spliterator(int[], int, int)}.\\n     *\\n     * \u003cp\u003eThe returned spliterator always reports the characteristics\\n     * {@code SIZED} and {@code SUBSIZED}.  The caller may provide additional\\n     * characteristics for the spliterator to report; it is common to\\n     * additionally specify {@code IMMUTABLE} and {@code ORDERED}.\\n     *\\n     * @param array The array, assumed to be unmodified during use\\n     * @param fromIndex The least index (inclusive) to cover\\n     * @param toIndex One past the greatest index to cover\\n     * @param additionalCharacteristics Additional spliterator characteristics\\n     *        of this spliterator\u0027s source or elements beyond {@code SIZED} and\\n     *        {@code SUBSIZED} which are always reported\\n     * @return A spliterator for an array\\n     * @throws NullPointerException if the given array is {@code null}\\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex} is negative,\\n     *         {@code toIndex} is less than {@code fromIndex}, or\\n     *         {@code toIndex} is greater than the array size\\n     * @see Arrays#spliterator(int[], int, int)\\n     \"}"}, {"color": "#97c2fc", "id": "public static Spliterator.OfLong spliterator(long[] array, int additionalCharacteristics)", "label": "public static Spliterator.OfLong spliterator(long[] array, int additionalCharacteristics)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a {@code Spliterator.OfLong} covering the elements of a given array,\\n     * using a customized set of spliterator characteristics.\\n     *\\n     * \u003cp\u003eThis method is provided as an implementation convenience for\\n     * Spliterators which store portions of their elements in arrays, and need\\n     * fine control over Spliterator characteristics.  Most other situations in\\n     * which a Spliterator for an array is needed should use\\n     * {@link Arrays#spliterator(long[])}.\\n     *\\n     * \u003cp\u003eThe returned spliterator always reports the characteristics\\n     * {@code SIZED} and {@code SUBSIZED}.  The caller may provide additional\\n     * characteristics for the spliterator to report; it is common to\\n     * additionally specify {@code IMMUTABLE} and {@code ORDERED}.\\n     *\\n     * @param array The array, assumed to be unmodified during use\\n     * @param additionalCharacteristics Additional spliterator characteristics\\n     *        of this spliterator\u0027s source or elements beyond {@code SIZED} and\\n     *        {@code SUBSIZED} which are always reported\\n     * @return A spliterator for an array\\n     * @throws NullPointerException if the given array is {@code null}\\n     * @see Arrays#spliterator(long[])\\n     \"}"}, {"color": "#97c2fc", "id": "public static Spliterator.OfLong spliterator(long[] array, int fromIndex, int toIndex, int additionalCharacteristics)", "label": "public static Spliterator.OfLong spliterator(long[] array, int fromIndex, int toIndex, int additionalCharacteristics)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a {@code Spliterator.OfLong} covering a range of elements of a\\n     * given array, using a customized set of spliterator characteristics.\\n     *\\n     * \u003cp\u003eThis method is provided as an implementation convenience for\\n     * Spliterators which store portions of their elements in arrays, and need\\n     * fine control over Spliterator characteristics.  Most other situations in\\n     * which a Spliterator for an array is needed should use\\n     * {@link Arrays#spliterator(long[], int, int)}.\\n     *\\n     * \u003cp\u003eThe returned spliterator always reports the characteristics\\n     * {@code SIZED} and {@code SUBSIZED}.  The caller may provide additional\\n     * characteristics for the spliterator to report.  (For example, if it is\\n     * known the array will not be further modified, specify {@code IMMUTABLE};\\n     * if the array data is considered to have an encounter order, specify\\n     * {@code ORDERED}).  The method {@link Arrays#spliterator(long[], int, int)} can\\n     * often be used instead, which returns a spliterator that reports\\n     * {@code SIZED}, {@code SUBSIZED}, {@code IMMUTABLE}, and {@code ORDERED}.\\n     *\\n     * @param array The array, assumed to be unmodified during use\\n     * @param fromIndex The least index (inclusive) to cover\\n     * @param toIndex One past the greatest index to cover\\n     * @param additionalCharacteristics Additional spliterator characteristics\\n     *        of this spliterator\u0027s source or elements beyond {@code SIZED} and\\n     *        {@code SUBSIZED} which are always reported\\n     * @return A spliterator for an array\\n     * @throws NullPointerException if the given array is {@code null}\\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex} is negative,\\n     *         {@code toIndex} is less than {@code fromIndex}, or\\n     *         {@code toIndex} is greater than the array size\\n     * @see Arrays#spliterator(long[], int, int)\\n     \"}"}, {"color": "#97c2fc", "id": "public static Spliterator.OfDouble spliterator(double[] array, int additionalCharacteristics)", "label": "public static Spliterator.OfDouble spliterator(double[] array, int additionalCharacteristics)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a {@code Spliterator.OfDouble} covering the elements of a given array,\\n     * using a customized set of spliterator characteristics.\\n     *\\n     * \u003cp\u003eThis method is provided as an implementation convenience for\\n     * Spliterators which store portions of their elements in arrays, and need\\n     * fine control over Spliterator characteristics.  Most other situations in\\n     * which a Spliterator for an array is needed should use\\n     * {@link Arrays#spliterator(double[])}.\\n     *\\n     * \u003cp\u003eThe returned spliterator always reports the characteristics\\n     * {@code SIZED} and {@code SUBSIZED}.  The caller may provide additional\\n     * characteristics for the spliterator to report; it is common to\\n     * additionally specify {@code IMMUTABLE} and {@code ORDERED}.\\n     *\\n     * @param array The array, assumed to be unmodified during use\\n     * @param additionalCharacteristics Additional spliterator characteristics\\n     *        of this spliterator\u0027s source or elements beyond {@code SIZED} and\\n     *        {@code SUBSIZED} which are always reported\\n     * @return A spliterator for an array\\n     * @throws NullPointerException if the given array is {@code null}\\n     * @see Arrays#spliterator(double[])\\n     \"}"}, {"color": "#97c2fc", "id": "public static Spliterator.OfDouble spliterator(double[] array, int fromIndex, int toIndex, int additionalCharacteristics)", "label": "public static Spliterator.OfDouble spliterator(double[] array, int fromIndex, int toIndex, int additionalCharacteristics)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Creates a {@code Spliterator.OfDouble} covering a range of elements of a\\n     * given array, using a customized set of spliterator characteristics.\\n     *\\n     * \u003cp\u003eThis method is provided as an implementation convenience for\\n     * Spliterators which store portions of their elements in arrays, and need\\n     * fine control over Spliterator characteristics.  Most other situations in\\n     * which a Spliterator for an array is needed should use\\n     * {@link Arrays#spliterator(double[], int, int)}.\\n     *\\n     * \u003cp\u003eThe returned spliterator always reports the characteristics\\n     * {@code SIZED} and {@code SUBSIZED}.  The caller may provide additional\\n     * characteristics for the spliterator to report.  (For example, if it is\\n     * known the array will not be further modified, specify {@code IMMUTABLE};\\n     * if the array data is considered to have an encounter order, specify\\n     * {@code ORDERED}).  The method {@link Arrays#spliterator(long[], int, int)} can\\n     * often be used instead, which returns a spliterator that reports\\n     * {@code SIZED}, {@code SUBSIZED}, {@code IMMUTABLE}, and {@code ORDERED}.\\n     *\\n     * @param array The array, assumed to be unmodified during use\\n     * @param fromIndex The least index (inclusive) to cover\\n     * @param toIndex One past the greatest index to cover\\n     * @param additionalCharacteristics Additional spliterator characteristics\\n     *        of this spliterator\u0027s source or elements beyond {@code SIZED} and\\n     *        {@code SUBSIZED} which are always reported\\n     * @return A spliterator for an array\\n     * @throws NullPointerException if the given array is {@code null}\\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex} is negative,\\n     *         {@code toIndex} is less than {@code fromIndex}, or\\n     *         {@code toIndex} is greater than the array size\\n     * @see Arrays#spliterator(double[], int, int)\\n     \"}"}, {"color": "#97c2fc", "id": "private static void checkFromToBounds(int arrayLength, int origin, int fence)", "label": "private static void checkFromToBounds(int arrayLength, int origin, int fence)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Validate inclusive start index and exclusive end index against the length\\n     * of an array.\\n     * @param arrayLength The length of the array\\n     * @param origin The inclusive start index\\n     * @param fence The exclusive end index\\n     * @throws ArrayIndexOutOfBoundsException if the start index is greater than\\n     * the end index, if the start index is negative, or the end index is\\n     * greater than the array length\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Spliterator\u003cT\u003e spliterator(Collection\u003c? extends T\u003e c, int characteristics)", "label": "public static Spliterator\u003cT\u003e spliterator(Collection\u003c? extends T\u003e c, int characteristics)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a {@code Spliterator} using the given collection\\\u0027s\\n     * {@link java.util.Collection#iterator()} as the source of elements, and\\n     * reporting its {@link java.util.Collection#size()} as its initial size.\\n     *\\n     * \u003cp\u003eThe spliterator is\\n     * \u003cem\u003e\u003ca href=\"Spliterator.html#binding\"\u003elate-binding\u003c/a\u003e\u003c/em\u003e, inherits\\n     * the \u003cem\u003efail-fast\u003c/em\u003e properties of the collection\\\u0027s iterator, and\\n     * implements {@code trySplit} to permit limited parallelism.\\n     *\\n     * @param \u003cT\u003e Type of elements\\n     * @param c The collection\\n     * @param characteristics Characteristics of this spliterator\\\u0027s source or\\n     *        elements.  The characteristics {@code SIZED} and {@code SUBSIZED}\\n     *        are additionally reported unless {@code CONCURRENT} is supplied.\\n     * @return A spliterator from an iterator\\n     * @throws NullPointerException if the given collection is {@code null}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Spliterator\u003cT\u003e spliterator(Iterator\u003c? extends T\u003e iterator, long size, int characteristics)", "label": "public static Spliterator\u003cT\u003e spliterator(Iterator\u003c? extends T\u003e iterator, long size, int characteristics)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a {@code Spliterator} using a given {@code Iterator}\\n     * as the source of elements, and with a given initially reported size.\\n     *\\n     * \u003cp\u003eThe spliterator is not\\n     * \u003cem\u003e\u003ca href=\"Spliterator.html#binding\"\u003elate-binding\u003c/a\u003e\u003c/em\u003e, inherits\\n     * the \u003cem\u003efail-fast\u003c/em\u003e properties of the iterator, and implements\\n     * {@code trySplit} to permit limited parallelism.\\n     *\\n     * \u003cp\u003eTraversal of elements should be accomplished through the spliterator.\\n     * The behaviour of splitting and traversal is undefined if the iterator is\\n     * operated on after the spliterator is returned, or the initially reported\\n     * size is not equal to the actual number of elements in the source.\\n     *\\n     * @param \u003cT\u003e Type of elements\\n     * @param iterator The iterator for the source\\n     * @param size The number of elements in the source, to be reported as\\n     *        initial {@code estimateSize}\\n     * @param characteristics Characteristics of this spliterator\\\u0027s source or\\n     *        elements.  The characteristics {@code SIZED} and {@code SUBSIZED}\\n     *        are additionally reported unless {@code CONCURRENT} is supplied.\\n     * @return A spliterator from an iterator\\n     * @throws NullPointerException if the given iterator is {@code null}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Spliterator\u003cT\u003e spliteratorUnknownSize(Iterator\u003c? extends T\u003e iterator, int characteristics)", "label": "public static Spliterator\u003cT\u003e spliteratorUnknownSize(Iterator\u003c? extends T\u003e iterator, int characteristics)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a {@code Spliterator} using a given {@code Iterator}\\n     * as the source of elements, with no initial size estimate.\\n     *\\n     * \u003cp\u003eThe spliterator is not\\n     * \u003cem\u003e\u003ca href=\"Spliterator.html#binding\"\u003elate-binding\u003c/a\u003e\u003c/em\u003e, inherits\\n     * the \u003cem\u003efail-fast\u003c/em\u003e properties of the iterator, and implements\\n     * {@code trySplit} to permit limited parallelism.\\n     *\\n     * \u003cp\u003eTraversal of elements should be accomplished through the spliterator.\\n     * The behaviour of splitting and traversal is undefined if the iterator is\\n     * operated on after the spliterator is returned.\\n     *\\n     * @param \u003cT\u003e Type of elements\\n     * @param iterator The iterator for the source\\n     * @param characteristics Characteristics of this spliterator\\\u0027s source\\n     *        or elements ({@code SIZED} and {@code SUBSIZED}, if supplied, are\\n     *        ignored and are not reported.)\\n     * @return A spliterator from an iterator\\n     * @throws NullPointerException if the given iterator is {@code null}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Spliterator.OfInt spliterator(PrimitiveIterator.OfInt iterator, long size, int characteristics)", "label": "public static Spliterator.OfInt spliterator(PrimitiveIterator.OfInt iterator, long size, int characteristics)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a {@code Spliterator.OfInt} using a given\\n     * {@code IntStream.IntIterator} as the source of elements, and with a given\\n     * initially reported size.\\n     *\\n     * \u003cp\u003eThe spliterator is not\\n     * \u003cem\u003e\u003ca href=\"Spliterator.html#binding\"\u003elate-binding\u003c/a\u003e\u003c/em\u003e, inherits\\n     * the \u003cem\u003efail-fast\u003c/em\u003e properties of the iterator, and implements\\n     * {@code trySplit} to permit limited parallelism.\\n     *\\n     * \u003cp\u003eTraversal of elements should be accomplished through the spliterator.\\n     * The behaviour of splitting and traversal is undefined if the iterator is\\n     * operated on after the spliterator is returned, or the initially reported\\n     * size is not equal to the actual number of elements in the source.\\n     *\\n     * @param iterator The iterator for the source\\n     * @param size The number of elements in the source, to be reported as\\n     *        initial {@code estimateSize}.\\n     * @param characteristics Characteristics of this spliterator\\\u0027s source or\\n     *        elements.  The characteristics {@code SIZED} and {@code SUBSIZED}\\n     *        are additionally reported unless {@code CONCURRENT} is supplied.\\n     * @return A spliterator from an iterator\\n     * @throws NullPointerException if the given iterator is {@code null}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Spliterator.OfInt spliteratorUnknownSize(PrimitiveIterator.OfInt iterator, int characteristics)", "label": "public static Spliterator.OfInt spliteratorUnknownSize(PrimitiveIterator.OfInt iterator, int characteristics)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a {@code Spliterator.OfInt} using a given\\n     * {@code IntStream.IntIterator} as the source of elements, with no initial\\n     * size estimate.\\n     *\\n     * \u003cp\u003eThe spliterator is not\\n     * \u003cem\u003e\u003ca href=\"Spliterator.html#binding\"\u003elate-binding\u003c/a\u003e\u003c/em\u003e, inherits\\n     * the \u003cem\u003efail-fast\u003c/em\u003e properties of the iterator, and implements\\n     * {@code trySplit} to permit limited parallelism.\\n     *\\n     * \u003cp\u003eTraversal of elements should be accomplished through the spliterator.\\n     * The behaviour of splitting and traversal is undefined if the iterator is\\n     * operated on after the spliterator is returned.\\n     *\\n     * @param iterator The iterator for the source\\n     * @param characteristics Characteristics of this spliterator\\\u0027s source\\n     *        or elements ({@code SIZED} and {@code SUBSIZED}, if supplied, are\\n     *        ignored and are not reported.)\\n     * @return A spliterator from an iterator\\n     * @throws NullPointerException if the given iterator is {@code null}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Spliterator.OfLong spliterator(PrimitiveIterator.OfLong iterator, long size, int characteristics)", "label": "public static Spliterator.OfLong spliterator(PrimitiveIterator.OfLong iterator, long size, int characteristics)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a {@code Spliterator.OfLong} using a given\\n     * {@code LongStream.LongIterator} as the source of elements, and with a\\n     * given initially reported size.\\n     *\\n     * \u003cp\u003eThe spliterator is not\\n     * \u003cem\u003e\u003ca href=\"Spliterator.html#binding\"\u003elate-binding\u003c/a\u003e\u003c/em\u003e, inherits\\n     * the \u003cem\u003efail-fast\u003c/em\u003e properties of the iterator, and implements\\n     * {@code trySplit} to permit limited parallelism.\\n     *\\n     * \u003cp\u003eTraversal of elements should be accomplished through the spliterator.\\n     * The behaviour of splitting and traversal is undefined if the iterator is\\n     * operated on after the spliterator is returned, or the initially reported\\n     * size is not equal to the actual number of elements in the source.\\n     *\\n     * @param iterator The iterator for the source\\n     * @param size The number of elements in the source, to be reported as\\n     *        initial {@code estimateSize}.\\n     * @param characteristics Characteristics of this spliterator\\\u0027s source or\\n     *        elements.  The characteristics {@code SIZED} and {@code SUBSIZED}\\n     *        are additionally reported unless {@code CONCURRENT} is supplied.\\n     * @return A spliterator from an iterator\\n     * @throws NullPointerException if the given iterator is {@code null}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Spliterator.OfLong spliteratorUnknownSize(PrimitiveIterator.OfLong iterator, int characteristics)", "label": "public static Spliterator.OfLong spliteratorUnknownSize(PrimitiveIterator.OfLong iterator, int characteristics)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a {@code Spliterator.OfLong} using a given\\n     * {@code LongStream.LongIterator} as the source of elements, with no\\n     * initial size estimate.\\n     *\\n     * \u003cp\u003eThe spliterator is not\\n     * \u003cem\u003e\u003ca href=\"Spliterator.html#binding\"\u003elate-binding\u003c/a\u003e\u003c/em\u003e, inherits\\n     * the \u003cem\u003efail-fast\u003c/em\u003e properties of the iterator, and implements\\n     * {@code trySplit} to permit limited parallelism.\\n     *\\n     * \u003cp\u003eTraversal of elements should be accomplished through the spliterator.\\n     * The behaviour of splitting and traversal is undefined if the iterator is\\n     * operated on after the spliterator is returned.\\n     *\\n     * @param iterator The iterator for the source\\n     * @param characteristics Characteristics of this spliterator\\\u0027s source\\n     *        or elements ({@code SIZED} and {@code SUBSIZED}, if supplied, are\\n     *        ignored and are not reported.)\\n     * @return A spliterator from an iterator\\n     * @throws NullPointerException if the given iterator is {@code null}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Spliterator.OfDouble spliterator(PrimitiveIterator.OfDouble iterator, long size, int characteristics)", "label": "public static Spliterator.OfDouble spliterator(PrimitiveIterator.OfDouble iterator, long size, int characteristics)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a {@code Spliterator.OfDouble} using a given\\n     * {@code DoubleStream.DoubleIterator} as the source of elements, and with a\\n     * given initially reported size.\\n     *\\n     * \u003cp\u003eThe spliterator is not\\n     * \u003cem\u003e\u003ca href=\"Spliterator.html#binding\"\u003elate-binding\u003c/a\u003e\u003c/em\u003e, inherits\\n     * the \u003cem\u003efail-fast\u003c/em\u003e properties of the iterator, and implements\\n     * {@code trySplit} to permit limited parallelism.\\n     *\\n     * \u003cp\u003eTraversal of elements should be accomplished through the spliterator.\\n     * The behaviour of splitting and traversal is undefined if the iterator is\\n     * operated on after the spliterator is returned, or the initially reported\\n     * size is not equal to the actual number of elements in the source.\\n     *\\n     * @param iterator The iterator for the source\\n     * @param size The number of elements in the source, to be reported as\\n     *        initial {@code estimateSize}\\n     * @param characteristics Characteristics of this spliterator\\\u0027s source or\\n     *        elements.  The characteristics {@code SIZED} and {@code SUBSIZED}\\n     *        are additionally reported unless {@code CONCURRENT} is supplied.\\n     * @return A spliterator from an iterator\\n     * @throws NullPointerException if the given iterator is {@code null}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Spliterator.OfDouble spliteratorUnknownSize(PrimitiveIterator.OfDouble iterator, int characteristics)", "label": "public static Spliterator.OfDouble spliteratorUnknownSize(PrimitiveIterator.OfDouble iterator, int characteristics)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates a {@code Spliterator.OfDouble} using a given\\n     * {@code DoubleStream.DoubleIterator} as the source of elements, with no\\n     * initial size estimate.\\n     *\\n     * \u003cp\u003eThe spliterator is not\\n     * \u003cem\u003e\u003ca href=\"Spliterator.html#binding\"\u003elate-binding\u003c/a\u003e\u003c/em\u003e, inherits\\n     * the \u003cem\u003efail-fast\u003c/em\u003e properties of the iterator, and implements\\n     * {@code trySplit} to permit limited parallelism.\\n     *\\n     * \u003cp\u003eTraversal of elements should be accomplished through the spliterator.\\n     * The behaviour of splitting and traversal is undefined if the iterator is\\n     * operated on after the spliterator is returned.\\n     *\\n     * @param iterator The iterator for the source\\n     * @param characteristics Characteristics of this spliterator\\\u0027s source\\n     *        or elements ({@code SIZED} and {@code SUBSIZED}, if supplied, are\\n     *        ignored and are not reported.)\\n     * @return A spliterator from an iterator\\n     * @throws NullPointerException if the given iterator is {@code null}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static Iterator\u003cT\u003e iterator(Spliterator\u003c? extends T\u003e spliterator)", "label": "public static Iterator\u003cT\u003e iterator(Spliterator\u003c? extends T\u003e spliterator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates an {@code Iterator} from a {@code Spliterator}.\\n     *\\n     * \u003cp\u003eTraversal of elements should be accomplished through the iterator.\\n     * The behaviour of traversal is undefined if the spliterator is operated\\n     * after the iterator is returned.\\n     *\\n     * @param \u003cT\u003e Type of elements\\n     * @param spliterator The spliterator\\n     * @return An iterator\\n     * @throws NullPointerException if the given spliterator is {@code null}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static PrimitiveIterator.OfInt iterator(Spliterator.OfInt spliterator)", "label": "public static PrimitiveIterator.OfInt iterator(Spliterator.OfInt spliterator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates an {@code PrimitiveIterator.OfInt} from a\\n     * {@code Spliterator.OfInt}.\\n     *\\n     * \u003cp\u003eTraversal of elements should be accomplished through the iterator.\\n     * The behaviour of traversal is undefined if the spliterator is operated\\n     * after the iterator is returned.\\n     *\\n     * @param spliterator The spliterator\\n     * @return An iterator\\n     * @throws NullPointerException if the given spliterator is {@code null}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static PrimitiveIterator.OfLong iterator(Spliterator.OfLong spliterator)", "label": "public static PrimitiveIterator.OfLong iterator(Spliterator.OfLong spliterator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates an {@code PrimitiveIterator.OfLong} from a\\n     * {@code Spliterator.OfLong}.\\n     *\\n     * \u003cp\u003eTraversal of elements should be accomplished through the iterator.\\n     * The behaviour of traversal is undefined if the spliterator is operated\\n     * after the iterator is returned.\\n     *\\n     * @param spliterator The spliterator\\n     * @return An iterator\\n     * @throws NullPointerException if the given spliterator is {@code null}\\n     \u0027}"}, {"color": "#97c2fc", "id": "public static PrimitiveIterator.OfDouble iterator(Spliterator.OfDouble spliterator)", "label": "public static PrimitiveIterator.OfDouble iterator(Spliterator.OfDouble spliterator)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Creates an {@code PrimitiveIterator.OfDouble} from a\\n     * {@code Spliterator.OfDouble}.\\n     *\\n     * \u003cp\u003eTraversal of elements should be accomplished through the iterator.\\n     * The behaviour of traversal is undefined if the spliterator is operated\\n     * after the iterator is returned.\\n     *\\n     * @param spliterator The spliterator\\n     * @return An iterator\\n     * @throws NullPointerException if the given spliterator is {@code null}\\n     \u0027}"}, {"color": "#97c2fc", "id": "parallelStream()", "label": "parallelStream()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "stream()", "label": "stream()", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " Stream\u003cE\u003e stream()", "label": " Stream\u003cE\u003e stream()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a sequential {@code Stream} with this collection as its source.\\n     *\\n     * \u003cp\u003eThis method should be overridden when the {@link #spliterator()}\\n     * method cannot return a spliterator that is {@code IMMUTABLE},\\n     * {@code CONCURRENT}, or \u003cem\u003elate-binding\u003c/em\u003e. (See {@link #spliterator()}\\n     * for details.)\\n     *\\n     * @implSpec\\n     * The default implementation creates a sequential {@code Stream} from the\\n     * collection\u0027s {@code Spliterator}.\\n     *\\n     * @return a sequential {@code Stream} over the elements in this collection\\n     * @since 1.8\\n     \"}"}, {"color": "#97c2fc", "id": " Stream\u003cE\u003e parallelStream()", "label": " Stream\u003cE\u003e parallelStream()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a possibly parallel {@code Stream} with this collection as its\\n     * source.  It is allowable for this method to return a sequential stream.\\n     *\\n     * \u003cp\u003eThis method should be overridden when the {@link #spliterator()}\\n     * method cannot return a spliterator that is {@code IMMUTABLE},\\n     * {@code CONCURRENT}, or \u003cem\u003elate-binding\u003c/em\u003e. (See {@link #spliterator()}\\n     * for details.)\\n     *\\n     * @implSpec\\n     * The default implementation creates a parallel {@code Stream} from the\\n     * collection\u0027s {@code Spliterator}.\\n     *\\n     * @return a possibly parallel {@code Stream} over the elements in this\\n     * collection\\n     * @since 1.8\\n     \"}"}, {"color": "#97c2fc", "id": " static Set\u003cE\u003e of()", "label": " static Set\u003cE\u003e of()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable set containing zero elements.\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Sets\u003c/a\u003e for details.\\n     *\\n     * @param \u003cE\u003e the {@code Set}\\\u0027s element type\\n     * @return an empty {@code Set}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static Set\u003cE\u003e of(E e1)", "label": " static Set\u003cE\u003e of(E e1)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable set containing one element.\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Sets\u003c/a\u003e for details.\\n     *\\n     * @param \u003cE\u003e the {@code Set}\\\u0027s element type\\n     * @param e1 the single element\\n     * @return a {@code Set} containing the specified element\\n     * @throws NullPointerException if the element is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static Set\u003cE\u003e of(E e1, E e2)", "label": " static Set\u003cE\u003e of(E e1, E e2)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable set containing two elements.\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Sets\u003c/a\u003e for details.\\n     *\\n     * @param \u003cE\u003e the {@code Set}\\\u0027s element type\\n     * @param e1 the first element\\n     * @param e2 the second element\\n     * @return a {@code Set} containing the specified elements\\n     * @throws IllegalArgumentException if the elements are duplicates\\n     * @throws NullPointerException if an element is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static Set\u003cE\u003e of(E e1, E e2, E e3)", "label": " static Set\u003cE\u003e of(E e1, E e2, E e3)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable set containing three elements.\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Sets\u003c/a\u003e for details.\\n     *\\n     * @param \u003cE\u003e the {@code Set}\\\u0027s element type\\n     * @param e1 the first element\\n     * @param e2 the second element\\n     * @param e3 the third element\\n     * @return a {@code Set} containing the specified elements\\n     * @throws IllegalArgumentException if there are any duplicate elements\\n     * @throws NullPointerException if an element is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static Set\u003cE\u003e of(E e1, E e2, E e3, E e4)", "label": " static Set\u003cE\u003e of(E e1, E e2, E e3, E e4)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable set containing four elements.\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Sets\u003c/a\u003e for details.\\n     *\\n     * @param \u003cE\u003e the {@code Set}\\\u0027s element type\\n     * @param e1 the first element\\n     * @param e2 the second element\\n     * @param e3 the third element\\n     * @param e4 the fourth element\\n     * @return a {@code Set} containing the specified elements\\n     * @throws IllegalArgumentException if there are any duplicate elements\\n     * @throws NullPointerException if an element is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static Set\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5)", "label": " static Set\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable set containing five elements.\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Sets\u003c/a\u003e for details.\\n     *\\n     * @param \u003cE\u003e the {@code Set}\\\u0027s element type\\n     * @param e1 the first element\\n     * @param e2 the second element\\n     * @param e3 the third element\\n     * @param e4 the fourth element\\n     * @param e5 the fifth element\\n     * @return a {@code Set} containing the specified elements\\n     * @throws IllegalArgumentException if there are any duplicate elements\\n     * @throws NullPointerException if an element is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static Set\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6)", "label": " static Set\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable set containing six elements.\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Sets\u003c/a\u003e for details.\\n     *\\n     * @param \u003cE\u003e the {@code Set}\\\u0027s element type\\n     * @param e1 the first element\\n     * @param e2 the second element\\n     * @param e3 the third element\\n     * @param e4 the fourth element\\n     * @param e5 the fifth element\\n     * @param e6 the sixth element\\n     * @return a {@code Set} containing the specified elements\\n     * @throws IllegalArgumentException if there are any duplicate elements\\n     * @throws NullPointerException if an element is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static Set\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6, E e7)", "label": " static Set\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6, E e7)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable set containing seven elements.\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Sets\u003c/a\u003e for details.\\n     *\\n     * @param \u003cE\u003e the {@code Set}\\\u0027s element type\\n     * @param e1 the first element\\n     * @param e2 the second element\\n     * @param e3 the third element\\n     * @param e4 the fourth element\\n     * @param e5 the fifth element\\n     * @param e6 the sixth element\\n     * @param e7 the seventh element\\n     * @return a {@code Set} containing the specified elements\\n     * @throws IllegalArgumentException if there are any duplicate elements\\n     * @throws NullPointerException if an element is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static Set\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)", "label": " static Set\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable set containing eight elements.\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Sets\u003c/a\u003e for details.\\n     *\\n     * @param \u003cE\u003e the {@code Set}\\\u0027s element type\\n     * @param e1 the first element\\n     * @param e2 the second element\\n     * @param e3 the third element\\n     * @param e4 the fourth element\\n     * @param e5 the fifth element\\n     * @param e6 the sixth element\\n     * @param e7 the seventh element\\n     * @param e8 the eighth element\\n     * @return a {@code Set} containing the specified elements\\n     * @throws IllegalArgumentException if there are any duplicate elements\\n     * @throws NullPointerException if an element is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static Set\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)", "label": " static Set\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable set containing nine elements.\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Sets\u003c/a\u003e for details.\\n     *\\n     * @param \u003cE\u003e the {@code Set}\\\u0027s element type\\n     * @param e1 the first element\\n     * @param e2 the second element\\n     * @param e3 the third element\\n     * @param e4 the fourth element\\n     * @param e5 the fifth element\\n     * @param e6 the sixth element\\n     * @param e7 the seventh element\\n     * @param e8 the eighth element\\n     * @param e9 the ninth element\\n     * @return a {@code Set} containing the specified elements\\n     * @throws IllegalArgumentException if there are any duplicate elements\\n     * @throws NullPointerException if an element is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static Set\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)", "label": " static Set\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable set containing ten elements.\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Sets\u003c/a\u003e for details.\\n     *\\n     * @param \u003cE\u003e the {@code Set}\\\u0027s element type\\n     * @param e1 the first element\\n     * @param e2 the second element\\n     * @param e3 the third element\\n     * @param e4 the fourth element\\n     * @param e5 the fifth element\\n     * @param e6 the sixth element\\n     * @param e7 the seventh element\\n     * @param e8 the eighth element\\n     * @param e9 the ninth element\\n     * @param e10 the tenth element\\n     * @return a {@code Set} containing the specified elements\\n     * @throws IllegalArgumentException if there are any duplicate elements\\n     * @throws NullPointerException if an element is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static Set\u003cE\u003e of(E... elements)", "label": " static Set\u003cE\u003e of(E... elements)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable set containing an arbitrary number of elements.\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Sets\u003c/a\u003e for details.\\n     *\\n     * @apiNote\\n     * This method also accepts a single array as an argument. The element type of\\n     * the resulting set will be the component type of the array, and the size of\\n     * the set will be equal to the length of the array. To create a set with\\n     * a single element that is an array, do the following:\\n     *\\n     * \u003cpre\u003e{@code\\n     *     String[] array = ... ;\\n     *     Set\u003cString[]\u003e list = Set.\u003cString[]\u003eof(array);\\n     * }\u003c/pre\u003e\\n     *\\n     * This will cause the {@link Set#of(Object) Set.of(E)} method\\n     * to be invoked instead.\\n     *\\n     * @param \u003cE\u003e the {@code Set}\\\u0027s element type\\n     * @param elements the elements to be contained in the set\\n     * @return a {@code Set} containing the specified elements\\n     * @throws IllegalArgumentException if there are any duplicate elements\\n     * @throws NullPointerException if an element is {@code null} or if the array is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static Set\u003cE\u003e copyOf(Collection\u003c? extends E\u003e coll)", "label": " static Set\u003cE\u003e copyOf(Collection\u003c? extends E\u003e coll)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an \u003ca href=\"#unmodifiable\"\u003eunmodifiable Set\u003c/a\u003e containing the elements\\n     * of the given Collection. The given Collection must not be null, and it must not\\n     * contain any null elements. If the given Collection contains duplicate elements,\\n     * an arbitrary element of the duplicates is preserved. If the given Collection is\\n     * subsequently modified, the returned Set will not reflect such modifications.\\n     *\\n     * @implNote\\n     * If the given Collection is an \u003ca href=\"#unmodifiable\"\u003eunmodifiable Set\u003c/a\u003e,\\n     * calling copyOf will generally not create a copy.\\n     *\\n     * @param \u003cE\u003e the {@code Set}\\\u0027s element type\\n     * @param coll a {@code Collection} from which elements are drawn, must be non-null\\n     * @return a {@code Set} containing the elements of the given {@code Collection}\\n     * @throws NullPointerException if coll is null, or if it contains any nulls\\n     * @since 10\\n     \u0027}"}, {"color": "#97c2fc", "id": " Collection\u003cV\u003e values()", "label": " Collection\u003cV\u003e values()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a {@link Collection} view of the values contained in this map.\\n     * The collection is backed by the map, so changes to the map are\\n     * reflected in the collection, and vice-versa.  If the map is\\n     * modified while an iteration over the collection is in progress\\n     * (except through the iterator\u0027s own {@code remove} operation),\\n     * the results of the iteration are undefined.  The collection\\n     * supports element removal, which removes the corresponding\\n     * mapping from the map, via the {@code Iterator.remove},\\n     * {@code Collection.remove}, {@code removeAll},\\n     * {@code retainAll} and {@code clear} operations.  It does not\\n     * support the {@code add} or {@code addAll} operations.\\n     *\\n     * @return a collection view of the values contained in this map\\n     \"}"}, {"color": "#97c2fc", "id": " Set\u003cMap.Entry\u003cK, V\u003e\u003e entrySet()", "label": " Set\u003cMap.Entry\u003cK, V\u003e\u003e entrySet()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \"\\n     * Returns a {@link Set} view of the mappings contained in this map.\\n     * The set is backed by the map, so changes to the map are\\n     * reflected in the set, and vice-versa.  If the map is modified\\n     * while an iteration over the set is in progress (except through\\n     * the iterator\u0027s own {@code remove} operation, or through the\\n     * {@code setValue} operation on a map entry returned by the\\n     * iterator) the results of the iteration are undefined.  The set\\n     * supports element removal, which removes the corresponding\\n     * mapping from the map, via the {@code Iterator.remove},\\n     * {@code Set.remove}, {@code removeAll}, {@code retainAll} and\\n     * {@code clear} operations.  It does not support the\\n     * {@code add} or {@code addAll} operations.\\n     *\\n     * @return a set view of the mappings contained in this map\\n     \"}"}, {"color": "#97c2fc", "id": " V getOrDefault(Object key, V defaultValue)", "label": " V getOrDefault(Object key, V defaultValue)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * {@inheritDoc}\\n     *\\n     * @implNote This implementation assumes that the ConcurrentMap cannot\\n     * contain null values and {@code get()} returning null unambiguously means\\n     * the key is absent. Implementations which support null values\\n     * \u003cstrong\u003emust\u003c/strong\u003e override this default implementation.\\n     *\\n     * @throws ClassCastException {@inheritDoc}\\n     * @throws NullPointerException {@inheritDoc}\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": " void forEach(BiConsumer\u003c? super K, ? super V\u003e action)", "label": " void forEach(BiConsumer\u003c? super K, ? super V\u003e action)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * {@inheritDoc}\\n     *\\n     * @implSpec The default implementation is equivalent to, for this\\n     * {@code map}:\\n     * \u003cpre\u003e {@code\\n     * for (Map.Entry\u003cK,V\u003e entry : map.entrySet()) {\\n     *   action.accept(entry.getKey(), entry.getValue());\\n     * }}\u003c/pre\u003e\\n     *\\n     * @implNote The default implementation assumes that\\n     * {@code IllegalStateException} thrown by {@code getKey()} or\\n     * {@code getValue()} indicates that the entry has been removed and cannot\\n     * be processed. Operation continues for subsequent entries.\\n     *\\n     * @throws NullPointerException {@inheritDoc}\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": " void replaceAll(BiFunction\u003c? super K, ? super V, ? extends V\u003e function)", "label": " void replaceAll(BiFunction\u003c? super K, ? super V, ? extends V\u003e function)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * {@inheritDoc}\\n     *\\n     * @implSpec\\n     * \u003cp\u003eThe default implementation is equivalent to, for this {@code map}:\\n     * \u003cpre\u003e {@code\\n     * for (Map.Entry\u003cK,V\u003e entry : map.entrySet()) {\\n     *   K k;\\n     *   V v;\\n     *   do {\\n     *     k = entry.getKey();\\n     *     v = entry.getValue();\\n     *   } while (!map.replace(k, v, function.apply(k, v)));\\n     * }}\u003c/pre\u003e\\n     *\\n     * The default implementation may retry these steps when multiple\\n     * threads attempt updates including potentially calling the function\\n     * repeatedly for a given key.\\n     *\\n     * \u003cp\u003eThis implementation assumes that the ConcurrentMap cannot contain null\\n     * values and {@code get()} returning null unambiguously means the key is\\n     * absent. Implementations which support null values \u003cstrong\u003emust\u003c/strong\u003e\\n     * override this default implementation.\\n     *\\n     * @throws UnsupportedOperationException {@inheritDoc}\\n     * @throws NullPointerException {@inheritDoc}\\n     * @throws ClassCastException {@inheritDoc}\\n     * @throws IllegalArgumentException {@inheritDoc}\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": " V putIfAbsent(K key, V value)", "label": " V putIfAbsent(K key, V value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * If the specified key is not already associated\\n     * with a value, associates it with the given value.\\n     * This is equivalent to, for this {@code map}:\\n     * \u003cpre\u003e {@code\\n     * if (!map.containsKey(key))\\n     *   return map.put(key, value);\\n     * else\\n     *   return map.get(key);}\u003c/pre\u003e\\n     *\\n     * except that the action is performed atomically.\\n     *\\n     * @implNote This implementation intentionally re-abstracts the\\n     * inappropriate default provided in {@code Map}.\\n     *\\n     * @param key key with which the specified value is to be associated\\n     * @param value value to be associated with the specified key\\n     * @return the previous value associated with the specified key, or\\n     *         {@code null} if there was no mapping for the key.\\n     *         (A {@code null} return can also indicate that the map\\n     *         previously associated {@code null} with the key,\\n     *         if the implementation supports null values.)\\n     * @throws UnsupportedOperationException if the {@code put} operation\\n     *         is not supported by this map\\n     * @throws ClassCastException if the class of the specified key or value\\n     *         prevents it from being stored in this map\\n     * @throws NullPointerException if the specified key or value is null,\\n     *         and this map does not permit null keys or values\\n     * @throws IllegalArgumentException if some property of the specified key\\n     *         or value prevents it from being stored in this map\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean remove(Object key, Object value)", "label": " boolean remove(Object key, Object value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Removes the entry for a key only if currently mapped to a given value.\\n     * This is equivalent to, for this {@code map}:\\n     * \u003cpre\u003e {@code\\n     * if (map.containsKey(key)\\n     *     \u0026\u0026 Objects.equals(map.get(key), value)) {\\n     *   map.remove(key);\\n     *   return true;\\n     * } else {\\n     *   return false;\\n     * }}\u003c/pre\u003e\\n     *\\n     * except that the action is performed atomically.\\n     *\\n     * @implNote This implementation intentionally re-abstracts the\\n     * inappropriate default provided in {@code Map}.\\n     *\\n     * @param key key with which the specified value is associated\\n     * @param value value expected to be associated with the specified key\\n     * @return {@code true} if the value was removed\\n     * @throws UnsupportedOperationException if the {@code remove} operation\\n     *         is not supported by this map\\n     * @throws ClassCastException if the key or value is of an inappropriate\\n     *         type for this map\\n     * (\u003ca href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     * @throws NullPointerException if the specified key or value is null,\\n     *         and this map does not permit null keys or values\\n     * (\u003ca href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     \u0027}"}, {"color": "#97c2fc", "id": " boolean replace(K key, V oldValue, V newValue)", "label": " boolean replace(K key, V oldValue, V newValue)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Replaces the entry for a key only if currently mapped to a given value.\\n     * This is equivalent to, for this {@code map}:\\n     * \u003cpre\u003e {@code\\n     * if (map.containsKey(key)\\n     *     \u0026\u0026 Objects.equals(map.get(key), oldValue)) {\\n     *   map.put(key, newValue);\\n     *   return true;\\n     * } else {\\n     *   return false;\\n     * }}\u003c/pre\u003e\\n     *\\n     * except that the action is performed atomically.\\n     *\\n     * @implNote This implementation intentionally re-abstracts the\\n     * inappropriate default provided in {@code Map}.\\n     *\\n     * @param key key with which the specified value is associated\\n     * @param oldValue value expected to be associated with the specified key\\n     * @param newValue value to be associated with the specified key\\n     * @return {@code true} if the value was replaced\\n     * @throws UnsupportedOperationException if the {@code put} operation\\n     *         is not supported by this map\\n     * @throws ClassCastException if the class of a specified key or value\\n     *         prevents it from being stored in this map\\n     * @throws NullPointerException if a specified key or value is null,\\n     *         and this map does not permit null keys or values\\n     * @throws IllegalArgumentException if some property of a specified key\\n     *         or value prevents it from being stored in this map\\n     \u0027}"}, {"color": "#97c2fc", "id": " V replace(K key, V value)", "label": " V replace(K key, V value)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Replaces the entry for a key only if currently mapped to some value.\\n     * This is equivalent to, for this {@code map}:\\n     * \u003cpre\u003e {@code\\n     * if (map.containsKey(key))\\n     *   return map.put(key, value);\\n     * else\\n     *   return null;}\u003c/pre\u003e\\n     *\\n     * except that the action is performed atomically.\\n     *\\n     * @implNote This implementation intentionally re-abstracts the\\n     * inappropriate default provided in {@code Map}.\\n     *\\n     * @param key key with which the specified value is associated\\n     * @param value value to be associated with the specified key\\n     * @return the previous value associated with the specified key, or\\n     *         {@code null} if there was no mapping for the key.\\n     *         (A {@code null} return can also indicate that the map\\n     *         previously associated {@code null} with the key,\\n     *         if the implementation supports null values.)\\n     * @throws UnsupportedOperationException if the {@code put} operation\\n     *         is not supported by this map\\n     * @throws ClassCastException if the class of the specified key or value\\n     *         prevents it from being stored in this map\\n     * @throws NullPointerException if the specified key or value is null,\\n     *         and this map does not permit null keys or values\\n     * @throws IllegalArgumentException if some property of the specified key\\n     *         or value prevents it from being stored in this map\\n     \u0027}"}, {"color": "#97c2fc", "id": " V computeIfAbsent(K key, Function\u003c? super K, ? extends V\u003e mappingFunction)", "label": " V computeIfAbsent(K key, Function\u003c? super K, ? extends V\u003e mappingFunction)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * {@inheritDoc}\\n     *\\n     * @implSpec\\n     * The default implementation is equivalent to the following steps for this\\n     * {@code map}:\\n     *\\n     * \u003cpre\u003e {@code\\n     * V oldValue, newValue;\\n     * return ((oldValue = map.get(key)) == null\\n     *         \u0026\u0026 (newValue = mappingFunction.apply(key)) != null\\n     *         \u0026\u0026 (oldValue = map.putIfAbsent(key, newValue)) == null)\\n     *   ? newValue\\n     *   : oldValue;}\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eThis implementation assumes that the ConcurrentMap cannot contain null\\n     * values and {@code get()} returning null unambiguously means the key is\\n     * absent. Implementations which support null values \u003cstrong\u003emust\u003c/strong\u003e\\n     * override this default implementation.\\n     *\\n     * @throws UnsupportedOperationException {@inheritDoc}\\n     * @throws ClassCastException {@inheritDoc}\\n     * @throws NullPointerException {@inheritDoc}\\n     * @throws IllegalArgumentException {@inheritDoc}\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "java.util.concurrent.ConcurrentMap", "label": "java.util.concurrent.ConcurrentMap", "shape": "dot", "title": "{\u0027type\u0027: \u0027class\u0027, \u0027comment\u0027: \u0027\\n * A {@link Map} providing thread safety and atomicity guarantees.\\n *\\n * \u003cp\u003eTo maintain the specified guarantees, default implementations of\\n * methods including {@link #putIfAbsent} inherited from {@link Map}\\n * must be overridden by implementations of this interface. Similarly,\\n * implementations of the collections returned by methods {@link\\n * #keySet}, {@link #values}, and {@link #entrySet} must override\\n * methods such as {@code removeIf} when necessary to\\n * preserve atomicity guarantees.\\n *\\n * \u003cp\u003eMemory consistency effects: As with other concurrent\\n * collections, actions in a thread prior to placing an object into a\\n * {@code ConcurrentMap} as a key or value\\n * \u003ca href=\"package-summary.html#MemoryVisibility\"\u003e\u003ci\u003ehappen-before\u003c/i\u003e\u003c/a\u003e\\n * actions subsequent to the access or removal of that object from\\n * the {@code ConcurrentMap} in another thread.\\n *\\n * \u003cp\u003eThis interface is a member of the\\n * \u003ca href=\"{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework\"\u003e\\n * Java Collections Framework\u003c/a\u003e.\\n *\\n * @since 1.5\\n * @author Doug Lea\\n * @param \u003cK\u003e the type of keys maintained by this map\\n * @param \u003cV\u003e the type of mapped values\\n \u0027}"}, {"color": "#97c2fc", "id": " V computeIfPresent(K key, BiFunction\u003c? super K, ? super V, ? extends V\u003e remappingFunction)", "label": " V computeIfPresent(K key, BiFunction\u003c? super K, ? super V, ? extends V\u003e remappingFunction)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * If the value for the specified key is present and non-null, attempts to\\n     * compute a new mapping given the key and its current mapped value.\\n     *\\n     * \u003cp\u003eIf the remapping function returns {@code null}, the mapping is removed.\\n     * If the remapping function itself throws an (unchecked) exception, the\\n     * exception is rethrown, and the current mapping is left unchanged.\\n     *\\n     * \u003cp\u003eThe remapping function should not modify this map during computation.\\n     *\\n     * @implSpec\\n     * The default implementation is equivalent to performing the following\\n     * steps for this {@code map}, then returning the current value or\\n     * {@code null} if now absent:\\n     *\\n     * \u003cpre\u003e {@code\\n     * if (map.get(key) != null) {\\n     *     V oldValue = map.get(key);\\n     *     V newValue = remappingFunction.apply(key, oldValue);\\n     *     if (newValue != null)\\n     *         map.put(key, newValue);\\n     *     else\\n     *         map.remove(key);\\n     * }\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eThe default implementation makes no guarantees about detecting if the\\n     * remapping function modifies this map during computation and, if\\n     * appropriate, reporting an error. Non-concurrent implementations should\\n     * override this method and, on a best-effort basis, throw a\\n     * {@code ConcurrentModificationException} if it is detected that the\\n     * remapping function modifies this map during computation. Concurrent\\n     * implementations should override this method and, on a best-effort basis,\\n     * throw an {@code IllegalStateException} if it is detected that the\\n     * remapping function modifies this map during computation and as a result\\n     * computation would never complete.\\n     *\\n     * \u003cp\u003eThe default implementation makes no guarantees about synchronization\\n     * or atomicity properties of this method. Any implementation providing\\n     * atomicity guarantees must override this method and document its\\n     * concurrency properties. In particular, all implementations of\\n     * subinterface {@link java.util.concurrent.ConcurrentMap} must document\\n     * whether the remapping function is applied once atomically only if the\\n     * value is not present.\\n     *\\n     * @param key key with which the specified value is to be associated\\n     * @param remappingFunction the remapping function to compute a value\\n     * @return the new value associated with the specified key, or null if none\\n     * @throws NullPointerException if the specified key is null and\\n     *         this map does not support null keys, or the\\n     *         remappingFunction is null\\n     * @throws UnsupportedOperationException if the {@code put} operation\\n     *         is not supported by this map\\n     *         (\u003ca href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     * @throws ClassCastException if the class of the specified key or value\\n     *         prevents it from being stored in this map\\n     *         (\u003ca href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     * @throws IllegalArgumentException if some property of the specified key\\n     *         or value prevents it from being stored in this map\\n     *         (\u003ca href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": " V compute(K key, BiFunction\u003c? super K, ? super V, ? extends V\u003e remappingFunction)", "label": " V compute(K key, BiFunction\u003c? super K, ? super V, ? extends V\u003e remappingFunction)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Attempts to compute a mapping for the specified key and its current\\n     * mapped value (or {@code null} if there is no current mapping). For\\n     * example, to either create or append a {@code String} msg to a value\\n     * mapping:\\n     *\\n     * \u003cpre\u003e {@code\\n     * map.compute(key, (k, v) -\u003e (v == null) ? msg : v.concat(msg))}\u003c/pre\u003e\\n     * (Method {@link #merge merge()} is often simpler to use for such purposes.)\\n     *\\n     * \u003cp\u003eIf the remapping function returns {@code null}, the mapping is removed\\n     * (or remains absent if initially absent).  If the remapping function\\n     * itself throws an (unchecked) exception, the exception is rethrown, and\\n     * the current mapping is left unchanged.\\n     *\\n     * \u003cp\u003eThe remapping function should not modify this map during computation.\\n     *\\n     * @implSpec\\n     * The default implementation is equivalent to performing the following\\n     * steps for this {@code map}:\\n     *\\n     * \u003cpre\u003e {@code\\n     * V oldValue = map.get(key);\\n     * V newValue = remappingFunction.apply(key, oldValue);\\n     * if (newValue != null) {\\n     *     map.put(key, newValue);\\n     * } else if (oldValue != null || map.containsKey(key)) {\\n     *     map.remove(key);\\n     * }\\n     * return newValue;\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eThe default implementation makes no guarantees about detecting if the\\n     * remapping function modifies this map during computation and, if\\n     * appropriate, reporting an error. Non-concurrent implementations should\\n     * override this method and, on a best-effort basis, throw a\\n     * {@code ConcurrentModificationException} if it is detected that the\\n     * remapping function modifies this map during computation. Concurrent\\n     * implementations should override this method and, on a best-effort basis,\\n     * throw an {@code IllegalStateException} if it is detected that the\\n     * remapping function modifies this map during computation and as a result\\n     * computation would never complete.\\n     *\\n     * \u003cp\u003eThe default implementation makes no guarantees about synchronization\\n     * or atomicity properties of this method. Any implementation providing\\n     * atomicity guarantees must override this method and document its\\n     * concurrency properties. In particular, all implementations of\\n     * subinterface {@link java.util.concurrent.ConcurrentMap} must document\\n     * whether the remapping function is applied once atomically only if the\\n     * value is not present.\\n     *\\n     * @param key key with which the specified value is to be associated\\n     * @param remappingFunction the remapping function to compute a value\\n     * @return the new value associated with the specified key, or null if none\\n     * @throws NullPointerException if the specified key is null and\\n     *         this map does not support null keys, or the\\n     *         remappingFunction is null\\n     * @throws UnsupportedOperationException if the {@code put} operation\\n     *         is not supported by this map\\n     *         (\u003ca href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     * @throws ClassCastException if the class of the specified key or value\\n     *         prevents it from being stored in this map\\n     *         (\u003ca href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     * @throws IllegalArgumentException if some property of the specified key\\n     *         or value prevents it from being stored in this map\\n     *         (\u003ca href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": " V merge(K key, V value, BiFunction\u003c? super V, ? super V, ? extends V\u003e remappingFunction)", "label": " V merge(K key, V value, BiFunction\u003c? super V, ? super V, ? extends V\u003e remappingFunction)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * If the specified key is not already associated with a value or is\\n     * associated with null, associates it with the given non-null value.\\n     * Otherwise, replaces the associated value with the results of the given\\n     * remapping function, or removes if the result is {@code null}. This\\n     * method may be of use when combining multiple mapped values for a key.\\n     * For example, to either create or append a {@code String msg} to a\\n     * value mapping:\\n     *\\n     * \u003cpre\u003e {@code\\n     * map.merge(key, msg, String::concat)\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eIf the remapping function returns {@code null}, the mapping is removed.\\n     * If the remapping function itself throws an (unchecked) exception, the\\n     * exception is rethrown, and the current mapping is left unchanged.\\n     *\\n     * \u003cp\u003eThe remapping function should not modify this map during computation.\\n     *\\n     * @implSpec\\n     * The default implementation is equivalent to performing the following\\n     * steps for this {@code map}, then returning the current value or\\n     * {@code null} if absent:\\n     *\\n     * \u003cpre\u003e {@code\\n     * V oldValue = map.get(key);\\n     * V newValue = (oldValue == null) ? value :\\n     *              remappingFunction.apply(oldValue, value);\\n     * if (newValue == null)\\n     *     map.remove(key);\\n     * else\\n     *     map.put(key, newValue);\\n     * }\u003c/pre\u003e\\n     *\\n     * \u003cp\u003eThe default implementation makes no guarantees about detecting if the\\n     * remapping function modifies this map during computation and, if\\n     * appropriate, reporting an error. Non-concurrent implementations should\\n     * override this method and, on a best-effort basis, throw a\\n     * {@code ConcurrentModificationException} if it is detected that the\\n     * remapping function modifies this map during computation. Concurrent\\n     * implementations should override this method and, on a best-effort basis,\\n     * throw an {@code IllegalStateException} if it is detected that the\\n     * remapping function modifies this map during computation and as a result\\n     * computation would never complete.\\n     *\\n     * \u003cp\u003eThe default implementation makes no guarantees about synchronization\\n     * or atomicity properties of this method. Any implementation providing\\n     * atomicity guarantees must override this method and document its\\n     * concurrency properties. In particular, all implementations of\\n     * subinterface {@link java.util.concurrent.ConcurrentMap} must document\\n     * whether the remapping function is applied once atomically only if the\\n     * value is not present.\\n     *\\n     * @param key key with which the resulting value is to be associated\\n     * @param value the non-null value to be merged with the existing value\\n     *        associated with the key or, if no existing value or a null value\\n     *        is associated with the key, to be associated with the key\\n     * @param remappingFunction the remapping function to recompute a value if\\n     *        present\\n     * @return the new value associated with the specified key, or null if no\\n     *         value is associated with the key\\n     * @throws UnsupportedOperationException if the {@code put} operation\\n     *         is not supported by this map\\n     *         (\u003ca href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     * @throws ClassCastException if the class of the specified key or value\\n     *         prevents it from being stored in this map\\n     *         (\u003ca href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     * @throws IllegalArgumentException if some property of the specified key\\n     *         or value prevents it from being stored in this map\\n     *         (\u003ca href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\"\u003eoptional\u003c/a\u003e)\\n     * @throws NullPointerException if the specified key is null and this map\\n     *         does not support null keys or the value or remappingFunction is\\n     *         null\\n     * @since 1.8\\n     \u0027}"}, {"color": "#97c2fc", "id": "merge", "label": "merge", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " static Map\u003cK, V\u003e of()", "label": " static Map\u003cK, V\u003e of()", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable map containing zero mappings.\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Maps\u003c/a\u003e for details.\\n     *\\n     * @param \u003cK\u003e the {@code Map}\\\u0027s key type\\n     * @param \u003cV\u003e the {@code Map}\\\u0027s value type\\n     * @return an empty {@code Map}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static Map\u003cK, V\u003e of(K k1, V v1)", "label": " static Map\u003cK, V\u003e of(K k1, V v1)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable map containing a single mapping.\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Maps\u003c/a\u003e for details.\\n     *\\n     * @param \u003cK\u003e the {@code Map}\\\u0027s key type\\n     * @param \u003cV\u003e the {@code Map}\\\u0027s value type\\n     * @param k1 the mapping\\\u0027s key\\n     * @param v1 the mapping\\\u0027s value\\n     * @return a {@code Map} containing the specified mapping\\n     * @throws NullPointerException if the key or the value is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2)", "label": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable map containing two mappings.\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Maps\u003c/a\u003e for details.\\n     *\\n     * @param \u003cK\u003e the {@code Map}\\\u0027s key type\\n     * @param \u003cV\u003e the {@code Map}\\\u0027s value type\\n     * @param k1 the first mapping\\\u0027s key\\n     * @param v1 the first mapping\\\u0027s value\\n     * @param k2 the second mapping\\\u0027s key\\n     * @param v2 the second mapping\\\u0027s value\\n     * @return a {@code Map} containing the specified mappings\\n     * @throws IllegalArgumentException if the keys are duplicates\\n     * @throws NullPointerException if any key or value is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2, K k3, V v3)", "label": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2, K k3, V v3)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable map containing three mappings.\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Maps\u003c/a\u003e for details.\\n     *\\n     * @param \u003cK\u003e the {@code Map}\\\u0027s key type\\n     * @param \u003cV\u003e the {@code Map}\\\u0027s value type\\n     * @param k1 the first mapping\\\u0027s key\\n     * @param v1 the first mapping\\\u0027s value\\n     * @param k2 the second mapping\\\u0027s key\\n     * @param v2 the second mapping\\\u0027s value\\n     * @param k3 the third mapping\\\u0027s key\\n     * @param v3 the third mapping\\\u0027s value\\n     * @return a {@code Map} containing the specified mappings\\n     * @throws IllegalArgumentException if there are any duplicate keys\\n     * @throws NullPointerException if any key or value is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4)", "label": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable map containing four mappings.\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Maps\u003c/a\u003e for details.\\n     *\\n     * @param \u003cK\u003e the {@code Map}\\\u0027s key type\\n     * @param \u003cV\u003e the {@code Map}\\\u0027s value type\\n     * @param k1 the first mapping\\\u0027s key\\n     * @param v1 the first mapping\\\u0027s value\\n     * @param k2 the second mapping\\\u0027s key\\n     * @param v2 the second mapping\\\u0027s value\\n     * @param k3 the third mapping\\\u0027s key\\n     * @param v3 the third mapping\\\u0027s value\\n     * @param k4 the fourth mapping\\\u0027s key\\n     * @param v4 the fourth mapping\\\u0027s value\\n     * @return a {@code Map} containing the specified mappings\\n     * @throws IllegalArgumentException if there are any duplicate keys\\n     * @throws NullPointerException if any key or value is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5)", "label": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable map containing five mappings.\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Maps\u003c/a\u003e for details.\\n     *\\n     * @param \u003cK\u003e the {@code Map}\\\u0027s key type\\n     * @param \u003cV\u003e the {@code Map}\\\u0027s value type\\n     * @param k1 the first mapping\\\u0027s key\\n     * @param v1 the first mapping\\\u0027s value\\n     * @param k2 the second mapping\\\u0027s key\\n     * @param v2 the second mapping\\\u0027s value\\n     * @param k3 the third mapping\\\u0027s key\\n     * @param v3 the third mapping\\\u0027s value\\n     * @param k4 the fourth mapping\\\u0027s key\\n     * @param v4 the fourth mapping\\\u0027s value\\n     * @param k5 the fifth mapping\\\u0027s key\\n     * @param v5 the fifth mapping\\\u0027s value\\n     * @return a {@code Map} containing the specified mappings\\n     * @throws IllegalArgumentException if there are any duplicate keys\\n     * @throws NullPointerException if any key or value is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6)", "label": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable map containing six mappings.\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Maps\u003c/a\u003e for details.\\n     *\\n     * @param \u003cK\u003e the {@code Map}\\\u0027s key type\\n     * @param \u003cV\u003e the {@code Map}\\\u0027s value type\\n     * @param k1 the first mapping\\\u0027s key\\n     * @param v1 the first mapping\\\u0027s value\\n     * @param k2 the second mapping\\\u0027s key\\n     * @param v2 the second mapping\\\u0027s value\\n     * @param k3 the third mapping\\\u0027s key\\n     * @param v3 the third mapping\\\u0027s value\\n     * @param k4 the fourth mapping\\\u0027s key\\n     * @param v4 the fourth mapping\\\u0027s value\\n     * @param k5 the fifth mapping\\\u0027s key\\n     * @param v5 the fifth mapping\\\u0027s value\\n     * @param k6 the sixth mapping\\\u0027s key\\n     * @param v6 the sixth mapping\\\u0027s value\\n     * @return a {@code Map} containing the specified mappings\\n     * @throws IllegalArgumentException if there are any duplicate keys\\n     * @throws NullPointerException if any key or value is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7)", "label": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable map containing seven mappings.\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Maps\u003c/a\u003e for details.\\n     *\\n     * @param \u003cK\u003e the {@code Map}\\\u0027s key type\\n     * @param \u003cV\u003e the {@code Map}\\\u0027s value type\\n     * @param k1 the first mapping\\\u0027s key\\n     * @param v1 the first mapping\\\u0027s value\\n     * @param k2 the second mapping\\\u0027s key\\n     * @param v2 the second mapping\\\u0027s value\\n     * @param k3 the third mapping\\\u0027s key\\n     * @param v3 the third mapping\\\u0027s value\\n     * @param k4 the fourth mapping\\\u0027s key\\n     * @param v4 the fourth mapping\\\u0027s value\\n     * @param k5 the fifth mapping\\\u0027s key\\n     * @param v5 the fifth mapping\\\u0027s value\\n     * @param k6 the sixth mapping\\\u0027s key\\n     * @param v6 the sixth mapping\\\u0027s value\\n     * @param k7 the seventh mapping\\\u0027s key\\n     * @param v7 the seventh mapping\\\u0027s value\\n     * @return a {@code Map} containing the specified mappings\\n     * @throws IllegalArgumentException if there are any duplicate keys\\n     * @throws NullPointerException if any key or value is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8)", "label": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable map containing eight mappings.\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Maps\u003c/a\u003e for details.\\n     *\\n     * @param \u003cK\u003e the {@code Map}\\\u0027s key type\\n     * @param \u003cV\u003e the {@code Map}\\\u0027s value type\\n     * @param k1 the first mapping\\\u0027s key\\n     * @param v1 the first mapping\\\u0027s value\\n     * @param k2 the second mapping\\\u0027s key\\n     * @param v2 the second mapping\\\u0027s value\\n     * @param k3 the third mapping\\\u0027s key\\n     * @param v3 the third mapping\\\u0027s value\\n     * @param k4 the fourth mapping\\\u0027s key\\n     * @param v4 the fourth mapping\\\u0027s value\\n     * @param k5 the fifth mapping\\\u0027s key\\n     * @param v5 the fifth mapping\\\u0027s value\\n     * @param k6 the sixth mapping\\\u0027s key\\n     * @param v6 the sixth mapping\\\u0027s value\\n     * @param k7 the seventh mapping\\\u0027s key\\n     * @param v7 the seventh mapping\\\u0027s value\\n     * @param k8 the eighth mapping\\\u0027s key\\n     * @param v8 the eighth mapping\\\u0027s value\\n     * @return a {@code Map} containing the specified mappings\\n     * @throws IllegalArgumentException if there are any duplicate keys\\n     * @throws NullPointerException if any key or value is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9)", "label": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable map containing nine mappings.\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Maps\u003c/a\u003e for details.\\n     *\\n     * @param \u003cK\u003e the {@code Map}\\\u0027s key type\\n     * @param \u003cV\u003e the {@code Map}\\\u0027s value type\\n     * @param k1 the first mapping\\\u0027s key\\n     * @param v1 the first mapping\\\u0027s value\\n     * @param k2 the second mapping\\\u0027s key\\n     * @param v2 the second mapping\\\u0027s value\\n     * @param k3 the third mapping\\\u0027s key\\n     * @param v3 the third mapping\\\u0027s value\\n     * @param k4 the fourth mapping\\\u0027s key\\n     * @param v4 the fourth mapping\\\u0027s value\\n     * @param k5 the fifth mapping\\\u0027s key\\n     * @param v5 the fifth mapping\\\u0027s value\\n     * @param k6 the sixth mapping\\\u0027s key\\n     * @param v6 the sixth mapping\\\u0027s value\\n     * @param k7 the seventh mapping\\\u0027s key\\n     * @param v7 the seventh mapping\\\u0027s value\\n     * @param k8 the eighth mapping\\\u0027s key\\n     * @param v8 the eighth mapping\\\u0027s value\\n     * @param k9 the ninth mapping\\\u0027s key\\n     * @param v9 the ninth mapping\\\u0027s value\\n     * @return a {@code Map} containing the specified mappings\\n     * @throws IllegalArgumentException if there are any duplicate keys\\n     * @throws NullPointerException if any key or value is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10)", "label": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable map containing ten mappings.\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Maps\u003c/a\u003e for details.\\n     *\\n     * @param \u003cK\u003e the {@code Map}\\\u0027s key type\\n     * @param \u003cV\u003e the {@code Map}\\\u0027s value type\\n     * @param k1 the first mapping\\\u0027s key\\n     * @param v1 the first mapping\\\u0027s value\\n     * @param k2 the second mapping\\\u0027s key\\n     * @param v2 the second mapping\\\u0027s value\\n     * @param k3 the third mapping\\\u0027s key\\n     * @param v3 the third mapping\\\u0027s value\\n     * @param k4 the fourth mapping\\\u0027s key\\n     * @param v4 the fourth mapping\\\u0027s value\\n     * @param k5 the fifth mapping\\\u0027s key\\n     * @param v5 the fifth mapping\\\u0027s value\\n     * @param k6 the sixth mapping\\\u0027s key\\n     * @param v6 the sixth mapping\\\u0027s value\\n     * @param k7 the seventh mapping\\\u0027s key\\n     * @param v7 the seventh mapping\\\u0027s value\\n     * @param k8 the eighth mapping\\\u0027s key\\n     * @param v8 the eighth mapping\\\u0027s value\\n     * @param k9 the ninth mapping\\\u0027s key\\n     * @param v9 the ninth mapping\\\u0027s value\\n     * @param k10 the tenth mapping\\\u0027s key\\n     * @param v10 the tenth mapping\\\u0027s value\\n     * @return a {@code Map} containing the specified mappings\\n     * @throws IllegalArgumentException if there are any duplicate keys\\n     * @throws NullPointerException if any key or value is {@code null}\\n     *\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": " static Map\u003cK, V\u003e ofEntries(Entry\u003c? extends K, ? extends V\u003e... entries)", "label": " static Map\u003cK, V\u003e ofEntries(Entry\u003c? extends K, ? extends V\u003e... entries)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable map containing keys and values extracted from the given entries.\\n     * The entries themselves are not stored in the map.\\n     * See \u003ca href=\"#unmodifiable\"\u003eUnmodifiable Maps\u003c/a\u003e for details.\\n     *\\n     * @apiNote\\n     * It is convenient to create the map entries using the {@link Map#entry Map.entry()} method.\\n     * For example,\\n     *\\n     * \u003cpre\u003e{@code\\n     *     import static java.util.Map.entry;\\n     *\\n     *     Map\u003cInteger,String\u003e map = Map.ofEntries(\\n     *         entry(1, \"a\"),\\n     *         entry(2, \"b\"),\\n     *         entry(3, \"c\"),\\n     *         ...\\n     *         entry(26, \"z\"));\\n     * }\u003c/pre\u003e\\n     *\\n     * @param \u003cK\u003e the {@code Map}\\\u0027s key type\\n     * @param \u003cV\u003e the {@code Map}\\\u0027s value type\\n     * @param entries {@code Map.Entry}s containing the keys and values from which the map is populated\\n     * @return a {@code Map} containing the specified mappings\\n     * @throws IllegalArgumentException if there are any duplicate keys\\n     * @throws NullPointerException if any entry, key, or value is {@code null}, or if\\n     *         the {@code entries} array is {@code null}\\n     *\\n     * @see Map#entry Map.entry()\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "entry", "label": "entry", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": " static Entry\u003cK, V\u003e entry(K k, V v)", "label": " static Entry\u003cK, V\u003e entry(K k, V v)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an unmodifiable {@link Entry} containing the given key and value.\\n     * These entries are suitable for populating {@code Map} instances using the\\n     * {@link Map#ofEntries Map.ofEntries()} method.\\n     * The {@code Entry} instances created by this method have the following characteristics:\\n     *\\n     * \u003cul\u003e\\n     * \u003cli\u003eThey disallow {@code null} keys and values. Attempts to create them using a {@code null}\\n     * key or value result in {@code NullPointerException}.\\n     * \u003cli\u003eThey are unmodifiable. Calls to {@link Entry#setValue Entry.setValue()}\\n     * on a returned {@code Entry} result in {@code UnsupportedOperationException}.\\n     * \u003cli\u003eThey are not serializable.\\n     * \u003cli\u003eThey are \u003ca href=\"../lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e.\\n     * Programmers should treat instances that are {@linkplain #equals(Object) equal}\\n     * as interchangeable and should not use them for synchronization, or\\n     * unpredictable behavior may occur. For example, in a future release,\\n     * synchronization may fail. Callers should make no assumptions\\n     * about the identity of the returned instances. This method is free to\\n     * create new instances or reuse existing ones.\\n     * \u003c/ul\u003e\\n     *\\n     * @apiNote\\n     * For a serializable {@code Entry}, see {@link AbstractMap.SimpleEntry} or\\n     * {@link AbstractMap.SimpleImmutableEntry}.\\n     *\\n     * @param \u003cK\u003e the key\\\u0027s type\\n     * @param \u003cV\u003e the value\\\u0027s type\\n     * @param k the key\\n     * @param v the value\\n     * @return an {@code Entry} containing the specified key and value\\n     * @throws NullPointerException if the key or value is {@code null}\\n     *\\n     * @see Map#ofEntries Map.ofEntries()\\n     * @since 9\\n     \u0027}"}, {"color": "#97c2fc", "id": "setValue", "label": "setValue", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "Entry", "label": "Entry", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "AbstractMap.SimpleImmutableEntry", "label": "AbstractMap.SimpleImmutableEntry", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": "ofEntries", "label": "ofEntries", "shape": "dot", "title": "{\u0027type\u0027: \u0027link-shadow\u0027, \u0027comment\u0027: \u0027No comment available\u0027}"}, {"color": "#97c2fc", "id": "AbstractMap.SimpleEntry", "label": "AbstractMap.SimpleEntry", "shape": "dot", "title": "{}"}, {"color": "#97c2fc", "id": " static Map\u003cK, V\u003e copyOf(Map\u003c? extends K, ? extends V\u003e map)", "label": " static Map\u003cK, V\u003e copyOf(Map\u003c? extends K, ? extends V\u003e map)", "shape": "dot", "title": "{\u0027type\u0027: \u0027method\u0027, \u0027comment\u0027: \u0027\\n     * Returns an \u003ca href=\"#unmodifiable\"\u003eunmodifiable Map\u003c/a\u003e containing the entries\\n     * of the given Map. The given Map must not be null, and it must not contain any\\n     * null keys or values. If the given Map is subsequently modified, the returned\\n     * Map will not reflect such modifications.\\n     *\\n     * @implNote\\n     * If the given Map is an \u003ca href=\"#unmodifiable\"\u003eunmodifiable Map\u003c/a\u003e,\\n     * calling copyOf will generally not create a copy.\\n     *\\n     * @param \u003cK\u003e the {@code Map}\\\u0027s key type\\n     * @param \u003cV\u003e the {@code Map}\\\u0027s value type\\n     * @param map a {@code Map} from which entries are drawn, must be non-null\\n     * @return a {@code Map} containing the entries of the given {@code Map}\\n     * @throws NullPointerException if map is null, or if it contains any null keys or values\\n     * @since 10\\n     \u0027}"}]);
                  edges = new vis.DataSet([{"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int size()"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean isEmpty()"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean containsKey(Object key)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean containsValue(Object value)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " V get(Object key)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " V put(K key, V value)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " V remove(Object key)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void putAll(Map\u003c? extends K, ? extends V\u003e m)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void clear()"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Set\u003cK\u003e keySet()"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Collection\u003cV\u003e values()"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Set\u003cMap.Entry\u003cK, V\u003e\u003e entrySet()"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean equals(Object o)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int hashCode()"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " V getOrDefault(Object key, V defaultValue)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void forEach(BiConsumer\u003c? super K, ? super V\u003e action)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void replaceAll(BiFunction\u003c? super K, ? super V, ? extends V\u003e function)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " V putIfAbsent(K key, V value)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean remove(Object key, Object value)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean replace(K key, V oldValue, V newValue)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " V replace(K key, V value)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " V computeIfAbsent(K key, Function\u003c? super K, ? extends V\u003e mappingFunction)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " V computeIfPresent(K key, BiFunction\u003c? super K, ? super V, ? extends V\u003e remappingFunction)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " V compute(K key, BiFunction\u003c? super K, ? super V, ? extends V\u003e remappingFunction)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " V merge(K key, V value, BiFunction\u003c? super V, ? super V, ? extends V\u003e remappingFunction)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Map\u003cK, V\u003e of()"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Map\u003cK, V\u003e of(K k1, V v1)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2, K k3, V v3)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Map\u003cK, V\u003e of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Map\u003cK, V\u003e ofEntries(Entry\u003c? extends K, ? extends V\u003e... entries)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Entry\u003cK, V\u003e entry(K k, V v)"}, {"arrows": "to", "from": "java.util.Map", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Map\u003cK, V\u003e copyOf(Map\u003c? extends K, ? extends V\u003e map)"}, {"arrows": "to", "from": " boolean isEmpty()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "length()"}, {"arrows": "to", "from": " V get(Object key)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "containsKeycontainsKey"}, {"arrows": "to", "from": " V put(K key, V value)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "containsKey(Object)"}, {"arrows": "to", "from": " void putAll(Map\u003c? extends K, ? extends V\u003e m)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "put(Object"}, {"arrows": "to", "from": " Set\u003cK\u003e keySet()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Set"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int size()"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean isEmpty()"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean contains(Object o)"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Iterator\u003cE\u003e iterator()"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Object[] toArray()"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " T[] toArray(T[] a)"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean add(E e)"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean remove(Object o)"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean containsAll(Collection\u003c?\u003e c)"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean addAll(Collection\u003c? extends E\u003e c)"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean retainAll(Collection\u003c?\u003e c)"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean removeAll(Collection\u003c?\u003e c)"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void clear()"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean equals(Object o)"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int hashCode()"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Spliterator\u003cE\u003e spliterator()"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Set\u003cE\u003e of()"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Set\u003cE\u003e of(E e1)"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Set\u003cE\u003e of(E e1, E e2)"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Set\u003cE\u003e of(E e1, E e2, E e3)"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Set\u003cE\u003e of(E e1, E e2, E e3, E e4)"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Set\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5)"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Set\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6)"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Set\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6, E e7)"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Set\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Set\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Set\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Set\u003cE\u003e of(E... elements)"}, {"arrows": "to", "from": "java.util.Set", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Set\u003cE\u003e copyOf(Collection\u003c? extends E\u003e coll)"}, {"arrows": "to", "from": " Object[] toArray()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toArray(IntFunction)"}, {"arrows": "to", "from": " Object[] toArray()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toArray(Object"}, {"arrows": "to", "from": " T[] toArray(T[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toArray()"}, {"arrows": "to", "from": " T[] toArray(T[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toArray(IntFunction)"}, {"arrows": "to", "from": " T[] toArray(T[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Collection"}, {"arrows": "to", "from": " T[] toArray(T[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.List"}, {"arrows": "to", "from": " boolean add(E e)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "add"}, {"arrows": "to", "from": " boolean add(E e)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Collection"}, {"arrows": "to", "from": "java.util.Collection", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int size()"}, {"arrows": "to", "from": "java.util.Collection", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean isEmpty()"}, {"arrows": "to", "from": "java.util.Collection", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean contains(Object o)"}, {"arrows": "to", "from": "java.util.Collection", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Iterator\u003cE\u003e iterator()"}, {"arrows": "to", "from": "java.util.Collection", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Object[] toArray()"}, {"arrows": "to", "from": "java.util.Collection", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " T[] toArray(T[] a)"}, {"arrows": "to", "from": "java.util.Collection", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " T[] toArray(IntFunction\u003cT[]\u003e generator)"}, {"arrows": "to", "from": "java.util.Collection", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean add(E e)"}, {"arrows": "to", "from": "java.util.Collection", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean remove(Object o)"}, {"arrows": "to", "from": "java.util.Collection", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean containsAll(Collection\u003c?\u003e c)"}, {"arrows": "to", "from": "java.util.Collection", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean addAll(Collection\u003c? extends E\u003e c)"}, {"arrows": "to", "from": "java.util.Collection", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean removeAll(Collection\u003c?\u003e c)"}, {"arrows": "to", "from": "java.util.Collection", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean removeIf(Predicate\u003c? super E\u003e filter)"}, {"arrows": "to", "from": "java.util.Collection", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean retainAll(Collection\u003c?\u003e c)"}, {"arrows": "to", "from": "java.util.Collection", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void clear()"}, {"arrows": "to", "from": "java.util.Collection", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean equals(Object o)"}, {"arrows": "to", "from": "java.util.Collection", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int hashCode()"}, {"arrows": "to", "from": "java.util.Collection", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Spliterator\u003cE\u003e spliterator()"}, {"arrows": "to", "from": "java.util.Collection", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Stream\u003cE\u003e stream()"}, {"arrows": "to", "from": "java.util.Collection", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Stream\u003cE\u003e parallelStream()"}, {"arrows": "to", "from": " T[] toArray(IntFunction\u003cT[]\u003e generator)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toArray(Object"}, {"arrows": "to", "from": " T[] toArray(IntFunction\u003cT[]\u003e generator)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toArray()"}, {"arrows": "to", "from": " boolean removeIf(Predicate\u003c? super E\u003e filter)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "iterator"}, {"arrows": "to", "from": " boolean removeIf(Predicate\u003c? super E\u003e filter)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "remove()"}, {"arrows": "to", "from": "java.util.Iterator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean hasNext()"}, {"arrows": "to", "from": "java.util.Iterator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " E next()"}, {"arrows": "to", "from": "java.util.Iterator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void remove()"}, {"arrows": "to", "from": "java.util.Iterator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void forEachRemaining(Consumer\u003c? super E\u003e action)"}, {"arrows": "to", "from": " boolean hasNext()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "next"}, {"arrows": "to", "from": " boolean hasNext()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.ListIterator"}, {"arrows": "to", "from": " E next()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "previous"}, {"arrows": "to", "from": " void remove()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "next"}, {"arrows": "to", "from": " void remove()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "forEachRemaining"}, {"arrows": "to", "from": " void remove()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UnsupportedOperationException"}, {"arrows": "to", "from": " void remove()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "previous"}, {"arrows": "to", "from": " void remove()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.ListIterator"}, {"arrows": "to", "from": " void remove()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "add"}, {"arrows": "to", "from": " void forEachRemaining(Consumer\u003c? super E\u003e action)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "remove"}, {"arrows": "to", "from": " int hashCode()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hashCode"}, {"arrows": "to", "from": " int hashCode()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hashCodeObject.hashCode"}, {"arrows": "to", "from": " int hashCode()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Set"}, {"arrows": "to", "from": " int hashCode()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Map"}, {"arrows": "to", "from": " Spliterator\u003cE\u003e spliterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SIZED"}, {"arrows": "to", "from": " Spliterator\u003cE\u003e spliterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.RandomAccess"}, {"arrows": "to", "from": " Spliterator\u003cE\u003e spliterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "modCount"}, {"arrows": "to", "from": " Spliterator\u003cE\u003e spliterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Spliterator"}, {"arrows": "to", "from": " Spliterator\u003cE\u003e spliterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.AbstractList"}, {"arrows": "to", "from": " Spliterator\u003cE\u003e spliterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "get"}, {"arrows": "to", "from": " Spliterator\u003cE\u003e spliterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SUBSIZED"}, {"arrows": "to", "from": " Spliterator\u003cE\u003e spliterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ORDERED"}, {"arrows": "to", "from": " Spliterator\u003cE\u003e spliterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "emptySpliterator()"}, {"arrows": "to", "from": " Spliterator\u003cE\u003e spliterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "parallelStream()"}, {"arrows": "to", "from": " Spliterator\u003cE\u003e spliterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "stream()"}, {"arrows": "to", "from": " Spliterator\u003cE\u003e spliterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "DISTINCT"}, {"arrows": "to", "from": "java.util.Spliterator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean tryAdvance(Consumer\u003c? super T\u003e action)"}, {"arrows": "to", "from": "java.util.Spliterator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void forEachRemaining(Consumer\u003c? super T\u003e action)"}, {"arrows": "to", "from": "java.util.Spliterator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Spliterator\u003cT\u003e trySplit()"}, {"arrows": "to", "from": "java.util.Spliterator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " long estimateSize()"}, {"arrows": "to", "from": "java.util.Spliterator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " long getExactSizeIfKnown()"}, {"arrows": "to", "from": "java.util.Spliterator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int characteristics()"}, {"arrows": "to", "from": "java.util.Spliterator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean hasCharacteristics(int characteristics)"}, {"arrows": "to", "from": "java.util.Spliterator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Comparator\u003c? super T\u003e getComparator()"}, {"arrows": "to", "from": " boolean tryAdvance(Consumer\u003c? super T\u003e action)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ORDERED"}, {"arrows": "to", "from": " void forEachRemaining(Consumer\u003c? super T\u003e action)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "tryAdvance"}, {"arrows": "to", "from": " void forEachRemaining(Consumer\u003c? super T\u003e action)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ORDERED"}, {"arrows": "to", "from": " Spliterator\u003cT\u003e trySplit()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ORDERED"}, {"arrows": "to", "from": " long estimateSize()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MAX_VALUE"}, {"arrows": "to", "from": " long estimateSize()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SUBSIZED"}, {"arrows": "to", "from": " long estimateSize()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "trySplit"}, {"arrows": "to", "from": " long estimateSize()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SIZED"}, {"arrows": "to", "from": " long estimateSize()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "forEachRemaining"}, {"arrows": "to", "from": " long getExactSizeIfKnown()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "estimateSize()"}, {"arrows": "to", "from": " long getExactSizeIfKnown()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SIZED"}, {"arrows": "to", "from": " int characteristics()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CONCURRENT"}, {"arrows": "to", "from": " int characteristics()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SUBSIZED"}, {"arrows": "to", "from": " int characteristics()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "DISTINCT"}, {"arrows": "to", "from": " int characteristics()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ORDERED"}, {"arrows": "to", "from": " int characteristics()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SORTED"}, {"arrows": "to", "from": " int characteristics()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NONNULL"}, {"arrows": "to", "from": " int characteristics()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SIZED"}, {"arrows": "to", "from": " int characteristics()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "IMMUTABLE"}, {"arrows": "to", "from": " boolean hasCharacteristics(int characteristics)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "characteristics"}, {"arrows": "to", "from": " Comparator\u003c? super T\u003e getComparator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "IllegalStateException"}, {"arrows": "to", "from": " Comparator\u003c? super T\u003e getComparator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SORTED"}, {"arrows": "to", "from": " Comparator\u003c? super T\u003e getComparator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Comparator"}, {"arrows": "to", "from": "java.util.Comparator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int compare(T o1, T o2)"}, {"arrows": "to", "from": "java.util.Comparator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean equals(Object obj)"}, {"arrows": "to", "from": "java.util.Comparator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Comparator\u003cT\u003e reversed()"}, {"arrows": "to", "from": "java.util.Comparator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Comparator\u003cT\u003e thenComparing(Comparator\u003c? super T\u003e other)"}, {"arrows": "to", "from": "java.util.Comparator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Comparator\u003cT\u003e thenComparing(Function\u003c? super T, ? extends U\u003e keyExtractor, Comparator\u003c? super U\u003e keyComparator)"}, {"arrows": "to", "from": "java.util.Comparator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Comparator\u003cT\u003e thenComparing(Function\u003c? super T, ? extends U\u003e keyExtractor)"}, {"arrows": "to", "from": "java.util.Comparator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Comparator\u003cT\u003e thenComparingInt(ToIntFunction\u003c? super T\u003e keyExtractor)"}, {"arrows": "to", "from": "java.util.Comparator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Comparator\u003cT\u003e thenComparingLong(ToLongFunction\u003c? super T\u003e keyExtractor)"}, {"arrows": "to", "from": "java.util.Comparator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Comparator\u003cT\u003e thenComparingDouble(ToDoubleFunction\u003c? super T\u003e keyExtractor)"}, {"arrows": "to", "from": "java.util.Comparator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Comparator\u003cT\u003e reverseOrder()"}, {"arrows": "to", "from": "java.util.Comparator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Comparator\u003cT\u003e naturalOrder()"}, {"arrows": "to", "from": "java.util.Comparator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Comparator\u003cT\u003e nullsFirst(Comparator\u003c? super T\u003e comparator)"}, {"arrows": "to", "from": "java.util.Comparator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Comparator\u003cT\u003e nullsLast(Comparator\u003c? super T\u003e comparator)"}, {"arrows": "to", "from": "java.util.Comparator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Comparator\u003cT\u003e comparing(Function\u003c? super T, ? extends U\u003e keyExtractor, Comparator\u003c? super U\u003e keyComparator)"}, {"arrows": "to", "from": "java.util.Comparator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Comparator\u003cT\u003e comparing(Function\u003c? super T, ? extends U\u003e keyExtractor)"}, {"arrows": "to", "from": "java.util.Comparator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Comparator\u003cT\u003e comparingInt(ToIntFunction\u003c? super T\u003e keyExtractor)"}, {"arrows": "to", "from": "java.util.Comparator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Comparator\u003cT\u003e comparingLong(ToLongFunction\u003c? super T\u003e keyExtractor)"}, {"arrows": "to", "from": "java.util.Comparator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Comparator\u003cT\u003e comparingDouble(ToDoubleFunction\u003c? super T\u003e keyExtractor)"}, {"arrows": "to", "from": " int compare(T o1, T o2)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "signumsignum"}, {"arrows": "to", "from": " boolean equals(Object obj)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(Object)"}, {"arrows": "to", "from": " boolean equals(Object obj)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "signum"}, {"arrows": "to", "from": " Comparator\u003cT\u003e thenComparing(Function\u003c? super T, ? extends U\u003e keyExtractor)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Comparable"}, {"arrows": "to", "from": "public static Comparator\u003cT\u003e reverseOrder()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Comparable"}, {"arrows": "to", "from": "public static Comparator\u003cT\u003e reverseOrder()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NullPointerException"}, {"arrows": "to", "from": "public static Comparator\u003cT\u003e naturalOrder()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Comparable"}, {"arrows": "to", "from": "public static Comparator\u003cT\u003e naturalOrder()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NullPointerException"}, {"arrows": "to", "from": "public static Comparator\u003cT\u003e comparing(Function\u003c? super T, ? extends U\u003e keyExtractor, Comparator\u003c? super U\u003e keyComparator)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Comparator"}, {"arrows": "to", "from": "public static Comparator\u003cT\u003e comparing(Function\u003c? super T, ? extends U\u003e keyExtractor)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Comparable"}, {"arrows": "to", "from": "public static Comparator\u003cT\u003e comparing(Function\u003c? super T, ? extends U\u003e keyExtractor)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.ComparableComparable"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator\u003cT\u003e emptySpliterator()"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator.OfInt emptyIntSpliterator()"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator.OfLong emptyLongSpliterator()"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator.OfDouble emptyDoubleSpliterator()"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator\u003cT\u003e spliterator(Object[] array, int additionalCharacteristics)"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator\u003cT\u003e spliterator(Object[] array, int fromIndex, int toIndex, int additionalCharacteristics)"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator.OfInt spliterator(int[] array, int additionalCharacteristics)"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator.OfInt spliterator(int[] array, int fromIndex, int toIndex, int additionalCharacteristics)"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator.OfLong spliterator(long[] array, int additionalCharacteristics)"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator.OfLong spliterator(long[] array, int fromIndex, int toIndex, int additionalCharacteristics)"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator.OfDouble spliterator(double[] array, int additionalCharacteristics)"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator.OfDouble spliterator(double[] array, int fromIndex, int toIndex, int additionalCharacteristics)"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void checkFromToBounds(int arrayLength, int origin, int fence)"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator\u003cT\u003e spliterator(Collection\u003c? extends T\u003e c, int characteristics)"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator\u003cT\u003e spliterator(Iterator\u003c? extends T\u003e iterator, long size, int characteristics)"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator\u003cT\u003e spliteratorUnknownSize(Iterator\u003c? extends T\u003e iterator, int characteristics)"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator.OfInt spliterator(PrimitiveIterator.OfInt iterator, long size, int characteristics)"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator.OfInt spliteratorUnknownSize(PrimitiveIterator.OfInt iterator, int characteristics)"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator.OfLong spliterator(PrimitiveIterator.OfLong iterator, long size, int characteristics)"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator.OfLong spliteratorUnknownSize(PrimitiveIterator.OfLong iterator, int characteristics)"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator.OfDouble spliterator(PrimitiveIterator.OfDouble iterator, long size, int characteristics)"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator.OfDouble spliteratorUnknownSize(PrimitiveIterator.OfDouble iterator, int characteristics)"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Iterator\u003cT\u003e iterator(Spliterator\u003c? extends T\u003e spliterator)"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static PrimitiveIterator.OfInt iterator(Spliterator.OfInt spliterator)"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static PrimitiveIterator.OfLong iterator(Spliterator.OfLong spliterator)"}, {"arrows": "to", "from": "java.util.Spliterators", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static PrimitiveIterator.OfDouble iterator(Spliterator.OfDouble spliterator)"}, {"arrows": "to", "from": "public static Spliterator\u003cT\u003e emptySpliterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SIZED"}, {"arrows": "to", "from": "public static Spliterator\u003cT\u003e emptySpliterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Spliterator"}, {"arrows": "to", "from": "public static Spliterator\u003cT\u003e emptySpliterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SUBSIZED"}, {"arrows": "to", "from": "public static Spliterator.OfInt emptyIntSpliterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SIZED"}, {"arrows": "to", "from": "public static Spliterator.OfInt emptyIntSpliterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Spliterator"}, {"arrows": "to", "from": "public static Spliterator.OfInt emptyIntSpliterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SUBSIZED"}, {"arrows": "to", "from": "public static Spliterator.OfLong emptyLongSpliterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SIZED"}, {"arrows": "to", "from": "public static Spliterator.OfLong emptyLongSpliterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Spliterator"}, {"arrows": "to", "from": "public static Spliterator.OfLong emptyLongSpliterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SUBSIZED"}, {"arrows": "to", "from": "public static Spliterator.OfDouble emptyDoubleSpliterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SIZED"}, {"arrows": "to", "from": "public static Spliterator.OfDouble emptyDoubleSpliterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Spliterator"}, {"arrows": "to", "from": "public static Spliterator.OfDouble emptyDoubleSpliterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SUBSIZED"}, {"arrows": "to", "from": "public static Spliterator\u003cT\u003e spliterator(Object[] array, int additionalCharacteristics)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "spliterator(Object"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void sort(int[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void sort(int[] a, int fromIndex, int toIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void sort(long[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void sort(long[] a, int fromIndex, int toIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void sort(short[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void sort(short[] a, int fromIndex, int toIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void sort(char[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void sort(char[] a, int fromIndex, int toIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void sort(byte[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void sort(byte[] a, int fromIndex, int toIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void sort(float[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void sort(float[] a, int fromIndex, int toIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void sort(double[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void sort(double[] a, int fromIndex, int toIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelSort(byte[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelSort(byte[] a, int fromIndex, int toIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelSort(char[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelSort(char[] a, int fromIndex, int toIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelSort(short[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelSort(short[] a, int fromIndex, int toIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelSort(int[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelSort(int[] a, int fromIndex, int toIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelSort(long[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelSort(long[] a, int fromIndex, int toIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelSort(float[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelSort(float[] a, int fromIndex, int toIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelSort(double[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelSort(double[] a, int fromIndex, int toIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static void rangeCheck(int arrayLength, int fromIndex, int toIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelSort(T[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelSort(T[] a, int fromIndex, int toIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelSort(T[] a, Comparator\u003c? super T\u003e cmp)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelSort(T[] a, int fromIndex, int toIndex, Comparator\u003c? super T\u003e cmp)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void sort(Object[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void sort(Object[] a, int fromIndex, int toIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void mergeSort(Object[] src, Object[] dest, int low, int high, int off)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void swap(Object[] x, int a, int b)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void sort(T[] a, Comparator\u003c? super T\u003e c)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void sort(T[] a, int fromIndex, int toIndex, Comparator\u003c? super T\u003e c)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelPrefix(T[] array, BinaryOperator\u003cT\u003e op)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelPrefix(T[] array, int fromIndex, int toIndex, BinaryOperator\u003cT\u003e op)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelPrefix(long[] array, LongBinaryOperator op)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelPrefix(long[] array, int fromIndex, int toIndex, LongBinaryOperator op)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelPrefix(double[] array, DoubleBinaryOperator op)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelPrefix(double[] array, int fromIndex, int toIndex, DoubleBinaryOperator op)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelPrefix(int[] array, IntBinaryOperator op)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelPrefix(int[] array, int fromIndex, int toIndex, IntBinaryOperator op)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int binarySearch(long[] a, long key)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int binarySearch(long[] a, int fromIndex, int toIndex, long key)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static int binarySearch0(long[] a, int fromIndex, int toIndex, long key)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int binarySearch(int[] a, int key)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int binarySearch(int[] a, int fromIndex, int toIndex, int key)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static int binarySearch0(int[] a, int fromIndex, int toIndex, int key)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int binarySearch(short[] a, short key)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int binarySearch(short[] a, int fromIndex, int toIndex, short key)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static int binarySearch0(short[] a, int fromIndex, int toIndex, short key)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int binarySearch(char[] a, char key)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int binarySearch(char[] a, int fromIndex, int toIndex, char key)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static int binarySearch0(char[] a, int fromIndex, int toIndex, char key)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int binarySearch(byte[] a, byte key)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int binarySearch(byte[] a, int fromIndex, int toIndex, byte key)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static int binarySearch0(byte[] a, int fromIndex, int toIndex, byte key)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int binarySearch(double[] a, double key)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int binarySearch(double[] a, int fromIndex, int toIndex, double key)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static int binarySearch0(double[] a, int fromIndex, int toIndex, double key)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int binarySearch(float[] a, float key)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int binarySearch(float[] a, int fromIndex, int toIndex, float key)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static int binarySearch0(float[] a, int fromIndex, int toIndex, float key)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int binarySearch(Object[] a, Object key)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int binarySearch(Object[] a, int fromIndex, int toIndex, Object key)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static int binarySearch0(Object[] a, int fromIndex, int toIndex, Object key)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int binarySearch(T[] a, T key, Comparator\u003c? super T\u003e c)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int binarySearch(T[] a, int fromIndex, int toIndex, T key, Comparator\u003c? super T\u003e c)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static int binarySearch0(T[] a, int fromIndex, int toIndex, T key, Comparator\u003c? super T\u003e c)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean equals(long[] a, long[] a2)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean equals(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean equals(int[] a, int[] a2)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean equals(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean equals(short[] a, short[] a2)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean equals(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean equals(char[] a, char[] a2)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean equals(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean equals(byte[] a, byte[] a2)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean equals(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean equals(boolean[] a, boolean[] a2)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean equals(boolean[] a, int aFromIndex, int aToIndex, boolean[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean equals(double[] a, double[] a2)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean equals(double[] a, int aFromIndex, int aToIndex, double[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean equals(float[] a, float[] a2)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean equals(float[] a, int aFromIndex, int aToIndex, float[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean equals(Object[] a, Object[] a2)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean equals(Object[] a, int aFromIndex, int aToIndex, Object[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean equals(T[] a, T[] a2, Comparator\u003c? super T\u003e cmp)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean equals(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator\u003c? super T\u003e cmp)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void fill(long[] a, long val)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void fill(long[] a, int fromIndex, int toIndex, long val)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void fill(int[] a, int val)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void fill(int[] a, int fromIndex, int toIndex, int val)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void fill(short[] a, short val)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void fill(short[] a, int fromIndex, int toIndex, short val)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void fill(char[] a, char val)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void fill(char[] a, int fromIndex, int toIndex, char val)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void fill(byte[] a, byte val)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void fill(byte[] a, int fromIndex, int toIndex, byte val)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void fill(boolean[] a, boolean val)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void fill(boolean[] a, int fromIndex, int toIndex, boolean val)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void fill(double[] a, double val)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void fill(double[] a, int fromIndex, int toIndex, double val)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void fill(float[] a, float val)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void fill(float[] a, int fromIndex, int toIndex, float val)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void fill(Object[] a, Object val)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void fill(Object[] a, int fromIndex, int toIndex, Object val)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static T[] copyOf(T[] original, int newLength)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static T[] copyOf(U[] original, int newLength, Class\u003c? extends T[]\u003e newType)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static byte[] copyOf(byte[] original, int newLength)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static short[] copyOf(short[] original, int newLength)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int[] copyOf(int[] original, int newLength)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static long[] copyOf(long[] original, int newLength)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static char[] copyOf(char[] original, int newLength)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static float[] copyOf(float[] original, int newLength)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static double[] copyOf(double[] original, int newLength)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean[] copyOf(boolean[] original, int newLength)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static T[] copyOfRange(T[] original, int from, int to)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static T[] copyOfRange(U[] original, int from, int to, Class\u003c? extends T[]\u003e newType)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static byte[] copyOfRange(byte[] original, int from, int to)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static short[] copyOfRange(short[] original, int from, int to)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int[] copyOfRange(int[] original, int from, int to)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static long[] copyOfRange(long[] original, int from, int to)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static char[] copyOfRange(char[] original, int from, int to)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static float[] copyOfRange(float[] original, int from, int to)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static double[] copyOfRange(double[] original, int from, int to)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean[] copyOfRange(boolean[] original, int from, int to)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static List\u003cT\u003e asList(T... a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int hashCode(long[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int hashCode(int[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int hashCode(short[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int hashCode(char[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int hashCode(byte[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int hashCode(boolean[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int hashCode(float[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int hashCode(double[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int hashCode(Object[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int deepHashCode(Object[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean deepEquals(Object[] a1, Object[] a2)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String toString(long[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String toString(int[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String toString(short[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String toString(char[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String toString(byte[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String toString(boolean[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String toString(float[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String toString(double[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String toString(Object[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String deepToString(Object[] a)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void setAll(T[] array, IntFunction\u003c? extends T\u003e generator)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelSetAll(T[] array, IntFunction\u003c? extends T\u003e generator)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void setAll(int[] array, IntUnaryOperator generator)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelSetAll(int[] array, IntUnaryOperator generator)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void setAll(long[] array, IntToLongFunction generator)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelSetAll(long[] array, IntToLongFunction generator)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void setAll(double[] array, IntToDoubleFunction generator)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void parallelSetAll(double[] array, IntToDoubleFunction generator)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator\u003cT\u003e spliterator(T[] array)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator\u003cT\u003e spliterator(T[] array, int startInclusive, int endExclusive)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator.OfInt spliterator(int[] array)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator.OfInt spliterator(int[] array, int startInclusive, int endExclusive)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator.OfLong spliterator(long[] array)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator.OfLong spliterator(long[] array, int startInclusive, int endExclusive)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator.OfDouble spliterator(double[] array)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Spliterator.OfDouble spliterator(double[] array, int startInclusive, int endExclusive)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Stream\u003cT\u003e stream(T[] array)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Stream\u003cT\u003e stream(T[] array, int startInclusive, int endExclusive)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static IntStream stream(int[] array)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static IntStream stream(int[] array, int startInclusive, int endExclusive)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static LongStream stream(long[] array)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static LongStream stream(long[] array, int startInclusive, int endExclusive)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static DoubleStream stream(double[] array)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static DoubleStream stream(double[] array, int startInclusive, int endExclusive)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(boolean[] a, boolean[] b)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(boolean[] a, int aFromIndex, int aToIndex, boolean[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(byte[] a, byte[] b)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compareUnsigned(byte[] a, byte[] b)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compareUnsigned(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(short[] a, short[] b)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compareUnsigned(short[] a, short[] b)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compareUnsigned(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(char[] a, char[] b)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(int[] a, int[] b)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compareUnsigned(int[] a, int[] b)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compareUnsigned(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(long[] a, long[] b)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compareUnsigned(long[] a, long[] b)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compareUnsigned(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(float[] a, float[] b)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(float[] a, int aFromIndex, int aToIndex, float[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(double[] a, double[] b)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(double[] a, int aFromIndex, int aToIndex, double[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(T[] a, T[] b)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(T[] a, T[] b, Comparator\u003c? super T\u003e cmp)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator\u003c? super T\u003e cmp)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int mismatch(boolean[] a, boolean[] b)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int mismatch(boolean[] a, int aFromIndex, int aToIndex, boolean[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int mismatch(byte[] a, byte[] b)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int mismatch(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int mismatch(char[] a, char[] b)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int mismatch(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int mismatch(short[] a, short[] b)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int mismatch(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int mismatch(int[] a, int[] b)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int mismatch(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int mismatch(long[] a, long[] b)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int mismatch(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int mismatch(float[] a, float[] b)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int mismatch(float[] a, int aFromIndex, int aToIndex, float[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int mismatch(double[] a, double[] b)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int mismatch(double[] a, int aFromIndex, int aToIndex, double[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int mismatch(Object[] a, Object[] b)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int mismatch(Object[] a, int aFromIndex, int aToIndex, Object[] b, int bFromIndex, int bToIndex)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int mismatch(T[] a, T[] b, Comparator\u003c? super T\u003e cmp)"}, {"arrows": "to", "from": "java.util.Arrays", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int mismatch(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator\u003c? super T\u003e cmp)"}, {"arrows": "to", "from": "public static void sort(float[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compareTo"}, {"arrows": "to", "from": "public static void sort(float[] a, int fromIndex, int toIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compareTo"}, {"arrows": "to", "from": "public static void sort(double[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compareTo"}, {"arrows": "to", "from": "public static void sort(double[] a, int fromIndex, int toIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compareTo"}, {"arrows": "to", "from": "public static void parallelSort(float[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compareTo"}, {"arrows": "to", "from": "public static void parallelSort(float[] a, int fromIndex, int toIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compareTo"}, {"arrows": "to", "from": "public static void parallelSort(double[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compareTo"}, {"arrows": "to", "from": "public static void parallelSort(double[] a, int fromIndex, int toIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compareTo"}, {"arrows": "to", "from": "public static void parallelSort(T[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Comparable"}, {"arrows": "to", "from": "public static void parallelSort(T[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "commonPool()"}, {"arrows": "to", "from": "public static void parallelSort(T[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sort(Object"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void checkPermission()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private boolean createWorker()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final String nextWorkerThreadName()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final void registerWorker(WorkQueue w)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final void deregisterWorker(ForkJoinWorkerThread wt, Throwable ex)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final void signalWork()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final void runWorker(WorkQueue w)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int scan(WorkQueue w, int prevSrc, int r)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int awaitWork(WorkQueue w)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final boolean canStop()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int tryCompensate(long c)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final void uncompensate()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final int helpJoin(ForkJoinTask\u003c?\u003e task, WorkQueue w, boolean canHelp)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final int helpComplete(ForkJoinTask\u003c?\u003e task, WorkQueue w, boolean owned)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private ForkJoinTask\u003c?\u003e pollScan(boolean submissionsOnly)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final int helpQuiescePool(WorkQueue w, long nanos, boolean interruptible)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final int externalHelpQuiescePool(long nanos, boolean interruptible)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final ForkJoinTask\u003c?\u003e nextTaskFor(WorkQueue w)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final WorkQueue submissionQueue()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final void externalPush(ForkJoinTask\u003c?\u003e task)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private ForkJoinTask\u003cT\u003e externalSubmit(ForkJoinTask\u003cT\u003e task)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static WorkQueue commonQueue()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final WorkQueue externalQueue()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static void helpAsyncBlocker(Executor e, ManagedBlocker blocker)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static int getSurplusQueuedTaskCount()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private boolean tryTerminate(boolean now, boolean enable)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static Object newInstanceFromSystemProperty(String property) throws ReflectiveOperationException"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static ForkJoinPool commonPool()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public T invoke(ForkJoinTask\u003cT\u003e task)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void execute(ForkJoinTask\u003c?\u003e task)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void execute(Runnable task)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ForkJoinTask\u003cT\u003e submit(ForkJoinTask\u003cT\u003e task)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ForkJoinTask\u003cT\u003e submit(Callable\u003cT\u003e task)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ForkJoinTask\u003cT\u003e submit(Runnable task, T result)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ForkJoinTask\u003c?\u003e submit(Runnable task)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public List\u003cFuture\u003cT\u003e\u003e invokeAll(Collection\u003c? extends Callable\u003cT\u003e\u003e tasks)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ForkJoinWorkerThreadFactory getFactory()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public UncaughtExceptionHandler getUncaughtExceptionHandler()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getParallelism()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int getCommonPoolParallelism()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getPoolSize()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean getAsyncMode()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getRunningThreadCount()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getActiveThreadCount()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isQuiescent()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long getStealCount()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long getQueuedTaskCount()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getQueuedSubmissionCount()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean hasQueuedSubmissions()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected ForkJoinTask\u003c?\u003e pollSubmission()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected int drainTasksTo(Collection\u003c? super ForkJoinTask\u003c?\u003e\u003e c)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void shutdown()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public List\u003cRunnable\u003e shutdownNow()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isTerminated()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isTerminating()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isShutdown()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean awaitQuiescence(long timeout, TimeUnit unit)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void managedBlock(ManagedBlocker blocker) throws InterruptedException"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void compensatedBlock(ManagedBlocker blocker) throws InterruptedException"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinPool", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void unmanagedBlock(ManagedBlocker blocker) throws InterruptedException"}, {"arrows": "to", "from": "public static ForkJoinPool commonPool()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "shutdownNow"}, {"arrows": "to", "from": "public static ForkJoinPool commonPool()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "shutdown"}, {"arrows": "to", "from": "public static ForkJoinPool commonPool()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "awaitQuiescence"}, {"arrows": "to", "from": "public static ForkJoinPool commonPool()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "exit"}, {"arrows": "to", "from": "public int getPoolSize()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getParallelism"}, {"arrows": "to", "from": "public String toString()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "LITTLE_ENDIAN"}, {"arrows": "to", "from": "public String toString()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "BIG_ENDIAN"}, {"arrows": "to", "from": "public String toString()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toString(int)"}, {"arrows": "to", "from": "public String toString()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getLoopbackAddress"}, {"arrows": "to", "from": "public String toString()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.InetAddress"}, {"arrows": "to", "from": "public String toString()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getHostString()"}, {"arrows": "to", "from": "public String toString()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toString()"}, {"arrows": "to", "from": "public String toString()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getLocalizedMessage"}, {"arrows": "to", "from": "public String toString()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getPath"}, {"arrows": "to", "from": "public void shutdown()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "commonPool()"}, {"arrows": "to", "from": "public void shutdown()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.RuntimePermission"}, {"arrows": "to", "from": "public List\u003cRunnable\u003e shutdownNow()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "commonPool()"}, {"arrows": "to", "from": "public List\u003cRunnable\u003e shutdownNow()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.RuntimePermission"}, {"arrows": "to", "from": "public boolean isTerminating()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.concurrent.ForkJoinTask"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void signalWaiters()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int setDone()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int trySetCancelled()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final int trySetThrown(Throwable ex)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int trySetException(Throwable ex)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final int doExec()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int awaitDone(ForkJoinPool pool, boolean ran, boolean interruptible, boolean timed, long nanos)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static final void cancelIgnoringExceptions(Future\u003c?\u003e t)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private Throwable getThrowableException()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private Throwable getException(int s)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void reportException(int s)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void reportExecutionException(int s)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static void rethrow(Throwable ex)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static void uncheckedThrow(Throwable t) throws T"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final ForkJoinTask\u003cV\u003e fork()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final V join()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final V invoke()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void invokeAll(ForkJoinTask\u003c?\u003e t1, ForkJoinTask\u003c?\u003e t2)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void invokeAll(ForkJoinTask\u003c?\u003e... tasks)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collection\u003cT\u003e invokeAll(Collection\u003cT\u003e tasks)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean cancel(boolean mayInterruptIfRunning)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final boolean isCompletedAbnormally()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final boolean isCompletedNormally()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final Throwable getException()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void completeExceptionally(Throwable ex)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void complete(V value)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final void quietlyComplete()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final V get() throws InterruptedException, ExecutionException"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final void quietlyJoin()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final void quietlyInvoke()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void helpQuiesce()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void reinitialize()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static ForkJoinPool getPool()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean inForkJoinPool()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean tryUnfork()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int getQueuedTaskCount()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int getSurplusQueuedTaskCount()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract V getRawResult()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected abstract void setRawResult(V value)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected abstract boolean exec()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected static ForkJoinTask\u003c?\u003e peekNextLocalTask()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected static ForkJoinTask\u003c?\u003e pollNextLocalTask()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected static ForkJoinTask\u003c?\u003e pollTask()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final short getForkJoinTaskTag()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final short setForkJoinTaskTag(short newValue)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final boolean compareAndSetForkJoinTaskTag(short expect, short update)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static ForkJoinTask\u003c?\u003e adapt(Runnable runnable)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static ForkJoinTask\u003cT\u003e adapt(Runnable runnable, T result)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static ForkJoinTask\u003cT\u003e adapt(Callable\u003c? extends T\u003e callable)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static ForkJoinTask\u003cT\u003e adaptInterruptible(Callable\u003c? extends T\u003e callable)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinTask", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException"}, {"arrows": "to", "from": "public final ForkJoinTask\u003cV\u003e fork()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "join"}, {"arrows": "to", "from": "public final ForkJoinTask\u003cV\u003e fork()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isDone"}, {"arrows": "to", "from": "public final ForkJoinTask\u003cV\u003e fork()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "inForkJoinPool"}, {"arrows": "to", "from": "public final ForkJoinTask\u003cV\u003e fork()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "commonPool()"}, {"arrows": "to", "from": "public final V join()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "get()"}, {"arrows": "to", "from": "public static void invokeAll(ForkJoinTask\u003c?\u003e t1, ForkJoinTask\u003c?\u003e t2)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getException()"}, {"arrows": "to", "from": "public static void invokeAll(ForkJoinTask\u003c?\u003e... tasks)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getException()"}, {"arrows": "to", "from": "public static Collection\u003cT\u003e invokeAll(Collection\u003cT\u003e tasks)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getException()"}, {"arrows": "to", "from": "public boolean cancel(boolean mayInterruptIfRunning)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "join"}, {"arrows": "to", "from": "public boolean cancel(boolean mayInterruptIfRunning)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isDone"}, {"arrows": "to", "from": "public boolean cancel(boolean mayInterruptIfRunning)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isCancelled"}, {"arrows": "to", "from": "public boolean cancel(boolean mayInterruptIfRunning)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "completeExceptionally(Throwable)"}, {"arrows": "to", "from": "public boolean cancel(boolean mayInterruptIfRunning)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "reinitialize"}, {"arrows": "to", "from": "public final void quietlyComplete()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "setRawResult"}, {"arrows": "to", "from": "public static ForkJoinPool getPool()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "inForkJoinPool"}, {"arrows": "to", "from": "public static boolean inForkJoinPool()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.concurrent.ForkJoinWorkerThread"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinWorkerThread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ForkJoinPool getPool()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinWorkerThread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getPoolIndex()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinWorkerThread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void onStart()"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinWorkerThread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void onTermination(Throwable exception)"}, {"arrows": "to", "from": "java.util.concurrent.ForkJoinWorkerThread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void run()"}, {"arrows": "to", "from": "public void run()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.concurrent.ForkJoinTask"}, {"arrows": "to", "from": "public abstract V getRawResult()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "join"}, {"arrows": "to", "from": "public static ForkJoinTask\u003c?\u003e adapt(Runnable runnable)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "join"}, {"arrows": "to", "from": "public static ForkJoinTask\u003cT\u003e adapt(Runnable runnable, T result)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "join"}, {"arrows": "to", "from": "public static ForkJoinTask\u003cT\u003e adapt(Callable\u003c? extends T\u003e callable)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "join"}, {"arrows": "to", "from": "public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "awaitQuiescence(long"}, {"arrows": "to", "from": "public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "commonPool()"}, {"arrows": "to", "from": "public boolean awaitQuiescence(long timeout, TimeUnit unit)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.concurrent.ForkJoinTask"}, {"arrows": "to", "from": "public boolean awaitQuiescence(long timeout, TimeUnit unit)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isQuiescent"}, {"arrows": "to", "from": "public static void managedBlock(ManagedBlocker blocker) throws InterruptedException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "block"}, {"arrows": "to", "from": "public static void parallelSort(T[] a, int fromIndex, int toIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Comparable"}, {"arrows": "to", "from": "public static void parallelSort(T[] a, int fromIndex, int toIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "commonPool()"}, {"arrows": "to", "from": "public static void parallelSort(T[] a, int fromIndex, int toIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sort(Object"}, {"arrows": "to", "from": "public static void parallelSort(T[] a, Comparator\u003c? super T\u003e cmp)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Comparator"}, {"arrows": "to", "from": "public static void parallelSort(T[] a, Comparator\u003c? super T\u003e cmp)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "commonPool()"}, {"arrows": "to", "from": "public static void parallelSort(T[] a, Comparator\u003c? super T\u003e cmp)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sort(Object"}, {"arrows": "to", "from": "public static void parallelSort(T[] a, int fromIndex, int toIndex, Comparator\u003c? super T\u003e cmp)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Comparable"}, {"arrows": "to", "from": "public static void parallelSort(T[] a, int fromIndex, int toIndex, Comparator\u003c? super T\u003e cmp)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "commonPool()"}, {"arrows": "to", "from": "public static void parallelSort(T[] a, int fromIndex, int toIndex, Comparator\u003c? super T\u003e cmp)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sort(Object"}, {"arrows": "to", "from": "public static void sort(Object[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Comparable"}, {"arrows": "to", "from": "public static void sort(Object[] a, int fromIndex, int toIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Comparable"}, {"arrows": "to", "from": "public static void sort(T[] a, Comparator\u003c? super T\u003e c)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Comparator"}, {"arrows": "to", "from": "public static void sort(T[] a, int fromIndex, int toIndex, Comparator\u003c? super T\u003e c)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Comparator"}, {"arrows": "to", "from": "public static void parallelPrefix(T[] array, int fromIndex, int toIndex, BinaryOperator\u003cT\u003e op)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "parallelPrefix(Object"}, {"arrows": "to", "from": "public static void parallelPrefix(long[] array, int fromIndex, int toIndex, LongBinaryOperator op)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "parallelPrefix(long"}, {"arrows": "to", "from": "public static void parallelPrefix(double[] array, int fromIndex, int toIndex, DoubleBinaryOperator op)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "parallelPrefix(double"}, {"arrows": "to", "from": "public static void parallelPrefix(int[] array, int fromIndex, int toIndex, IntBinaryOperator op)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "parallelPrefix(int"}, {"arrows": "to", "from": "public static int binarySearch(long[] a, long key)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sort(long"}, {"arrows": "to", "from": "public static int binarySearch(long[] a, int fromIndex, int toIndex, long key)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sort(long"}, {"arrows": "to", "from": "public static int binarySearch(int[] a, int key)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sort(int"}, {"arrows": "to", "from": "public static int binarySearch(int[] a, int fromIndex, int toIndex, int key)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sort(int"}, {"arrows": "to", "from": "public static int binarySearch(short[] a, short key)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sort(short"}, {"arrows": "to", "from": "public static int binarySearch(short[] a, int fromIndex, int toIndex, short key)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sort(short"}, {"arrows": "to", "from": "public static int binarySearch(char[] a, char key)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sort(char"}, {"arrows": "to", "from": "public static int binarySearch(char[] a, int fromIndex, int toIndex, char key)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sort(char"}, {"arrows": "to", "from": "public static int binarySearch(byte[] a, byte key)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sort(byte"}, {"arrows": "to", "from": "public static int binarySearch(byte[] a, int fromIndex, int toIndex, byte key)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sort(byte"}, {"arrows": "to", "from": "public static int binarySearch(double[] a, double key)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sort(double"}, {"arrows": "to", "from": "public static int binarySearch(double[] a, int fromIndex, int toIndex, double key)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sort(double"}, {"arrows": "to", "from": "public static int binarySearch(float[] a, float key)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sort(float"}, {"arrows": "to", "from": "public static int binarySearch(float[] a, int fromIndex, int toIndex, float key)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sort(float"}, {"arrows": "to", "from": "public static int binarySearch(Object[] a, Object key)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sort(Object"}, {"arrows": "to", "from": "public static int binarySearch(Object[] a, int fromIndex, int toIndex, Object key)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sort(Object"}, {"arrows": "to", "from": "public static int binarySearch(T[] a, T key, Comparator\u003c? super T\u003e c)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sort(Object"}, {"arrows": "to", "from": "public static int binarySearch(T[] a, int fromIndex, int toIndex, T key, Comparator\u003c? super T\u003e c)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sort(Object"}, {"arrows": "to", "from": "public static List\u003cT\u003e asList(T... a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.RandomAccess"}, {"arrows": "to", "from": "public static List\u003cT\u003e asList(T... a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Collection"}, {"arrows": "to", "from": "public static List\u003cT\u003e asList(T... a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unmodifiableList"}, {"arrows": "to", "from": "public static List\u003cT\u003e asList(T... a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.Serializable"}, {"arrows": "to", "from": "public static List\u003cT\u003e asList(T... a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UnsupportedOperationException"}, {"arrows": "to", "from": "public static int hashCode(long[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.List"}, {"arrows": "to", "from": "public static int hashCode(long[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Long"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int size()"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean isEmpty()"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean contains(Object o)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Iterator\u003cE\u003e iterator()"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Object[] toArray()"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " T[] toArray(T[] a)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean add(E e)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean remove(Object o)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean containsAll(Collection\u003c?\u003e c)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean addAll(Collection\u003c? extends E\u003e c)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean addAll(int index, Collection\u003c? extends E\u003e c)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean removeAll(Collection\u003c?\u003e c)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean retainAll(Collection\u003c?\u003e c)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void replaceAll(UnaryOperator\u003cE\u003e operator)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void sort(Comparator\u003c? super E\u003e c)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void clear()"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean equals(Object o)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int hashCode()"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " E get(int index)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " E set(int index, E element)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void add(int index, E element)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " E remove(int index)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int indexOf(Object o)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int lastIndexOf(Object o)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " ListIterator\u003cE\u003e listIterator()"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " ListIterator\u003cE\u003e listIterator(int index)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " List\u003cE\u003e subList(int fromIndex, int toIndex)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Spliterator\u003cE\u003e spliterator()"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void addFirst(E e)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void addLast(E e)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " E getFirst()"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " E getLast()"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " E removeFirst()"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " E removeLast()"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " List\u003cE\u003e reversed()"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static List\u003cE\u003e of()"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static List\u003cE\u003e of(E e1)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static List\u003cE\u003e of(E e1, E e2)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static List\u003cE\u003e of(E e1, E e2, E e3)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static List\u003cE\u003e of(E e1, E e2, E e3, E e4)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static List\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static List\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static List\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6, E e7)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static List\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static List\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static List\u003cE\u003e of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static List\u003cE\u003e of(E... elements)"}, {"arrows": "to", "from": "java.util.List", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static List\u003cE\u003e copyOf(Collection\u003c? extends E\u003e coll)"}, {"arrows": "to", "from": " void sort(Comparator\u003c? super E\u003e c)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Comparable"}, {"arrows": "to", "from": " void sort(Comparator\u003c? super E\u003e c)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Comparator"}, {"arrows": "to", "from": " void sort(Comparator\u003c? super E\u003e c)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sort(List)"}, {"arrows": "to", "from": " ListIterator\u003cE\u003e listIterator(int index)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "next"}, {"arrows": "to", "from": " ListIterator\u003cE\u003e listIterator(int index)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "previous"}, {"arrows": "to", "from": "java.util.ListIterator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean hasNext()"}, {"arrows": "to", "from": "java.util.ListIterator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " E next()"}, {"arrows": "to", "from": "java.util.ListIterator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean hasPrevious()"}, {"arrows": "to", "from": "java.util.ListIterator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " E previous()"}, {"arrows": "to", "from": "java.util.ListIterator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int nextIndex()"}, {"arrows": "to", "from": "java.util.ListIterator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int previousIndex()"}, {"arrows": "to", "from": "java.util.ListIterator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void remove()"}, {"arrows": "to", "from": "java.util.ListIterator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void set(E e)"}, {"arrows": "to", "from": "java.util.ListIterator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void add(E e)"}, {"arrows": "to", "from": " boolean hasPrevious()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "previous"}, {"arrows": "to", "from": " E previous()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "next"}, {"arrows": "to", "from": " int nextIndex()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "next"}, {"arrows": "to", "from": " int previousIndex()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "previous"}, {"arrows": "to", "from": " void set(E e)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "remove"}, {"arrows": "to", "from": " void set(E e)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "previous"}, {"arrows": "to", "from": " void set(E e)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "next"}, {"arrows": "to", "from": " void set(E e)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "add"}, {"arrows": "to", "from": " void add(E e)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "previous"}, {"arrows": "to", "from": " void add(E e)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "next"}, {"arrows": "to", "from": "java.util.AbstractList", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean add(E e)"}, {"arrows": "to", "from": "java.util.AbstractList", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract E get(int index)"}, {"arrows": "to", "from": "java.util.AbstractList", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public E set(int index, E element)"}, {"arrows": "to", "from": "java.util.AbstractList", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void add(int index, E element)"}, {"arrows": "to", "from": "java.util.AbstractList", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public E remove(int index)"}, {"arrows": "to", "from": "java.util.AbstractList", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int indexOf(Object o)"}, {"arrows": "to", "from": "java.util.AbstractList", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int lastIndexOf(Object o)"}, {"arrows": "to", "from": "java.util.AbstractList", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void clear()"}, {"arrows": "to", "from": "java.util.AbstractList", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean addAll(int index, Collection\u003c? extends E\u003e c)"}, {"arrows": "to", "from": "java.util.AbstractList", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Iterator\u003cE\u003e iterator()"}, {"arrows": "to", "from": "java.util.AbstractList", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ListIterator\u003cE\u003e listIterator()"}, {"arrows": "to", "from": "java.util.AbstractList", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ListIterator\u003cE\u003e listIterator(final int index)"}, {"arrows": "to", "from": "java.util.AbstractList", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public List\u003cE\u003e subList(int fromIndex, int toIndex)"}, {"arrows": "to", "from": "java.util.AbstractList", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean equals(Object o)"}, {"arrows": "to", "from": "java.util.AbstractList", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int hashCode()"}, {"arrows": "to", "from": "java.util.AbstractList", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void removeRange(int fromIndex, int toIndex)"}, {"arrows": "to", "from": "public boolean add(E e)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "add(int"}, {"arrows": "to", "from": "public boolean add(E e)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "add"}, {"arrows": "to", "from": "public boolean addAll(int index, Collection\u003c? extends E\u003e c)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "add(int"}, {"arrows": "to", "from": "public Iterator\u003cE\u003e iterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "modCount"}, {"arrows": "to", "from": "public Iterator\u003cE\u003e iterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UnsupportedOperationException"}, {"arrows": "to", "from": "public ListIterator\u003cE\u003e listIterator(final int index)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "modCount"}, {"arrows": "to", "from": "public ListIterator\u003cE\u003e listIterator(final int index)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UnsupportedOperationException"}, {"arrows": "to", "from": "public int hashCode()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hashCode"}, {"arrows": "to", "from": "public int hashCode()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(Object)"}, {"arrows": "to", "from": "public int hashCode()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.HashMap"}, {"arrows": "to", "from": "public int hashCode()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.Object"}, {"arrows": "to", "from": "public int hashCode()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "doubleToLongBits(double)"}, {"arrows": "to", "from": " static List\u003cE\u003e of(E... elements)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "of(Object)"}, {"arrows": "to", "from": "public static int hashCode(int[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Integer"}, {"arrows": "to", "from": "public static int hashCode(int[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.List"}, {"arrows": "to", "from": "public static int hashCode(short[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.List"}, {"arrows": "to", "from": "public static int hashCode(short[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Short"}, {"arrows": "to", "from": "public static int hashCode(char[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.List"}, {"arrows": "to", "from": "public static int hashCode(char[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Character"}, {"arrows": "to", "from": "public static int hashCode(byte[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.List"}, {"arrows": "to", "from": "public static int hashCode(byte[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Byte"}, {"arrows": "to", "from": "public static int hashCode(boolean[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.List"}, {"arrows": "to", "from": "public static int hashCode(boolean[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Boolean"}, {"arrows": "to", "from": "public static int hashCode(float[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Float"}, {"arrows": "to", "from": "public static int hashCode(float[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.List"}, {"arrows": "to", "from": "public static int hashCode(double[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.List"}, {"arrows": "to", "from": "public static int hashCode(double[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Double"}, {"arrows": "to", "from": "public static int deepHashCode(Object[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.List"}, {"arrows": "to", "from": "public static boolean deepEquals(Object[] a1, Object[] a2)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(Object"}, {"arrows": "to", "from": "public static String toString(Object[] a)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toString"}, {"arrows": "to", "from": "public static Spliterator\u003cT\u003e spliterator(T[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SIZED"}, {"arrows": "to", "from": "public static Spliterator\u003cT\u003e spliterator(T[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "IMMUTABLE"}, {"arrows": "to", "from": "public static Spliterator\u003cT\u003e spliterator(T[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SUBSIZED"}, {"arrows": "to", "from": "public static Spliterator\u003cT\u003e spliterator(T[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Spliterator"}, {"arrows": "to", "from": "public static Spliterator\u003cT\u003e spliterator(T[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ORDERED"}, {"arrows": "to", "from": "public static Spliterator\u003cT\u003e spliterator(T[] array, int startInclusive, int endExclusive)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SIZED"}, {"arrows": "to", "from": "public static Spliterator\u003cT\u003e spliterator(T[] array, int startInclusive, int endExclusive)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "IMMUTABLE"}, {"arrows": "to", "from": "public static Spliterator\u003cT\u003e spliterator(T[] array, int startInclusive, int endExclusive)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SUBSIZED"}, {"arrows": "to", "from": "public static Spliterator\u003cT\u003e spliterator(T[] array, int startInclusive, int endExclusive)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Spliterator"}, {"arrows": "to", "from": "public static Spliterator\u003cT\u003e spliterator(T[] array, int startInclusive, int endExclusive)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ORDERED"}, {"arrows": "to", "from": "public static Spliterator.OfInt spliterator(int[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Spliterator.OfInt"}, {"arrows": "to", "from": "public static Spliterator.OfInt spliterator(int[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SIZED"}, {"arrows": "to", "from": "public static Spliterator.OfInt spliterator(int[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "IMMUTABLE"}, {"arrows": "to", "from": "public static Spliterator.OfInt spliterator(int[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SUBSIZED"}, {"arrows": "to", "from": "public static Spliterator.OfInt spliterator(int[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ORDERED"}, {"arrows": "to", "from": "public static Spliterator.OfInt spliterator(int[] array, int startInclusive, int endExclusive)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Spliterator.OfInt"}, {"arrows": "to", "from": "public static Spliterator.OfInt spliterator(int[] array, int startInclusive, int endExclusive)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SIZED"}, {"arrows": "to", "from": "public static Spliterator.OfInt spliterator(int[] array, int startInclusive, int endExclusive)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "IMMUTABLE"}, {"arrows": "to", "from": "public static Spliterator.OfInt spliterator(int[] array, int startInclusive, int endExclusive)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SUBSIZED"}, {"arrows": "to", "from": "public static Spliterator.OfInt spliterator(int[] array, int startInclusive, int endExclusive)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ORDERED"}, {"arrows": "to", "from": "public static Spliterator.OfLong spliterator(long[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Spliterator.OfLong"}, {"arrows": "to", "from": "public static Spliterator.OfLong spliterator(long[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SIZED"}, {"arrows": "to", "from": "public static Spliterator.OfLong spliterator(long[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "IMMUTABLE"}, {"arrows": "to", "from": "public static Spliterator.OfLong spliterator(long[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SUBSIZED"}, {"arrows": "to", "from": "public static Spliterator.OfLong spliterator(long[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ORDERED"}, {"arrows": "to", "from": "public static Spliterator.OfLong spliterator(long[] array, int startInclusive, int endExclusive)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Spliterator.OfLong"}, {"arrows": "to", "from": "public static Spliterator.OfLong spliterator(long[] array, int startInclusive, int endExclusive)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SIZED"}, {"arrows": "to", "from": "public static Spliterator.OfLong spliterator(long[] array, int startInclusive, int endExclusive)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "IMMUTABLE"}, {"arrows": "to", "from": "public static Spliterator.OfLong spliterator(long[] array, int startInclusive, int endExclusive)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SUBSIZED"}, {"arrows": "to", "from": "public static Spliterator.OfLong spliterator(long[] array, int startInclusive, int endExclusive)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ORDERED"}, {"arrows": "to", "from": "public static Spliterator.OfDouble spliterator(double[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Spliterator.OfDouble"}, {"arrows": "to", "from": "public static Spliterator.OfDouble spliterator(double[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SIZED"}, {"arrows": "to", "from": "public static Spliterator.OfDouble spliterator(double[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "IMMUTABLE"}, {"arrows": "to", "from": "public static Spliterator.OfDouble spliterator(double[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SUBSIZED"}, {"arrows": "to", "from": "public static Spliterator.OfDouble spliterator(double[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ORDERED"}, {"arrows": "to", "from": "public static Spliterator.OfDouble spliterator(double[] array, int startInclusive, int endExclusive)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Spliterator.OfDouble"}, {"arrows": "to", "from": "public static Spliterator.OfDouble spliterator(double[] array, int startInclusive, int endExclusive)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SIZED"}, {"arrows": "to", "from": "public static Spliterator.OfDouble spliterator(double[] array, int startInclusive, int endExclusive)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "IMMUTABLE"}, {"arrows": "to", "from": "public static Spliterator.OfDouble spliterator(double[] array, int startInclusive, int endExclusive)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SUBSIZED"}, {"arrows": "to", "from": "public static Spliterator.OfDouble spliterator(double[] array, int startInclusive, int endExclusive)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ORDERED"}, {"arrows": "to", "from": "public static Stream\u003cT\u003e stream(T[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.stream.DoubleStream"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " DoubleStream filter(DoublePredicate predicate)"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " DoubleStream map(DoubleUnaryOperator mapper)"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Stream\u003cU\u003e mapToObj(DoubleFunction\u003c? extends U\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " IntStream mapToInt(DoubleToIntFunction mapper)"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " LongStream mapToLong(DoubleToLongFunction mapper)"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " DoubleStream flatMap(DoubleFunction\u003c? extends DoubleStream\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " DoubleStream mapMulti(DoubleMapMultiConsumer mapper)"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " DoubleStream distinct()"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " DoubleStream sorted()"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " DoubleStream peek(DoubleConsumer action)"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " DoubleStream limit(long maxSize)"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " DoubleStream skip(long n)"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " DoubleStream takeWhile(DoublePredicate predicate)"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " DoubleStream dropWhile(DoublePredicate predicate)"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void forEach(DoubleConsumer action)"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void forEachOrdered(DoubleConsumer action)"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " double[] toArray()"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " double reduce(double identity, DoubleBinaryOperator op)"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " OptionalDouble reduce(DoubleBinaryOperator op)"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " R collect(Supplier\u003cR\u003e supplier, ObjDoubleConsumer\u003cR\u003e accumulator, BiConsumer\u003cR, R\u003e combiner)"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " double sum()"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " OptionalDouble min()"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " OptionalDouble max()"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " long count()"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " OptionalDouble average()"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " DoubleSummaryStatistics summaryStatistics()"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean anyMatch(DoublePredicate predicate)"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean allMatch(DoublePredicate predicate)"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean noneMatch(DoublePredicate predicate)"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " OptionalDouble findFirst()"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " OptionalDouble findAny()"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Stream\u003cDouble\u003e boxed()"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Builder builder()"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static DoubleStream empty()"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static DoubleStream of(double t)"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static DoubleStream of(double... values)"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static DoubleStream iterate(final double seed, final DoubleUnaryOperator f)"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static DoubleStream iterate(double seed, DoublePredicate hasNext, DoubleUnaryOperator next)"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static DoubleStream generate(DoubleSupplier s)"}, {"arrows": "to", "from": "java.util.stream.DoubleStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static DoubleStream concat(DoubleStream a, DoubleStream b)"}, {"arrows": "to", "from": " DoubleStream flatMap(DoubleFunction\u003c? extends DoubleStream\u003e mapper)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close()"}, {"arrows": "to", "from": "java.util.stream.BaseStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Iterator\u003cT\u003e iterator()"}, {"arrows": "to", "from": "java.util.stream.BaseStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Spliterator\u003cT\u003e spliterator()"}, {"arrows": "to", "from": "java.util.stream.BaseStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean isParallel()"}, {"arrows": "to", "from": "java.util.stream.BaseStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " S sequential()"}, {"arrows": "to", "from": "java.util.stream.BaseStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " S parallel()"}, {"arrows": "to", "from": "java.util.stream.BaseStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " S unordered()"}, {"arrows": "to", "from": "java.util.stream.BaseStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " S onClose(Runnable closeHandler)"}, {"arrows": "to", "from": "java.util.stream.BaseStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void close()"}, {"arrows": "to", "from": " S onClose(Runnable closeHandler)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close()"}, {"arrows": "to", "from": " DoubleStream mapMulti(DoubleMapMultiConsumer mapper)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "flatMap"}, {"arrows": "to", "from": " DoubleStream distinct()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compare(double"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String toString(double d)"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String toHexString(double d)"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Double valueOf(String s) throws NumberFormatException"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Double valueOf(double d)"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static double parseDouble(String s) throws NumberFormatException"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isNaN(double v)"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isInfinite(double v)"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isFinite(double d)"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isNaN()"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isInfinite()"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public byte byteValue()"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public short shortValue()"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int intValue()"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long longValue()"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public float floatValue()"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public double doubleValue()"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int hashCode()"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int hashCode(double value)"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean equals(Object obj)"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static long doubleToLongBits(double value)"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static native long doubleToRawLongBits(double value)"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static native double longBitsToDouble(long bits)"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int compareTo(Double anotherDouble)"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(double d1, double d2)"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static double sum(double a, double b)"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static double max(double a, double b)"}, {"arrows": "to", "from": "java.lang.Double", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static double min(double a, double b)"}, {"arrows": "to", "from": "public static String toString(double d)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toString(int)"}, {"arrows": "to", "from": "public static String toString(double d)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.text.NumberFormat"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String toString(int i, int radix)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String toUnsignedString(int i, int radix)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String toHexString(int i)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String toOctalString(int i)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String toBinaryString(int i)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static String toUnsignedString0(int val, int shift)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static void formatUnsignedInt(int val, int shift, char[] buf, int offset, int len)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void formatUnsignedInt(int val, int shift, byte[] buf, int len)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static void formatUnsignedInt(int val, int shift, byte[] buf, int offset, int len)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String toString(int i)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String toUnsignedString(int i)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static int getChars(int i, int index, byte[] buf)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static int getChars(int i, int index, char[] buf)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static int stringSize(int x)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int parseInt(String s, int radix) throws NumberFormatException"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix) throws NumberFormatException"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int parseInt(String s) throws NumberFormatException"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int parseUnsignedInt(String s, int radix) throws NumberFormatException"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int parseUnsignedInt(CharSequence s, int beginIndex, int endIndex, int radix) throws NumberFormatException"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int parseUnsignedInt(String s) throws NumberFormatException"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Integer valueOf(String s, int radix) throws NumberFormatException"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Integer valueOf(String s) throws NumberFormatException"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Integer valueOf(int i)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public byte byteValue()"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public short shortValue()"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int intValue()"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long longValue()"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public float floatValue()"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public double doubleValue()"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int hashCode()"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int hashCode(int value)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean equals(Object obj)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Integer getInteger(String nm)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Integer getInteger(String nm, int val)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Integer getInteger(String nm, Integer val)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Integer decode(String nm) throws NumberFormatException"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int compareTo(Integer anotherInteger)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(int x, int y)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compareUnsigned(int x, int y)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static long toUnsignedLong(int x)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int divideUnsigned(int dividend, int divisor)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int remainderUnsigned(int dividend, int divisor)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int highestOneBit(int i)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int lowestOneBit(int i)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int numberOfLeadingZeros(int i)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int numberOfTrailingZeros(int i)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int bitCount(int i)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int rotateLeft(int i, int distance)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int rotateRight(int i, int distance)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int reverse(int i)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int signum(int i)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int reverseBytes(int i)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int sum(int a, int b)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int max(int a, int b)"}, {"arrows": "to", "from": "java.lang.Integer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int min(int a, int b)"}, {"arrows": "to", "from": "public static String toString(int i, int radix)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toUpperCase()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int length()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isEmpty()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public native char charAt(int index)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int codePointAt(int index)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int codePointBefore(int index)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int codePointCount(int beginIndex, int endIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int offsetByCodePoints(int index, int codePointOffset)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void getChars(char[] dst, int dstBegin)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " native void getCharsNoCheck(int start, int end, char[] buffer, int index)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public byte[] getBytes(String charsetName) throws UnsupportedEncodingException"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public byte[] getBytes(Charset charset)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public byte[] getBytes()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean equals(Object anObject)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean contentEquals(StringBuffer sb)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean contentEquals(CharSequence cs)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean equalsIgnoreCase(String anotherString)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public native int compareTo(String anotherString)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int compareToIgnoreCase(String str)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean regionMatches(int toffset, String other, int ooffset, int len)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean startsWith(String prefix, int toffset)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean startsWith(String prefix)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean endsWith(String suffix)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int hashCode()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int indexOf(int ch)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int indexOf(int ch, int fromIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int indexOfSupplementary(int ch, int fromIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int lastIndexOf(int ch)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int lastIndexOf(int ch, int fromIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int lastIndexOfSupplementary(int ch, int fromIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int indexOf(String str)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int indexOf(String str, int fromIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static int indexOf(String source, String target, int fromIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static int indexOf(byte[] src, byte srcCoder, int srcCount, String tgtStr, int fromIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int lastIndexOf(String str)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int lastIndexOf(String str, int fromIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static int lastIndexOf(String source, String target, int fromIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static int lastIndexOf(byte[] src, byte srcCoder, int srcCount, String tgtStr, int fromIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static int lastIndexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String substring(int beginIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String substring(int beginIndex, int endIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private native String fastSubstring(int start, int length)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CharSequence subSequence(int beginIndex, int endIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public native String concat(String str)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String replace(char oldChar, char newChar)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private native String doReplace(char oldChar, char newChar)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean matches(String regex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean contains(CharSequence s)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String replaceFirst(String regex, String replacement)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String replaceAll(String regex, String replacement)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String replace(CharSequence target, CharSequence replacement)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String[] split(String regex, int limit)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String[] split(String regex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String join(CharSequence delimiter, CharSequence... elements)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String join(CharSequence delimiter, Iterable\u003c? extends CharSequence\u003e elements)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toLowerCase(Locale locale)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toLowerCase()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toUpperCase(Locale locale)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toUpperCase()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String trim()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String strip()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String stripLeading()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String stripTrailing()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isBlank()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Stream\u003cString\u003e lines()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String indent(int n)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String stripIndent()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String translateEscapes()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public R transform(Function\u003c? super String, ? extends R\u003e f)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public IntStream chars()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public IntStream codePoints()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public native char[] toCharArray()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String format(String format, Object... args)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String format(Locale l, String format, Object... args)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String formatted(Object... args)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String valueOf(Object obj)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String valueOf(char[] data)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String valueOf(char[] data, int offset, int count)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String copyValueOf(char[] data, int offset, int count)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String copyValueOf(char[] data)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String valueOf(boolean b)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String valueOf(char c)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String valueOf(int i)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String valueOf(long l)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String valueOf(float f)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String valueOf(double d)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public native String intern()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String repeat(int count)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void getBytes(byte[] dst, int dstBegin, byte coder)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private native void fillBytesLatin1(byte[] dst, int byteIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private native void fillBytesUTF16(byte[] dst, int byteIndex)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " byte coder()"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static void checkIndex(int index, int length)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static void checkOffset(int offset, int length)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static void checkBoundsOffCount(int offset, int count, int length)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static String valueOfCodePoint(int codePoint)"}, {"arrows": "to", "from": "java.lang.String", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static void checkBoundsBeginEnd(int begin, int end, int length)"}, {"arrows": "to", "from": "public int length()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isError()"}, {"arrows": "to", "from": "public boolean isEmpty()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "length()"}, {"arrows": "to", "from": "public int codePointAt(int index)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "length()"}, {"arrows": "to", "from": "public int codePointBefore(int index)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "length()"}, {"arrows": "to", "from": "java.lang.CharSequence", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int length()"}, {"arrows": "to", "from": "java.lang.CharSequence", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " char charAt(int index)"}, {"arrows": "to", "from": "java.lang.CharSequence", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean isEmpty()"}, {"arrows": "to", "from": "java.lang.CharSequence", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " CharSequence subSequence(int start, int end)"}, {"arrows": "to", "from": "java.lang.CharSequence", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.lang.CharSequence", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public IntStream chars()"}, {"arrows": "to", "from": "java.lang.CharSequence", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public IntStream codePoints()"}, {"arrows": "to", "from": "java.lang.CharSequence", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(CharSequence cs1, CharSequence cs2)"}, {"arrows": "to", "from": "public byte[] getBytes(String charsetName) throws UnsupportedEncodingException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.charset.CharsetEncoder"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final Charset charset()"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final byte[] replacement()"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final CharsetEncoder replaceWith(byte[] newReplacement)"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void implReplaceWith(byte[] newReplacement)"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isLegalReplacement(byte[] repl)"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CodingErrorAction malformedInputAction()"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final CharsetEncoder onMalformedInput(CodingErrorAction newAction)"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void implOnMalformedInput(CodingErrorAction newAction)"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CodingErrorAction unmappableCharacterAction()"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final CharsetEncoder onUnmappableCharacter(CodingErrorAction newAction)"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void implOnUnmappableCharacter(CodingErrorAction newAction)"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final float averageBytesPerChar()"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final float maxBytesPerChar()"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final CoderResult encode(CharBuffer in, ByteBuffer out, boolean endOfInput)"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final CoderResult flush(ByteBuffer out)"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected CoderResult implFlush(ByteBuffer out)"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final CharsetEncoder reset()"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void implReset()"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected abstract CoderResult encodeLoop(CharBuffer in, ByteBuffer out)"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final ByteBuffer encode(CharBuffer in) throws CharacterCodingException"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean canEncode(char c)"}, {"arrows": "to", "from": "java.nio.charset.CharsetEncoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean canEncode(CharSequence cs)"}, {"arrows": "to", "from": "public final CharsetEncoder replaceWith(byte[] newReplacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "implReplaceWith"}, {"arrows": "to", "from": "public final CharsetEncoder replaceWith(byte[] newReplacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "maxBytesPerChar()"}, {"arrows": "to", "from": "public final CharsetEncoder replaceWith(byte[] newReplacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isLegalReplacement"}, {"arrows": "to", "from": "public final CharsetEncoder onMalformedInput(CodingErrorAction newAction)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "implOnMalformedInputimplOnMalformedInput"}, {"arrows": "to", "from": "public final CharsetEncoder onUnmappableCharacter(CodingErrorAction newAction)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "implOnUnmappableCharacterimplOnUnmappableCharacter"}, {"arrows": "to", "from": "public final CoderResult encode(CharBuffer in, ByteBuffer out, boolean endOfInput)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "OVERFLOW"}, {"arrows": "to", "from": "public final CoderResult encode(CharBuffer in, ByteBuffer out, boolean endOfInput)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.charset.CoderResult"}, {"arrows": "to", "from": "public final CoderResult encode(CharBuffer in, ByteBuffer out, boolean endOfInput)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "reset"}, {"arrows": "to", "from": "public final CoderResult encode(CharBuffer in, ByteBuffer out, boolean endOfInput)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "REPORT"}, {"arrows": "to", "from": "public final CoderResult encode(CharBuffer in, ByteBuffer out, boolean endOfInput)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "encodeLoop"}, {"arrows": "to", "from": "public final CoderResult encode(CharBuffer in, ByteBuffer out, boolean endOfInput)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNDERFLOW"}, {"arrows": "to", "from": "public final CoderResult encode(CharBuffer in, ByteBuffer out, boolean endOfInput)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "remaining"}, {"arrows": "to", "from": "public final CoderResult encode(CharBuffer in, ByteBuffer out, boolean endOfInput)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "length()"}, {"arrows": "to", "from": "java.nio.charset.CoderResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.nio.charset.CoderResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isUnderflow()"}, {"arrows": "to", "from": "java.nio.charset.CoderResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isOverflow()"}, {"arrows": "to", "from": "java.nio.charset.CoderResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isError()"}, {"arrows": "to", "from": "java.nio.charset.CoderResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isMalformed()"}, {"arrows": "to", "from": "java.nio.charset.CoderResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isUnmappable()"}, {"arrows": "to", "from": "java.nio.charset.CoderResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int length()"}, {"arrows": "to", "from": "java.nio.charset.CoderResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static CoderResult malformedForLength(int length)"}, {"arrows": "to", "from": "java.nio.charset.CoderResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static CoderResult unmappableForLength(int length)"}, {"arrows": "to", "from": "java.nio.charset.CoderResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void throwException() throws CharacterCodingException"}, {"arrows": "to", "from": "public void throwException() throws CharacterCodingException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "OVERFLOW"}, {"arrows": "to", "from": "public void throwException() throws CharacterCodingException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNDERFLOW"}, {"arrows": "to", "from": "java.nio.charset.CodingErrorAction", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static IllegalArgumentException createSameBufferException()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static IllegalArgumentException createCapacityException(int capacity)"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final int capacity()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final int position()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer position(int newPosition)"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private IllegalArgumentException createPositionException(int newPosition)"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final int limit()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer limit(int newLimit)"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private IllegalArgumentException createLimitException(int newLimit)"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer mark()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer reset()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer clear()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer flip()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer rewind()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final int remaining()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final boolean hasRemaining()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract boolean isReadOnly()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract boolean hasArray()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract Object array()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int arrayOffset()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract boolean isDirect()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract Buffer slice()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract Buffer slice(int index, int length)"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract Buffer duplicate()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract Object base()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final int nextGetIndex()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final int nextPutIndex()"}, {"arrows": "to", "from": "java.nio.Buffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final int checkIndex(int i)"}, {"arrows": "to", "from": "public Buffer flip()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compact"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static ByteBuffer allocateDirect(int capacity)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static ByteBuffer allocate(int capacity)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static ByteBuffer wrap(byte[] array, int offset, int length)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static ByteBuffer wrap(byte[] array)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer slice()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer slice(int index, int length)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer duplicate()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer asReadOnlyBuffer()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract byte get()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer put(byte b)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract byte get(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer put(int index, byte b)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ByteBuffer get(byte[] dst, int offset, int length)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ByteBuffer get(byte[] dst)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ByteBuffer get(int index, byte[] dst, int offset, int length)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ByteBuffer get(int index, byte[] dst)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ByteBuffer put(ByteBuffer src)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ByteBuffer put(int index, ByteBuffer src, int offset, int length)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ByteBuffer put(byte[] src, int offset, int length)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final ByteBuffer put(byte[] src)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ByteBuffer put(int index, byte[] src, int offset, int length)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ByteBuffer put(int index, byte[] src)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final boolean hasArray()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final byte[] array()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final int arrayOffset()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer position(int newPosition)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer limit(int newLimit)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer mark()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer reset()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer clear()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer flip()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Buffer rewind()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer compact()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract boolean isDirect()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int hashCode()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean equals(Object ob)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int compareTo(ByteBuffer that)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int mismatch(ByteBuffer that)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final ByteOrder order()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final ByteBuffer order(ByteOrder bo)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final int alignmentOffset(int index, int unitSize)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final ByteBuffer alignedSlice(int unitSize)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract byte _get(int i)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract void _put(int i, byte b)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract char getChar()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer putChar(char value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract char getChar(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract char getCharUnchecked(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer putChar(int index, char value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract void putCharUnchecked(int index, char value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract CharBuffer asCharBuffer()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract short getShort()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer putShort(short value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract short getShort(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract short getShortUnchecked(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer putShort(int index, short value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract void putShortUnchecked(int index, short value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ShortBuffer asShortBuffer()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int getInt()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer putInt(int value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int getInt(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract int getIntUnchecked(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer putInt(int index, int value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract void putIntUnchecked(int index, int value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract IntBuffer asIntBuffer()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract long getLong()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer putLong(long value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract long getLong(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract long getLongUnchecked(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer putLong(int index, long value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract void putLongUnchecked(int index, long value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract LongBuffer asLongBuffer()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract float getFloat()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer putFloat(float value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract float getFloat(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract float getFloatUnchecked(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer putFloat(int index, float value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract void putFloatUnchecked(int index, float value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract FloatBuffer asFloatBuffer()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract double getDouble()"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer putDouble(double value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract double getDouble(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract double getDoubleUnchecked(int index)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer putDouble(int index, double value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " abstract void putDoubleUnchecked(int index, double value)"}, {"arrows": "to", "from": "java.nio.ByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract DoubleBuffer asDoubleBuffer()"}, {"arrows": "to", "from": "public static ByteBuffer allocateDirect(int capacity)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "BIG_ENDIAN"}, {"arrows": "to", "from": "public static ByteBuffer allocateDirect(int capacity)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasArray"}, {"arrows": "to", "from": "java.nio.ByteOrder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static ByteOrder nativeOrder()"}, {"arrows": "to", "from": "java.nio.ByteOrder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "public static ByteBuffer allocate(int capacity)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "array"}, {"arrows": "to", "from": "public static ByteBuffer allocate(int capacity)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "arrayOffset"}, {"arrows": "to", "from": "public static ByteBuffer allocate(int capacity)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "BIG_ENDIAN"}, {"arrows": "to", "from": "public static ByteBuffer wrap(byte[] array, int offset, int length)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "array"}, {"arrows": "to", "from": "public static ByteBuffer wrap(byte[] array, int offset, int length)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "arrayOffset"}, {"arrows": "to", "from": "public static ByteBuffer wrap(byte[] array, int offset, int length)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "BIG_ENDIAN"}, {"arrows": "to", "from": "public static ByteBuffer wrap(byte[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "array"}, {"arrows": "to", "from": "public static ByteBuffer wrap(byte[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "arrayOffset"}, {"arrows": "to", "from": "public static ByteBuffer wrap(byte[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "BIG_ENDIAN"}, {"arrows": "to", "from": "public abstract ByteBuffer slice()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "BIG_ENDIAN"}, {"arrows": "to", "from": "public abstract ByteBuffer slice(int index, int length)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "limit()"}, {"arrows": "to", "from": "public abstract ByteBuffer slice(int index, int length)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "BIG_ENDIAN"}, {"arrows": "to", "from": "public abstract ByteBuffer duplicate()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "BIG_ENDIAN"}, {"arrows": "to", "from": "public abstract ByteBuffer asReadOnlyBuffer()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "duplicate"}, {"arrows": "to", "from": "public abstract ByteBuffer asReadOnlyBuffer()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "BIG_ENDIAN"}, {"arrows": "to", "from": "public ByteBuffer get(byte[] dst, int offset, int length)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.BufferUnderflowException"}, {"arrows": "to", "from": "public ByteBuffer put(ByteBuffer src)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.BufferOverflowException"}, {"arrows": "to", "from": "public ByteBuffer put(byte[] src, int offset, int length)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.BufferOverflowException"}, {"arrows": "to", "from": "public final boolean hasArray()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "array()"}, {"arrows": "to", "from": "public final boolean hasArray()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "arrayOffset()"}, {"arrows": "to", "from": "public final byte[] array()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasArray"}, {"arrows": "to", "from": "public final int arrayOffset()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasArray"}, {"arrows": "to", "from": "public boolean equals(Object ob)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(Object)"}, {"arrows": "to", "from": "public int compareTo(ByteBuffer that)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compare(byte"}, {"arrows": "to", "from": "public int mismatch(ByteBuffer that)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "position()"}, {"arrows": "to", "from": "public int mismatch(ByteBuffer that)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "remaining()"}, {"arrows": "to", "from": "public final ByteOrder order()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.ByteOrder"}, {"arrows": "to", "from": "public final ByteBuffer order(ByteOrder bo)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "BIG_ENDIAN"}, {"arrows": "to", "from": "public final ByteBuffer order(ByteOrder bo)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "LITTLE_ENDIAN"}, {"arrows": "to", "from": "public final ByteBuffer alignedSlice(int unitSize)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "BIG_ENDIAN"}, {"arrows": "to", "from": "public abstract boolean hasArray()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "array()"}, {"arrows": "to", "from": "public abstract boolean hasArray()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "arrayOffset()"}, {"arrows": "to", "from": "public abstract Object array()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasArray"}, {"arrows": "to", "from": "public abstract int arrayOffset()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hasArray"}, {"arrows": "to", "from": "public abstract Buffer slice(int index, int length)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "limit()"}, {"arrows": "to", "from": " final int nextGetIndex()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.BufferUnderflowException"}, {"arrows": "to", "from": " final int nextPutIndex()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.BufferOverflowException"}, {"arrows": "to", "from": " final int checkIndex(int i)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "IndexOutOfBoundsException"}, {"arrows": "to", "from": "public final CoderResult flush(ByteBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "OVERFLOW"}, {"arrows": "to", "from": "public final CoderResult flush(ByteBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "encode(CharBuffer"}, {"arrows": "to", "from": "public final CoderResult flush(ByteBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "flush"}, {"arrows": "to", "from": "public final CoderResult flush(ByteBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNDERFLOW"}, {"arrows": "to", "from": "public final CoderResult flush(ByteBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "remaining"}, {"arrows": "to", "from": "public final CoderResult flush(ByteBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "implFlush"}, {"arrows": "to", "from": "protected CoderResult implFlush(ByteBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "OVERFLOW"}, {"arrows": "to", "from": "protected CoderResult implFlush(ByteBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNDERFLOW"}, {"arrows": "to", "from": "public final CharsetEncoder reset()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "implReset()"}, {"arrows": "to", "from": "protected abstract CoderResult encodeLoop(CharBuffer in, ByteBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.charset.CoderResult"}, {"arrows": "to", "from": "protected abstract CoderResult encodeLoop(CharBuffer in, ByteBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "encode"}, {"arrows": "to", "from": "protected abstract CoderResult encodeLoop(CharBuffer in, ByteBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNDERFLOW"}, {"arrows": "to", "from": "protected abstract CoderResult encodeLoop(CharBuffer in, ByteBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "remaining"}, {"arrows": "to", "from": "public final ByteBuffer encode(CharBuffer in) throws CharacterCodingException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "REPORT"}, {"arrows": "to", "from": "public boolean canEncode(char c)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "canEncode(java.lang.CharSequence)"}, {"arrows": "to", "from": "public byte[] getBytes(Charset charset)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.charset.CharsetEncoder"}, {"arrows": "to", "from": "public byte[] getBytes()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.charset.CharsetEncoder"}, {"arrows": "to", "from": "public boolean equals(Object anObject)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.text.Collator"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static synchronized Collator getInstance()"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collator getInstance(Locale desiredLocale)"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int compare(String source, String target)"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int compare(Object o1, Object o2)"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract CollationKey getCollationKey(String source)"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean equals(String source, String target)"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized int getStrength()"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized void setStrength(int newStrength)"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized int getDecomposition()"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized void setDecomposition(int decompositionMode)"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static synchronized Locale[] getAvailableLocales()"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int decompositionMode_Java_ICU(int mode)"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Object clone()"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean equals(Object that)"}, {"arrows": "to", "from": "java.text.Collator", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int hashCode()"}, {"arrows": "to", "from": "public boolean contentEquals(StringBuffer sb)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.text.Collator"}, {"arrows": "to", "from": "public boolean contentEquals(CharSequence cs)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.text.Collator"}, {"arrows": "to", "from": "public boolean equalsIgnoreCase(String anotherString)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.text.Collator"}, {"arrows": "to", "from": "public int compareToIgnoreCase(String str)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.text.Collator"}, {"arrows": "to", "from": "public boolean regionMatches(int toffset, String other, int ooffset, int len)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.text.Collator"}, {"arrows": "to", "from": "public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.text.Collator"}, {"arrows": "to", "from": "public boolean startsWith(String prefix)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(Object)"}, {"arrows": "to", "from": "public boolean endsWith(String suffix)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(Object)"}, {"arrows": "to", "from": "public CharSequence subSequence(int beginIndex, int endIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.CharSequence"}, {"arrows": "to", "from": "public boolean matches(String regex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.regex.Pattern"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Pattern compile(String regex)"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Pattern compile(String regex, int flags)"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String pattern()"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Matcher matcher(CharSequence input)"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int flags()"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean matches(String regex, CharSequence input)"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String[] split(CharSequence input, int limit)"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String[] split(CharSequence input)"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String quote(String s)"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void compile() throws PatternSyntaxException"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Predicate\u003cString\u003e asPredicate()"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Predicate\u003cString\u003e asMatchPredicate()"}, {"arrows": "to", "from": "java.util.regex.Pattern", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Stream\u003cString\u003e splitAsStream(final CharSequence input)"}, {"arrows": "to", "from": "public static Pattern compile(String regex, int flags)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNIX_LINES"}, {"arrows": "to", "from": "public static Pattern compile(String regex, int flags)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MULTILINE"}, {"arrows": "to", "from": "public static Pattern compile(String regex, int flags)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "LITERAL"}, {"arrows": "to", "from": "public static Pattern compile(String regex, int flags)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CASE_INSENSITIVE"}, {"arrows": "to", "from": "public static Pattern compile(String regex, int flags)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNICODE_CASE"}, {"arrows": "to", "from": "public static Pattern compile(String regex, int flags)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "DOTALL"}, {"arrows": "to", "from": "public static Pattern compile(String regex, int flags)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "COMMENTS"}, {"arrows": "to", "from": "public String[] split(CharSequence input)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "split(java.lang.CharSequence"}, {"arrows": "to", "from": "public String replaceFirst(String regex, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "replaceFirst"}, {"arrows": "to", "from": "public String replaceFirst(String regex, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.regex.Pattern"}, {"arrows": "to", "from": "public String replaceFirst(String regex, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.regex.Matcher"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Pattern pattern()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public MatchResult toMatchResult()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Matcher usePattern(Pattern newPattern)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Matcher reset()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Matcher reset(CharSequence input)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int start()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int start(int group)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int start(String name)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int end()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int end(int group)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int end(String name)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String group()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String group(int group)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String group(String name)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int groupCount()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean matches()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean find()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean find(int start)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean lookingAt()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String quoteReplacement(String s)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Matcher appendReplacement(StringBuffer sb, String replacement)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Matcher appendReplacement(StringBuilder sb, String replacement)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public StringBuffer appendTail(StringBuffer sb)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public StringBuilder appendTail(StringBuilder sb)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String replaceAll(String replacement)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String replaceAll(Function\u003cMatchResult, String\u003e replacer)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Stream\u003cMatchResult\u003e results()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String replaceFirst(String replacement)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String replaceFirst(Function\u003cMatchResult, String\u003e replacer)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Matcher region(int start, int end)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int regionStart()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int regionEnd()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean hasTransparentBounds()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Matcher useTransparentBounds(boolean b)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean hasAnchoringBounds()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Matcher useAnchoringBounds(boolean b)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean hitEnd()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean requireEnd()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int getTextLength()"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " CharSequence getSubSequence(int beginIndex, int endIndex)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private Matcher reset(CharSequence input, int start, int end)"}, {"arrows": "to", "from": "java.util.regex.Matcher", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void ensureMatch()"}, {"arrows": "to", "from": "public MatchResult toMatchResult()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.regex.MatchResult"}, {"arrows": "to", "from": "java.util.regex.MatchResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int start()"}, {"arrows": "to", "from": "java.util.regex.MatchResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int start(int group)"}, {"arrows": "to", "from": "java.util.regex.MatchResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int end()"}, {"arrows": "to", "from": "java.util.regex.MatchResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int end(int group)"}, {"arrows": "to", "from": "java.util.regex.MatchResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String group()"}, {"arrows": "to", "from": "java.util.regex.MatchResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String group(int group)"}, {"arrows": "to", "from": "java.util.regex.MatchResult", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int groupCount()"}, {"arrows": "to", "from": "public boolean find(int start)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "find()"}, {"arrows": "to", "from": "public boolean lookingAt()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "matches"}, {"arrows": "to", "from": "public static String quoteReplacement(String s)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.regex.Matcher"}, {"arrows": "to", "from": "public Matcher appendReplacement(StringBuffer sb, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "group(String)"}, {"arrows": "to", "from": "public Matcher appendReplacement(StringBuffer sb, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "start()"}, {"arrows": "to", "from": "public Matcher appendReplacement(StringBuffer sb, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "end()"}, {"arrows": "to", "from": "public Matcher appendReplacement(StringBuffer sb, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "appendTail(StringBuffer)"}, {"arrows": "to", "from": "public Matcher appendReplacement(StringBuffer sb, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "find()"}, {"arrows": "to", "from": "public Matcher appendReplacement(StringBuffer sb, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "group(int)"}, {"arrows": "to", "from": "public Matcher appendReplacement(StringBuilder sb, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "start()"}, {"arrows": "to", "from": "public Matcher appendReplacement(StringBuilder sb, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "end()"}, {"arrows": "to", "from": "public Matcher appendReplacement(StringBuilder sb, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "appendTail(StringBuilder)"}, {"arrows": "to", "from": "public Matcher appendReplacement(StringBuilder sb, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "find()"}, {"arrows": "to", "from": "public Matcher appendReplacement(StringBuilder sb, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "group(int)"}, {"arrows": "to", "from": "public StringBuffer appendTail(StringBuffer sb)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "appendReplacement(StringBuffer"}, {"arrows": "to", "from": "public StringBuilder appendTail(StringBuilder sb)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "appendReplacement(StringBuilder"}, {"arrows": "to", "from": "public String replaceAll(String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "appendReplacement"}, {"arrows": "to", "from": "public String replaceAll(Function\u003cMatchResult, String\u003e replacer)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "appendReplacementappendReplacement"}, {"arrows": "to", "from": "public String replaceAll(Function\u003cMatchResult, String\u003e replacer)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.ConcurrentModificationException"}, {"arrows": "to", "from": "public Stream\u003cMatchResult\u003e results()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.ConcurrentModificationException"}, {"arrows": "to", "from": "public Stream\u003cMatchResult\u003e results()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toMatchResult()"}, {"arrows": "to", "from": "public String replaceFirst(String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "appendReplacement"}, {"arrows": "to", "from": "public String replaceFirst(Function\u003cMatchResult, String\u003e replacer)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "appendReplacementappendReplacement"}, {"arrows": "to", "from": "public String replaceFirst(Function\u003cMatchResult, String\u003e replacer)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.ConcurrentModificationException"}, {"arrows": "to", "from": "public Matcher region(int start, int end)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "useTransparentBounds(boolean)"}, {"arrows": "to", "from": "public Matcher region(int start, int end)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "useAnchoringBounds(boolean)"}, {"arrows": "to", "from": "public int regionStart()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "regionEnd()"}, {"arrows": "to", "from": "public int regionStart()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "regionStart()"}, {"arrows": "to", "from": "public int regionEnd()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "regionEnd()"}, {"arrows": "to", "from": "public int regionEnd()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "regionStart()"}, {"arrows": "to", "from": "public boolean hasTransparentBounds()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "useTransparentBounds(boolean)"}, {"arrows": "to", "from": "public boolean hasAnchoringBounds()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "useAnchoringBounds(boolean)"}, {"arrows": "to", "from": "public String replaceAll(String regex, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.regex.Pattern"}, {"arrows": "to", "from": "public String replaceAll(String regex, String replacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.regex.Matcher"}, {"arrows": "to", "from": "public String[] split(String regex, int limit)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.regex.Pattern"}, {"arrows": "to", "from": "public String[] split(String regex, int limit)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "split(java.lang.CharSequence"}, {"arrows": "to", "from": "public String[] split(String regex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "split(String"}, {"arrows": "to", "from": "public String toLowerCase(Locale locale)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.Character"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Character valueOf(char c)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public char charValue()"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int hashCode()"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int hashCode(char value)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean equals(Object obj)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String toString(char c)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String toString(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isValidCodePoint(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isBmpCodePoint(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isSupplementaryCodePoint(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isHighSurrogate(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isLowSurrogate(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isSurrogate(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isSurrogatePair(char high, char low)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int charCount(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int toCodePoint(char high, char low)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int codePointAt(CharSequence seq, int index)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int codePointAt(char[] a, int index)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int codePointAt(char[] a, int index, int limit)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static int codePointAtImpl(char[] a, int index, int limit)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int codePointBefore(CharSequence seq, int index)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int codePointBefore(char[] a, int index)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int codePointBefore(char[] a, int index, int start)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static int codePointBeforeImpl(char[] a, int index, int start)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static char highSurrogate(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static char lowSurrogate(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int toChars(int codePoint, char[] dst, int dstIndex)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static char[] toChars(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int codePointCount(CharSequence seq, int beginIndex, int endIndex)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int codePointCount(char[] a, int offset, int count)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int offsetByCodePoints(CharSequence seq, int index, int codePointOffset)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int offsetByCodePoints(char[] a, int start, int count, int index, int codePointOffset)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isLowerCase(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isLowerCase(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isUpperCase(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isUpperCase(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isTitleCase(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isTitleCase(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isDigit(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isDigit(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isDefined(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isDefined(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isLetter(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isLetter(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isLetterOrDigit(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isLetterOrDigit(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isAlphabetic(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isIdeographic(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isJavaIdentifierStart(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isJavaIdentifierStart(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isJavaIdentifierPart(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isJavaIdentifierPart(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isUnicodeIdentifierStart(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isUnicodeIdentifierStart(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isUnicodeIdentifierPart(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isUnicodeIdentifierPart(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isIdentifierIgnorable(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isIdentifierIgnorable(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static char toLowerCase(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int toLowerCase(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static char toUpperCase(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int toUpperCase(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static char toTitleCase(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int toTitleCase(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int digit(char ch, int radix)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int digit(int codePoint, int radix)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int getNumericValue(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int getNumericValue(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isSpaceChar(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isSpaceChar(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isWhitespace(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isWhitespace(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isISOControl(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isISOControl(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int getType(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int getType(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static char forDigit(int digit, int radix)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static byte getDirectionality(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static byte getDirectionality(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isMirrored(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isMirrored(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int compareTo(Character anotherCharacter)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compare(char x, char y)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static char reverseBytes(char ch)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String getName(int codePoint)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int codePointOf(String name)"}, {"arrows": "to", "from": "java.lang.Character", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static native String getNameImpl(int codePoint)"}, {"arrows": "to", "from": "public static Character valueOf(char c)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Character(char)"}, {"arrows": "to", "from": "public boolean equals(Object obj)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hashCode"}, {"arrows": "to", "from": "public boolean equals(Object obj)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "doubleToLongBits(double)"}, {"arrows": "to", "from": "public static boolean isValidCodePoint(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MIN_CODE_POINT"}, {"arrows": "to", "from": "public static boolean isValidCodePoint(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MAX_CODE_POINT"}, {"arrows": "to", "from": "public static boolean isBmpCodePoint(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MIN_VALUE"}, {"arrows": "to", "from": "public static boolean isBmpCodePoint(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MAX_VALUE"}, {"arrows": "to", "from": "public static boolean isSupplementaryCodePoint(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MIN_SUPPLEMENTARY_CODE_POINT"}, {"arrows": "to", "from": "public static boolean isSupplementaryCodePoint(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MAX_CODE_POINT"}, {"arrows": "to", "from": "public static boolean isHighSurrogate(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MIN_HIGH_SURROGATE"}, {"arrows": "to", "from": "public static boolean isHighSurrogate(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MAX_HIGH_SURROGATE"}, {"arrows": "to", "from": "public static boolean isLowSurrogate(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MAX_LOW_SURROGATE"}, {"arrows": "to", "from": "public static boolean isLowSurrogate(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MIN_LOW_SURROGATE"}, {"arrows": "to", "from": "public static boolean isSurrogate(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MIN_SURROGATE"}, {"arrows": "to", "from": "public static boolean isSurrogate(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MAX_SURROGATE"}, {"arrows": "to", "from": "public static int charCount(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isValidCodePoint(int)"}, {"arrows": "to", "from": "public static int toCodePoint(char high, char low)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isSurrogatePair(char"}, {"arrows": "to", "from": "public static int codePointAt(CharSequence seq, int index)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "length()"}, {"arrows": "to", "from": "public static int codePointBefore(CharSequence seq, int index)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "length()"}, {"arrows": "to", "from": "public static char highSurrogate(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isSupplementaryCodePoint"}, {"arrows": "to", "from": "public static char highSurrogate(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toCodePoint"}, {"arrows": "to", "from": "public static char highSurrogate(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "lowSurrogate"}, {"arrows": "to", "from": "public static char highSurrogate(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isHighSurrogate"}, {"arrows": "to", "from": "public static char lowSurrogate(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isLowSurrogate"}, {"arrows": "to", "from": "public static char lowSurrogate(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isSupplementaryCodePoint"}, {"arrows": "to", "from": "public static char lowSurrogate(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toCodePoint"}, {"arrows": "to", "from": "public static char lowSurrogate(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "highSurrogate"}, {"arrows": "to", "from": "public static boolean isLowerCase(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isLowerCase(int)"}, {"arrows": "to", "from": "public static boolean isUpperCase(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isUpperCase(int)"}, {"arrows": "to", "from": "public static boolean isTitleCase(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isTitleCase(int)"}, {"arrows": "to", "from": "public static boolean isDigit(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isDigit(int)"}, {"arrows": "to", "from": "public static boolean isDefined(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isDefined(int)"}, {"arrows": "to", "from": "public static boolean isLetter(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isLetter(int)"}, {"arrows": "to", "from": "public static boolean isLetterOrDigit(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isLetterOrDigit(int)"}, {"arrows": "to", "from": "public static boolean isJavaIdentifierStart(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isLetter(char)"}, {"arrows": "to", "from": "public static boolean isJavaIdentifierStart(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getType(char)"}, {"arrows": "to", "from": "public static boolean isJavaIdentifierStart(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isJavaIdentifierStart(int)"}, {"arrows": "to", "from": "public static boolean isJavaIdentifierPart(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isJavaIdentifierPart(int)"}, {"arrows": "to", "from": "public static boolean isUnicodeIdentifierStart(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isLetter(char)"}, {"arrows": "to", "from": "public static boolean isUnicodeIdentifierStart(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getType(char)"}, {"arrows": "to", "from": "public static boolean isUnicodeIdentifierStart(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isUnicodeIdentifierStart(int)"}, {"arrows": "to", "from": "public static boolean isUnicodeIdentifierPart(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isUnicodeIdentifierPart(int)"}, {"arrows": "to", "from": "public static boolean isIdentifierIgnorable(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isIdentifierIgnorable(int)"}, {"arrows": "to", "from": "public static char toLowerCase(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.String"}, {"arrows": "to", "from": "public static char toLowerCase(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toLowerCase(int)"}, {"arrows": "to", "from": "public static char toUpperCase(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toUpperCase(int)"}, {"arrows": "to", "from": "public static char toUpperCase(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toUpperCase()"}, {"arrows": "to", "from": "public static char toTitleCase(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toTitleCase(int)"}, {"arrows": "to", "from": "public static int digit(char ch, int radix)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "digit(int"}, {"arrows": "to", "from": "public static int getNumericValue(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getNumericValue(int)"}, {"arrows": "to", "from": "public static boolean isSpaceChar(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isSpaceChar(int)"}, {"arrows": "to", "from": "public static boolean isWhitespace(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isWhitespace(int)"}, {"arrows": "to", "from": "public static boolean isISOControl(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isISOControl(int)"}, {"arrows": "to", "from": "public static int getType(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getType(int)"}, {"arrows": "to", "from": "public static byte getDirectionality(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDirectionality(int)"}, {"arrows": "to", "from": "public static boolean isMirrored(char ch)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isMirrored(int)"}, {"arrows": "to", "from": "public static String getName(int codePoint)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNASSIGNED"}, {"arrows": "to", "from": "public String toUpperCase(Locale locale)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.Character"}, {"arrows": "to", "from": "public String strip()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isWhitespace(int)"}, {"arrows": "to", "from": "public String stripLeading()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isWhitespace(int)"}, {"arrows": "to", "from": "public String stripTrailing()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isWhitespace(int)"}, {"arrows": "to", "from": "public boolean isBlank()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isWhitespace(int)"}, {"arrows": "to", "from": "public Stream\u003cString\u003e lines()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.UncheckedIOException"}, {"arrows": "to", "from": "public Stream\u003cString\u003e lines()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.stream.Stream"}, {"arrows": "to", "from": "public Stream\u003cString\u003e lines()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.IOException"}, {"arrows": "to", "from": "public String indent(int n)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "lines()"}, {"arrows": "to", "from": "public String stripIndent()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isBlank()"}, {"arrows": "to", "from": "public static String format(String format, Object... args)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault(java.util.Locale.Category)"}, {"arrows": "to", "from": "public static String format(String format, Object... args)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FORMAT"}, {"arrows": "to", "from": "public static String copyValueOf(char[] data, int offset, int count)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "valueOf(char"}, {"arrows": "to", "from": "public static String copyValueOf(char[] data)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "valueOf(char"}, {"arrows": "to", "from": " byte coder()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "canEncode(int)"}, {"arrows": "to", "from": "java.lang.StringLatin1", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int compareToUTF16(byte[] value, byte[] other, int len1, int len2)"}, {"arrows": "to", "from": "java.lang.StringLatin1", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void inflate(byte[] src, int srcOff, char[] dst, int dstOff, int len)"}, {"arrows": "to", "from": "java.lang.StringLatin1", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void inflate(byte[] src, int srcOff, byte[] dst, int dstOff, int len)"}, {"arrows": "to", "from": "public static String toUnsignedString(int i, int radix)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toString(int"}, {"arrows": "to", "from": "public static String toHexString(int i)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "parseUnsignedInt(String"}, {"arrows": "to", "from": "public static String toHexString(int i)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toUpperCase()"}, {"arrows": "to", "from": "public static String toOctalString(int i)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "parseUnsignedInt(String"}, {"arrows": "to", "from": "public static String toBinaryString(int i)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "parseUnsignedInt(String"}, {"arrows": "to", "from": "public static String toString(int i)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toString(int"}, {"arrows": "to", "from": "public static String toUnsignedString(int i)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toUnsignedString(int"}, {"arrows": "to", "from": "public static int parseInt(String s, int radix) throws NumberFormatException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.Character"}, {"arrows": "to", "from": "public static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix) throws NumberFormatException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.CharSequence"}, {"arrows": "to", "from": "public static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix) throws NumberFormatException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.Character"}, {"arrows": "to", "from": "public static int parseInt(String s) throws NumberFormatException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "parseInt(java.lang.String"}, {"arrows": "to", "from": "public static int parseUnsignedInt(String s, int radix) throws NumberFormatException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.Character"}, {"arrows": "to", "from": "public static int parseUnsignedInt(CharSequence s, int beginIndex, int endIndex, int radix) throws NumberFormatException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.CharSequence"}, {"arrows": "to", "from": "public static int parseUnsignedInt(CharSequence s, int beginIndex, int endIndex, int radix) throws NumberFormatException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.Character"}, {"arrows": "to", "from": "public static int parseUnsignedInt(String s) throws NumberFormatException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "parseUnsignedInt(java.lang.String"}, {"arrows": "to", "from": "public static Integer valueOf(String s, int radix) throws NumberFormatException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "parseInt(java.lang.String"}, {"arrows": "to", "from": "public static Integer valueOf(String s) throws NumberFormatException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "parseInt(java.lang.String)"}, {"arrows": "to", "from": "public static Integer valueOf(int i)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Integer(int)"}, {"arrows": "to", "from": "public byte byteValue()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "intValue"}, {"arrows": "to", "from": "public short shortValue()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "intValue"}, {"arrows": "to", "from": "public static Integer getInteger(String nm)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getProperty(java.lang.String)"}, {"arrows": "to", "from": "public static Integer getInteger(String nm)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "decode"}, {"arrows": "to", "from": "public static Integer getInteger(String nm)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getProperty(String)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void setIn(InputStream in)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void setOut(PrintStream out)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void setErr(PrintStream err)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Console console()"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Channel inheritedChannel() throws IOException"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void setSecurityManager(final SecurityManager s)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static SecurityManager getSecurityManager()"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static native long currentTimeMillis()"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static native long nanoTime()"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void arraycopy(char[] src, int srcPos, char[] dst, int dstPos, int length)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static native void arraycopyCharUnchecked(char[] src, int srcPos, char[] dst, int dstPos, int length)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void arraycopy(byte[] src, int srcPos, byte[] dst, int dstPos, int length)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static native void arraycopyByteUnchecked(byte[] src, int srcPos, byte[] dst, int dstPos, int length)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void arraycopy(short[] src, int srcPos, short[] dst, int dstPos, int length)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static native void arraycopyShortUnchecked(short[] src, int srcPos, short[] dst, int dstPos, int length)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void arraycopy(int[] src, int srcPos, int[] dst, int dstPos, int length)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static native void arraycopyIntUnchecked(int[] src, int srcPos, int[] dst, int dstPos, int length)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void arraycopy(long[] src, int srcPos, long[] dst, int dstPos, int length)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static native void arraycopyLongUnchecked(long[] src, int srcPos, long[] dst, int dstPos, int length)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void arraycopy(float[] src, int srcPos, float[] dst, int dstPos, int length)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static native void arraycopyFloatUnchecked(float[] src, int srcPos, float[] dst, int dstPos, int length)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void arraycopy(double[] src, int srcPos, double[] dst, int dstPos, int length)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static native void arraycopyDoubleUnchecked(double[] src, int srcPos, double[] dst, int dstPos, int length)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void arraycopy(boolean[] src, int srcPos, boolean[] dst, int dstPos, int length)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static native void arraycopyBooleanUnchecked(boolean[] src, int srcPos, boolean[] dst, int dstPos, int length)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int identityHashCode(Object x)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Properties getProperties()"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String lineSeparator()"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void setProperties(Properties props)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String getProperty(String key)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String getProperty(String key, String def)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String setProperty(String key, String value)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String clearProperty(String key)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String getenv(String name)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static java.util.Map\u003cString, String\u003e getenv()"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void exit(int status)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void gc()"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void runFinalization()"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void load(String filename)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void loadLibrary(String libname)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static native String mapLibraryName(String libname)"}, {"arrows": "to", "from": "java.lang.System", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static PrintStream newPrintStream(FileOutputStream fos, String enc)"}, {"arrows": "to", "from": "public static Console console()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.Console"}, {"arrows": "to", "from": "java.io.Console", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public PrintWriter writer()"}, {"arrows": "to", "from": "java.io.Console", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Reader reader()"}, {"arrows": "to", "from": "java.io.Console", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Console format(String fmt, Object... args)"}, {"arrows": "to", "from": "java.io.Console", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Console printf(String format, Object... args)"}, {"arrows": "to", "from": "java.io.Console", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String readLine(String fmt, Object... args)"}, {"arrows": "to", "from": "java.io.Console", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String readLine()"}, {"arrows": "to", "from": "java.io.Console", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public char[] readPassword(String fmt, Object... args)"}, {"arrows": "to", "from": "java.io.Console", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public char[] readPassword()"}, {"arrows": "to", "from": "java.io.Console", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void flush()"}, {"arrows": "to", "from": "java.io.Console", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Charset charset()"}, {"arrows": "to", "from": "java.io.Console", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static native boolean echo(boolean on) throws IOException"}, {"arrows": "to", "from": "public PrintWriter writer()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.PrintWriter"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static Charset toCharset(String csn) throws UnsupportedEncodingException"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void ensureOpen() throws IOException"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void flush()"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void close()"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean checkError()"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void setError()"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void clearError()"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void write(int c)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void write(char[] buf, int off, int len)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void write(char[] buf)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void write(String s, int off, int len)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void write(String s)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void print(boolean b)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void print(char c)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void print(int i)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void print(long l)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void print(float f)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void print(double d)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void print(char[] s)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void print(String s)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void print(Object obj)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void println()"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void println(boolean x)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void println(char x)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void println(int x)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void println(long x)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void println(float x)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void println(double x)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void println(char[] x)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void println(String x)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void println(Object x)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public PrintWriter printf(String format, Object... args)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public PrintWriter printf(Locale l, String format, Object... args)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public PrintWriter format(String format, Object... args)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public PrintWriter format(Locale l, String format, Object... args)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public PrintWriter append(CharSequence csq)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public PrintWriter append(CharSequence csq, int start, int end)"}, {"arrows": "to", "from": "java.io.PrintWriter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public PrintWriter append(char c)"}, {"arrows": "to", "from": "public void close()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.SocketException"}, {"arrows": "to", "from": "public void close()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "receive"}, {"arrows": "to", "from": "protected void setError()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkError()"}, {"arrows": "to", "from": "protected void setError()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "clearError()"}, {"arrows": "to", "from": "protected void clearError()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkError()"}, {"arrows": "to", "from": "protected void clearError()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "setError()"}, {"arrows": "to", "from": "public void print(boolean b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.String"}, {"arrows": "to", "from": "public void print(boolean b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "write(int)"}, {"arrows": "to", "from": "public void print(char c)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "write(int)"}, {"arrows": "to", "from": "public void print(int i)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "write(int)"}, {"arrows": "to", "from": "public void print(int i)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.String"}, {"arrows": "to", "from": "public void print(long l)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.String"}, {"arrows": "to", "from": "public void print(long l)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "write(int)"}, {"arrows": "to", "from": "public void print(float f)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "write(int)"}, {"arrows": "to", "from": "public void print(float f)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.String"}, {"arrows": "to", "from": "public void print(double d)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.String"}, {"arrows": "to", "from": "public void print(double d)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "write(int)"}, {"arrows": "to", "from": "public void print(char[] s)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "write(int)"}, {"arrows": "to", "from": "public void print(String s)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "write(int)"}, {"arrows": "to", "from": "public void print(Object obj)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.String"}, {"arrows": "to", "from": "public void print(Object obj)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "write(int)"}, {"arrows": "to", "from": "public void println(boolean x)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "print(boolean)"}, {"arrows": "to", "from": "public void println(boolean x)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "println()"}, {"arrows": "to", "from": "public void println(char x)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "print(char)"}, {"arrows": "to", "from": "public void println(char x)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "println()"}, {"arrows": "to", "from": "public void println(int x)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "println()"}, {"arrows": "to", "from": "public void println(int x)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "print(int)"}, {"arrows": "to", "from": "public void println(long x)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "println()"}, {"arrows": "to", "from": "public void println(long x)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "print(long)"}, {"arrows": "to", "from": "public void println(float x)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "println()"}, {"arrows": "to", "from": "public void println(float x)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "print(float)"}, {"arrows": "to", "from": "public void println(double x)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "println()"}, {"arrows": "to", "from": "public void println(double x)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "print(double)"}, {"arrows": "to", "from": "public void println(char[] x)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "println()"}, {"arrows": "to", "from": "public void println(char[] x)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "print(char"}, {"arrows": "to", "from": "public void println(String x)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "println()"}, {"arrows": "to", "from": "public void println(String x)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "print(String)"}, {"arrows": "to", "from": "public void println(Object x)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "println()"}, {"arrows": "to", "from": "public void println(Object x)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "print(String)"}, {"arrows": "to", "from": "public PrintWriter format(String format, Object... args)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault()"}, {"arrows": "to", "from": "public Reader reader()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "read(char"}, {"arrows": "to", "from": "public Reader reader()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Scanner"}, {"arrows": "to", "from": "public Reader reader()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.Reader"}, {"arrows": "to", "from": "public Reader reader()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "readLine"}, {"arrows": "to", "from": "java.io.Reader", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Reader nullReader()"}, {"arrows": "to", "from": "java.io.Reader", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int read(java.nio.CharBuffer target) throws IOException"}, {"arrows": "to", "from": "java.io.Reader", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int read() throws IOException"}, {"arrows": "to", "from": "java.io.Reader", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int read(char[] cbuf) throws IOException"}, {"arrows": "to", "from": "java.io.Reader", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int read(char[] cbuf, int off, int len) throws IOException"}, {"arrows": "to", "from": "java.io.Reader", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long skip(long n) throws IOException"}, {"arrows": "to", "from": "java.io.Reader", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean ready() throws IOException"}, {"arrows": "to", "from": "java.io.Reader", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean markSupported()"}, {"arrows": "to", "from": "java.io.Reader", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void mark(int readAheadLimit) throws IOException"}, {"arrows": "to", "from": "java.io.Reader", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void reset() throws IOException"}, {"arrows": "to", "from": "java.io.Reader", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract void close() throws IOException"}, {"arrows": "to", "from": "java.io.Reader", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long transferTo(Writer out) throws IOException"}, {"arrows": "to", "from": "public static Reader nullReader()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "lock"}, {"arrows": "to", "from": "public abstract void close() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "wakeup"}, {"arrows": "to", "from": "public abstract void close() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.ClosedSelectorException"}, {"arrows": "to", "from": "public abstract void close() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault"}, {"arrows": "to", "from": "public abstract void close() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.DirectoryStream"}, {"arrows": "to", "from": "public abstract void close() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.WatchService"}, {"arrows": "to", "from": "public abstract void close() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.ClosedFileSystemException"}, {"arrows": "to", "from": "public abstract void close() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.Channel"}, {"arrows": "to", "from": "public Charset charset()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.charset.Charset"}, {"arrows": "to", "from": "java.nio.charset.Charset", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void checkName(String s)"}, {"arrows": "to", "from": "java.nio.charset.Charset", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static Charset lookup(String charsetName)"}, {"arrows": "to", "from": "java.nio.charset.Charset", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isSupported(String charsetName)"}, {"arrows": "to", "from": "java.nio.charset.Charset", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Charset forName(String charsetName)"}, {"arrows": "to", "from": "java.nio.charset.Charset", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static SortedMap\u003cString, Charset\u003e availableCharsets()"}, {"arrows": "to", "from": "java.nio.charset.Charset", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Charset defaultCharset()"}, {"arrows": "to", "from": "java.nio.charset.Charset", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final String name()"}, {"arrows": "to", "from": "java.nio.charset.Charset", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final Set\u003cString\u003e aliases()"}, {"arrows": "to", "from": "java.nio.charset.Charset", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String displayName()"}, {"arrows": "to", "from": "java.nio.charset.Charset", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final boolean isRegistered()"}, {"arrows": "to", "from": "java.nio.charset.Charset", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String displayName(Locale locale)"}, {"arrows": "to", "from": "java.nio.charset.Charset", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract boolean contains(Charset cs)"}, {"arrows": "to", "from": "java.nio.charset.Charset", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract CharsetDecoder newDecoder()"}, {"arrows": "to", "from": "java.nio.charset.Charset", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract CharsetEncoder newEncoder()"}, {"arrows": "to", "from": "java.nio.charset.Charset", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean canEncode()"}, {"arrows": "to", "from": "java.nio.charset.Charset", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final CharBuffer decode(ByteBuffer bb)"}, {"arrows": "to", "from": "java.nio.charset.Charset", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final ByteBuffer encode(CharBuffer cb)"}, {"arrows": "to", "from": "java.nio.charset.Charset", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final ByteBuffer encode(String str)"}, {"arrows": "to", "from": "java.nio.charset.Charset", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final int compareTo(Charset that)"}, {"arrows": "to", "from": "java.nio.charset.Charset", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final int hashCode()"}, {"arrows": "to", "from": "java.nio.charset.Charset", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final boolean equals(Object ob)"}, {"arrows": "to", "from": "java.nio.charset.Charset", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final String toString()"}, {"arrows": "to", "from": "public static SortedMap\u003cString, Charset\u003e availableCharsets()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "forNameforName"}, {"arrows": "to", "from": "public static SortedMap\u003cString, Charset\u003e availableCharsets()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "forName"}, {"arrows": "to", "from": "public final CharBuffer decode(ByteBuffer bb)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "decode(java.nio.ByteBuffer)"}, {"arrows": "to", "from": "java.nio.charset.CharsetDecoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final Charset charset()"}, {"arrows": "to", "from": "java.nio.charset.CharsetDecoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final String replacement()"}, {"arrows": "to", "from": "java.nio.charset.CharsetDecoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final CharsetDecoder replaceWith(String newReplacement)"}, {"arrows": "to", "from": "java.nio.charset.CharsetDecoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void implReplaceWith(String newReplacement)"}, {"arrows": "to", "from": "java.nio.charset.CharsetDecoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CodingErrorAction malformedInputAction()"}, {"arrows": "to", "from": "java.nio.charset.CharsetDecoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final CharsetDecoder onMalformedInput(CodingErrorAction newAction)"}, {"arrows": "to", "from": "java.nio.charset.CharsetDecoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void implOnMalformedInput(CodingErrorAction newAction)"}, {"arrows": "to", "from": "java.nio.charset.CharsetDecoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public CodingErrorAction unmappableCharacterAction()"}, {"arrows": "to", "from": "java.nio.charset.CharsetDecoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final CharsetDecoder onUnmappableCharacter(CodingErrorAction newAction)"}, {"arrows": "to", "from": "java.nio.charset.CharsetDecoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void implOnUnmappableCharacter(CodingErrorAction newAction)"}, {"arrows": "to", "from": "java.nio.charset.CharsetDecoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final float averageCharsPerByte()"}, {"arrows": "to", "from": "java.nio.charset.CharsetDecoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final float maxCharsPerByte()"}, {"arrows": "to", "from": "java.nio.charset.CharsetDecoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final CoderResult decode(ByteBuffer in, CharBuffer out, boolean endOfInput)"}, {"arrows": "to", "from": "java.nio.charset.CharsetDecoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final CoderResult flush(CharBuffer out)"}, {"arrows": "to", "from": "java.nio.charset.CharsetDecoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected CoderResult implFlush(CharBuffer out)"}, {"arrows": "to", "from": "java.nio.charset.CharsetDecoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final CharsetDecoder reset()"}, {"arrows": "to", "from": "java.nio.charset.CharsetDecoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void implReset()"}, {"arrows": "to", "from": "java.nio.charset.CharsetDecoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected abstract CoderResult decodeLoop(ByteBuffer in, CharBuffer out)"}, {"arrows": "to", "from": "java.nio.charset.CharsetDecoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final CharBuffer decode(ByteBuffer in) throws CharacterCodingException"}, {"arrows": "to", "from": "java.nio.charset.CharsetDecoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isAutoDetecting()"}, {"arrows": "to", "from": "java.nio.charset.CharsetDecoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isCharsetDetected()"}, {"arrows": "to", "from": "java.nio.charset.CharsetDecoder", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Charset detectedCharset()"}, {"arrows": "to", "from": "public final CharsetDecoder replaceWith(String newReplacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "maxCharsPerByte()"}, {"arrows": "to", "from": "public final CharsetDecoder replaceWith(String newReplacement)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "implReplaceWith"}, {"arrows": "to", "from": "public final CharsetDecoder onMalformedInput(CodingErrorAction newAction)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "implOnMalformedInputimplOnMalformedInput"}, {"arrows": "to", "from": "public final CharsetDecoder onUnmappableCharacter(CodingErrorAction newAction)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "implOnUnmappableCharacterimplOnUnmappableCharacter"}, {"arrows": "to", "from": "public final CoderResult decode(ByteBuffer in, CharBuffer out, boolean endOfInput)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "OVERFLOW"}, {"arrows": "to", "from": "public final CoderResult decode(ByteBuffer in, CharBuffer out, boolean endOfInput)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "decodeLoop"}, {"arrows": "to", "from": "public final CoderResult decode(ByteBuffer in, CharBuffer out, boolean endOfInput)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.charset.CoderResult"}, {"arrows": "to", "from": "public final CoderResult decode(ByteBuffer in, CharBuffer out, boolean endOfInput)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "reset"}, {"arrows": "to", "from": "public final CoderResult decode(ByteBuffer in, CharBuffer out, boolean endOfInput)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "REPORT"}, {"arrows": "to", "from": "public final CoderResult decode(ByteBuffer in, CharBuffer out, boolean endOfInput)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNDERFLOW"}, {"arrows": "to", "from": "public final CoderResult decode(ByteBuffer in, CharBuffer out, boolean endOfInput)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "remaining"}, {"arrows": "to", "from": "public final CoderResult decode(ByteBuffer in, CharBuffer out, boolean endOfInput)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "length()"}, {"arrows": "to", "from": "public final CoderResult flush(CharBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "OVERFLOW"}, {"arrows": "to", "from": "public final CoderResult flush(CharBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "flush"}, {"arrows": "to", "from": "public final CoderResult flush(CharBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNDERFLOW"}, {"arrows": "to", "from": "public final CoderResult flush(CharBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "decode(ByteBuffer"}, {"arrows": "to", "from": "public final CoderResult flush(CharBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "remaining"}, {"arrows": "to", "from": "public final CoderResult flush(CharBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "implFlush"}, {"arrows": "to", "from": "protected CoderResult implFlush(CharBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "OVERFLOW"}, {"arrows": "to", "from": "protected CoderResult implFlush(CharBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNDERFLOW"}, {"arrows": "to", "from": "public final CharsetDecoder reset()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "implReset()"}, {"arrows": "to", "from": "protected abstract CoderResult decodeLoop(ByteBuffer in, CharBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.charset.CoderResult"}, {"arrows": "to", "from": "protected abstract CoderResult decodeLoop(ByteBuffer in, CharBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNDERFLOW"}, {"arrows": "to", "from": "protected abstract CoderResult decodeLoop(ByteBuffer in, CharBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "remaining"}, {"arrows": "to", "from": "protected abstract CoderResult decodeLoop(ByteBuffer in, CharBuffer out)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "decode"}, {"arrows": "to", "from": "public final CharBuffer decode(ByteBuffer in) throws CharacterCodingException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "REPORT"}, {"arrows": "to", "from": "public boolean isCharsetDetected()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "detectedCharsetdetectedCharset"}, {"arrows": "to", "from": "public boolean isCharsetDetected()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UnsupportedOperationException"}, {"arrows": "to", "from": "public Charset detectedCharset()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "IllegalStateException"}, {"arrows": "to", "from": "public Charset detectedCharset()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UnsupportedOperationException"}, {"arrows": "to", "from": "public final ByteBuffer encode(CharBuffer cb)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.charset.CharsetEncoder"}, {"arrows": "to", "from": "public static Channel inheritedChannel() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.spi.SelectorProvider"}, {"arrows": "to", "from": "java.nio.channels.spi.SelectorProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static SelectorProvider provider()"}, {"arrows": "to", "from": "java.nio.channels.spi.SelectorProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract DatagramChannel openDatagramChannel() throws IOException"}, {"arrows": "to", "from": "java.nio.channels.spi.SelectorProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract DatagramChannel openDatagramChannel(ProtocolFamily family) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.spi.SelectorProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract Pipe openPipe() throws IOException"}, {"arrows": "to", "from": "java.nio.channels.spi.SelectorProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract AbstractSelector openSelector() throws IOException"}, {"arrows": "to", "from": "java.nio.channels.spi.SelectorProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ServerSocketChannel openServerSocketChannel() throws IOException"}, {"arrows": "to", "from": "java.nio.channels.spi.SelectorProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract SocketChannel openSocketChannel() throws IOException"}, {"arrows": "to", "from": "java.nio.channels.spi.SelectorProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Channel inheritedChannel() throws IOException"}, {"arrows": "to", "from": "public Channel inheritedChannel() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.ServerSocketChannelServerSocketChannel"}, {"arrows": "to", "from": "public Channel inheritedChannel() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.SocketChannel"}, {"arrows": "to", "from": "public Channel inheritedChannel() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.DatagramChannel"}, {"arrows": "to", "from": "public Channel inheritedChannel() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "RuntimePermission"}, {"arrows": "to", "from": "public Channel inheritedChannel() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.Channel"}, {"arrows": "to", "from": "java.nio.channels.SocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static SocketChannel open() throws IOException"}, {"arrows": "to", "from": "java.nio.channels.SocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static SocketChannel open(SocketAddress remote) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.SocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final int validOps()"}, {"arrows": "to", "from": "java.nio.channels.SocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract SocketChannel bind(SocketAddress local) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.SocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract SocketChannel setOption(SocketOption\u003cT\u003e name, T value) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.SocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract SocketChannel shutdownInput() throws IOException"}, {"arrows": "to", "from": "java.nio.channels.SocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract SocketChannel shutdownOutput() throws IOException"}, {"arrows": "to", "from": "java.nio.channels.SocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract Socket socket()"}, {"arrows": "to", "from": "java.nio.channels.SocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract boolean isConnected()"}, {"arrows": "to", "from": "java.nio.channels.SocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract boolean isConnectionPending()"}, {"arrows": "to", "from": "java.nio.channels.SocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract boolean connect(SocketAddress remote) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.SocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract boolean finishConnect() throws IOException"}, {"arrows": "to", "from": "java.nio.channels.SocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract SocketAddress getRemoteAddress() throws IOException"}, {"arrows": "to", "from": "java.nio.channels.SocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int read(ByteBuffer dst) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.SocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract long read(ByteBuffer[] dsts, int offset, int length) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.SocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final long read(ByteBuffer[] dsts) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.SocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int write(ByteBuffer src) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.SocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract long write(ByteBuffer[] srcs, int offset, int length) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.SocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final long write(ByteBuffer[] srcs) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.SocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract SocketAddress getLocalAddress() throws IOException"}, {"arrows": "to", "from": "public static SocketChannel open() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.spi.SelectorProvider"}, {"arrows": "to", "from": "public static SocketChannel open(SocketAddress remote) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "open()"}, {"arrows": "to", "from": "public static SocketChannel open(SocketAddress remote) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "connect(SocketAddress)"}, {"arrows": "to", "from": "public final int validOps()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "OP_READ"}, {"arrows": "to", "from": "public final int validOps()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.SelectionKey"}, {"arrows": "to", "from": "java.nio.channels.SelectionKey", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract SelectableChannel channel()"}, {"arrows": "to", "from": "java.nio.channels.SelectionKey", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract Selector selector()"}, {"arrows": "to", "from": "java.nio.channels.SelectionKey", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract boolean isValid()"}, {"arrows": "to", "from": "java.nio.channels.SelectionKey", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract void cancel()"}, {"arrows": "to", "from": "java.nio.channels.SelectionKey", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int interestOps()"}, {"arrows": "to", "from": "java.nio.channels.SelectionKey", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract SelectionKey interestOps(int ops)"}, {"arrows": "to", "from": "java.nio.channels.SelectionKey", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int interestOpsOr(int ops)"}, {"arrows": "to", "from": "java.nio.channels.SelectionKey", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int interestOpsAnd(int ops)"}, {"arrows": "to", "from": "java.nio.channels.SelectionKey", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int readyOps()"}, {"arrows": "to", "from": "java.nio.channels.SelectionKey", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final boolean isReadable()"}, {"arrows": "to", "from": "java.nio.channels.SelectionKey", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final boolean isWritable()"}, {"arrows": "to", "from": "java.nio.channels.SelectionKey", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final boolean isConnectable()"}, {"arrows": "to", "from": "java.nio.channels.SelectionKey", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final boolean isAcceptable()"}, {"arrows": "to", "from": "java.nio.channels.SelectionKey", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final Object attach(Object ob)"}, {"arrows": "to", "from": "java.nio.channels.SelectionKey", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final Object attachment()"}, {"arrows": "to", "from": "public int interestOpsOr(int ops)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "interestOpsAnd(int)"}, {"arrows": "to", "from": "public int interestOpsAnd(int ops)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "interestOpsOr(int)"}, {"arrows": "to", "from": "public final Object attach(Object ob)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "attachment()"}, {"arrows": "to", "from": "public abstract SocketChannel bind(SocketAddress local) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkListen"}, {"arrows": "to", "from": "public abstract SocketChannel shutdownOutput() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.ClosedChannelException"}, {"arrows": "to", "from": "public abstract Socket socket()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.Socket"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static InetAddress[] nonNullAddress(InetAddress address)"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void createImpl(boolean stream) throws SocketException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void setImpl()"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " SocketImpl getImpl() throws SocketException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void connect(SocketAddress endpoint) throws IOException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void connect(SocketAddress endpoint, int timeout) throws IOException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void bind(SocketAddress bindpoint) throws IOException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final void postAccept()"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public InetAddress getInetAddress()"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public InetAddress getLocalAddress()"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getPort()"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getLocalPort()"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public SocketAddress getRemoteSocketAddress()"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public SocketChannel getChannel()"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public InputStream getInputStream() throws IOException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public OutputStream getOutputStream() throws IOException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setTcpNoDelay(boolean on) throws SocketException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean getTcpNoDelay() throws SocketException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setSoLinger(boolean on, int linger) throws SocketException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getSoLinger() throws SocketException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void sendUrgentData(int data) throws IOException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setOOBInline(boolean on) throws SocketException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean getOOBInline() throws SocketException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized void setSoTimeout(int timeout) throws SocketException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized int getSoTimeout() throws SocketException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized void setSendBufferSize(int size) throws SocketException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized int getSendBufferSize() throws SocketException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized void setReceiveBufferSize(int size) throws SocketException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized int getReceiveBufferSize() throws SocketException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setKeepAlive(boolean on) throws SocketException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean getKeepAlive() throws SocketException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setTrafficClass(int tc) throws SocketException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getTrafficClass() throws SocketException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setReuseAddress(boolean on) throws SocketException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean getReuseAddress() throws SocketException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized void close() throws IOException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void shutdownInput() throws IOException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void shutdownOutput() throws IOException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isConnected()"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isBound()"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isClosed()"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isInputShutdown()"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isOutputShutdown()"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static synchronized void setSocketImplFactory(SocketImplFactory fac) throws IOException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setPerformancePreferences(int connectionTime, int latency, int bandwidth)"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Socket setOption(SocketOption\u003cT\u003e name, T value) throws IOException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public T getOption(SocketOption\u003cT\u003e name) throws IOException"}, {"arrows": "to", "from": "java.net.Socket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Set\u003cSocketOption\u003c?\u003e\u003e supportedOptions()"}, {"arrows": "to", "from": "public InetAddress getInetAddress()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close"}, {"arrows": "to", "from": "public InetAddress getInetAddress()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.ServerSocket"}, {"arrows": "to", "from": "public InetAddress getInetAddress()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getLoopbackAddress"}, {"arrows": "to", "from": "public InetAddress getInetAddress()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.DatagramSocket"}, {"arrows": "to", "from": "public InetAddress getLocalAddress()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getLoopbackAddress"}, {"arrows": "to", "from": "public InetAddress getLocalAddress()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.InetAddress"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private Object readResolve() throws ObjectStreamException"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isMulticastAddress()"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isAnyLocalAddress()"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isLoopbackAddress()"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isLinkLocalAddress()"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isSiteLocalAddress()"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isMCGlobal()"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isMCNodeLocal()"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isMCLinkLocal()"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isMCSiteLocal()"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isMCOrgLocal()"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isReachable(int timeout) throws IOException"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isReachable(NetworkInterface netif, int ttl, int timeout) throws IOException"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getHostName()"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getCanonicalHostName()"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static String getHostFromNameService(InetAddress addr)"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public byte[] getAddress()"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getHostAddress()"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int hashCode()"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean equals(Object obj)"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static InetAddress getByAddress(String host, byte[] addr) throws UnknownHostException"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static InetAddress getByAddress(String host, byte[] addr, int scopeId) throws UnknownHostException"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static InetAddress getByName(String host) throws UnknownHostException"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static InetAddress[] getAllByName(String host) throws UnknownHostException"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static InetAddress getLoopbackAddress()"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static InetAddress getByAddress(byte[] addr) throws UnknownHostException"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static InetAddress getLocalHost() throws UnknownHostException"}, {"arrows": "to", "from": "java.net.InetAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static InetAddress anyLocalAddress()"}, {"arrows": "to", "from": "public String getHostName()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getCanonicalHostName()"}, {"arrows": "to", "from": "public int getPort()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close"}, {"arrows": "to", "from": "public int getPort()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.DatagramSocket"}, {"arrows": "to", "from": "public int getLocalPort()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close"}, {"arrows": "to", "from": "public int getLocalPort()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.ServerSocket"}, {"arrows": "to", "from": "public SocketAddress getRemoteSocketAddress()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close"}, {"arrows": "to", "from": "public SocketAddress getRemoteSocketAddress()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.DatagramSocket"}, {"arrows": "to", "from": "public SocketChannel getChannel()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.SocketChannel"}, {"arrows": "to", "from": "public SocketChannel getChannel()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "accept"}, {"arrows": "to", "from": "java.nio.channels.ServerSocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static ServerSocketChannel open() throws IOException"}, {"arrows": "to", "from": "java.nio.channels.ServerSocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final int validOps()"}, {"arrows": "to", "from": "java.nio.channels.ServerSocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final ServerSocketChannel bind(SocketAddress local) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.ServerSocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ServerSocketChannel bind(SocketAddress local, int backlog) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.ServerSocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ServerSocketChannel setOption(SocketOption\u003cT\u003e name, T value) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.ServerSocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ServerSocket socket()"}, {"arrows": "to", "from": "java.nio.channels.ServerSocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract SocketChannel accept() throws IOException"}, {"arrows": "to", "from": "java.nio.channels.ServerSocketChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract SocketAddress getLocalAddress() throws IOException"}, {"arrows": "to", "from": "public static ServerSocketChannel open() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.spi.SelectorProvider"}, {"arrows": "to", "from": "public static ServerSocketChannel open() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "bind(SocketAddress)"}, {"arrows": "to", "from": "java.net.ServerSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void createImpl() throws SocketException"}, {"arrows": "to", "from": "java.net.ServerSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void bind(SocketAddress endpoint) throws IOException"}, {"arrows": "to", "from": "java.net.ServerSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void bind(SocketAddress endpoint, int backlog) throws IOException"}, {"arrows": "to", "from": "java.net.ServerSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public InetAddress getInetAddress()"}, {"arrows": "to", "from": "java.net.ServerSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getLocalPort()"}, {"arrows": "to", "from": "java.net.ServerSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Socket accept() throws IOException"}, {"arrows": "to", "from": "java.net.ServerSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected final void implAccept(Socket s) throws IOException"}, {"arrows": "to", "from": "java.net.ServerSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void close() throws IOException"}, {"arrows": "to", "from": "java.net.ServerSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ServerSocketChannel getChannel()"}, {"arrows": "to", "from": "java.net.ServerSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isBound()"}, {"arrows": "to", "from": "java.net.ServerSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isClosed()"}, {"arrows": "to", "from": "java.net.ServerSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized void setSoTimeout(int timeout) throws SocketException"}, {"arrows": "to", "from": "java.net.ServerSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized int getSoTimeout() throws IOException"}, {"arrows": "to", "from": "java.net.ServerSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setReuseAddress(boolean on) throws SocketException"}, {"arrows": "to", "from": "java.net.ServerSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean getReuseAddress() throws SocketException"}, {"arrows": "to", "from": "java.net.ServerSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.net.ServerSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static synchronized void setSocketFactory(SocketImplFactory fac) throws IOException"}, {"arrows": "to", "from": "java.net.ServerSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized void setReceiveBufferSize(int size) throws SocketException"}, {"arrows": "to", "from": "java.net.ServerSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized int getReceiveBufferSize() throws SocketException"}, {"arrows": "to", "from": "java.net.ServerSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setPerformancePreferences(int connectionTime, int latency, int bandwidth)"}, {"arrows": "to", "from": "java.net.ServerSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ServerSocket setOption(SocketOption\u003cT\u003e name, T value) throws IOException"}, {"arrows": "to", "from": "java.net.ServerSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public T getOption(SocketOption\u003cT\u003e name) throws IOException"}, {"arrows": "to", "from": "java.net.ServerSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Set\u003cSocketOption\u003c?\u003e\u003e supportedOptions()"}, {"arrows": "to", "from": "public void close() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.SocketException"}, {"arrows": "to", "from": "public void close() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "accept()"}, {"arrows": "to", "from": "public void close() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.ClosedChannelException"}, {"arrows": "to", "from": "public void close() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.AsynchronousCloseException"}, {"arrows": "to", "from": "public void close() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close"}, {"arrows": "to", "from": "public ServerSocketChannel getChannel()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.ServerSocketChannel"}, {"arrows": "to", "from": "public boolean isBound()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isClosed()"}, {"arrows": "to", "from": "public boolean isBound()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close"}, {"arrows": "to", "from": "public synchronized void setSoTimeout(int timeout) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SO_TIMEOUT"}, {"arrows": "to", "from": "public synchronized void setSoTimeout(int timeout) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.SocketOptions"}, {"arrows": "to", "from": "java.net.SocketOptions", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setOption(int optID, Object value) throws SocketException"}, {"arrows": "to", "from": "java.net.SocketOptions", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Object getOption(int optID) throws SocketException"}, {"arrows": "to", "from": "public synchronized int getSoTimeout() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SO_TIMEOUT"}, {"arrows": "to", "from": "public void setReuseAddress(boolean on) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "bind(SocketAddress)"}, {"arrows": "to", "from": "public void setReuseAddress(boolean on) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.SocketOptions"}, {"arrows": "to", "from": "public void setReuseAddress(boolean on) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getReuseAddress()"}, {"arrows": "to", "from": "public void setReuseAddress(boolean on) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isBound()"}, {"arrows": "to", "from": "public void setReuseAddress(boolean on) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.Socket"}, {"arrows": "to", "from": "public boolean getReuseAddress() throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.SocketOptions"}, {"arrows": "to", "from": "public synchronized void setReceiveBufferSize(int size) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.Socket"}, {"arrows": "to", "from": "public synchronized void setReceiveBufferSize(int size) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "accept()"}, {"arrows": "to", "from": "public synchronized void setReceiveBufferSize(int size) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.SocketOptions"}, {"arrows": "to", "from": "public synchronized void setReceiveBufferSize(int size) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getReceiveBufferSize()"}, {"arrows": "to", "from": "public synchronized void setReceiveBufferSize(int size) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.ServerSocket"}, {"arrows": "to", "from": "public synchronized void setReceiveBufferSize(int size) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.DatagramSocket"}, {"arrows": "to", "from": "public synchronized void setReceiveBufferSize(int size) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "receive(DatagramPacket)"}, {"arrows": "to", "from": "public synchronized int getReceiveBufferSize() throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.Socket"}, {"arrows": "to", "from": "public synchronized int getReceiveBufferSize() throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.SocketOptions"}, {"arrows": "to", "from": "public ServerSocket setOption(SocketOption\u003cT\u003e name, T value) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.StandardSocketOptions"}, {"arrows": "to", "from": "public T getOption(SocketOption\u003cT\u003e name) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.StandardSocketOptions"}, {"arrows": "to", "from": "public final ServerSocketChannel bind(SocketAddress local) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkListen"}, {"arrows": "to", "from": "public abstract ServerSocketChannel bind(SocketAddress local, int backlog) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkListen"}, {"arrows": "to", "from": "public abstract ServerSocket socket()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.ServerSocket"}, {"arrows": "to", "from": "public abstract SocketChannel accept() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.ServerSocket"}, {"arrows": "to", "from": "public abstract SocketChannel accept() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "accept"}, {"arrows": "to", "from": "public abstract SocketChannel accept() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkAccept"}, {"arrows": "to", "from": "java.lang.SecurityManager", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ThreadGroup getThreadGroup()"}, {"arrows": "to", "from": "public abstract SocketAddress getLocalAddress() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getLoopbackAddress"}, {"arrows": "to", "from": "public abstract SocketAddress getLocalAddress() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.InetAddress"}, {"arrows": "to", "from": "public InputStream getInputStream() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.IllegalBlockingModeException"}, {"arrows": "to", "from": "public InputStream getInputStream() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "read"}, {"arrows": "to", "from": "public InputStream getInputStream() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.IOException"}, {"arrows": "to", "from": "public InputStream getInputStream() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close"}, {"arrows": "to", "from": "public InputStream getInputStream() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "shutdownInput()"}, {"arrows": "to", "from": "public InputStream getInputStream() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.InputStream"}, {"arrows": "to", "from": "java.io.InputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static InputStream nullInputStream()"}, {"arrows": "to", "from": "java.io.InputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int read() throws IOException"}, {"arrows": "to", "from": "java.io.InputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int read(byte[] b) throws IOException"}, {"arrows": "to", "from": "java.io.InputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int read(byte[] b, int off, int len) throws IOException"}, {"arrows": "to", "from": "java.io.InputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public byte[] readAllBytes() throws IOException"}, {"arrows": "to", "from": "java.io.InputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public byte[] readNBytes(int len) throws IOException"}, {"arrows": "to", "from": "java.io.InputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int readNBytes(byte[] b, int off, int len) throws IOException"}, {"arrows": "to", "from": "java.io.InputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long skip(long n) throws IOException"}, {"arrows": "to", "from": "java.io.InputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void skipNBytes(long n) throws IOException"}, {"arrows": "to", "from": "java.io.InputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int available() throws IOException"}, {"arrows": "to", "from": "java.io.InputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void close() throws IOException"}, {"arrows": "to", "from": "java.io.InputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized void mark(int readlimit)"}, {"arrows": "to", "from": "java.io.InputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized void reset() throws IOException"}, {"arrows": "to", "from": "java.io.InputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean markSupported()"}, {"arrows": "to", "from": "java.io.InputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long transferTo(OutputStream out) throws IOException"}, {"arrows": "to", "from": "public byte[] readAllBytes() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MAX_VALUE"}, {"arrows": "to", "from": "public byte[] readAllBytes() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "readNBytes(int)"}, {"arrows": "to", "from": "public void skipNBytes(long n) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "read()"}, {"arrows": "to", "from": "public void skipNBytes(long n) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "skip(long)"}, {"arrows": "to", "from": "public int available() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close()"}, {"arrows": "to", "from": "public int available() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.IOException"}, {"arrows": "to", "from": "public OutputStream getOutputStream() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.OutputStream"}, {"arrows": "to", "from": "public OutputStream getOutputStream() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.IllegalBlockingModeException"}, {"arrows": "to", "from": "java.io.OutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static OutputStream nullOutputStream()"}, {"arrows": "to", "from": "java.io.OutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract void write(int b) throws IOException"}, {"arrows": "to", "from": "java.io.OutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void write(byte[] b) throws IOException"}, {"arrows": "to", "from": "java.io.OutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void write(byte[] b, int off, int len) throws IOException"}, {"arrows": "to", "from": "java.io.OutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void flush() throws IOException"}, {"arrows": "to", "from": "java.io.OutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void close() throws IOException"}, {"arrows": "to", "from": "public void setTcpNoDelay(boolean on) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.SocketOptions"}, {"arrows": "to", "from": "public boolean getTcpNoDelay() throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.SocketOptions"}, {"arrows": "to", "from": "public void setSoLinger(boolean on, int linger) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.SocketOptions"}, {"arrows": "to", "from": "public int getSoLinger() throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.SocketOptions"}, {"arrows": "to", "from": "public void setOOBInline(boolean on) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.SocketOptions"}, {"arrows": "to", "from": "public boolean getOOBInline() throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.SocketOptions"}, {"arrows": "to", "from": "public synchronized int getSoTimeout() throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SO_TIMEOUT"}, {"arrows": "to", "from": "public synchronized void setSendBufferSize(int size) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.SocketOptions"}, {"arrows": "to", "from": "public synchronized void setSendBufferSize(int size) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSendBufferSize()"}, {"arrows": "to", "from": "public synchronized void setSendBufferSize(int size) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.DatagramSocket"}, {"arrows": "to", "from": "public synchronized void setSendBufferSize(int size) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "send(DatagramPacket)"}, {"arrows": "to", "from": "public synchronized int getSendBufferSize() throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.SocketOptions"}, {"arrows": "to", "from": "public void setKeepAlive(boolean on) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.SocketOptions"}, {"arrows": "to", "from": "public boolean getKeepAlive() throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.SocketOptions"}, {"arrows": "to", "from": "public int getTrafficClass() throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "setTrafficClass(int)"}, {"arrows": "to", "from": "public synchronized void close() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.OutputStream"}, {"arrows": "to", "from": "public synchronized void close() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.SocketException"}, {"arrows": "to", "from": "public synchronized void close() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.InputStream"}, {"arrows": "to", "from": "public boolean isConnected()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isClosed()"}, {"arrows": "to", "from": "public boolean isConnected()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close"}, {"arrows": "to", "from": "public Socket setOption(SocketOption\u003cT\u003e name, T value) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.StandardSocketOptions"}, {"arrows": "to", "from": "public abstract boolean isConnected()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isOpen"}, {"arrows": "to", "from": "public abstract boolean isConnected()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.DatagramChannel"}, {"arrows": "to", "from": "public abstract boolean isConnectionPending()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "finishConnect"}, {"arrows": "to", "from": "public abstract boolean connect(SocketAddress remote) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.Socket"}, {"arrows": "to", "from": "public abstract boolean connect(SocketAddress remote) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "finishConnect"}, {"arrows": "to", "from": "public abstract boolean connect(SocketAddress remote) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public abstract boolean finishConnect() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "connectconnect"}, {"arrows": "to", "from": "public abstract boolean finishConnect() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.IOException"}, {"arrows": "to", "from": "public abstract SocketAddress getRemoteAddress() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.InetSocketAddress"}, {"arrows": "to", "from": "java.net.InetSocketAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static InetSocketAddress createUnresolved(String host, int port)"}, {"arrows": "to", "from": "java.net.InetSocketAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void writeObject(ObjectOutputStream out) throws IOException"}, {"arrows": "to", "from": "java.net.InetSocketAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException"}, {"arrows": "to", "from": "java.net.InetSocketAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void readObjectNoData() throws ObjectStreamException"}, {"arrows": "to", "from": "java.net.InetSocketAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final int getPort()"}, {"arrows": "to", "from": "java.net.InetSocketAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final InetAddress getAddress()"}, {"arrows": "to", "from": "java.net.InetSocketAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final String getHostName()"}, {"arrows": "to", "from": "java.net.InetSocketAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final String getHostString()"}, {"arrows": "to", "from": "java.net.InetSocketAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final boolean isUnresolved()"}, {"arrows": "to", "from": "java.net.InetSocketAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.net.InetSocketAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final boolean equals(Object obj)"}, {"arrows": "to", "from": "java.net.InetSocketAddress", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final int hashCode()"}, {"arrows": "to", "from": "public abstract int read(ByteBuffer dst) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.ReadableByteChannel"}, {"arrows": "to", "from": "public abstract long read(ByteBuffer[] dsts, int offset, int length) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.ScatteringByteChannel"}, {"arrows": "to", "from": "public final long read(ByteBuffer[] dsts) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.ScatteringByteChannel"}, {"arrows": "to", "from": "public abstract int write(ByteBuffer src) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.WritableByteChannel"}, {"arrows": "to", "from": "public abstract long write(ByteBuffer[] srcs, int offset, int length) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.GatheringByteChannel"}, {"arrows": "to", "from": "public final long write(ByteBuffer[] srcs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.GatheringByteChannel"}, {"arrows": "to", "from": "java.nio.channels.DatagramChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static DatagramChannel open() throws IOException"}, {"arrows": "to", "from": "java.nio.channels.DatagramChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static DatagramChannel open(ProtocolFamily family) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.DatagramChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final int validOps()"}, {"arrows": "to", "from": "java.nio.channels.DatagramChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract DatagramChannel bind(SocketAddress local) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.DatagramChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract DatagramChannel setOption(SocketOption\u003cT\u003e name, T value) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.DatagramChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract DatagramSocket socket()"}, {"arrows": "to", "from": "java.nio.channels.DatagramChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract boolean isConnected()"}, {"arrows": "to", "from": "java.nio.channels.DatagramChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract DatagramChannel connect(SocketAddress remote) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.DatagramChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract DatagramChannel disconnect() throws IOException"}, {"arrows": "to", "from": "java.nio.channels.DatagramChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract SocketAddress getRemoteAddress() throws IOException"}, {"arrows": "to", "from": "java.nio.channels.DatagramChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract SocketAddress receive(ByteBuffer dst) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.DatagramChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int send(ByteBuffer src, SocketAddress target) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.DatagramChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int read(ByteBuffer dst) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.DatagramChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract long read(ByteBuffer[] dsts, int offset, int length) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.DatagramChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final long read(ByteBuffer[] dsts) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.DatagramChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int write(ByteBuffer src) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.DatagramChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract long write(ByteBuffer[] srcs, int offset, int length) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.DatagramChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final long write(ByteBuffer[] srcs) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.DatagramChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract SocketAddress getLocalAddress() throws IOException"}, {"arrows": "to", "from": "public static DatagramChannel open() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.spi.SelectorProvider"}, {"arrows": "to", "from": "public static DatagramChannel open() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "open(ProtocolFamily)"}, {"arrows": "to", "from": "public static DatagramChannel open() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.ProtocolFamily"}, {"arrows": "to", "from": "java.net.ProtocolFamily", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " String name()"}, {"arrows": "to", "from": "public static DatagramChannel open(ProtocolFamily family) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.spi.SelectorProvider"}, {"arrows": "to", "from": "public static DatagramChannel open(ProtocolFamily family) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.ProtocolFamily"}, {"arrows": "to", "from": "public static DatagramChannel open(ProtocolFamily family) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "INET6"}, {"arrows": "to", "from": "public abstract DatagramChannel bind(SocketAddress local) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkListen"}, {"arrows": "to", "from": "public abstract DatagramSocket socket()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.DatagramSocket"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private synchronized void connectInternal(InetAddress address, int port) throws SocketException"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " DatagramSocketImpl getImpl() throws SocketException"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized void bind(SocketAddress addr) throws SocketException"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void connect(InetAddress address, int port)"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void connect(SocketAddress addr) throws SocketException"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void disconnect()"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isBound()"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isConnected()"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public InetAddress getInetAddress()"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getPort()"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public SocketAddress getRemoteSocketAddress()"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void send(DatagramPacket p) throws IOException"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized void receive(DatagramPacket p) throws IOException"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public InetAddress getLocalAddress()"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getLocalPort()"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized void setSoTimeout(int timeout) throws SocketException"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized int getSoTimeout() throws SocketException"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized void setSendBufferSize(int size) throws SocketException"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized int getSendBufferSize() throws SocketException"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized void setReceiveBufferSize(int size) throws SocketException"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized int getReceiveBufferSize() throws SocketException"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized void setReuseAddress(boolean on) throws SocketException"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized boolean getReuseAddress() throws SocketException"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized void setBroadcast(boolean on) throws SocketException"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized boolean getBroadcast() throws SocketException"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized void setTrafficClass(int tc) throws SocketException"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized int getTrafficClass() throws SocketException"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void close()"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isClosed()"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public DatagramChannel getChannel()"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static synchronized void setDatagramSocketImplFactory(DatagramSocketImplFactory fac) throws IOException"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public DatagramSocket setOption(SocketOption\u003cT\u003e name, T value) throws IOException"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public T getOption(SocketOption\u003cT\u003e name) throws IOException"}, {"arrows": "to", "from": "java.net.DatagramSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Set\u003cSocketOption\u003c?\u003e\u003e supportedOptions()"}, {"arrows": "to", "from": "public void connect(InetAddress address, int port)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public void connect(InetAddress address, int port)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "send"}, {"arrows": "to", "from": "public void connect(InetAddress address, int port)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "receive"}, {"arrows": "to", "from": "public void connect(InetAddress address, int port)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.InetAddress"}, {"arrows": "to", "from": "public void connect(InetAddress address, int port)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkAccept"}, {"arrows": "to", "from": "public void connect(SocketAddress addr) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "connect(InetAddress"}, {"arrows": "to", "from": "public void connect(SocketAddress addr) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.InetSocketAddress"}, {"arrows": "to", "from": "public synchronized void setReuseAddress(boolean on) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "bind(SocketAddress)"}, {"arrows": "to", "from": "public synchronized void setReuseAddress(boolean on) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.MulticastSocket"}, {"arrows": "to", "from": "public synchronized void setReuseAddress(boolean on) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getReuseAddress()"}, {"arrows": "to", "from": "public synchronized void setReuseAddress(boolean on) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isBound()"}, {"arrows": "to", "from": "java.net.MulticastSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setTimeToLive(int ttl) throws IOException"}, {"arrows": "to", "from": "java.net.MulticastSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getTimeToLive() throws IOException"}, {"arrows": "to", "from": "java.net.MulticastSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void joinGroup(InetAddress mcastaddr) throws IOException"}, {"arrows": "to", "from": "java.net.MulticastSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void leaveGroup(InetAddress mcastaddr) throws IOException"}, {"arrows": "to", "from": "java.net.MulticastSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException"}, {"arrows": "to", "from": "java.net.MulticastSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException"}, {"arrows": "to", "from": "java.net.MulticastSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setInterface(InetAddress inf) throws SocketException"}, {"arrows": "to", "from": "java.net.MulticastSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public InetAddress getInterface() throws SocketException"}, {"arrows": "to", "from": "java.net.MulticastSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setNetworkInterface(NetworkInterface netIf) throws SocketException"}, {"arrows": "to", "from": "java.net.MulticastSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public NetworkInterface getNetworkInterface() throws SocketException"}, {"arrows": "to", "from": "java.net.MulticastSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setLoopbackMode(boolean disable) throws SocketException"}, {"arrows": "to", "from": "java.net.MulticastSocket", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean getLoopbackMode() throws SocketException"}, {"arrows": "to", "from": "public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "setNetworkInterface(NetworkInterface)"}, {"arrows": "to", "from": "public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "setInterface(InetAddress)"}, {"arrows": "to", "from": "public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "setNetworkInterface(NetworkInterface)"}, {"arrows": "to", "from": "public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "setInterface(InetAddress)"}, {"arrows": "to", "from": "public void setLoopbackMode(boolean disable) throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getLoopbackMode()"}, {"arrows": "to", "from": "public synchronized int getTrafficClass() throws SocketException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "setTrafficClass(int)"}, {"arrows": "to", "from": "public DatagramChannel getChannel()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.DatagramChannel"}, {"arrows": "to", "from": "public DatagramSocket setOption(SocketOption\u003cT\u003e name, T value) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.StandardSocketOptions"}, {"arrows": "to", "from": "public abstract DatagramChannel connect(SocketAddress remote) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.DatagramSocket"}, {"arrows": "to", "from": "public abstract DatagramChannel connect(SocketAddress remote) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public abstract DatagramChannel connect(SocketAddress remote) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "bind"}, {"arrows": "to", "from": "public abstract DatagramChannel connect(SocketAddress remote) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkAccept"}, {"arrows": "to", "from": "public abstract SocketAddress receive(ByteBuffer dst) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.DatagramSocket"}, {"arrows": "to", "from": "public abstract SocketAddress receive(ByteBuffer dst) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "read(java.nio.ByteBuffer)"}, {"arrows": "to", "from": "public abstract SocketAddress receive(ByteBuffer dst) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "receive"}, {"arrows": "to", "from": "public abstract SocketAddress receive(ByteBuffer dst) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "connect"}, {"arrows": "to", "from": "public abstract SocketAddress receive(ByteBuffer dst) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "bind"}, {"arrows": "to", "from": "public abstract SocketAddress receive(ByteBuffer dst) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkAccept"}, {"arrows": "to", "from": "java.nio.channels.ReadableByteChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int read(ByteBuffer dst) throws IOException"}, {"arrows": "to", "from": "public abstract int send(ByteBuffer src, SocketAddress target) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.DatagramSocket"}, {"arrows": "to", "from": "public abstract int send(ByteBuffer src, SocketAddress target) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "write(java.nio.ByteBuffer)"}, {"arrows": "to", "from": "public abstract int send(ByteBuffer src, SocketAddress target) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "send"}, {"arrows": "to", "from": "public abstract int send(ByteBuffer src, SocketAddress target) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "connect"}, {"arrows": "to", "from": "public abstract int send(ByteBuffer src, SocketAddress target) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public abstract int send(ByteBuffer src, SocketAddress target) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "bind"}, {"arrows": "to", "from": "java.nio.channels.WritableByteChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int write(ByteBuffer src) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.ScatteringByteChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long read(ByteBuffer[] dsts, int offset, int length) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.ScatteringByteChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long read(ByteBuffer[] dsts) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.GatheringByteChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long write(ByteBuffer[] srcs, int offset, int length) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.GatheringByteChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long write(ByteBuffer[] srcs) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.Channel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isOpen()"}, {"arrows": "to", "from": "java.nio.channels.Channel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void close() throws IOException"}, {"arrows": "to", "from": "public static native long nanoTime()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "currentTimeMillis()"}, {"arrows": "to", "from": "public static native long nanoTime()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "android.os.SystemClock"}, {"arrows": "to", "from": "android.os.SystemClock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void sleep(long ms)"}, {"arrows": "to", "from": "android.os.SystemClock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean setCurrentTimeMillis(long millis)"}, {"arrows": "to", "from": "android.os.SystemClock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static native long uptimeMillis()"}, {"arrows": "to", "from": "android.os.SystemClock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static native long uptimeNanos()"}, {"arrows": "to", "from": "android.os.SystemClock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static native long elapsedRealtime()"}, {"arrows": "to", "from": "android.os.SystemClock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static native long elapsedRealtimeNanos()"}, {"arrows": "to", "from": "android.os.SystemClock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static native long currentThreadTimeMillis()"}, {"arrows": "to", "from": "android.os.SystemClock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Clock currentNetworkTimeClock()"}, {"arrows": "to", "from": "android.os.SystemClock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Clock currentGnssTimeClock()"}, {"arrows": "to", "from": "public static void sleep(long ms)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "interrupt()"}, {"arrows": "to", "from": "public static void sleep(long ms)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sleep(long)"}, {"arrows": "to", "from": "public static void sleep(long ms)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "InterruptedException"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static native Thread currentThread()"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static native void yield()"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void sleep(long millis) throws InterruptedException"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void sleep(long millis, int nanos) throws InterruptedException"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void onSpinWait()"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected Object clone() throws CloneNotSupportedException"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void init2(Thread parent, boolean inheritThreadLocals)"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized void start()"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static native void nativeCreate(Thread t, long stackSize, boolean daemon)"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void run()"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void exit()"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void interrupt()"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static native boolean interrupted()"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public native boolean isInterrupted()"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final boolean isAlive()"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final void setPriority(int newPriority)"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final int getPriority()"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final synchronized void setName(String name)"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final String getName()"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final ThreadGroup getThreadGroup()"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int activeCount()"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static int enumerate(Thread[] tarray)"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final void join(long millis) throws InterruptedException"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final void join(long millis, int nanos) throws InterruptedException"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final void join() throws InterruptedException"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void dumpStack()"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final void setDaemon(boolean on)"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final boolean isDaemon()"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final void checkAccess()"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ClassLoader getContextClassLoader()"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setContextClassLoader(ClassLoader cl)"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static native boolean holdsLock(Object obj)"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public StackTraceElement[] getStackTrace()"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Map\u003cThread, StackTraceElement[]\u003e getAllStackTraces()"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static boolean isCCLOverridden(Class\u003c?\u003e cl)"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static boolean auditSubclass(final Class\u003c?\u003e subcl)"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long getId()"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public State getState()"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh)"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public UncaughtExceptionHandler getUncaughtExceptionHandler()"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setUncaughtExceptionHandler(UncaughtExceptionHandler eh)"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final void dispatchUncaughtException(Throwable e)"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static void processQueue(ReferenceQueue\u003cClass\u003c?\u003e\u003e queue, ConcurrentMap\u003c? extends WeakReference\u003cClass\u003c?\u003e\u003e, ?\u003e map)"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " native void setPriority0(int newPriority)"}, {"arrows": "to", "from": "java.lang.Thread", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private native int nativeGetStatus(boolean hasBeenStarted)"}, {"arrows": "to", "from": "public static native void yield()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.concurrent.locks"}, {"arrows": "to", "from": "public void interrupt()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sleep(long)"}, {"arrows": "to", "from": "public void interrupt()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sleep(long"}, {"arrows": "to", "from": "public void interrupt()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkAccess()"}, {"arrows": "to", "from": "public void interrupt()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "wait(long)"}, {"arrows": "to", "from": "public void interrupt()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "join()"}, {"arrows": "to", "from": "public void interrupt()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.Selector"}, {"arrows": "to", "from": "public void interrupt()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "wakeup"}, {"arrows": "to", "from": "public void interrupt()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.Object"}, {"arrows": "to", "from": "public void interrupt()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.ClosedByInterruptException"}, {"arrows": "to", "from": "public void interrupt()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.InterruptibleChannel"}, {"arrows": "to", "from": "public void interrupt()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "wait(long"}, {"arrows": "to", "from": "public void interrupt()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.InterruptedException"}, {"arrows": "to", "from": "public void interrupt()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "join(long)"}, {"arrows": "to", "from": "public void interrupt()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityException"}, {"arrows": "to", "from": "public void interrupt()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "join(long"}, {"arrows": "to", "from": "java.lang.Object", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final Class\u003c?\u003e getClass()"}, {"arrows": "to", "from": "java.lang.Object", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int hashCode()"}, {"arrows": "to", "from": "java.lang.Object", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static int identityHashCode(Object obj)"}, {"arrows": "to", "from": "java.lang.Object", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static native int identityHashCodeNative(Object obj)"}, {"arrows": "to", "from": "java.lang.Object", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean equals(Object obj)"}, {"arrows": "to", "from": "java.lang.Object", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected Object clone() throws CloneNotSupportedException"}, {"arrows": "to", "from": "java.lang.Object", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private native Object internalClone()"}, {"arrows": "to", "from": "java.lang.Object", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.lang.Object", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final native void notify()"}, {"arrows": "to", "from": "java.lang.Object", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final native void notifyAll()"}, {"arrows": "to", "from": "java.lang.Object", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final void wait(long timeoutMillis) throws InterruptedException"}, {"arrows": "to", "from": "java.lang.Object", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final native void wait(long timeoutMillis, int nanos) throws InterruptedException"}, {"arrows": "to", "from": "java.lang.Object", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final void wait() throws InterruptedException"}, {"arrows": "to", "from": "java.lang.Object", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void finalize() throws Throwable"}, {"arrows": "to", "from": "public final void wait() throws InterruptedException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "wait(long"}, {"arrows": "to", "from": "java.nio.channels.Selector", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Selector open() throws IOException"}, {"arrows": "to", "from": "java.nio.channels.Selector", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract boolean isOpen()"}, {"arrows": "to", "from": "java.nio.channels.Selector", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract SelectorProvider provider()"}, {"arrows": "to", "from": "java.nio.channels.Selector", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract Set\u003cSelectionKey\u003e keys()"}, {"arrows": "to", "from": "java.nio.channels.Selector", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract Set\u003cSelectionKey\u003e selectedKeys()"}, {"arrows": "to", "from": "java.nio.channels.Selector", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int selectNow() throws IOException"}, {"arrows": "to", "from": "java.nio.channels.Selector", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int select(long timeout) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.Selector", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int select() throws IOException"}, {"arrows": "to", "from": "java.nio.channels.Selector", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int select(Consumer\u003cSelectionKey\u003e action, long timeout) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.Selector", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int select(Consumer\u003cSelectionKey\u003e action) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.Selector", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int selectNow(Consumer\u003cSelectionKey\u003e action) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.Selector", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int doSelect(Consumer\u003cSelectionKey\u003e action, long timeout) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.Selector", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract Selector wakeup()"}, {"arrows": "to", "from": "java.nio.channels.Selector", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract void close() throws IOException"}, {"arrows": "to", "from": "public static Selector open() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.spi.SelectorProvider"}, {"arrows": "to", "from": "public abstract Set\u003cSelectionKey\u003e keys()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UnsupportedOperationException"}, {"arrows": "to", "from": "public abstract Set\u003cSelectionKey\u003e selectedKeys()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UnsupportedOperationException"}, {"arrows": "to", "from": "public abstract int selectNow() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "wakeup"}, {"arrows": "to", "from": "public abstract int select(long timeout) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "wakeup"}, {"arrows": "to", "from": "public abstract int select(long timeout) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "wait(long)"}, {"arrows": "to", "from": "public abstract int select() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "wakeup"}, {"arrows": "to", "from": "public int select(Consumer\u003cSelectionKey\u003e action, long timeout) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "wakeup"}, {"arrows": "to", "from": "public int select(Consumer\u003cSelectionKey\u003e action, long timeout) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "wait(long)"}, {"arrows": "to", "from": "public int select(Consumer\u003cSelectionKey\u003e action, long timeout) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.SelectionKey"}, {"arrows": "to", "from": "public int select(Consumer\u003cSelectionKey\u003e action, long timeout) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "select(long)"}, {"arrows": "to", "from": "public int select(Consumer\u003cSelectionKey\u003e action, long timeout) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "accept(Object)"}, {"arrows": "to", "from": "java.util.function.Consumer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void accept(T t)"}, {"arrows": "to", "from": "java.util.function.Consumer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Consumer\u003cT\u003e andThen(Consumer\u003c? super T\u003e after)"}, {"arrows": "to", "from": "public int select(Consumer\u003cSelectionKey\u003e action) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "wakeup"}, {"arrows": "to", "from": "public int select(Consumer\u003cSelectionKey\u003e action) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "select(Consumer"}, {"arrows": "to", "from": "public int selectNow(Consumer\u003cSelectionKey\u003e action) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "wakeup"}, {"arrows": "to", "from": "public int selectNow(Consumer\u003cSelectionKey\u003e action) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "selectNow()"}, {"arrows": "to", "from": "public abstract Selector wakeup()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "selectNow()"}, {"arrows": "to", "from": "public abstract Selector wakeup()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "selectNow(Consumer)"}, {"arrows": "to", "from": "java.nio.channels.InterruptibleChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void close() throws IOException"}, {"arrows": "to", "from": "public static int enumerate(Thread[] tarray)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkAccess"}, {"arrows": "to", "from": "public static int enumerate(Thread[] tarray)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.ThreadGroup"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static Void checkParentAccess(ThreadGroup parent)"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final String getName()"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final ThreadGroup getParent()"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final int getMaxPriority()"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final boolean isDaemon()"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized boolean isDestroyed()"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final void setDaemon(boolean daemon)"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final void setMaxPriority(int pri)"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final boolean parentOf(ThreadGroup g)"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final void checkAccess()"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int activeCount()"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int enumerate(Thread[] list)"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int enumerate(Thread[] list, boolean recurse)"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int activeGroupCount()"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int enumerate(ThreadGroup[] list)"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int enumerate(ThreadGroup[] list, boolean recurse)"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final void interrupt()"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private boolean stopOrSuspend(boolean suspend)"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final void destroy()"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private final void add(ThreadGroup g)"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void remove(ThreadGroup g)"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void addUnstarted()"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void add(Thread t)"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void threadStartFailed(Thread t)"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void threadTerminated(Thread t)"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void remove(Thread t)"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void list()"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void uncaughtException(Thread t, Throwable e)"}, {"arrows": "to", "from": "java.lang.ThreadGroup", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "public final void setMaxPriority(int pri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.Thread"}, {"arrows": "to", "from": "public void uncaughtException(Thread t, Throwable e)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "printStackTrace"}, {"arrows": "to", "from": "public void uncaughtException(Thread t, Throwable e)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Thread.UncaughtExceptionHandler"}, {"arrows": "to", "from": "public void uncaughtException(Thread t, Throwable e)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.Thread"}, {"arrows": "to", "from": "public void uncaughtException(Thread t, Throwable e)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.ThreadDeath"}, {"arrows": "to", "from": "java.lang.Throwable", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMessage()"}, {"arrows": "to", "from": "java.lang.Throwable", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getLocalizedMessage()"}, {"arrows": "to", "from": "java.lang.Throwable", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized Throwable getCause()"}, {"arrows": "to", "from": "java.lang.Throwable", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized Throwable initCause(Throwable cause)"}, {"arrows": "to", "from": "java.lang.Throwable", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final void setCause(Throwable t)"}, {"arrows": "to", "from": "java.lang.Throwable", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.lang.Throwable", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void printStackTrace()"}, {"arrows": "to", "from": "java.lang.Throwable", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void printStackTrace(PrintStream s)"}, {"arrows": "to", "from": "java.lang.Throwable", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void printEnclosedStackTrace(PrintStreamOrWriter s, StackTraceElement[] enclosingTrace, String caption, String prefix, Set\u003cThrowable\u003e dejaVu)"}, {"arrows": "to", "from": "java.lang.Throwable", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void printStackTrace(PrintWriter s)"}, {"arrows": "to", "from": "java.lang.Throwable", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public synchronized Throwable fillInStackTrace()"}, {"arrows": "to", "from": "java.lang.Throwable", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static native Object nativeFillInStackTrace()"}, {"arrows": "to", "from": "java.lang.Throwable", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public StackTraceElement[] getStackTrace()"}, {"arrows": "to", "from": "java.lang.Throwable", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setStackTrace(StackTraceElement[] stackTrace)"}, {"arrows": "to", "from": "java.lang.Throwable", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static native StackTraceElement[] nativeGetStackTrace(Object stackState)"}, {"arrows": "to", "from": "java.lang.Throwable", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException"}, {"arrows": "to", "from": "java.lang.Throwable", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private synchronized void writeObject(ObjectOutputStream s) throws IOException"}, {"arrows": "to", "from": "java.lang.Throwable", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final synchronized void addSuppressed(Throwable exception)"}, {"arrows": "to", "from": "java.lang.Throwable", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final synchronized Throwable[] getSuppressed()"}, {"arrows": "to", "from": "public synchronized Throwable getCause()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "initCause(Throwable)"}, {"arrows": "to", "from": "public synchronized Throwable initCause(Throwable cause)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getCause()"}, {"arrows": "to", "from": "public synchronized Throwable initCause(Throwable cause)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Throwable(String"}, {"arrows": "to", "from": "public synchronized Throwable initCause(Throwable cause)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Throwable(Throwable)"}, {"arrows": "to", "from": "public void printStackTrace()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "fillInStackTrace()"}, {"arrows": "to", "from": "public void printStackTrace()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toString()"}, {"arrows": "to", "from": "public StackTraceElement[] getStackTrace()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "printStackTrace()"}, {"arrows": "to", "from": "public void setStackTrace(StackTraceElement[] stackTrace)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "fillInStackTrace()"}, {"arrows": "to", "from": "public void setStackTrace(StackTraceElement[] stackTrace)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getStackTrace()"}, {"arrows": "to", "from": "public void setStackTrace(StackTraceElement[] stackTrace)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "printStackTrace()"}, {"arrows": "to", "from": "public final void setDaemon(boolean on)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkAccess"}, {"arrows": "to", "from": "public void setContextClassLoader(ClassLoader cl)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public void setContextClassLoader(ClassLoader cl)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.RuntimePermission"}, {"arrows": "to", "from": "public static Map\u003cThread, StackTraceElement[]\u003e getAllStackTraces()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getStackTrace"}, {"arrows": "to", "from": "public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.ThreadGroup"}, {"arrows": "to", "from": "public static Clock currentNetworkTimeClock()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "currentTimeMillis()"}, {"arrows": "to", "from": "public static Clock currentNetworkTimeClock()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "millis()"}, {"arrows": "to", "from": "public static Clock currentNetworkTimeClock()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.time.Clock"}, {"arrows": "to", "from": "public static Clock currentGnssTimeClock()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.time.Clock"}, {"arrows": "to", "from": "public static Properties getProperties()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createTempFile"}, {"arrows": "to", "from": "public static Properties getProperties()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getProperty(String)"}, {"arrows": "to", "from": "public static Properties getProperties()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "separator"}, {"arrows": "to", "from": "public static Properties getProperties()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.File"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final boolean isInvalid()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int getPrefixLength()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getName()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getParent()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public File getParentFile()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getPath()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isAbsolute()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getAbsolutePath()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public File getAbsoluteFile()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getCanonicalPath() throws IOException"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public File getCanonicalFile() throws IOException"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public URI toURI()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean canRead()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean canWrite()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean exists()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isDirectory()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isFile()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isHidden()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long lastModified()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long length()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean createNewFile() throws IOException"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean delete()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void deleteOnExit()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String[] list()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String[] list(FilenameFilter filter)"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public File[] listFiles()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public File[] listFiles(FilenameFilter filter)"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public File[] listFiles(FileFilter filter)"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean mkdir()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean mkdirs()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean renameTo(File dest)"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean setLastModified(long time)"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean setReadOnly()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean setWritable(boolean writable, boolean ownerOnly)"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean setWritable(boolean writable)"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean setReadable(boolean readable, boolean ownerOnly)"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean setReadable(boolean readable)"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean setExecutable(boolean executable, boolean ownerOnly)"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean setExecutable(boolean executable)"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean canExecute()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static File[] listRoots()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long getTotalSpace()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long getFreeSpace()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long getUsableSpace()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static File createTempFile(String prefix, String suffix, File directory) throws IOException"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static File createTempFile(String prefix, String suffix) throws IOException"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int compareTo(File pathname)"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean equals(Object obj)"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int hashCode()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private synchronized void writeObject(java.io.ObjectOutputStream s) throws IOException"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private synchronized void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException"}, {"arrows": "to", "from": "java.io.File", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Path toPath()"}, {"arrows": "to", "from": "public String getPath()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "separator"}, {"arrows": "to", "from": "public String getPath()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getRawPath()"}, {"arrows": "to", "from": "public File getAbsoluteFile()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getAbsolutePath"}, {"arrows": "to", "from": "public String getCanonicalPath() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public String getCanonicalPath() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getAbsolutePath"}, {"arrows": "to", "from": "public File getCanonicalFile() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public File getCanonicalFile() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getCanonicalPath"}, {"arrows": "to", "from": "public URI toURI()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "File(java.net.URI)"}, {"arrows": "to", "from": "public URI toURI()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getAbsoluteFile()"}, {"arrows": "to", "from": "public URI toURI()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Path"}, {"arrows": "to", "from": "public URI toURI()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toPath"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Path of(String first, String... more)"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Path of(URI uri)"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " FileSystem getFileSystem()"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean isAbsolute()"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Path getRoot()"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Path getFileName()"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Path getParent()"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int getNameCount()"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Path getName(int index)"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Path subpath(int beginIndex, int endIndex)"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean startsWith(Path other)"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean startsWith(String other)"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean endsWith(Path other)"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean endsWith(String other)"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Path normalize()"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Path resolve(Path other)"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Path resolve(String other)"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Path resolveSibling(Path other)"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Path resolveSibling(String other)"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Path relativize(Path other)"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " URI toUri()"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Path toAbsolutePath()"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Path toRealPath(LinkOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " File toFile()"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " WatchKey register(WatchService watcher, WatchEvent.Kind\u003c?\u003e[] events, WatchEvent.Modifier... modifiers) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " WatchKey register(WatchService watcher, WatchEvent.Kind\u003c?\u003e... events) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Iterator\u003cPath\u003e iterator()"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int compareTo(Path other)"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean equals(Object other)"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int hashCode()"}, {"arrows": "to", "from": "java.nio.file.Path", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " String toString()"}, {"arrows": "to", "from": "public static Path of(String first, String... more)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault"}, {"arrows": "to", "from": "public static Path of(String first, String... more)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.FileSystem"}, {"arrows": "to", "from": "public static Path of(String first, String... more)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSeparator"}, {"arrows": "to", "from": "java.nio.file.FileSystems", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static FileSystem getDefault()"}, {"arrows": "to", "from": "java.nio.file.FileSystems", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static FileSystem getFileSystem(URI uri)"}, {"arrows": "to", "from": "java.nio.file.FileSystems", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static FileSystem newFileSystem(URI uri, Map\u003cString, ?\u003e env) throws IOException"}, {"arrows": "to", "from": "java.nio.file.FileSystems", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static FileSystem newFileSystem(URI uri, Map\u003cString, ?\u003e env, ClassLoader loader) throws IOException"}, {"arrows": "to", "from": "java.nio.file.FileSystems", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static FileSystem newFileSystem(Path path, ClassLoader loader) throws IOException"}, {"arrows": "to", "from": "public static FileSystem getDefault()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.spi.FileSystemProvider"}, {"arrows": "to", "from": "public static FileSystem getDefault()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.File"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static List\u003cFileSystemProvider\u003e loadInstalledProviders()"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static List\u003cFileSystemProvider\u003e installedProviders()"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract String getScheme()"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract FileSystem newFileSystem(URI uri, Map\u003cString, ?\u003e env) throws IOException"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract FileSystem getFileSystem(URI uri)"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract Path getPath(URI uri)"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public FileSystem newFileSystem(Path path, Map\u003cString, ?\u003e env) throws IOException"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public InputStream newInputStream(Path path, OpenOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public OutputStream newOutputStream(Path path, OpenOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public FileChannel newFileChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public AsynchronousFileChannel newAsynchronousFileChannel(Path path, Set\u003c? extends OpenOption\u003e options, ExecutorService executor, FileAttribute\u003c?\u003e... attrs) throws IOException"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, DirectoryStream.Filter\u003c? super Path\u003e filter) throws IOException"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract void createDirectory(Path dir, FileAttribute\u003c?\u003e... attrs) throws IOException"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void createSymbolicLink(Path link, Path target, FileAttribute\u003c?\u003e... attrs) throws IOException"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void createLink(Path link, Path existing) throws IOException"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract void delete(Path path) throws IOException"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean deleteIfExists(Path path) throws IOException"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Path readSymbolicLink(Path link) throws IOException"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract void copy(Path source, Path target, CopyOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract void move(Path source, Path target, CopyOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract boolean isSameFile(Path path, Path path2) throws IOException"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract boolean isHidden(Path path) throws IOException"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract FileStore getFileStore(Path path) throws IOException"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract void checkAccess(Path path, AccessMode... modes) throws IOException"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract V getFileAttributeView(Path path, Class\u003cV\u003e type, LinkOption... options)"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract A readAttributes(Path path, Class\u003cA\u003e type, LinkOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract Map\u003cString, Object\u003e readAttributes(Path path, String attributes, LinkOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.spi.FileSystemProvider", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract void setAttribute(Path path, String attribute, Object value, LinkOption... options) throws IOException"}, {"arrows": "to", "from": "public static List\u003cFileSystemProvider\u003e installedProviders()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FileSystems"}, {"arrows": "to", "from": "public abstract FileSystem newFileSystem(URI uri, Map\u003cString, ?\u003e env) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "newFileSystem(URI"}, {"arrows": "to", "from": "public abstract FileSystem newFileSystem(URI uri, Map\u003cString, ?\u003e env) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close"}, {"arrows": "to", "from": "public abstract FileSystem newFileSystem(URI uri, Map\u003cString, ?\u003e env) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FileSystemAlreadyExistsException"}, {"arrows": "to", "from": "java.nio.file.FileSystem", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract FileSystemProvider provider()"}, {"arrows": "to", "from": "java.nio.file.FileSystem", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract void close() throws IOException"}, {"arrows": "to", "from": "java.nio.file.FileSystem", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract boolean isOpen()"}, {"arrows": "to", "from": "java.nio.file.FileSystem", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract boolean isReadOnly()"}, {"arrows": "to", "from": "java.nio.file.FileSystem", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract String getSeparator()"}, {"arrows": "to", "from": "java.nio.file.FileSystem", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract Iterable\u003cPath\u003e getRootDirectories()"}, {"arrows": "to", "from": "java.nio.file.FileSystem", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract Iterable\u003cFileStore\u003e getFileStores()"}, {"arrows": "to", "from": "java.nio.file.FileSystem", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract Set\u003cString\u003e supportedFileAttributeViews()"}, {"arrows": "to", "from": "java.nio.file.FileSystem", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract Path getPath(String first, String... more)"}, {"arrows": "to", "from": "java.nio.file.FileSystem", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract PathMatcher getPathMatcher(String syntaxAndPattern)"}, {"arrows": "to", "from": "java.nio.file.FileSystem", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract UserPrincipalLookupService getUserPrincipalLookupService()"}, {"arrows": "to", "from": "java.nio.file.FileSystem", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract WatchService newWatchService() throws IOException"}, {"arrows": "to", "from": "java.nio.file.DirectoryStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Iterator\u003cT\u003e iterator()"}, {"arrows": "to", "from": "java.nio.file.WatchService", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void close() throws IOException"}, {"arrows": "to", "from": "java.nio.file.WatchService", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " WatchKey poll()"}, {"arrows": "to", "from": "java.nio.file.WatchService", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " WatchKey poll(long timeout, TimeUnit unit) throws InterruptedException"}, {"arrows": "to", "from": "java.nio.file.WatchService", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " WatchKey take() throws InterruptedException"}, {"arrows": "to", "from": " void close() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "poll(long"}, {"arrows": "to", "from": " void close() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.ClosedWatchServiceException"}, {"arrows": "to", "from": " void close() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isValidinvalidated"}, {"arrows": "to", "from": " void close() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "take"}, {"arrows": "to", "from": "java.nio.file.WatchKey", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean isValid()"}, {"arrows": "to", "from": "java.nio.file.WatchKey", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " List\u003cWatchEvent\u003c?\u003e\u003e pollEvents()"}, {"arrows": "to", "from": "java.nio.file.WatchKey", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean reset()"}, {"arrows": "to", "from": "java.nio.file.WatchKey", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void cancel()"}, {"arrows": "to", "from": "java.nio.file.WatchKey", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Watchable watchable()"}, {"arrows": "to", "from": " boolean reset()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isValid"}, {"arrows": "to", "from": " void cancel()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "pollEvents"}, {"arrows": "to", "from": "public abstract String getSeparator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toString()"}, {"arrows": "to", "from": "public abstract String getSeparator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "separator"}, {"arrows": "to", "from": "public abstract Iterable\u003cPath\u003e getRootDirectories()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public abstract Iterable\u003cFileStore\u003e getFileStores()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.FileStore"}, {"arrows": "to", "from": "public abstract Iterable\u003cFileStore\u003e getFileStores()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public abstract Iterable\u003cFileStore\u003e getFileStores()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "RuntimePermission"}, {"arrows": "to", "from": "java.nio.file.FileStore", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract String name()"}, {"arrows": "to", "from": "java.nio.file.FileStore", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract String type()"}, {"arrows": "to", "from": "java.nio.file.FileStore", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract boolean isReadOnly()"}, {"arrows": "to", "from": "java.nio.file.FileStore", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract long getTotalSpace() throws IOException"}, {"arrows": "to", "from": "java.nio.file.FileStore", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract long getUsableSpace() throws IOException"}, {"arrows": "to", "from": "java.nio.file.FileStore", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long getBlockSize() throws IOException"}, {"arrows": "to", "from": "java.nio.file.FileStore", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract long getUnallocatedSpace() throws IOException"}, {"arrows": "to", "from": "java.nio.file.FileStore", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract boolean supportsFileAttributeView(Class\u003c? extends FileAttributeView\u003e type)"}, {"arrows": "to", "from": "java.nio.file.FileStore", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract boolean supportsFileAttributeView(String name)"}, {"arrows": "to", "from": "java.nio.file.FileStore", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract V getFileStoreAttributeView(Class\u003cV\u003e type)"}, {"arrows": "to", "from": "java.nio.file.FileStore", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract Object getAttribute(String attribute) throws IOException"}, {"arrows": "to", "from": "public abstract String name()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toString()"}, {"arrows": "to", "from": "public abstract boolean supportsFileAttributeView(Class\u003c? extends FileAttributeView\u003e type)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.BasicFileAttributeView"}, {"arrows": "to", "from": "public abstract boolean supportsFileAttributeView(String name)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "name"}, {"arrows": "to", "from": "public abstract boolean supportsFileAttributeView(String name)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.BasicFileAttributeView"}, {"arrows": "to", "from": "public abstract Object getAttribute(String attribute) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.FileStore"}, {"arrows": "to", "from": "public abstract Object getAttribute(String attribute) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "name"}, {"arrows": "to", "from": "public abstract Set\u003cString\u003e supportedFileAttributeViews()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "name"}, {"arrows": "to", "from": "public abstract Set\u003cString\u003e supportedFileAttributeViews()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.BasicFileAttributeView"}, {"arrows": "to", "from": "public abstract Set\u003cString\u003e supportedFileAttributeViews()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.FileStore"}, {"arrows": "to", "from": "public abstract Path getPath(String first, String... more)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSeparatorname"}, {"arrows": "to", "from": "public abstract Path getPath(String first, String... more)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.InvalidPathException"}, {"arrows": "to", "from": "public abstract Path getPath(String first, String... more)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Path"}, {"arrows": "to", "from": "java.nio.file.InvalidPathException", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getInput()"}, {"arrows": "to", "from": "java.nio.file.InvalidPathException", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getReason()"}, {"arrows": "to", "from": "java.nio.file.InvalidPathException", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getIndex()"}, {"arrows": "to", "from": "java.nio.file.InvalidPathException", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMessage()"}, {"arrows": "to", "from": "public abstract PathMatcher getPathMatcher(String syntaxAndPattern)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Path"}, {"arrows": "to", "from": "public abstract PathMatcher getPathMatcher(String syntaxAndPattern)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isHidden"}, {"arrows": "to", "from": "public abstract PathMatcher getPathMatcher(String syntaxAndPattern)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.regex.Pattern"}, {"arrows": "to", "from": "public abstract PathMatcher getPathMatcher(String syntaxAndPattern)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSeparator"}, {"arrows": "to", "from": "public abstract PathMatcher getPathMatcher(String syntaxAndPattern)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Charactercharacters"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static FileSystemProvider provider(Path path)"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static Runnable asUncheckedRunnable(Closeable c)"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static InputStream newInputStream(Path path, OpenOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static OutputStream newOutputStream(Path path, OpenOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static SeekableByteChannel newByteChannel(Path path, OpenOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, String glob) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, DirectoryStream.Filter\u003c? super Path\u003e filter) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Path createFile(Path path, FileAttribute\u003c?\u003e... attrs) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Path createDirectory(Path dir, FileAttribute\u003c?\u003e... attrs) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Path createDirectories(Path dir, FileAttribute\u003c?\u003e... attrs) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void createAndCheckIsDirectory(Path dir, FileAttribute\u003c?\u003e... attrs) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Path createTempFile(Path dir, String prefix, String suffix, FileAttribute\u003c?\u003e... attrs) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Path createTempFile(String prefix, String suffix, FileAttribute\u003c?\u003e... attrs) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Path createTempDirectory(Path dir, String prefix, FileAttribute\u003c?\u003e... attrs) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Path createTempDirectory(String prefix, FileAttribute\u003c?\u003e... attrs) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Path createSymbolicLink(Path link, Path target, FileAttribute\u003c?\u003e... attrs) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Path createLink(Path link, Path existing) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static void delete(Path path) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean deleteIfExists(Path path) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Path copy(Path source, Path target, CopyOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Path move(Path source, Path target, CopyOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Path readSymbolicLink(Path link) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static FileStore getFileStore(Path path) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isSameFile(Path path, Path path2) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isHidden(Path path) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static String probeContentType(Path path) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static V getFileAttributeView(Path path, Class\u003cV\u003e type, LinkOption... options)"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static A readAttributes(Path path, Class\u003cA\u003e type, LinkOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Path setAttribute(Path path, String attribute, Object value, LinkOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Object getAttribute(Path path, String attribute, LinkOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Map\u003cString, Object\u003e readAttributes(Path path, String attributes, LinkOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Set\u003cPosixFilePermission\u003e getPosixFilePermissions(Path path, LinkOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Path setPosixFilePermissions(Path path, Set\u003cPosixFilePermission\u003e perms) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static UserPrincipal getOwner(Path path, LinkOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Path setOwner(Path path, UserPrincipal owner) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isSymbolicLink(Path path)"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isDirectory(Path path, LinkOption... options)"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isRegularFile(Path path, LinkOption... options)"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static FileTime getLastModifiedTime(Path path, LinkOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Path setLastModifiedTime(Path path, FileTime time) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static long size(Path path) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static boolean followLinks(LinkOption... options)"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean exists(Path path, LinkOption... options)"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean notExists(Path path, LinkOption... options)"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static boolean isAccessible(Path path, AccessMode... modes)"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isReadable(Path path)"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isWritable(Path path)"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static boolean isExecutable(Path path)"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Path walkFileTree(Path start, Set\u003cFileVisitOption\u003e options, int maxDepth, FileVisitor\u003c? super Path\u003e visitor) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Path walkFileTree(Path start, FileVisitor\u003c? super Path\u003e visitor) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static BufferedReader newBufferedReader(Path path, Charset cs) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static BufferedReader newBufferedReader(Path path) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static BufferedWriter newBufferedWriter(Path path, Charset cs, OpenOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static BufferedWriter newBufferedWriter(Path path, OpenOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static long copy(InputStream source, OutputStream sink) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static long copy(InputStream in, Path target, CopyOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static long copy(Path source, OutputStream out) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static byte[] read(InputStream source, int initialSize) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static byte[] readAllBytes(Path path) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static List\u003cString\u003e readAllLines(Path path, Charset cs) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static List\u003cString\u003e readAllLines(Path path) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Path write(Path path, byte[] bytes, OpenOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Path write(Path path, Iterable\u003c? extends CharSequence\u003e lines, Charset cs, OpenOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Path write(Path path, Iterable\u003c? extends CharSequence\u003e lines, OpenOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Stream\u003cPath\u003e list(Path dir) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Stream\u003cPath\u003e walk(Path start, int maxDepth, FileVisitOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Stream\u003cPath\u003e walk(Path start, FileVisitOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Stream\u003cPath\u003e find(Path start, int maxDepth, BiPredicate\u003cPath, BasicFileAttributes\u003e matcher, FileVisitOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Stream\u003cString\u003e lines(Path path, Charset cs) throws IOException"}, {"arrows": "to", "from": "java.nio.file.Files", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Stream\u003cString\u003e lines(Path path) throws IOException"}, {"arrows": "to", "from": "public static InputStream newInputStream(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static InputStream newInputStream(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.InputStream"}, {"arrows": "to", "from": "public static InputStream newInputStream(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "reset"}, {"arrows": "to", "from": "public static InputStream newInputStream(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ"}, {"arrows": "to", "from": "public static OutputStream newOutputStream(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "newByteChannel(Path"}, {"arrows": "to", "from": "public static OutputStream newOutputStream(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "WRITE"}, {"arrows": "to", "from": "public static OutputStream newOutputStream(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CREATECREATE"}, {"arrows": "to", "from": "public static OutputStream newOutputStream(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkDelete(String)"}, {"arrows": "to", "from": "public static OutputStream newOutputStream(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ"}, {"arrows": "to", "from": "public static OutputStream newOutputStream(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "TRUNCATE_EXISTING"}, {"arrows": "to", "from": "public static OutputStream newOutputStream(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isRegularFileregular"}, {"arrows": "to", "from": "public static OutputStream newOutputStream(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SPARSE"}, {"arrows": "to", "from": "public static SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "WRITE"}, {"arrows": "to", "from": "public static SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ"}, {"arrows": "to", "from": "public static SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SYNC"}, {"arrows": "to", "from": "public static SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "DSYNC"}, {"arrows": "to", "from": "public static SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkDelete(String)"}, {"arrows": "to", "from": "public static SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CREATE"}, {"arrows": "to", "from": "public static SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "TRUNCATE_EXISTING"}, {"arrows": "to", "from": "public static SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "APPEND"}, {"arrows": "to", "from": "public static SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "DELETE_ON_CLOSE"}, {"arrows": "to", "from": "public static SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close"}, {"arrows": "to", "from": "public static SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CREATE_NEW"}, {"arrows": "to", "from": "public static SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FileAttributefile"}, {"arrows": "to", "from": "public static SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.FileChannel"}, {"arrows": "to", "from": "java.nio.channels.SeekableByteChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int read(ByteBuffer dst) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.SeekableByteChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int write(ByteBuffer src) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.SeekableByteChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " long position() throws IOException"}, {"arrows": "to", "from": "java.nio.channels.SeekableByteChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " SeekableByteChannel position(long newPosition) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.SeekableByteChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " long size() throws IOException"}, {"arrows": "to", "from": "java.nio.channels.SeekableByteChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " SeekableByteChannel truncate(long size) throws IOException"}, {"arrows": "to", "from": " int read(ByteBuffer dst) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.ReadableByteChannel"}, {"arrows": "to", "from": " int write(ByteBuffer src) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.WritableByteChannel"}, {"arrows": "to", "from": " int write(ByteBuffer src) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "APPEND"}, {"arrows": "to", "from": " SeekableByteChannel position(long newPosition) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "APPEND"}, {"arrows": "to", "from": " SeekableByteChannel truncate(long size) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "APPEND"}, {"arrows": "to", "from": "java.nio.channels.FileChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static FileChannel open(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.FileChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static FileChannel open(Path path, OpenOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.FileChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int read(ByteBuffer dst) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.FileChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract long read(ByteBuffer[] dsts, int offset, int length) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.FileChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final long read(ByteBuffer[] dsts) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.FileChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int write(ByteBuffer src) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.FileChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract long write(ByteBuffer[] srcs, int offset, int length) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.FileChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final long write(ByteBuffer[] srcs) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.FileChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract long position() throws IOException"}, {"arrows": "to", "from": "java.nio.channels.FileChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract FileChannel position(long newPosition) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.FileChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract long size() throws IOException"}, {"arrows": "to", "from": "java.nio.channels.FileChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract FileChannel truncate(long size) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.FileChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract void force(boolean metaData) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.FileChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract long transferTo(long position, long count, WritableByteChannel target) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.FileChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract long transferFrom(ReadableByteChannel src, long position, long count) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.FileChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int read(ByteBuffer dst, long position) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.FileChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int write(ByteBuffer src, long position) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.FileChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract MappedByteBuffer map(MapMode mode, long position, long size) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.FileChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract FileLock lock(long position, long size, boolean shared) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.FileChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final FileLock lock() throws IOException"}, {"arrows": "to", "from": "java.nio.channels.FileChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract FileLock tryLock(long position, long size, boolean shared) throws IOException"}, {"arrows": "to", "from": "java.nio.channels.FileChannel", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final FileLock tryLock() throws IOException"}, {"arrows": "to", "from": "public static FileChannel open(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SPARSE"}, {"arrows": "to", "from": "public static FileChannel open(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "DSYNC"}, {"arrows": "to", "from": "public static FileChannel open(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static FileChannel open(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ"}, {"arrows": "to", "from": "public static FileChannel open(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close"}, {"arrows": "to", "from": "public static FileChannel open(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SYNC"}, {"arrows": "to", "from": "public static FileChannel open(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.attribute.FileAttribute"}, {"arrows": "to", "from": "public static FileChannel open(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "APPEND"}, {"arrows": "to", "from": "public static FileChannel open(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CREATE"}, {"arrows": "to", "from": "public static FileChannel open(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static FileChannel open(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "WRITEWRITE"}, {"arrows": "to", "from": "public static FileChannel open(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "TRUNCATE_EXISTING"}, {"arrows": "to", "from": "public static FileChannel open(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "newFileChannel"}, {"arrows": "to", "from": "public static FileChannel open(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CREATE_NEW"}, {"arrows": "to", "from": "public static FileChannel open(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "DELETE_ON_CLOSE"}, {"arrows": "to", "from": "java.nio.file.attribute.FileAttribute", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " String name()"}, {"arrows": "to", "from": "java.nio.file.attribute.FileAttribute", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " T value()"}, {"arrows": "to", "from": "public static FileChannel open(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static FileChannel open(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static FileChannel open(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "open(Path"}, {"arrows": "to", "from": "public abstract void force(boolean metaData) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "map"}, {"arrows": "to", "from": "public abstract void force(boolean metaData) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "force"}, {"arrows": "to", "from": "public abstract void force(boolean metaData) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.MappedByteBuffer"}, {"arrows": "to", "from": "java.nio.MappedByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final boolean isSync()"}, {"arrows": "to", "from": "java.nio.MappedByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " final FileDescriptor fileDescriptor()"}, {"arrows": "to", "from": "java.nio.MappedByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void checkMapped()"}, {"arrows": "to", "from": "java.nio.MappedByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private long mappingOffset()"}, {"arrows": "to", "from": "java.nio.MappedByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final boolean isLoaded()"}, {"arrows": "to", "from": "java.nio.MappedByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final MappedByteBuffer load()"}, {"arrows": "to", "from": "java.nio.MappedByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final MappedByteBuffer force()"}, {"arrows": "to", "from": "java.nio.MappedByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final MappedByteBuffer force(int index, int length)"}, {"arrows": "to", "from": "java.nio.MappedByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final Buffer position(int newPosition)"}, {"arrows": "to", "from": "java.nio.MappedByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final Buffer limit(int newLimit)"}, {"arrows": "to", "from": "java.nio.MappedByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final Buffer mark()"}, {"arrows": "to", "from": "java.nio.MappedByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final Buffer reset()"}, {"arrows": "to", "from": "java.nio.MappedByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final Buffer clear()"}, {"arrows": "to", "from": "java.nio.MappedByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final Buffer flip()"}, {"arrows": "to", "from": "java.nio.MappedByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final Buffer rewind()"}, {"arrows": "to", "from": "java.nio.MappedByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer slice()"}, {"arrows": "to", "from": "java.nio.MappedByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract MappedByteBuffer slice(int index, int length)"}, {"arrows": "to", "from": "java.nio.MappedByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer duplicate()"}, {"arrows": "to", "from": "java.nio.MappedByteBuffer", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract ByteBuffer compact()"}, {"arrows": "to", "from": " final boolean isSync()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_ONLY_SYNCExtendedMapModeMapMode"}, {"arrows": "to", "from": " final boolean isSync()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "map"}, {"arrows": "to", "from": " final boolean isSync()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_ONLY_SYNCExtendedMapMode"}, {"arrows": "to", "from": "public final MappedByteBuffer force()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_WRITE"}, {"arrows": "to", "from": "public final MappedByteBuffer force(int index, int length)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_WRITE"}, {"arrows": "to", "from": "public abstract int read(ByteBuffer dst, long position) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "read(ByteBuffer)"}, {"arrows": "to", "from": "public abstract int write(ByteBuffer src, long position) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "write(ByteBuffer)"}, {"arrows": "to", "from": "public abstract MappedByteBuffer map(MapMode mode, long position, long size) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_WRITE"}, {"arrows": "to", "from": "public abstract MappedByteBuffer map(MapMode mode, long position, long size) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "PRIVATE"}, {"arrows": "to", "from": "public abstract MappedByteBuffer map(MapMode mode, long position, long size) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ_ONLY"}, {"arrows": "to", "from": "public abstract MappedByteBuffer map(MapMode mode, long position, long size) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "write"}, {"arrows": "to", "from": "public abstract MappedByteBuffer map(MapMode mode, long position, long size) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "PRIVATEPRIVATE"}, {"arrows": "to", "from": "public abstract MappedByteBuffer map(MapMode mode, long position, long size) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "read"}, {"arrows": "to", "from": "public abstract MappedByteBuffer map(MapMode mode, long position, long size) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MapMode"}, {"arrows": "to", "from": "public abstract MappedByteBuffer map(MapMode mode, long position, long size) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.ReadOnlyBufferException"}, {"arrows": "to", "from": "public abstract MappedByteBuffer map(MapMode mode, long position, long size) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.MappedByteBuffer"}, {"arrows": "to", "from": "public abstract MappedByteBuffer map(MapMode mode, long position, long size) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MAX_VALUE"}, {"arrows": "to", "from": "public abstract FileLock lock(long position, long size, boolean shared) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.FileLockInterruptionException"}, {"arrows": "to", "from": "public abstract FileLock lock(long position, long size, boolean shared) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.AsynchronousCloseException"}, {"arrows": "to", "from": "public abstract FileLock lock(long position, long size, boolean shared) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MAX_VALUE"}, {"arrows": "to", "from": "public abstract FileLock lock(long position, long size, boolean shared) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isShared()"}, {"arrows": "to", "from": "public abstract FileLock lock(long position, long size, boolean shared) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "lock()"}, {"arrows": "to", "from": "java.nio.channels.FileLock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final FileChannel channel()"}, {"arrows": "to", "from": "java.nio.channels.FileLock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Channel acquiredBy()"}, {"arrows": "to", "from": "java.nio.channels.FileLock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final long position()"}, {"arrows": "to", "from": "java.nio.channels.FileLock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final long size()"}, {"arrows": "to", "from": "java.nio.channels.FileLock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final boolean isShared()"}, {"arrows": "to", "from": "java.nio.channels.FileLock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final boolean overlaps(long position, long size)"}, {"arrows": "to", "from": "java.nio.channels.FileLock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract boolean isValid()"}, {"arrows": "to", "from": "java.nio.channels.FileLock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract void release() throws IOException"}, {"arrows": "to", "from": "java.nio.channels.FileLock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final void close() throws IOException"}, {"arrows": "to", "from": "java.nio.channels.FileLock", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final String toString()"}, {"arrows": "to", "from": "public final FileChannel channel()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "acquiredBy"}, {"arrows": "to", "from": "public final void close() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "release"}, {"arrows": "to", "from": "public final FileLock lock() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "lock(long"}, {"arrows": "to", "from": "public abstract FileLock tryLock(long position, long size, boolean shared) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MAX_VALUE"}, {"arrows": "to", "from": "public abstract FileLock tryLock(long position, long size, boolean shared) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "tryLock()"}, {"arrows": "to", "from": "public abstract FileLock tryLock(long position, long size, boolean shared) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isShared()"}, {"arrows": "to", "from": "public final FileLock tryLock() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "tryLock(long"}, {"arrows": "to", "from": "public static SeekableByteChannel newByteChannel(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "newByteChannel(Path"}, {"arrows": "to", "from": "public static SeekableByteChannel newByteChannel(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static SeekableByteChannel newByteChannel(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkDelete(String)"}, {"arrows": "to", "from": "public static SeekableByteChannel newByteChannel(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CREATE_NEW"}, {"arrows": "to", "from": "public static SeekableByteChannel newByteChannel(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.DirectoryStream"}, {"arrows": "to", "from": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Path"}, {"arrows": "to", "from": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.SecureDirectoryStream"}, {"arrows": "to", "from": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "iterator"}, {"arrows": "to", "from": "java.nio.file.SecureDirectoryStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " SecureDirectoryStream\u003cT\u003e newDirectoryStream(T path, LinkOption... options) throws IOException"}, {"arrows": "to", "from": "java.nio.file.SecureDirectoryStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " SeekableByteChannel newByteChannel(T path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException"}, {"arrows": "to", "from": "java.nio.file.SecureDirectoryStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void deleteFile(T path) throws IOException"}, {"arrows": "to", "from": "java.nio.file.SecureDirectoryStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void deleteDirectory(T path) throws IOException"}, {"arrows": "to", "from": "java.nio.file.SecureDirectoryStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void move(T srcpath, SecureDirectoryStream\u003cT\u003e targetdir, T targetpath) throws IOException"}, {"arrows": "to", "from": "java.nio.file.SecureDirectoryStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " V getFileAttributeView(Class\u003cV\u003e type)"}, {"arrows": "to", "from": "java.nio.file.SecureDirectoryStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " V getFileAttributeView(T path, Class\u003cV\u003e type, LinkOption... options)"}, {"arrows": "to", "from": " SecureDirectoryStream\u003cT\u003e newDirectoryStream(T path, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": " SecureDirectoryStream\u003cT\u003e newDirectoryStream(T path, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NOFOLLOW_LINKS"}, {"arrows": "to", "from": " SecureDirectoryStream\u003cT\u003e newDirectoryStream(T path, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Files"}, {"arrows": "to", "from": " SecureDirectoryStream\u003cT\u003e newDirectoryStream(T path, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Path"}, {"arrows": "to", "from": " SeekableByteChannel newByteChannel(T path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Files"}, {"arrows": "to", "from": " SeekableByteChannel newByteChannel(T path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": " SeekableByteChannel newByteChannel(T path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NOFOLLOW_LINKS"}, {"arrows": "to", "from": " SeekableByteChannel newByteChannel(T path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CREATE_NEW"}, {"arrows": "to", "from": " SeekableByteChannel newByteChannel(T path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": " SeekableByteChannel newByteChannel(T path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Path"}, {"arrows": "to", "from": " void deleteFile(T path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkDelete(String)"}, {"arrows": "to", "from": " void deleteFile(T path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Files"}, {"arrows": "to", "from": " void deleteDirectory(T path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkDelete(String)"}, {"arrows": "to", "from": " void deleteDirectory(T path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Files"}, {"arrows": "to", "from": " void move(T srcpath, SecureDirectoryStream\u003cT\u003e targetdir, T targetpath) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Files"}, {"arrows": "to", "from": " void move(T srcpath, SecureDirectoryStream\u003cT\u003e targetdir, T targetpath) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ATOMIC_MOVE"}, {"arrows": "to", "from": " void move(T srcpath, SecureDirectoryStream\u003cT\u003e targetdir, T targetpath) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Path"}, {"arrows": "to", "from": " void move(T srcpath, SecureDirectoryStream\u003cT\u003e targetdir, T targetpath) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": " V getFileAttributeView(Class\u003cV\u003e type)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.BasicFileAttributeView"}, {"arrows": "to", "from": " V getFileAttributeView(Class\u003cV\u003e type)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close"}, {"arrows": "to", "from": " V getFileAttributeView(Class\u003cV\u003e type)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.ClosedDirectoryStreamException"}, {"arrows": "to", "from": " V getFileAttributeView(T path, Class\u003cV\u003e type, LinkOption... options)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.BasicFileAttributeView"}, {"arrows": "to", "from": " V getFileAttributeView(T path, Class\u003cV\u003e type, LinkOption... options)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close"}, {"arrows": "to", "from": " V getFileAttributeView(T path, Class\u003cV\u003e type, LinkOption... options)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.ClosedDirectoryStreamException"}, {"arrows": "to", "from": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, String glob) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.DirectoryStream"}, {"arrows": "to", "from": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, String glob) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Path"}, {"arrows": "to", "from": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, String glob) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.SecureDirectoryStream"}, {"arrows": "to", "from": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, String glob) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, String glob) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "iterator"}, {"arrows": "to", "from": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, String glob) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.FileSystem"}, {"arrows": "to", "from": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, DirectoryStream.Filter\u003c? super Path\u003e filter) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "DirectoryStream.Filterfilter"}, {"arrows": "to", "from": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, DirectoryStream.Filter\u003c? super Path\u003e filter) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.DirectoryStream"}, {"arrows": "to", "from": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, DirectoryStream.Filter\u003c? super Path\u003e filter) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Path"}, {"arrows": "to", "from": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, DirectoryStream.Filter\u003c? super Path\u003e filter) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Iterator"}, {"arrows": "to", "from": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, DirectoryStream.Filter\u003c? super Path\u003e filter) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.SecureDirectoryStream"}, {"arrows": "to", "from": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, DirectoryStream.Filter\u003c? super Path\u003e filter) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, DirectoryStream.Filter\u003c? super Path\u003e filter) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "iterator"}, {"arrows": "to", "from": "public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, DirectoryStream.Filter\u003c? super Path\u003e filter) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.DirectoryIteratorException"}, {"arrows": "to", "from": "java.nio.file.DirectoryIteratorException", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public IOException getCause()"}, {"arrows": "to", "from": "java.nio.file.DirectoryIteratorException", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException"}, {"arrows": "to", "from": "public static Path createFile(Path path, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "name"}, {"arrows": "to", "from": "public static Path createFile(Path path, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FileAttributefile"}, {"arrows": "to", "from": "public static Path createFile(Path path, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static Path createDirectory(Path dir, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "name"}, {"arrows": "to", "from": "public static Path createDirectory(Path dir, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FileAttributefile"}, {"arrows": "to", "from": "public static Path createDirectory(Path dir, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static Path createDirectory(Path dir, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createDirectories"}, {"arrows": "to", "from": "public static Path createDirectories(Path dir, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "name"}, {"arrows": "to", "from": "public static Path createDirectories(Path dir, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createDirectory"}, {"arrows": "to", "from": "public static Path createDirectories(Path dir, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkPropertyAccess(String)"}, {"arrows": "to", "from": "public static Path createDirectories(Path dir, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static Path createDirectories(Path dir, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Path"}, {"arrows": "to", "from": "public static Path createDirectories(Path dir, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FileAttributefile"}, {"arrows": "to", "from": "public static Path createDirectories(Path dir, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static Path createTempFile(Path dir, String prefix, String suffix, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.File"}, {"arrows": "to", "from": "public static Path createTempFile(Path dir, String prefix, String suffix, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "name"}, {"arrows": "to", "from": "public static Path createTempFile(Path dir, String prefix, String suffix, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "addShutdownHook"}, {"arrows": "to", "from": "public static Path createTempFile(Path dir, String prefix, String suffix, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "DELETE_ON_CLOSE"}, {"arrows": "to", "from": "public static Path createTempFile(Path dir, String prefix, String suffix, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FileAttributefile"}, {"arrows": "to", "from": "public static Path createTempFile(Path dir, String prefix, String suffix, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static Path createTempFile(String prefix, String suffix, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createTempFile(Path"}, {"arrows": "to", "from": "public static Path createTempFile(String prefix, String suffix, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static Path createTempDirectory(Path dir, String prefix, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "name"}, {"arrows": "to", "from": "public static Path createTempDirectory(Path dir, String prefix, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.File"}, {"arrows": "to", "from": "public static Path createTempDirectory(Path dir, String prefix, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "addShutdownHookshutdown"}, {"arrows": "to", "from": "public static Path createTempDirectory(Path dir, String prefix, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FileAttributefile"}, {"arrows": "to", "from": "public static Path createTempDirectory(Path dir, String prefix, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static Path createTempDirectory(String prefix, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createTempDirectory(Path"}, {"arrows": "to", "from": "public static Path createTempDirectory(String prefix, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static Path createSymbolicLink(Path link, Path target, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "name"}, {"arrows": "to", "from": "public static Path createSymbolicLink(Path link, Path target, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FileAttributeattributes"}, {"arrows": "to", "from": "public static Path createSymbolicLink(Path link, Path target, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.FileStore"}, {"arrows": "to", "from": "public static Path createSymbolicLink(Path link, Path target, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.IOException"}, {"arrows": "to", "from": "public static Path createSymbolicLink(Path link, Path target, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static Path createSymbolicLink(Path link, Path target, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Path"}, {"arrows": "to", "from": "public static Path createSymbolicLink(Path link, Path target, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.LinkPermission"}, {"arrows": "to", "from": "public static Path createLink(Path link, Path existing) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static Path createLink(Path link, Path existing) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.LinkPermission"}, {"arrows": "to", "from": "public static void delete(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkDelete(String)"}, {"arrows": "to", "from": "public static void delete(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "walkFileTree"}, {"arrows": "to", "from": "public static boolean deleteIfExists(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "delete(Path)"}, {"arrows": "to", "from": "public static boolean deleteIfExists(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkDelete(String)"}, {"arrows": "to", "from": "public static Path copy(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "lastModifiedTime"}, {"arrows": "to", "from": "public static Path copy(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "REPLACE_EXISTING"}, {"arrows": "to", "from": "public static Path copy(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static Path copy(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.IOException"}, {"arrows": "to", "from": "public static Path copy(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NOFOLLOW_LINKS"}, {"arrows": "to", "from": "public static Path copy(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "walkFileTreewalkFileTree"}, {"arrows": "to", "from": "public static Path copy(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static Path copy(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "COPY_ATTRIBUTES"}, {"arrows": "to", "from": "public static Path copy(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isSameFile"}, {"arrows": "to", "from": "public static Path copy(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.LinkPermission"}, {"arrows": "to", "from": "java.nio.file.attribute.BasicFileAttributes", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " FileTime lastModifiedTime()"}, {"arrows": "to", "from": "java.nio.file.attribute.BasicFileAttributes", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " FileTime lastAccessTime()"}, {"arrows": "to", "from": "java.nio.file.attribute.BasicFileAttributes", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " FileTime creationTime()"}, {"arrows": "to", "from": "java.nio.file.attribute.BasicFileAttributes", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean isRegularFile()"}, {"arrows": "to", "from": "java.nio.file.attribute.BasicFileAttributes", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean isDirectory()"}, {"arrows": "to", "from": "java.nio.file.attribute.BasicFileAttributes", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean isSymbolicLink()"}, {"arrows": "to", "from": "java.nio.file.attribute.BasicFileAttributes", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean isOther()"}, {"arrows": "to", "from": "java.nio.file.attribute.BasicFileAttributes", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " long size()"}, {"arrows": "to", "from": "java.nio.file.attribute.BasicFileAttributes", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Object fileKey()"}, {"arrows": "to", "from": " FileTime lastAccessTime()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "lastModifiedTime()"}, {"arrows": "to", "from": " FileTime creationTime()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "lastModifiedTime()"}, {"arrows": "to", "from": " long size()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isRegularFile"}, {"arrows": "to", "from": " Object fileKey()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Files"}, {"arrows": "to", "from": "public static Path move(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ATOMIC_MOVE"}, {"arrows": "to", "from": "public static Path move(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "copy"}, {"arrows": "to", "from": "public static Path move(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.FileStore"}, {"arrows": "to", "from": "public static Path move(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "lastModifiedTime"}, {"arrows": "to", "from": "public static Path move(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "REPLACE_EXISTING"}, {"arrows": "to", "from": "public static Path move(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "walkFileTree"}, {"arrows": "to", "from": "public static Path move(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.AtomicMoveNotSupportedException"}, {"arrows": "to", "from": "public static Path move(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.IOException"}, {"arrows": "to", "from": "public static Path move(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static Path move(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isSameFile"}, {"arrows": "to", "from": "public static FileStore getFileStore(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.FileStore"}, {"arrows": "to", "from": "public static FileStore getFileStore(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static FileStore getFileStore(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "RuntimePermission"}, {"arrows": "to", "from": "public static FileStore getFileStore(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.attribute.FileStoreAttributeView"}, {"arrows": "to", "from": "public static boolean isSameFile(Path path, Path path2) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static boolean isSameFile(Path path, Path path2) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(Object)"}, {"arrows": "to", "from": "public static boolean isHidden(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static boolean isHidden(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isHidden"}, {"arrows": "to", "from": "java.nio.file.attribute.DosFileAttributes", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean isReadOnly()"}, {"arrows": "to", "from": "java.nio.file.attribute.DosFileAttributes", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean isHidden()"}, {"arrows": "to", "from": "java.nio.file.attribute.DosFileAttributes", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean isArchive()"}, {"arrows": "to", "from": "java.nio.file.attribute.DosFileAttributes", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean isSystem()"}, {"arrows": "to", "from": "public static String probeContentType(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "probeContentType"}, {"arrows": "to", "from": "public static String probeContentType(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.ServiceLoader"}, {"arrows": "to", "from": "public static String probeContentType(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.spi.FileTypeDetector"}, {"arrows": "to", "from": "java.nio.file.spi.FileTypeDetector", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract String probeContentType(Path path) throws IOException"}, {"arrows": "to", "from": "public abstract String probeContentType(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static V getFileAttributeView(Path path, Class\u003cV\u003e type, LinkOption... options)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.attribute.BasicFileAttributeView"}, {"arrows": "to", "from": "public static V getFileAttributeView(Path path, Class\u003cV\u003e type, LinkOption... options)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NOFOLLOW_LINKS"}, {"arrows": "to", "from": "java.nio.file.attribute.BasicFileAttributeView", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " String name()"}, {"arrows": "to", "from": "java.nio.file.attribute.BasicFileAttributeView", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " BasicFileAttributes readAttributes() throws IOException"}, {"arrows": "to", "from": "java.nio.file.attribute.BasicFileAttributeView", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void setTimes(FileTime lastModifiedTime, FileTime lastAccessTime, FileTime createTime) throws IOException"}, {"arrows": "to", "from": " BasicFileAttributes readAttributes() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": " void setTimes(FileTime lastModifiedTime, FileTime lastAccessTime, FileTime createTime) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static A readAttributes(Path path, Class\u003cA\u003e type, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NOFOLLOW_LINKSNOFOLLOW_LINKS"}, {"arrows": "to", "from": "public static A readAttributes(Path path, Class\u003cA\u003e type, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static Path setAttribute(Path path, String attribute, Object value, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NOFOLLOW_LINKSNOFOLLOW_LINKS"}, {"arrows": "to", "from": "public static Path setAttribute(Path path, String attribute, Object value, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "name"}, {"arrows": "to", "from": "public static Path setAttribute(Path path, String attribute, Object value, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.attribute.BasicFileAttributeView"}, {"arrows": "to", "from": "public static Path setAttribute(Path path, String attribute, Object value, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static Object getAttribute(Path path, String attribute, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NOFOLLOW_LINKSNOFOLLOW_LINKS"}, {"arrows": "to", "from": "public static Object getAttribute(Path path, String attribute, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "name"}, {"arrows": "to", "from": "public static Object getAttribute(Path path, String attribute, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static Object getAttribute(Path path, String attribute, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.attribute.BasicFileAttributeView"}, {"arrows": "to", "from": "public static Map\u003cString, Object\u003e readAttributes(Path path, String attributes, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NOFOLLOW_LINKSNOFOLLOW_LINKS"}, {"arrows": "to", "from": "public static Map\u003cString, Object\u003e readAttributes(Path path, String attributes, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "name"}, {"arrows": "to", "from": "public static Map\u003cString, Object\u003e readAttributes(Path path, String attributes, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.attribute.PosixFileAttributes"}, {"arrows": "to", "from": "public static Map\u003cString, Object\u003e readAttributes(Path path, String attributes, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static Map\u003cString, Object\u003e readAttributes(Path path, String attributes, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.attribute.BasicFileAttributeView"}, {"arrows": "to", "from": "public static Map\u003cString, Object\u003e readAttributes(Path path, String attributes, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.attribute.BasicFileAttributes"}, {"arrows": "to", "from": "java.nio.file.attribute.PosixFileAttributes", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " UserPrincipal owner()"}, {"arrows": "to", "from": "java.nio.file.attribute.PosixFileAttributes", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " GroupPrincipal group()"}, {"arrows": "to", "from": "java.nio.file.attribute.PosixFileAttributes", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Set\u003cPosixFilePermission\u003e permissions()"}, {"arrows": "to", "from": " Set\u003cPosixFilePermission\u003e permissions()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.attribute.PosixFilePermission"}, {"arrows": "to", "from": " Set\u003cPosixFilePermission\u003e permissions()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "setPermissionssetPermissions"}, {"arrows": "to", "from": "java.nio.file.attribute.PosixFileAttributeView", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " String name()"}, {"arrows": "to", "from": "java.nio.file.attribute.PosixFileAttributeView", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " PosixFileAttributes readAttributes() throws IOException"}, {"arrows": "to", "from": "java.nio.file.attribute.PosixFileAttributeView", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void setPermissions(Set\u003cPosixFilePermission\u003e perms) throws IOException"}, {"arrows": "to", "from": "java.nio.file.attribute.PosixFileAttributeView", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void setGroup(GroupPrincipal group) throws IOException"}, {"arrows": "to", "from": " PosixFileAttributes readAttributes() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": " PosixFileAttributes readAttributes() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "RuntimePermission"}, {"arrows": "to", "from": " void setPermissions(Set\u003cPosixFilePermission\u003e perms) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "RuntimePermission"}, {"arrows": "to", "from": " void setPermissions(Set\u003cPosixFilePermission\u003e perms) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": " void setGroup(GroupPrincipal group) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "RuntimePermission"}, {"arrows": "to", "from": " void setGroup(GroupPrincipal group) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static Set\u003cPosixFilePermission\u003e getPosixFilePermissions(Path path, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NOFOLLOW_LINKSNOFOLLOW_LINKS"}, {"arrows": "to", "from": "public static Set\u003cPosixFilePermission\u003e getPosixFilePermissions(Path path, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static Set\u003cPosixFilePermission\u003e getPosixFilePermissions(Path path, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.attribute.PosixFileAttributeView"}, {"arrows": "to", "from": "public static Set\u003cPosixFilePermission\u003e getPosixFilePermissions(Path path, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "RuntimePermission"}, {"arrows": "to", "from": "public static Path setPosixFilePermissions(Path path, Set\u003cPosixFilePermission\u003e perms) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.attribute.PosixFileAttributeView"}, {"arrows": "to", "from": "public static Path setPosixFilePermissions(Path path, Set\u003cPosixFilePermission\u003e perms) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "RuntimePermission"}, {"arrows": "to", "from": "public static Path setPosixFilePermissions(Path path, Set\u003cPosixFilePermission\u003e perms) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static UserPrincipal getOwner(Path path, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static UserPrincipal getOwner(Path path, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "RuntimePermission"}, {"arrows": "to", "from": "public static UserPrincipal getOwner(Path path, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.attribute.FileOwnerAttributeView"}, {"arrows": "to", "from": "java.nio.file.attribute.FileOwnerAttributeView", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " String name()"}, {"arrows": "to", "from": "java.nio.file.attribute.FileOwnerAttributeView", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " UserPrincipal getOwner() throws IOException"}, {"arrows": "to", "from": "java.nio.file.attribute.FileOwnerAttributeView", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void setOwner(UserPrincipal owner) throws IOException"}, {"arrows": "to", "from": " UserPrincipal getOwner() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": " UserPrincipal getOwner() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "RuntimePermission"}, {"arrows": "to", "from": " UserPrincipal getOwner() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.attribute.GroupPrincipal"}, {"arrows": "to", "from": " void setOwner(UserPrincipal owner) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "RuntimePermission"}, {"arrows": "to", "from": " void setOwner(UserPrincipal owner) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.attribute.GroupPrincipal"}, {"arrows": "to", "from": " void setOwner(UserPrincipal owner) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static Path setOwner(Path path, UserPrincipal owner) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "RuntimePermission"}, {"arrows": "to", "from": "public static Path setOwner(Path path, UserPrincipal owner) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.attribute.FileOwnerAttributeView"}, {"arrows": "to", "from": "public static Path setOwner(Path path, UserPrincipal owner) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static boolean isSymbolicLink(Path path)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "readAttributes(Path"}, {"arrows": "to", "from": "public static boolean isSymbolicLink(Path path)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static boolean isSymbolicLink(Path path)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.attribute.BasicFileAttributes"}, {"arrows": "to", "from": "public static boolean isDirectory(Path path, LinkOption... options)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NOFOLLOW_LINKSNOFOLLOW_LINKS"}, {"arrows": "to", "from": "public static boolean isDirectory(Path path, LinkOption... options)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "readAttributes(Path"}, {"arrows": "to", "from": "public static boolean isDirectory(Path path, LinkOption... options)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static boolean isDirectory(Path path, LinkOption... options)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.attribute.BasicFileAttributes"}, {"arrows": "to", "from": "public static boolean isRegularFile(Path path, LinkOption... options)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NOFOLLOW_LINKSNOFOLLOW_LINKS"}, {"arrows": "to", "from": "public static boolean isRegularFile(Path path, LinkOption... options)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "readAttributes(Path"}, {"arrows": "to", "from": "public static boolean isRegularFile(Path path, LinkOption... options)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static boolean isRegularFile(Path path, LinkOption... options)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isRegularFile"}, {"arrows": "to", "from": "public static FileTime getLastModifiedTime(Path path, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NOFOLLOW_LINKSNOFOLLOW_LINKS"}, {"arrows": "to", "from": "public static FileTime getLastModifiedTime(Path path, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static Path setLastModifiedTime(Path path, FileTime time) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static long size(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isRegularFile"}, {"arrows": "to", "from": "public static long size(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static boolean exists(Path path, LinkOption... options)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NOFOLLOW_LINKSNOFOLLOW_LINKS"}, {"arrows": "to", "from": "public static boolean exists(Path path, LinkOption... options)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static boolean notExists(Path path, LinkOption... options)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NOFOLLOW_LINKSNOFOLLOW_LINKS"}, {"arrows": "to", "from": "public static boolean notExists(Path path, LinkOption... options)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static boolean notExists(Path path, LinkOption... options)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "existsexists"}, {"arrows": "to", "from": "public static boolean isReadable(Path path)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static boolean isWritable(Path path)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static boolean isExecutable(Path path)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkExec(String)"}, {"arrows": "to", "from": "public static boolean isExecutable(Path path)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "exec"}, {"arrows": "to", "from": "public static Path walkFileTree(Path start, Set\u003cFileVisitOption\u003e options, int maxDepth, FileVisitor\u003c? super Path\u003e visitor) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.FileVisitor"}, {"arrows": "to", "from": "public static Path walkFileTree(Path start, Set\u003cFileVisitOption\u003e options, int maxDepth, FileVisitor\u003c? super Path\u003e visitor) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static Path walkFileTree(Path start, Set\u003cFileVisitOption\u003e options, int maxDepth, FileVisitor\u003c? super Path\u003e visitor) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "visitFile"}, {"arrows": "to", "from": "public static Path walkFileTree(Path start, Set\u003cFileVisitOption\u003e options, int maxDepth, FileVisitor\u003c? super Path\u003e visitor) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "TERMINATETERMINATE"}, {"arrows": "to", "from": "public static Path walkFileTree(Path start, Set\u003cFileVisitOption\u003e options, int maxDepth, FileVisitor\u003c? super Path\u003e visitor) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.attribute.BasicFileAttributes"}, {"arrows": "to", "from": "public static Path walkFileTree(Path start, Set\u003cFileVisitOption\u003e options, int maxDepth, FileVisitor\u003c? super Path\u003e visitor) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FOLLOW_LINKS"}, {"arrows": "to", "from": "public static Path walkFileTree(Path start, Set\u003cFileVisitOption\u003e options, int maxDepth, FileVisitor\u003c? super Path\u003e visitor) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MAX_VALUE"}, {"arrows": "to", "from": "public static Path walkFileTree(Path start, Set\u003cFileVisitOption\u003e options, int maxDepth, FileVisitor\u003c? super Path\u003e visitor) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.FileSystemLoopException"}, {"arrows": "to", "from": "public static Path walkFileTree(Path start, Set\u003cFileVisitOption\u003e options, int maxDepth, FileVisitor\u003c? super Path\u003e visitor) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isSameFileisSameFile"}, {"arrows": "to", "from": "java.nio.file.FileVisitor", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs) throws IOException"}, {"arrows": "to", "from": "java.nio.file.FileVisitor", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " FileVisitResult visitFile(T file, BasicFileAttributes attrs) throws IOException"}, {"arrows": "to", "from": "java.nio.file.FileVisitor", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " FileVisitResult visitFileFailed(T file, IOException exc) throws IOException"}, {"arrows": "to", "from": "java.nio.file.FileVisitor", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " FileVisitResult postVisitDirectory(T dir, IOException exc) throws IOException"}, {"arrows": "to", "from": " FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CONTINUE"}, {"arrows": "to", "from": " FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SKIP_SIBLINGS"}, {"arrows": "to", "from": " FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SKIP_SUBTREE"}, {"arrows": "to", "from": " FileVisitResult postVisitDirectory(T dir, IOException exc) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "SKIP_SIBLINGS"}, {"arrows": "to", "from": " FileVisitResult postVisitDirectory(T dir, IOException exc) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "visitFile"}, {"arrows": "to", "from": "public static Path walkFileTree(Path start, FileVisitor\u003c? super Path\u003e visitor) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static BufferedReader newBufferedReader(Path path, Charset cs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static BufferedReader newBufferedReader(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Charsetcharset"}, {"arrows": "to", "from": "public static BufferedReader newBufferedReader(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static BufferedReader newBufferedReader(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UTF_8"}, {"arrows": "to", "from": "public static BufferedWriter newBufferedWriter(Path path, Charset cs, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isRegularFile"}, {"arrows": "to", "from": "public static BufferedWriter newBufferedWriter(Path path, Charset cs, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "WRITE"}, {"arrows": "to", "from": "public static BufferedWriter newBufferedWriter(Path path, Charset cs, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CREATE"}, {"arrows": "to", "from": "public static BufferedWriter newBufferedWriter(Path path, Charset cs, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "TRUNCATE_EXISTING"}, {"arrows": "to", "from": "public static BufferedWriter newBufferedWriter(Path path, Charset cs, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static BufferedWriter newBufferedWriter(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.charset.Charset"}, {"arrows": "to", "from": "public static BufferedWriter newBufferedWriter(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UTF_8"}, {"arrows": "to", "from": "public static BufferedWriter newBufferedWriter(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static long copy(InputStream in, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "REPLACE_EXISTINGREPLACE_EXISTING"}, {"arrows": "to", "from": "public static long copy(InputStream in, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkDelete(String)"}, {"arrows": "to", "from": "public static long copy(InputStream in, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static long copy(Path source, OutputStream out) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "flush"}, {"arrows": "to", "from": "public static long copy(Path source, OutputStream out) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static long copy(Path source, OutputStream out) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.Flushable"}, {"arrows": "to", "from": "java.io.Flushable", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void flush() throws IOException"}, {"arrows": "to", "from": "public static byte[] readAllBytes(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static List\u003cString\u003e readAllLines(Path path, Charset cs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static List\u003cString\u003e readAllLines(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.charset.Charset"}, {"arrows": "to", "from": "public static List\u003cString\u003e readAllLines(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static List\u003cString\u003e readAllLines(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UTF_8"}, {"arrows": "to", "from": "public static Path write(Path path, byte[] bytes, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isRegularFile"}, {"arrows": "to", "from": "public static Path write(Path path, byte[] bytes, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "WRITE"}, {"arrows": "to", "from": "public static Path write(Path path, byte[] bytes, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CREATE"}, {"arrows": "to", "from": "public static Path write(Path path, byte[] bytes, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "TRUNCATE_EXISTING"}, {"arrows": "to", "from": "public static Path write(Path path, byte[] bytes, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static Path write(Path path, Iterable\u003c? extends CharSequence\u003e lines, Charset cs, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isRegularFile"}, {"arrows": "to", "from": "public static Path write(Path path, Iterable\u003c? extends CharSequence\u003e lines, Charset cs, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "WRITE"}, {"arrows": "to", "from": "public static Path write(Path path, Iterable\u003c? extends CharSequence\u003e lines, Charset cs, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CREATE"}, {"arrows": "to", "from": "public static Path write(Path path, Iterable\u003c? extends CharSequence\u003e lines, Charset cs, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "TRUNCATE_EXISTING"}, {"arrows": "to", "from": "public static Path write(Path path, Iterable\u003c? extends CharSequence\u003e lines, Charset cs, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static Path write(Path path, Iterable\u003c? extends CharSequence\u003e lines, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.charset.Charset"}, {"arrows": "to", "from": "public static Path write(Path path, Iterable\u003c? extends CharSequence\u003e lines, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UTF_8"}, {"arrows": "to", "from": "public static Path write(Path path, Iterable\u003c? extends CharSequence\u003e lines, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e list(Path dir) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.UncheckedIOException"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e list(Path dir) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.DirectoryStream"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e list(Path dir) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e list(Path dir) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Path"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e list(Path dir) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e list(Path dir) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.IOException"}, {"arrows": "to", "from": "java.io.UncheckedIOException", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public IOException getCause()"}, {"arrows": "to", "from": "java.io.UncheckedIOException", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e walk(Path start, int maxDepth, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.IllegalStateException"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e walk(Path start, int maxDepth, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e walk(Path start, int maxDepth, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.IOException"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e walk(Path start, int maxDepth, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.attribute.BasicFileAttributes"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e walk(Path start, int maxDepth, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.UncheckedIOException"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e walk(Path start, int maxDepth, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FOLLOW_LINKS"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e walk(Path start, int maxDepth, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.DirectoryStream"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e walk(Path start, int maxDepth, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e walk(Path start, int maxDepth, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Path"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e walk(Path start, int maxDepth, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MAX_VALUE"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e walk(Path start, int maxDepth, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.FileSystemLoopException"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e walk(Path start, int maxDepth, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isSameFileisSameFile"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e walk(Path start, int maxDepth, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.InputStream"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e walk(Path start, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.DirectoryStream"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e walk(Path start, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e walk(Path start, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.IllegalStateException"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e walk(Path start, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Path"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e walk(Path start, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e walk(Path start, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.InputStream"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e find(Path start, int maxDepth, BiPredicate\u003cPath, BasicFileAttributes\u003e matcher, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.IllegalStateException"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e find(Path start, int maxDepth, BiPredicate\u003cPath, BasicFileAttributes\u003e matcher, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e find(Path start, int maxDepth, BiPredicate\u003cPath, BasicFileAttributes\u003e matcher, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "walk"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e find(Path start, int maxDepth, BiPredicate\u003cPath, BasicFileAttributes\u003e matcher, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.IOException"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e find(Path start, int maxDepth, BiPredicate\u003cPath, BasicFileAttributes\u003e matcher, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.attribute.BasicFileAttributes"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e find(Path start, int maxDepth, BiPredicate\u003cPath, BasicFileAttributes\u003e matcher, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.UncheckedIOException"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e find(Path start, int maxDepth, BiPredicate\u003cPath, BasicFileAttributes\u003e matcher, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.function.BiPredicate"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e find(Path start, int maxDepth, BiPredicate\u003cPath, BasicFileAttributes\u003e matcher, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.DirectoryStream"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e find(Path start, int maxDepth, BiPredicate\u003cPath, BasicFileAttributes\u003e matcher, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e find(Path start, int maxDepth, BiPredicate\u003cPath, BasicFileAttributes\u003e matcher, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Path"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e find(Path start, int maxDepth, BiPredicate\u003cPath, BasicFileAttributes\u003e matcher, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "filter"}, {"arrows": "to", "from": "public static Stream\u003cPath\u003e find(Path start, int maxDepth, BiPredicate\u003cPath, BasicFileAttributes\u003e matcher, FileVisitOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.InputStream"}, {"arrows": "to", "from": "java.util.function.BiPredicate", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean test(T t, U u)"}, {"arrows": "to", "from": "java.util.function.BiPredicate", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " BiPredicate\u003cT, U\u003e and(BiPredicate\u003c? super T, ? super U\u003e other)"}, {"arrows": "to", "from": "java.util.function.BiPredicate", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " BiPredicate\u003cT, U\u003e negate()"}, {"arrows": "to", "from": "java.util.function.BiPredicate", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " BiPredicate\u003cT, U\u003e or(BiPredicate\u003c? super T, ? super U\u003e other)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Stream\u003cR\u003e map(Function\u003c? super T, ? extends R\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " IntStream mapToInt(ToIntFunction\u003c? super T\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " LongStream mapToLong(ToLongFunction\u003c? super T\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " DoubleStream mapToDouble(ToDoubleFunction\u003c? super T\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Stream\u003cR\u003e flatMap(Function\u003c? super T, ? extends Stream\u003c? extends R\u003e\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " IntStream flatMapToInt(Function\u003c? super T, ? extends IntStream\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " LongStream flatMapToLong(Function\u003c? super T, ? extends LongStream\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " DoubleStream flatMapToDouble(Function\u003c? super T, ? extends DoubleStream\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Stream\u003cR\u003e mapMulti(BiConsumer\u003c? super T, ? super Consumer\u003cR\u003e\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " IntStream mapMultiToInt(BiConsumer\u003c? super T, ? super IntConsumer\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " LongStream mapMultiToLong(BiConsumer\u003c? super T, ? super LongConsumer\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " DoubleStream mapMultiToDouble(BiConsumer\u003c? super T, ? super DoubleConsumer\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Stream\u003cT\u003e distinct()"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Stream\u003cT\u003e sorted()"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Stream\u003cT\u003e sorted(Comparator\u003c? super T\u003e comparator)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Stream\u003cT\u003e peek(Consumer\u003c? super T\u003e action)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Stream\u003cT\u003e limit(long maxSize)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Stream\u003cT\u003e skip(long n)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Stream\u003cT\u003e takeWhile(Predicate\u003c? super T\u003e predicate)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Stream\u003cT\u003e dropWhile(Predicate\u003c? super T\u003e predicate)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void forEach(Consumer\u003c? super T\u003e action)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void forEachOrdered(Consumer\u003c? super T\u003e action)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Object[] toArray()"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " A[] toArray(IntFunction\u003cA[]\u003e generator)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " T reduce(T identity, BinaryOperator\u003cT\u003e accumulator)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Optional\u003cT\u003e reduce(BinaryOperator\u003cT\u003e accumulator)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " U reduce(U identity, BiFunction\u003cU, ? super T, U\u003e accumulator, BinaryOperator\u003cU\u003e combiner)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " R collect(Supplier\u003cR\u003e supplier, BiConsumer\u003cR, ? super T\u003e accumulator, BiConsumer\u003cR, R\u003e combiner)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " R collect(Collector\u003c? super T, A, R\u003e collector)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " List\u003cT\u003e toList()"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Optional\u003cT\u003e min(Comparator\u003c? super T\u003e comparator)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Optional\u003cT\u003e max(Comparator\u003c? super T\u003e comparator)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " long count()"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean anyMatch(Predicate\u003c? super T\u003e predicate)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean allMatch(Predicate\u003c? super T\u003e predicate)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean noneMatch(Predicate\u003c? super T\u003e predicate)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Optional\u003cT\u003e findFirst()"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Optional\u003cT\u003e findAny()"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Builder\u003cT\u003e builder()"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Stream\u003cT\u003e empty()"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Stream\u003cT\u003e of(T t)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Stream\u003cT\u003e ofNullable(T t)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Stream\u003cT\u003e of(T... values)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Stream\u003cT\u003e iterate(final T seed, final UnaryOperator\u003cT\u003e f)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Stream\u003cT\u003e iterate(T seed, Predicate\u003c? super T\u003e hasNext, UnaryOperator\u003cT\u003e next)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Stream\u003cT\u003e generate(Supplier\u003c? extends T\u003e s)"}, {"arrows": "to", "from": "java.util.stream.Stream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Stream\u003cT\u003e concat(Stream\u003c? extends T\u003e a, Stream\u003c? extends T\u003e b)"}, {"arrows": "to", "from": " Stream\u003cR\u003e flatMap(Function\u003c? super T, ? extends Stream\u003c? extends R\u003e\u003e mapper)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close()"}, {"arrows": "to", "from": " IntStream flatMapToInt(Function\u003c? super T, ? extends IntStream\u003e mapper)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close()"}, {"arrows": "to", "from": " LongStream flatMapToLong(Function\u003c? super T, ? extends LongStream\u003e mapper)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close()"}, {"arrows": "to", "from": " DoubleStream flatMapToDouble(Function\u003c? super T, ? extends DoubleStream\u003e mapper)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close()"}, {"arrows": "to", "from": " Stream\u003cR\u003e mapMulti(BiConsumer\u003c? super T, ? super Consumer\u003cR\u003e\u003e mapper)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "flatMap"}, {"arrows": "to", "from": " IntStream mapMultiToInt(BiConsumer\u003c? super T, ? super IntConsumer\u003e mapper)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "flatMapToInt"}, {"arrows": "to", "from": " LongStream mapMultiToLong(BiConsumer\u003c? super T, ? super LongConsumer\u003e mapper)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "flatMapToLong"}, {"arrows": "to", "from": " DoubleStream mapMultiToDouble(BiConsumer\u003c? super T, ? super DoubleConsumer\u003e mapper)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "flatMapToDouble"}, {"arrows": "to", "from": " Stream\u003cT\u003e distinct()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(Object)"}, {"arrows": "to", "from": " Stream\u003cT\u003e distinct()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "generate(Supplier)"}, {"arrows": "to", "from": " Stream\u003cT\u003e distinct()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unordered()"}, {"arrows": "to", "from": " Stream\u003cT\u003e distinct()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sequential()"}, {"arrows": "to", "from": " Stream\u003cT\u003e peek(Consumer\u003c? super T\u003e action)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "count"}, {"arrows": "to", "from": " Stream\u003cT\u003e limit(long maxSize)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "generate(Supplier)"}, {"arrows": "to", "from": " Stream\u003cT\u003e limit(long maxSize)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unordered()"}, {"arrows": "to", "from": " Stream\u003cT\u003e limit(long maxSize)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sequential()"}, {"arrows": "to", "from": " Stream\u003cT\u003e skip(long n)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "generate(Supplier)"}, {"arrows": "to", "from": " Stream\u003cT\u003e skip(long n)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unordered()"}, {"arrows": "to", "from": " Stream\u003cT\u003e skip(long n)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sequential()"}, {"arrows": "to", "from": " Stream\u003cT\u003e takeWhile(Predicate\u003c? super T\u003e predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "spliterator()"}, {"arrows": "to", "from": " Stream\u003cT\u003e takeWhile(Predicate\u003c? super T\u003e predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isParallel()"}, {"arrows": "to", "from": " Stream\u003cT\u003e takeWhile(Predicate\u003c? super T\u003e predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "generate(Supplier)"}, {"arrows": "to", "from": " Stream\u003cT\u003e takeWhile(Predicate\u003c? super T\u003e predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unordered()"}, {"arrows": "to", "from": " Stream\u003cT\u003e takeWhile(Predicate\u003c? super T\u003e predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sequential()"}, {"arrows": "to", "from": " Stream\u003cT\u003e dropWhile(Predicate\u003c? super T\u003e predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "spliterator()"}, {"arrows": "to", "from": " Stream\u003cT\u003e dropWhile(Predicate\u003c? super T\u003e predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isParallel()"}, {"arrows": "to", "from": " Stream\u003cT\u003e dropWhile(Predicate\u003c? super T\u003e predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "generate(Supplier)"}, {"arrows": "to", "from": " Stream\u003cT\u003e dropWhile(Predicate\u003c? super T\u003e predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unordered()"}, {"arrows": "to", "from": " Stream\u003cT\u003e dropWhile(Predicate\u003c? super T\u003e predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sequential()"}, {"arrows": "to", "from": " Optional\u003cT\u003e reduce(BinaryOperator\u003cT\u003e accumulator)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Optional"}, {"arrows": "to", "from": " R collect(Supplier\u003cR\u003e supplier, BiConsumer\u003cR, ? super T\u003e accumulator, BiConsumer\u003cR, R\u003e combiner)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "reduce(Object"}, {"arrows": "to", "from": " R collect(Collector\u003c? super T, A, R\u003e collector)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNORDERED"}, {"arrows": "to", "from": " R collect(Collector\u003c? super T, A, R\u003e collector)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CONCURRENT"}, {"arrows": "to", "from": " R collect(Collector\u003c? super T, A, R\u003e collector)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.stream.Collector"}, {"arrows": "to", "from": " R collect(Collector\u003c? super T, A, R\u003e collector)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "collect(Supplier"}, {"arrows": "to", "from": "java.util.stream.Collector", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Supplier\u003cA\u003e supplier()"}, {"arrows": "to", "from": "java.util.stream.Collector", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " BiConsumer\u003cA, T\u003e accumulator()"}, {"arrows": "to", "from": "java.util.stream.Collector", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " BinaryOperator\u003cA\u003e combiner()"}, {"arrows": "to", "from": "java.util.stream.Collector", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Function\u003cA, R\u003e finisher()"}, {"arrows": "to", "from": "java.util.stream.Collector", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Set\u003cCharacteristics\u003e characteristics()"}, {"arrows": "to", "from": "java.util.stream.Collector", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, R, R\u003e of(Supplier\u003cR\u003e supplier, BiConsumer\u003cR, T\u003e accumulator, BinaryOperator\u003cR\u003e combiner, Characteristics... characteristics)"}, {"arrows": "to", "from": "java.util.stream.Collector", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, A, R\u003e of(Supplier\u003cA\u003e supplier, BiConsumer\u003cA, T\u003e accumulator, BinaryOperator\u003cA\u003e combiner, Function\u003cA, R\u003e finisher, Characteristics... characteristics)"}, {"arrows": "to", "from": " List\u003cT\u003e toList()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toCollection(Supplier)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static IllegalStateException duplicateKeyException(Object k, Object u, Object v)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static BinaryOperator\u003cM\u003e uniqKeysMapMerger()"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static BiConsumer\u003cMap\u003cK, V\u003e, T\u003e uniqKeysMapAccumulator(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends V\u003e valueMapper)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, C\u003e toCollection(Supplier\u003cC\u003e collectionFactory)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, List\u003cT\u003e\u003e toList()"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, List\u003cT\u003e\u003e toUnmodifiableList()"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, Set\u003cT\u003e\u003e toSet()"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, Set\u003cT\u003e\u003e toUnmodifiableSet()"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cCharSequence, ?, String\u003e joining()"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cCharSequence, ?, String\u003e joining(CharSequence delimiter)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cCharSequence, ?, String\u003e joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static BinaryOperator\u003cM\u003e mapMerger(BinaryOperator\u003cV\u003e mergeFunction)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, R\u003e mapping(Function\u003c? super T, ? extends U\u003e mapper, Collector\u003c? super U, A, R\u003e downstream)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, R\u003e flatMapping(Function\u003c? super T, ? extends Stream\u003c? extends U\u003e\u003e mapper, Collector\u003c? super U, A, R\u003e downstream)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, R\u003e filtering(Predicate\u003c? super T\u003e predicate, Collector\u003c? super T, A, R\u003e downstream)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, A, RR\u003e collectingAndThen(Collector\u003cT, A, R\u003e downstream, Function\u003cR, RR\u003e finisher)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, Long\u003e counting()"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, Optional\u003cT\u003e\u003e minBy(Comparator\u003c? super T\u003e comparator)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, Optional\u003cT\u003e\u003e maxBy(Comparator\u003c? super T\u003e comparator)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, Integer\u003e summingInt(ToIntFunction\u003c? super T\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, Long\u003e summingLong(ToLongFunction\u003c? super T\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, Double\u003e summingDouble(ToDoubleFunction\u003c? super T\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static double[] sumWithCompensation(double[] intermediateSum, double value)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static double computeFinalSum(double[] summands)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, Double\u003e averagingInt(ToIntFunction\u003c? super T\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, Double\u003e averagingLong(ToLongFunction\u003c? super T\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, Double\u003e averagingDouble(ToDoubleFunction\u003c? super T\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, T\u003e reducing(T identity, BinaryOperator\u003cT\u003e op)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, Optional\u003cT\u003e\u003e reducing(BinaryOperator\u003cT\u003e op)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, U\u003e reducing(U identity, Function\u003c? super T, ? extends U\u003e mapper, BinaryOperator\u003cU\u003e op)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, Map\u003cK, List\u003cT\u003e\u003e\u003e groupingBy(Function\u003c? super T, ? extends K\u003e classifier)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, Map\u003cK, D\u003e\u003e groupingBy(Function\u003c? super T, ? extends K\u003e classifier, Collector\u003c? super T, A, D\u003e downstream)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, M\u003e groupingBy(Function\u003c? super T, ? extends K\u003e classifier, Supplier\u003cM\u003e mapFactory, Collector\u003c? super T, A, D\u003e downstream)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, ConcurrentMap\u003cK, List\u003cT\u003e\u003e\u003e groupingByConcurrent(Function\u003c? super T, ? extends K\u003e classifier)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, ConcurrentMap\u003cK, D\u003e\u003e groupingByConcurrent(Function\u003c? super T, ? extends K\u003e classifier, Collector\u003c? super T, A, D\u003e downstream)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, M\u003e groupingByConcurrent(Function\u003c? super T, ? extends K\u003e classifier, Supplier\u003cM\u003e mapFactory, Collector\u003c? super T, A, D\u003e downstream)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, Map\u003cBoolean, List\u003cT\u003e\u003e\u003e partitioningBy(Predicate\u003c? super T\u003e predicate)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, Map\u003cBoolean, D\u003e\u003e partitioningBy(Predicate\u003c? super T\u003e predicate, Collector\u003c? super T, A, D\u003e downstream)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, Map\u003cK, U\u003e\u003e toMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, Map\u003cK, U\u003e\u003e toUnmodifiableMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, Map\u003cK, U\u003e\u003e toMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, Map\u003cK, U\u003e\u003e toUnmodifiableMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, M\u003e toMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction, Supplier\u003cM\u003e mapFactory)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, ConcurrentMap\u003cK, U\u003e\u003e toConcurrentMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, ConcurrentMap\u003cK, U\u003e\u003e toConcurrentMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, M\u003e toConcurrentMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction, Supplier\u003cM\u003e mapFactory)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, IntSummaryStatistics\u003e summarizingInt(ToIntFunction\u003c? super T\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, LongSummaryStatistics\u003e summarizingLong(ToLongFunction\u003c? super T\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, DoubleSummaryStatistics\u003e summarizingDouble(ToDoubleFunction\u003c? super T\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.Collectors", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Collector\u003cT, ?, R\u003e teeing(Collector\u003c? super T, ?, R1\u003e downstream1, Collector\u003c? super T, ?, R2\u003e downstream2, BiFunction\u003c? super R1, ? super R2, R\u003e merger)"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, List\u003cT\u003e\u003e toList()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toCollection(Supplier)"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, Set\u003cT\u003e\u003e toSet()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toCollection(Supplier)"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, Set\u003cT\u003e\u003e toSet()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNORDERED"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, Set\u003cT\u003e\u003e toUnmodifiableSet()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNORDERED"}, {"arrows": "to", "from": "private static BinaryOperator\u003cM\u003e mapMerger(BinaryOperator\u003cV\u003e mergeFunction)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "merge(Object"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, R\u003e flatMapping(Function\u003c? super T, ? extends Stream\u003c? extends U\u003e\u003e mapper, Collector\u003c? super U, A, R\u003e downstream)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.stream.Stream"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, R\u003e flatMapping(Function\u003c? super T, ? extends Stream\u003c? extends U\u003e\u003e mapper, Collector\u003c? super U, A, R\u003e downstream)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close()"}, {"arrows": "to", "from": "public static Collector\u003cT, A, RR\u003e collectingAndThen(Collector\u003cT, A, R\u003e downstream, Function\u003cR, RR\u003e finisher)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toList()"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, T\u003e reducing(T identity, BinaryOperator\u003cT\u003e op)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "reduce(Object"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, Optional\u003cT\u003e\u003e reducing(BinaryOperator\u003cT\u003e op)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.stream.Stream"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, U\u003e reducing(U identity, Function\u003c? super T, ? extends U\u003e mapper, BinaryOperator\u003cU\u003e op)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "reduce(Object"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, U\u003e reducing(U identity, Function\u003c? super T, ? extends U\u003e mapper, BinaryOperator\u003cU\u003e op)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "reducing(Object"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, U\u003e reducing(U identity, Function\u003c? super T, ? extends U\u003e mapper, BinaryOperator\u003cU\u003e op)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.stream.Stream"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, Map\u003cK, List\u003cT\u003e\u003e\u003e groupingBy(Function\u003c? super T, ? extends K\u003e classifier)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "groupingByConcurrent(Function)"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, Map\u003cK, D\u003e\u003e groupingBy(Function\u003c? super T, ? extends K\u003e classifier, Collector\u003c? super T, A, D\u003e downstream)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "groupingByConcurrent(Function"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, M\u003e groupingBy(Function\u003c? super T, ? extends K\u003e classifier, Supplier\u003cM\u003e mapFactory, Collector\u003c? super T, A, D\u003e downstream)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "groupingByConcurrent(Function"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, ConcurrentMap\u003cK, List\u003cT\u003e\u003e\u003e groupingByConcurrent(Function\u003c? super T, ? extends K\u003e classifier)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNORDERED"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, ConcurrentMap\u003cK, List\u003cT\u003e\u003e\u003e groupingByConcurrent(Function\u003c? super T, ? extends K\u003e classifier)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CONCURRENT"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, ConcurrentMap\u003cK, D\u003e\u003e groupingByConcurrent(Function\u003c? super T, ? extends K\u003e classifier, Collector\u003c? super T, A, D\u003e downstream)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNORDERED"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, ConcurrentMap\u003cK, D\u003e\u003e groupingByConcurrent(Function\u003c? super T, ? extends K\u003e classifier, Collector\u003c? super T, A, D\u003e downstream)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CONCURRENT"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, M\u003e groupingByConcurrent(Function\u003c? super T, ? extends K\u003e classifier, Supplier\u003cM\u003e mapFactory, Collector\u003c? super T, A, D\u003e downstream)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNORDERED"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, M\u003e groupingByConcurrent(Function\u003c? super T, ? extends K\u003e classifier, Supplier\u003cM\u003e mapFactory, Collector\u003c? super T, A, D\u003e downstream)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CONCURRENT"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, Map\u003cK, U\u003e\u003e toMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toMap(Function"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, Map\u003cK, U\u003e\u003e toMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(Object)"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, Map\u003cK, U\u003e\u003e toMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "identity()"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, Map\u003cK, U\u003e\u003e toMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toConcurrentMap(Function"}, {"arrows": "to", "from": "java.util.function.Function", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " R apply(T t)"}, {"arrows": "to", "from": "java.util.function.Function", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Function\u003cV, R\u003e compose(Function\u003c? super V, ? extends T\u003e before)"}, {"arrows": "to", "from": "java.util.function.Function", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Function\u003cT, V\u003e andThen(Function\u003c? super R, ? extends V\u003e after)"}, {"arrows": "to", "from": "java.util.function.Function", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static Function\u003cT, T\u003e identity()"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, Map\u003cK, U\u003e\u003e toUnmodifiableMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(Object)"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, Map\u003cK, U\u003e\u003e toUnmodifiableMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toUnmodifiableMap(Function"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, Map\u003cK, U\u003e\u003e toMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(Object)"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, Map\u003cK, U\u003e\u003e toMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "merge(Object"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, Map\u003cK, U\u003e\u003e toMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toConcurrentMap(Function"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, Map\u003cK, U\u003e\u003e toUnmodifiableMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(Object)"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, Map\u003cK, U\u003e\u003e toUnmodifiableMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "merge(Object"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, M\u003e toMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction, Supplier\u003cM\u003e mapFactory)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(Object)"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, M\u003e toMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction, Supplier\u003cM\u003e mapFactory)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "merge(Object"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, M\u003e toMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction, Supplier\u003cM\u003e mapFactory)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toConcurrentMap(Function"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, ConcurrentMap\u003cK, U\u003e\u003e toConcurrentMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(Object)"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, ConcurrentMap\u003cK, U\u003e\u003e toConcurrentMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNORDERED"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, ConcurrentMap\u003cK, U\u003e\u003e toConcurrentMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CONCURRENT"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, ConcurrentMap\u003cK, U\u003e\u003e toConcurrentMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "identity()"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, ConcurrentMap\u003cK, U\u003e\u003e toConcurrentMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toConcurrentMap(Function"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, ConcurrentMap\u003cK, U\u003e\u003e toConcurrentMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(Object)"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, ConcurrentMap\u003cK, U\u003e\u003e toConcurrentMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNORDERED"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, ConcurrentMap\u003cK, U\u003e\u003e toConcurrentMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CONCURRENT"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, ConcurrentMap\u003cK, U\u003e\u003e toConcurrentMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "merge(Object"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, M\u003e toConcurrentMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction, Supplier\u003cM\u003e mapFactory)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(Object)"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, M\u003e toConcurrentMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction, Supplier\u003cM\u003e mapFactory)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNORDERED"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, M\u003e toConcurrentMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction, Supplier\u003cM\u003e mapFactory)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CONCURRENT"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, M\u003e toConcurrentMap(Function\u003c? super T, ? extends K\u003e keyMapper, Function\u003c? super T, ? extends U\u003e valueMapper, BinaryOperator\u003cU\u003e mergeFunction, Supplier\u003cM\u003e mapFactory)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "merge(Object"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, R\u003e teeing(Collector\u003c? super T, ?, R1\u003e downstream1, Collector\u003c? super T, ?, R2\u003e downstream2, BiFunction\u003c? super R1, ? super R2, R\u003e merger)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UNORDERED"}, {"arrows": "to", "from": "public static Collector\u003cT, ?, R\u003e teeing(Collector\u003c? super T, ?, R1\u003e downstream1, Collector\u003c? super T, ?, R2\u003e downstream2, BiFunction\u003c? super R1, ? super R2, R\u003e merger)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CONCURRENT"}, {"arrows": "to", "from": " Optional\u003cT\u003e findFirst()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Optional"}, {"arrows": "to", "from": " Optional\u003cT\u003e findAny()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Optional"}, {"arrows": "to", "from": " Optional\u003cT\u003e findAny()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "findFirst()"}, {"arrows": "to", "from": "public static Stream\u003cString\u003e lines(Path path, Charset cs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.UncheckedIOException"}, {"arrows": "to", "from": "public static Stream\u003cString\u003e lines(Path path, Charset cs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "readAllLines(Path"}, {"arrows": "to", "from": "public static Stream\u003cString\u003e lines(Path path, Charset cs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close"}, {"arrows": "to", "from": "public static Stream\u003cString\u003e lines(Path path, Charset cs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.stream.Stream"}, {"arrows": "to", "from": "public static Stream\u003cString\u003e lines(Path path, Charset cs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static Stream\u003cString\u003e lines(Path path, Charset cs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.BufferedReader"}, {"arrows": "to", "from": "java.io.BufferedReader", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void ensureOpen() throws IOException"}, {"arrows": "to", "from": "java.io.BufferedReader", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void fill() throws IOException"}, {"arrows": "to", "from": "java.io.BufferedReader", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int read() throws IOException"}, {"arrows": "to", "from": "java.io.BufferedReader", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private int read1(char[] cbuf, int off, int len) throws IOException"}, {"arrows": "to", "from": "java.io.BufferedReader", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int read(char[] cbuf, int off, int len) throws IOException"}, {"arrows": "to", "from": "java.io.BufferedReader", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " String readLine(boolean ignoreLF) throws IOException"}, {"arrows": "to", "from": "java.io.BufferedReader", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String readLine() throws IOException"}, {"arrows": "to", "from": "java.io.BufferedReader", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long skip(long n) throws IOException"}, {"arrows": "to", "from": "java.io.BufferedReader", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean ready() throws IOException"}, {"arrows": "to", "from": "java.io.BufferedReader", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean markSupported()"}, {"arrows": "to", "from": "java.io.BufferedReader", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void mark(int readAheadLimit) throws IOException"}, {"arrows": "to", "from": "java.io.BufferedReader", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void reset() throws IOException"}, {"arrows": "to", "from": "java.io.BufferedReader", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Stream\u003cString\u003e lines()"}, {"arrows": "to", "from": "public int read(char[] cbuf, int off, int len) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "read(char"}, {"arrows": "to", "from": "public int read(char[] cbuf, int off, int len) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.Reader"}, {"arrows": "to", "from": "public static Stream\u003cString\u003e lines(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.charset.Charset"}, {"arrows": "to", "from": "public static Stream\u003cString\u003e lines(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public static Stream\u003cString\u003e lines(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "UTF_8"}, {"arrows": "to", "from": "public abstract WatchService newWatchService() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.WatchService"}, {"arrows": "to", "from": "public abstract FileSystem getFileSystem(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "newFileSystemnewFileSystem"}, {"arrows": "to", "from": "public abstract FileSystem getFileSystem(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "newFileSystem(URI"}, {"arrows": "to", "from": "public abstract FileSystem getFileSystem(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FileSystemNotFoundException"}, {"arrows": "to", "from": "public abstract FileSystem getFileSystem(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close"}, {"arrows": "to", "from": "public abstract FileSystem getFileSystem(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "newFileSystem(Path"}, {"arrows": "to", "from": "public abstract FileSystem getFileSystem(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefaultdefault"}, {"arrows": "to", "from": "public abstract Path getPath(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FileSystem"}, {"arrows": "to", "from": "public abstract Path getPath(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.URI"}, {"arrows": "to", "from": "public abstract Path getPath(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static URI create(String str)"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public URI parseServerAuthority() throws URISyntaxException"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public URI normalize()"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public URI resolve(URI uri)"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public URI resolve(String str)"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public URI relativize(URI uri)"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public URL toURL() throws MalformedURLException"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getScheme()"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isAbsolute()"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isOpaque()"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getRawSchemeSpecificPart()"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getSchemeSpecificPart()"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getRawAuthority()"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getAuthority()"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getRawUserInfo()"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getUserInfo()"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getHost()"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getPort()"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getRawPath()"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getPath()"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getRawQuery()"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getQuery()"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getRawFragment()"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getFragment()"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean equals(Object ob)"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int hashCode()"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int compareTo(URI that)"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toString()"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String toASCIIString()"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void writeObject(ObjectOutputStream os) throws IOException"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void readObject(ObjectInputStream is) throws ClassNotFoundException, IOException"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static int toLower(char c)"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static int toUpper(char c)"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static boolean equalIgnoringCase(String s, String t)"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static int hashIgnoringCase(int hash, String s)"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static int compareIgnoringCase(String s, String t)"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static String resolvePath(String base, String child, boolean absolute)"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static URI resolve(URI base, URI child)"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static void removeDots(char[] path, int[] segs, boolean removeLeading)"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static long lowMask(String chars)"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static long highMask(String chars)"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static long lowMask(char first, char last)"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static long highMask(char first, char last)"}, {"arrows": "to", "from": "java.net.URI", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static boolean match(char c, long lowMask, long highMask)"}, {"arrows": "to", "from": "public static URI create(String str)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.URISyntaxException"}, {"arrows": "to", "from": "public static URI create(String str)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "URI(String)"}, {"arrows": "to", "from": "public static URI create(String str)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "IllegalArgumentException"}, {"arrows": "to", "from": "java.net.URISyntaxException", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getInput()"}, {"arrows": "to", "from": "java.net.URISyntaxException", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getReason()"}, {"arrows": "to", "from": "java.net.URISyntaxException", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getIndex()"}, {"arrows": "to", "from": "java.net.URISyntaxException", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMessage()"}, {"arrows": "to", "from": "public URI resolve(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "normalize()"}, {"arrows": "to", "from": "public URI resolve(String str)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "resolve(java.net.URI)"}, {"arrows": "to", "from": "public URI resolve(String str)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "create(String)"}, {"arrows": "to", "from": "public String getSchemeSpecificPart()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getRawSchemeSpecificPart()"}, {"arrows": "to", "from": "public String getAuthority()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getRawAuthority()"}, {"arrows": "to", "from": "public String getUserInfo()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getRawUserInfo()"}, {"arrows": "to", "from": "public String getQuery()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getRawQuery()"}, {"arrows": "to", "from": "public String getFragment()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getRawFragment()"}, {"arrows": "to", "from": "public int compareTo(URI that)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.String"}, {"arrows": "to", "from": "public int compareTo(URI that)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compareTo(Object)"}, {"arrows": "to", "from": "java.lang.Comparable", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int compareTo(T o)"}, {"arrows": "to", "from": "public int compareTo(T o)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "signumsignum"}, {"arrows": "to", "from": "public String toASCIIString()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toString()"}, {"arrows": "to", "from": "private void writeObject(ObjectOutputStream os) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "defaultWriteObject()"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void useProtocolVersion(int version) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final void writeObject(Object obj) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void writeObjectOverride(Object obj) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeUnshared(Object obj) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void defaultWriteObject() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ObjectOutputStream.PutField putFields() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeFields() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void reset() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void annotateClass(Class\u003c?\u003e cl) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void annotateProxyClass(Class\u003c?\u003e cl) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected Object replaceObject(Object obj) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected boolean enableReplaceObject(boolean enable) throws SecurityException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void writeStreamHeader() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void writeClassDescriptor(ObjectStreamClass desc) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void write(int val) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void write(byte[] buf) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void write(byte[] buf, int off, int len) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void flush() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void drain() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void close() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeBoolean(boolean val) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeByte(int val) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeShort(int val) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeChar(int val) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeInt(int val) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeLong(long val) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeFloat(float val) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeDouble(double val) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeBytes(String str) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeChars(String str) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void writeUTF(String str) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int getProtocolVersion()"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void writeTypeString(String str) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void verifySubclass()"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static boolean auditSubclass(final Class\u003c?\u003e subcl)"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void clear()"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void writeObject0(Object obj, boolean unshared) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void writeNull() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void writeHandle(int handle) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void writeClass(Class\u003c?\u003e cl, boolean unshared) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void writeClassDesc(ObjectStreamClass desc, boolean unshared) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void writeProxyDesc(ObjectStreamClass desc, boolean unshared) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void writeNonProxyDesc(ObjectStreamClass desc, boolean unshared) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void writeString(String str, boolean unshared) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void writeArray(Object array, ObjectStreamClass desc, boolean unshared) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void writeEnum(Enum\u003c?\u003e en, ObjectStreamClass desc, boolean unshared) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void writeOrdinaryObject(Object obj, ObjectStreamClass desc, boolean unshared) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void writeExternalData(Externalizable obj) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void writeRecordData(Object obj, ObjectStreamClass desc) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void writeSerialData(Object obj, ObjectStreamClass desc) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void defaultWriteFields(Object obj, ObjectStreamClass desc) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void writeFatalException(IOException ex) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static native void floatsToBytes(float[] src, int srcpos, byte[] dst, int dstpos, int nfloats)"}, {"arrows": "to", "from": "java.io.ObjectOutputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static native void doublesToBytes(double[] src, int srcpos, byte[] dst, int dstpos, int ndoubles)"}, {"arrows": "to", "from": "private void readObject(ObjectInputStream is) throws ClassNotFoundException, IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "defaultReadObject()"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final Object readObject() throws IOException, ClassNotFoundException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected Object readObjectOverride() throws IOException, ClassNotFoundException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Object readUnshared() throws IOException, ClassNotFoundException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void defaultReadObject() throws IOException, ClassNotFoundException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public ObjectInputStream.GetField readFields() throws IOException, ClassNotFoundException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void registerValidation(ObjectInputValidation obj, int prio) throws NotActiveException, InvalidObjectException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected Class\u003c?\u003e resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected Class\u003c?\u003e resolveProxyClass(String[] interfaces) throws IOException, ClassNotFoundException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected Object resolveObject(Object obj) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected boolean enableResolveObject(boolean enable) throws SecurityException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected void readStreamHeader() throws IOException, StreamCorruptedException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "protected ObjectStreamClass readClassDescriptor() throws IOException, ClassNotFoundException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int read() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int read(byte[] buf, int off, int len) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int available() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void close() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean readBoolean() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public byte readByte() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int readUnsignedByte() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public char readChar() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public short readShort() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int readUnsignedShort() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int readInt() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public long readLong() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public float readFloat() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public double readDouble() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void readFully(byte[] buf) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void readFully(byte[] buf, int off, int len) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int skipBytes(int len) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String readUTF() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void checkArray(Class\u003c?\u003e arrayType, int arrayLength) throws InvalidClassException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void verifySubclass()"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static boolean auditSubclass(final Class\u003c?\u003e subcl)"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void clear()"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private Object readObject0(boolean unshared) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private Object checkResolve(Object obj) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " String readTypeString() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private Object readNull() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private Object readHandle(boolean unshared) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private Class\u003c?\u003e readClass(boolean unshared) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private ObjectStreamClass readClassDesc(boolean unshared) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private ObjectStreamClass readProxyDesc(boolean unshared) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private ObjectStreamClass readNonProxyDesc(boolean unshared) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private String readString(boolean unshared) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private Object readArray(boolean unshared) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private Enum\u003c?\u003e readEnum(boolean unshared) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private Object readOrdinaryObject(boolean unshared) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void readExternalData(Externalizable obj, ObjectStreamClass desc) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private Object readRecord(ObjectStreamClass desc) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void readSerialData(Object obj, ObjectStreamClass desc) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void skipCustomData() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void defaultReadFields(Object obj, ObjectStreamClass desc) throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private IOException readFatalException() throws IOException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void handleReset() throws StreamCorruptedException"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static native void bytesToFloats(byte[] src, int srcpos, float[] dst, int dstpos, int nfloats)"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static native void bytesToDoubles(byte[] src, int srcpos, double[] dst, int dstpos, int ndoubles)"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static ClassLoader latestUserDefinedLoader()"}, {"arrows": "to", "from": "java.io.ObjectInputStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private static Object cloneArray(Object array)"}, {"arrows": "to", "from": "protected Class\u003c?\u003e resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.InvalidClassException"}, {"arrows": "to", "from": "java.io.InvalidClassException", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public String getMessage()"}, {"arrows": "to", "from": "public InputStream newInputStream(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "newInputStream"}, {"arrows": "to", "from": "public InputStream newInputStream(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "newByteChannel"}, {"arrows": "to", "from": "public InputStream newInputStream(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public OutputStream newOutputStream(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "newByteChannel"}, {"arrows": "to", "from": "public OutputStream newOutputStream(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkDelete(String)"}, {"arrows": "to", "from": "public OutputStream newOutputStream(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "newOutputStream"}, {"arrows": "to", "from": "public OutputStream newOutputStream(Path path, OpenOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public FileChannel newFileChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public FileChannel newFileChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public FileChannel newFileChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "open(Path"}, {"arrows": "to", "from": "public AsynchronousFileChannel newAsynchronousFileChannel(Path path, Set\u003c? extends OpenOption\u003e options, ExecutorService executor, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public AsynchronousFileChannel newAsynchronousFileChannel(Path path, Set\u003c? extends OpenOption\u003e options, ExecutorService executor, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public AsynchronousFileChannel newAsynchronousFileChannel(Path path, Set\u003c? extends OpenOption\u003e options, ExecutorService executor, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "open(Path"}, {"arrows": "to", "from": "public abstract SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "newByteChannel(Path"}, {"arrows": "to", "from": "public abstract SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public abstract SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkDelete(String)"}, {"arrows": "to", "from": "public abstract SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public abstract SeekableByteChannel newByteChannel(Path path, Set\u003c? extends OpenOption\u003e options, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "CREATE_NEW"}, {"arrows": "to", "from": "public abstract DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, DirectoryStream.Filter\u003c? super Path\u003e filter) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public abstract DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, DirectoryStream.Filter\u003c? super Path\u003e filter) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "newDirectoryStream(java.nio.file.Path"}, {"arrows": "to", "from": "public abstract void createDirectory(Path dir, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createDirectory"}, {"arrows": "to", "from": "public abstract void createDirectory(Path dir, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public void createSymbolicLink(Path link, Path target, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createSymbolicLink"}, {"arrows": "to", "from": "public void createSymbolicLink(Path link, Path target, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "LinkPermission"}, {"arrows": "to", "from": "public void createSymbolicLink(Path link, Path target, FileAttribute\u003c?\u003e... attrs) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public void createLink(Path link, Path existing) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "LinkPermission"}, {"arrows": "to", "from": "public void createLink(Path link, Path existing) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createLink"}, {"arrows": "to", "from": "public void createLink(Path link, Path existing) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public abstract void delete(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkDelete(String)"}, {"arrows": "to", "from": "public abstract void delete(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "delete"}, {"arrows": "to", "from": "public boolean deleteIfExists(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "deleteIfExists"}, {"arrows": "to", "from": "public boolean deleteIfExists(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkDelete(String)"}, {"arrows": "to", "from": "public boolean deleteIfExists(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "delete"}, {"arrows": "to", "from": "public Path readSymbolicLink(Path link) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "readSymbolicLink"}, {"arrows": "to", "from": "public abstract void copy(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "LinkPermission"}, {"arrows": "to", "from": "public abstract void copy(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "copy(Path"}, {"arrows": "to", "from": "public abstract void copy(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public abstract void copy(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public abstract void move(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "move"}, {"arrows": "to", "from": "public abstract void move(Path source, Path target, CopyOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public abstract boolean isSameFile(Path path, Path path2) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public abstract boolean isSameFile(Path path, Path path2) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isSameFile"}, {"arrows": "to", "from": "public abstract boolean isHidden(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isHidden"}, {"arrows": "to", "from": "public abstract boolean isHidden(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public abstract FileStore getFileStore(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FileStore"}, {"arrows": "to", "from": "public abstract FileStore getFileStore(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public abstract FileStore getFileStore(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "RuntimePermission"}, {"arrows": "to", "from": "public abstract FileStore getFileStore(Path path) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getFileStore"}, {"arrows": "to", "from": "public abstract void checkAccess(Path path, AccessMode... modes) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isReadable"}, {"arrows": "to", "from": "public abstract void checkAccess(Path path, AccessMode... modes) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkExec(String)"}, {"arrows": "to", "from": "public abstract void checkAccess(Path path, AccessMode... modes) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "WRITE"}, {"arrows": "to", "from": "public abstract void checkAccess(Path path, AccessMode... modes) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isWritable"}, {"arrows": "to", "from": "public abstract void checkAccess(Path path, AccessMode... modes) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public abstract void checkAccess(Path path, AccessMode... modes) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isExecutableisExecutable"}, {"arrows": "to", "from": "public abstract void checkAccess(Path path, AccessMode... modes) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "exec"}, {"arrows": "to", "from": "public abstract void checkAccess(Path path, AccessMode... modes) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "READ"}, {"arrows": "to", "from": "public abstract void checkAccess(Path path, AccessMode... modes) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public abstract void checkAccess(Path path, AccessMode... modes) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "EXECUTE"}, {"arrows": "to", "from": "public abstract V getFileAttributeView(Path path, Class\u003cV\u003e type, LinkOption... options)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getFileAttributeView"}, {"arrows": "to", "from": "public abstract A readAttributes(Path path, Class\u003cA\u003e type, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "readAttributes(Path"}, {"arrows": "to", "from": "public abstract A readAttributes(Path path, Class\u003cA\u003e type, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public abstract Map\u003cString, Object\u003e readAttributes(Path path, String attributes, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "readAttributes(Path"}, {"arrows": "to", "from": "public abstract Map\u003cString, Object\u003e readAttributes(Path path, String attributes, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public abstract void setAttribute(Path path, String attribute, Object value, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkWrite(String)"}, {"arrows": "to", "from": "public abstract void setAttribute(Path path, String attribute, Object value, LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "setAttribute"}, {"arrows": "to", "from": "public static FileSystem getFileSystem(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.spi.FileSystemProvider"}, {"arrows": "to", "from": "public static FileSystem getFileSystem(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.URI"}, {"arrows": "to", "from": "public static FileSystem getFileSystem(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.FileSystemNotFoundException"}, {"arrows": "to", "from": "public static FileSystem getFileSystem(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "newFileSystem"}, {"arrows": "to", "from": "public static FileSystem getFileSystem(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefaultdefault"}, {"arrows": "to", "from": "public static FileSystem getFileSystem(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.FileSystem"}, {"arrows": "to", "from": "public static FileSystem newFileSystem(URI uri, Map\u003cString, ?\u003e env) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "newFileSystem(URI"}, {"arrows": "to", "from": "public static FileSystem newFileSystem(URI uri, Map\u003cString, ?\u003e env) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.spi.FileSystemProvider"}, {"arrows": "to", "from": "public static FileSystem newFileSystem(URI uri, Map\u003cString, ?\u003e env) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.URI"}, {"arrows": "to", "from": "public static FileSystem newFileSystem(URI uri, Map\u003cString, ?\u003e env) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close"}, {"arrows": "to", "from": "public static FileSystem newFileSystem(URI uri, Map\u003cString, ?\u003e env, ClassLoader loader) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "newFileSystem(URI"}, {"arrows": "to", "from": "public static FileSystem newFileSystem(URI uri, Map\u003cString, ?\u003e env, ClassLoader loader) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.FileSystems"}, {"arrows": "to", "from": "public static FileSystem newFileSystem(URI uri, Map\u003cString, ?\u003e env, ClassLoader loader) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.URI"}, {"arrows": "to", "from": "public static FileSystem newFileSystem(Path path, ClassLoader loader) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "newFileSystem(Path"}, {"arrows": "to", "from": "public static FileSystem newFileSystem(Path path, ClassLoader loader) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.spi.FileSystemProvider"}, {"arrows": "to", "from": "public static Path of(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault"}, {"arrows": "to", "from": "public static Path of(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.spi.FileSystemProvider"}, {"arrows": "to", "from": "public static Path of(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.URI"}, {"arrows": "to", "from": "public static Path of(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toAbsolutePath()"}, {"arrows": "to", "from": "public static Path of(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toUri()"}, {"arrows": "to", "from": "public static Path of(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.File"}, {"arrows": "to", "from": " Path getParent()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "normalize"}, {"arrows": "to", "from": " Path getName(int index)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getNameCount"}, {"arrows": "to", "from": " Path subpath(int beginIndex, int endIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getNameCountcount"}, {"arrows": "to", "from": " boolean startsWith(String other)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "startsWith(Path)"}, {"arrows": "to", "from": " boolean endsWith(String other)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "endsWith(Path)"}, {"arrows": "to", "from": " Path resolve(Path other)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "endsWith"}, {"arrows": "to", "from": " Path resolve(Path other)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getRoot"}, {"arrows": "to", "from": " Path resolve(Path other)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isAbsolute()"}, {"arrows": "to", "from": " Path resolve(String other)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "resolve(Path)"}, {"arrows": "to", "from": " Path resolveSibling(Path other)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getParent"}, {"arrows": "to", "from": " Path resolveSibling(Path other)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isAbsolute()"}, {"arrows": "to", "from": " Path resolveSibling(String other)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getParent"}, {"arrows": "to", "from": " Path resolveSibling(String other)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "resolveSibling(Path)"}, {"arrows": "to", "from": " Path relativize(Path other)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals"}, {"arrows": "to", "from": " Path relativize(Path other)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isAbsolute"}, {"arrows": "to", "from": " Path relativize(Path other)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getRoot"}, {"arrows": "to", "from": " Path relativize(Path other)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isSameFile"}, {"arrows": "to", "from": " Path relativize(Path other)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "resolve(Path)"}, {"arrows": "to", "from": " Path relativize(Path other)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "normalize"}, {"arrows": "to", "from": " URI toUri()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "get(URI)"}, {"arrows": "to", "from": " URI toUri()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toAbsolutePath"}, {"arrows": "to", "from": " URI toUri()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.URI"}, {"arrows": "to", "from": " URI toUri()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.File"}, {"arrows": "to", "from": " URI toUri()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toAbsolutePath()"}, {"arrows": "to", "from": "java.nio.file.Paths", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Path get(String first, String... more)"}, {"arrows": "to", "from": "java.nio.file.Paths", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Path get(URI uri)"}, {"arrows": "to", "from": "public static Path get(String first, String... more)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault"}, {"arrows": "to", "from": "public static Path get(String first, String... more)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSeparatorname"}, {"arrows": "to", "from": "public static Path get(String first, String... more)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.FileSystem"}, {"arrows": "to", "from": "public static Path get(String first, String... more)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Path"}, {"arrows": "to", "from": "public static Path get(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault"}, {"arrows": "to", "from": "public static Path get(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.spi.FileSystemProvider"}, {"arrows": "to", "from": "public static Path get(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.net.URI"}, {"arrows": "to", "from": "public static Path get(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toAbsolutePath()"}, {"arrows": "to", "from": "public static Path get(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Path"}, {"arrows": "to", "from": "public static Path get(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toUri()"}, {"arrows": "to", "from": "public static Path get(URI uri)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.File"}, {"arrows": "to", "from": " Path toAbsolutePath()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkPropertyAccess(String)"}, {"arrows": "to", "from": " Path toAbsolutePath()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isAbsolute"}, {"arrows": "to", "from": " Path toRealPath(LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkPropertyAccess(String)"}, {"arrows": "to", "from": " Path toRealPath(LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toAbsolutePath"}, {"arrows": "to", "from": " Path toRealPath(LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": " Path toRealPath(LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isAbsolute"}, {"arrows": "to", "from": " Path toRealPath(LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NOFOLLOW_LINKS"}, {"arrows": "to", "from": " Path toRealPath(LinkOption... options) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isSameFile"}, {"arrows": "to", "from": " File toFile()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals"}, {"arrows": "to", "from": " File toFile()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.File"}, {"arrows": "to", "from": " WatchKey register(WatchService watcher, WatchEvent.Kind\u003c?\u003e[] events, WatchEvent.Modifier... modifiers) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ENTRY_CREATE"}, {"arrows": "to", "from": " WatchKey register(WatchService watcher, WatchEvent.Kind\u003c?\u003e[] events, WatchEvent.Modifier... modifiers) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "context"}, {"arrows": "to", "from": " WatchKey register(WatchService watcher, WatchEvent.Kind\u003c?\u003e[] events, WatchEvent.Modifier... modifiers) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.StandardWatchEventKinds"}, {"arrows": "to", "from": " WatchKey register(WatchService watcher, WatchEvent.Kind\u003c?\u003e[] events, WatchEvent.Modifier... modifiers) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "java.nio.file.WatchEvent", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Kind\u003cT\u003e kind()"}, {"arrows": "to", "from": "java.nio.file.WatchEvent", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int count()"}, {"arrows": "to", "from": "java.nio.file.WatchEvent", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " T context()"}, {"arrows": "to", "from": " T context()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ENTRY_CREATE"}, {"arrows": "to", "from": " T context()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.StandardWatchEventKinds"}, {"arrows": "to", "from": " T context()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Path"}, {"arrows": "to", "from": " WatchKey register(WatchService watcher, WatchEvent.Kind\u003c?\u003e... events) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": " WatchKey register(WatchService watcher, WatchEvent.Kind\u003c?\u003e... events) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "register(WatchService"}, {"arrows": "to", "from": " Iterator\u003cPath\u003e iterator()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getRoot"}, {"arrows": "to", "from": " int compareTo(Path other)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals"}, {"arrows": "to", "from": " boolean equals(Object other)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(Object)"}, {"arrows": "to", "from": " boolean equals(Object other)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isSameFile"}, {"arrows": "to", "from": " String toString()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.FileSystem"}, {"arrows": "to", "from": " String toString()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getSeparator"}, {"arrows": "to", "from": "public boolean canRead()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public boolean canWrite()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public boolean exists()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public boolean isDirectory()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public boolean isDirectory()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "readAttributes(Path"}, {"arrows": "to", "from": "public boolean isFile()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public boolean isFile()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "readAttributes(Path"}, {"arrows": "to", "from": "public boolean isHidden()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public long lastModified()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public long lastModified()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "readAttributes(Path"}, {"arrows": "to", "from": "public long length()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public long length()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "readAttributes(Path"}, {"arrows": "to", "from": "public boolean createNewFile() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public boolean createNewFile() throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.FileLock"}, {"arrows": "to", "from": "public boolean delete()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public boolean delete()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "delete(Path)"}, {"arrows": "to", "from": "public boolean delete()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Files"}, {"arrows": "to", "from": "public boolean delete()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.IOException"}, {"arrows": "to", "from": "public void deleteOnExit()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public void deleteOnExit()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "delete"}, {"arrows": "to", "from": "public void deleteOnExit()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.channels.FileLock"}, {"arrows": "to", "from": "public String[] list()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Files"}, {"arrows": "to", "from": "public String[] list()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public String[] list(FilenameFilter filter)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "list()"}, {"arrows": "to", "from": "public String[] list(FilenameFilter filter)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "accept"}, {"arrows": "to", "from": "public String[] list(FilenameFilter filter)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "java.io.FilenameFilter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean accept(File dir, String name)"}, {"arrows": "to", "from": "public File[] listFiles()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Files"}, {"arrows": "to", "from": "public File[] listFiles()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public File[] listFiles()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "File(File"}, {"arrows": "to", "from": "public File[] listFiles(FilenameFilter filter)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public File[] listFiles(FilenameFilter filter)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "listFiles()"}, {"arrows": "to", "from": "public File[] listFiles(FilenameFilter filter)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.FilenameFilter"}, {"arrows": "to", "from": "public File[] listFiles(FileFilter filter)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public File[] listFiles(FileFilter filter)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "listFiles()"}, {"arrows": "to", "from": "public File[] listFiles(FileFilter filter)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "accept"}, {"arrows": "to", "from": "java.io.FileFilter", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean accept(File pathname)"}, {"arrows": "to", "from": "public boolean mkdir()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public boolean mkdirs()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public boolean renameTo(File dest)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "move"}, {"arrows": "to", "from": "public boolean renameTo(File dest)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public boolean renameTo(File dest)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Files"}, {"arrows": "to", "from": "public boolean setLastModified(long time)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public boolean setLastModified(long time)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "lastModified"}, {"arrows": "to", "from": "public boolean setReadOnly()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public boolean setWritable(boolean writable, boolean ownerOnly)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public boolean setWritable(boolean writable, boolean ownerOnly)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Files"}, {"arrows": "to", "from": "public boolean setWritable(boolean writable)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public boolean setReadable(boolean readable, boolean ownerOnly)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public boolean setReadable(boolean readable, boolean ownerOnly)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Files"}, {"arrows": "to", "from": "public boolean setReadable(boolean readable)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public boolean setExecutable(boolean executable, boolean ownerOnly)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public boolean setExecutable(boolean executable, boolean ownerOnly)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Files"}, {"arrows": "to", "from": "public boolean setExecutable(boolean executable)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public boolean canExecute()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public long getTotalSpace()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public long getTotalSpace()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "RuntimePermission"}, {"arrows": "to", "from": "public long getFreeSpace()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public long getFreeSpace()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getTotalSpace"}, {"arrows": "to", "from": "public long getFreeSpace()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "RuntimePermission"}, {"arrows": "to", "from": "public long getUsableSpace()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getFreeSpace"}, {"arrows": "to", "from": "public long getUsableSpace()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "checkRead(String)"}, {"arrows": "to", "from": "public long getUsableSpace()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "RuntimePermission"}, {"arrows": "to", "from": "public static File createTempFile(String prefix, String suffix, File directory) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public static File createTempFile(String prefix, String suffix, File directory) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "deleteOnExit"}, {"arrows": "to", "from": "public static File createTempFile(String prefix, String suffix) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public static File createTempFile(String prefix, String suffix) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "createTempFile(java.lang.String"}, {"arrows": "to", "from": "public static File createTempFile(String prefix, String suffix) throws IOException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Files"}, {"arrows": "to", "from": "public Path toPath()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getDefault"}, {"arrows": "to", "from": "public Path toPath()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getPath"}, {"arrows": "to", "from": "public Path toPath()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.io.File"}, {"arrows": "to", "from": "public Path toPath()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.nio.file.Path"}, {"arrows": "to", "from": "public static void setProperties(Properties props)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getProperty"}, {"arrows": "to", "from": "public static String getenv(String name)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public static String getenv(String name)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.RuntimePermission"}, {"arrows": "to", "from": "public static String getenv(String name)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityException"}, {"arrows": "to", "from": "public static java.util.Map\u003cString, String\u003e getenv()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals"}, {"arrows": "to", "from": "public static java.util.Map\u003cString, String\u003e getenv()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityManager"}, {"arrows": "to", "from": "public static java.util.Map\u003cString, String\u003e getenv()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "hashCode"}, {"arrows": "to", "from": "public static java.util.Map\u003cString, String\u003e getenv()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.RuntimePermission"}, {"arrows": "to", "from": "public static java.util.Map\u003cString, String\u003e getenv()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.SecurityException"}, {"arrows": "to", "from": "public static java.util.Map\u003cString, String\u003e getenv()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.String"}, {"arrows": "to", "from": "public static java.util.Map\u003cString, String\u003e getenv()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.ClassCastException"}, {"arrows": "to", "from": "public static java.util.Map\u003cString, String\u003e getenv()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.NullPointerException"}, {"arrows": "to", "from": "public static Integer getInteger(String nm, int val)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getProperty(java.lang.String)"}, {"arrows": "to", "from": "public static Integer getInteger(String nm, int val)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "decode"}, {"arrows": "to", "from": "public static Integer getInteger(String nm, int val)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getProperty(String)"}, {"arrows": "to", "from": "public static Integer getInteger(String nm, Integer val)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getProperty(java.lang.String)"}, {"arrows": "to", "from": "public static Integer getInteger(String nm, Integer val)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "decode"}, {"arrows": "to", "from": "public static Integer getInteger(String nm, Integer val)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getProperty(String)"}, {"arrows": "to", "from": "public static Integer getInteger(String nm, Integer val)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "valueOf(java.lang.String"}, {"arrows": "to", "from": "public static Integer decode(String nm) throws NumberFormatException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.NumberFormatException"}, {"arrows": "to", "from": "java.lang.NumberFormatException", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static NumberFormatException forInputString(String s, int radix)"}, {"arrows": "to", "from": "java.lang.NumberFormatException", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " static NumberFormatException forCharSequence(CharSequence s, int beginIndex, int endIndex, int errorIndex)"}, {"arrows": "to", "from": "public static int max(int a, int b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "max(int"}, {"arrows": "to", "from": "public static int min(int a, int b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "min(int"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public StringBuffer format(Object number, StringBuffer toAppendTo, FieldPosition pos)"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final Object parseObject(String source, ParsePosition pos)"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final String format(double number)"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public final String format(long number)"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract StringBuffer format(double number, StringBuffer toAppendTo, FieldPosition pos)"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract StringBuffer format(long number, StringBuffer toAppendTo, FieldPosition pos)"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract Number parse(String source, ParsePosition parsePosition)"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Number parse(String source) throws ParseException"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isParseIntegerOnly()"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setParseIntegerOnly(boolean value)"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final NumberFormat getInstance()"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static NumberFormat getInstance(Locale inLocale)"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final NumberFormat getNumberInstance()"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static NumberFormat getNumberInstance(Locale inLocale)"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final NumberFormat getIntegerInstance()"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static NumberFormat getIntegerInstance(Locale inLocale)"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final NumberFormat getCurrencyInstance()"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static NumberFormat getCurrencyInstance(Locale inLocale)"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static final NumberFormat getPercentInstance()"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static NumberFormat getPercentInstance(Locale inLocale)"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Locale[] getAvailableLocales()"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int hashCode()"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean equals(Object obj)"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Object clone()"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public boolean isGroupingUsed()"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setGroupingUsed(boolean newValue)"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getMaximumIntegerDigits()"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setMaximumIntegerDigits(int newValue)"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getMinimumIntegerDigits()"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setMinimumIntegerDigits(int newValue)"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getMaximumFractionDigits()"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setMaximumFractionDigits(int newValue)"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public int getMinimumFractionDigits()"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setMinimumFractionDigits(int newValue)"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public Currency getCurrency()"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setCurrency(Currency currency)"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public RoundingMode getRoundingMode()"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public void setRoundingMode(RoundingMode roundingMode)"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException"}, {"arrows": "to", "from": "java.text.NumberFormat", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "private void writeObject(ObjectOutputStream stream) throws IOException"}, {"arrows": "to", "from": "public StringBuffer format(Object number, StringBuffer toAppendTo, FieldPosition pos)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "INTEGER_FIELD"}, {"arrows": "to", "from": "public StringBuffer format(Object number, StringBuffer toAppendTo, FieldPosition pos)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "doubleValue()"}, {"arrows": "to", "from": "public StringBuffer format(Object number, StringBuffer toAppendTo, FieldPosition pos)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "format(long"}, {"arrows": "to", "from": "public StringBuffer format(Object number, StringBuffer toAppendTo, FieldPosition pos)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "bitLength()"}, {"arrows": "to", "from": "public StringBuffer format(Object number, StringBuffer toAppendTo, FieldPosition pos)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.Number"}, {"arrows": "to", "from": "public StringBuffer format(Object number, StringBuffer toAppendTo, FieldPosition pos)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "format(double"}, {"arrows": "to", "from": "java.lang.Number", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract int intValue()"}, {"arrows": "to", "from": "java.lang.Number", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract long longValue()"}, {"arrows": "to", "from": "java.lang.Number", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract float floatValue()"}, {"arrows": "to", "from": "java.lang.Number", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public abstract double doubleValue()"}, {"arrows": "to", "from": "java.lang.Number", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public byte byteValue()"}, {"arrows": "to", "from": "java.lang.Number", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public short shortValue()"}, {"arrows": "to", "from": "public final Object parseObject(String source, ParsePosition pos)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "parse(String"}, {"arrows": "to", "from": "public abstract StringBuffer format(double number, StringBuffer toAppendTo, FieldPosition pos)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "INTEGER_FIELD"}, {"arrows": "to", "from": "public abstract StringBuffer format(long number, StringBuffer toAppendTo, FieldPosition pos)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "INTEGER_FIELD"}, {"arrows": "to", "from": "public Number parse(String source) throws ParseException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "parse(String"}, {"arrows": "to", "from": "public static final NumberFormat getInstance()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FORMAT"}, {"arrows": "to", "from": "public static final NumberFormat getInstance()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getNumberInstance()"}, {"arrows": "to", "from": "public static NumberFormat getInstance(Locale inLocale)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getNumberInstance(java.util.Locale)"}, {"arrows": "to", "from": "public static final NumberFormat getNumberInstance()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FORMAT"}, {"arrows": "to", "from": "public static final NumberFormat getNumberInstance()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getNumberInstance(Locale)"}, {"arrows": "to", "from": "public static final NumberFormat getIntegerInstance()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isParseIntegerOnly"}, {"arrows": "to", "from": "public static final NumberFormat getIntegerInstance()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FORMAT"}, {"arrows": "to", "from": "public static final NumberFormat getIntegerInstance()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getIntegerInstance(Locale)"}, {"arrows": "to", "from": "public static final NumberFormat getIntegerInstance()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "HALF_EVEN"}, {"arrows": "to", "from": "public static NumberFormat getIntegerInstance(Locale inLocale)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isParseIntegerOnly"}, {"arrows": "to", "from": "public static NumberFormat getIntegerInstance(Locale inLocale)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "HALF_EVEN"}, {"arrows": "to", "from": "public static final NumberFormat getCurrencyInstance()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getCurrencyInstance(Locale)"}, {"arrows": "to", "from": "public static final NumberFormat getCurrencyInstance()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FORMAT"}, {"arrows": "to", "from": "public static final NumberFormat getPercentInstance()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "getPercentInstance(Locale)"}, {"arrows": "to", "from": "public static final NumberFormat getPercentInstance()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FORMAT"}, {"arrows": "to", "from": "public static Locale[] getAvailableLocales()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "FORMAT"}, {"arrows": "to", "from": "public static Locale[] getAvailableLocales()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Locale"}, {"arrows": "to", "from": "public static Locale[] getAvailableLocales()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "NumberFormat.Style"}, {"arrows": "to", "from": "public Currency getCurrency()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "setCurrency(java.util.Currency)"}, {"arrows": "to", "from": "public RoundingMode getRoundingMode()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.UnsupportedOperationException"}, {"arrows": "to", "from": "public RoundingMode getRoundingMode()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.math.RoundingMode"}, {"arrows": "to", "from": "public void setRoundingMode(RoundingMode roundingMode)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.UnsupportedOperationException"}, {"arrows": "to", "from": "public void setRoundingMode(RoundingMode roundingMode)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.math.RoundingMode"}, {"arrows": "to", "from": "public static String toHexString(double d)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "toString(int)"}, {"arrows": "to", "from": "public static Double valueOf(String s) throws NumberFormatException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.lang.String"}, {"arrows": "to", "from": "public static Double valueOf(String s) throws NumberFormatException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MIN_VALUE"}, {"arrows": "to", "from": "public static Double valueOf(String s) throws NumberFormatException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "MAX_VALUE"}, {"arrows": "to", "from": "public static Double valueOf(String s) throws NumberFormatException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ulp(double)"}, {"arrows": "to", "from": "public static Double valueOf(String s) throws NumberFormatException", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.text.NumberFormat"}, {"arrows": "to", "from": "public static Double valueOf(double d)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Double(double)"}, {"arrows": "to", "from": "public static long doubleToLongBits(double value)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "longBitsToDouble(long)"}, {"arrows": "to", "from": "public static native long doubleToRawLongBits(double value)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "longBitsToDouble(long)"}, {"arrows": "to", "from": "public static double max(double a, double b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "max(double"}, {"arrows": "to", "from": "public static double min(double a, double b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "min(double"}, {"arrows": "to", "from": " DoubleStream sorted()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compare(double"}, {"arrows": "to", "from": " DoubleStream peek(DoubleConsumer action)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "count"}, {"arrows": "to", "from": " DoubleStream limit(long maxSize)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "generate(DoubleSupplier)"}, {"arrows": "to", "from": " DoubleStream limit(long maxSize)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unordered()"}, {"arrows": "to", "from": " DoubleStream limit(long maxSize)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sequential()"}, {"arrows": "to", "from": " DoubleStream skip(long n)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "generate(DoubleSupplier)"}, {"arrows": "to", "from": " DoubleStream skip(long n)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unordered()"}, {"arrows": "to", "from": " DoubleStream skip(long n)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sequential()"}, {"arrows": "to", "from": " DoubleStream takeWhile(DoublePredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "spliterator()"}, {"arrows": "to", "from": " DoubleStream takeWhile(DoublePredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isParallel()"}, {"arrows": "to", "from": " DoubleStream takeWhile(DoublePredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "generate(DoubleSupplier)"}, {"arrows": "to", "from": " DoubleStream takeWhile(DoublePredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unordered()"}, {"arrows": "to", "from": " DoubleStream takeWhile(DoublePredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sequential()"}, {"arrows": "to", "from": " DoubleStream dropWhile(DoublePredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "spliterator()"}, {"arrows": "to", "from": " DoubleStream dropWhile(DoublePredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isParallel()"}, {"arrows": "to", "from": " DoubleStream dropWhile(DoublePredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "generate(DoubleSupplier)"}, {"arrows": "to", "from": " DoubleStream dropWhile(DoublePredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unordered()"}, {"arrows": "to", "from": " DoubleStream dropWhile(DoublePredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sequential()"}, {"arrows": "to", "from": " R collect(Supplier\u003cR\u003e supplier, ObjDoubleConsumer\u003cR\u003e accumulator, BiConsumer\u003cR, R\u003e combiner)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "reduce(double"}, {"arrows": "to", "from": " OptionalDouble average()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sum"}, {"arrows": "to", "from": " OptionalDouble findFirst()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.OptionalDouble"}, {"arrows": "to", "from": " OptionalDouble findAny()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "findFirst()"}, {"arrows": "to", "from": " OptionalDouble findAny()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.OptionalDouble"}, {"arrows": "to", "from": "public static Stream\u003cT\u003e stream(T[] array, int startInclusive, int endExclusive)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.stream.DoubleStream"}, {"arrows": "to", "from": "public static IntStream stream(int[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.stream.IntStream"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " IntStream filter(IntPredicate predicate)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " IntStream map(IntUnaryOperator mapper)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Stream\u003cU\u003e mapToObj(IntFunction\u003c? extends U\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " LongStream mapToLong(IntToLongFunction mapper)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " DoubleStream mapToDouble(IntToDoubleFunction mapper)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " IntStream flatMap(IntFunction\u003c? extends IntStream\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " IntStream mapMulti(IntMapMultiConsumer mapper)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " IntStream distinct()"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " IntStream sorted()"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " IntStream peek(IntConsumer action)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " IntStream limit(long maxSize)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " IntStream skip(long n)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " IntStream takeWhile(IntPredicate predicate)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " IntStream dropWhile(IntPredicate predicate)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void forEach(IntConsumer action)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void forEachOrdered(IntConsumer action)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int[] toArray()"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int reduce(int identity, IntBinaryOperator op)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " OptionalInt reduce(IntBinaryOperator op)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " R collect(Supplier\u003cR\u003e supplier, ObjIntConsumer\u003cR\u003e accumulator, BiConsumer\u003cR, R\u003e combiner)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " int sum()"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " OptionalInt min()"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " OptionalInt max()"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " long count()"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " OptionalDouble average()"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " IntSummaryStatistics summaryStatistics()"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean anyMatch(IntPredicate predicate)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean allMatch(IntPredicate predicate)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean noneMatch(IntPredicate predicate)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " OptionalInt findFirst()"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " OptionalInt findAny()"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " LongStream asLongStream()"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " DoubleStream asDoubleStream()"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Stream\u003cInteger\u003e boxed()"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Builder builder()"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static IntStream empty()"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static IntStream of(int t)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static IntStream of(int... values)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static IntStream iterate(final int seed, final IntUnaryOperator f)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static IntStream iterate(int seed, IntPredicate hasNext, IntUnaryOperator next)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static IntStream generate(IntSupplier s)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static IntStream range(int startInclusive, int endExclusive)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static IntStream rangeClosed(int startInclusive, int endInclusive)"}, {"arrows": "to", "from": "java.util.stream.IntStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static IntStream concat(IntStream a, IntStream b)"}, {"arrows": "to", "from": " IntStream flatMap(IntFunction\u003c? extends IntStream\u003e mapper)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close()"}, {"arrows": "to", "from": " IntStream mapMulti(IntMapMultiConsumer mapper)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "flatMap"}, {"arrows": "to", "from": " IntStream peek(IntConsumer action)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "count"}, {"arrows": "to", "from": " IntStream limit(long maxSize)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "generate(IntSupplier)"}, {"arrows": "to", "from": " IntStream limit(long maxSize)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unordered()"}, {"arrows": "to", "from": " IntStream limit(long maxSize)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sequential()"}, {"arrows": "to", "from": " IntStream skip(long n)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "generate(IntSupplier)"}, {"arrows": "to", "from": " IntStream skip(long n)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unordered()"}, {"arrows": "to", "from": " IntStream skip(long n)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sequential()"}, {"arrows": "to", "from": " IntStream takeWhile(IntPredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "generate(IntSupplier)"}, {"arrows": "to", "from": " IntStream takeWhile(IntPredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "spliterator()"}, {"arrows": "to", "from": " IntStream takeWhile(IntPredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isParallel()"}, {"arrows": "to", "from": " IntStream takeWhile(IntPredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unordered()"}, {"arrows": "to", "from": " IntStream takeWhile(IntPredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sequential()"}, {"arrows": "to", "from": " IntStream dropWhile(IntPredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "generate(IntSupplier)"}, {"arrows": "to", "from": " IntStream dropWhile(IntPredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "spliterator()"}, {"arrows": "to", "from": " IntStream dropWhile(IntPredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isParallel()"}, {"arrows": "to", "from": " IntStream dropWhile(IntPredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unordered()"}, {"arrows": "to", "from": " IntStream dropWhile(IntPredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sequential()"}, {"arrows": "to", "from": " R collect(Supplier\u003cR\u003e supplier, ObjIntConsumer\u003cR\u003e accumulator, BiConsumer\u003cR, R\u003e combiner)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "reduce(int"}, {"arrows": "to", "from": " OptionalInt findFirst()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.OptionalInt"}, {"arrows": "to", "from": " OptionalInt findAny()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "findFirst()"}, {"arrows": "to", "from": " OptionalInt findAny()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.OptionalInt"}, {"arrows": "to", "from": "public static IntStream stream(int[] array, int startInclusive, int endExclusive)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.stream.IntStream"}, {"arrows": "to", "from": "public static LongStream stream(long[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.stream.LongStream"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " LongStream filter(LongPredicate predicate)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " LongStream map(LongUnaryOperator mapper)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Stream\u003cU\u003e mapToObj(LongFunction\u003c? extends U\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " IntStream mapToInt(LongToIntFunction mapper)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " DoubleStream mapToDouble(LongToDoubleFunction mapper)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " LongStream flatMap(LongFunction\u003c? extends LongStream\u003e mapper)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " LongStream mapMulti(LongMapMultiConsumer mapper)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " LongStream distinct()"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " LongStream sorted()"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " LongStream peek(LongConsumer action)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " LongStream limit(long maxSize)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " LongStream skip(long n)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " LongStream takeWhile(LongPredicate predicate)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " LongStream dropWhile(LongPredicate predicate)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void forEach(LongConsumer action)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void forEachOrdered(LongConsumer action)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " long[] toArray()"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " long reduce(long identity, LongBinaryOperator op)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " OptionalLong reduce(LongBinaryOperator op)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " R collect(Supplier\u003cR\u003e supplier, ObjLongConsumer\u003cR\u003e accumulator, BiConsumer\u003cR, R\u003e combiner)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " long sum()"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " OptionalLong min()"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " OptionalLong max()"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " long count()"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " OptionalDouble average()"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " LongSummaryStatistics summaryStatistics()"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean anyMatch(LongPredicate predicate)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean allMatch(LongPredicate predicate)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean noneMatch(LongPredicate predicate)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " OptionalLong findFirst()"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " OptionalLong findAny()"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " DoubleStream asDoubleStream()"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " Stream\u003cLong\u003e boxed()"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static Builder builder()"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static LongStream empty()"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static LongStream of(long t)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static LongStream of(long... values)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static LongStream iterate(final long seed, final LongUnaryOperator f)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static LongStream iterate(long seed, LongPredicate hasNext, LongUnaryOperator next)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static LongStream generate(LongSupplier s)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static LongStream range(long startInclusive, final long endExclusive)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static LongStream rangeClosed(long startInclusive, final long endInclusive)"}, {"arrows": "to", "from": "java.util.stream.LongStream", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": "public static LongStream concat(LongStream a, LongStream b)"}, {"arrows": "to", "from": " LongStream flatMap(LongFunction\u003c? extends LongStream\u003e mapper)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "close()"}, {"arrows": "to", "from": " LongStream mapMulti(LongMapMultiConsumer mapper)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "flatMap"}, {"arrows": "to", "from": " LongStream peek(LongConsumer action)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "count"}, {"arrows": "to", "from": " LongStream limit(long maxSize)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "generate(LongSupplier)"}, {"arrows": "to", "from": " LongStream limit(long maxSize)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unordered()"}, {"arrows": "to", "from": " LongStream limit(long maxSize)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sequential()"}, {"arrows": "to", "from": " LongStream skip(long n)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "generate(LongSupplier)"}, {"arrows": "to", "from": " LongStream skip(long n)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unordered()"}, {"arrows": "to", "from": " LongStream skip(long n)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sequential()"}, {"arrows": "to", "from": " LongStream takeWhile(LongPredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "spliterator()"}, {"arrows": "to", "from": " LongStream takeWhile(LongPredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isParallel()"}, {"arrows": "to", "from": " LongStream takeWhile(LongPredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "generate(LongSupplier)"}, {"arrows": "to", "from": " LongStream takeWhile(LongPredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unordered()"}, {"arrows": "to", "from": " LongStream takeWhile(LongPredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sequential()"}, {"arrows": "to", "from": " LongStream dropWhile(LongPredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "spliterator()"}, {"arrows": "to", "from": " LongStream dropWhile(LongPredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "isParallel()"}, {"arrows": "to", "from": " LongStream dropWhile(LongPredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "generate(LongSupplier)"}, {"arrows": "to", "from": " LongStream dropWhile(LongPredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "unordered()"}, {"arrows": "to", "from": " LongStream dropWhile(LongPredicate predicate)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "sequential()"}, {"arrows": "to", "from": " R collect(Supplier\u003cR\u003e supplier, ObjLongConsumer\u003cR\u003e accumulator, BiConsumer\u003cR, R\u003e combiner)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "reduce(long"}, {"arrows": "to", "from": " OptionalLong findFirst()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.OptionalLong"}, {"arrows": "to", "from": " OptionalLong findAny()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.OptionalLong"}, {"arrows": "to", "from": " OptionalLong findAny()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "findFirst()"}, {"arrows": "to", "from": "public static LongStream stream(long[] array, int startInclusive, int endExclusive)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.stream.LongStream"}, {"arrows": "to", "from": "public static DoubleStream stream(double[] array)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.stream.DoubleStream"}, {"arrows": "to", "from": "public static DoubleStream stream(double[] array, int startInclusive, int endExclusive)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.stream.DoubleStream"}, {"arrows": "to", "from": "public static int compare(boolean[] a, boolean[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(boolean"}, {"arrows": "to", "from": "public static int compare(boolean[] a, boolean[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compare(boolean"}, {"arrows": "to", "from": "public static int compare(boolean[] a, boolean[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(boolean"}, {"arrows": "to", "from": "public static int compare(boolean[] a, int aFromIndex, int aToIndex, boolean[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(boolean"}, {"arrows": "to", "from": "public static int compare(boolean[] a, int aFromIndex, int aToIndex, boolean[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compare(boolean"}, {"arrows": "to", "from": "public static int compare(boolean[] a, int aFromIndex, int aToIndex, boolean[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(boolean"}, {"arrows": "to", "from": "public static int compare(byte[] a, byte[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compare(byte"}, {"arrows": "to", "from": "public static int compare(byte[] a, byte[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(byte"}, {"arrows": "to", "from": "public static int compare(byte[] a, byte[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(byte"}, {"arrows": "to", "from": "public static int compare(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compare(byte"}, {"arrows": "to", "from": "public static int compare(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(byte"}, {"arrows": "to", "from": "public static int compare(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(byte"}, {"arrows": "to", "from": "public static int compareUnsigned(byte[] a, byte[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compareUnsigned(byte"}, {"arrows": "to", "from": "public static int compareUnsigned(byte[] a, byte[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(byte"}, {"arrows": "to", "from": "public static int compareUnsigned(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compareUnsigned(byte"}, {"arrows": "to", "from": "public static int compareUnsigned(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(byte"}, {"arrows": "to", "from": "public static int compare(short[] a, short[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compare(short"}, {"arrows": "to", "from": "public static int compare(short[] a, short[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(short"}, {"arrows": "to", "from": "public static int compare(short[] a, short[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(short"}, {"arrows": "to", "from": "public static int compare(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compare(short"}, {"arrows": "to", "from": "public static int compare(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(short"}, {"arrows": "to", "from": "public static int compare(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(short"}, {"arrows": "to", "from": "public static int compareUnsigned(short[] a, short[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compareUnsigned(short"}, {"arrows": "to", "from": "public static int compareUnsigned(short[] a, short[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(short"}, {"arrows": "to", "from": "public static int compareUnsigned(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compareUnsigned(short"}, {"arrows": "to", "from": "public static int compareUnsigned(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(short"}, {"arrows": "to", "from": "public static int compare(char[] a, char[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(char"}, {"arrows": "to", "from": "public static int compare(char[] a, char[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(char"}, {"arrows": "to", "from": "public static int compare(char[] a, char[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compare(char"}, {"arrows": "to", "from": "public static int compare(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(char"}, {"arrows": "to", "from": "public static int compare(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(char"}, {"arrows": "to", "from": "public static int compare(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compare(char"}, {"arrows": "to", "from": "public static int compare(int[] a, int[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(int"}, {"arrows": "to", "from": "public static int compare(int[] a, int[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(int"}, {"arrows": "to", "from": "public static int compare(int[] a, int[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compare(int"}, {"arrows": "to", "from": "public static int compare(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(int"}, {"arrows": "to", "from": "public static int compare(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(int"}, {"arrows": "to", "from": "public static int compare(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compare(int"}, {"arrows": "to", "from": "public static int compareUnsigned(int[] a, int[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(int"}, {"arrows": "to", "from": "public static int compareUnsigned(int[] a, int[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compareUnsigned(int"}, {"arrows": "to", "from": "public static int compareUnsigned(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(int"}, {"arrows": "to", "from": "public static int compareUnsigned(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compareUnsigned(int"}, {"arrows": "to", "from": "public static int compare(long[] a, long[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compare(long"}, {"arrows": "to", "from": "public static int compare(long[] a, long[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(long"}, {"arrows": "to", "from": "public static int compare(long[] a, long[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(long"}, {"arrows": "to", "from": "public static int compare(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compare(long"}, {"arrows": "to", "from": "public static int compare(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(long"}, {"arrows": "to", "from": "public static int compare(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(long"}, {"arrows": "to", "from": "public static int compareUnsigned(long[] a, long[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compareUnsigned(long"}, {"arrows": "to", "from": "public static int compareUnsigned(long[] a, long[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(long"}, {"arrows": "to", "from": "public static int compareUnsigned(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compareUnsigned(long"}, {"arrows": "to", "from": "public static int compareUnsigned(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(long"}, {"arrows": "to", "from": "public static int compare(float[] a, float[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compare(float"}, {"arrows": "to", "from": "public static int compare(float[] a, float[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(float"}, {"arrows": "to", "from": "public static int compare(float[] a, float[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(float"}, {"arrows": "to", "from": "public static int compare(float[] a, int aFromIndex, int aToIndex, float[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compare(float"}, {"arrows": "to", "from": "public static int compare(float[] a, int aFromIndex, int aToIndex, float[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(float"}, {"arrows": "to", "from": "public static int compare(float[] a, int aFromIndex, int aToIndex, float[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(float"}, {"arrows": "to", "from": "public static int compare(double[] a, double[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(double"}, {"arrows": "to", "from": "public static int compare(double[] a, double[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compare(double"}, {"arrows": "to", "from": "public static int compare(double[] a, double[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(double"}, {"arrows": "to", "from": "public static int compare(double[] a, int aFromIndex, int aToIndex, double[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(double"}, {"arrows": "to", "from": "public static int compare(double[] a, int aFromIndex, int aToIndex, double[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "compare(double"}, {"arrows": "to", "from": "public static int compare(double[] a, int aFromIndex, int aToIndex, double[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(double"}, {"arrows": "to", "from": "public static int compare(T[] a, T[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(Object"}, {"arrows": "to", "from": "public static int compare(T[] a, T[] b)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(Object"}, {"arrows": "to", "from": "public static int compare(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(Object"}, {"arrows": "to", "from": "public static int compare(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "equals(Object"}, {"arrows": "to", "from": "public static int compare(T[] a, T[] b, Comparator\u003c? super T\u003e cmp)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(Object"}, {"arrows": "to", "from": "public static int compare(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator\u003c? super T\u003e cmp)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "mismatch(Object"}, {"arrows": "to", "from": "public static Spliterator\u003cT\u003e spliterator(Object[] array, int fromIndex, int toIndex, int additionalCharacteristics)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "spliterator(Object"}, {"arrows": "to", "from": "public static Spliterator.OfInt spliterator(int[] array, int additionalCharacteristics)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Arrays"}, {"arrows": "to", "from": "public static Spliterator.OfInt spliterator(int[] array, int fromIndex, int toIndex, int additionalCharacteristics)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Arrays"}, {"arrows": "to", "from": "public static Spliterator.OfLong spliterator(long[] array, int additionalCharacteristics)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Arrays"}, {"arrows": "to", "from": "public static Spliterator.OfLong spliterator(long[] array, int fromIndex, int toIndex, int additionalCharacteristics)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Arrays"}, {"arrows": "to", "from": "public static Spliterator.OfDouble spliterator(double[] array, int additionalCharacteristics)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Arrays"}, {"arrows": "to", "from": "public static Spliterator.OfDouble spliterator(double[] array, int fromIndex, int toIndex, int additionalCharacteristics)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Arrays"}, {"arrows": "to", "from": "public static Spliterator\u003cT\u003e spliterator(Collection\u003c? extends T\u003e c, int characteristics)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Collection"}, {"arrows": "to", "from": " Stream\u003cE\u003e stream()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "spliterator()"}, {"arrows": "to", "from": " Stream\u003cE\u003e parallelStream()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "spliterator()"}, {"arrows": "to", "from": " static Set\u003cE\u003e of(E... elements)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "of(Object)"}, {"arrows": "to", "from": " Collection\u003cV\u003e values()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Collection"}, {"arrows": "to", "from": " Set\u003cMap.Entry\u003cK, V\u003e\u003e entrySet()", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.Set"}, {"arrows": "to", "from": " V computeIfAbsent(K key, Function\u003c? super K, ? extends V\u003e mappingFunction)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.concurrent.ConcurrentMap"}, {"arrows": "to", "from": "java.util.concurrent.ConcurrentMap", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " V getOrDefault(Object key, V defaultValue)"}, {"arrows": "to", "from": "java.util.concurrent.ConcurrentMap", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void forEach(BiConsumer\u003c? super K, ? super V\u003e action)"}, {"arrows": "to", "from": "java.util.concurrent.ConcurrentMap", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " V putIfAbsent(K key, V value)"}, {"arrows": "to", "from": "java.util.concurrent.ConcurrentMap", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean remove(Object key, Object value)"}, {"arrows": "to", "from": "java.util.concurrent.ConcurrentMap", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " boolean replace(K key, V oldValue, V newValue)"}, {"arrows": "to", "from": "java.util.concurrent.ConcurrentMap", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " V replace(K key, V value)"}, {"arrows": "to", "from": "java.util.concurrent.ConcurrentMap", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " void replaceAll(BiFunction\u003c? super K, ? super V, ? extends V\u003e function)"}, {"arrows": "to", "from": "java.util.concurrent.ConcurrentMap", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " V computeIfAbsent(K key, Function\u003c? super K, ? extends V\u003e mappingFunction)"}, {"arrows": "to", "from": "java.util.concurrent.ConcurrentMap", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " V computeIfPresent(K key, BiFunction\u003c? super K, ? super V, ? extends V\u003e remappingFunction)"}, {"arrows": "to", "from": "java.util.concurrent.ConcurrentMap", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " V compute(K key, BiFunction\u003c? super K, ? super V, ? extends V\u003e remappingFunction)"}, {"arrows": "to", "from": "java.util.concurrent.ConcurrentMap", "title": "{\u0027type\u0027: \u0027child\u0027}", "to": " V merge(K key, V value, BiFunction\u003c? super V, ? super V, ? extends V\u003e remappingFunction)"}, {"arrows": "to", "from": " V computeIfPresent(K key, BiFunction\u003c? super K, ? super V, ? extends V\u003e remappingFunction)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.concurrent.ConcurrentMap"}, {"arrows": "to", "from": " V compute(K key, BiFunction\u003c? super K, ? super V, ? extends V\u003e remappingFunction)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "merge"}, {"arrows": "to", "from": " V compute(K key, BiFunction\u003c? super K, ? super V, ? extends V\u003e remappingFunction)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.concurrent.ConcurrentMap"}, {"arrows": "to", "from": " V merge(K key, V value, BiFunction\u003c? super V, ? super V, ? extends V\u003e remappingFunction)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "java.util.concurrent.ConcurrentMap"}, {"arrows": "to", "from": " static Map\u003cK, V\u003e ofEntries(Entry\u003c? extends K, ? extends V\u003e... entries)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "entry"}, {"arrows": "to", "from": " static Entry\u003cK, V\u003e entry(K k, V v)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "setValue"}, {"arrows": "to", "from": " static Entry\u003cK, V\u003e entry(K k, V v)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "Entry"}, {"arrows": "to", "from": " static Entry\u003cK, V\u003e entry(K k, V v)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "AbstractMap.SimpleImmutableEntry"}, {"arrows": "to", "from": " static Entry\u003cK, V\u003e entry(K k, V v)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "ofEntries"}, {"arrows": "to", "from": " static Entry\u003cK, V\u003e entry(K k, V v)", "title": "{\u0027type\u0027: \u0027link\u0027}", "to": "AbstractMap.SimpleEntry"}]);

                  nodeColors = {};
                  allNodes = nodes.get({ returnType: "Object" });
                  for (nodeId in allNodes) {
                    nodeColors[nodeId] = allNodes[nodeId].color;
                  }
                  allEdges = edges.get({ returnType: "Object" });
                  // adding nodes and edges to the graph
                  data = {nodes: nodes, edges: edges};

                  var options = {
    "configure": {
        "enabled": false
    },
    "edges": {
        "color": {
            "inherit": true
        },
        "smooth": {
            "enabled": true,
            "type": "dynamic"
        }
    },
    "interaction": {
        "dragNodes": true,
        "hideEdgesOnDrag": false,
        "hideNodesOnDrag": false
    },
    "physics": {
        "enabled": true,
        "stabilization": {
            "enabled": true,
            "fit": true,
            "iterations": 1000,
            "onlyDynamicEdges": false,
            "updateInterval": 50
        }
    }
};

                  


                  

                  network = new vis.Network(container, data, options);

                  

                  

                  
                  // make a custom popup
                      var popup = document.createElement("div");
                      popup.className = 'popup';
                      popupTimeout = null;
                      popup.addEventListener('mouseover', function () {
                          console.log(popup)
                          if (popupTimeout !== null) {
                              clearTimeout(popupTimeout);
                              popupTimeout = null;
                          }
                      });
                      popup.addEventListener('mouseout', function () {
                          if (popupTimeout === null) {
                              hidePopup();
                          }
                      });
                      container.appendChild(popup);


                      // use the popup event to show
                      network.on("showPopup", function (params) {
                          showPopup(params);
                      });

                      // use the hide event to hide it
                      network.on("hidePopup", function (params) {
                          hidePopup();
                      });

                      // hiding the popup through css
                      function hidePopup() {
                          popupTimeout = setTimeout(function () { popup.style.display = 'none'; }, 500);
                      }

                      // showing the popup
                      function showPopup(nodeId) {
                          // get the data from the vis.DataSet
                          var nodeData = nodes.get([nodeId]);
                          popup.innerHTML = nodeData[0].title;

                          // get the position of the node
                          var posCanvas = network.getPositions([nodeId])[nodeId];

                          // get the bounding box of the node
                          var boundingBox = network.getBoundingBox(nodeId);

                          //position tooltip:
                          posCanvas.x = posCanvas.x + 0.5 * (boundingBox.right - boundingBox.left);

                          // convert coordinates to the DOM space
                          var posDOM = network.canvasToDOM(posCanvas);

                          // Give it an offset
                          posDOM.x += 10;
                          posDOM.y -= 20;

                          // show and place the tooltip.
                          popup.style.display = 'block';
                          popup.style.top = posDOM.y + 'px';
                          popup.style.left = posDOM.x + 'px';
                      }
                  


                  
                      network.on("stabilizationProgress", function(params) {
                          document.getElementById('loadingBar').removeAttribute("style");
                          var maxWidth = 496;
                          var minWidth = 20;
                          var widthFactor = params.iterations/params.total;
                          var width = Math.max(minWidth,maxWidth * widthFactor);
                          document.getElementById('bar').style.width = width + 'px';
                          document.getElementById('text').innerHTML = Math.round(widthFactor*100) + '%';
                      });
                      network.once("stabilizationIterationsDone", function() {
                          document.getElementById('text').innerHTML = '100%';
                          document.getElementById('bar').style.width = '496px';
                          document.getElementById('loadingBar').style.opacity = 0;
                          // really clean the dom element
                          setTimeout(function () {document.getElementById('loadingBar').style.display = 'none';}, 500);
                      });
                  

                  return network;

              }
              drawGraph();
        </script>
    </body>
</html>