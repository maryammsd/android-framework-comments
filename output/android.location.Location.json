{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/location/Location.java",
  "packageName" : "android.location",
  "className" : "Location",
  "comment" : "\n * A data class representing a geographic location. A location consists of a latitude, longitude,\n * timestamp, accuracy, and other information such as bearing, altitude and velocity.\n *\n * <p>All locations generated through {@link LocationManager} are guaranteed to have a valid\n * latitude, longitude, timestamp (both Unix epoch time and elapsed realtime since boot), and\n * accuracy. All other parameters are optional.\n *\n * <p class=\"note\">Note that Android provides the ability for applications to submit \"mock\" or faked\n * locations through {@link LocationManager}, and that these locations can then be received by\n * applications using LocationManager to obtain location information. These locations can be\n * identified via the {@link #isMock()} API. Applications that wish to determine if a given location\n * represents the best estimate of the real position of the device as opposed to a fake location\n * coming from another application or the user should use this API. Keep in mind that the user may\n * have a good reason for mocking their location, and thus apps should generally reject mock\n * locations only when it is essential to their use case that only real locations are accepted.\n ",
  "links" : [ "#isMock()", "android.location.LocationManager" ],
  "variables" : [ {
    "name" : "FORMAT_DEGREES",
    "type" : "int",
    "comment" : "\n     * Constant used to specify formatting of a latitude or longitude in the form \"[+-]DDD.DDDDD\n     * where D indicates degrees.\n     ",
    "links" : [ ]
  }, {
    "name" : "FORMAT_MINUTES",
    "type" : "int",
    "comment" : "\n     * Constant used to specify formatting of a latitude or longitude in the form \"[+-]DDD:MM.MMMMM\"\n     * where D indicates degrees and M indicates minutes of arc (1 minute = 1/60th of a degree).\n     ",
    "links" : [ ]
  }, {
    "name" : "FORMAT_SECONDS",
    "type" : "int",
    "comment" : "\n     * Constant used to specify formatting of a latitude or longitude in the form \"DDD:MM:SS.SSSSS\"\n     * where D indicates degrees, M indicates minutes of arc, and S indicates seconds of arc (1\n     * minute = 1/60th of a degree, 1 second = 1/3600th of a degree).\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_NO_GPS_LOCATION",
    "type" : "String",
    "comment" : "\n     * Bundle key for a version of the location containing no GPS data.\n     *\n     * @hide\n     * @deprecated As of Android R, this extra is longer in use, since it is not necessary to keep\n     * gps locations separate from other locations for coarsening. Providers that do not need to\n     * support platforms below Android R should not use this constant.\n     ",
    "links" : [ ]
  }, {
    "name" : "HAS_ALTITUDE_MASK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAS_SPEED_MASK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAS_BEARING_MASK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAS_HORIZONTAL_ACCURACY_MASK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAS_MOCK_PROVIDER_MASK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAS_ALTITUDE_ACCURACY_MASK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAS_SPEED_ACCURACY_MASK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAS_BEARING_ACCURACY_MASK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAS_ELAPSED_REALTIME_UNCERTAINTY_MASK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAS_MSL_ALTITUDE_MASK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "HAS_MSL_ALTITUDE_ACCURACY_MASK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sBearingDistanceCache",
    "type" : "ThreadLocal<BearingDistanceCache>",
    "comment" : " on the same thread for caching purposes.",
    "links" : [ ]
  }, {
    "name" : "mFieldsMask",
    "type" : "int",
    "comment" : " A bitmask of fields present in this object (see HAS_* constants defined above).",
    "links" : [ ]
  }, {
    "name" : "mProvider",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTimeMs",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mElapsedRealtimeNs",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mElapsedRealtimeUncertaintyNs",
    "type" : "double",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLatitudeDegrees",
    "type" : "double",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLongitudeDegrees",
    "type" : "double",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHorizontalAccuracyMeters",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAltitudeMeters",
    "type" : "double",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAltitudeAccuracyMeters",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSpeedMetersPerSecond",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSpeedAccuracyMetersPerSecond",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBearingDegrees",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBearingAccuracyDegrees",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMslAltitudeMeters",
    "type" : "double",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMslAltitudeAccuracyMeters",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mExtras",
    "type" : "Bundle",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CREATOR",
    "type" : "Parcelable.Creator<Location>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public void set(@NonNull Location location)",
    "returnType" : "void",
    "comment" : "\n     * Turns this location into a copy of the given location.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void reset()",
    "returnType" : "void",
    "comment" : "\n     * Sets the provider to null, removes all optional fields, and sets the values of all other\n     * fields to zero.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float distanceTo(@NonNull Location dest)",
    "returnType" : "float",
    "comment" : "\n     * Returns the approximate distance in meters between this location and the given location.\n     * Distance is defined using the WGS84 ellipsoid.\n     *\n     * @param dest the destination location\n     * @return the approximate distance in meters\n     ",
    "links" : [ ]
  }, {
    "name" : "public float bearingTo(@NonNull Location dest)",
    "returnType" : "float",
    "comment" : "\n     * Returns the approximate initial bearing in degrees east of true north when traveling along\n     * the shortest path between this location and the given location. The shortest path is defined\n     * using the WGS84 ellipsoid. Locations that are (nearly) antipodal may produce meaningless\n     * results.\n     *\n     * @param dest the destination location\n     * @return the initial bearing in degrees\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getProvider()",
    "returnType" : "String",
    "comment" : "\n     * Returns the name of the provider associated with this location.\n     *\n     * @return the name of the provider\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setProvider(@Nullable String provider)",
    "returnType" : "void",
    "comment" : "\n     * Sets the name of the provider associated with this location\n     *\n     * @param provider the name of the provider\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getTime()",
    "returnType" : "long",
    "comment" : "\n     * Returns the Unix epoch time of this location fix, in milliseconds since the start of the Unix\n     * epoch (00:00:00 January 1, 1970 UTC).\n     *\n     * <p>There is no guarantee that different locations have times set from the same clock.\n     * Locations derived from the {@link LocationManager#GPS_PROVIDER} are guaranteed to have their\n     * time originate from the clock in use by the satellite constellation that provided the fix.\n     * Locations derived from other providers may use any clock to set their time, though it is most\n     * common to use the device's Unix epoch time system clock (which may be incorrect).\n     *\n     * <p>Note that the device's Unix epoch time system clock is not monotonic; it can jump forwards\n     * or backwards unpredictably and may be changed at any time by the user, so this time should\n     * not be used to order or compare locations. Prefer {@link #getElapsedRealtimeNanos} for that\n     * purpose, as the elapsed realtime clock is guaranteed to be monotonic.\n     *\n     * <p>On the other hand, this method may be useful for presenting a human-readable time to the\n     * user, or as a heuristic for comparing location fixes across reboot or across devices.\n     *\n     * <p>All locations generated by the {@link LocationManager} are guaranteed to have this time\n     * set, however remember that the device's system clock may have changed since the location was\n     * generated.\n     *\n     * @return the Unix epoch time of this location\n     ",
    "links" : [ "#getElapsedRealtimeNanos", "android.location.LocationManager#GPS_PROVIDER", "android.location.LocationManager" ]
  }, {
    "name" : "public void setTime(@IntRange(from = 0) long timeMs)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Unix epoch time of this location fix, in milliseconds since the start of the Unix\n     * epoch (00:00:00 January 1 1970 UTC).\n     *\n     * @param timeMs the Unix epoch time of this location\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getElapsedRealtimeNanos()",
    "returnType" : "long",
    "comment" : "\n     * Return the time of this fix in nanoseconds of elapsed realtime since system boot.\n     *\n     * <p>This value can be compared with {@link android.os.SystemClock#elapsedRealtimeNanos} to\n     * reliably order or compare locations. This is reliable because elapsed realtime is guaranteed\n     * to be monotonic and continues to increment even when the system is in deep sleep (unlike\n     * {@link #getTime}). However, since elapsed realtime is with reference to system boot, it does\n     * not make sense to use this value to order or compare locations across boot cycles or devices.\n     *\n     * <p>All locations generated by the {@link LocationManager} are guaranteed to have a valid\n     * elapsed realtime set.\n     *\n     * @return elapsed realtime of this location in nanoseconds\n     ",
    "links" : [ "android.os.SystemClock#elapsedRealtimeNanos", "android.location.LocationManager", "#getTime" ]
  }, {
    "name" : "public long getElapsedRealtimeMillis()",
    "returnType" : "long",
    "comment" : "\n     * Return the time of this fix in milliseconds of elapsed realtime since system boot.\n     *\n     * @return elapsed realtime of this location in milliseconds\n     * @see #getElapsedRealtimeNanos()\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getElapsedRealtimeAgeMillis()",
    "returnType" : "long",
    "comment" : "\n     * A convenience methods that returns the age of this location in milliseconds with respect to\n     * the current elapsed realtime.\n     *\n     * @return age of this location in milliseconds\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getElapsedRealtimeAgeMillis(@IntRange(from = 0) long referenceRealtimeMs)",
    "returnType" : "long",
    "comment" : "\n     * A convenience method that returns the age of this location with respect to the given\n     * reference elapsed realtime.\n     *\n     * @param referenceRealtimeMs reference realtime in milliseconds\n     * @return age of this location in milliseconds\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setElapsedRealtimeNanos(@IntRange(from = 0) long elapsedRealtimeNs)",
    "returnType" : "void",
    "comment" : "\n     * Set the time of this location in nanoseconds of elapsed realtime since system boot.\n     *\n     * @param elapsedRealtimeNs elapsed realtime in nanoseconds\n     ",
    "links" : [ ]
  }, {
    "name" : "public double getElapsedRealtimeUncertaintyNanos()",
    "returnType" : "double",
    "comment" : "\n     * Get the uncertainty in nanoseconds of the precision of {@link #getElapsedRealtimeNanos()} at\n     * the 68th percentile confidence level. This means that there is 68% chance that the true\n     * elapsed realtime of this location is within {@link #getElapsedRealtimeNanos()} +/- this\n     * uncertainty.\n     *\n     * <p>This is only valid if {@link #hasElapsedRealtimeUncertaintyNanos()} is true.\n     *\n     * @return uncertainty in nanoseconds of the elapsed realtime of this location\n     ",
    "links" : [ "#getElapsedRealtimeNanos()", "#hasElapsedRealtimeUncertaintyNanos()" ]
  }, {
    "name" : "public void setElapsedRealtimeUncertaintyNanos(@FloatRange(from = 0.0) double elapsedRealtimeUncertaintyNs)",
    "returnType" : "void",
    "comment" : "\n     * Sets the uncertainty in nanoseconds of the precision of the elapsed realtime timestamp at a\n     * 68% confidence level.\n     *\n     * @param elapsedRealtimeUncertaintyNs uncertainty in nanoseconds of the elapsed realtime of\n     *                                     this location\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasElapsedRealtimeUncertaintyNanos()",
    "returnType" : "boolean",
    "comment" : "\n     * True if this location has an elapsed realtime uncertainty, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeElapsedRealtimeUncertaintyNanos()",
    "returnType" : "void",
    "comment" : "\n     * Removes the elapsed realtime uncertainty from this location.\n     ",
    "links" : [ ]
  }, {
    "name" : "public double getLatitude()",
    "returnType" : "double",
    "comment" : "\n     * Get the latitude in degrees. All locations generated by the {@link LocationManager} will have\n     * a valid latitude.\n     *\n     * @return latitude of this location\n     ",
    "links" : [ "android.location.LocationManager" ]
  }, {
    "name" : "public void setLatitude(@FloatRange(from = -90.0, to = 90.0) double latitudeDegrees)",
    "returnType" : "void",
    "comment" : "\n     * Set the latitude of this location.\n     *\n     * @param latitudeDegrees latitude in degrees\n     ",
    "links" : [ ]
  }, {
    "name" : "public double getLongitude()",
    "returnType" : "double",
    "comment" : "\n     * Get the longitude in degrees. All locations generated by the {@link LocationManager} will\n     * have a valid longitude.\n     *\n     * @return longitude of this location\n     ",
    "links" : [ "android.location.LocationManager" ]
  }, {
    "name" : "public void setLongitude(@FloatRange(from = -180.0, to = 180.0) double longitudeDegrees)",
    "returnType" : "void",
    "comment" : "\n     * Set the longitude of this location.\n     *\n     * @param longitudeDegrees longitude in degrees\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getAccuracy()",
    "returnType" : "float",
    "comment" : "\n     * Returns the estimated horizontal accuracy radius in meters of this location at the 68th\n     * percentile confidence level. This means that there is a 68% chance that the true location of\n     * the device is within a distance of this uncertainty of the reported location. Another way of\n     * putting this is that if a circle with a radius equal to this accuracy is drawn around the\n     * reported location, there is a 68% chance that the true location falls within this circle.\n     * This accuracy value is only valid for horizontal positioning, and not vertical positioning.\n     *\n     * <p>This is only valid if {@link #hasAccuracy()} is true. All locations generated by the\n     * {@link LocationManager} include horizontal accuracy.\n     *\n     * @return horizontal accuracy of this location\n     ",
    "links" : [ "#hasAccuracy()", "android.location.LocationManager" ]
  }, {
    "name" : "public void setAccuracy(@FloatRange(from = 0.0) float horizontalAccuracyMeters)",
    "returnType" : "void",
    "comment" : "\n     * Set the horizontal accuracy in meters of this location.\n     *\n     * @param horizontalAccuracyMeters horizontal altitude in meters\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasAccuracy()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if this location has a horizontal accuracy, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeAccuracy()",
    "returnType" : "void",
    "comment" : "\n     * Remove the horizontal accuracy from this location.\n     ",
    "links" : [ ]
  }, {
    "name" : "public double getAltitude()",
    "returnType" : "double",
    "comment" : "\n     * The altitude of this location in meters above the WGS84 reference ellipsoid.\n     *\n     * <p>This is only valid if {@link #hasAltitude()} is true.\n     *\n     * @return altitude of this location\n     ",
    "links" : [ "#hasAltitude()" ]
  }, {
    "name" : "public void setAltitude(@FloatRange double altitudeMeters)",
    "returnType" : "void",
    "comment" : "\n     * Set the altitude of this location in meters above the WGS84 reference ellipsoid.\n     *\n     * @param altitudeMeters altitude in meters\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasAltitude()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if this location has an altitude, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeAltitude()",
    "returnType" : "void",
    "comment" : "\n     * Removes the altitude from this location.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getVerticalAccuracyMeters()",
    "returnType" : "float",
    "comment" : "\n     * Returns the estimated altitude accuracy in meters of this location at the 68th percentile\n     * confidence level. This means that there is 68% chance that the true altitude of this location\n     * falls within {@link #getAltitude()} ()} +/- this uncertainty.\n     *\n     * <p>This is only valid if {@link #hasVerticalAccuracy()} is true.\n     *\n     * @return vertical accuracy of this location\n     ",
    "links" : [ "#hasVerticalAccuracy()", "#getAltitude()" ]
  }, {
    "name" : "public void setVerticalAccuracyMeters(@FloatRange(from = 0.0) float altitudeAccuracyMeters)",
    "returnType" : "void",
    "comment" : "\n     * Set the altitude accuracy of this location in meters.\n     *\n     * @param altitudeAccuracyMeters altitude accuracy in meters\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasVerticalAccuracy()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if this location has a vertical accuracy, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeVerticalAccuracy()",
    "returnType" : "void",
    "comment" : "\n     * Remove the vertical accuracy from this location.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getSpeed()",
    "returnType" : "float",
    "comment" : "\n     * Returns the speed at the time of this location in meters per second. Note that the speed\n     * returned here may be more accurate than would be obtained simply by calculating\n     * {@code distance / time} for sequential positions, such as if the Doppler measurements from\n     * GNSS satellites are taken into account.\n     *\n     * <p>This is only valid if {@link #hasSpeed()} is true.\n     *\n     * @return speed at the time of this location\n     ",
    "links" : [ "#hasSpeed()" ]
  }, {
    "name" : "public void setSpeed(@FloatRange(from = 0.0) float speedMetersPerSecond)",
    "returnType" : "void",
    "comment" : "\n     * Set the speed at the time of this location, in meters per second.\n     *\n     * @param speedMetersPerSecond speed in meters per second\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasSpeed()",
    "returnType" : "boolean",
    "comment" : "\n     * True if this location has a speed, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeSpeed()",
    "returnType" : "void",
    "comment" : "\n     * Remove the speed from this location.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getSpeedAccuracyMetersPerSecond()",
    "returnType" : "float",
    "comment" : "\n     * Returns the estimated speed accuracy in meters per second of this location at the 68th\n     * percentile confidence level. This means that there is 68% chance that the true speed at the\n     * time of this location falls within {@link #getSpeed()} ()} +/- this uncertainty.\n     *\n     * <p>This is only valid if {@link #hasSpeedAccuracy()} is true.\n     *\n     * @return vertical accuracy of this location\n     ",
    "links" : [ "#getSpeed()", "#hasSpeedAccuracy()" ]
  }, {
    "name" : "public void setSpeedAccuracyMetersPerSecond(@FloatRange(from = 0.0) float speedAccuracyMeterPerSecond)",
    "returnType" : "void",
    "comment" : "\n     * Set the speed accuracy of this location in meters per second.\n     *\n     * @param speedAccuracyMeterPerSecond speed accuracy in meters per second\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasSpeedAccuracy()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if this location has a speed accuracy, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeSpeedAccuracy()",
    "returnType" : "void",
    "comment" : "\n     * Remove the speed accuracy from this location.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getBearing()",
    "returnType" : "float",
    "comment" : "\n     * Returns the bearing at the time of this location in degrees. Bearing is the horizontal\n     * direction of travel of this device and is unrelated to the device orientation. The bearing\n     * is guaranteed to be in the range [0, 360).\n     *\n     * <p>This is only valid if {@link #hasBearing()} is true.\n     *\n     * @return bearing at the time of this location\n     ",
    "links" : [ "#hasBearing()" ]
  }, {
    "name" : "public void setBearing(@FloatRange(fromInclusive = false, toInclusive = false) float bearingDegrees)",
    "returnType" : "void",
    "comment" : "\n     * Set the bearing at the time of this location, in degrees. The given bearing will be converted\n     * into the range [0, 360).\n     *\n     * <p class=\"note\">Note: passing in extremely high or low floating point values to this function\n     * may produce strange results due to the intricacies of floating point math.\n     *\n     * @param bearingDegrees bearing in degrees\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasBearing()",
    "returnType" : "boolean",
    "comment" : "\n     * True if this location has a bearing, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeBearing()",
    "returnType" : "void",
    "comment" : "\n     * Remove the bearing from this location.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getBearingAccuracyDegrees()",
    "returnType" : "float",
    "comment" : "\n     * Returns the estimated bearing accuracy in degrees of this location at the 68th percentile\n     * confidence level. This means that there is 68% chance that the true bearing at the\n     * time of this location falls within {@link #getBearing()} ()} +/- this uncertainty.\n     *\n     * <p>This is only valid if {@link #hasBearingAccuracy()} ()} is true.\n     *\n     * @return bearing accuracy in degrees of this location\n     ",
    "links" : [ "#getBearing()", "#hasBearingAccuracy()" ]
  }, {
    "name" : "public void setBearingAccuracyDegrees(@FloatRange(from = 0.0) float bearingAccuracyDegrees)",
    "returnType" : "void",
    "comment" : "\n     * Set the bearing accuracy in degrees of this location.\n     *\n     * @param bearingAccuracyDegrees bearing accuracy in degrees\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasBearingAccuracy()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if this location has a bearing accuracy, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeBearingAccuracy()",
    "returnType" : "void",
    "comment" : "\n     * Remove the bearing accuracy from this location.\n     ",
    "links" : [ ]
  }, {
    "name" : "public double getMslAltitudeMeters()",
    "returnType" : "double",
    "comment" : "\n     * Returns the Mean Sea Level altitude of this location in meters.\n     *\n     * <p>This is only valid if {@link #hasMslAltitude()} is true.\n     ",
    "links" : [ "#hasMslAltitude()" ]
  }, {
    "name" : "public void setMslAltitudeMeters(@FloatRange double mslAltitudeMeters)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Mean Sea Level altitude of this location in meters.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasMslAltitude()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if this location has a Mean Sea Level altitude, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeMslAltitude()",
    "returnType" : "void",
    "comment" : "\n     * Removes the Mean Sea Level altitude from this location.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getMslAltitudeAccuracyMeters()",
    "returnType" : "float",
    "comment" : "\n     * Returns the estimated Mean Sea Level altitude accuracy in meters of this location at the 68th\n     * percentile confidence level. This means that there is 68% chance that the true Mean Sea Level\n     * altitude of this location falls within {@link #getMslAltitudeMeters()} +/- this uncertainty.\n     *\n     * <p>This is only valid if {@link #hasMslAltitudeAccuracy()} is true.\n     ",
    "links" : [ "#getMslAltitudeMeters()", "#hasMslAltitudeAccuracy()" ]
  }, {
    "name" : "public void setMslAltitudeAccuracyMeters(@FloatRange(from = 0.0) float mslAltitudeAccuracyMeters)",
    "returnType" : "void",
    "comment" : "\n     * Sets the Mean Sea Level altitude accuracy of this location in meters.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasMslAltitudeAccuracy()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if this location has a Mean Sea Level altitude accuracy, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeMslAltitudeAccuracy()",
    "returnType" : "void",
    "comment" : "\n     * Removes the Mean Sea Level altitude accuracy from this location.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isFromMockProvider()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if this is a mock location. If this location comes from the Android framework,\n     * this indicates that the location was provided by a test location provider, and thus may not\n     * be related to the actual location of the device.\n     *\n     * @return true if this location came from a mock provider, false otherwise\n     * @deprecated Prefer {@link #isMock()} instead.\n     ",
    "links" : [ "#isMock()" ]
  }, {
    "name" : "public void setIsFromMockProvider(boolean isFromMockProvider)",
    "returnType" : "void",
    "comment" : "\n     * Flag this location as having come from a mock provider or not.\n     *\n     * @param isFromMockProvider true if this location came from a mock provider, false otherwise\n     * @deprecated Prefer {@link #setMock(boolean)} instead.\n     * @hide\n     ",
    "links" : [ "#setMock(boolean)" ]
  }, {
    "name" : "public boolean isMock()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if this location is marked as a mock location. If this location comes from the\n     * Android framework, this indicates that the location was provided by a test location provider,\n     * and thus may not be related to the actual location of the device.\n     *\n     * @see LocationManager#addTestProvider\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setMock(boolean mock)",
    "returnType" : "void",
    "comment" : "\n     * Sets whether this location is marked as a mock location.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Bundle getExtras()",
    "returnType" : "Bundle",
    "comment" : "\n     * Returns an optional bundle of additional information associated with this location. The keys\n     * and values within the bundle are determined by the location provider.\n     *\n     * <p> Common key/value pairs are listed below. There is no guarantee that these key/value pairs\n     * will be present for any location.\n     *\n     * <ul>\n     * <li> satellites - the number of satellites used to derive a GNSS fix. This key was deprecated\n     * in API 34 because the information can be obtained through more accurate means, such as by\n     * referencing {@link GnssStatus#usedInFix}.\n     * </ul>\n     ",
    "links" : [ "android.location.GnssStatus#usedInFix" ]
  }, {
    "name" : "public void setExtras(@Nullable Bundle extras)",
    "returnType" : "void",
    "comment" : "\n     * Sets the extra information associated with this fix to the given Bundle.\n     *\n     * <p>Note this stores a copy of the given extras, so any changes to extras after calling this\n     * method won't be reflected in the location bundle.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isComplete()",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if this location is considered complete. A location is considered complete if it\n     * has a non-null provider, accuracy, and non-zero time and elapsed realtime. The exact\n     * definition of completeness may change over time.\n     *\n     * <p>All locations supplied by the {@link LocationManager} are guaranteed to be complete.\n     ",
    "links" : [ "android.location.LocationManager" ]
  }, {
    "name" : "public void makeComplete()",
    "returnType" : "void",
    "comment" : "\n     * Helper to fill incomplete fields with valid (but likely nonsensical) values.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean equals(@Nullable Object o)",
    "returnType" : "boolean",
    "comment" : "\n     * Location equality is provided primarily for test purposes. Comparing locations for equality\n     * in production may indicate incorrect assumptions, and should be avoided whenever possible.\n     *\n     * <p>{@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean areExtrasEqual(@Nullable Bundle extras1, @Nullable Bundle extras2)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int hashCode()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dump(@NonNull Printer pw, @Nullable String prefix)",
    "returnType" : "void",
    "comment" : "\n     * Dumps location information to the given Printer.\n     *\n     * @deprecated Prefer to use {@link #toString()} along with whatever custom formatting is\n     * required instead of this method. It is not this class's job to manage print representations.\n     ",
    "links" : [ "#toString()" ]
  }, {
    "name" : "public int describeContents()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void writeToParcel(@NonNull Parcel parcel, int flags)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static String convert(@FloatRange double coordinate, @Format int outputType)",
    "returnType" : "String",
    "comment" : "\n     * Converts a latitude/longitude coordinate to a String representation. The outputType must be\n     * one of {@link #FORMAT_DEGREES}, {@link #FORMAT_MINUTES}, or {@link #FORMAT_SECONDS}. The\n     * coordinate must be a number between -180.0 and 180.0, inclusive. This conversion is performed\n     * in a method that is dependent on the default locale, and so is not guaranteed to round-trip\n     * with {@link #convert(String)}.\n     *\n     * @throws IllegalArgumentException if coordinate is less than -180.0, greater than 180.0, or is\n     *                                  not a number.\n     * @throws IllegalArgumentException if outputType is not a recognized value.\n     ",
    "links" : [ "#FORMAT_DEGREES", "#convert(String)", "#FORMAT_MINUTES", "#FORMAT_SECONDS" ]
  }, {
    "name" : "public static double convert(@NonNull String coordinate)",
    "returnType" : "double",
    "comment" : "\n     * Converts a String in one of the formats described by {@link #FORMAT_DEGREES},\n     * {@link #FORMAT_MINUTES}, or {@link #FORMAT_SECONDS} into a double. This conversion is\n     * performed in a locale agnostic method, and so is not guaranteed to round-trip with\n     * {@link #convert(double, int)}.\n     *\n     * @throws NullPointerException if coordinate is null\n     * @throws IllegalArgumentException if the coordinate is not\n     * in one of the valid formats.\n     ",
    "links" : [ "#FORMAT_DEGREES", "#convert(double", "#FORMAT_MINUTES", "#FORMAT_SECONDS" ]
  }, {
    "name" : "private static void computeDistanceAndBearing(double lat1, double lon1, double lat2, double lon2, BearingDistanceCache results)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static void distanceBetween(@FloatRange(from = -90.0, to = 90.0) double startLatitude, @FloatRange(from = -180.0, to = 180.0) double startLongitude, @FloatRange(from = -90.0, to = 90.0) double endLatitude, @FloatRange(from = -180.0, to = 180.0) double endLongitude, float[] results)",
    "returnType" : "void",
    "comment" : "\n     * Computes the approximate distance in meters between two\n     * locations, and optionally the initial and final bearings of the\n     * shortest path between them.  Distance and bearing are defined using the\n     * WGS84 ellipsoid.\n     *\n     * <p> The computed distance is stored in results[0].  If results has length\n     * 2 or greater, the initial bearing is stored in results[1]. If results has\n     * length 3 or greater, the final bearing is stored in results[2].\n     *\n     * @param startLatitude the starting latitude\n     * @param startLongitude the starting longitude\n     * @param endLatitude the ending latitude\n     * @param endLongitude the ending longitude\n     * @param results an array of floats to hold the results\n     *\n     * @throws IllegalArgumentException if results is null or has length < 1\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public void set(@NonNull Location location)", "public void reset()", "public float distanceTo(@NonNull Location dest)", "public float bearingTo(@NonNull Location dest)", "public String getProvider()", "public void setProvider(@Nullable String provider)", "public long getTime()", "public void setTime(@IntRange(from = 0) long timeMs)", "public long getElapsedRealtimeNanos()", "public long getElapsedRealtimeMillis()", "public long getElapsedRealtimeAgeMillis()", "public long getElapsedRealtimeAgeMillis(@IntRange(from = 0) long referenceRealtimeMs)", "public void setElapsedRealtimeNanos(@IntRange(from = 0) long elapsedRealtimeNs)", "public double getElapsedRealtimeUncertaintyNanos()", "public void setElapsedRealtimeUncertaintyNanos(@FloatRange(from = 0.0) double elapsedRealtimeUncertaintyNs)", "public boolean hasElapsedRealtimeUncertaintyNanos()", "public void removeElapsedRealtimeUncertaintyNanos()", "public double getLatitude()", "public void setLatitude(@FloatRange(from = -90.0, to = 90.0) double latitudeDegrees)", "public double getLongitude()", "public void setLongitude(@FloatRange(from = -180.0, to = 180.0) double longitudeDegrees)", "public float getAccuracy()", "public void setAccuracy(@FloatRange(from = 0.0) float horizontalAccuracyMeters)", "public boolean hasAccuracy()", "public void removeAccuracy()", "public double getAltitude()", "public void setAltitude(@FloatRange double altitudeMeters)", "public boolean hasAltitude()", "public void removeAltitude()", "public float getVerticalAccuracyMeters()", "public void setVerticalAccuracyMeters(@FloatRange(from = 0.0) float altitudeAccuracyMeters)", "public boolean hasVerticalAccuracy()", "public void removeVerticalAccuracy()", "public float getSpeed()", "public void setSpeed(@FloatRange(from = 0.0) float speedMetersPerSecond)", "public boolean hasSpeed()", "public void removeSpeed()", "public float getSpeedAccuracyMetersPerSecond()", "public void setSpeedAccuracyMetersPerSecond(@FloatRange(from = 0.0) float speedAccuracyMeterPerSecond)", "public boolean hasSpeedAccuracy()", "public void removeSpeedAccuracy()", "public float getBearing()", "public void setBearing(@FloatRange(fromInclusive = false, toInclusive = false) float bearingDegrees)", "public boolean hasBearing()", "public void removeBearing()", "public float getBearingAccuracyDegrees()", "public void setBearingAccuracyDegrees(@FloatRange(from = 0.0) float bearingAccuracyDegrees)", "public boolean hasBearingAccuracy()", "public void removeBearingAccuracy()", "public double getMslAltitudeMeters()", "public void setMslAltitudeMeters(@FloatRange double mslAltitudeMeters)", "public boolean hasMslAltitude()", "public void removeMslAltitude()", "public float getMslAltitudeAccuracyMeters()", "public void setMslAltitudeAccuracyMeters(@FloatRange(from = 0.0) float mslAltitudeAccuracyMeters)", "public boolean hasMslAltitudeAccuracy()", "public void removeMslAltitudeAccuracy()", "public boolean isFromMockProvider()", "public void setIsFromMockProvider(boolean isFromMockProvider)", "public boolean isMock()", "public void setMock(boolean mock)", "public Bundle getExtras()", "public void setExtras(@Nullable Bundle extras)", "public boolean isComplete()", "public void makeComplete()", "public boolean equals(@Nullable Object o)", "private static boolean areExtrasEqual(@Nullable Bundle extras1, @Nullable Bundle extras2)", "public int hashCode()", "public String toString()", "public void dump(@NonNull Printer pw, @Nullable String prefix)", "public int describeContents()", "public void writeToParcel(@NonNull Parcel parcel, int flags)", "public static String convert(@FloatRange double coordinate, @Format int outputType)", "public static double convert(@NonNull String coordinate)", "private static void computeDistanceAndBearing(double lat1, double lon1, double lat2, double lon2, BearingDistanceCache results)", "public static void distanceBetween(@FloatRange(from = -90.0, to = 90.0) double startLatitude, @FloatRange(from = -180.0, to = 180.0) double startLongitude, @FloatRange(from = -90.0, to = 90.0) double endLatitude, @FloatRange(from = -180.0, to = 180.0) double endLongitude, float[] results)" ],
  "variableNames" : [ "FORMAT_DEGREES", "FORMAT_MINUTES", "FORMAT_SECONDS", "EXTRA_NO_GPS_LOCATION", "HAS_ALTITUDE_MASK", "HAS_SPEED_MASK", "HAS_BEARING_MASK", "HAS_HORIZONTAL_ACCURACY_MASK", "HAS_MOCK_PROVIDER_MASK", "HAS_ALTITUDE_ACCURACY_MASK", "HAS_SPEED_ACCURACY_MASK", "HAS_BEARING_ACCURACY_MASK", "HAS_ELAPSED_REALTIME_UNCERTAINTY_MASK", "HAS_MSL_ALTITUDE_MASK", "HAS_MSL_ALTITUDE_ACCURACY_MASK", "sBearingDistanceCache", "mFieldsMask", "mProvider", "mTimeMs", "mElapsedRealtimeNs", "mElapsedRealtimeUncertaintyNs", "mLatitudeDegrees", "mLongitudeDegrees", "mHorizontalAccuracyMeters", "mAltitudeMeters", "mAltitudeAccuracyMeters", "mSpeedMetersPerSecond", "mSpeedAccuracyMetersPerSecond", "mBearingDegrees", "mBearingAccuracyDegrees", "mMslAltitudeMeters", "mMslAltitudeAccuracyMeters", "mExtras", "CREATOR" ]
}