{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/sql/SQLXML.java",
  "packageName" : "java.sql",
  "className" : "SQLXML",
  "comment" : "\n * The mapping in the JavaTM programming language for the SQL XML type.\n * XML is a built-in type that stores an XML value\n * as a column value in a row of a database table.\n * By default drivers implement an SQLXML object as\n * a logical pointer to the XML data\n * rather than the data itself.\n * An SQLXML object is valid for the duration of the transaction in which it was created.\n * <p>\n * The SQLXML interface provides methods for accessing the XML value\n * as a String, a Reader or Writer, or as a Stream.  The XML value\n * may also be accessed through a Source or set as a Result, which\n * are used with XML Parser APIs such as DOM, SAX, and StAX, as\n * well as with XSLT transforms and XPath evaluations.\n * <p>\n * Methods in the interfaces ResultSet, CallableStatement, and PreparedStatement,\n * such as getSQLXML allow a programmer to access an XML value.\n * In addition, this interface has methods for updating an XML value.\n * <p>\n * The XML value of the SQLXML instance may be obtained as a BinaryStream using\n * <pre>\n *   SQLXML sqlxml = resultSet.getSQLXML(column);\n *   InputStream binaryStream = sqlxml.getBinaryStream();\n * </pre>\n * For example, to parse an XML value with a DOM parser:\n * <pre>\n *   DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n *   Document result = parser.parse(binaryStream);\n * </pre>\n * or to parse an XML value with a SAX parser to your handler:\n * <pre>\n *   SAXParser parser = SAXParserFactory.newInstance().newSAXParser();\n *   parser.parse(binaryStream, myHandler);\n * </pre>\n * or to parse an XML value with a StAX parser:\n * <pre>\n *   XMLInputFactory factory = XMLInputFactory.newInstance();\n *   XMLStreamReader streamReader = factory.createXMLStreamReader(binaryStream);\n * </pre>\n * <p>\n * Because databases may use an optimized representation for the XML,\n * accessing the value through getSource() and\n * setResult() can lead to improved processing performance\n * without serializing to a stream representation and parsing the XML.\n * <p>\n * For example, to obtain a DOM Document Node:\n * <pre>\n *   DOMSource domSource = sqlxml.getSource(DOMSource.class);\n *   Document document = (Document) domSource.getNode();\n * </pre>\n * or to set the value to a DOM Document Node to myNode:\n * <pre>\n *   DOMResult domResult = sqlxml.setResult(DOMResult.class);\n *   domResult.setNode(myNode);\n * </pre>\n * or, to send SAX events to your handler:\n * <pre>\n *   SAXSource saxSource = sqlxml.getSource(SAXSource.class);\n *   XMLReader xmlReader = saxSource.getXMLReader();\n *   xmlReader.setContentHandler(myHandler);\n *   xmlReader.parse(saxSource.getInputSource());\n * </pre>\n * or, to set the result value from SAX events:\n * <pre>\n *   SAXResult saxResult = sqlxml.setResult(SAXResult.class);\n *   ContentHandler contentHandler = saxResult.getXMLReader().getContentHandler();\n *   contentHandler.startDocument();\n *   // set the XML elements and attributes into the result\n *   contentHandler.endDocument();\n * </pre>\n * or, to obtain StAX events:\n * <pre>\n *   StAXSource staxSource = sqlxml.getSource(StAXSource.class);\n *   XMLStreamReader streamReader = staxSource.getXMLStreamReader();\n * </pre>\n * or, to set the result value from StAX events:\n * <pre>\n *   StAXResult staxResult = sqlxml.setResult(StAXResult.class);\n *   XMLStreamWriter streamWriter = staxResult.getXMLStreamWriter();\n * </pre>\n * or, to perform XSLT transformations on the XML value using the XSLT in xsltFile\n * output to file resultFile:\n * <pre>\n *   File xsltFile = new File(\"a.xslt\");\n *   File myFile = new File(\"result.xml\");\n *   Transformer xslt = TransformerFactory.newInstance().newTransformer(new StreamSource(xsltFile));\n *   Source source = sqlxml.getSource(null);\n *   Result result = new StreamResult(myFile);\n *   xslt.transform(source, result);\n * </pre>\n * or, to evaluate an XPath expression on the XML value:\n * <pre>\n *   XPath xpath = XPathFactory.newInstance().newXPath();\n *   DOMSource domSource = sqlxml.getSource(DOMSource.class);\n *   Document document = (Document) domSource.getNode();\n *   String expression = \"/foo/@bar\";\n *   String barValue = xpath.evaluate(expression, document);\n * </pre>\n * To set the XML value to be the result of an XSLT transform:\n * <pre>\n *   File sourceFile = new File(\"source.xml\");\n *   Transformer xslt = TransformerFactory.newInstance().newTransformer(new StreamSource(xsltFile));\n *   Source streamSource = new StreamSource(sourceFile);\n *   Result result = sqlxml.setResult(null);\n *   xslt.transform(streamSource, result);\n * </pre>\n * Any Source can be transformed to a Result using the identity transform\n * specified by calling newTransformer():\n * <pre>\n *   Transformer identity = TransformerFactory.newInstance().newTransformer();\n *   Source source = sqlxml.getSource(null);\n *   File myFile = new File(\"result.xml\");\n *   Result result = new StreamResult(myFile);\n *   identity.transform(source, result);\n * </pre>\n * To write the contents of a Source to standard output:\n * <pre>\n *   Transformer identity = TransformerFactory.newInstance().newTransformer();\n *   Source source = sqlxml.getSource(null);\n *   Result result = new StreamResult(System.out);\n *   identity.transform(source, result);\n * </pre>\n * To create a DOMSource from a DOMResult:\n * <pre>\n *    DOMSource domSource = new DOMSource(domResult.getNode());\n * </pre>\n * <p>\n * Incomplete or invalid XML values may cause an SQLException when\n * set or the exception may occur when execute() occurs.  All streams\n * must be closed before execute() occurs or an SQLException will be thrown.\n * <p>\n * Reading and writing XML values to or from an SQLXML object can happen at most once.\n * The conceptual states of readable and not readable determine if one\n * of the reading APIs will return a value or throw an exception.\n * The conceptual states of writable and not writable determine if one\n * of the writing APIs will set a value or throw an exception.\n * <p>\n * The state moves from readable to not readable once free() or any of the\n * reading APIs are called: getBinaryStream(), getCharacterStream(), getSource(), and getString().\n * Implementations may also change the state to not writable when this occurs.\n * <p>\n * The state moves from writable to not writeable once free() or any of the\n * writing APIs are called: setBinaryStream(), setCharacterStream(), setResult(), and setString().\n * Implementations may also change the state to not readable when this occurs.\n * <p>\n  * <p>\n * All methods on the <code>SQLXML</code> interface must be fully implemented if the\n * JDBC driver supports the data type.\n *\n * @see javax.xml.parsers\n * @see javax.xml.transform\n * @see javax.xml.xpath\n * @since 1.6\n ",
  "links" : [ ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " void free() throws SQLException",
    "returnType" : "void",
    "comment" : "\n   * This method closes this object and releases the resources that it held.\n   * The SQL XML object becomes invalid and neither readable or writeable\n   * when this method is called.\n   *\n   * After <code>free</code> has been called, any attempt to invoke a\n   * method other than <code>free</code> will result in a <code>SQLException</code>\n   * being thrown.  If <code>free</code> is called multiple times, the subsequent\n   * calls to <code>free</code> are treated as a no-op.\n   * @throws SQLException if there is an error freeing the XML value.\n   * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n   * this method\n   * @since 1.6\n   ",
    "links" : [ ]
  }, {
    "name" : " InputStream getBinaryStream() throws SQLException",
    "returnType" : "InputStream",
    "comment" : "\n   * Retrieves the XML value designated by this SQLXML instance as a stream.\n   * The bytes of the input stream are interpreted according to appendix F of the XML 1.0 specification.\n   * The behavior of this method is the same as ResultSet.getBinaryStream()\n   * when the designated column of the ResultSet has a type java.sql.Types of SQLXML.\n   * <p>\n   * The SQL XML object becomes not readable when this method is called and\n   * may also become not writable depending on implementation.\n   *\n   * @return a stream containing the XML data.\n   * @throws SQLException if there is an error processing the XML value.\n   *   An exception is thrown if the state is not readable.\n   * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n   * this method\n   * @since 1.6\n   ",
    "links" : [ ]
  }, {
    "name" : " OutputStream setBinaryStream() throws SQLException",
    "returnType" : "OutputStream",
    "comment" : "\n   * Retrieves a stream that can be used to write the XML value that this SQLXML instance represents.\n   * The stream begins at position 0.\n   * The bytes of the stream are interpreted according to appendix F of the XML 1.0 specification\n   * The behavior of this method is the same as ResultSet.updateBinaryStream()\n   * when the designated column of the ResultSet has a type java.sql.Types of SQLXML.\n   * <p>\n   * The SQL XML object becomes not writeable when this method is called and\n   * may also become not readable depending on implementation.\n   *\n   * @return a stream to which data can be written.\n   * @throws SQLException if there is an error processing the XML value.\n   *   An exception is thrown if the state is not writable.\n   * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n   * this method\n   * @since 1.6\n   ",
    "links" : [ ]
  }, {
    "name" : " Reader getCharacterStream() throws SQLException",
    "returnType" : "Reader",
    "comment" : "\n   * Retrieves the XML value designated by this SQLXML instance as a java.io.Reader object.\n   * The format of this stream is defined by org.xml.sax.InputSource,\n   * where the characters in the stream represent the unicode code points for\n   * XML according to section 2 and appendix B of the XML 1.0 specification.\n   * Although an encoding declaration other than unicode may be present,\n   * the encoding of the stream is unicode.\n   * The behavior of this method is the same as ResultSet.getCharacterStream()\n   * when the designated column of the ResultSet has a type java.sql.Types of SQLXML.\n   * <p>\n   * The SQL XML object becomes not readable when this method is called and\n   * may also become not writable depending on implementation.\n   *\n   * @return a stream containing the XML data.\n   * @throws SQLException if there is an error processing the XML value.\n   *   The getCause() method of the exception may provide a more detailed exception, for example,\n   *   if the stream does not contain valid characters.\n   *   An exception is thrown if the state is not readable.\n   * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n   * this method\n   * @since 1.6\n   ",
    "links" : [ ]
  }, {
    "name" : " Writer setCharacterStream() throws SQLException",
    "returnType" : "Writer",
    "comment" : "\n   * Retrieves a stream to be used to write the XML value that this SQLXML instance represents.\n   * The format of this stream is defined by org.xml.sax.InputSource,\n   * where the characters in the stream represent the unicode code points for\n   * XML according to section 2 and appendix B of the XML 1.0 specification.\n   * Although an encoding declaration other than unicode may be present,\n   * the encoding of the stream is unicode.\n   * The behavior of this method is the same as ResultSet.updateCharacterStream()\n   * when the designated column of the ResultSet has a type java.sql.Types of SQLXML.\n   * <p>\n   * The SQL XML object becomes not writeable when this method is called and\n   * may also become not readable depending on implementation.\n   *\n   * @return a stream to which data can be written.\n   * @throws SQLException if there is an error processing the XML value.\n   *   The getCause() method of the exception may provide a more detailed exception, for example,\n   *   if the stream does not contain valid characters.\n   *   An exception is thrown if the state is not writable.\n   * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n   * this method\n   * @since 1.6\n   ",
    "links" : [ ]
  }, {
    "name" : " String getString() throws SQLException",
    "returnType" : "String",
    "comment" : "\n   * Returns a string representation of the XML value designated by this SQLXML instance.\n   * The format of this String is defined by org.xml.sax.InputSource,\n   * where the characters in the stream represent the unicode code points for\n   * XML according to section 2 and appendix B of the XML 1.0 specification.\n   * Although an encoding declaration other than unicode may be present,\n   * the encoding of the String is unicode.\n   * The behavior of this method is the same as ResultSet.getString()\n   * when the designated column of the ResultSet has a type java.sql.Types of SQLXML.\n   * <p>\n   * The SQL XML object becomes not readable when this method is called and\n   * may also become not writable depending on implementation.\n   *\n   * @return a string representation of the XML value designated by this SQLXML instance.\n   * @throws SQLException if there is an error processing the XML value.\n   *   The getCause() method of the exception may provide a more detailed exception, for example,\n   *   if the stream does not contain valid characters.\n   *   An exception is thrown if the state is not readable.\n   * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n   * this method\n   * @since 1.6\n   ",
    "links" : [ ]
  }, {
    "name" : " void setString(String value) throws SQLException",
    "returnType" : "void",
    "comment" : "\n   * Sets the XML value designated by this SQLXML instance to the given String representation.\n   * The format of this String is defined by org.xml.sax.InputSource,\n   * where the characters in the stream represent the unicode code points for\n   * XML according to section 2 and appendix B of the XML 1.0 specification.\n   * Although an encoding declaration other than unicode may be present,\n   * the encoding of the String is unicode.\n   * The behavior of this method is the same as ResultSet.updateString()\n   * when the designated column of the ResultSet has a type java.sql.Types of SQLXML.\n   * <p>\n   * The SQL XML object becomes not writeable when this method is called and\n   * may also become not readable depending on implementation.\n   *\n   * @param value the XML value\n   * @throws SQLException if there is an error processing the XML value.\n   *   The getCause() method of the exception may provide a more detailed exception, for example,\n   *   if the stream does not contain valid characters.\n   *   An exception is thrown if the state is not writable.\n   * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n   * this method\n   * @since 1.6\n   ",
    "links" : [ ]
  }, {
    "name" : " T getSource(Class<T> sourceClass) throws SQLException",
    "returnType" : "T",
    "comment" : "\n   * Returns a Source for reading the XML value designated by this SQLXML instance.\n   * Sources are used as inputs to XML parsers and XSLT transformers.\n   * <p>\n   * Sources for XML parsers will have namespace processing on by default.\n   * The systemID of the Source is implementation dependent.\n   * <p>\n   * The SQL XML object becomes not readable when this method is called and\n   * may also become not writable depending on implementation.\n   * <p>\n   * Note that SAX is a callback architecture, so a returned\n   * SAXSource should then be set with a content handler that will\n   * receive the SAX events from parsing.  The content handler\n   * will receive callbacks based on the contents of the XML.\n   * <pre>\n   *   SAXSource saxSource = sqlxml.getSource(SAXSource.class);\n   *   XMLReader xmlReader = saxSource.getXMLReader();\n   *   xmlReader.setContentHandler(myHandler);\n   *   xmlReader.parse(saxSource.getInputSource());\n   * </pre>\n   *\n   * @param sourceClass The class of the source, or null.\n   * If the class is null, a vendor specifc Source implementation will be returned.\n   * The following classes are supported at a minimum:\n   * <pre>\n   *   javax.xml.transform.dom.DOMSource - returns a DOMSource\n   *   javax.xml.transform.sax.SAXSource - returns a SAXSource\n   *   javax.xml.transform.stax.StAXSource - returns a StAXSource\n   *   javax.xml.transform.stream.StreamSource - returns a StreamSource\n   * </pre>\n   * @return a Source for reading the XML value.\n   * @throws SQLException if there is an error processing the XML value\n   *   or if this feature is not supported.\n   *   The getCause() method of the exception may provide a more detailed exception, for example,\n   *   if an XML parser exception occurs.\n   *   An exception is thrown if the state is not readable.\n   * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n   * this method\n   * @since 1.6\n   ",
    "links" : [ ]
  }, {
    "name" : " T setResult(Class<T> resultClass) throws SQLException",
    "returnType" : "T",
    "comment" : "\n   * Returns a Result for setting the XML value designated by this SQLXML instance.\n   * <p>\n   * The systemID of the Result is implementation dependent.\n   * <p>\n   * The SQL XML object becomes not writeable when this method is called and\n   * may also become not readable depending on implementation.\n   * <p>\n   * Note that SAX is a callback architecture and the returned\n   * SAXResult has a content handler assigned that will receive the\n   * SAX events based on the contents of the XML.  Call the content\n   * handler with the contents of the XML document to assign the values.\n   * <pre>\n   *   SAXResult saxResult = sqlxml.setResult(SAXResult.class);\n   *   ContentHandler contentHandler = saxResult.getXMLReader().getContentHandler();\n   *   contentHandler.startDocument();\n   *   // set the XML elements and attributes into the result\n   *   contentHandler.endDocument();\n   * </pre>\n   *\n   * @param resultClass The class of the result, or null.\n   * If resultClass is null, a vendor specific Result implementation will be returned.\n   * The following classes are supported at a minimum:\n   * <pre>\n   *   javax.xml.transform.dom.DOMResult - returns a DOMResult\n   *   javax.xml.transform.sax.SAXResult - returns a SAXResult\n   *   javax.xml.transform.stax.StAXResult - returns a StAXResult\n   *   javax.xml.transform.stream.StreamResult - returns a StreamResult\n   * </pre>\n   * @return Returns a Result for setting the XML value.\n   * @throws SQLException if there is an error processing the XML value\n   *   or if this feature is not supported.\n   *   The getCause() method of the exception may provide a more detailed exception, for example,\n   *   if an XML parser exception occurs.\n   *   An exception is thrown if the state is not writable.\n   * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n   * this method\n   * @since 1.6\n   ",
    "links" : [ ]
  } ],
  "methodNames" : [ " void free() throws SQLException", " InputStream getBinaryStream() throws SQLException", " OutputStream setBinaryStream() throws SQLException", " Reader getCharacterStream() throws SQLException", " Writer setCharacterStream() throws SQLException", " String getString() throws SQLException", " void setString(String value) throws SQLException", " T getSource(Class<T> sourceClass) throws SQLException", " T setResult(Class<T> resultClass) throws SQLException" ],
  "variableNames" : [ ]
}