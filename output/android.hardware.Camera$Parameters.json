{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/hardware/Camera.java",
  "packageName" : "android.hardware",
  "className" : "Parameters",
  "comment" : "\n     * Camera service settings.\n     *\n     * <p>To make camera parameters take effect, applications have to call\n     * {@link Camera#setParameters(Camera.Parameters)}. For example, after\n     * {@link Camera.Parameters#setWhiteBalance} is called, white balance is not\n     * actually changed until {@link Camera#setParameters(Camera.Parameters)}\n     * is called with the changed parameters object.\n     *\n     * <p>Different devices may have different camera capabilities, such as\n     * picture size or flash modes. The application should query the camera\n     * capabilities before setting parameters. For example, the application\n     * should call {@link Camera.Parameters#getSupportedColorEffects()} before\n     * calling {@link Camera.Parameters#setColorEffect(String)}. If the\n     * camera does not support color effects,\n     * {@link Camera.Parameters#getSupportedColorEffects()} will return null.\n     *\n     * @deprecated We recommend using the new {@link android.hardware.camera2} API for new\n     *             applications.\n     ",
  "links" : [ "Camera.Parameters#setWhiteBalance", "android.hardware.Camera#setParameters(Camera.Parameters)", "android.hardware.camera2", "Camera.Parameters#getSupportedColorEffects()", "Camera.Parameters#setColorEffect(String)" ],
  "variables" : [ {
    "name" : "KEY_PREVIEW_SIZE",
    "type" : "String",
    "comment" : " Parameter keys to communicate with the camera driver.",
    "links" : [ ]
  }, {
    "name" : "KEY_PREVIEW_FORMAT",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_PREVIEW_FRAME_RATE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_PREVIEW_FPS_RANGE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_PICTURE_SIZE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_PICTURE_FORMAT",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_JPEG_THUMBNAIL_SIZE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_JPEG_THUMBNAIL_WIDTH",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_JPEG_THUMBNAIL_HEIGHT",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_JPEG_THUMBNAIL_QUALITY",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_JPEG_QUALITY",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_ROTATION",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_GPS_LATITUDE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_GPS_LONGITUDE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_GPS_ALTITUDE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_GPS_TIMESTAMP",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_GPS_PROCESSING_METHOD",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_WHITE_BALANCE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_EFFECT",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_ANTIBANDING",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_SCENE_MODE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_FLASH_MODE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_FOCUS_MODE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_FOCUS_AREAS",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_MAX_NUM_FOCUS_AREAS",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_FOCAL_LENGTH",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_HORIZONTAL_VIEW_ANGLE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_VERTICAL_VIEW_ANGLE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_EXPOSURE_COMPENSATION",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_MAX_EXPOSURE_COMPENSATION",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_MIN_EXPOSURE_COMPENSATION",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_EXPOSURE_COMPENSATION_STEP",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_AUTO_EXPOSURE_LOCK",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_AUTO_EXPOSURE_LOCK_SUPPORTED",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_AUTO_WHITEBALANCE_LOCK",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_AUTO_WHITEBALANCE_LOCK_SUPPORTED",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_METERING_AREAS",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_MAX_NUM_METERING_AREAS",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_ZOOM",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_MAX_ZOOM",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_ZOOM_RATIOS",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_ZOOM_SUPPORTED",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_SMOOTH_ZOOM_SUPPORTED",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_FOCUS_DISTANCES",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_VIDEO_SIZE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_MAX_NUM_DETECTED_FACES_HW",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_MAX_NUM_DETECTED_FACES_SW",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_RECORDING_HINT",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_VIDEO_SNAPSHOT_SUPPORTED",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_VIDEO_STABILIZATION",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "KEY_VIDEO_STABILIZATION_SUPPORTED",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SUPPORTED_VALUES_SUFFIX",
    "type" : "String",
    "comment" : " Parameter key suffix for supported values.",
    "links" : [ ]
  }, {
    "name" : "TRUE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "FALSE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "WHITE_BALANCE_AUTO",
    "type" : "String",
    "comment" : " Values for white balance settings.",
    "links" : [ ]
  }, {
    "name" : "WHITE_BALANCE_INCANDESCENT",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "WHITE_BALANCE_FLUORESCENT",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "WHITE_BALANCE_WARM_FLUORESCENT",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "WHITE_BALANCE_DAYLIGHT",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "WHITE_BALANCE_CLOUDY_DAYLIGHT",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "WHITE_BALANCE_TWILIGHT",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "WHITE_BALANCE_SHADE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EFFECT_NONE",
    "type" : "String",
    "comment" : " Values for color effect settings.",
    "links" : [ ]
  }, {
    "name" : "EFFECT_MONO",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EFFECT_NEGATIVE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EFFECT_SOLARIZE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EFFECT_SEPIA",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EFFECT_POSTERIZE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EFFECT_WHITEBOARD",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EFFECT_BLACKBOARD",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EFFECT_AQUA",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ANTIBANDING_AUTO",
    "type" : "String",
    "comment" : " Values for antibanding settings.",
    "links" : [ ]
  }, {
    "name" : "ANTIBANDING_50HZ",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ANTIBANDING_60HZ",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ANTIBANDING_OFF",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "FLASH_MODE_OFF",
    "type" : "String",
    "comment" : "\n         * Flash will not be fired.\n         ",
    "links" : [ ]
  }, {
    "name" : "FLASH_MODE_AUTO",
    "type" : "String",
    "comment" : "\n         * Flash will be fired automatically when required. The flash may be fired\n         * during preview, auto-focus, or snapshot depending on the driver.\n         ",
    "links" : [ ]
  }, {
    "name" : "FLASH_MODE_ON",
    "type" : "String",
    "comment" : "\n         * Flash will always be fired during snapshot. The flash may also be\n         * fired during preview or auto-focus depending on the driver.\n         ",
    "links" : [ ]
  }, {
    "name" : "FLASH_MODE_RED_EYE",
    "type" : "String",
    "comment" : "\n         * Flash will be fired in red-eye reduction mode.\n         ",
    "links" : [ ]
  }, {
    "name" : "FLASH_MODE_TORCH",
    "type" : "String",
    "comment" : "\n         * Constant emission of light during preview, auto-focus and snapshot.\n         * This can also be used for video recording.\n         ",
    "links" : [ ]
  }, {
    "name" : "SCENE_MODE_AUTO",
    "type" : "String",
    "comment" : "\n         * Scene mode is off.\n         ",
    "links" : [ ]
  }, {
    "name" : "SCENE_MODE_ACTION",
    "type" : "String",
    "comment" : "\n         * Take photos of fast moving objects. Same as {@link\n         * #SCENE_MODE_SPORTS}.\n         ",
    "links" : [ "#SCENE_MODE_SPORTS" ]
  }, {
    "name" : "SCENE_MODE_PORTRAIT",
    "type" : "String",
    "comment" : "\n         * Take people pictures.\n         ",
    "links" : [ ]
  }, {
    "name" : "SCENE_MODE_LANDSCAPE",
    "type" : "String",
    "comment" : "\n         * Take pictures on distant objects.\n         ",
    "links" : [ ]
  }, {
    "name" : "SCENE_MODE_NIGHT",
    "type" : "String",
    "comment" : "\n         * Take photos at night.\n         ",
    "links" : [ ]
  }, {
    "name" : "SCENE_MODE_NIGHT_PORTRAIT",
    "type" : "String",
    "comment" : "\n         * Take people pictures at night.\n         ",
    "links" : [ ]
  }, {
    "name" : "SCENE_MODE_THEATRE",
    "type" : "String",
    "comment" : "\n         * Take photos in a theater. Flash light is off.\n         ",
    "links" : [ ]
  }, {
    "name" : "SCENE_MODE_BEACH",
    "type" : "String",
    "comment" : "\n         * Take pictures on the beach.\n         ",
    "links" : [ ]
  }, {
    "name" : "SCENE_MODE_SNOW",
    "type" : "String",
    "comment" : "\n         * Take pictures on the snow.\n         ",
    "links" : [ ]
  }, {
    "name" : "SCENE_MODE_SUNSET",
    "type" : "String",
    "comment" : "\n         * Take sunset photos.\n         ",
    "links" : [ ]
  }, {
    "name" : "SCENE_MODE_STEADYPHOTO",
    "type" : "String",
    "comment" : "\n         * Avoid blurry pictures (for example, due to hand shake).\n         ",
    "links" : [ ]
  }, {
    "name" : "SCENE_MODE_FIREWORKS",
    "type" : "String",
    "comment" : "\n         * For shooting firework displays.\n         ",
    "links" : [ ]
  }, {
    "name" : "SCENE_MODE_SPORTS",
    "type" : "String",
    "comment" : "\n         * Take photos of fast moving objects. Same as {@link\n         * #SCENE_MODE_ACTION}.\n         ",
    "links" : [ "#SCENE_MODE_ACTION" ]
  }, {
    "name" : "SCENE_MODE_PARTY",
    "type" : "String",
    "comment" : "\n         * Take indoor low-light shot.\n         ",
    "links" : [ ]
  }, {
    "name" : "SCENE_MODE_CANDLELIGHT",
    "type" : "String",
    "comment" : "\n         * Capture the naturally warm color of scenes lit by candles.\n         ",
    "links" : [ ]
  }, {
    "name" : "SCENE_MODE_BARCODE",
    "type" : "String",
    "comment" : "\n         * Applications are looking for a barcode. Camera driver will be\n         * optimized for barcode reading.\n         ",
    "links" : [ ]
  }, {
    "name" : "SCENE_MODE_HDR",
    "type" : "String",
    "comment" : "\n         * Capture a scene using high dynamic range imaging techniques. The\n         * camera will return an image that has an extended dynamic range\n         * compared to a regular capture. Capturing such an image may take\n         * longer than a regular capture.\n         ",
    "links" : [ ]
  }, {
    "name" : "FOCUS_MODE_AUTO",
    "type" : "String",
    "comment" : "\n         * Auto-focus mode. Applications should call {@link\n         * #autoFocus(AutoFocusCallback)} to start the focus in this mode.\n         ",
    "links" : [ "#autoFocus(AutoFocusCallback)" ]
  }, {
    "name" : "FOCUS_MODE_INFINITY",
    "type" : "String",
    "comment" : "\n         * Focus is set at infinity. Applications should not call\n         * {@link #autoFocus(AutoFocusCallback)} in this mode.\n         ",
    "links" : [ "#autoFocus(AutoFocusCallback)" ]
  }, {
    "name" : "FOCUS_MODE_MACRO",
    "type" : "String",
    "comment" : "\n         * Macro (close-up) focus mode. Applications should call\n         * {@link #autoFocus(AutoFocusCallback)} to start the focus in this\n         * mode.\n         ",
    "links" : [ "#autoFocus(AutoFocusCallback)" ]
  }, {
    "name" : "FOCUS_MODE_FIXED",
    "type" : "String",
    "comment" : "\n         * Focus is fixed. The camera is always in this mode if the focus is not\n         * adjustable. If the camera has auto-focus, this mode can fix the\n         * focus, which is usually at hyperfocal distance. Applications should\n         * not call {@link #autoFocus(AutoFocusCallback)} in this mode.\n         ",
    "links" : [ "#autoFocus(AutoFocusCallback)" ]
  }, {
    "name" : "FOCUS_MODE_EDOF",
    "type" : "String",
    "comment" : "\n         * Extended depth of field (EDOF). Focusing is done digitally and\n         * continuously. Applications should not call {@link\n         * #autoFocus(AutoFocusCallback)} in this mode.\n         ",
    "links" : [ "#autoFocus(AutoFocusCallback)" ]
  }, {
    "name" : "FOCUS_MODE_CONTINUOUS_VIDEO",
    "type" : "String",
    "comment" : "\n         * Continuous auto focus mode intended for video recording. The camera\n         * continuously tries to focus. This is the best choice for video\n         * recording because the focus changes smoothly . Applications still can\n         * call {@link #takePicture(Camera.ShutterCallback,\n         * Camera.PictureCallback, Camera.PictureCallback)} in this mode but the\n         * subject may not be in focus. Auto focus starts when the parameter is\n         * set.\n         *\n         * <p>Since API level 14, applications can call {@link\n         * #autoFocus(AutoFocusCallback)} in this mode. The focus callback will\n         * immediately return with a boolean that indicates whether the focus is\n         * sharp or not. The focus position is locked after autoFocus call. If\n         * applications want to resume the continuous focus, cancelAutoFocus\n         * must be called. Restarting the preview will not resume the continuous\n         * autofocus. To stop continuous focus, applications should change the\n         * focus mode to other modes.\n         *\n         * @see #FOCUS_MODE_CONTINUOUS_PICTURE\n         ",
    "links" : [ "#takePicture(Camera.ShutterCallback", "#autoFocus(AutoFocusCallback)" ]
  }, {
    "name" : "FOCUS_MODE_CONTINUOUS_PICTURE",
    "type" : "String",
    "comment" : "\n         * Continuous auto focus mode intended for taking pictures. The camera\n         * continuously tries to focus. The speed of focus change is more\n         * aggressive than {@link #FOCUS_MODE_CONTINUOUS_VIDEO}. Auto focus\n         * starts when the parameter is set.\n         *\n         * <p>Applications can call {@link #autoFocus(AutoFocusCallback)} in\n         * this mode. If the autofocus is in the middle of scanning, the focus\n         * callback will return when it completes. If the autofocus is not\n         * scanning, the focus callback will immediately return with a boolean\n         * that indicates whether the focus is sharp or not. The apps can then\n         * decide if they want to take a picture immediately or to change the\n         * focus mode to auto, and run a full autofocus cycle. The focus\n         * position is locked after autoFocus call. If applications want to\n         * resume the continuous focus, cancelAutoFocus must be called.\n         * Restarting the preview will not resume the continuous autofocus. To\n         * stop continuous focus, applications should change the focus mode to\n         * other modes.\n         *\n         * @see #FOCUS_MODE_CONTINUOUS_VIDEO\n         ",
    "links" : [ "#FOCUS_MODE_CONTINUOUS_VIDEO", "#autoFocus(AutoFocusCallback)" ]
  }, {
    "name" : "FOCUS_DISTANCE_NEAR_INDEX",
    "type" : "int",
    "comment" : "\n         * The array index of near focus distance for use with\n         * {@link #getFocusDistances(float[])}.\n         ",
    "links" : [ "#getFocusDistances(float" ]
  }, {
    "name" : "FOCUS_DISTANCE_OPTIMAL_INDEX",
    "type" : "int",
    "comment" : "\n         * The array index of optimal focus distance for use with\n         * {@link #getFocusDistances(float[])}.\n         ",
    "links" : [ "#getFocusDistances(float" ]
  }, {
    "name" : "FOCUS_DISTANCE_FAR_INDEX",
    "type" : "int",
    "comment" : "\n         * The array index of far focus distance for use with\n         * {@link #getFocusDistances(float[])}.\n         ",
    "links" : [ "#getFocusDistances(float" ]
  }, {
    "name" : "PREVIEW_FPS_MIN_INDEX",
    "type" : "int",
    "comment" : "\n         * The array index of minimum preview fps for use with {@link\n         * #getPreviewFpsRange(int[])} or {@link\n         * #getSupportedPreviewFpsRange()}.\n         ",
    "links" : [ "#getPreviewFpsRange(int", "#getSupportedPreviewFpsRange()" ]
  }, {
    "name" : "PREVIEW_FPS_MAX_INDEX",
    "type" : "int",
    "comment" : "\n         * The array index of maximum preview fps for use with {@link\n         * #getPreviewFpsRange(int[])} or {@link\n         * #getSupportedPreviewFpsRange()}.\n         ",
    "links" : [ "#getPreviewFpsRange(int", "#getSupportedPreviewFpsRange()" ]
  }, {
    "name" : "PIXEL_FORMAT_YUV422SP",
    "type" : "String",
    "comment" : " Formats for setPreviewFormat and setPictureFormat.",
    "links" : [ ]
  }, {
    "name" : "PIXEL_FORMAT_YUV420SP",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PIXEL_FORMAT_YUV422I",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PIXEL_FORMAT_YUV420P",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PIXEL_FORMAT_RGB565",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PIXEL_FORMAT_JPEG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PIXEL_FORMAT_BAYER_RGGB",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMap",
    "type" : "LinkedHashMap<String, String>",
    "comment" : "\n         * Order matters: Keys that are {@link #set(String, String) set} later\n         * will take precedence over keys that are set earlier (if the two keys\n         * conflict with each other).\n         *\n         * <p>One example is {@link #setPreviewFpsRange(int, int)} , since it\n         * conflicts with {@link #setPreviewFrameRate(int)} whichever key is set later\n         * is the one that will take precedence.\n         * </p>\n         ",
    "links" : [ "#setPreviewFpsRange(int", "#setPreviewFrameRate(int)", "#set(String" ]
  } ],
  "methods" : [ {
    "name" : "public void copyFrom(Parameters other)",
    "returnType" : "void",
    "comment" : "\n         * Overwrite existing parameters with a copy of the ones from {@code other}.\n         *\n         * <b>For use by the legacy shim only.</b>\n         *\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "private Camera getOuter()",
    "returnType" : "Camera",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean same(Parameters other)",
    "returnType" : "boolean",
    "comment" : "\n         * Value equality check.\n         *\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public void dump()",
    "returnType" : "void",
    "comment" : "\n         * Writes the current Parameters to the log.\n         * @hide\n         * @deprecated\n         ",
    "links" : [ ]
  }, {
    "name" : "public String flatten()",
    "returnType" : "String",
    "comment" : "\n         * Creates a single string with all the parameters set in\n         * this Parameters object.\n         * <p>The {@link #unflatten(String)} method does the reverse.</p>\n         *\n         * @return a String with all values from this Parameters object, in\n         *         semi-colon delimited key-value pairs\n         ",
    "links" : [ "#unflatten(String)" ]
  }, {
    "name" : "public void unflatten(String flattened)",
    "returnType" : "void",
    "comment" : "\n         * Takes a flattened string of parameters and adds each one to\n         * this Parameters object.\n         * <p>The {@link #flatten()} method does the reverse.</p>\n         *\n         * @param flattened a String of parameters (key-value paired) that\n         *                  are semi-colon delimited\n         ",
    "links" : [ "#flatten()" ]
  }, {
    "name" : "public void remove(String key)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void set(String key, String value)",
    "returnType" : "void",
    "comment" : "\n         * Sets a String parameter.\n         *\n         * @param key   the key name for the parameter\n         * @param value the String value of the parameter\n         ",
    "links" : [ ]
  }, {
    "name" : "public void set(String key, int value)",
    "returnType" : "void",
    "comment" : "\n         * Sets an integer parameter.\n         *\n         * @param key   the key name for the parameter\n         * @param value the int value of the parameter\n         ",
    "links" : [ ]
  }, {
    "name" : "private void put(String key, String value)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void set(String key, List<Area> areas)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public String get(String key)",
    "returnType" : "String",
    "comment" : "\n         * Returns the value of a String parameter.\n         *\n         * @param key the key name for the parameter\n         * @return the String value of the parameter\n         ",
    "links" : [ ]
  }, {
    "name" : "public int getInt(String key)",
    "returnType" : "int",
    "comment" : "\n         * Returns the value of an integer parameter.\n         *\n         * @param key the key name for the parameter\n         * @return the int value of the parameter\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setPreviewSize(int width, int height)",
    "returnType" : "void",
    "comment" : "\n         * Sets the dimensions for preview pictures. If the preview has already\n         * started, applications should stop the preview first before changing\n         * preview size.\n         *\n         * The sides of width and height are based on camera orientation. That\n         * is, the preview size is the size before it is rotated by display\n         * orientation. So applications need to consider the display orientation\n         * while setting preview size. For example, suppose the camera supports\n         * both 480x320 and 320x480 preview sizes. The application wants a 3:2\n         * preview ratio. If the display orientation is set to 0 or 180, preview\n         * size should be set to 480x320. If the display orientation is set to\n         * 90 or 270, preview size should be set to 320x480. The display\n         * orientation should also be considered while setting picture size and\n         * thumbnail size.\n         *\n         * Exception on 176x144 (QCIF) resolution:\n         * Camera devices usually have a fixed capability for downscaling from\n         * larger resolution to smaller, and the QCIF resolution sometimes\n         * is not fully supported due to this limitation on devices with\n         * high-resolution image sensors. Therefore, trying to configure a QCIF\n         * preview size with any picture or video size larger than 1920x1080\n         * (either width or height) might not be supported, and\n         * {@link #setParameters(Camera.Parameters)} might throw a\n         * RuntimeException if it is not.\n         *\n         * @param width  the width of the pictures, in pixels\n         * @param height the height of the pictures, in pixels\n         * @see #setDisplayOrientation(int)\n         * @see #getCameraInfo(int, CameraInfo)\n         * @see #setPictureSize(int, int)\n         * @see #setJpegThumbnailSize(int, int)\n         ",
    "links" : [ "#setParameters(Camera.Parameters)" ]
  }, {
    "name" : "public Size getPreviewSize()",
    "returnType" : "Size",
    "comment" : "\n         * Returns the dimensions setting for preview pictures.\n         *\n         * @return a Size object with the width and height setting\n         *          for the preview picture\n         ",
    "links" : [ ]
  }, {
    "name" : "public List<Size> getSupportedPreviewSizes()",
    "returnType" : "List<Size>",
    "comment" : "\n         * Gets the supported preview sizes.\n         *\n         * @return a list of Size object. This method will always return a list\n         *         with at least one element.\n         ",
    "links" : [ ]
  }, {
    "name" : "public List<Size> getSupportedVideoSizes()",
    "returnType" : "List<Size>",
    "comment" : "\n         * <p>Gets the supported video frame sizes that can be used by\n         * MediaRecorder.</p>\n         *\n         * <p>If the returned list is not null, the returned list will contain at\n         * least one Size and one of the sizes in the returned list must be\n         * passed to MediaRecorder.setVideoSize() for camcorder application if\n         * camera is used as the video source. In this case, the size of the\n         * preview can be different from the resolution of the recorded video\n         * during video recording.</p>\n         *\n         * <p>Exception on 176x144 (QCIF) resolution:\n         * Camera devices usually have a fixed capability for downscaling from\n         * larger resolution to smaller, and the QCIF resolution sometimes\n         * is not fully supported due to this limitation on devices with\n         * high-resolution image sensors. Therefore, trying to configure a QCIF\n         * video resolution with any preview or picture size larger than\n         * 1920x1080  (either width or height) might not be supported, and\n         * {@link #setParameters(Camera.Parameters)} will throw a\n         * RuntimeException if it is not.</p>\n         *\n         * @return a list of Size object if camera has separate preview and\n         *         video output; otherwise, null is returned.\n         * @see #getPreferredPreviewSizeForVideo()\n         ",
    "links" : [ "#setParameters(Camera.Parameters)" ]
  }, {
    "name" : "public Size getPreferredPreviewSizeForVideo()",
    "returnType" : "Size",
    "comment" : "\n         * Returns the preferred or recommended preview size (width and height)\n         * in pixels for video recording. Camcorder applications should\n         * set the preview size to a value that is not larger than the\n         * preferred preview size. In other words, the product of the width\n         * and height of the preview size should not be larger than that of\n         * the preferred preview size. In addition, we recommend to choose a\n         * preview size that has the same aspect ratio as the resolution of\n         * video to be recorded.\n         *\n         * @return the preferred preview size (width and height) in pixels for\n         *         video recording if getSupportedVideoSizes() does not return\n         *         null; otherwise, null is returned.\n         * @see #getSupportedVideoSizes()\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setJpegThumbnailSize(int width, int height)",
    "returnType" : "void",
    "comment" : "\n         * <p>Sets the dimensions for EXIF thumbnail in Jpeg picture. If\n         * applications set both width and height to 0, EXIF will not contain\n         * thumbnail.</p>\n         *\n         * <p>Applications need to consider the display orientation. See {@link\n         * #setPreviewSize(int,int)} for reference.</p>\n         *\n         * @param width  the width of the thumbnail, in pixels\n         * @param height the height of the thumbnail, in pixels\n         * @see #setPreviewSize(int,int)\n         ",
    "links" : [ "#setPreviewSize(int" ]
  }, {
    "name" : "public Size getJpegThumbnailSize()",
    "returnType" : "Size",
    "comment" : "\n         * Returns the dimensions for EXIF thumbnail in Jpeg picture.\n         *\n         * @return a Size object with the height and width setting for the EXIF\n         *         thumbnails\n         ",
    "links" : [ ]
  }, {
    "name" : "public List<Size> getSupportedJpegThumbnailSizes()",
    "returnType" : "List<Size>",
    "comment" : "\n         * Gets the supported jpeg thumbnail sizes.\n         *\n         * @return a list of Size object. This method will always return a list\n         *         with at least two elements. Size 0,0 (no thumbnail) is always\n         *         supported.\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setJpegThumbnailQuality(int quality)",
    "returnType" : "void",
    "comment" : "\n         * Sets the quality of the EXIF thumbnail in Jpeg picture.\n         *\n         * @param quality the JPEG quality of the EXIF thumbnail. The range is 1\n         *                to 100, with 100 being the best.\n         ",
    "links" : [ ]
  }, {
    "name" : "public int getJpegThumbnailQuality()",
    "returnType" : "int",
    "comment" : "\n         * Returns the quality setting for the EXIF thumbnail in Jpeg picture.\n         *\n         * @return the JPEG quality setting of the EXIF thumbnail.\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setJpegQuality(int quality)",
    "returnType" : "void",
    "comment" : "\n         * Sets Jpeg quality of captured picture.\n         *\n         * @param quality the JPEG quality of captured picture. The range is 1\n         *                to 100, with 100 being the best.\n         ",
    "links" : [ ]
  }, {
    "name" : "public int getJpegQuality()",
    "returnType" : "int",
    "comment" : "\n         * Returns the quality setting for the JPEG picture.\n         *\n         * @return the JPEG picture quality setting.\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setPreviewFrameRate(int fps)",
    "returnType" : "void",
    "comment" : "\n         * Sets the rate at which preview frames are received. This is the\n         * target frame rate. The actual frame rate depends on the driver.\n         *\n         * @param fps the frame rate (frames per second)\n         * @deprecated replaced by {@link #setPreviewFpsRange(int,int)}\n         ",
    "links" : [ "#setPreviewFpsRange(int" ]
  }, {
    "name" : "public int getPreviewFrameRate()",
    "returnType" : "int",
    "comment" : "\n         * Returns the setting for the rate at which preview frames are\n         * received. This is the target frame rate. The actual frame rate\n         * depends on the driver.\n         *\n         * @return the frame rate setting (frames per second)\n         * @deprecated replaced by {@link #getPreviewFpsRange(int[])}\n         ",
    "links" : [ "#getPreviewFpsRange(int" ]
  }, {
    "name" : "public List<Integer> getSupportedPreviewFrameRates()",
    "returnType" : "List<Integer>",
    "comment" : "\n         * Gets the supported preview frame rates.\n         *\n         * @return a list of supported preview frame rates. null if preview\n         *         frame rate setting is not supported.\n         * @deprecated replaced by {@link #getSupportedPreviewFpsRange()}\n         ",
    "links" : [ "#getSupportedPreviewFpsRange()" ]
  }, {
    "name" : "public void setPreviewFpsRange(int min, int max)",
    "returnType" : "void",
    "comment" : "\n         * Sets the minimum and maximum preview fps. This controls the rate of\n         * preview frames received in {@link PreviewCallback}. The minimum and\n         * maximum preview fps must be one of the elements from {@link\n         * #getSupportedPreviewFpsRange}.\n         *\n         * @param min the minimum preview fps (scaled by 1000).\n         * @param max the maximum preview fps (scaled by 1000).\n         * @throws RuntimeException if fps range is invalid.\n         * @see #setPreviewCallbackWithBuffer(Camera.PreviewCallback)\n         * @see #getSupportedPreviewFpsRange()\n         ",
    "links" : [ "PreviewCallback", "#getSupportedPreviewFpsRange" ]
  }, {
    "name" : "public void getPreviewFpsRange(int[] range)",
    "returnType" : "void",
    "comment" : "\n         * Returns the current minimum and maximum preview fps. The values are\n         * one of the elements returned by {@link #getSupportedPreviewFpsRange}.\n         *\n         * @return range the minimum and maximum preview fps (scaled by 1000).\n         * @see #PREVIEW_FPS_MIN_INDEX\n         * @see #PREVIEW_FPS_MAX_INDEX\n         * @see #getSupportedPreviewFpsRange()\n         ",
    "links" : [ "#getSupportedPreviewFpsRange" ]
  }, {
    "name" : "public List<int[]> getSupportedPreviewFpsRange()",
    "returnType" : "List<int[]>",
    "comment" : "\n         * Gets the supported preview fps (frame-per-second) ranges. Each range\n         * contains a minimum fps and maximum fps. If minimum fps equals to\n         * maximum fps, the camera outputs frames in fixed frame rate. If not,\n         * the camera outputs frames in auto frame rate. The actual frame rate\n         * fluctuates between the minimum and the maximum. The values are\n         * multiplied by 1000 and represented in integers. For example, if frame\n         * rate is 26.623 frames per second, the value is 26623.\n         *\n         * @return a list of supported preview fps ranges. This method returns a\n         *         list with at least one element. Every element is an int array\n         *         of two values - minimum fps and maximum fps. The list is\n         *         sorted from small to large (first by maximum fps and then\n         *         minimum fps).\n         * @see #PREVIEW_FPS_MIN_INDEX\n         * @see #PREVIEW_FPS_MAX_INDEX\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setPreviewFormat(int pixel_format)",
    "returnType" : "void",
    "comment" : "\n         * Sets the image format for preview pictures.\n         * <p>If this is never called, the default format will be\n         * {@link android.graphics.ImageFormat#NV21}, which\n         * uses the NV21 encoding format.</p>\n         *\n         * <p>Use {@link Parameters#getSupportedPreviewFormats} to get a list of\n         * the available preview formats.\n         *\n         * <p>It is strongly recommended that either\n         * {@link android.graphics.ImageFormat#NV21} or\n         * {@link android.graphics.ImageFormat#YV12} is used, since\n         * they are supported by all camera devices.</p>\n         *\n         * <p>For YV12, the image buffer that is received is not necessarily\n         * tightly packed, as there may be padding at the end of each row of\n         * pixel data, as described in\n         * {@link android.graphics.ImageFormat#YV12}. For camera callback data,\n         * it can be assumed that the stride of the Y and UV data is the\n         * smallest possible that meets the alignment requirements. That is, if\n         * the preview size is <var>width x height</var>, then the following\n         * equations describe the buffer index for the beginning of row\n         * <var>y</var> for the Y plane and row <var>c</var> for the U and V\n         * planes:\n         *\n         * <pre>{@code\n         * yStride   = (int) ceil(width / 16.0) * 16;\n         * uvStride  = (int) ceil( (yStride / 2) / 16.0) * 16;\n         * ySize     = yStride * height;\n         * uvSize    = uvStride * height / 2;\n         * yRowIndex = yStride * y;\n         * uRowIndex = ySize + uvSize + uvStride * c;\n         * vRowIndex = ySize + uvStride * c;\n         * size      = ySize + uvSize * 2;\n         * }\n         *</pre>\n         *\n         * @param pixel_format the desired preview picture format, defined by\n         *   one of the {@link android.graphics.ImageFormat} constants.  (E.g.,\n         *   <var>ImageFormat.NV21</var> (default), or\n         *   <var>ImageFormat.YV12</var>)\n         *\n         * @see android.graphics.ImageFormat\n         * @see android.hardware.Camera.Parameters#getSupportedPreviewFormats\n         ",
    "links" : [ "android.graphics.ImageFormat#YV12", "android.graphics.ImageFormat#NV21", "android.graphics.ImageFormat", "#getSupportedPreviewFormats" ]
  }, {
    "name" : "public int getPreviewFormat()",
    "returnType" : "int",
    "comment" : "\n         * Returns the image format for preview frames got from\n         * {@link PreviewCallback}.\n         *\n         * @return the preview format.\n         * @see android.graphics.ImageFormat\n         * @see #setPreviewFormat\n         ",
    "links" : [ "PreviewCallback" ]
  }, {
    "name" : "public List<Integer> getSupportedPreviewFormats()",
    "returnType" : "List<Integer>",
    "comment" : "\n         * Gets the supported preview formats. {@link android.graphics.ImageFormat#NV21}\n         * is always supported. {@link android.graphics.ImageFormat#YV12}\n         * is always supported since API level 12.\n         *\n         * @return a list of supported preview formats. This method will always\n         *         return a list with at least one element.\n         * @see android.graphics.ImageFormat\n         * @see #setPreviewFormat\n         ",
    "links" : [ "android.graphics.ImageFormat#YV12", "android.graphics.ImageFormat#NV21" ]
  }, {
    "name" : "public void setPictureSize(int width, int height)",
    "returnType" : "void",
    "comment" : "\n         * <p>Sets the dimensions for pictures.</p>\n         *\n         * <p>Applications need to consider the display orientation. See {@link\n         * #setPreviewSize(int,int)} for reference.</p>\n         *\n         * <p>Exception on 176x144 (QCIF) resolution:\n         * Camera devices usually have a fixed capability for downscaling from\n         * larger resolution to smaller, and the QCIF resolution sometimes\n         * is not fully supported due to this limitation on devices with\n         * high-resolution image sensors. Therefore, trying to configure a QCIF\n         * picture size with any preview or video size larger than 1920x1080\n         * (either width or height) might not be supported, and\n         * {@link #setParameters(Camera.Parameters)} might throw a\n         * RuntimeException if it is not.</p>\n         *\n         * @param width  the width for pictures, in pixels\n         * @param height the height for pictures, in pixels\n         * @see #setPreviewSize(int,int)\n         *\n         ",
    "links" : [ "#setPreviewSize(int", "#setParameters(Camera.Parameters)" ]
  }, {
    "name" : "public Size getPictureSize()",
    "returnType" : "Size",
    "comment" : "\n         * Returns the dimension setting for pictures.\n         *\n         * @return a Size object with the height and width setting\n         *          for pictures\n         ",
    "links" : [ ]
  }, {
    "name" : "public List<Size> getSupportedPictureSizes()",
    "returnType" : "List<Size>",
    "comment" : "\n         * Gets the supported picture sizes.\n         *\n         * @return a list of supported picture sizes. This method will always\n         *         return a list with at least one element.\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setPictureFormat(int pixel_format)",
    "returnType" : "void",
    "comment" : "\n         * Sets the image format for pictures.\n         *\n         * @param pixel_format the desired picture format\n         *                     (<var>ImageFormat.NV21</var>,\n         *                      <var>ImageFormat.RGB_565</var>, or\n         *                      <var>ImageFormat.JPEG</var>)\n         * @see android.graphics.ImageFormat\n         ",
    "links" : [ ]
  }, {
    "name" : "public int getPictureFormat()",
    "returnType" : "int",
    "comment" : "\n         * Returns the image format for pictures.\n         *\n         * @return the picture format\n         * @see android.graphics.ImageFormat\n         ",
    "links" : [ ]
  }, {
    "name" : "public List<Integer> getSupportedPictureFormats()",
    "returnType" : "List<Integer>",
    "comment" : "\n         * Gets the supported picture formats.\n         *\n         * @return supported picture formats. This method will always return a\n         *         list with at least one element.\n         * @see android.graphics.ImageFormat\n         ",
    "links" : [ ]
  }, {
    "name" : "private String cameraFormatForPixelFormat(int pixel_format)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int pixelFormatForCameraFormat(String format)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setRotation(int rotation)",
    "returnType" : "void",
    "comment" : "\n         * Sets the clockwise rotation angle in degrees relative to the\n         * orientation of the camera. This affects the pictures returned from\n         * JPEG {@link PictureCallback}. The camera driver may set orientation\n         * in the EXIF header without rotating the picture. Or the driver may\n         * rotate the picture and the EXIF thumbnail. If the Jpeg picture is\n         * rotated, the orientation in the EXIF header will be missing or 1 (row\n         * #0 is top and column #0 is left side).\n         *\n         * <p>\n         * If applications want to rotate the picture to match the orientation\n         * of what users see, apps should use\n         * {@link android.view.OrientationEventListener} and\n         * {@link android.hardware.Camera.CameraInfo}. The value from\n         * OrientationEventListener is relative to the natural orientation of\n         * the device. CameraInfo.orientation is the angle between camera\n         * orientation and natural device orientation. The sum of the two is the\n         * rotation angle for back-facing camera. The difference of the two is\n         * the rotation angle for front-facing camera. Note that the JPEG\n         * pictures of front-facing cameras are not mirrored as in preview\n         * display.\n         *\n         * <p>\n         * For example, suppose the natural orientation of the device is\n         * portrait. The device is rotated 270 degrees clockwise, so the device\n         * orientation is 270. Suppose a back-facing camera sensor is mounted in\n         * landscape and the top side of the camera sensor is aligned with the\n         * right edge of the display in natural orientation. So the camera\n         * orientation is 90. The rotation should be set to 0 (270 + 90).\n         *\n         * <p>The reference code is as follows.\n         *\n         * <pre>\n         * public void onOrientationChanged(int orientation) {\n         *     if (orientation == ORIENTATION_UNKNOWN) return;\n         *     android.hardware.Camera.CameraInfo info =\n         *            new android.hardware.Camera.CameraInfo();\n         *     android.hardware.Camera.getCameraInfo(cameraId, info);\n         *     orientation = (orientation + 45) / 90 * 90;\n         *     int rotation = 0;\n         *     if (info.facing == CameraInfo.CAMERA_FACING_FRONT) {\n         *         rotation = (info.orientation - orientation + 360) % 360;\n         *     } else {  // back-facing camera\n         *         rotation = (info.orientation + orientation) % 360;\n         *     }\n         *     mParameters.setRotation(rotation);\n         * }\n         * </pre>\n         *\n         * @param rotation The rotation angle in degrees relative to the\n         *                 orientation of the camera. Rotation can only be 0,\n         *                 90, 180 or 270.\n         * @throws IllegalArgumentException if rotation value is invalid.\n         * @see android.view.OrientationEventListener\n         * @see #getCameraInfo(int, CameraInfo)\n         ",
    "links" : [ "PictureCallback", "android.hardware.Camera.CameraInfo", "android.view.OrientationEventListener" ]
  }, {
    "name" : "public void setGpsLatitude(double latitude)",
    "returnType" : "void",
    "comment" : "\n         * Sets GPS latitude coordinate. This will be stored in JPEG EXIF\n         * header.\n         *\n         * @param latitude GPS latitude coordinate.\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setGpsLongitude(double longitude)",
    "returnType" : "void",
    "comment" : "\n         * Sets GPS longitude coordinate. This will be stored in JPEG EXIF\n         * header.\n         *\n         * @param longitude GPS longitude coordinate.\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setGpsAltitude(double altitude)",
    "returnType" : "void",
    "comment" : "\n         * Sets GPS altitude. This will be stored in JPEG EXIF header.\n         *\n         * @param altitude GPS altitude in meters.\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setGpsTimestamp(long timestamp)",
    "returnType" : "void",
    "comment" : "\n         * Sets GPS timestamp. This will be stored in JPEG EXIF header.\n         *\n         * @param timestamp GPS timestamp (UTC in seconds since January 1,\n         *                  1970).\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setGpsProcessingMethod(String processing_method)",
    "returnType" : "void",
    "comment" : "\n         * Sets GPS processing method. The method will be stored in a UTF-8 string up to 31 bytes\n         * long, in the JPEG EXIF header.\n         *\n         * @param processing_method The processing method to get this location.\n         ",
    "links" : [ ]
  }, {
    "name" : "public void removeGpsData()",
    "returnType" : "void",
    "comment" : "\n         * Removes GPS latitude, longitude, altitude, and timestamp from the\n         * parameters.\n         ",
    "links" : [ ]
  }, {
    "name" : "public String getWhiteBalance()",
    "returnType" : "String",
    "comment" : "\n         * Gets the current white balance setting.\n         *\n         * @return current white balance. null if white balance setting is not\n         *         supported.\n         * @see #WHITE_BALANCE_AUTO\n         * @see #WHITE_BALANCE_INCANDESCENT\n         * @see #WHITE_BALANCE_FLUORESCENT\n         * @see #WHITE_BALANCE_WARM_FLUORESCENT\n         * @see #WHITE_BALANCE_DAYLIGHT\n         * @see #WHITE_BALANCE_CLOUDY_DAYLIGHT\n         * @see #WHITE_BALANCE_TWILIGHT\n         * @see #WHITE_BALANCE_SHADE\n         *\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setWhiteBalance(String value)",
    "returnType" : "void",
    "comment" : "\n         * Sets the white balance. Changing the setting will release the\n         * auto-white balance lock. It is recommended not to change white\n         * balance and AWB lock at the same time.\n         *\n         * @param value new white balance.\n         * @see #getWhiteBalance()\n         * @see #setAutoWhiteBalanceLock(boolean)\n         ",
    "links" : [ ]
  }, {
    "name" : "public List<String> getSupportedWhiteBalance()",
    "returnType" : "List<String>",
    "comment" : "\n         * Gets the supported white balance.\n         *\n         * @return a list of supported white balance. null if white balance\n         *         setting is not supported.\n         * @see #getWhiteBalance()\n         ",
    "links" : [ ]
  }, {
    "name" : "public String getColorEffect()",
    "returnType" : "String",
    "comment" : "\n         * Gets the current color effect setting.\n         *\n         * @return current color effect. null if color effect\n         *         setting is not supported.\n         * @see #EFFECT_NONE\n         * @see #EFFECT_MONO\n         * @see #EFFECT_NEGATIVE\n         * @see #EFFECT_SOLARIZE\n         * @see #EFFECT_SEPIA\n         * @see #EFFECT_POSTERIZE\n         * @see #EFFECT_WHITEBOARD\n         * @see #EFFECT_BLACKBOARD\n         * @see #EFFECT_AQUA\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setColorEffect(String value)",
    "returnType" : "void",
    "comment" : "\n         * Sets the current color effect setting.\n         *\n         * @param value new color effect.\n         * @see #getColorEffect()\n         ",
    "links" : [ ]
  }, {
    "name" : "public List<String> getSupportedColorEffects()",
    "returnType" : "List<String>",
    "comment" : "\n         * Gets the supported color effects.\n         *\n         * @return a list of supported color effects. null if color effect\n         *         setting is not supported.\n         * @see #getColorEffect()\n         ",
    "links" : [ ]
  }, {
    "name" : "public String getAntibanding()",
    "returnType" : "String",
    "comment" : "\n         * Gets the current antibanding setting.\n         *\n         * @return current antibanding. null if antibanding setting is not\n         *         supported.\n         * @see #ANTIBANDING_AUTO\n         * @see #ANTIBANDING_50HZ\n         * @see #ANTIBANDING_60HZ\n         * @see #ANTIBANDING_OFF\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setAntibanding(String antibanding)",
    "returnType" : "void",
    "comment" : "\n         * Sets the antibanding.\n         *\n         * @param antibanding new antibanding value.\n         * @see #getAntibanding()\n         ",
    "links" : [ ]
  }, {
    "name" : "public List<String> getSupportedAntibanding()",
    "returnType" : "List<String>",
    "comment" : "\n         * Gets the supported antibanding values.\n         *\n         * @return a list of supported antibanding values. null if antibanding\n         *         setting is not supported.\n         * @see #getAntibanding()\n         ",
    "links" : [ ]
  }, {
    "name" : "public String getSceneMode()",
    "returnType" : "String",
    "comment" : "\n         * Gets the current scene mode setting.\n         *\n         * @return one of SCENE_MODE_XXX string constant. null if scene mode\n         *         setting is not supported.\n         * @see #SCENE_MODE_AUTO\n         * @see #SCENE_MODE_ACTION\n         * @see #SCENE_MODE_PORTRAIT\n         * @see #SCENE_MODE_LANDSCAPE\n         * @see #SCENE_MODE_NIGHT\n         * @see #SCENE_MODE_NIGHT_PORTRAIT\n         * @see #SCENE_MODE_THEATRE\n         * @see #SCENE_MODE_BEACH\n         * @see #SCENE_MODE_SNOW\n         * @see #SCENE_MODE_SUNSET\n         * @see #SCENE_MODE_STEADYPHOTO\n         * @see #SCENE_MODE_FIREWORKS\n         * @see #SCENE_MODE_SPORTS\n         * @see #SCENE_MODE_PARTY\n         * @see #SCENE_MODE_CANDLELIGHT\n         * @see #SCENE_MODE_BARCODE\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setSceneMode(String value)",
    "returnType" : "void",
    "comment" : "\n         * Sets the scene mode. Changing scene mode may override other\n         * parameters (such as flash mode, focus mode, white balance). For\n         * example, suppose originally flash mode is on and supported flash\n         * modes are on/off. In night scene mode, both flash mode and supported\n         * flash mode may be changed to off. After setting scene mode,\n         * applications should call getParameters to know if some parameters are\n         * changed.\n         *\n         * @param value scene mode.\n         * @see #getSceneMode()\n         ",
    "links" : [ ]
  }, {
    "name" : "public List<String> getSupportedSceneModes()",
    "returnType" : "List<String>",
    "comment" : "\n         * Gets the supported scene modes.\n         *\n         * @return a list of supported scene modes. null if scene mode setting\n         *         is not supported.\n         * @see #getSceneMode()\n         ",
    "links" : [ ]
  }, {
    "name" : "public String getFlashMode()",
    "returnType" : "String",
    "comment" : "\n         * Gets the current flash mode setting.\n         *\n         * @return current flash mode. null if flash mode setting is not\n         *         supported.\n         * @see #FLASH_MODE_OFF\n         * @see #FLASH_MODE_AUTO\n         * @see #FLASH_MODE_ON\n         * @see #FLASH_MODE_RED_EYE\n         * @see #FLASH_MODE_TORCH\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setFlashMode(String value)",
    "returnType" : "void",
    "comment" : "\n         * Sets the flash mode.\n         *\n         * @param value flash mode.\n         * @see #getFlashMode()\n         ",
    "links" : [ ]
  }, {
    "name" : "public List<String> getSupportedFlashModes()",
    "returnType" : "List<String>",
    "comment" : "\n         * Gets the supported flash modes.\n         *\n         * @return a list of supported flash modes. null if flash mode setting\n         *         is not supported.\n         * @see #getFlashMode()\n         ",
    "links" : [ ]
  }, {
    "name" : "public String getFocusMode()",
    "returnType" : "String",
    "comment" : "\n         * Gets the current focus mode setting.\n         *\n         * @return current focus mode. This method will always return a non-null\n         *         value. Applications should call {@link\n         *         #autoFocus(AutoFocusCallback)} to start the focus if focus\n         *         mode is FOCUS_MODE_AUTO or FOCUS_MODE_MACRO.\n         * @see #FOCUS_MODE_AUTO\n         * @see #FOCUS_MODE_INFINITY\n         * @see #FOCUS_MODE_MACRO\n         * @see #FOCUS_MODE_FIXED\n         * @see #FOCUS_MODE_EDOF\n         * @see #FOCUS_MODE_CONTINUOUS_VIDEO\n         ",
    "links" : [ "#autoFocus(AutoFocusCallback)" ]
  }, {
    "name" : "public void setFocusMode(String value)",
    "returnType" : "void",
    "comment" : "\n         * Sets the focus mode.\n         *\n         * @param value focus mode.\n         * @see #getFocusMode()\n         ",
    "links" : [ ]
  }, {
    "name" : "public List<String> getSupportedFocusModes()",
    "returnType" : "List<String>",
    "comment" : "\n         * Gets the supported focus modes.\n         *\n         * @return a list of supported focus modes. This method will always\n         *         return a list with at least one element.\n         * @see #getFocusMode()\n         ",
    "links" : [ ]
  }, {
    "name" : "public float getFocalLength()",
    "returnType" : "float",
    "comment" : "\n         * Gets the focal length (in millimeter) of the camera.\n         *\n         * @return the focal length. Returns -1.0 when the device\n         *         doesn't report focal length information.\n         ",
    "links" : [ ]
  }, {
    "name" : "public float getHorizontalViewAngle()",
    "returnType" : "float",
    "comment" : "\n         * Gets the horizontal angle of view in degrees.\n         *\n         * @return horizontal angle of view. Returns -1.0 when the device\n         *         doesn't report view angle information.\n         ",
    "links" : [ ]
  }, {
    "name" : "public float getVerticalViewAngle()",
    "returnType" : "float",
    "comment" : "\n         * Gets the vertical angle of view in degrees.\n         *\n         * @return vertical angle of view. Returns -1.0 when the device\n         *         doesn't report view angle information.\n         ",
    "links" : [ ]
  }, {
    "name" : "public int getExposureCompensation()",
    "returnType" : "int",
    "comment" : "\n         * Gets the current exposure compensation index.\n         *\n         * @return current exposure compensation index. The range is {@link\n         *         #getMinExposureCompensation} to {@link\n         *         #getMaxExposureCompensation}. 0 means exposure is not\n         *         adjusted.\n         ",
    "links" : [ "#getMaxExposureCompensation", "#getMinExposureCompensation" ]
  }, {
    "name" : "public void setExposureCompensation(int value)",
    "returnType" : "void",
    "comment" : "\n         * Sets the exposure compensation index.\n         *\n         * @param value exposure compensation index. The valid value range is\n         *        from {@link #getMinExposureCompensation} (inclusive) to {@link\n         *        #getMaxExposureCompensation} (inclusive). 0 means exposure is\n         *        not adjusted. Application should call\n         *        getMinExposureCompensation and getMaxExposureCompensation to\n         *        know if exposure compensation is supported.\n         ",
    "links" : [ "#getMaxExposureCompensation", "#getMinExposureCompensation" ]
  }, {
    "name" : "public int getMaxExposureCompensation()",
    "returnType" : "int",
    "comment" : "\n         * Gets the maximum exposure compensation index.\n         *\n         * @return maximum exposure compensation index (>=0). If both this\n         *         method and {@link #getMinExposureCompensation} return 0,\n         *         exposure compensation is not supported.\n         ",
    "links" : [ "#getMinExposureCompensation" ]
  }, {
    "name" : "public int getMinExposureCompensation()",
    "returnType" : "int",
    "comment" : "\n         * Gets the minimum exposure compensation index.\n         *\n         * @return minimum exposure compensation index (<=0). If both this\n         *         method and {@link #getMaxExposureCompensation} return 0,\n         *         exposure compensation is not supported.\n         ",
    "links" : [ "#getMaxExposureCompensation" ]
  }, {
    "name" : "public float getExposureCompensationStep()",
    "returnType" : "float",
    "comment" : "\n         * Gets the exposure compensation step.\n         *\n         * @return exposure compensation step. Applications can get EV by\n         *         multiplying the exposure compensation index and step. Ex: if\n         *         exposure compensation index is -6 and step is 0.333333333, EV\n         *         is -2.\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setAutoExposureLock(boolean toggle)",
    "returnType" : "void",
    "comment" : "\n         * <p>Sets the auto-exposure lock state. Applications should check\n         * {@link #isAutoExposureLockSupported} before using this method.</p>\n         *\n         * <p>If set to true, the camera auto-exposure routine will immediately\n         * pause until the lock is set to false. Exposure compensation settings\n         * changes will still take effect while auto-exposure is locked.</p>\n         *\n         * <p>If auto-exposure is already locked, setting this to true again has\n         * no effect (the driver will not recalculate exposure values).</p>\n         *\n         * <p>Stopping preview with {@link #stopPreview()}, or triggering still\n         * image capture with {@link #takePicture(Camera.ShutterCallback,\n         * Camera.PictureCallback, Camera.PictureCallback)}, will not change the\n         * lock.</p>\n         *\n         * <p>Exposure compensation, auto-exposure lock, and auto-white balance\n         * lock can be used to capture an exposure-bracketed burst of images,\n         * for example.</p>\n         *\n         * <p>Auto-exposure state, including the lock state, will not be\n         * maintained after camera {@link #release()} is called.  Locking\n         * auto-exposure after {@link #open()} but before the first call to\n         * {@link #startPreview()} will not allow the auto-exposure routine to\n         * run at all, and may result in severely over- or under-exposed\n         * images.</p>\n         *\n         * @param toggle new state of the auto-exposure lock. True means that\n         *        auto-exposure is locked, false means that the auto-exposure\n         *        routine is free to run normally.\n         *\n         * @see #getAutoExposureLock()\n         ",
    "links" : [ "#takePicture(Camera.ShutterCallback", "#open()", "#release()", "#startPreview()", "#isAutoExposureLockSupported", "#stopPreview()" ]
  }, {
    "name" : "public boolean getAutoExposureLock()",
    "returnType" : "boolean",
    "comment" : "\n         * Gets the state of the auto-exposure lock. Applications should check\n         * {@link #isAutoExposureLockSupported} before using this method. See\n         * {@link #setAutoExposureLock} for details about the lock.\n         *\n         * @return State of the auto-exposure lock. Returns true if\n         *         auto-exposure is currently locked, and false otherwise.\n         *\n         * @see #setAutoExposureLock(boolean)\n         *\n         ",
    "links" : [ "#setAutoExposureLock", "#isAutoExposureLockSupported" ]
  }, {
    "name" : "public boolean isAutoExposureLockSupported()",
    "returnType" : "boolean",
    "comment" : "\n         * Returns true if auto-exposure locking is supported. Applications\n         * should call this before trying to lock auto-exposure. See\n         * {@link #setAutoExposureLock} for details about the lock.\n         *\n         * @return true if auto-exposure lock is supported.\n         * @see #setAutoExposureLock(boolean)\n         *\n         ",
    "links" : [ "#setAutoExposureLock" ]
  }, {
    "name" : "public void setAutoWhiteBalanceLock(boolean toggle)",
    "returnType" : "void",
    "comment" : "\n         * <p>Sets the auto-white balance lock state. Applications should check\n         * {@link #isAutoWhiteBalanceLockSupported} before using this\n         * method.</p>\n         *\n         * <p>If set to true, the camera auto-white balance routine will\n         * immediately pause until the lock is set to false.</p>\n         *\n         * <p>If auto-white balance is already locked, setting this to true\n         * again has no effect (the driver will not recalculate white balance\n         * values).</p>\n         *\n         * <p>Stopping preview with {@link #stopPreview()}, or triggering still\n         * image capture with {@link #takePicture(Camera.ShutterCallback,\n         * Camera.PictureCallback, Camera.PictureCallback)}, will not change the\n         * the lock.</p>\n         *\n         * <p> Changing the white balance mode with {@link #setWhiteBalance}\n         * will release the auto-white balance lock if it is set.</p>\n         *\n         * <p>Exposure compensation, AE lock, and AWB lock can be used to\n         * capture an exposure-bracketed burst of images, for example.\n         * Auto-white balance state, including the lock state, will not be\n         * maintained after camera {@link #release()} is called.  Locking\n         * auto-white balance after {@link #open()} but before the first call to\n         * {@link #startPreview()} will not allow the auto-white balance routine\n         * to run at all, and may result in severely incorrect color in captured\n         * images.</p>\n         *\n         * @param toggle new state of the auto-white balance lock. True means\n         *        that auto-white balance is locked, false means that the\n         *        auto-white balance routine is free to run normally.\n         *\n         * @see #getAutoWhiteBalanceLock()\n         * @see #setWhiteBalance(String)\n         ",
    "links" : [ "#takePicture(Camera.ShutterCallback", "#setWhiteBalance", "#open()", "#release()", "#startPreview()", "#isAutoWhiteBalanceLockSupported", "#stopPreview()" ]
  }, {
    "name" : "public boolean getAutoWhiteBalanceLock()",
    "returnType" : "boolean",
    "comment" : "\n         * Gets the state of the auto-white balance lock. Applications should\n         * check {@link #isAutoWhiteBalanceLockSupported} before using this\n         * method. See {@link #setAutoWhiteBalanceLock} for details about the\n         * lock.\n         *\n         * @return State of the auto-white balance lock. Returns true if\n         *         auto-white balance is currently locked, and false\n         *         otherwise.\n         *\n         * @see #setAutoWhiteBalanceLock(boolean)\n         *\n         ",
    "links" : [ "#isAutoWhiteBalanceLockSupported", "#setAutoWhiteBalanceLock" ]
  }, {
    "name" : "public boolean isAutoWhiteBalanceLockSupported()",
    "returnType" : "boolean",
    "comment" : "\n         * Returns true if auto-white balance locking is supported. Applications\n         * should call this before trying to lock auto-white balance. See\n         * {@link #setAutoWhiteBalanceLock} for details about the lock.\n         *\n         * @return true if auto-white balance lock is supported.\n         * @see #setAutoWhiteBalanceLock(boolean)\n         *\n         ",
    "links" : [ "#setAutoWhiteBalanceLock" ]
  }, {
    "name" : "public int getZoom()",
    "returnType" : "int",
    "comment" : "\n         * Gets current zoom value. This also works when smooth zoom is in\n         * progress. Applications should check {@link #isZoomSupported} before\n         * using this method.\n         *\n         * @return the current zoom value. The range is 0 to {@link\n         *         #getMaxZoom}. 0 means the camera is not zoomed.\n         ",
    "links" : [ "#getMaxZoom", "#isZoomSupported" ]
  }, {
    "name" : "public void setZoom(int value)",
    "returnType" : "void",
    "comment" : "\n         * Sets current zoom value. If the camera is zoomed (value > 0), the\n         * actual picture size may be smaller than picture size setting.\n         * Applications can check the actual picture size after picture is\n         * returned from {@link PictureCallback}. The preview size remains the\n         * same in zoom. Applications should check {@link #isZoomSupported}\n         * before using this method.\n         *\n         * @param value zoom value. The valid range is 0 to {@link #getMaxZoom}.\n         ",
    "links" : [ "PictureCallback", "#getMaxZoom", "#isZoomSupported" ]
  }, {
    "name" : "public boolean isZoomSupported()",
    "returnType" : "boolean",
    "comment" : "\n         * Returns true if zoom is supported. Applications should call this\n         * before using other zoom methods.\n         *\n         * @return true if zoom is supported.\n         ",
    "links" : [ ]
  }, {
    "name" : "public int getMaxZoom()",
    "returnType" : "int",
    "comment" : "\n         * Gets the maximum zoom value allowed for snapshot. This is the maximum\n         * value that applications can set to {@link #setZoom(int)}.\n         * Applications should call {@link #isZoomSupported} before using this\n         * method. This value may change in different preview size. Applications\n         * should call this again after setting preview size.\n         *\n         * @return the maximum zoom value supported by the camera.\n         ",
    "links" : [ "#setZoom(int)", "#isZoomSupported" ]
  }, {
    "name" : "public List<Integer> getZoomRatios()",
    "returnType" : "List<Integer>",
    "comment" : "\n         * Gets the zoom ratios of all zoom values. Applications should check\n         * {@link #isZoomSupported} before using this method.\n         *\n         * @return the zoom ratios in 1/100 increments. Ex: a zoom of 3.2x is\n         *         returned as 320. The number of elements is {@link\n         *         #getMaxZoom} + 1. The list is sorted from small to large. The\n         *         first element is always 100. The last element is the zoom\n         *         ratio of the maximum zoom value.\n         ",
    "links" : [ "#getMaxZoom", "#isZoomSupported" ]
  }, {
    "name" : "public boolean isSmoothZoomSupported()",
    "returnType" : "boolean",
    "comment" : "\n         * Returns true if smooth zoom is supported. Applications should call\n         * this before using other smooth zoom methods.\n         *\n         * @return true if smooth zoom is supported.\n         ",
    "links" : [ ]
  }, {
    "name" : "public void getFocusDistances(float[] output)",
    "returnType" : "void",
    "comment" : "\n         * <p>Gets the distances from the camera to where an object appears to be\n         * in focus. The object is sharpest at the optimal focus distance. The\n         * depth of field is the far focus distance minus near focus distance.</p>\n         *\n         * <p>Focus distances may change after calling {@link\n         * #autoFocus(AutoFocusCallback)}, {@link #cancelAutoFocus}, or {@link\n         * #startPreview()}. Applications can call {@link #getParameters()}\n         * and this method anytime to get the latest focus distances. If the\n         * focus mode is FOCUS_MODE_CONTINUOUS_VIDEO, focus distances may change\n         * from time to time.</p>\n         *\n         * <p>This method is intended to estimate the distance between the camera\n         * and the subject. After autofocus, the subject distance may be within\n         * near and far focus distance. However, the precision depends on the\n         * camera hardware, autofocus algorithm, the focus area, and the scene.\n         * The error can be large and it should be only used as a reference.</p>\n         *\n         * <p>Far focus distance >= optimal focus distance >= near focus distance.\n         * If the focus distance is infinity, the value will be\n         * {@code Float.POSITIVE_INFINITY}.</p>\n         *\n         * @param output focus distances in meters. output must be a float\n         *        array with three elements. Near focus distance, optimal focus\n         *        distance, and far focus distance will be filled in the array.\n         * @see #FOCUS_DISTANCE_NEAR_INDEX\n         * @see #FOCUS_DISTANCE_OPTIMAL_INDEX\n         * @see #FOCUS_DISTANCE_FAR_INDEX\n         ",
    "links" : [ "#cancelAutoFocus", "#startPreview()", "#autoFocus(AutoFocusCallback)", "#getParameters()" ]
  }, {
    "name" : "public int getMaxNumFocusAreas()",
    "returnType" : "int",
    "comment" : "\n         * Gets the maximum number of focus areas supported. This is the maximum\n         * length of the list in {@link #setFocusAreas(List)} and\n         * {@link #getFocusAreas()}.\n         *\n         * @return the maximum number of focus areas supported by the camera.\n         * @see #getFocusAreas()\n         ",
    "links" : [ "#setFocusAreas(List)", "#getFocusAreas()" ]
  }, {
    "name" : "public List<Area> getFocusAreas()",
    "returnType" : "List<Area>",
    "comment" : "\n         * <p>Gets the current focus areas. Camera driver uses the areas to decide\n         * focus.</p>\n         *\n         * <p>Before using this API or {@link #setFocusAreas(List)}, apps should\n         * call {@link #getMaxNumFocusAreas()} to know the maximum number of\n         * focus areas first. If the value is 0, focus area is not supported.</p>\n         *\n         * <p>Each focus area is a rectangle with specified weight. The direction\n         * is relative to the sensor orientation, that is, what the sensor sees.\n         * The direction is not affected by the rotation or mirroring of\n         * {@link #setDisplayOrientation(int)}. Coordinates of the rectangle\n         * range from -1000 to 1000. (-1000, -1000) is the upper left point.\n         * (1000, 1000) is the lower right point. The width and height of focus\n         * areas cannot be 0 or negative.</p>\n         *\n         * <p>The weight must range from 1 to 1000. The weight should be\n         * interpreted as a per-pixel weight - all pixels in the area have the\n         * specified weight. This means a small area with the same weight as a\n         * larger area will have less influence on the focusing than the larger\n         * area. Focus areas can partially overlap and the driver will add the\n         * weights in the overlap region.</p>\n         *\n         * <p>A special case of a {@code null} focus area list means the driver is\n         * free to select focus targets as it wants. For example, the driver may\n         * use more signals to select focus areas and change them\n         * dynamically. Apps can set the focus area list to {@code null} if they\n         * want the driver to completely control focusing.</p>\n         *\n         * <p>Focus areas are relative to the current field of view\n         * ({@link #getZoom()}). No matter what the zoom level is, (-1000,-1000)\n         * represents the top of the currently visible camera frame. The focus\n         * area cannot be set to be outside the current field of view, even\n         * when using zoom.</p>\n         *\n         * <p>Focus area only has effect if the current focus mode is\n         * {@link #FOCUS_MODE_AUTO}, {@link #FOCUS_MODE_MACRO},\n         * {@link #FOCUS_MODE_CONTINUOUS_VIDEO}, or\n         * {@link #FOCUS_MODE_CONTINUOUS_PICTURE}.</p>\n         *\n         * @return a list of current focus areas\n         ",
    "links" : [ "#FOCUS_MODE_AUTO", "#setFocusAreas(List)", "#FOCUS_MODE_CONTINUOUS_VIDEO", "#getZoom()", "#getMaxNumFocusAreas()", "#setDisplayOrientation(int)", "#FOCUS_MODE_MACRO", "#FOCUS_MODE_CONTINUOUS_PICTURE" ]
  }, {
    "name" : "public void setFocusAreas(List<Area> focusAreas)",
    "returnType" : "void",
    "comment" : "\n         * Sets focus areas. See {@link #getFocusAreas()} for documentation.\n         *\n         * @param focusAreas the focus areas\n         * @see #getFocusAreas()\n         ",
    "links" : [ "#getFocusAreas()" ]
  }, {
    "name" : "public int getMaxNumMeteringAreas()",
    "returnType" : "int",
    "comment" : "\n         * Gets the maximum number of metering areas supported. This is the\n         * maximum length of the list in {@link #setMeteringAreas(List)} and\n         * {@link #getMeteringAreas()}.\n         *\n         * @return the maximum number of metering areas supported by the camera.\n         * @see #getMeteringAreas()\n         ",
    "links" : [ "#setMeteringAreas(List)", "#getMeteringAreas()" ]
  }, {
    "name" : "public List<Area> getMeteringAreas()",
    "returnType" : "List<Area>",
    "comment" : "\n         * <p>Gets the current metering areas. Camera driver uses these areas to\n         * decide exposure.</p>\n         *\n         * <p>Before using this API or {@link #setMeteringAreas(List)}, apps should\n         * call {@link #getMaxNumMeteringAreas()} to know the maximum number of\n         * metering areas first. If the value is 0, metering area is not\n         * supported.</p>\n         *\n         * <p>Each metering area is a rectangle with specified weight. The\n         * direction is relative to the sensor orientation, that is, what the\n         * sensor sees. The direction is not affected by the rotation or\n         * mirroring of {@link #setDisplayOrientation(int)}. Coordinates of the\n         * rectangle range from -1000 to 1000. (-1000, -1000) is the upper left\n         * point. (1000, 1000) is the lower right point. The width and height of\n         * metering areas cannot be 0 or negative.</p>\n         *\n         * <p>The weight must range from 1 to 1000, and represents a weight for\n         * every pixel in the area. This means that a large metering area with\n         * the same weight as a smaller area will have more effect in the\n         * metering result.  Metering areas can partially overlap and the driver\n         * will add the weights in the overlap region.</p>\n         *\n         * <p>A special case of a {@code null} metering area list means the driver\n         * is free to meter as it chooses. For example, the driver may use more\n         * signals to select metering areas and change them dynamically. Apps\n         * can set the metering area list to {@code null} if they want the\n         * driver to completely control metering.</p>\n         *\n         * <p>Metering areas are relative to the current field of view\n         * ({@link #getZoom()}). No matter what the zoom level is, (-1000,-1000)\n         * represents the top of the currently visible camera frame. The\n         * metering area cannot be set to be outside the current field of view,\n         * even when using zoom.</p>\n         *\n         * <p>No matter what metering areas are, the final exposure are compensated\n         * by {@link #setExposureCompensation(int)}.</p>\n         *\n         * @return a list of current metering areas\n         ",
    "links" : [ "#setMeteringAreas(List)", "#getZoom()", "#getMaxNumMeteringAreas()", "#setDisplayOrientation(int)", "#setExposureCompensation(int)" ]
  }, {
    "name" : "public void setMeteringAreas(List<Area> meteringAreas)",
    "returnType" : "void",
    "comment" : "\n         * Sets metering areas. See {@link #getMeteringAreas()} for\n         * documentation.\n         *\n         * @param meteringAreas the metering areas\n         * @see #getMeteringAreas()\n         ",
    "links" : [ "#getMeteringAreas()" ]
  }, {
    "name" : "public int getMaxNumDetectedFaces()",
    "returnType" : "int",
    "comment" : "\n         * Gets the maximum number of detected faces supported. This is the\n         * maximum length of the list returned from {@link FaceDetectionListener}.\n         * If the return value is 0, face detection of the specified type is not\n         * supported.\n         *\n         * @return the maximum number of detected face supported by the camera.\n         * @see #startFaceDetection()\n         ",
    "links" : [ "FaceDetectionListener" ]
  }, {
    "name" : "public void setRecordingHint(boolean hint)",
    "returnType" : "void",
    "comment" : "\n         * Sets recording mode hint. This tells the camera that the intent of\n         * the application is to record videos {@link\n         * android.media.MediaRecorder#start()}, not to take still pictures\n         * {@link #takePicture(Camera.ShutterCallback, Camera.PictureCallback,\n         * Camera.PictureCallback, Camera.PictureCallback)}. Using this hint can\n         * allow MediaRecorder.start() to start faster or with fewer glitches on\n         * output. This should be called before starting preview for the best\n         * result, but can be changed while the preview is active. The default\n         * value is false.\n         *\n         * The app can still call takePicture() when the hint is true or call\n         * MediaRecorder.start() when the hint is false. But the performance may\n         * be worse.\n         *\n         * @param hint true if the apps intend to record videos using\n         *             {@link android.media.MediaRecorder}.\n         ",
    "links" : [ "#takePicture(Camera.ShutterCallback", "android.media.MediaRecorder#start()", "android.media.MediaRecorder" ]
  }, {
    "name" : "public boolean isVideoSnapshotSupported()",
    "returnType" : "boolean",
    "comment" : "\n         * <p>Returns true if video snapshot is supported. That is, applications\n         * can call {@link #takePicture(Camera.ShutterCallback,\n         * Camera.PictureCallback, Camera.PictureCallback,\n         * Camera.PictureCallback)} during recording. Applications do not need\n         * to call {@link #startPreview()} after taking a picture. The preview\n         * will be still active. Other than that, taking a picture during\n         * recording is identical to taking a picture normally. All settings and\n         * methods related to takePicture work identically. Ex:\n         * {@link #getPictureSize()}, {@link #getSupportedPictureSizes()},\n         * {@link #setJpegQuality(int)}, {@link #setRotation(int)}, and etc. The\n         * picture will have an EXIF header. {@link #FLASH_MODE_AUTO} and\n         * {@link #FLASH_MODE_ON} also still work, but the video will record the\n         * flash.</p>\n         *\n         * <p>Applications can set shutter callback as null to avoid the shutter\n         * sound. It is also recommended to set raw picture and post view\n         * callbacks to null to avoid the interrupt of preview display.</p>\n         *\n         * <p>Field-of-view of the recorded video may be different from that of the\n         * captured pictures. The maximum size of a video snapshot may be\n         * smaller than that for regular still captures. If the current picture\n         * size is set higher than can be supported by video snapshot, the\n         * picture will be captured at the maximum supported size instead.</p>\n         *\n         * @return true if video snapshot is supported.\n         ",
    "links" : [ "#takePicture(Camera.ShutterCallback", "#getSupportedPictureSizes()", "#FLASH_MODE_AUTO", "#startPreview()", "#setJpegQuality(int)", "#FLASH_MODE_ON", "#setRotation(int)", "#getPictureSize()" ]
  }, {
    "name" : "public void setVideoStabilization(boolean toggle)",
    "returnType" : "void",
    "comment" : "\n         * <p>Enables and disables video stabilization. Use\n         * {@link #isVideoStabilizationSupported} to determine if calling this\n         * method is valid.</p>\n         *\n         * <p>Video stabilization reduces the shaking due to the motion of the\n         * camera in both the preview stream and in recorded videos, including\n         * data received from the preview callback. It does not reduce motion\n         * blur in images captured with\n         * {@link Camera#takePicture takePicture}.</p>\n         *\n         * <p>Video stabilization can be enabled and disabled while preview or\n         * recording is active, but toggling it may cause a jump in the video\n         * stream that may be undesirable in a recorded video.</p>\n         *\n         * @param toggle Set to true to enable video stabilization, and false to\n         * disable video stabilization.\n         * @see #isVideoStabilizationSupported()\n         * @see #getVideoStabilization()\n         ",
    "links" : [ "#isVideoStabilizationSupported", "android.hardware.Camera#takePicture" ]
  }, {
    "name" : "public boolean getVideoStabilization()",
    "returnType" : "boolean",
    "comment" : "\n         * Get the current state of video stabilization. See\n         * {@link #setVideoStabilization} for details of video stabilization.\n         *\n         * @return true if video stabilization is enabled\n         * @see #isVideoStabilizationSupported()\n         * @see #setVideoStabilization(boolean)\n         ",
    "links" : [ "#setVideoStabilization" ]
  }, {
    "name" : "public boolean isVideoStabilizationSupported()",
    "returnType" : "boolean",
    "comment" : "\n         * Returns true if video stabilization is supported. See\n         * {@link #setVideoStabilization} for details of video stabilization.\n         *\n         * @return true if video stabilization is supported\n         * @see #setVideoStabilization(boolean)\n         * @see #getVideoStabilization()\n         ",
    "links" : [ "#setVideoStabilization" ]
  }, {
    "name" : "private ArrayList<String> split(String str)",
    "returnType" : "ArrayList<String>",
    "comment" : " Return null if the passing string is null or the size is 0.",
    "links" : [ ]
  }, {
    "name" : "private ArrayList<Integer> splitInt(String str)",
    "returnType" : "ArrayList<Integer>",
    "comment" : " Return null if the passing string is null or the size is 0.",
    "links" : [ ]
  }, {
    "name" : "private void splitInt(String str, int[] output)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void splitFloat(String str, float[] output)",
    "returnType" : "void",
    "comment" : " Splits a comma delimited string to an ArrayList of Float.",
    "links" : [ ]
  }, {
    "name" : "private float getFloat(String key, float defaultValue)",
    "returnType" : "float",
    "comment" : " Returns the value of a float parameter.",
    "links" : [ ]
  }, {
    "name" : "private int getInt(String key, int defaultValue)",
    "returnType" : "int",
    "comment" : " Returns the value of a integer parameter.",
    "links" : [ ]
  }, {
    "name" : "private ArrayList<Size> splitSize(String str)",
    "returnType" : "ArrayList<Size>",
    "comment" : " Return null if the passing string is null or the size is 0.",
    "links" : [ ]
  }, {
    "name" : "private Size strToSize(String str)",
    "returnType" : "Size",
    "comment" : " Return null if the passing string is null.",
    "links" : [ ]
  }, {
    "name" : "private ArrayList<int[]> splitRange(String str)",
    "returnType" : "ArrayList<int[]>",
    "comment" : " passing string is null or the size is 0.",
    "links" : [ ]
  }, {
    "name" : "private ArrayList<Area> splitArea(String str)",
    "returnType" : "ArrayList<Area>",
    "comment" : " the passing string is null or the size is 0 or (0,0,0,0,0).",
    "links" : [ ]
  }, {
    "name" : "private boolean same(String s1, String s2)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ "public void copyFrom(Parameters other)", "private Camera getOuter()", "public boolean same(Parameters other)", "public void dump()", "public String flatten()", "public void unflatten(String flattened)", "public void remove(String key)", "public void set(String key, String value)", "public void set(String key, int value)", "private void put(String key, String value)", "private void set(String key, List<Area> areas)", "public String get(String key)", "public int getInt(String key)", "public void setPreviewSize(int width, int height)", "public Size getPreviewSize()", "public List<Size> getSupportedPreviewSizes()", "public List<Size> getSupportedVideoSizes()", "public Size getPreferredPreviewSizeForVideo()", "public void setJpegThumbnailSize(int width, int height)", "public Size getJpegThumbnailSize()", "public List<Size> getSupportedJpegThumbnailSizes()", "public void setJpegThumbnailQuality(int quality)", "public int getJpegThumbnailQuality()", "public void setJpegQuality(int quality)", "public int getJpegQuality()", "public void setPreviewFrameRate(int fps)", "public int getPreviewFrameRate()", "public List<Integer> getSupportedPreviewFrameRates()", "public void setPreviewFpsRange(int min, int max)", "public void getPreviewFpsRange(int[] range)", "public List<int[]> getSupportedPreviewFpsRange()", "public void setPreviewFormat(int pixel_format)", "public int getPreviewFormat()", "public List<Integer> getSupportedPreviewFormats()", "public void setPictureSize(int width, int height)", "public Size getPictureSize()", "public List<Size> getSupportedPictureSizes()", "public void setPictureFormat(int pixel_format)", "public int getPictureFormat()", "public List<Integer> getSupportedPictureFormats()", "private String cameraFormatForPixelFormat(int pixel_format)", "private int pixelFormatForCameraFormat(String format)", "public void setRotation(int rotation)", "public void setGpsLatitude(double latitude)", "public void setGpsLongitude(double longitude)", "public void setGpsAltitude(double altitude)", "public void setGpsTimestamp(long timestamp)", "public void setGpsProcessingMethod(String processing_method)", "public void removeGpsData()", "public String getWhiteBalance()", "public void setWhiteBalance(String value)", "public List<String> getSupportedWhiteBalance()", "public String getColorEffect()", "public void setColorEffect(String value)", "public List<String> getSupportedColorEffects()", "public String getAntibanding()", "public void setAntibanding(String antibanding)", "public List<String> getSupportedAntibanding()", "public String getSceneMode()", "public void setSceneMode(String value)", "public List<String> getSupportedSceneModes()", "public String getFlashMode()", "public void setFlashMode(String value)", "public List<String> getSupportedFlashModes()", "public String getFocusMode()", "public void setFocusMode(String value)", "public List<String> getSupportedFocusModes()", "public float getFocalLength()", "public float getHorizontalViewAngle()", "public float getVerticalViewAngle()", "public int getExposureCompensation()", "public void setExposureCompensation(int value)", "public int getMaxExposureCompensation()", "public int getMinExposureCompensation()", "public float getExposureCompensationStep()", "public void setAutoExposureLock(boolean toggle)", "public boolean getAutoExposureLock()", "public boolean isAutoExposureLockSupported()", "public void setAutoWhiteBalanceLock(boolean toggle)", "public boolean getAutoWhiteBalanceLock()", "public boolean isAutoWhiteBalanceLockSupported()", "public int getZoom()", "public void setZoom(int value)", "public boolean isZoomSupported()", "public int getMaxZoom()", "public List<Integer> getZoomRatios()", "public boolean isSmoothZoomSupported()", "public void getFocusDistances(float[] output)", "public int getMaxNumFocusAreas()", "public List<Area> getFocusAreas()", "public void setFocusAreas(List<Area> focusAreas)", "public int getMaxNumMeteringAreas()", "public List<Area> getMeteringAreas()", "public void setMeteringAreas(List<Area> meteringAreas)", "public int getMaxNumDetectedFaces()", "public void setRecordingHint(boolean hint)", "public boolean isVideoSnapshotSupported()", "public void setVideoStabilization(boolean toggle)", "public boolean getVideoStabilization()", "public boolean isVideoStabilizationSupported()", "private ArrayList<String> split(String str)", "private ArrayList<Integer> splitInt(String str)", "private void splitInt(String str, int[] output)", "private void splitFloat(String str, float[] output)", "private float getFloat(String key, float defaultValue)", "private int getInt(String key, int defaultValue)", "private ArrayList<Size> splitSize(String str)", "private Size strToSize(String str)", "private ArrayList<int[]> splitRange(String str)", "private ArrayList<Area> splitArea(String str)", "private boolean same(String s1, String s2)" ],
  "variableNames" : [ "KEY_PREVIEW_SIZE", "KEY_PREVIEW_FORMAT", "KEY_PREVIEW_FRAME_RATE", "KEY_PREVIEW_FPS_RANGE", "KEY_PICTURE_SIZE", "KEY_PICTURE_FORMAT", "KEY_JPEG_THUMBNAIL_SIZE", "KEY_JPEG_THUMBNAIL_WIDTH", "KEY_JPEG_THUMBNAIL_HEIGHT", "KEY_JPEG_THUMBNAIL_QUALITY", "KEY_JPEG_QUALITY", "KEY_ROTATION", "KEY_GPS_LATITUDE", "KEY_GPS_LONGITUDE", "KEY_GPS_ALTITUDE", "KEY_GPS_TIMESTAMP", "KEY_GPS_PROCESSING_METHOD", "KEY_WHITE_BALANCE", "KEY_EFFECT", "KEY_ANTIBANDING", "KEY_SCENE_MODE", "KEY_FLASH_MODE", "KEY_FOCUS_MODE", "KEY_FOCUS_AREAS", "KEY_MAX_NUM_FOCUS_AREAS", "KEY_FOCAL_LENGTH", "KEY_HORIZONTAL_VIEW_ANGLE", "KEY_VERTICAL_VIEW_ANGLE", "KEY_EXPOSURE_COMPENSATION", "KEY_MAX_EXPOSURE_COMPENSATION", "KEY_MIN_EXPOSURE_COMPENSATION", "KEY_EXPOSURE_COMPENSATION_STEP", "KEY_AUTO_EXPOSURE_LOCK", "KEY_AUTO_EXPOSURE_LOCK_SUPPORTED", "KEY_AUTO_WHITEBALANCE_LOCK", "KEY_AUTO_WHITEBALANCE_LOCK_SUPPORTED", "KEY_METERING_AREAS", "KEY_MAX_NUM_METERING_AREAS", "KEY_ZOOM", "KEY_MAX_ZOOM", "KEY_ZOOM_RATIOS", "KEY_ZOOM_SUPPORTED", "KEY_SMOOTH_ZOOM_SUPPORTED", "KEY_FOCUS_DISTANCES", "KEY_VIDEO_SIZE", "KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO", "KEY_MAX_NUM_DETECTED_FACES_HW", "KEY_MAX_NUM_DETECTED_FACES_SW", "KEY_RECORDING_HINT", "KEY_VIDEO_SNAPSHOT_SUPPORTED", "KEY_VIDEO_STABILIZATION", "KEY_VIDEO_STABILIZATION_SUPPORTED", "SUPPORTED_VALUES_SUFFIX", "TRUE", "FALSE", "WHITE_BALANCE_AUTO", "WHITE_BALANCE_INCANDESCENT", "WHITE_BALANCE_FLUORESCENT", "WHITE_BALANCE_WARM_FLUORESCENT", "WHITE_BALANCE_DAYLIGHT", "WHITE_BALANCE_CLOUDY_DAYLIGHT", "WHITE_BALANCE_TWILIGHT", "WHITE_BALANCE_SHADE", "EFFECT_NONE", "EFFECT_MONO", "EFFECT_NEGATIVE", "EFFECT_SOLARIZE", "EFFECT_SEPIA", "EFFECT_POSTERIZE", "EFFECT_WHITEBOARD", "EFFECT_BLACKBOARD", "EFFECT_AQUA", "ANTIBANDING_AUTO", "ANTIBANDING_50HZ", "ANTIBANDING_60HZ", "ANTIBANDING_OFF", "FLASH_MODE_OFF", "FLASH_MODE_AUTO", "FLASH_MODE_ON", "FLASH_MODE_RED_EYE", "FLASH_MODE_TORCH", "SCENE_MODE_AUTO", "SCENE_MODE_ACTION", "SCENE_MODE_PORTRAIT", "SCENE_MODE_LANDSCAPE", "SCENE_MODE_NIGHT", "SCENE_MODE_NIGHT_PORTRAIT", "SCENE_MODE_THEATRE", "SCENE_MODE_BEACH", "SCENE_MODE_SNOW", "SCENE_MODE_SUNSET", "SCENE_MODE_STEADYPHOTO", "SCENE_MODE_FIREWORKS", "SCENE_MODE_SPORTS", "SCENE_MODE_PARTY", "SCENE_MODE_CANDLELIGHT", "SCENE_MODE_BARCODE", "SCENE_MODE_HDR", "FOCUS_MODE_AUTO", "FOCUS_MODE_INFINITY", "FOCUS_MODE_MACRO", "FOCUS_MODE_FIXED", "FOCUS_MODE_EDOF", "FOCUS_MODE_CONTINUOUS_VIDEO", "FOCUS_MODE_CONTINUOUS_PICTURE", "FOCUS_DISTANCE_NEAR_INDEX", "FOCUS_DISTANCE_OPTIMAL_INDEX", "FOCUS_DISTANCE_FAR_INDEX", "PREVIEW_FPS_MIN_INDEX", "PREVIEW_FPS_MAX_INDEX", "PIXEL_FORMAT_YUV422SP", "PIXEL_FORMAT_YUV420SP", "PIXEL_FORMAT_YUV422I", "PIXEL_FORMAT_YUV420P", "PIXEL_FORMAT_RGB565", "PIXEL_FORMAT_JPEG", "PIXEL_FORMAT_BAYER_RGGB", "mMap" ]
}