{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/renderscript/ScriptIntrinsicBLAS.java",
  "packageName" : "android.renderscript",
  "className" : "ScriptIntrinsicBLAS",
  "comment" : "\n *\n * ScriptIntrinsicBLAS class provides high performance RenderScript APIs to BLAS.\n *\n * The BLAS (Basic Linear Algebra Subprograms) are routines that provide standard\n * building blocks for performing basic vector and matrix operations.\n *\n * For detailed description of BLAS, please refer to http://www.netlib.org/blas/\n *\n *",
  "variables" : [ {
    "name" : "mLUT",
    "type" : "Allocation",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_sdsdot",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dsdot",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_sdot",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_ddot",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_cdotu_sub",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_cdotc_sub",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_zdotu_sub",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_zdotc_sub",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_snrm2",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_sasum",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dnrm2",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dasum",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_scnrm2",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_scasum",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dznrm2",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dzasum",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_isamax",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_idamax",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_icamax",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_izamax",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_sswap",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_scopy",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_saxpy",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dswap",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dcopy",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_daxpy",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_cswap",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_ccopy",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_caxpy",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_zswap",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_zcopy",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_zaxpy",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_srotg",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_srotmg",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_srot",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_srotm",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_drotg",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_drotmg",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_drot",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_drotm",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_sscal",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dscal",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_cscal",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_zscal",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_csscal",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_zdscal",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_sgemv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_sgbmv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_strmv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_stbmv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_stpmv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_strsv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_stbsv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_stpsv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dgemv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dgbmv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dtrmv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dtbmv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dtpmv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dtrsv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dtbsv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dtpsv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_cgemv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_cgbmv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_ctrmv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_ctbmv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_ctpmv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_ctrsv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_ctbsv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_ctpsv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_zgemv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_zgbmv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_ztrmv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_ztbmv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_ztpmv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_ztrsv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_ztbsv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_ztpsv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_ssymv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_ssbmv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_sspmv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_sger",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_ssyr",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_sspr",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_ssyr2",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_sspr2",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dsymv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dsbmv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dspmv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dger",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dsyr",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dspr",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dsyr2",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dspr2",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_chemv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_chbmv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_chpmv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_cgeru",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_cgerc",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_cher",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_chpr",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_cher2",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_chpr2",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_zhemv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_zhbmv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_zhpmv",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_zgeru",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_zgerc",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_zher",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_zhpr",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_zher2",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_zhpr2",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_sgemm",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_ssymm",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_ssyrk",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_ssyr2k",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_strmm",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_strsm",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dgemm",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dsymm",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dsyrk",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dsyr2k",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dtrmm",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_dtrsm",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_cgemm",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_csymm",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_csyrk",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_csyr2k",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_ctrmm",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_ctrsm",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_zgemm",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_zsymm",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_zsyrk",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_zsyr2k",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_ztrmm",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_ztrsm",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_chemm",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_cherk",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_cher2k",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_zhemm",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_zherk",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_zher2k",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RsBlas_bnnm",
    "type" : "int",
    "comment" : " BLAS extensions start here",
    "links" : [ ]
  }, {
    "name" : "NO_TRANSPOSE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TRANSPOSE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CONJ_TRANSPOSE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "UPPER",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LOWER",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NON_UNIT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "UNIT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LEFT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RIGHT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static ScriptIntrinsicBLAS create(RenderScript rs)",
    "returnType" : "ScriptIntrinsicBLAS",
    "comment" : "\n     * Create an intrinsic to access BLAS subroutines.\n     *\n     * @param rs The RenderScript context\n     * @return ScriptIntrinsicBLAS\n     ",
    "links" : [ ]
  }, {
    "name" : " static void validateSide(@Side int Side)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static void validateTranspose(@Transpose int Trans)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static void validateConjTranspose(@Transpose int Trans)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static void validateDiag(@Diag int Diag)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static void validateUplo(@Uplo int Uplo)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static void validateGEMV(Element e, int TransA, Allocation A, Allocation X, int incX, Allocation Y, int incY)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void SGEMV(@Transpose int TransA, float alpha, Allocation A, Allocation X, int incX, float beta, Allocation Y, int incY)",
    "returnType" : "void",
    "comment" : "\n     * SGEMV performs one of the matrix-vector operations\n     * y := alpha*A*x + beta*y   or   y := alpha*A**T*x + beta*y\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/db/d58/sgemv_8f.html\n     *\n     * @param TransA The type of transpose applied to matrix A.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param beta The scalar beta.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F32}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F32" ]
  }, {
    "name" : "public void DGEMV(@Transpose int TransA, double alpha, Allocation A, Allocation X, int incX, double beta, Allocation Y, int incY)",
    "returnType" : "void",
    "comment" : "\n     * DGEMV performs one of the matrix-vector operations\n     * y := alpha*A*x + beta*y   or   y := alpha*A**T*x + beta*y\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/dc/da8/dgemv_8f.html\n     *\n     * @param TransA The type of transpose applied to matrix A.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param beta The scalar beta.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F64}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F64" ]
  }, {
    "name" : "public void CGEMV(@Transpose int TransA, Float2 alpha, Allocation A, Allocation X, int incX, Float2 beta, Allocation Y, int incY)",
    "returnType" : "void",
    "comment" : "\n     * CGEMV performs one of the matrix-vector operations\n     * y := alpha*A*x + beta*y   or   y := alpha*A**T*x + beta*y   or   y := alpha*A**H*x + beta*y\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d4/d8a/cgemv_8f.html\n     *\n     * @param TransA The type of transpose applied to matrix A.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32_2}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param beta The scalar beta.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F32_2}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void ZGEMV(@Transpose int TransA, Double2 alpha, Allocation A, Allocation X, int incX, Double2 beta, Allocation Y, int incY)",
    "returnType" : "void",
    "comment" : "\n     * ZGEMV performs one of the matrix-vector operations\n     * y := alpha*A*x + beta*y   or   y := alpha*A**T*x + beta*y   or   y := alpha*A**H*x + beta*y\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/db/d40/zgemv_8f.html\n     *\n     * @param TransA The type of transpose applied to matrix A.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64_2}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param beta The scalar beta.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F64_2}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : "public void SGBMV(@Transpose int TransA, int KL, int KU, float alpha, Allocation A, Allocation X, int incX, float beta, Allocation Y, int incY)",
    "returnType" : "void",
    "comment" : "\n     * SGBMV performs one of the matrix-vector operations\n     * y := alpha*A*x + beta*y   or   y := alpha*A**T*x + beta*y\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d6/d46/sgbmv_8f.html\n     *\n     * Note: For a M*N matrix, the input Allocation should also be of size M*N (dimY = M, dimX = N),\n     *       but only the region M*(KL+KU+1) will be referenced. The following subroutine can is an\n     *       example showing how to convert the original matrix 'a' to row-based band matrix 'b'.\n     *           for i in range(0, m):\n     *              for j in range(max(0, i-kl), min(i+ku+1, n)):\n     *                  b[i, j-i+kl] = a[i, j]\n     *\n     * @param TransA The type of transpose applied to matrix A.\n     * @param KL The number of sub-diagonals of the matrix A.\n     * @param KU The number of super-diagonals of the matrix A.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains the band matrix A, supported elements type {@link Element#F32}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param beta The scalar beta.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F32}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F32" ]
  }, {
    "name" : "public void DGBMV(@Transpose int TransA, int KL, int KU, double alpha, Allocation A, Allocation X, int incX, double beta, Allocation Y, int incY)",
    "returnType" : "void",
    "comment" : "\n     * DGBMV performs one of the matrix-vector operations\n     * y := alpha*A*x + beta*y   or   y := alpha*A**T*x + beta*y\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d2/d3f/dgbmv_8f.html\n     *\n     * Note: For a M*N matrix, the input Allocation should also be of size M*N (dimY = M, dimX = N),\n     *       but only the region M*(KL+KU+1) will be referenced. The following subroutine can is an\n     *       example showing how to convert the original matrix 'a' to row-based band matrix 'b'.\n     *           for i in range(0, m):\n     *              for j in range(max(0, i-kl), min(i+ku+1, n)):\n     *                  b[i, j-i+kl] = a[i, j]\n     *\n     * @param TransA The type of transpose applied to matrix A.\n     * @param KL The number of sub-diagonals of the matrix A.\n     * @param KU The number of super-diagonals of the matrix A.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains the band matrix A, supported elements type {@link Element#F64}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param beta The scalar beta.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F64}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F64" ]
  }, {
    "name" : "public void CGBMV(@Transpose int TransA, int KL, int KU, Float2 alpha, Allocation A, Allocation X, int incX, Float2 beta, Allocation Y, int incY)",
    "returnType" : "void",
    "comment" : "\n     * CGBMV performs one of the matrix-vector operations\n     * y := alpha*A*x + beta*y   or   y := alpha*A**T*x + beta*y   or   y := alpha*A**H*x + beta*y\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d0/d75/cgbmv_8f.html\n     *\n     * Note: For a M*N matrix, the input Allocation should also be of size M*N (dimY = M, dimX = N),\n     *       but only the region M*(KL+KU+1) will be referenced. The following subroutine can is an\n     *       example showing how to convert the original matrix 'a' to row-based band matrix 'b'.\n     *           for i in range(0, m):\n     *              for j in range(max(0, i-kl), min(i+ku+1, n)):\n     *                  b[i, j-i+kl] = a[i, j]\n     *\n     * @param TransA The type of transpose applied to matrix A.\n     * @param KL The number of sub-diagonals of the matrix A.\n     * @param KU The number of super-diagonals of the matrix A.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains the band matrix A, supported elements type {@link Element#F32_2}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param beta The scalar beta.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F32_2}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void ZGBMV(@Transpose int TransA, int KL, int KU, Double2 alpha, Allocation A, Allocation X, int incX, Double2 beta, Allocation Y, int incY)",
    "returnType" : "void",
    "comment" : "\n     * ZGBMV performs one of the matrix-vector operations\n     * y := alpha*A*x + beta*y   or   y := alpha*A**T*x + beta*y   or   y := alpha*A**H*x + beta*y\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d9/d46/zgbmv_8f.html\n     *\n     * Note: For a M*N matrix, the input Allocation should also be of size M*N (dimY = M, dimX = N),\n     *       but only the region M*(KL+KU+1) will be referenced. The following subroutine can is an\n     *       example showing how to convert the original matrix 'a' to row-based band matrix 'b'.\n     *           for i in range(0, m):\n     *              for j in range(max(0, i-kl), min(i+ku+1, n)):\n     *                  b[i, j-i+kl] = a[i, j]\n     *\n     * @param TransA The type of transpose applied to matrix A.\n     * @param KL The number of sub-diagonals of the matrix A.\n     * @param KU The number of super-diagonals of the matrix A.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains the band matrix A, supported elements type {@link Element#F64_2}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param beta The scalar beta.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F64_2}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : " static void validateTRMV(Element e, @Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation A, Allocation X, int incX)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static int validateTPMV(Element e, @Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation Ap, Allocation X, int incX)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void STRMV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation A, Allocation X, int incX)",
    "returnType" : "void",
    "comment" : "\n     * STRMV performs one of the matrix-vector operations\n     * x := A*x   or   x := A**T*x\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/de/d45/strmv_8f.html\n     *\n     * @param Uplo Specifies whether the matrix is an upper or lower triangular matrix.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F32" ]
  }, {
    "name" : "public void DTRMV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation A, Allocation X, int incX)",
    "returnType" : "void",
    "comment" : "\n     * DTRMV performs one of the matrix-vector operations\n     * x := A*x   or   x := A**T*x\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/dc/d7e/dtrmv_8f.html\n     *\n     * @param Uplo Specifies whether the matrix is an upper or lower triangular matrix.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F64" ]
  }, {
    "name" : "public void CTRMV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation A, Allocation X, int incX)",
    "returnType" : "void",
    "comment" : "\n     * CTRMV performs one of the matrix-vector operations\n     * x := A*x   or   x := A**T*x   or   x := A**H*x\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/df/d78/ctrmv_8f.html\n     *\n     * @param Uplo Specifies whether the matrix is an upper or lower triangular matrix.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32_2}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void ZTRMV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation A, Allocation X, int incX)",
    "returnType" : "void",
    "comment" : "\n     * ZTRMV performs one of the matrix-vector operations\n     * x := A*x   or   x := A**T*x   or   x := A**H*x\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d0/dd1/ztrmv_8f.html\n     *\n     * @param Uplo Specifies whether the matrix is an upper or lower triangular matrix.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64_2}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : "public void STBMV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, int K, Allocation A, Allocation X, int incX)",
    "returnType" : "void",
    "comment" : "\n     * STBMV performs one of the matrix-vector operations\n     * x := A*x   or   x := A**T*x\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d6/d7d/stbmv_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should also be of size N*N (dimY = N, dimX = N),\n     *       but only the region N*(K+1) will be referenced. The following subroutine can is an\n     *       example showing how to convert a UPPER trianglar matrix 'a' to row-based band matrix 'b'.\n     *           for i in range(0, n):\n     *              for j in range(i, min(i+k+1, n)):\n     *                  b[i, j-i] = a[i, j]\n     *\n     * @param Uplo Specifies whether the matrix is an upper or lower triangular matrix.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param K The number of off-diagonals of the matrix A\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F32" ]
  }, {
    "name" : "public void DTBMV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, int K, Allocation A, Allocation X, int incX)",
    "returnType" : "void",
    "comment" : "\n     * DTBMV performs one of the matrix-vector operations\n     * x := A*x   or   x := A**T*x\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/df/d29/dtbmv_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should also be of size N*N (dimY = N, dimX = N),\n     *       but only the region N*(K+1) will be referenced. The following subroutine can is an\n     *       example showing how to convert a UPPER trianglar matrix 'a' to row-based band matrix 'b'.\n     *           for i in range(0, n):\n     *              for j in range(i, min(i+k+1, n)):\n     *                  b[i, j-i] = a[i, j]\n     *\n     * @param Uplo Specifies whether the matrix is an upper or lower triangular matrix.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param K The number of off-diagonals of the matrix A\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F64" ]
  }, {
    "name" : "public void CTBMV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, int K, Allocation A, Allocation X, int incX)",
    "returnType" : "void",
    "comment" : "\n     * CTBMV performs one of the matrix-vector operations\n     * x := A*x   or   x := A**T*x   or   x := A**H*x\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d3/dcd/ctbmv_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should also be of size N*N (dimY = N, dimX = N),\n     *       but only the region N*(K+1) will be referenced. The following subroutine can is an\n     *       example showing how to convert a UPPER trianglar matrix 'a' to row-based band matrix 'b'.\n     *           for i in range(0, n):\n     *              for j in range(i, min(i+k+1, n)):\n     *                  b[i, j-i] = a[i, j]\n     *\n     * @param Uplo Specifies whether the matrix is an upper or lower triangular matrix.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param K The number of off-diagonals of the matrix A\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32_2}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void ZTBMV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, int K, Allocation A, Allocation X, int incX)",
    "returnType" : "void",
    "comment" : "\n     * ZTBMV performs one of the matrix-vector operations\n     * x := A*x   or   x := A**T*x   or   x := A**H*x\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d3/d39/ztbmv_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should also be of size N*N (dimY = N, dimX = N),\n     *       but only the region N*(K+1) will be referenced. The following subroutine can is an\n     *       example showing how to convert a UPPER trianglar matrix 'a' to row-based band matrix 'b'.\n     *           for i in range(0, n):\n     *              for j in range(i, min(i+k+1, n)):\n     *                  b[i, j-i] = a[i, j]\n     *\n     * @param Uplo Specifies whether the matrix is an upper or lower triangular matrix.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param K The number of off-diagonals of the matrix A\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64_2}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : "public void STPMV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation Ap, Allocation X, int incX)",
    "returnType" : "void",
    "comment" : "\n     * STPMV performs one of the matrix-vector operations\n     * x := A*x   or   x := A**T*x\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/db/db1/stpmv_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,\n     *       The following subroutine can is an example showing how to convert a UPPER trianglar matrix\n     *       'a' to packed matrix 'b'.\n     *           k = 0\n     *           for i in range(0, n):\n     *              for j in range(i, n):\n     *                  b[k++] = a[i, j]\n     *\n     * @param Uplo Specifies whether the matrix is an upper or lower triangular matrix.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param Ap The input allocation contains packed matrix A, supported elements type {@link Element#F32}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F32" ]
  }, {
    "name" : "public void DTPMV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation Ap, Allocation X, int incX)",
    "returnType" : "void",
    "comment" : "\n     * DTPMV performs one of the matrix-vector operations\n     * x := A*x   or   x := A**T*x\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/dc/dcd/dtpmv_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,\n     *       The following subroutine can is an example showing how to convert a UPPER trianglar matrix\n     *       'a' to packed matrix 'b'.\n     *           k = 0\n     *           for i in range(0, n):\n     *              for j in range(i, n):\n     *                  b[k++] = a[i, j]\n     *\n     * @param Uplo Specifies whether the matrix is an upper or lower triangular matrix.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param Ap The input allocation contains packed matrix A, supported elements type {@link Element#F64}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F64" ]
  }, {
    "name" : "public void CTPMV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation Ap, Allocation X, int incX)",
    "returnType" : "void",
    "comment" : "\n     * CTPMV performs one of the matrix-vector operations\n     * x := A*x   or   x := A**T*x   or   x := A**H*x\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d4/dbb/ctpmv_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,\n     *       The following subroutine can is an example showing how to convert a UPPER trianglar matrix\n     *       'a' to packed matrix 'b'.\n     *           k = 0\n     *           for i in range(0, n):\n     *              for j in range(i, n):\n     *                  b[k++] = a[i, j]\n     *\n     * @param Uplo Specifies whether the matrix is an upper or lower triangular matrix.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param Ap The input allocation contains packed matrix A, supported elements type {@link Element#F32_2}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void ZTPMV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation Ap, Allocation X, int incX)",
    "returnType" : "void",
    "comment" : "\n     * ZTPMV performs one of the matrix-vector operations\n     * x := A*x   or   x := A**T*x   or   x := A**H*x\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d2/d9e/ztpmv_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,\n     *       The following subroutine can is an example showing how to convert a UPPER trianglar matrix\n     *       'a' to packed matrix 'b'.\n     *           k = 0\n     *           for i in range(0, n):\n     *              for j in range(i, n):\n     *                  b[k++] = a[i, j]\n     *\n     * @param Uplo Specifies whether the matrix is an upper or lower triangular matrix.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param Ap The input allocation contains packed matrix A, supported elements type {@link Element#F64_2}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : "public void STRSV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation A, Allocation X, int incX)",
    "returnType" : "void",
    "comment" : "\n     * STRSV solves one of the systems of equations\n     * A*x = b   or   A**T*x = b\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d0/d2a/strsv_8f.html\n     *\n     * @param Uplo Specifies whether the matrix is an upper or lower triangular matrix.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F32" ]
  }, {
    "name" : "public void DTRSV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation A, Allocation X, int incX)",
    "returnType" : "void",
    "comment" : "\n     * DTRSV solves one of the systems of equations\n     * A*x = b   or   A**T*x = b\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d6/d96/dtrsv_8f.html\n     *\n     * @param Uplo Specifies whether the matrix is an upper or lower triangular matrix.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F64" ]
  }, {
    "name" : "public void CTRSV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation A, Allocation X, int incX)",
    "returnType" : "void",
    "comment" : "\n     * CTRSV solves one of the systems of equations\n     * A*x = b   or   A**T*x = b   or   A**H*x = b\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d4/dc8/ctrsv_8f.html\n     *\n     * @param Uplo Specifies whether the matrix is an upper or lower triangular matrix.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32_2}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void ZTRSV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation A, Allocation X, int incX)",
    "returnType" : "void",
    "comment" : "\n     * ZTRSV solves one of the systems of equations\n     * A*x = b   or   A**T*x = b   or   A**H*x = b\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d1/d2f/ztrsv_8f.html\n     *\n     * @param Uplo Specifies whether the matrix is an upper or lower triangular matrix.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64_2}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : "public void STBSV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, int K, Allocation A, Allocation X, int incX)",
    "returnType" : "void",
    "comment" : "\n     * STBSV solves one of the systems of equations\n     * A*x = b   or   A**T*x = b\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d0/d1f/stbsv_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should also be of size N*N (dimY = N, dimX = N),\n     *       but only the region N*(K+1) will be referenced. The following subroutine can is an\n     *       example showing how to convert a UPPER trianglar matrix 'a' to row-based band matrix 'b'.\n     *           for i in range(0, n):\n     *              for j in range(i, min(i+k+1, n)):\n     *                  b[i, j-i] = a[i, j]\n     *\n     * @param Uplo Specifies whether the matrix is an upper or lower triangular matrix.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param K The number of off-diagonals of the matrix A\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F32" ]
  }, {
    "name" : "public void DTBSV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, int K, Allocation A, Allocation X, int incX)",
    "returnType" : "void",
    "comment" : "\n     * DTBSV solves one of the systems of equations\n     * A*x = b   or   A**T*x = b\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d4/dcf/dtbsv_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should also be of size N*N (dimY = N, dimX = N),\n     *       but only the region N*(K+1) will be referenced. The following subroutine can is an\n     *       example showing how to convert a UPPER trianglar matrix 'a' to row-based band matrix 'b'.\n     *           for i in range(0, n):\n     *              for j in range(i, min(i+k+1, n)):\n     *                  b[i, j-i] = a[i, j]\n     *\n     * @param Uplo Specifies whether the matrix is an upper or lower triangular matrix.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param K The number of off-diagonals of the matrix A\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F64" ]
  }, {
    "name" : "public void CTBSV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, int K, Allocation A, Allocation X, int incX)",
    "returnType" : "void",
    "comment" : "\n     * CTBSV solves one of the systems of equations\n     * A*x = b   or   A**T*x = b   or   A**H*x = b\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d9/d5f/ctbsv_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should also be of size N*N (dimY = N, dimX = N),\n     *       but only the region N*(K+1) will be referenced. The following subroutine can is an\n     *       example showing how to convert a UPPER trianglar matrix 'a' to row-based band matrix 'b'.\n     *           for i in range(0, n):\n     *              for j in range(i, min(i+k+1, n)):\n     *                  b[i, j-i] = a[i, j]\n     *\n     * @param Uplo Specifies whether the matrix is an upper or lower triangular matrix.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param K The number of off-diagonals of the matrix A\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32_2}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void ZTBSV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, int K, Allocation A, Allocation X, int incX)",
    "returnType" : "void",
    "comment" : "\n     * ZTBSV solves one of the systems of equations\n     * A*x = b   or   A**T*x = b   or   A**H*x = b\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d4/d5a/ztbsv_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should also be of size N*N (dimY = N, dimX = N),\n     *       but only the region N*(K+1) will be referenced. The following subroutine can is an\n     *       example showing how to convert a UPPER trianglar matrix 'a' to row-based band matrix 'b'.\n     *           for i in range(0, n):\n     *              for j in range(i, min(i+k+1, n)):\n     *                  b[i, j-i] = a[i, j]\n     *\n     * @param Uplo Specifies whether the matrix is an upper or lower triangular matrix.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param K The number of off-diagonals of the matrix A\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64_2}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : "public void STPSV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation Ap, Allocation X, int incX)",
    "returnType" : "void",
    "comment" : "\n     * STPSV solves one of the systems of equations\n     * A*x = b   or   A**T*x = b\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d0/d7c/stpsv_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,\n     *       The following subroutine can is an example showing how to convert a UPPER trianglar matrix\n     *       'a' to packed matrix 'b'.\n     *           k = 0\n     *           for i in range(0, n):\n     *              for j in range(i, n):\n     *                  b[k++] = a[i, j]\n     *\n     * @param Uplo Specifies whether the matrix is an upper or lower triangular matrix.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param Ap The input allocation contains packed matrix A, supported elements type {@link Element#F32}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F32" ]
  }, {
    "name" : "public void DTPSV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation Ap, Allocation X, int incX)",
    "returnType" : "void",
    "comment" : "\n     * DTPSV solves one of the systems of equations\n     * A*x = b   or   A**T*x = b\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d9/d84/dtpsv_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,\n     *       The following subroutine can is an example showing how to convert a UPPER trianglar matrix\n     *       'a' to packed matrix 'b'.\n     *           k = 0\n     *           for i in range(0, n):\n     *              for j in range(i, n):\n     *                  b[k++] = a[i, j]\n     *\n     * @param Uplo Specifies whether the matrix is an upper or lower triangular matrix.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param Ap The input allocation contains packed matrix A, supported elements type {@link Element#F64}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F64" ]
  }, {
    "name" : "public void CTPSV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation Ap, Allocation X, int incX)",
    "returnType" : "void",
    "comment" : "\n     * CTPSV solves one of the systems of equations\n     * A*x = b   or   A**T*x = b   or   A**H*x = b\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d8/d56/ctpsv_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,\n     *       The following subroutine can is an example showing how to convert a UPPER trianglar matrix\n     *       'a' to packed matrix 'b'.\n     *           k = 0\n     *           for i in range(0, n):\n     *              for j in range(i, n):\n     *                  b[k++] = a[i, j]\n     *\n     * @param Uplo Specifies whether the matrix is an upper or lower triangular matrix.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param Ap The input allocation contains packed matrix A, supported elements type {@link Element#F32_2}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void ZTPSV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation Ap, Allocation X, int incX)",
    "returnType" : "void",
    "comment" : "\n     * ZTPSV solves one of the systems of equations\n     * A*x = b   or   A**T*x = b   or   A**H*x = b\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/da/d57/ztpsv_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,\n     *       The following subroutine can is an example showing how to convert a UPPER trianglar matrix\n     *       'a' to packed matrix 'b'.\n     *           k = 0\n     *           for i in range(0, n):\n     *              for j in range(i, n):\n     *                  b[k++] = a[i, j]\n     *\n     * @param Uplo Specifies whether the matrix is an upper or lower triangular matrix.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param Ap The input allocation contains packed matrix A, supported elements type {@link Element#F64_2}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : " static int validateSYMV(Element e, @Uplo int Uplo, Allocation A, Allocation X, Allocation Y, int incX, int incY)",
    "returnType" : "int",
    "comment" : "\n     * Level 2, S and D only\n     ",
    "links" : [ ]
  }, {
    "name" : " static int validateSPMV(Element e, @Uplo int Uplo, Allocation Ap, Allocation X, int incX, Allocation Y, int incY)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static void validateGER(Element e, Allocation X, int incX, Allocation Y, int incY, Allocation A)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static int validateSYR(Element e, @Uplo int Uplo, Allocation X, int incX, Allocation A)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static int validateSPR(Element e, @Uplo int Uplo, Allocation X, int incX, Allocation Ap)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static int validateSYR2(Element e, @Uplo int Uplo, Allocation X, int incX, Allocation Y, int incY, Allocation A)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static int validateSPR2(Element e, @Uplo int Uplo, Allocation X, int incX, Allocation Y, int incY, Allocation Ap)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void SSYMV(@Uplo int Uplo, float alpha, Allocation A, Allocation X, int incX, float beta, Allocation Y, int incY)",
    "returnType" : "void",
    "comment" : "\n     * SSYMV performs the matrix-vector operation\n     * y := alpha*A*x + beta*y\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d2/d94/ssymv_8f.html\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part is to be referenced.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param beta The scalar beta.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F32}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F32" ]
  }, {
    "name" : "public void SSBMV(@Uplo int Uplo, int K, float alpha, Allocation A, Allocation X, int incX, float beta, Allocation Y, int incY)",
    "returnType" : "void",
    "comment" : "\n     * SSBMV performs the matrix-vector operation\n     * y := alpha*A*x + beta*y\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d3/da1/ssbmv_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should also be of size N*N (dimY = N, dimX = N),\n     *       but only the region N*(K+1) will be referenced. The following subroutine can is an\n     *       example showing how to convert a UPPER trianglar matrix 'a' to row-based band matrix 'b'.\n     *           for i in range(0, n):\n     *              for j in range(i, min(i+k+1, n)):\n     *                  b[i, j-i] = a[i, j]\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part of the band matrix A is being supplied.\n     * @param K The number of off-diagonals of the matrix A\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param beta The scalar beta.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F32}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F32" ]
  }, {
    "name" : "public void SSPMV(@Uplo int Uplo, float alpha, Allocation Ap, Allocation X, int incX, float beta, Allocation Y, int incY)",
    "returnType" : "void",
    "comment" : "\n     * SSPMV performs the matrix-vector operation\n     * y := alpha*A*x + beta*y\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d8/d68/sspmv_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,\n     *       The following subroutine can is an example showing how to convert a UPPER trianglar matrix\n     *       'a' to packed matrix 'b'.\n     *           k = 0\n     *           for i in range(0, n):\n     *              for j in range(i, n):\n     *                  b[k++] = a[i, j]\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part of the matrix A is supplied in packed form.\n     * @param alpha The scalar alpha.\n     * @param Ap The input allocation contains matrix A, supported elements type {@link Element#F32}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param beta The scalar beta.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F32}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F32" ]
  }, {
    "name" : "public void SGER(float alpha, Allocation X, int incX, Allocation Y, int incY, Allocation A)",
    "returnType" : "void",
    "comment" : "\n     * SGER performs the rank 1 operation\n     * A := alpha*x*y**T + A\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/db/d5c/sger_8f.html\n     *\n     * @param alpha The scalar alpha.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F32}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32}.\n     ",
    "links" : [ "android.renderscript.Element#F32" ]
  }, {
    "name" : "public void SSYR(@Uplo int Uplo, float alpha, Allocation X, int incX, Allocation A)",
    "returnType" : "void",
    "comment" : "\n     * SSYR performs the rank 1 operation\n     * A := alpha*x*x**T + A\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d6/dac/ssyr_8f.html\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part is to be referenced.\n     * @param alpha The scalar alpha.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32}.\n     ",
    "links" : [ "android.renderscript.Element#F32" ]
  }, {
    "name" : "public void SSPR(@Uplo int Uplo, float alpha, Allocation X, int incX, Allocation Ap)",
    "returnType" : "void",
    "comment" : "\n     * SSPR performs the rank 1 operation\n     * A := alpha*x*x**T + A\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d2/d9b/sspr_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,\n     *       The following subroutine can is an example showing how to convert a UPPER trianglar matrix\n     *       'a' to packed matrix 'b'.\n     *           k = 0\n     *           for i in range(0, n):\n     *              for j in range(i, n):\n     *                  b[k++] = a[i, j]\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part is to be supplied in the packed form.\n     * @param alpha The scalar alpha.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param Ap The input allocation contains matrix A, supported elements type {@link Element#F32}.\n     ",
    "links" : [ "android.renderscript.Element#F32" ]
  }, {
    "name" : "public void SSYR2(@Uplo int Uplo, float alpha, Allocation X, int incX, Allocation Y, int incY, Allocation A)",
    "returnType" : "void",
    "comment" : "\n     * SSYR2 performs the symmetric rank 2 operation\n     * A := alpha*x*y**T + alpha*y*x**T + A\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/db/d99/ssyr2_8f.html\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part is to be referenced.\n     * @param alpha The scalar alpha.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F32}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32}.\n     ",
    "links" : [ "android.renderscript.Element#F32" ]
  }, {
    "name" : "public void SSPR2(@Uplo int Uplo, float alpha, Allocation X, int incX, Allocation Y, int incY, Allocation Ap)",
    "returnType" : "void",
    "comment" : "\n     * SSPR2 performs the symmetric rank 2 operation\n     * A := alpha*x*y**T + alpha*y*x**T + A\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/db/d3e/sspr2_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,\n     *       The following subroutine can is an example showing how to convert a UPPER trianglar matrix\n     *       'a' to packed matrix 'b'.\n     *           k = 0\n     *           for i in range(0, n):\n     *              for j in range(i, n):\n     *                  b[k++] = a[i, j]\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part is to be supplied in the packed form.\n     * @param alpha The scalar alpha.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F32}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     * @param Ap The input allocation contains matrix A, supported elements type {@link Element#F32}.\n     ",
    "links" : [ "android.renderscript.Element#F32" ]
  }, {
    "name" : "public void DSYMV(@Uplo int Uplo, double alpha, Allocation A, Allocation X, int incX, double beta, Allocation Y, int incY)",
    "returnType" : "void",
    "comment" : "\n     * DSYMV performs the matrix-vector operation\n     * y := alpha*A*x + beta*y\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d8/dbe/dsymv_8f.html\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part is to be referenced.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param beta The scalar beta.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F64}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F64" ]
  }, {
    "name" : "public void DSBMV(@Uplo int Uplo, int K, double alpha, Allocation A, Allocation X, int incX, double beta, Allocation Y, int incY)",
    "returnType" : "void",
    "comment" : "\n     * DSBMV performs the matrix-vector operation\n     * y := alpha*A*x + beta*y\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d8/d1e/dsbmv_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should also be of size N*N (dimY = N, dimX = N),\n     *       but only the region N*(K+1) will be referenced. The following subroutine can is an\n     *       example showing how to convert a UPPER trianglar matrix 'a' to row-based band matrix 'b'.\n     *           for i in range(0, n):\n     *              for j in range(i, min(i+k+1, n)):\n     *                  b[i, j-i] = a[i, j]\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part of the band matrix A is being supplied.\n     * @param K The number of off-diagonals of the matrix A\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param beta The scalar beta.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F64}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F64" ]
  }, {
    "name" : "public void DSPMV(@Uplo int Uplo, double alpha, Allocation Ap, Allocation X, int incX, double beta, Allocation Y, int incY)",
    "returnType" : "void",
    "comment" : "\n     * DSPMV performs the matrix-vector operation\n     * y := alpha*A*x + beta*y\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d4/d85/dspmv_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,\n     *       The following subroutine can is an example showing how to convert a UPPER trianglar matrix\n     *       'a' to packed matrix 'b'.\n     *           k = 0\n     *           for i in range(0, n):\n     *              for j in range(i, n):\n     *                  b[k++] = a[i, j]\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part of the matrix A is supplied in packed form.\n     * @param alpha The scalar alpha.\n     * @param Ap The input allocation contains matrix A, supported elements type {@link Element#F64}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param beta The scalar beta.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F64}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F64" ]
  }, {
    "name" : "public void DGER(double alpha, Allocation X, int incX, Allocation Y, int incY, Allocation A)",
    "returnType" : "void",
    "comment" : "\n     * DGER performs the rank 1 operation\n     * A := alpha*x*y**T + A\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/dc/da8/dger_8f.html\n     *\n     * @param alpha The scalar alpha.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F64}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64}.\n     ",
    "links" : [ "android.renderscript.Element#F64" ]
  }, {
    "name" : "public void DSYR(@Uplo int Uplo, double alpha, Allocation X, int incX, Allocation A)",
    "returnType" : "void",
    "comment" : "\n     * DSYR performs the rank 1 operation\n     * A := alpha*x*x**T + A\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d3/d60/dsyr_8f.html\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part is to be referenced.\n     * @param alpha The scalar alpha.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64}.\n     ",
    "links" : [ "android.renderscript.Element#F64" ]
  }, {
    "name" : "public void DSPR(@Uplo int Uplo, double alpha, Allocation X, int incX, Allocation Ap)",
    "returnType" : "void",
    "comment" : "\n     * DSPR performs the rank 1 operation\n     * A := alpha*x*x**T + A\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/dd/dba/dspr_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,\n     *       The following subroutine can is an example showing how to convert a UPPER trianglar matrix\n     *       'a' to packed matrix 'b'.\n     *           k = 0\n     *           for i in range(0, n):\n     *              for j in range(i, n):\n     *                  b[k++] = a[i, j]\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part is to be supplied in the packed form.\n     * @param alpha The scalar alpha.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param Ap The input allocation contains matrix A, supported elements type {@link Element#F64}.\n     ",
    "links" : [ "android.renderscript.Element#F64" ]
  }, {
    "name" : "public void DSYR2(@Uplo int Uplo, double alpha, Allocation X, int incX, Allocation Y, int incY, Allocation A)",
    "returnType" : "void",
    "comment" : "\n     * DSYR2 performs the symmetric rank 2 operation\n     * A := alpha*x*y**T + alpha*y*x**T + A\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/de/d41/dsyr2_8f.html\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part is to be referenced.\n     * @param alpha The scalar alpha.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F64}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64}.\n     ",
    "links" : [ "android.renderscript.Element#F64" ]
  }, {
    "name" : "public void DSPR2(@Uplo int Uplo, double alpha, Allocation X, int incX, Allocation Y, int incY, Allocation Ap)",
    "returnType" : "void",
    "comment" : "\n     * DSPR2 performs the symmetric rank 2 operation\n     * A := alpha*x*y**T + alpha*y*x**T + A\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/dd/d9e/dspr2_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,\n     *       The following subroutine can is an example showing how to convert a UPPER trianglar matrix\n     *       'a' to packed matrix 'b'.\n     *           k = 0\n     *           for i in range(0, n):\n     *              for j in range(i, n):\n     *                  b[k++] = a[i, j]\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part is to be supplied in the packed form.\n     * @param alpha The scalar alpha.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F64}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     * @param Ap The input allocation contains matrix A, supported elements type {@link Element#F64}.\n     ",
    "links" : [ "android.renderscript.Element#F64" ]
  }, {
    "name" : " static void validateGERU(Element e, Allocation X, int incX, Allocation Y, int incY, Allocation A)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void CHEMV(@Uplo int Uplo, Float2 alpha, Allocation A, Allocation X, int incX, Float2 beta, Allocation Y, int incY)",
    "returnType" : "void",
    "comment" : "\n     * CHEMV performs the matrix-vector operation\n     * y := alpha*A*x + beta*y\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d7/d51/chemv_8f.html\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part is to be referenced.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32_2}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param beta The scalar beta.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F32_2}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void CHBMV(@Uplo int Uplo, int K, Float2 alpha, Allocation A, Allocation X, int incX, Float2 beta, Allocation Y, int incY)",
    "returnType" : "void",
    "comment" : "\n     * CHBMV performs the matrix-vector operation\n     * y := alpha*A*x + beta*y\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/db/dc2/chbmv_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should also be of size N*N (dimY = N, dimX = N),\n     *       but only the region N*(K+1) will be referenced. The following subroutine can is an\n     *       example showing how to convert a UPPER trianglar matrix 'a' to row-based band matrix 'b'.\n     *           for i in range(0, n):\n     *              for j in range(i, min(i+k+1, n)):\n     *                  b[i, j-i] = a[i, j]\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part of the band matrix A is being supplied.\n     * @param K The number of off-diagonals of the matrix A\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32_2}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param beta The scalar beta.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F32_2}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void CHPMV(@Uplo int Uplo, Float2 alpha, Allocation Ap, Allocation X, int incX, Float2 beta, Allocation Y, int incY)",
    "returnType" : "void",
    "comment" : "\n     * CHPMV performs the matrix-vector operation\n     * y := alpha*A*x + beta*y\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d2/d06/chpmv_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,\n     *       The following subroutine can is an example showing how to convert a UPPER trianglar matrix\n     *       'a' to packed matrix 'b'.\n     *           k = 0\n     *           for i in range(0, n):\n     *              for j in range(i, n):\n     *                  b[k++] = a[i, j]\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part of the matrix A is supplied in packed form.\n     * @param alpha The scalar alpha.\n     * @param Ap The input allocation contains matrix A, supported elements type {@link Element#F32_2}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param beta The scalar beta.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F32_2}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void CGERU(Float2 alpha, Allocation X, int incX, Allocation Y, int incY, Allocation A)",
    "returnType" : "void",
    "comment" : "\n     * CGERU performs the rank 1 operation\n     * A := alpha*x*y**T + A\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/db/d5f/cgeru_8f.html\n     *\n     * @param alpha The scalar alpha.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F32_2}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32_2}.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void CGERC(Float2 alpha, Allocation X, int incX, Allocation Y, int incY, Allocation A)",
    "returnType" : "void",
    "comment" : "\n     * CGERC performs the rank 1 operation\n     * A := alpha*x*y**H + A\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/dd/d84/cgerc_8f.html\n     *\n     * @param alpha The scalar alpha.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F32_2}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32_2}.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void CHER(@Uplo int Uplo, float alpha, Allocation X, int incX, Allocation A)",
    "returnType" : "void",
    "comment" : "\n     * CHER performs the rank 1 operation\n     * A := alpha*x*x**H + A\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d3/d6d/cher_8f.html\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part is to be referenced.\n     * @param alpha The scalar alpha.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32_2}.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void CHPR(@Uplo int Uplo, float alpha, Allocation X, int incX, Allocation Ap)",
    "returnType" : "void",
    "comment" : "\n     * CHPR performs the rank 1 operation\n     * A := alpha*x*x**H + A\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/db/dcd/chpr_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,\n     *       The following subroutine can is an example showing how to convert a UPPER trianglar matrix\n     *       'a' to packed matrix 'b'.\n     *           k = 0\n     *           for i in range(0, n):\n     *              for j in range(i, n):\n     *                  b[k++] = a[i, j]\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part is to be supplied in the packed form.\n     * @param alpha The scalar alpha.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param Ap The input allocation contains matrix A, supported elements type {@link Element#F32_2}.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void CHER2(@Uplo int Uplo, Float2 alpha, Allocation X, int incX, Allocation Y, int incY, Allocation A)",
    "returnType" : "void",
    "comment" : "\n     * CHER2 performs the symmetric rank 2 operation\n     * A := alpha*x*y**H + alpha*y*x**H + A\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/db/d87/cher2_8f.html\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part is to be referenced.\n     * @param alpha The scalar alpha.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F32_2}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32_2}.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void CHPR2(@Uplo int Uplo, Float2 alpha, Allocation X, int incX, Allocation Y, int incY, Allocation Ap)",
    "returnType" : "void",
    "comment" : "\n     * CHPR2 performs the symmetric rank 2 operation\n     * A := alpha*x*y**H + alpha*y*x**H + A\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d6/d44/chpr2_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,\n     *       The following subroutine can is an example showing how to convert a UPPER trianglar matrix\n     *       'a' to packed matrix 'b'.\n     *           k = 0\n     *           for i in range(0, n):\n     *              for j in range(i, n):\n     *                  b[k++] = a[i, j]\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part is to be supplied in the packed form.\n     * @param alpha The scalar alpha.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F32_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F32_2}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     * @param Ap The input allocation contains matrix A, supported elements type {@link Element#F32_2}.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void ZHEMV(@Uplo int Uplo, Double2 alpha, Allocation A, Allocation X, int incX, Double2 beta, Allocation Y, int incY)",
    "returnType" : "void",
    "comment" : "\n     * ZHEMV performs the matrix-vector operation\n     * y := alpha*A*x + beta*y\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d0/ddd/zhemv_8f.html\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part is to be referenced.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64_2}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param beta The scalar beta.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F64_2}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : "public void ZHBMV(@Uplo int Uplo, int K, Double2 alpha, Allocation A, Allocation X, int incX, Double2 beta, Allocation Y, int incY)",
    "returnType" : "void",
    "comment" : "\n     * ZHBMV performs the matrix-vector operation\n     * y := alpha*A*x + beta*y\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d3/d1a/zhbmv_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should also be of size N*N (dimY = N, dimX = N),\n     *       but only the region N*(K+1) will be referenced. The following subroutine can is an\n     *       example showing how to convert a UPPER trianglar matrix 'a' to row-based band matrix 'b'.\n     *           for i in range(0, n):\n     *              for j in range(i, min(i+k+1, n)):\n     *                  b[i, j-i] = a[i, j]\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part of the band matrix A is being supplied.\n     * @param K The number of off-diagonals of the matrix A\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64_2}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param beta The scalar beta.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F64_2}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : "public void ZHPMV(@Uplo int Uplo, Double2 alpha, Allocation Ap, Allocation X, int incX, Double2 beta, Allocation Y, int incY)",
    "returnType" : "void",
    "comment" : "\n     * ZHPMV performs the matrix-vector operation\n     * y := alpha*A*x + beta*y\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d0/d60/zhpmv_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,\n     *       The following subroutine can is an example showing how to convert a UPPER trianglar matrix\n     *       'a' to packed matrix 'b'.\n     *           k = 0\n     *           for i in range(0, n):\n     *              for j in range(i, n):\n     *                  b[k++] = a[i, j]\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part of the matrix A is supplied in packed form.\n     * @param alpha The scalar alpha.\n     * @param Ap The input allocation contains matrix A, supported elements type {@link Element#F64_2}.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param beta The scalar beta.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F64_2}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : "public void ZGERU(Double2 alpha, Allocation X, int incX, Allocation Y, int incY, Allocation A)",
    "returnType" : "void",
    "comment" : "\n     * ZGERU performs the rank 1 operation\n     * A := alpha*x*y**T + A\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d7/d12/zgeru_8f.html\n     *\n     * @param alpha The scalar alpha.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F64_2}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64_2}.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : "public void ZGERC(Double2 alpha, Allocation X, int incX, Allocation Y, int incY, Allocation A)",
    "returnType" : "void",
    "comment" : "\n     * ZGERC performs the rank 1 operation\n     * A := alpha*x*y**H + A\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d3/dad/zgerc_8f.html\n     *\n     * @param alpha The scalar alpha.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F64_2}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64_2}.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : "public void ZHER(@Uplo int Uplo, double alpha, Allocation X, int incX, Allocation A)",
    "returnType" : "void",
    "comment" : "\n     * ZHER performs the rank 1 operation\n     * A := alpha*x*x**H + A\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/de/d0e/zher_8f.html\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part is to be referenced.\n     * @param alpha The scalar alpha.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64_2}.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : "public void ZHPR(@Uplo int Uplo, double alpha, Allocation X, int incX, Allocation Ap)",
    "returnType" : "void",
    "comment" : "\n     * ZHPR performs the rank 1 operation\n     * A := alpha*x*x**H + A\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/de/de1/zhpr_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,\n     *       The following subroutine can is an example showing how to convert a UPPER trianglar matrix\n     *       'a' to packed matrix 'b'.\n     *           k = 0\n     *           for i in range(0, n):\n     *              for j in range(i, n):\n     *                  b[k++] = a[i, j]\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part is to be supplied in the packed form.\n     * @param alpha The scalar alpha.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param Ap The input allocation contains matrix A, supported elements type {@link Element#F64_2}.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : "public void ZHER2(@Uplo int Uplo, Double2 alpha, Allocation X, int incX, Allocation Y, int incY, Allocation A)",
    "returnType" : "void",
    "comment" : "\n     * ZHER2 performs the symmetric rank 2 operation\n     * A := alpha*x*y**H + alpha*y*x**H + A\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/da/d8a/zher2_8f.html\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part is to be referenced.\n     * @param alpha The scalar alpha.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F64_2}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64_2}.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : "public void ZHPR2(@Uplo int Uplo, Double2 alpha, Allocation X, int incX, Allocation Y, int incY, Allocation Ap)",
    "returnType" : "void",
    "comment" : "\n     * ZHPR2 performs the symmetric rank 2 operation\n     * A := alpha*x*y**H + alpha*y*x**H + A\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d5/d52/zhpr2_8f.html\n     *\n     * Note: For a N*N matrix, the input Allocation should be a 1D allocation of size dimX = N*(N+1)/2,\n     *       The following subroutine can is an example showing how to convert a UPPER trianglar matrix\n     *       'a' to packed matrix 'b'.\n     *           k = 0\n     *           for i in range(0, n):\n     *              for j in range(i, n):\n     *                  b[k++] = a[i, j]\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part is to be supplied in the packed form.\n     * @param alpha The scalar alpha.\n     * @param X The input allocation contains vector x, supported elements type {@link Element#F64_2}.\n     * @param incX The increment for the elements of vector x, must be larger than zero.\n     * @param Y The input allocation contains vector y, supported elements type {@link Element#F64_2}.\n     * @param incY The increment for the elements of vector y, must be larger than zero.\n     * @param Ap The input allocation contains matrix A, supported elements type {@link Element#F64_2}.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : " static void validateL3(Element e, int TransA, int TransB, int Side, Allocation A, Allocation B, Allocation C)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void SGEMM(@Transpose int TransA, @Transpose int TransB, float alpha, Allocation A, Allocation B, float beta, Allocation C)",
    "returnType" : "void",
    "comment" : "\n     * SGEMM performs one of the matrix-matrix operations\n     * C := alpha*op(A)*op(B) + beta*C   where op(X) is one of op(X) = X  or  op(X) = X**T\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d4/de2/sgemm_8f.html\n     *\n     * @param TransA The type of transpose applied to matrix A.\n     * @param TransB The type of transpose applied to matrix B.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32}.\n     * @param B The input allocation contains matrix B, supported elements type {@link Element#F32}.\n     * @param beta The scalar beta.\n     * @param C The input allocation contains matrix C, supported elements type {@link Element#F32}.\n     ",
    "links" : [ "android.renderscript.Element#F32" ]
  }, {
    "name" : "public void DGEMM(@Transpose int TransA, @Transpose int TransB, double alpha, Allocation A, Allocation B, double beta, Allocation C)",
    "returnType" : "void",
    "comment" : "\n     * DGEMM performs one of the matrix-matrix operations\n     * C := alpha*op(A)*op(B) + beta*C   where op(X) is one of op(X) = X  or  op(X) = X**T\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d7/d2b/dgemm_8f.html\n     *\n     * @param TransA The type of transpose applied to matrix A.\n     * @param TransB The type of transpose applied to matrix B.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64}.\n     * @param B The input allocation contains matrix B, supported elements type {@link Element#F64}.\n     * @param beta The scalar beta.\n     * @param C The input allocation contains matrix C, supported elements type {@link Element#F64}.\n     ",
    "links" : [ "android.renderscript.Element#F64" ]
  }, {
    "name" : "public void CGEMM(@Transpose int TransA, @Transpose int TransB, Float2 alpha, Allocation A, Allocation B, Float2 beta, Allocation C)",
    "returnType" : "void",
    "comment" : "\n     * CGEMM performs one of the matrix-matrix operations\n     * C := alpha*op(A)*op(B) + beta*C   where op(X) is one of op(X) = X  or  op(X) = X**T  or  op(X) = X**H\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d6/d5b/cgemm_8f.html\n     *\n     * @param TransA The type of transpose applied to matrix A.\n     * @param TransB The type of transpose applied to matrix B.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32_2}.\n     * @param B The input allocation contains matrix B, supported elements type {@link Element#F32_2}.\n     * @param beta The scalar beta.\n     * @param C The input allocation contains matrix C, supported elements type {@link Element#F32_2}.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void ZGEMM(@Transpose int TransA, @Transpose int TransB, Double2 alpha, Allocation A, Allocation B, Double2 beta, Allocation C)",
    "returnType" : "void",
    "comment" : "\n     * ZGEMM performs one of the matrix-matrix operations\n     * C := alpha*op(A)*op(B) + beta*C   where op(X) is one of op(X) = X  or  op(X) = X**T  or  op(X) = X**H\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d7/d76/zgemm_8f.html\n     *\n     * @param TransA The type of transpose applied to matrix A.\n     * @param TransB The type of transpose applied to matrix B.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64_2}.\n     * @param B The input allocation contains matrix B, supported elements type {@link Element#F64_2}.\n     * @param beta The scalar beta.\n     * @param C The input allocation contains matrix C, supported elements type {@link Element#F64_2}.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : "public void SSYMM(@Side int Side, @Uplo int Uplo, float alpha, Allocation A, Allocation B, float beta, Allocation C)",
    "returnType" : "void",
    "comment" : "\n     * SSYMM performs one of the matrix-matrix operations\n     * C := alpha*A*B + beta*C   or   C := alpha*B*A + beta*C\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d7/d42/ssymm_8f.html\n     *\n     * @param Side Specifies whether the symmetric matrix A appears on the left or right.\n     * @param Uplo Specifies whether the upper or lower triangular part is to be referenced.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32}.\n     * @param B The input allocation contains matrix B, supported elements type {@link Element#F32}.\n     * @param beta The scalar beta.\n     * @param C The input allocation contains matrix C, supported elements type {@link Element#F32}.\n     ",
    "links" : [ "android.renderscript.Element#F32" ]
  }, {
    "name" : "public void DSYMM(@Side int Side, @Uplo int Uplo, double alpha, Allocation A, Allocation B, double beta, Allocation C)",
    "returnType" : "void",
    "comment" : "\n     * DSYMM performs one of the matrix-matrix operations\n     * C := alpha*A*B + beta*C   or   C := alpha*B*A + beta*C\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d8/db0/dsymm_8f.html\n     *\n     * @param Side Specifies whether the symmetric matrix A appears on the left or right.\n     * @param Uplo Specifies whether the upper or lower triangular part is to be referenced.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64}.\n     * @param B The input allocation contains matrix B, supported elements type {@link Element#F64}.\n     * @param beta The scalar beta.\n     * @param C The input allocation contains matrix C, supported elements type {@link Element#F64}.\n     ",
    "links" : [ "android.renderscript.Element#F64" ]
  }, {
    "name" : "public void CSYMM(@Side int Side, @Uplo int Uplo, Float2 alpha, Allocation A, Allocation B, Float2 beta, Allocation C)",
    "returnType" : "void",
    "comment" : "\n     * CSYMM performs one of the matrix-matrix operations\n     * C := alpha*A*B + beta*C   or   C := alpha*B*A + beta*C\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/db/d59/csymm_8f.html\n     *\n     * @param Side Specifies whether the symmetric matrix A appears on the left or right.\n     * @param Uplo Specifies whether the upper or lower triangular part is to be referenced.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32_2}.\n     * @param B The input allocation contains matrix B, supported elements type {@link Element#F32_2}.\n     * @param beta The scalar beta.\n     * @param C The input allocation contains matrix C, supported elements type {@link Element#F32_2}.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void ZSYMM(@Side int Side, @Uplo int Uplo, Double2 alpha, Allocation A, Allocation B, Double2 beta, Allocation C)",
    "returnType" : "void",
    "comment" : "\n     * ZSYMM performs one of the matrix-matrix operations\n     * C := alpha*A*B + beta*C   or   C := alpha*B*A + beta*C\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/df/d51/zsymm_8f.html\n     *\n     * @param Side Specifies whether the symmetric matrix A appears on the left or right.\n     * @param Uplo Specifies whether the upper or lower triangular part is to be referenced.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64_2}.\n     * @param B The input allocation contains matrix B, supported elements type {@link Element#F64_2}.\n     * @param beta The scalar beta.\n     * @param C The input allocation contains matrix C, supported elements type {@link Element#F64_2}.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : "public void SSYRK(@Uplo int Uplo, @Transpose int Trans, float alpha, Allocation A, float beta, Allocation C)",
    "returnType" : "void",
    "comment" : "\n     * SSYRK performs one of the symmetric rank k operations\n     * C := alpha*A*A**T + beta*C   or   C := alpha*A**T*A + beta*C\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d0/d40/ssyrk_8f.html\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part of C is to be referenced.\n     * @param Trans The type of transpose applied to the operation.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32}.\n     * @param beta The scalar beta.\n     * @param C The input allocation contains matrix C, supported elements type {@link Element#F32}.\n     ",
    "links" : [ "android.renderscript.Element#F32" ]
  }, {
    "name" : "public void DSYRK(@Uplo int Uplo, @Transpose int Trans, double alpha, Allocation A, double beta, Allocation C)",
    "returnType" : "void",
    "comment" : "\n     * DSYRK performs one of the symmetric rank k operations\n     * C := alpha*A*A**T + beta*C   or   C := alpha*A**T*A + beta*C\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/dc/d05/dsyrk_8f.html\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part of C is to be referenced.\n     * @param Trans The type of transpose applied to the operation.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64}.\n     * @param beta The scalar beta.\n     * @param C The input allocation contains matrix C, supported elements type {@link Element#F64}.\n     ",
    "links" : [ "android.renderscript.Element#F64" ]
  }, {
    "name" : "public void CSYRK(@Uplo int Uplo, @Transpose int Trans, Float2 alpha, Allocation A, Float2 beta, Allocation C)",
    "returnType" : "void",
    "comment" : "\n     * CSYRK performs one of the symmetric rank k operations\n     * C := alpha*A*A**T + beta*C   or   C := alpha*A**T*A + beta*C\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d3/d6a/csyrk_8f.html\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part of C is to be referenced.\n     * @param Trans The type of transpose applied to the operation.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32_2}.\n     * @param beta The scalar beta.\n     * @param C The input allocation contains matrix C, supported elements type {@link Element#F32_2}.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void ZSYRK(@Uplo int Uplo, @Transpose int Trans, Double2 alpha, Allocation A, Double2 beta, Allocation C)",
    "returnType" : "void",
    "comment" : "\n     * ZSYRK performs one of the symmetric rank k operations\n     * C := alpha*A*A**T + beta*C   or   C := alpha*A**T*A + beta*C\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/de/d54/zsyrk_8f.html\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part of C is to be referenced.\n     * @param Trans The type of transpose applied to the operation.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64_2}.\n     * @param beta The scalar beta.\n     * @param C The input allocation contains matrix C, supported elements type {@link Element#F64_2}.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : " static void validateSYR2K(Element e, @Transpose int Trans, Allocation A, Allocation B, Allocation C)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void SSYR2K(@Uplo int Uplo, @Transpose int Trans, float alpha, Allocation A, Allocation B, float beta, Allocation C)",
    "returnType" : "void",
    "comment" : "\n     * SSYR2K performs one of the symmetric rank 2k operations\n     * C := alpha*A*B**T + alpha*B*A**T + beta*C   or   C := alpha*A**T*B + alpha*B**T*A + beta*C\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/df/d3d/ssyr2k_8f.html\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part of C is to be referenced.\n     * @param Trans The type of transpose applied to the operation.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32}.\n     * @param B The input allocation contains matrix B, supported elements type {@link Element#F32}.\n     * @param beta The scalar beta.\n     * @param C The input allocation contains matrix C, supported elements type {@link Element#F32}.\n     ",
    "links" : [ "android.renderscript.Element#F32" ]
  }, {
    "name" : "public void DSYR2K(@Uplo int Uplo, @Transpose int Trans, double alpha, Allocation A, Allocation B, double beta, Allocation C)",
    "returnType" : "void",
    "comment" : "\n     * DSYR2K performs one of the symmetric rank 2k operations\n     * C := alpha*A*B**T + alpha*B*A**T + beta*C   or   C := alpha*A**T*B + alpha*B**T*A + beta*C\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d1/dec/dsyr2k_8f.html\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part of C is to be referenced.\n     * @param Trans The type of transpose applied to the operation.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64}.\n     * @param B The input allocation contains matrix B, supported elements type {@link Element#F64}.\n     * @param beta The scalar beta.\n     * @param C The input allocation contains matrix C, supported elements type {@link Element#F64}.\n     ",
    "links" : [ "android.renderscript.Element#F64" ]
  }, {
    "name" : "public void CSYR2K(@Uplo int Uplo, @Transpose int Trans, Float2 alpha, Allocation A, Allocation B, Float2 beta, Allocation C)",
    "returnType" : "void",
    "comment" : "\n     * CSYR2K performs one of the symmetric rank 2k operations\n     * C := alpha*A*B**T + alpha*B*A**T + beta*C   or   C := alpha*A**T*B + alpha*B**T*A + beta*C\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/de/d7e/csyr2k_8f.html\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part of C is to be referenced.\n     * @param Trans The type of transpose applied to the operation.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32_2}.\n     * @param B The input allocation contains matrix B, supported elements type {@link Element#F32_2}.\n     * @param beta The scalar beta.\n     * @param C The input allocation contains matrix C, supported elements type {@link Element#F32_2}.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void ZSYR2K(@Uplo int Uplo, @Transpose int Trans, Double2 alpha, Allocation A, Allocation B, Double2 beta, Allocation C)",
    "returnType" : "void",
    "comment" : "\n     * ZSYR2K performs one of the symmetric rank 2k operations\n     * C := alpha*A*B**T + alpha*B*A**T + beta*C   or   C := alpha*A**T*B + alpha*B**T*A + beta*C\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/df/d20/zsyr2k_8f.html\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part of C is to be referenced.\n     * @param Trans The type of transpose applied to the operation.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64_2}.\n     * @param B The input allocation contains matrix B, supported elements type {@link Element#F64_2}.\n     * @param beta The scalar beta.\n     * @param C The input allocation contains matrix C, supported elements type {@link Element#F64_2}.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : " static void validateTRMM(Element e, @Side int Side, @Transpose int TransA, Allocation A, Allocation B)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void STRMM(@Side int Side, @Uplo int Uplo, @Transpose int TransA, @Diag int Diag, float alpha, Allocation A, Allocation B)",
    "returnType" : "void",
    "comment" : "\n     * STRMM performs one of the matrix-matrix operations\n     * B := alpha*op(A)*B   or   B := alpha*B*op(A)\n     * op(A) is one of  op(A) = A  or  op(A) = A**T\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/df/d01/strmm_8f.html\n     *\n     * @param Side Specifies whether the symmetric matrix A appears on the left or right.\n     * @param Uplo Specifies whether matrix A is upper or lower triangular.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32}.\n     * @param B The input allocation contains matrix B, supported elements type {@link Element#F32}.\n     ",
    "links" : [ "android.renderscript.Element#F32" ]
  }, {
    "name" : "public void DTRMM(@Side int Side, @Uplo int Uplo, @Transpose int TransA, @Diag int Diag, double alpha, Allocation A, Allocation B)",
    "returnType" : "void",
    "comment" : "\n     * DTRMM performs one of the matrix-matrix operations\n     * B := alpha*op(A)*B   or   B := alpha*B*op(A)\n     * op(A) is one of  op(A) = A  or  op(A) = A**T\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/dd/d19/dtrmm_8f.html\n     *\n     * @param Side Specifies whether the symmetric matrix A appears on the left or right.\n     * @param Uplo Specifies whether matrix A is upper or lower triangular.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64}.\n     * @param B The input allocation contains matrix B, supported elements type {@link Element#F64}.\n     ",
    "links" : [ "android.renderscript.Element#F64" ]
  }, {
    "name" : "public void CTRMM(@Side int Side, @Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Float2 alpha, Allocation A, Allocation B)",
    "returnType" : "void",
    "comment" : "\n     * CTRMM performs one of the matrix-matrix operations\n     * B := alpha*op(A)*B   or   B := alpha*B*op(A)\n     * op(A) is one of  op(A) = A  or  op(A) = A**T  or  op(A) = A**H\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d4/d9b/ctrmm_8f.html\n     *\n     * @param Side Specifies whether the symmetric matrix A appears on the left or right.\n     * @param Uplo Specifies whether matrix A is upper or lower triangular.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32_2}.\n     * @param B The input allocation contains matrix B, supported elements type {@link Element#F32_2}.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void ZTRMM(@Side int Side, @Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Double2 alpha, Allocation A, Allocation B)",
    "returnType" : "void",
    "comment" : "\n     * ZTRMM performs one of the matrix-matrix operations\n     * B := alpha*op(A)*B   or   B := alpha*B*op(A)\n     * op(A) is one of  op(A) = A  or  op(A) = A**T  or  op(A) = A**H\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d8/de1/ztrmm_8f.html\n     *\n     * @param Side Specifies whether the symmetric matrix A appears on the left or right.\n     * @param Uplo Specifies whether matrix A is upper or lower triangular.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64_2}.\n     * @param B The input allocation contains matrix B, supported elements type {@link Element#F64_2}.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : " static void validateTRSM(Element e, @Side int Side, @Transpose int TransA, Allocation A, Allocation B)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void STRSM(@Side int Side, @Uplo int Uplo, @Transpose int TransA, @Diag int Diag, float alpha, Allocation A, Allocation B)",
    "returnType" : "void",
    "comment" : "\n     * STRSM solves one of the matrix equations\n     * op(A)*X := alpha*B   or   X*op(A) := alpha*B\n     * op(A) is one of  op(A) = A  or  op(A) = A**T\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d2/d8b/strsm_8f.html\n     *\n     * @param Side Specifies whether the symmetric matrix A appears on the left or right.\n     * @param Uplo Specifies whether matrix A is upper or lower triangular.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32}.\n     * @param B The input allocation contains matrix B, supported elements type {@link Element#F32}.\n     ",
    "links" : [ "android.renderscript.Element#F32" ]
  }, {
    "name" : "public void DTRSM(@Side int Side, @Uplo int Uplo, @Transpose int TransA, @Diag int Diag, double alpha, Allocation A, Allocation B)",
    "returnType" : "void",
    "comment" : "\n     * DTRSM solves one of the matrix equations\n     * op(A)*X := alpha*B   or   X*op(A) := alpha*B\n     * op(A) is one of  op(A) = A  or  op(A) = A**T\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/de/da7/dtrsm_8f.html\n     *\n     * @param Side Specifies whether the symmetric matrix A appears on the left or right.\n     * @param Uplo Specifies whether matrix A is upper or lower triangular.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64}.\n     * @param B The input allocation contains matrix B, supported elements type {@link Element#F64}.\n     ",
    "links" : [ "android.renderscript.Element#F64" ]
  }, {
    "name" : "public void CTRSM(@Side int Side, @Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Float2 alpha, Allocation A, Allocation B)",
    "returnType" : "void",
    "comment" : "\n     * CTRSM solves one of the matrix equations\n     * op(A)*X := alpha*B   or   X*op(A) := alpha*B\n     * op(A) is one of  op(A) = A  or  op(A) = A**T  or  op(A) = A**H\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/de/d30/ctrsm_8f.html\n     *\n     * @param Side Specifies whether the symmetric matrix A appears on the left or right.\n     * @param Uplo Specifies whether matrix A is upper or lower triangular.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32_2}.\n     * @param B The input allocation contains matrix B, supported elements type {@link Element#F32_2}.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void ZTRSM(@Side int Side, @Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Double2 alpha, Allocation A, Allocation B)",
    "returnType" : "void",
    "comment" : "\n     * ZTRSM solves one of the matrix equations\n     * op(A)*X := alpha*B   or   X*op(A) := alpha*B\n     * op(A) is one of  op(A) = A  or  op(A) = A**T  or  op(A) = A**H\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d1/d39/ztrsm_8f.html\n     *\n     * @param Side Specifies whether the symmetric matrix A appears on the left or right.\n     * @param Uplo Specifies whether matrix A is upper or lower triangular.\n     * @param TransA The type of transpose applied to matrix A.\n     * @param Diag Specifies whether or not A is unit triangular.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64_2}.\n     * @param B The input allocation contains matrix B, supported elements type {@link Element#F64_2}.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : " static void validateHEMM(Element e, @Side int Side, Allocation A, Allocation B, Allocation C)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void CHEMM(@Side int Side, @Uplo int Uplo, Float2 alpha, Allocation A, Allocation B, Float2 beta, Allocation C)",
    "returnType" : "void",
    "comment" : "\n     * CHEMM performs one of the matrix-matrix operations\n     * C := alpha*A*B + beta*C   or   C := alpha*B*A + beta*C\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d3/d66/chemm_8f.html\n     *\n     * @param Side Specifies whether the symmetric matrix A appears on the left or right.\n     * @param Uplo Specifies whether the upper or lower triangular part is to be referenced.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32_2}.\n     * @param B The input allocation contains matrix B, supported elements type {@link Element#F32_2}.\n     * @param beta The scalar beta.\n     * @param C The input allocation contains matrix C, supported elements type {@link Element#F32_2}.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void ZHEMM(@Side int Side, @Uplo int Uplo, Double2 alpha, Allocation A, Allocation B, Double2 beta, Allocation C)",
    "returnType" : "void",
    "comment" : "\n     * ZHEMM performs one of the matrix-matrix operations\n     * C := alpha*A*B + beta*C   or   C := alpha*B*A + beta*C\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d6/d3e/zhemm_8f.html\n     *\n     * @param Side Specifies whether the symmetric matrix A appears on the left or right.\n     * @param Uplo Specifies whether the upper or lower triangular part is to be referenced.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64_2}.\n     * @param B The input allocation contains matrix B, supported elements type {@link Element#F64_2}.\n     * @param beta The scalar beta.\n     * @param C The input allocation contains matrix C, supported elements type {@link Element#F64_2}.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : " static void validateHERK(Element e, @Transpose int Trans, Allocation A, Allocation C)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void CHERK(@Uplo int Uplo, @Transpose int Trans, float alpha, Allocation A, float beta, Allocation C)",
    "returnType" : "void",
    "comment" : "\n     * CHERK performs one of the hermitian rank k operations\n     * C := alpha*A*A**H + beta*C   or   C := alpha*A**H*A + beta*C\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d8/d52/cherk_8f.html\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part of C is to be referenced.\n     * @param Trans The type of transpose applied to the operation.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32_2}.\n     * @param beta The scalar beta.\n     * @param C The input allocation contains matrix C, supported elements type {@link Element#F32_2}.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void ZHERK(@Uplo int Uplo, @Transpose int Trans, double alpha, Allocation A, double beta, Allocation C)",
    "returnType" : "void",
    "comment" : "\n     * ZHERK performs one of the hermitian rank k operations\n     * C := alpha*A*A**H + beta*C   or   C := alpha*A**H*A + beta*C\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d1/db1/zherk_8f.html\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part of C is to be referenced.\n     * @param Trans The type of transpose applied to the operation.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64_2}.\n     * @param beta The scalar beta.\n     * @param C The input allocation contains matrix C, supported elements type {@link Element#F64_2}.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : " static void validateHER2K(Element e, @Transpose int Trans, Allocation A, Allocation B, Allocation C)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void CHER2K(@Uplo int Uplo, @Transpose int Trans, Float2 alpha, Allocation A, Allocation B, float beta, Allocation C)",
    "returnType" : "void",
    "comment" : "\n     * CHER2K performs one of the hermitian rank 2k operations\n     * C := alpha*A*B**H + conjg( alpha )*B*A**H + beta*C   or   C := alpha*A**H*B + conjg( alpha )*B**H*A + beta*C\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d1/d82/cher2k_8f.html\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part of C is to be referenced.\n     * @param Trans The type of transpose applied to the operation.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F32_2}.\n     * @param B The input allocation contains matrix B, supported elements type {@link Element#F32_2}.\n     * @param beta The scalar beta.\n     * @param C The input allocation contains matrix C, supported elements type {@link Element#F32_2}.\n     ",
    "links" : [ "android.renderscript.Element#F32_2" ]
  }, {
    "name" : "public void ZHER2K(@Uplo int Uplo, @Transpose int Trans, Double2 alpha, Allocation A, Allocation B, double beta, Allocation C)",
    "returnType" : "void",
    "comment" : "\n     * ZHER2K performs one of the hermitian rank 2k operations\n     * C := alpha*A*B**H + conjg( alpha )*B*A**H + beta*C   or   C := alpha*A**H*B + conjg( alpha )*B**H*A + beta*C\n     *\n     * Details: http://www.netlib.org/lapack/explore-html/d7/dfa/zher2k_8f.html\n     *\n     * @param Uplo Specifies whether the upper or lower triangular part of C is to be referenced.\n     * @param Trans The type of transpose applied to the operation.\n     * @param alpha The scalar alpha.\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#F64_2}.\n     * @param B The input allocation contains matrix B, supported elements type {@link Element#F64_2}.\n     * @param beta The scalar beta.\n     * @param C The input allocation contains matrix C, supported elements type {@link Element#F64_2}.\n     ",
    "links" : [ "android.renderscript.Element#F64_2" ]
  }, {
    "name" : "public void BNNM(Allocation A, int a_offset, Allocation B, int b_offset, Allocation C, int c_offset, int c_mult)",
    "returnType" : "void",
    "comment" : "\n     * 8-bit GEMM-like operation for neural networks: C = A * Transpose(B)\n     * Calculations are done in 1.10.21 fixed-point format for the final output,\n     * just before there's a shift down to drop the fractional parts. The output\n     * values are gated to 0 to 255 to fit in a byte, but the 10-bit format\n     * gives some headroom to avoid wrapping around on small overflows.\n     *\n     * @param A The input allocation contains matrix A, supported elements type {@link Element#U8}.\n     * @param a_offset The offset for all values in matrix A, e.g A[i,j] = A[i,j] - a_offset. Value should be from 0 to 255.\n     * @param B The input allocation contains matrix B, supported elements type {@link Element#U8}.\n     * @param b_offset The offset for all values in matrix B, e.g B[i,j] = B[i,j] - b_offset. Value should be from 0 to 255.\n     * @param C The input allocation contains matrix C, supported elements type {@link Element#U8}.\n     * @param c_offset The offset for all values in matrix C.\n     * @param c_mult The multiplier for all values in matrix C, e.g C[i,j] = (C[i,j] + c_offset) * c_mult.\n     *",
    "links" : [ "android.renderscript.Element#U8" ]
  } ],
  "variableNames" : [ "mLUT", "RsBlas_sdsdot", "RsBlas_dsdot", "RsBlas_sdot", "RsBlas_ddot", "RsBlas_cdotu_sub", "RsBlas_cdotc_sub", "RsBlas_zdotu_sub", "RsBlas_zdotc_sub", "RsBlas_snrm2", "RsBlas_sasum", "RsBlas_dnrm2", "RsBlas_dasum", "RsBlas_scnrm2", "RsBlas_scasum", "RsBlas_dznrm2", "RsBlas_dzasum", "RsBlas_isamax", "RsBlas_idamax", "RsBlas_icamax", "RsBlas_izamax", "RsBlas_sswap", "RsBlas_scopy", "RsBlas_saxpy", "RsBlas_dswap", "RsBlas_dcopy", "RsBlas_daxpy", "RsBlas_cswap", "RsBlas_ccopy", "RsBlas_caxpy", "RsBlas_zswap", "RsBlas_zcopy", "RsBlas_zaxpy", "RsBlas_srotg", "RsBlas_srotmg", "RsBlas_srot", "RsBlas_srotm", "RsBlas_drotg", "RsBlas_drotmg", "RsBlas_drot", "RsBlas_drotm", "RsBlas_sscal", "RsBlas_dscal", "RsBlas_cscal", "RsBlas_zscal", "RsBlas_csscal", "RsBlas_zdscal", "RsBlas_sgemv", "RsBlas_sgbmv", "RsBlas_strmv", "RsBlas_stbmv", "RsBlas_stpmv", "RsBlas_strsv", "RsBlas_stbsv", "RsBlas_stpsv", "RsBlas_dgemv", "RsBlas_dgbmv", "RsBlas_dtrmv", "RsBlas_dtbmv", "RsBlas_dtpmv", "RsBlas_dtrsv", "RsBlas_dtbsv", "RsBlas_dtpsv", "RsBlas_cgemv", "RsBlas_cgbmv", "RsBlas_ctrmv", "RsBlas_ctbmv", "RsBlas_ctpmv", "RsBlas_ctrsv", "RsBlas_ctbsv", "RsBlas_ctpsv", "RsBlas_zgemv", "RsBlas_zgbmv", "RsBlas_ztrmv", "RsBlas_ztbmv", "RsBlas_ztpmv", "RsBlas_ztrsv", "RsBlas_ztbsv", "RsBlas_ztpsv", "RsBlas_ssymv", "RsBlas_ssbmv", "RsBlas_sspmv", "RsBlas_sger", "RsBlas_ssyr", "RsBlas_sspr", "RsBlas_ssyr2", "RsBlas_sspr2", "RsBlas_dsymv", "RsBlas_dsbmv", "RsBlas_dspmv", "RsBlas_dger", "RsBlas_dsyr", "RsBlas_dspr", "RsBlas_dsyr2", "RsBlas_dspr2", "RsBlas_chemv", "RsBlas_chbmv", "RsBlas_chpmv", "RsBlas_cgeru", "RsBlas_cgerc", "RsBlas_cher", "RsBlas_chpr", "RsBlas_cher2", "RsBlas_chpr2", "RsBlas_zhemv", "RsBlas_zhbmv", "RsBlas_zhpmv", "RsBlas_zgeru", "RsBlas_zgerc", "RsBlas_zher", "RsBlas_zhpr", "RsBlas_zher2", "RsBlas_zhpr2", "RsBlas_sgemm", "RsBlas_ssymm", "RsBlas_ssyrk", "RsBlas_ssyr2k", "RsBlas_strmm", "RsBlas_strsm", "RsBlas_dgemm", "RsBlas_dsymm", "RsBlas_dsyrk", "RsBlas_dsyr2k", "RsBlas_dtrmm", "RsBlas_dtrsm", "RsBlas_cgemm", "RsBlas_csymm", "RsBlas_csyrk", "RsBlas_csyr2k", "RsBlas_ctrmm", "RsBlas_ctrsm", "RsBlas_zgemm", "RsBlas_zsymm", "RsBlas_zsyrk", "RsBlas_zsyr2k", "RsBlas_ztrmm", "RsBlas_ztrsm", "RsBlas_chemm", "RsBlas_cherk", "RsBlas_cher2k", "RsBlas_zhemm", "RsBlas_zherk", "RsBlas_zher2k", "RsBlas_bnnm", "NO_TRANSPOSE", "TRANSPOSE", "CONJ_TRANSPOSE", "UPPER", "LOWER", "NON_UNIT", "UNIT", "LEFT", "RIGHT" ],
  "methodNames" : [ "public static ScriptIntrinsicBLAS create(RenderScript rs)", " static void validateSide(@Side int Side)", " static void validateTranspose(@Transpose int Trans)", " static void validateConjTranspose(@Transpose int Trans)", " static void validateDiag(@Diag int Diag)", " static void validateUplo(@Uplo int Uplo)", " static void validateGEMV(Element e, int TransA, Allocation A, Allocation X, int incX, Allocation Y, int incY)", "public void SGEMV(@Transpose int TransA, float alpha, Allocation A, Allocation X, int incX, float beta, Allocation Y, int incY)", "public void DGEMV(@Transpose int TransA, double alpha, Allocation A, Allocation X, int incX, double beta, Allocation Y, int incY)", "public void CGEMV(@Transpose int TransA, Float2 alpha, Allocation A, Allocation X, int incX, Float2 beta, Allocation Y, int incY)", "public void ZGEMV(@Transpose int TransA, Double2 alpha, Allocation A, Allocation X, int incX, Double2 beta, Allocation Y, int incY)", "public void SGBMV(@Transpose int TransA, int KL, int KU, float alpha, Allocation A, Allocation X, int incX, float beta, Allocation Y, int incY)", "public void DGBMV(@Transpose int TransA, int KL, int KU, double alpha, Allocation A, Allocation X, int incX, double beta, Allocation Y, int incY)", "public void CGBMV(@Transpose int TransA, int KL, int KU, Float2 alpha, Allocation A, Allocation X, int incX, Float2 beta, Allocation Y, int incY)", "public void ZGBMV(@Transpose int TransA, int KL, int KU, Double2 alpha, Allocation A, Allocation X, int incX, Double2 beta, Allocation Y, int incY)", " static void validateTRMV(Element e, @Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation A, Allocation X, int incX)", " static int validateTPMV(Element e, @Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation Ap, Allocation X, int incX)", "public void STRMV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation A, Allocation X, int incX)", "public void DTRMV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation A, Allocation X, int incX)", "public void CTRMV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation A, Allocation X, int incX)", "public void ZTRMV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation A, Allocation X, int incX)", "public void STBMV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, int K, Allocation A, Allocation X, int incX)", "public void DTBMV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, int K, Allocation A, Allocation X, int incX)", "public void CTBMV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, int K, Allocation A, Allocation X, int incX)", "public void ZTBMV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, int K, Allocation A, Allocation X, int incX)", "public void STPMV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation Ap, Allocation X, int incX)", "public void DTPMV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation Ap, Allocation X, int incX)", "public void CTPMV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation Ap, Allocation X, int incX)", "public void ZTPMV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation Ap, Allocation X, int incX)", "public void STRSV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation A, Allocation X, int incX)", "public void DTRSV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation A, Allocation X, int incX)", "public void CTRSV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation A, Allocation X, int incX)", "public void ZTRSV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation A, Allocation X, int incX)", "public void STBSV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, int K, Allocation A, Allocation X, int incX)", "public void DTBSV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, int K, Allocation A, Allocation X, int incX)", "public void CTBSV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, int K, Allocation A, Allocation X, int incX)", "public void ZTBSV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, int K, Allocation A, Allocation X, int incX)", "public void STPSV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation Ap, Allocation X, int incX)", "public void DTPSV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation Ap, Allocation X, int incX)", "public void CTPSV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation Ap, Allocation X, int incX)", "public void ZTPSV(@Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Allocation Ap, Allocation X, int incX)", " static int validateSYMV(Element e, @Uplo int Uplo, Allocation A, Allocation X, Allocation Y, int incX, int incY)", " static int validateSPMV(Element e, @Uplo int Uplo, Allocation Ap, Allocation X, int incX, Allocation Y, int incY)", " static void validateGER(Element e, Allocation X, int incX, Allocation Y, int incY, Allocation A)", " static int validateSYR(Element e, @Uplo int Uplo, Allocation X, int incX, Allocation A)", " static int validateSPR(Element e, @Uplo int Uplo, Allocation X, int incX, Allocation Ap)", " static int validateSYR2(Element e, @Uplo int Uplo, Allocation X, int incX, Allocation Y, int incY, Allocation A)", " static int validateSPR2(Element e, @Uplo int Uplo, Allocation X, int incX, Allocation Y, int incY, Allocation Ap)", "public void SSYMV(@Uplo int Uplo, float alpha, Allocation A, Allocation X, int incX, float beta, Allocation Y, int incY)", "public void SSBMV(@Uplo int Uplo, int K, float alpha, Allocation A, Allocation X, int incX, float beta, Allocation Y, int incY)", "public void SSPMV(@Uplo int Uplo, float alpha, Allocation Ap, Allocation X, int incX, float beta, Allocation Y, int incY)", "public void SGER(float alpha, Allocation X, int incX, Allocation Y, int incY, Allocation A)", "public void SSYR(@Uplo int Uplo, float alpha, Allocation X, int incX, Allocation A)", "public void SSPR(@Uplo int Uplo, float alpha, Allocation X, int incX, Allocation Ap)", "public void SSYR2(@Uplo int Uplo, float alpha, Allocation X, int incX, Allocation Y, int incY, Allocation A)", "public void SSPR2(@Uplo int Uplo, float alpha, Allocation X, int incX, Allocation Y, int incY, Allocation Ap)", "public void DSYMV(@Uplo int Uplo, double alpha, Allocation A, Allocation X, int incX, double beta, Allocation Y, int incY)", "public void DSBMV(@Uplo int Uplo, int K, double alpha, Allocation A, Allocation X, int incX, double beta, Allocation Y, int incY)", "public void DSPMV(@Uplo int Uplo, double alpha, Allocation Ap, Allocation X, int incX, double beta, Allocation Y, int incY)", "public void DGER(double alpha, Allocation X, int incX, Allocation Y, int incY, Allocation A)", "public void DSYR(@Uplo int Uplo, double alpha, Allocation X, int incX, Allocation A)", "public void DSPR(@Uplo int Uplo, double alpha, Allocation X, int incX, Allocation Ap)", "public void DSYR2(@Uplo int Uplo, double alpha, Allocation X, int incX, Allocation Y, int incY, Allocation A)", "public void DSPR2(@Uplo int Uplo, double alpha, Allocation X, int incX, Allocation Y, int incY, Allocation Ap)", " static void validateGERU(Element e, Allocation X, int incX, Allocation Y, int incY, Allocation A)", "public void CHEMV(@Uplo int Uplo, Float2 alpha, Allocation A, Allocation X, int incX, Float2 beta, Allocation Y, int incY)", "public void CHBMV(@Uplo int Uplo, int K, Float2 alpha, Allocation A, Allocation X, int incX, Float2 beta, Allocation Y, int incY)", "public void CHPMV(@Uplo int Uplo, Float2 alpha, Allocation Ap, Allocation X, int incX, Float2 beta, Allocation Y, int incY)", "public void CGERU(Float2 alpha, Allocation X, int incX, Allocation Y, int incY, Allocation A)", "public void CGERC(Float2 alpha, Allocation X, int incX, Allocation Y, int incY, Allocation A)", "public void CHER(@Uplo int Uplo, float alpha, Allocation X, int incX, Allocation A)", "public void CHPR(@Uplo int Uplo, float alpha, Allocation X, int incX, Allocation Ap)", "public void CHER2(@Uplo int Uplo, Float2 alpha, Allocation X, int incX, Allocation Y, int incY, Allocation A)", "public void CHPR2(@Uplo int Uplo, Float2 alpha, Allocation X, int incX, Allocation Y, int incY, Allocation Ap)", "public void ZHEMV(@Uplo int Uplo, Double2 alpha, Allocation A, Allocation X, int incX, Double2 beta, Allocation Y, int incY)", "public void ZHBMV(@Uplo int Uplo, int K, Double2 alpha, Allocation A, Allocation X, int incX, Double2 beta, Allocation Y, int incY)", "public void ZHPMV(@Uplo int Uplo, Double2 alpha, Allocation Ap, Allocation X, int incX, Double2 beta, Allocation Y, int incY)", "public void ZGERU(Double2 alpha, Allocation X, int incX, Allocation Y, int incY, Allocation A)", "public void ZGERC(Double2 alpha, Allocation X, int incX, Allocation Y, int incY, Allocation A)", "public void ZHER(@Uplo int Uplo, double alpha, Allocation X, int incX, Allocation A)", "public void ZHPR(@Uplo int Uplo, double alpha, Allocation X, int incX, Allocation Ap)", "public void ZHER2(@Uplo int Uplo, Double2 alpha, Allocation X, int incX, Allocation Y, int incY, Allocation A)", "public void ZHPR2(@Uplo int Uplo, Double2 alpha, Allocation X, int incX, Allocation Y, int incY, Allocation Ap)", " static void validateL3(Element e, int TransA, int TransB, int Side, Allocation A, Allocation B, Allocation C)", "public void SGEMM(@Transpose int TransA, @Transpose int TransB, float alpha, Allocation A, Allocation B, float beta, Allocation C)", "public void DGEMM(@Transpose int TransA, @Transpose int TransB, double alpha, Allocation A, Allocation B, double beta, Allocation C)", "public void CGEMM(@Transpose int TransA, @Transpose int TransB, Float2 alpha, Allocation A, Allocation B, Float2 beta, Allocation C)", "public void ZGEMM(@Transpose int TransA, @Transpose int TransB, Double2 alpha, Allocation A, Allocation B, Double2 beta, Allocation C)", "public void SSYMM(@Side int Side, @Uplo int Uplo, float alpha, Allocation A, Allocation B, float beta, Allocation C)", "public void DSYMM(@Side int Side, @Uplo int Uplo, double alpha, Allocation A, Allocation B, double beta, Allocation C)", "public void CSYMM(@Side int Side, @Uplo int Uplo, Float2 alpha, Allocation A, Allocation B, Float2 beta, Allocation C)", "public void ZSYMM(@Side int Side, @Uplo int Uplo, Double2 alpha, Allocation A, Allocation B, Double2 beta, Allocation C)", "public void SSYRK(@Uplo int Uplo, @Transpose int Trans, float alpha, Allocation A, float beta, Allocation C)", "public void DSYRK(@Uplo int Uplo, @Transpose int Trans, double alpha, Allocation A, double beta, Allocation C)", "public void CSYRK(@Uplo int Uplo, @Transpose int Trans, Float2 alpha, Allocation A, Float2 beta, Allocation C)", "public void ZSYRK(@Uplo int Uplo, @Transpose int Trans, Double2 alpha, Allocation A, Double2 beta, Allocation C)", " static void validateSYR2K(Element e, @Transpose int Trans, Allocation A, Allocation B, Allocation C)", "public void SSYR2K(@Uplo int Uplo, @Transpose int Trans, float alpha, Allocation A, Allocation B, float beta, Allocation C)", "public void DSYR2K(@Uplo int Uplo, @Transpose int Trans, double alpha, Allocation A, Allocation B, double beta, Allocation C)", "public void CSYR2K(@Uplo int Uplo, @Transpose int Trans, Float2 alpha, Allocation A, Allocation B, Float2 beta, Allocation C)", "public void ZSYR2K(@Uplo int Uplo, @Transpose int Trans, Double2 alpha, Allocation A, Allocation B, Double2 beta, Allocation C)", " static void validateTRMM(Element e, @Side int Side, @Transpose int TransA, Allocation A, Allocation B)", "public void STRMM(@Side int Side, @Uplo int Uplo, @Transpose int TransA, @Diag int Diag, float alpha, Allocation A, Allocation B)", "public void DTRMM(@Side int Side, @Uplo int Uplo, @Transpose int TransA, @Diag int Diag, double alpha, Allocation A, Allocation B)", "public void CTRMM(@Side int Side, @Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Float2 alpha, Allocation A, Allocation B)", "public void ZTRMM(@Side int Side, @Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Double2 alpha, Allocation A, Allocation B)", " static void validateTRSM(Element e, @Side int Side, @Transpose int TransA, Allocation A, Allocation B)", "public void STRSM(@Side int Side, @Uplo int Uplo, @Transpose int TransA, @Diag int Diag, float alpha, Allocation A, Allocation B)", "public void DTRSM(@Side int Side, @Uplo int Uplo, @Transpose int TransA, @Diag int Diag, double alpha, Allocation A, Allocation B)", "public void CTRSM(@Side int Side, @Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Float2 alpha, Allocation A, Allocation B)", "public void ZTRSM(@Side int Side, @Uplo int Uplo, @Transpose int TransA, @Diag int Diag, Double2 alpha, Allocation A, Allocation B)", " static void validateHEMM(Element e, @Side int Side, Allocation A, Allocation B, Allocation C)", "public void CHEMM(@Side int Side, @Uplo int Uplo, Float2 alpha, Allocation A, Allocation B, Float2 beta, Allocation C)", "public void ZHEMM(@Side int Side, @Uplo int Uplo, Double2 alpha, Allocation A, Allocation B, Double2 beta, Allocation C)", " static void validateHERK(Element e, @Transpose int Trans, Allocation A, Allocation C)", "public void CHERK(@Uplo int Uplo, @Transpose int Trans, float alpha, Allocation A, float beta, Allocation C)", "public void ZHERK(@Uplo int Uplo, @Transpose int Trans, double alpha, Allocation A, double beta, Allocation C)", " static void validateHER2K(Element e, @Transpose int Trans, Allocation A, Allocation B, Allocation C)", "public void CHER2K(@Uplo int Uplo, @Transpose int Trans, Float2 alpha, Allocation A, Allocation B, float beta, Allocation C)", "public void ZHER2K(@Uplo int Uplo, @Transpose int Trans, Double2 alpha, Allocation A, Allocation B, double beta, Allocation C)", "public void BNNM(Allocation A, int a_offset, Allocation B, int b_offset, Allocation C, int c_offset, int c_mult)" ]
}