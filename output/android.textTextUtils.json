{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/text/TextUtils.java",
  "packageName" : "android.text",
  "className" : "TextUtils",
  "comment" : "",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ELLIPSIS_FILLER",
    "type" : "char",
    "comment" : " ZERO WIDTH NO-BREAK SPACE",
    "links" : [ ]
  }, {
    "name" : "ELLIPSIS_NORMAL",
    "type" : "String",
    "comment" : " HORIZONTAL ELLIPSIS (…)",
    "links" : [ ]
  }, {
    "name" : "ELLIPSIS_TWO_DOTS",
    "type" : "String",
    "comment" : " TWO DOT LEADER (‥)",
    "links" : [ ]
  }, {
    "name" : "LINE_FEED_CODE_POINT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NBSP_CODE_POINT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SAFE_STRING_FLAG_TRIM",
    "type" : "int",
    "comment" : "\n     * Remove {@link Character#isWhitespace(int) whitespace} and non-breaking spaces from the edges\n     * of the label.\n     *\n     * @see #makeSafeForPresentation(String, int, float, int)\n     ",
    "links" : [ "Character#isWhitespace" ]
  }, {
    "name" : "SAFE_STRING_FLAG_SINGLE_LINE",
    "type" : "int",
    "comment" : "\n     * Force entire string into single line of text (no newlines). Cannot be set at the same time as\n     * {@link #SAFE_STRING_FLAG_FIRST_LINE}.\n     *\n     * @see #makeSafeForPresentation(String, int, float, int)\n     ",
    "links" : [ "#SAFE_STRING_FLAG_FIRST_LINE" ]
  }, {
    "name" : "SAFE_STRING_FLAG_FIRST_LINE",
    "type" : "int",
    "comment" : "\n     * Return only first line of text (truncate at first newline). Cannot be set at the same time as\n     * {@link #SAFE_STRING_FLAG_SINGLE_LINE}.\n     *\n     * @see #makeSafeForPresentation(String, int, float, int)\n     ",
    "links" : [ "#SAFE_STRING_FLAG_SINGLE_LINE" ]
  }, {
    "name" : "ALIGNMENT_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "FIRST_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "FOREGROUND_COLOR_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "RELATIVE_SIZE_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SCALE_X_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "STRIKETHROUGH_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "UNDERLINE_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "STYLE_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "BULLET_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "QUOTE_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "LEADING_MARGIN_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "URL_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "BACKGROUND_COLOR_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "TYPEFACE_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SUPERSCRIPT_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SUBSCRIPT_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ABSOLUTE_SIZE_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "TEXT_APPEARANCE_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ANNOTATION",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SUGGESTION_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SPELL_CHECK_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SUGGESTION_RANGE_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "EASY_EDIT_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "LOCALE_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "TTS_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ACCESSIBILITY_CLICKABLE_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ACCESSIBILITY_URL_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "LINE_BACKGROUND_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "LINE_HEIGHT_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ACCESSIBILITY_REPLACEMENT_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "LAST_SPAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CHAR_SEQUENCE_CREATOR",
    "type" : "Parcelable.Creator<CharSequence>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CAP_MODE_CHARACTERS",
    "type" : "int",
    "comment" : "\n     * Capitalization mode for {@link #getCapsMode}: capitalize all\n     * characters.  This value is explicitly defined to be the same as\n     * {@link InputType#TYPE_TEXT_FLAG_CAP_CHARACTERS}.\n     ",
    "links" : [ "#getCapsMode", "InputType#TYPE_TEXT_FLAG_CAP_CHARACTERS" ]
  }, {
    "name" : "CAP_MODE_WORDS",
    "type" : "int",
    "comment" : "\n     * Capitalization mode for {@link #getCapsMode}: capitalize the first\n     * character of all words.  This value is explicitly defined to be the same as\n     * {@link InputType#TYPE_TEXT_FLAG_CAP_WORDS}.\n     ",
    "links" : [ "#getCapsMode", "InputType#TYPE_TEXT_FLAG_CAP_WORDS" ]
  }, {
    "name" : "CAP_MODE_SENTENCES",
    "type" : "int",
    "comment" : "\n     * Capitalization mode for {@link #getCapsMode}: capitalize the first\n     * character of each sentence.  This value is explicitly defined to be the same as\n     * {@link InputType#TYPE_TEXT_FLAG_CAP_SENTENCES}.\n     ",
    "links" : [ "#getCapsMode", "InputType#TYPE_TEXT_FLAG_CAP_SENTENCES" ]
  }, {
    "name" : "PARCEL_SAFE_TEXT_LENGTH",
    "type" : "int",
    "comment" : "\n     * Intent size limitations prevent sending over a megabyte of data. Limit\n     * text length to 100K characters - 200KB.\n     ",
    "links" : [ ]
  }, {
    "name" : "sLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sTemp",
    "type" : "char[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EMPTY_STRING_ARRAY",
    "type" : "String[]",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static String getEllipsisString(@NonNull TextUtils.TruncateAt method)",
    "returnType" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static void getChars(CharSequence s, int start, int end, char[] dest, int destoff)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static int indexOf(CharSequence s, char ch)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static int indexOf(CharSequence s, char ch, int start)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static int indexOf(CharSequence s, char ch, int start, int end)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static int lastIndexOf(CharSequence s, char ch)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static int lastIndexOf(CharSequence s, char ch, int last)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static int lastIndexOf(CharSequence s, char ch, int start, int last)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static int indexOf(CharSequence s, CharSequence needle)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static int indexOf(CharSequence s, CharSequence needle, int start)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static int indexOf(CharSequence s, CharSequence needle, int start, int end)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean regionMatches(CharSequence one, int toffset, CharSequence two, int ooffset, int len)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static String substring(CharSequence source, int start, int end)",
    "returnType" : "String",
    "comment" : "\n     * Create a new String object containing the given range of characters\n     * from the source string.  This is different than simply calling\n     * {@link CharSequence#subSequence(int, int) CharSequence.subSequence}\n     * in that it does not preserve any style runs in the source sequence,\n     * allowing a more efficient implementation.\n     ",
    "links" : [ "CharSequence#subSequence" ]
  }, {
    "name" : "public static String join(@NonNull CharSequence delimiter, @NonNull Object[] tokens)",
    "returnType" : "String",
    "comment" : "\n     * Returns a string containing the tokens joined by delimiters.\n     *\n     * @param delimiter a CharSequence that will be inserted between the tokens. If null, the string\n     *     \"null\" will be used as the delimiter.\n     * @param tokens an array objects to be joined. Strings will be formed from the objects by\n     *     calling object.toString(). If tokens is null, a NullPointerException will be thrown. If\n     *     tokens is an empty array, an empty string will be returned.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String join(@NonNull CharSequence delimiter, @NonNull Iterable tokens)",
    "returnType" : "String",
    "comment" : "\n     * Returns a string containing the tokens joined by delimiters.\n     *\n     * @param delimiter a CharSequence that will be inserted between the tokens. If null, the string\n     *     \"null\" will be used as the delimiter.\n     * @param tokens an array objects to be joined. Strings will be formed from the objects by\n     *     calling object.toString(). If tokens is null, a NullPointerException will be thrown. If\n     *     tokens is empty, an empty string will be returned.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String[] split(String text, String expression)",
    "returnType" : "String[]",
    "comment" : "\n     *\n     * This method yields the same result as {@code text.split(expression, -1)} except that if\n     * {@code text.isEmpty()} then this method returns an empty array whereas\n     * {@code \"\".split(expression, -1)} would have returned an array with a single {@code \"\"}.\n     *\n     * The {@code -1} means that trailing empty Strings are not removed from the result; for\n     * example split(\"a,\", \",\"  ) returns {\"a\", \"\"}. Note that whether a leading zero-width match\n     * can result in a leading {@code \"\"} depends on whether your app\n     * {@link android.content.pm.ApplicationInfo#targetSdkVersion targets an SDK version}\n     * {@code <= 28}; see {@link Pattern#split(CharSequence, int)}.\n     *\n     * @param text the string to split\n     * @param expression the regular expression to match\n     * @return an array of strings. The array will be empty if text is empty\n     *\n     * @throws NullPointerException if expression or text is null\n     ",
    "links" : [ "android.content.pm.ApplicationInfo#targetSdkVersion", "Pattern#split" ]
  }, {
    "name" : "public static String[] split(String text, Pattern pattern)",
    "returnType" : "String[]",
    "comment" : "\n     * Splits a string on a pattern. This method yields the same result as\n     * {@code pattern.split(text, -1)} except that if {@code text.isEmpty()} then this method\n     * returns an empty array whereas {@code pattern.split(\"\", -1)} would have returned an array\n     * with a single {@code \"\"}.\n     *\n     * The {@code -1} means that trailing empty Strings are not removed from the result;\n     * Note that whether a leading zero-width match can result in a leading {@code \"\"} depends\n     * on whether your app {@link android.content.pm.ApplicationInfo#targetSdkVersion targets\n     * an SDK version} {@code <= 28}; see {@link Pattern#split(CharSequence, int)}.\n     *\n     * @param text the string to split\n     * @param pattern the regular expression to match\n     * @return an array of strings. The array will be empty if text is empty\n     *\n     * @throws NullPointerException if expression or text is null\n     ",
    "links" : [ "android.content.pm.ApplicationInfo#targetSdkVersion", "Pattern#split" ]
  }, {
    "name" : "public static CharSequence stringOrSpannedString(CharSequence source)",
    "returnType" : "CharSequence",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean isEmpty(@Nullable CharSequence str)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the string is null or 0-length.\n     * @param str the string to be examined\n     * @return true if str is null or zero length\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String nullIfEmpty(@Nullable String str)",
    "returnType" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static String emptyIfNull(@Nullable String str)",
    "returnType" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static String firstNotEmpty(@Nullable String a, @NonNull String b)",
    "returnType" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static int length(@Nullable String s)",
    "returnType" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static String safeIntern(String s)",
    "returnType" : "String",
    "comment" : "\n     * @return interned string if it's null.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getTrimmedLength(CharSequence s)",
    "returnType" : "int",
    "comment" : "\n     * Returns the length that the specified CharSequence would have if\n     * spaces and ASCII control characters were trimmed from the start and end,\n     * as by {@link String#trim}.\n     ",
    "links" : [ "String#trim" ]
  }, {
    "name" : "public static boolean equals(CharSequence a, CharSequence b)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if a and b are equal, including if they are both null.\n     * <p><i>Note: In platform versions 1.1 and earlier, this method only worked well if\n     * both the arguments were instances of String.</i></p>\n     * @param a first CharSequence to check\n     * @param b second CharSequence to check\n     * @return true if a and b are equal\n     ",
    "links" : [ ]
  }, {
    "name" : "public static CharSequence getReverse(CharSequence source, int start, int end)",
    "returnType" : "CharSequence",
    "comment" : "\n     * This function only reverses individual {@code char}s and not their associated\n     * spans. It doesn't support surrogate pairs (that correspond to non-BMP code points), combining\n     * sequences or conjuncts either.\n     * @deprecated Do not use.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void writeToParcel(@Nullable CharSequence cs, @NonNull Parcel p, int parcelableFlags)",
    "returnType" : "void",
    "comment" : "\n     * Flatten a CharSequence and whatever styles can be copied across processes\n     * into the parcel.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void writeWhere(Parcel p, Spanned sp, Object o)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static void dumpSpans(CharSequence cs, Printer printer, String prefix)",
    "returnType" : "void",
    "comment" : "\n     * Debugging tool to print the spans in a CharSequence.  The output will\n     * be printed one span per line.  If the CharSequence is not a Spanned,\n     * then the entire string will be printed on a single line.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static CharSequence replace(CharSequence template, String[] sources, CharSequence[] destinations)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Return a new CharSequence in which each of the source strings is\n     * replaced by the corresponding element of the destinations.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static CharSequence expandTemplate(CharSequence template, CharSequence... values)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Replace instances of \"^1\", \"^2\", etc. in the\n     * <code>template</code> CharSequence with the corresponding\n     * <code>values</code>.  \"^^\" is used to produce a single caret in\n     * the output.  Only up to 9 replacement values are supported,\n     * \"^10\" will be produce the first replacement value followed by a\n     * '0'.\n     *\n     * @param template the input text containing \"^1\"-style\n     * placeholder values.  This object is not modified; a copy is\n     * returned.\n     *\n     * @param values CharSequences substituted into the template.  The\n     * first is substituted for \"^1\", the second for \"^2\", and so on.\n     *\n     * @return the new CharSequence produced by doing the replacement\n     *\n     * @throws IllegalArgumentException if the template requests a\n     * value that was not provided, or if more than 9 values are\n     * provided.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getOffsetBefore(CharSequence text, int offset)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static int getOffsetAfter(CharSequence text, int offset)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void readSpan(Parcel p, Spannable sp, Object o)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static void copySpansFrom(Spanned source, int start, int end, Class kind, Spannable dest, int destoff)",
    "returnType" : "void",
    "comment" : "\n     * Copies the spans from the region <code>start...end</code> in\n     * <code>source</code> to the region\n     * <code>destoff...destoff+end-start</code> in <code>dest</code>.\n     * Spans in <code>source</code> that begin before <code>start</code>\n     * or end after <code>end</code> but overlap this range are trimmed\n     * as if they began at <code>start</code> or ended at <code>end</code>.\n     *\n     * @throws IndexOutOfBoundsException if any of the copied spans\n     * are out of range in <code>dest</code>.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static CharSequence toUpperCase(@Nullable Locale locale, @NonNull CharSequence source, boolean copySpans)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Transforms a CharSequences to uppercase, copying the sources spans and keeping them spans as\n     * much as possible close to their relative original places. In the case the the uppercase\n     * string is identical to the sources, the source itself is returned instead of being copied.\n     *\n     * If copySpans is set, source must be an instance of Spanned.\n     *\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "private static int toUpperMapToDest(Edits.Iterator iterator, int sourceIndex)",
    "returnType" : "int",
    "comment" : " helper method for toUpperCase()",
    "links" : [ ]
  }, {
    "name" : "public static CharSequence ellipsize(CharSequence text, TextPaint p, float avail, TruncateAt where)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Returns the original text if it fits in the specified width\n     * given the properties of the specified Paint,\n     * or, if it does not fit, a truncated\n     * copy with ellipsis character added at the specified edge or center.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static CharSequence ellipsize(CharSequence text, TextPaint paint, float avail, TruncateAt where, boolean preserveLength, @Nullable EllipsizeCallback callback)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Returns the original text if it fits in the specified width\n     * given the properties of the specified Paint,\n     * or, if it does not fit, a copy with ellipsis character added\n     * at the specified edge or center.\n     * If <code>preserveLength</code> is specified, the returned copy\n     * will be padded with zero-width spaces to preserve the original\n     * length and offsets instead of truncating.\n     * If <code>callback</code> is non-null, it will be called to\n     * report the start and end of the ellipsized range.  TextDirection\n     * is determined by the first strong directional character.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static CharSequence ellipsize(CharSequence text, TextPaint paint, float avail, TruncateAt where, boolean preserveLength, @Nullable EllipsizeCallback callback, TextDirectionHeuristic textDir, String ellipsis)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Returns the original text if it fits in the specified width\n     * given the properties of the specified Paint,\n     * or, if it does not fit, a copy with ellipsis character added\n     * at the specified edge or center.\n     * If <code>preserveLength</code> is specified, the returned copy\n     * will be padded with zero-width spaces to preserve the original\n     * length and offsets instead of truncating.\n     * If <code>callback</code> is non-null, it will be called to\n     * report the start and end of the ellipsized range.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static CharSequence listEllipsize(@Nullable Context context, @Nullable List<CharSequence> elements, @NonNull String separator, @NonNull TextPaint paint, @FloatRange(from = 0.0, fromInclusive = false) float avail, @PluralsRes int moreId)",
    "returnType" : "CharSequence",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static CharSequence commaEllipsize(CharSequence text, TextPaint p, float avail, String oneMore, String more)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Converts a CharSequence of the comma-separated form \"Andy, Bob,\n     * Charles, David\" that is too wide to fit into the specified width\n     * into one like \"Andy, Bob, 2 more\".\n     *\n     * @param text the text to truncate\n     * @param p the Paint with which to measure the text\n     * @param avail the horizontal width available for the text (in pixels)\n     * @param oneMore the string for \"1 more\" in the current locale\n     * @param more the string for \"%d more\" in the current locale\n     *\n     * @deprecated Do not use. This is not internationalized, and has known issues\n     * with right-to-left text, languages that have more than one plural form, languages\n     * that use a different character as a comma-like separator, etc.\n     * Use {@link #listEllipsize} instead.\n     ",
    "links" : [ "#listEllipsize" ]
  }, {
    "name" : "public static CharSequence commaEllipsize(CharSequence text, TextPaint p, float avail, String oneMore, String more, TextDirectionHeuristic textDir)",
    "returnType" : "CharSequence",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " static boolean couldAffectRtl(char c)",
    "returnType" : "boolean",
    "comment" : " package ",
    "links" : [ ]
  }, {
    "name" : " static boolean doesNotNeedBidi(char[] text, int start, int len)",
    "returnType" : "boolean",
    "comment" : " package ",
    "links" : [ ]
  }, {
    "name" : " static char[] obtain(int len)",
    "returnType" : "char[]",
    "comment" : " package ",
    "links" : [ ]
  }, {
    "name" : " static void recycle(char[] temp)",
    "returnType" : "void",
    "comment" : " package ",
    "links" : [ ]
  }, {
    "name" : "public static String htmlEncode(String s)",
    "returnType" : "String",
    "comment" : "\n     * Html-encode the string.\n     * @param s the string to be encoded\n     * @return the encoded string\n     ",
    "links" : [ ]
  }, {
    "name" : "public static CharSequence concat(CharSequence... text)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Returns a CharSequence concatenating the specified CharSequences,\n     * retaining their spans if any.\n     *\n     * If there are no parameters, an empty string will be returned.\n     *\n     * If the number of parameters is exactly one, that parameter is returned as output, even if it\n     * is null.\n     *\n     * If the number of parameters is at least two, any null CharSequence among the parameters is\n     * treated as if it was the string <code>\"null\"</code>.\n     *\n     * If there are paragraph spans in the source CharSequences that satisfy paragraph boundary\n     * requirements in the sources but would no longer satisfy them in the concatenated\n     * CharSequence, they may get extended in the resulting CharSequence or not retained.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isGraphic(CharSequence str)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the given CharSequence contains any printable characters.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isGraphic(char c)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether this character is a printable character.\n     *\n     * This does not support non-BMP characters and should not be used.\n     *\n     * @deprecated Use {@link #isGraphic(CharSequence)} instead.\n     ",
    "links" : [ "#isGraphic" ]
  }, {
    "name" : "public static boolean isDigitsOnly(CharSequence str)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the given CharSequence contains only digits.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isPrintableAscii(final char c)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isPrintableAsciiOnly(final CharSequence str)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getCapsMode(CharSequence cs, int off, int reqModes)",
    "returnType" : "int",
    "comment" : "\n     * Determine what caps mode should be in effect at the current offset in\n     * the text.  Only the mode bits set in <var>reqModes</var> will be\n     * checked.  Note that the caps mode flags here are explicitly defined\n     * to match those in {@link InputType}.\n     *\n     * @param cs The text that should be checked for caps modes.\n     * @param off Location in the text at which to check.\n     * @param reqModes The modes to be checked: may be any combination of\n     * {@link #CAP_MODE_CHARACTERS}, {@link #CAP_MODE_WORDS}, and\n     * {@link #CAP_MODE_SENTENCES}.\n     *\n     * @return Returns the actual capitalization modes that can be in effect\n     * at the current position, which is any combination of\n     * {@link #CAP_MODE_CHARACTERS}, {@link #CAP_MODE_WORDS}, and\n     * {@link #CAP_MODE_SENTENCES}.\n     ",
    "links" : [ "InputType", "#CAP_MODE_CHARACTERS", "#CAP_MODE_WORDS", "#CAP_MODE_SENTENCES", "#CAP_MODE_CHARACTERS", "#CAP_MODE_WORDS", "#CAP_MODE_SENTENCES" ]
  }, {
    "name" : "public static boolean delimitedStringContains(String delimitedString, char delimiter, String item)",
    "returnType" : "boolean",
    "comment" : "\n     * Does a comma-delimited list 'delimitedString' contain a certain item?\n     * (without allocating memory)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static T[] removeEmptySpans(T[] spans, Spanned spanned, Class<T> klass)",
    "returnType" : "T[]",
    "comment" : "\n     * Removes empty spans from the <code>spans</code> array.\n     *\n     * When parsing a Spanned using {@link Spanned#nextSpanTransition(int, int, Class)}, empty spans\n     * will (correctly) create span transitions, and calling getSpans on a slice of text bounded by\n     * one of these transitions will (correctly) include the empty overlapping span.\n     *\n     * However, these empty spans should not be taken into account when layouting or rendering the\n     * string and this method provides a way to filter getSpans' results accordingly.\n     *\n     * @param spans A list of spans retrieved using {@link Spanned#getSpans(int, int, Class)} from\n     * the <code>spanned</code>\n     * @param spanned The Spanned from which spans were extracted\n     * @return A subset of spans where empty spans ({@link Spanned#getSpanStart(Object)}  ==\n     * {@link Spanned#getSpanEnd(Object)} have been removed. The initial order is preserved\n     * @hide\n     ",
    "links" : [ "Spanned#nextSpanTransition", "Spanned#getSpans", "Spanned#getSpanStart", "Spanned#getSpanEnd" ]
  }, {
    "name" : "public static long packRangeInLong(int start, int end)",
    "returnType" : "long",
    "comment" : "\n     * Pack 2 int values into a long, useful as a return value for a range\n     * @see #unpackRangeStartFromLong(long)\n     * @see #unpackRangeEndFromLong(long)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int unpackRangeStartFromLong(long range)",
    "returnType" : "int",
    "comment" : "\n     * Get the start value from a range packed in a long by {@link #packRangeInLong(int, int)}\n     * @see #unpackRangeEndFromLong(long)\n     * @see #packRangeInLong(int, int)\n     * @hide\n     ",
    "links" : [ "#packRangeInLong" ]
  }, {
    "name" : "public static int unpackRangeEndFromLong(long range)",
    "returnType" : "int",
    "comment" : "\n     * Get the end value from a range packed in a long by {@link #packRangeInLong(int, int)}\n     * @see #unpackRangeStartFromLong(long)\n     * @see #packRangeInLong(int, int)\n     * @hide\n     ",
    "links" : [ "#packRangeInLong" ]
  }, {
    "name" : "public static int getLayoutDirectionFromLocale(Locale locale)",
    "returnType" : "int",
    "comment" : "\n     * Return the layout direction for a given Locale\n     *\n     * @param locale the Locale for which we want the layout direction. Can be null.\n     * @return the layout direction. This may be one of:\n     * {@link android.view.View#LAYOUT_DIRECTION_LTR} or\n     * {@link android.view.View#LAYOUT_DIRECTION_RTL}.\n     *\n     * Be careful: this code will need to be updated when vertical scripts will be supported\n     ",
    "links" : [ "android.view.View#LAYOUT_DIRECTION_LTR", "android.view.View#LAYOUT_DIRECTION_RTL" ]
  }, {
    "name" : "public static CharSequence formatSelectedCount(int count)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Return localized string representing the given number of selected items.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean hasStyleSpan(@NonNull Spanned spanned)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether or not the specified spanned text has a style span.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static CharSequence trimNoCopySpans(@Nullable CharSequence charSequence)",
    "returnType" : "CharSequence",
    "comment" : "\n     * If the {@code charSequence} is instance of {@link Spanned}, creates a new copy and\n     * {@link NoCopySpan}'s are removed from the copy. Otherwise the given {@code charSequence} is\n     * returned as it is.\n     *\n     * @hide\n     ",
    "links" : [ "Spanned", "NoCopySpan" ]
  }, {
    "name" : "public static void wrap(StringBuilder builder, String start, String end)",
    "returnType" : "void",
    "comment" : "\n     * Prepends {@code start} and appends {@code end} to a given {@link StringBuilder}\n     *\n     * @hide\n     ",
    "links" : [ "StringBuilder" ]
  }, {
    "name" : "public static T trimToParcelableSize(@Nullable T text)",
    "returnType" : "T",
    "comment" : "\n     * Trims the text to {@link #PARCEL_SAFE_TEXT_LENGTH} length. Returns the string as it is if\n     * the length() is smaller than {@link #PARCEL_SAFE_TEXT_LENGTH}. Used for text that is parceled\n     * into a {@link Parcelable}.\n     *\n     * @hide\n     ",
    "links" : [ "#PARCEL_SAFE_TEXT_LENGTH", "#PARCEL_SAFE_TEXT_LENGTH", "Parcelable" ]
  }, {
    "name" : "public static T trimToSize(@Nullable T text, @IntRange(from = 1) int size)",
    "returnType" : "T",
    "comment" : "\n     * Trims the text to {@code size} length. Returns the string as it is if the length() is\n     * smaller than {@code size}. If chars at {@code size-1} and {@code size} is a surrogate\n     * pair, returns a CharSequence of length {@code size-1}.\n     *\n     * @param size length of the result, should be greater than 0\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static T trimToLengthWithEllipsis(@Nullable T text, @IntRange(from = 1) int size)",
    "returnType" : "T",
    "comment" : "\n     * Trims the {@code text} to the first {@code size} characters and adds an ellipsis if the\n     * resulting string is shorter than the input. This will result in an output string which is\n     * longer than {@code size} for most inputs.\n     *\n     * @param size length of the result, should be greater than 0\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean isNewline(int codePoint)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean isWhiteSpace(int codePoint)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static String withoutPrefix(@Nullable String prefix, @Nullable String str)",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static CharSequence makeSafeForPresentation(@NonNull String unclean, @IntRange(from = 0) int maxCharactersToConsider, @FloatRange(from = 0) float ellipsizeDip, @SafeStringFlags int flags)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Remove html, remove bad characters, and truncate string.\n     *\n     * <p>This method is meant to remove common mistakes and nefarious formatting from strings that\n     * were loaded from untrusted sources (such as other packages).\n     *\n     * <p>This method first {@link Html#fromHtml treats the string like HTML} and then ...\n     * <ul>\n     * <li>Removes new lines or truncates at first new line\n     * <li>Trims the white-space off the end\n     * <li>Truncates the string\n     * </ul>\n     * ... if specified.\n     *\n     * @param unclean The input string\n     * @param maxCharactersToConsider The maximum number of characters of {@code unclean} to\n     *                                consider from the input string. {@code 0} disables this\n     *                                feature.\n     * @param ellipsizeDip Assuming maximum length of the string (in dip), assuming font size 42.\n     *                     This is roughly 50 characters for {@code ellipsizeDip == 1000}.<br />\n     *                     Usually ellipsizing should be left to the view showing the string. If a\n     *                     string is used as an input to another string, it might be useful to\n     *                     control the length of the input string though. {@code 0} disables this\n     *                     feature.\n     * @param flags Flags controlling cleaning behavior (Can be {@link #SAFE_STRING_FLAG_TRIM},\n     *              {@link #SAFE_STRING_FLAG_SINGLE_LINE},\n     *              and {@link #SAFE_STRING_FLAG_FIRST_LINE})\n     *\n     * @return The cleaned string\n     ",
    "links" : [ "Html#fromHtml", "#SAFE_STRING_FLAG_TRIM", "#SAFE_STRING_FLAG_SINGLE_LINE", "#SAFE_STRING_FLAG_FIRST_LINE" ]
  } ],
  "variableNames" : [ "TAG", "ELLIPSIS_FILLER", "ELLIPSIS_NORMAL", "ELLIPSIS_TWO_DOTS", "LINE_FEED_CODE_POINT", "NBSP_CODE_POINT", "SAFE_STRING_FLAG_TRIM", "SAFE_STRING_FLAG_SINGLE_LINE", "SAFE_STRING_FLAG_FIRST_LINE", "ALIGNMENT_SPAN", "FIRST_SPAN", "FOREGROUND_COLOR_SPAN", "RELATIVE_SIZE_SPAN", "SCALE_X_SPAN", "STRIKETHROUGH_SPAN", "UNDERLINE_SPAN", "STYLE_SPAN", "BULLET_SPAN", "QUOTE_SPAN", "LEADING_MARGIN_SPAN", "URL_SPAN", "BACKGROUND_COLOR_SPAN", "TYPEFACE_SPAN", "SUPERSCRIPT_SPAN", "SUBSCRIPT_SPAN", "ABSOLUTE_SIZE_SPAN", "TEXT_APPEARANCE_SPAN", "ANNOTATION", "SUGGESTION_SPAN", "SPELL_CHECK_SPAN", "SUGGESTION_RANGE_SPAN", "EASY_EDIT_SPAN", "LOCALE_SPAN", "TTS_SPAN", "ACCESSIBILITY_CLICKABLE_SPAN", "ACCESSIBILITY_URL_SPAN", "LINE_BACKGROUND_SPAN", "LINE_HEIGHT_SPAN", "ACCESSIBILITY_REPLACEMENT_SPAN", "LAST_SPAN", "CHAR_SEQUENCE_CREATOR", "CAP_MODE_CHARACTERS", "CAP_MODE_WORDS", "CAP_MODE_SENTENCES", "PARCEL_SAFE_TEXT_LENGTH", "sLock", "sTemp", "EMPTY_STRING_ARRAY" ],
  "methodNames" : [ "public static String getEllipsisString(@NonNull TextUtils.TruncateAt method)", "public static void getChars(CharSequence s, int start, int end, char[] dest, int destoff)", "public static int indexOf(CharSequence s, char ch)", "public static int indexOf(CharSequence s, char ch, int start)", "public static int indexOf(CharSequence s, char ch, int start, int end)", "public static int lastIndexOf(CharSequence s, char ch)", "public static int lastIndexOf(CharSequence s, char ch, int last)", "public static int lastIndexOf(CharSequence s, char ch, int start, int last)", "public static int indexOf(CharSequence s, CharSequence needle)", "public static int indexOf(CharSequence s, CharSequence needle, int start)", "public static int indexOf(CharSequence s, CharSequence needle, int start, int end)", "public static boolean regionMatches(CharSequence one, int toffset, CharSequence two, int ooffset, int len)", "public static String substring(CharSequence source, int start, int end)", "public static String join(@NonNull CharSequence delimiter, @NonNull Object[] tokens)", "public static String join(@NonNull CharSequence delimiter, @NonNull Iterable tokens)", "public static String[] split(String text, String expression)", "public static String[] split(String text, Pattern pattern)", "public static CharSequence stringOrSpannedString(CharSequence source)", "public static boolean isEmpty(@Nullable CharSequence str)", "public static String nullIfEmpty(@Nullable String str)", "public static String emptyIfNull(@Nullable String str)", "public static String firstNotEmpty(@Nullable String a, @NonNull String b)", "public static int length(@Nullable String s)", "public static String safeIntern(String s)", "public static int getTrimmedLength(CharSequence s)", "public static boolean equals(CharSequence a, CharSequence b)", "public static CharSequence getReverse(CharSequence source, int start, int end)", "public static void writeToParcel(@Nullable CharSequence cs, @NonNull Parcel p, int parcelableFlags)", "private static void writeWhere(Parcel p, Spanned sp, Object o)", "public static void dumpSpans(CharSequence cs, Printer printer, String prefix)", "public static CharSequence replace(CharSequence template, String[] sources, CharSequence[] destinations)", "public static CharSequence expandTemplate(CharSequence template, CharSequence... values)", "public static int getOffsetBefore(CharSequence text, int offset)", "public static int getOffsetAfter(CharSequence text, int offset)", "private static void readSpan(Parcel p, Spannable sp, Object o)", "public static void copySpansFrom(Spanned source, int start, int end, Class kind, Spannable dest, int destoff)", "public static CharSequence toUpperCase(@Nullable Locale locale, @NonNull CharSequence source, boolean copySpans)", "private static int toUpperMapToDest(Edits.Iterator iterator, int sourceIndex)", "public static CharSequence ellipsize(CharSequence text, TextPaint p, float avail, TruncateAt where)", "public static CharSequence ellipsize(CharSequence text, TextPaint paint, float avail, TruncateAt where, boolean preserveLength, @Nullable EllipsizeCallback callback)", "public static CharSequence ellipsize(CharSequence text, TextPaint paint, float avail, TruncateAt where, boolean preserveLength, @Nullable EllipsizeCallback callback, TextDirectionHeuristic textDir, String ellipsis)", "public static CharSequence listEllipsize(@Nullable Context context, @Nullable List<CharSequence> elements, @NonNull String separator, @NonNull TextPaint paint, @FloatRange(from = 0.0, fromInclusive = false) float avail, @PluralsRes int moreId)", "public static CharSequence commaEllipsize(CharSequence text, TextPaint p, float avail, String oneMore, String more)", "public static CharSequence commaEllipsize(CharSequence text, TextPaint p, float avail, String oneMore, String more, TextDirectionHeuristic textDir)", " static boolean couldAffectRtl(char c)", " static boolean doesNotNeedBidi(char[] text, int start, int len)", " static char[] obtain(int len)", " static void recycle(char[] temp)", "public static String htmlEncode(String s)", "public static CharSequence concat(CharSequence... text)", "public static boolean isGraphic(CharSequence str)", "public static boolean isGraphic(char c)", "public static boolean isDigitsOnly(CharSequence str)", "public static boolean isPrintableAscii(final char c)", "public static boolean isPrintableAsciiOnly(final CharSequence str)", "public static int getCapsMode(CharSequence cs, int off, int reqModes)", "public static boolean delimitedStringContains(String delimitedString, char delimiter, String item)", "public static T[] removeEmptySpans(T[] spans, Spanned spanned, Class<T> klass)", "public static long packRangeInLong(int start, int end)", "public static int unpackRangeStartFromLong(long range)", "public static int unpackRangeEndFromLong(long range)", "public static int getLayoutDirectionFromLocale(Locale locale)", "public static CharSequence formatSelectedCount(int count)", "public static boolean hasStyleSpan(@NonNull Spanned spanned)", "public static CharSequence trimNoCopySpans(@Nullable CharSequence charSequence)", "public static void wrap(StringBuilder builder, String start, String end)", "public static T trimToParcelableSize(@Nullable T text)", "public static T trimToSize(@Nullable T text, @IntRange(from = 1) int size)", "public static T trimToLengthWithEllipsis(@Nullable T text, @IntRange(from = 1) int size)", "private static boolean isNewline(int codePoint)", "private static boolean isWhiteSpace(int codePoint)", "public static String withoutPrefix(@Nullable String prefix, @Nullable String str)", "public static CharSequence makeSafeForPresentation(@NonNull String unclean, @IntRange(from = 0) int maxCharactersToConsider, @FloatRange(from = 0) float ellipsizeDip, @SafeStringFlags int flags)" ]
}