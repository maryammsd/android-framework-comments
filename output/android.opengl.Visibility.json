{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/opengl/Visibility.java",
  "packageName" : "android.opengl",
  "className" : "Visibility",
  "comment" : "\n * A collection of utility methods for computing the visibility of triangle\n * meshes.\n *\n ",
  "variables" : [ ],
  "methods" : [ {
    "name" : "public static native int visibilityTest(float[] ws, int wsOffset, float[] positions, int positionsOffset, char[] indices, int indicesOffset, int indexCount)",
    "returnType" : "int",
    "comment" : "\n     * Test whether a given triangle mesh is visible on the screen. The mesh\n     * is specified as an indexed triangle list.\n     *\n     * @param ws the world space to screen space transform matrix, as an OpenGL\n     * column matrix.\n     * @param wsOffset an index into the ws array where the data starts.\n     * @param positions the vertex positions (x, y, z).\n     * @param positionsOffset the index in the positions array where the data\n     *        starts.\n     * @param indices the indices of the triangle list. The indices are\n     * expressed as chars because they are unsigned 16-bit values.\n     * @param indicesOffset the index in the indices array where the index data\n     *        starts.\n     * @param indexCount the number of indices in use. Typically a multiple of\n     * three. If not a multiple of three, the remaining one or two indices will\n     * be ignored.\n     * @return 2 if all of the mesh is visible, 1 if some part of the mesh is\n     *         visible, 0 if no part is visible.\n     *\n     * @throws IllegalArgumentException if ws is null, wsOffset < 0,\n     * positions is null, positionsOffset < 0, indices is null,\n     * indicesOffset < 0, indicesOffset > indices.length - indexCount\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native int frustumCullSpheres(float[] mvp, int mvpOffset, float[] spheres, int spheresOffset, int spheresCount, int[] results, int resultsOffset, int resultsCapacity)",
    "returnType" : "int",
    "comment" : "\n     * Given an OpenGL ES ModelView-Projection matrix (which implicitly\n     * describes a frustum) and a list of spheres, determine which spheres\n     * intersect the frustum.\n     * <p>\n     * A ModelView-Projection matrix can be computed by multiplying the\n     * a Projection matrix by the a ModelView matrix (in that order.). There\n     * are several possible ways to obtain the current ModelView and\n     * Projection matrices. The most generally applicable way is to keep\n     * track of the current matrices in application code. If that is not\n     * convenient, there are two optional OpenGL ES extensions which may\n     * be used to read the current matrices from OpenGL ES:\n     * <ul>\n     * <li>GL10Ext.glQueryMatrixxOES\n     * <li>GL11.GL_MODELVIEW_MATRIX_FLOAT_AS_INT_BITS_OES and\n     * GL_PROJECTION_MATRIX_FLOAT_AS_INT_BITS_OES\n     * </ul>\n     * The problem with reading back the matrices is that your application\n     * will only work with devices that support the extension(s) that\n     * it uses.\n     * <p>\n     * A frustum is a six-sided truncated pyramid that defines the portion of\n     * world space that is visible in the view.\n     * <p>\n     * Spheres are described as four floating point values: x, y, z, and r, in\n     * world-space coordinates. R is the radius of the sphere.\n     * <p>\n     * @param mvp a float array containing the mode-view-projection matrix\n     * @param mvpOffset The offset of the mvp data within the mvp array.\n     * @param spheres a float array containing the sphere data.\n     * @param spheresOffset an offset into the sphere array where the sphere\n     *        data starts\n     * @param spheresCount the number of spheres to cull.\n     * @param results an integer array containing the indices of the spheres\n     * that are either contained entirely within or intersect the frustum.\n     * @param resultsOffset an offset into the results array where the results\n     *        start.\n     * @param resultsCapacity the number of array elements available for storing\n     *        results.\n     * @return the number of spheres that intersected the frustum. Can be\n     * larger than resultsCapacity, in which case only the first resultsCapacity\n     * results are written into the results array.\n     *\n     * @throws IllegalArgumentException if mvp is null, mvpOffset < 0,\n     * mvpOffset > mvp.length - 16, spheres is null, spheresOffset < 0,\n     * spheresOffset > spheres.length - sphereCount,\n     * results is null, resultsOffset < 0, resultsOffset > results.length -\n     * resultsCapacity.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native void computeBoundingSphere(float[] positions, int positionsOffset, int positionsCount, float[] sphere, int sphereOffset)",
    "returnType" : "void",
    "comment" : "\n     * Compute a bounding sphere for a set of points. It is approximately the\n     * minimal bounding sphere of an axis-aligned box that bounds the points.\n     *\n     * @param positions positions in x, y, z triples\n     * @param positionsOffset offset into positions array\n     * @param positionsCount number of position triples to process\n     * @param sphere array containing the output as (x, y, z, r)\n     * @param sphereOffset offset where the sphere data will be written\n     *\n     * @throws IllegalArgumentException if positions is null,\n     * positionsOffset < 0, positionsOffset > positions.length - positionsCount,\n     * sphere is null, sphereOffset < 0, sphereOffset > sphere.length - 4.\n     ",
    "links" : [ ]
  } ],
  "variableNames" : [ ],
  "methodNames" : [ "public static native int visibilityTest(float[] ws, int wsOffset, float[] positions, int positionsOffset, char[] indices, int indicesOffset, int indexCount)", "public static native int frustumCullSpheres(float[] mvp, int mvpOffset, float[] spheres, int spheresOffset, int spheresCount, int[] results, int resultsOffset, int resultsCapacity)", "public static native void computeBoundingSphere(float[] positions, int positionsOffset, int positionsCount, float[] sphere, int sphereOffset)" ]
}