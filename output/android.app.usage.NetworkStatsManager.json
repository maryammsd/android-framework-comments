{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/app/usage/NetworkStatsManager.java",
  "packageName" : "android.app.usage",
  "className" : "NetworkStatsManager",
  "comment" : "\n * Provides access to network usage history and statistics. Usage data is collected in\n * discrete bins of time called 'Buckets'. See {@link NetworkStats.Bucket} for details.\n * <p />\n * Queries can define a time interval in the form of start and end timestamps (Long.MIN_VALUE and\n * Long.MAX_VALUE can be used to simulate open ended intervals). By default, apps can only obtain\n * data about themselves. See the below note for special cases in which apps can obtain data about\n * other applications.\n * <h3>\n * Summary queries\n * </h3>\n * {@link #querySummaryForDevice} <p />\n * {@link #querySummaryForUser} <p />\n * {@link #querySummary} <p />\n * These queries aggregate network usage across the whole interval. Therefore there will be only one\n * bucket for a particular key, state, metered and roaming combination. In case of the user-wide\n * and device-wide summaries a single bucket containing the totalised network usage is returned.\n * <h3>\n * History queries\n * </h3>\n * {@link #queryDetailsForUid} <p />\n * {@link #queryDetails} <p />\n * These queries do not aggregate over time but do aggregate over state, metered and roaming.\n * Therefore there can be multiple buckets for a particular key. However, all Buckets will have\n * {@code state} {@link NetworkStats.Bucket#STATE_ALL},\n * {@code defaultNetwork} {@link NetworkStats.Bucket#DEFAULT_NETWORK_ALL},\n * {@code metered } {@link NetworkStats.Bucket#METERED_ALL},\n * {@code roaming} {@link NetworkStats.Bucket#ROAMING_ALL}.\n * <p />\n * <b>NOTE:</b> Calling {@link #querySummaryForDevice} or accessing stats for apps other than the\n * calling app requires the permission {@link android.Manifest.permission#PACKAGE_USAGE_STATS},\n * which is a system-level permission and will not be granted to third-party apps. However,\n * declaring the permission implies intention to use the API and the user of the device can grant\n * permission through the Settings application.\n * <p />\n * Profile owner apps are automatically granted permission to query data on the profile they manage\n * (that is, for any query except {@link #querySummaryForDevice}). Device owner apps and carrier-\n * privileged apps likewise get access to usage data for all users on the device.\n * <p />\n * In addition to tethering usage, usage by removed users and apps, and usage by the system\n * is also included in the results for callers with one of these higher levels of access.\n * <p />\n * <b>NOTE:</b> Prior to API level {@value android.os.Build.VERSION_CODES#N}, all calls to these APIs required\n * the above permission, even to access an app's own data usage, and carrier-privileged apps were\n * not included.\n ",
  "links" : [ "#queryDetails", "android.Manifest.permission#PACKAGE_USAGE_STATS", "NetworkStats.Bucket#STATE_ALL", "#querySummaryForUser", "#queryDetailsForUid", "NetworkStats.Bucket", "NetworkStats.Bucket#DEFAULT_NETWORK_ALL", "NetworkStats.Bucket#METERED_ALL", "#querySummaryForDevice", "#querySummary", "NetworkStats.Bucket#ROAMING_ALL" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DBG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CALLBACK_LIMIT_REACHED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CALLBACK_RELEASED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MIN_THRESHOLD_BYTES",
    "type" : "long",
    "comment" : " 2MiB",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mService",
    "type" : "INetworkStatsService",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PREFIX_DEV",
    "type" : "String",
    "comment" : "\n     * @deprecated Use {@link NetworkStatsDataMigrationUtils#PREFIX_XT}\n     * instead.\n     * @hide\n     ",
    "links" : [ "android.net.netstats.NetworkStatsDataMigrationUtils#PREFIX_XT" ]
  }, {
    "name" : "FLAG_POLL_ON_OPEN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "FLAG_POLL_FORCE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "FLAG_AUGMENT_WITH_SUBSCRIPTION_PLAN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_TYPE_5G_NSA",
    "type" : "int",
    "comment" : "\n     * Virtual RAT type to represent 5G NSA (Non Stand Alone) mode, where the primary cell is\n     * still LTE and network allocates a secondary 5G cell so telephony reports RAT = LTE along\n     * with NR state as connected. This is a concept added by NetworkStats on top of the telephony\n     * constants for backward compatibility of metrics so this should not be overlapped with any of\n     * the {@code TelephonyManager.NETWORK_TYPE_*} constants.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "mFlags",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public INetworkStatsService getBinder()",
    "returnType" : "INetworkStatsService",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void setPollOnOpen(boolean pollOnOpen)",
    "returnType" : "void",
    "comment" : " can make no use of this API.",
    "links" : [ ]
  }, {
    "name" : "public void setPollForce(boolean pollForce)",
    "returnType" : "void",
    "comment" : "\n     * Set poll force flag to indicate that calling any subsequent query method will force a stats\n     * poll.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAugmentWithSubscriptionPlan(boolean augmentWithSubscriptionPlan)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public Bucket querySummaryForDevice(@NonNull NetworkTemplate template, long startTime, long endTime)",
    "returnType" : "Bucket",
    "comment" : "\n     * Query network usage statistics summaries.\n     *\n     * Result is summarised data usage for the whole\n     * device. Result is a single Bucket aggregated over time, state, uid, tag, metered, and\n     * roaming. This means the bucket's start and end timestamp will be the same as the\n     * 'startTime' and 'endTime' arguments. State is going to be\n     * {@link NetworkStats.Bucket#STATE_ALL}, uid {@link NetworkStats.Bucket#UID_ALL},\n     * tag {@link NetworkStats.Bucket#TAG_NONE},\n     * default network {@link NetworkStats.Bucket#DEFAULT_NETWORK_ALL},\n     * metered {@link NetworkStats.Bucket#METERED_ALL},\n     * and roaming {@link NetworkStats.Bucket#ROAMING_ALL}.\n     * This may take a long time, and apps should avoid calling this on their main thread.\n     *\n     * @param template Template used to match networks. See {@link NetworkTemplate}.\n     * @param startTime Start of period, in milliseconds since the Unix epoch, see\n     *            {@link java.lang.System#currentTimeMillis}.\n     * @param endTime End of period, in milliseconds since the Unix epoch, see\n     *            {@link java.lang.System#currentTimeMillis}.\n     * @return Bucket Summarised data usage.\n     *\n     * @hide\n     ",
    "links" : [ "NetworkStats.Bucket#UID_ALL", "NetworkStats.Bucket#STATE_ALL", "NetworkStats.Bucket#DEFAULT_NETWORK_ALL", "NetworkStats.Bucket#METERED_ALL", "NetworkStats.Bucket#TAG_NONE", "java.lang.System#currentTimeMillis", "android.net.NetworkTemplate", "NetworkStats.Bucket#ROAMING_ALL" ]
  }, {
    "name" : "public Bucket querySummaryForDevice(int networkType, @Nullable String subscriberId, long startTime, long endTime) throws SecurityException, RemoteException",
    "returnType" : "Bucket",
    "comment" : "\n     * Query network usage statistics summaries. Result is summarised data usage for the whole\n     * device. Result is a single Bucket aggregated over time, state, uid, tag, metered, and\n     * roaming. This means the bucket's start and end timestamp are going to be the same as the\n     * 'startTime' and 'endTime' parameters. State is going to be\n     * {@link NetworkStats.Bucket#STATE_ALL}, uid {@link NetworkStats.Bucket#UID_ALL},\n     * tag {@link NetworkStats.Bucket#TAG_NONE},\n     * default network {@link NetworkStats.Bucket#DEFAULT_NETWORK_ALL},\n     * metered {@link NetworkStats.Bucket#METERED_ALL},\n     * and roaming {@link NetworkStats.Bucket#ROAMING_ALL}.\n     * This may take a long time, and apps should avoid calling this on their main thread.\n     *\n     * @param networkType As defined in {@link ConnectivityManager}, e.g.\n     *            {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}\n     *            etc.\n     * @param subscriberId If applicable, the subscriber id of the network interface.\n     *                     <p>Starting with API level 29, the {@code subscriberId} is guarded by\n     *                     additional restrictions. Calling apps that do not meet the new\n     *                     requirements to access the {@code subscriberId} can provide a {@code\n     *                     null} value when querying for the mobile network type to receive usage\n     *                     for all mobile networks. For additional details see {@link\n     *                     TelephonyManager#getSubscriberId()}.\n     *                     <p>Starting with API level 31, calling apps can provide a\n     *                     {@code subscriberId} with wifi network type to receive usage for\n     *                     wifi networks which is under the given subscription if applicable.\n     *                     Otherwise, pass {@code null} when querying all wifi networks.\n     * @param startTime Start of period. Defined in terms of \"Unix time\", see\n     *            {@link java.lang.System#currentTimeMillis}.\n     * @param endTime End of period. Defined in terms of \"Unix time\", see\n     *            {@link java.lang.System#currentTimeMillis}.\n     * @return Bucket object or null if permissions are insufficient or error happened during\n     *         statistics collection.\n     ",
    "links" : [ "NetworkStats.Bucket#UID_ALL", "android.net.ConnectivityManager", "android.net.ConnectivityManager#TYPE_WIFI", "NetworkStats.Bucket#STATE_ALL", "android.telephony.TelephonyManager#getSubscriberId()", "NetworkStats.Bucket#DEFAULT_NETWORK_ALL", "NetworkStats.Bucket#METERED_ALL", "NetworkStats.Bucket#TAG_NONE", "android.net.ConnectivityManager#TYPE_MOBILE", "java.lang.System#currentTimeMillis", "NetworkStats.Bucket#ROAMING_ALL" ]
  }, {
    "name" : "public Bucket querySummaryForUser(int networkType, @Nullable String subscriberId, long startTime, long endTime) throws SecurityException, RemoteException",
    "returnType" : "Bucket",
    "comment" : "\n     * Query network usage statistics summaries. Result is summarised data usage for all uids\n     * belonging to calling user. Result is a single Bucket aggregated over time, state and uid.\n     * This means the bucket's start and end timestamp are going to be the same as the 'startTime'\n     * and 'endTime' parameters. State is going to be {@link NetworkStats.Bucket#STATE_ALL},\n     * uid {@link NetworkStats.Bucket#UID_ALL}, tag {@link NetworkStats.Bucket#TAG_NONE},\n     * metered {@link NetworkStats.Bucket#METERED_ALL}, and roaming\n     * {@link NetworkStats.Bucket#ROAMING_ALL}.\n     * This may take a long time, and apps should avoid calling this on their main thread.\n     *\n     * @param networkType As defined in {@link ConnectivityManager}, e.g.\n     *            {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}\n     *            etc.\n     * @param subscriberId If applicable, the subscriber id of the network interface.\n     *                     <p>Starting with API level 29, the {@code subscriberId} is guarded by\n     *                     additional restrictions. Calling apps that do not meet the new\n     *                     requirements to access the {@code subscriberId} can provide a {@code\n     *                     null} value when querying for the mobile network type to receive usage\n     *                     for all mobile networks. For additional details see {@link\n     *                     TelephonyManager#getSubscriberId()}.\n     *                     <p>Starting with API level 31, calling apps can provide a\n     *                     {@code subscriberId} with wifi network type to receive usage for\n     *                     wifi networks which is under the given subscription if applicable.\n     *                     Otherwise, pass {@code null} when querying all wifi networks.\n     * @param startTime Start of period. Defined in terms of \"Unix time\", see\n     *            {@link java.lang.System#currentTimeMillis}.\n     * @param endTime End of period. Defined in terms of \"Unix time\", see\n     *            {@link java.lang.System#currentTimeMillis}.\n     * @return Bucket object or null if permissions are insufficient or error happened during\n     *         statistics collection.\n     ",
    "links" : [ "NetworkStats.Bucket#UID_ALL", "android.net.ConnectivityManager", "android.net.ConnectivityManager#TYPE_WIFI", "NetworkStats.Bucket#STATE_ALL", "android.telephony.TelephonyManager#getSubscriberId()", "NetworkStats.Bucket#METERED_ALL", "NetworkStats.Bucket#TAG_NONE", "android.net.ConnectivityManager#TYPE_MOBILE", "java.lang.System#currentTimeMillis", "NetworkStats.Bucket#ROAMING_ALL" ]
  }, {
    "name" : "public NetworkStats querySummary(int networkType, @Nullable String subscriberId, long startTime, long endTime) throws SecurityException, RemoteException",
    "returnType" : "NetworkStats",
    "comment" : "\n     * Query network usage statistics summaries. Result filtered to include only uids belonging to\n     * calling user. Result is aggregated over time, hence all buckets will have the same start and\n     * end timestamps. Not aggregated over state, uid, default network, metered, or roaming. This\n     * means buckets' start and end timestamps are going to be the same as the 'startTime' and\n     * 'endTime' parameters. State, uid, metered, and roaming are going to vary, and tag is going to\n     * be the same.\n     * This may take a long time, and apps should avoid calling this on their main thread.\n     *\n     * @param networkType As defined in {@link ConnectivityManager}, e.g.\n     *            {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}\n     *            etc.\n     * @param subscriberId If applicable, the subscriber id of the network interface.\n     *                     <p>Starting with API level 29, the {@code subscriberId} is guarded by\n     *                     additional restrictions. Calling apps that do not meet the new\n     *                     requirements to access the {@code subscriberId} can provide a {@code\n     *                     null} value when querying for the mobile network type to receive usage\n     *                     for all mobile networks. For additional details see {@link\n     *                     TelephonyManager#getSubscriberId()}.\n     *                     <p>Starting with API level 31, calling apps can provide a\n     *                     {@code subscriberId} with wifi network type to receive usage for\n     *                     wifi networks which is under the given subscription if applicable.\n     *                     Otherwise, pass {@code null} when querying all wifi networks.\n     * @param startTime Start of period. Defined in terms of \"Unix time\", see\n     *            {@link java.lang.System#currentTimeMillis}.\n     * @param endTime End of period. Defined in terms of \"Unix time\", see\n     *            {@link java.lang.System#currentTimeMillis}.\n     * @return Statistics object or null if permissions are insufficient or error happened during\n     *         statistics collection.\n     ",
    "links" : [ "android.net.ConnectivityManager", "android.net.ConnectivityManager#TYPE_WIFI", "android.telephony.TelephonyManager#getSubscriberId()", "android.net.ConnectivityManager#TYPE_MOBILE", "java.lang.System#currentTimeMillis" ]
  }, {
    "name" : "public NetworkStats querySummary(@NonNull NetworkTemplate template, long startTime, long endTime) throws SecurityException",
    "returnType" : "NetworkStats",
    "comment" : "\n     * Query network usage statistics summaries.\n     *\n     * The results will only include traffic made by UIDs belonging to the calling user profile.\n     * The results are aggregated over time, so that all buckets will have the same start and\n     * end timestamps as the passed arguments. Not aggregated over state, uid, default network,\n     * metered, or roaming.\n     * This may take a long time, and apps should avoid calling this on their main thread.\n     *\n     * @param template Template used to match networks. See {@link NetworkTemplate}.\n     * @param startTime Start of period, in milliseconds since the Unix epoch, see\n     *            {@link java.lang.System#currentTimeMillis}.\n     * @param endTime End of period, in milliseconds since the Unix epoch, see\n     *            {@link java.lang.System#currentTimeMillis}.\n     * @return Statistics which is described above.\n     * @hide\n     ",
    "links" : [ "java.lang.System#currentTimeMillis", "android.net.NetworkTemplate" ]
  }, {
    "name" : "public NetworkStats queryTaggedSummary(@NonNull NetworkTemplate template, long startTime, long endTime) throws SecurityException",
    "returnType" : "NetworkStats",
    "comment" : "\n     * Query tagged network usage statistics summaries.\n     *\n     * The results will only include tagged traffic made by UIDs belonging to the calling user\n     * profile. The results are aggregated over time, so that all buckets will have the same\n     * start and end timestamps as the passed arguments. Not aggregated over state, uid,\n     * default network, metered, or roaming.\n     * This may take a long time, and apps should avoid calling this on their main thread.\n     *\n     * @param template Template used to match networks. See {@link NetworkTemplate}.\n     * @param startTime Start of period, in milliseconds since the Unix epoch, see\n     *            {@link System#currentTimeMillis}.\n     * @param endTime End of period, in milliseconds since the Unix epoch, see\n     *            {@link System#currentTimeMillis}.\n     * @return Statistics which is described above.\n     * @hide\n     ",
    "links" : [ "#currentTimeMillis", "android.net.NetworkTemplate" ]
  }, {
    "name" : "public NetworkStats queryDetailsForDevice(@NonNull NetworkTemplate template, long startTime, long endTime)",
    "returnType" : "NetworkStats",
    "comment" : "\n     * Query usage statistics details for networks matching a given {@link NetworkTemplate}.\n     *\n     * Result is not aggregated over time. This means buckets' start and\n     * end timestamps will be between 'startTime' and 'endTime' parameters.\n     * <p>Only includes buckets whose entire time period is included between\n     * startTime and endTime. Doesn't interpolate or return partial buckets.\n     * Since bucket length is in the order of hours, this\n     * method cannot be used to measure data usage on a fine grained time scale.\n     * This may take a long time, and apps should avoid calling this on their main thread.\n     *\n     * @param template Template used to match networks. See {@link NetworkTemplate}.\n     * @param startTime Start of period, in milliseconds since the Unix epoch, see\n     *                  {@link java.lang.System#currentTimeMillis}.\n     * @param endTime End of period, in milliseconds since the Unix epoch, see\n     *                {@link java.lang.System#currentTimeMillis}.\n     * @return Statistics which is described above.\n     * @hide\n     ",
    "links" : [ "java.lang.System#currentTimeMillis", "android.net.NetworkTemplate" ]
  }, {
    "name" : "public NetworkStats queryDetailsForUid(int networkType, @Nullable String subscriberId, long startTime, long endTime, int uid) throws SecurityException",
    "returnType" : "NetworkStats",
    "comment" : "\n     * Query network usage statistics details for a given uid.\n     * This may take a long time, and apps should avoid calling this on their main thread.\n     *\n     * @param networkType As defined in {@link ConnectivityManager}, e.g.\n     *            {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}\n     *            etc.\n     * @param subscriberId If applicable, the subscriber id of the network interface.\n     *                     <p>Starting with API level 29, the {@code subscriberId} is guarded by\n     *                     additional restrictions. Calling apps that do not meet the new\n     *                     requirements to access the {@code subscriberId} can provide a {@code\n     *                     null} value when querying for the mobile network type to receive usage\n     *                     for all mobile networks. For additional details see {@link\n     *                     TelephonyManager#getSubscriberId()}.\n     *                     <p>Starting with API level 31, calling apps can provide a\n     *                     {@code subscriberId} with wifi network type to receive usage for\n     *                     wifi networks which is under the given subscription if applicable.\n     *                     Otherwise, pass {@code null} when querying all wifi networks.\n     * @param startTime Start of period. Defined in terms of \"Unix time\", see\n     *            {@link java.lang.System#currentTimeMillis}.\n     * @param endTime End of period. Defined in terms of \"Unix time\", see\n     *            {@link java.lang.System#currentTimeMillis}.\n     * @param uid UID of app\n     * @return Statistics which is described above.\n     * @throws SecurityException if permissions are insufficient to read network statistics.\n     * @see #queryDetailsForUidTagState(int, String, long, long, int, int, int)\n     ",
    "links" : [ "android.net.ConnectivityManager", "android.net.ConnectivityManager#TYPE_WIFI", "android.telephony.TelephonyManager#getSubscriberId()", "android.net.ConnectivityManager#TYPE_MOBILE", "java.lang.System#currentTimeMillis" ]
  }, {
    "name" : "public NetworkStats queryDetailsForUid(@NonNull NetworkTemplate template, long startTime, long endTime, int uid) throws SecurityException",
    "returnType" : "NetworkStats",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public NetworkStats queryDetailsForUidTag(int networkType, @Nullable String subscriberId, long startTime, long endTime, int uid, int tag) throws SecurityException",
    "returnType" : "NetworkStats",
    "comment" : "\n     * Query network usage statistics details for a given uid and tag.\n     *\n     * This may take a long time, and apps should avoid calling this on their main thread.\n     * Only usable for uids belonging to calling user. Result is not aggregated over time.\n     * This means buckets' start and end timestamps are going to be between 'startTime' and\n     * 'endTime' parameters. The uid is going to be the same as the 'uid' parameter, the tag\n     * the same as the 'tag' parameter, and the state the same as the 'state' parameter.\n     * defaultNetwork is going to be {@link NetworkStats.Bucket#DEFAULT_NETWORK_ALL},\n     * metered is going to be {@link NetworkStats.Bucket#METERED_ALL}, and\n     * roaming is going to be {@link NetworkStats.Bucket#ROAMING_ALL}.\n     * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't\n     * interpolate across partial buckets. Since bucket length is in the order of hours, this\n     * method cannot be used to measure data usage on a fine grained time scale.\n     * This may take a long time, and apps should avoid calling this on their main thread.\n     *\n     * @param networkType As defined in {@link ConnectivityManager}, e.g.\n     *            {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}\n     *            etc.\n     * @param subscriberId If applicable, the subscriber id of the network interface.\n     *                     <p>Starting with API level 29, the {@code subscriberId} is guarded by\n     *                     additional restrictions. Calling apps that do not meet the new\n     *                     requirements to access the {@code subscriberId} can provide a {@code\n     *                     null} value when querying for the mobile network type to receive usage\n     *                     for all mobile networks. For additional details see {@link\n     *                     TelephonyManager#getSubscriberId()}.\n     *                     <p>Starting with API level 31, calling apps can provide a\n     *                     {@code subscriberId} with wifi network type to receive usage for\n     *                     wifi networks which is under the given subscription if applicable.\n     *                     Otherwise, pass {@code null} when querying all wifi networks.\n     * @param startTime Start of period. Defined in terms of \"Unix time\", see\n     *            {@link java.lang.System#currentTimeMillis}.\n     * @param endTime End of period. Defined in terms of \"Unix time\", see\n     *            {@link java.lang.System#currentTimeMillis}.\n     * @param uid UID of app\n     * @param tag TAG of interest. Use {@link NetworkStats.Bucket#TAG_NONE} for aggregated data\n     *            across all the tags.\n     * @return Statistics which is described above.\n     * @throws SecurityException if permissions are insufficient to read network statistics.\n     ",
    "links" : [ "android.net.ConnectivityManager", "android.net.ConnectivityManager#TYPE_WIFI", "android.telephony.TelephonyManager#getSubscriberId()", "NetworkStats.Bucket#DEFAULT_NETWORK_ALL", "NetworkStats.Bucket#METERED_ALL", "NetworkStats.Bucket#TAG_NONE", "android.net.ConnectivityManager#TYPE_MOBILE", "java.lang.System#currentTimeMillis", "NetworkStats.Bucket#ROAMING_ALL" ]
  }, {
    "name" : "public NetworkStats queryDetailsForUidTagState(int networkType, @Nullable String subscriberId, long startTime, long endTime, int uid, int tag, int state) throws SecurityException",
    "returnType" : "NetworkStats",
    "comment" : "\n     * Query network usage statistics details for a given uid, tag, and state.\n     *\n     * Only usable for uids belonging to calling user. Result is not aggregated over time.\n     * This means buckets' start and end timestamps are going to be between 'startTime' and\n     * 'endTime' parameters. The uid is going to be the same as the 'uid' parameter, the tag\n     * the same as the 'tag' parameter, and the state the same as the 'state' parameter.\n     * defaultNetwork is going to be {@link NetworkStats.Bucket#DEFAULT_NETWORK_ALL},\n     * metered is going to be {@link NetworkStats.Bucket#METERED_ALL}, and\n     * roaming is going to be {@link NetworkStats.Bucket#ROAMING_ALL}.\n     * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't\n     * interpolate across partial buckets. Since bucket length is in the order of hours, this\n     * method cannot be used to measure data usage on a fine grained time scale.\n     * This may take a long time, and apps should avoid calling this on their main thread.\n     *\n     * @param networkType As defined in {@link ConnectivityManager}, e.g.\n     *            {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}\n     *            etc.\n     * @param subscriberId If applicable, the subscriber id of the network interface.\n     *                     <p>Starting with API level 29, the {@code subscriberId} is guarded by\n     *                     additional restrictions. Calling apps that do not meet the new\n     *                     requirements to access the {@code subscriberId} can provide a {@code\n     *                     null} value when querying for the mobile network type to receive usage\n     *                     for all mobile networks. For additional details see {@link\n     *                     TelephonyManager#getSubscriberId()}.\n     *                     <p>Starting with API level 31, calling apps can provide a\n     *                     {@code subscriberId} with wifi network type to receive usage for\n     *                     wifi networks which is under the given subscription if applicable.\n     *                     Otherwise, pass {@code null} when querying all wifi networks.\n     * @param startTime Start of period. Defined in terms of \"Unix time\", see\n     *            {@link java.lang.System#currentTimeMillis}.\n     * @param endTime End of period. Defined in terms of \"Unix time\", see\n     *            {@link java.lang.System#currentTimeMillis}.\n     * @param uid UID of app\n     * @param tag TAG of interest. Use {@link NetworkStats.Bucket#TAG_NONE} for aggregated data\n     *            across all the tags.\n     * @param state state of interest. Use {@link NetworkStats.Bucket#STATE_ALL} to aggregate\n     *            traffic from all states.\n     * @return Statistics which is described above.\n     * @throws SecurityException if permissions are insufficient to read network statistics.\n     ",
    "links" : [ "android.net.ConnectivityManager", "android.net.ConnectivityManager#TYPE_WIFI", "NetworkStats.Bucket#STATE_ALL", "android.telephony.TelephonyManager#getSubscriberId()", "NetworkStats.Bucket#DEFAULT_NETWORK_ALL", "NetworkStats.Bucket#METERED_ALL", "NetworkStats.Bucket#TAG_NONE", "android.net.ConnectivityManager#TYPE_MOBILE", "java.lang.System#currentTimeMillis", "NetworkStats.Bucket#ROAMING_ALL" ]
  }, {
    "name" : "public NetworkStats queryDetailsForUidTagState(@NonNull NetworkTemplate template, long startTime, long endTime, int uid, int tag, int state) throws SecurityException",
    "returnType" : "NetworkStats",
    "comment" : "\n     * Query network usage statistics details for a given template, uid, tag, and state.\n     *\n     * Only usable for uids belonging to calling user. Result is not aggregated over time.\n     * This means buckets' start and end timestamps are going to be between 'startTime' and\n     * 'endTime' parameters. The uid is going to be the same as the 'uid' parameter, the tag\n     * the same as the 'tag' parameter, and the state the same as the 'state' parameter.\n     * defaultNetwork is going to be {@link NetworkStats.Bucket#DEFAULT_NETWORK_ALL},\n     * metered is going to be {@link NetworkStats.Bucket#METERED_ALL}, and\n     * roaming is going to be {@link NetworkStats.Bucket#ROAMING_ALL}.\n     * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't\n     * interpolate across partial buckets. Since bucket length is in the order of hours, this\n     * method cannot be used to measure data usage on a fine grained time scale.\n     * This may take a long time, and apps should avoid calling this on their main thread.\n     *\n     * @param template Template used to match networks. See {@link NetworkTemplate}.\n     * @param startTime Start of period, in milliseconds since the Unix epoch, see\n     *                  {@link java.lang.System#currentTimeMillis}.\n     * @param endTime End of period, in milliseconds since the Unix epoch, see\n     *                {@link java.lang.System#currentTimeMillis}.\n     * @param uid UID of app\n     * @param tag TAG of interest. Use {@link NetworkStats.Bucket#TAG_NONE} for aggregated data\n     *            across all the tags.\n     * @param state state of interest. Use {@link NetworkStats.Bucket#STATE_ALL} to aggregate\n     *            traffic from all states.\n     * @return Statistics which is described above.\n     * @hide\n     ",
    "links" : [ "NetworkStats.Bucket#STATE_ALL", "NetworkStats.Bucket#DEFAULT_NETWORK_ALL", "NetworkStats.Bucket#METERED_ALL", "NetworkStats.Bucket#TAG_NONE", "java.lang.System#currentTimeMillis", "android.net.NetworkTemplate", "NetworkStats.Bucket#ROAMING_ALL" ]
  }, {
    "name" : "public NetworkStats queryDetails(int networkType, @Nullable String subscriberId, long startTime, long endTime) throws SecurityException, RemoteException",
    "returnType" : "NetworkStats",
    "comment" : "\n     * Query network usage statistics details. Result filtered to include only uids belonging to\n     * calling user. Result is aggregated over state but not aggregated over time, uid, tag,\n     * metered, nor roaming. This means buckets' start and end timestamps are going to be between\n     * 'startTime' and 'endTime' parameters. State is going to be\n     * {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,\n     * tag {@link NetworkStats.Bucket#TAG_NONE},\n     * default network is going to be {@link NetworkStats.Bucket#DEFAULT_NETWORK_ALL},\n     * metered is going to be {@link NetworkStats.Bucket#METERED_ALL},\n     * and roaming is going to be {@link NetworkStats.Bucket#ROAMING_ALL}.\n     * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't\n     * interpolate across partial buckets. Since bucket length is in the order of hours, this\n     * method cannot be used to measure data usage on a fine grained time scale.\n     * This may take a long time, and apps should avoid calling this on their main thread.\n     *\n     * @param networkType As defined in {@link ConnectivityManager}, e.g.\n     *            {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}\n     *            etc.\n     * @param subscriberId If applicable, the subscriber id of the network interface.\n     *                     <p>Starting with API level 29, the {@code subscriberId} is guarded by\n     *                     additional restrictions. Calling apps that do not meet the new\n     *                     requirements to access the {@code subscriberId} can provide a {@code\n     *                     null} value when querying for the mobile network type to receive usage\n     *                     for all mobile networks. For additional details see {@link\n     *                     TelephonyManager#getSubscriberId()}.\n     *                     <p>Starting with API level 31, calling apps can provide a\n     *                     {@code subscriberId} with wifi network type to receive usage for\n     *                     wifi networks which is under the given subscription if applicable.\n     *                     Otherwise, pass {@code null} when querying all wifi networks.\n     * @param startTime Start of period. Defined in terms of \"Unix time\", see\n     *            {@link java.lang.System#currentTimeMillis}.\n     * @param endTime End of period. Defined in terms of \"Unix time\", see\n     *            {@link java.lang.System#currentTimeMillis}.\n     * @return Statistics object or null if permissions are insufficient or error happened during\n     *         statistics collection.\n     ",
    "links" : [ "android.net.ConnectivityManager", "android.net.ConnectivityManager#TYPE_WIFI", "NetworkStats.Bucket#STATE_ALL", "android.telephony.TelephonyManager#getSubscriberId()", "NetworkStats.Bucket#DEFAULT_NETWORK_ALL", "NetworkStats.Bucket#METERED_ALL", "NetworkStats.Bucket#TAG_NONE", "android.net.ConnectivityManager#TYPE_MOBILE", "java.lang.System#currentTimeMillis", "NetworkStats.Bucket#ROAMING_ALL" ]
  }, {
    "name" : "public android.net.NetworkStats getMobileUidStats()",
    "returnType" : "android.net.NetworkStats",
    "comment" : "\n     * Query realtime mobile network usage statistics.\n     *\n     * Return a snapshot of current UID network statistics for both cellular and satellite (which\n     * also uses same mobile radio as cellular) when called. The snapshot will include any\n     * tethering traffic, video calling data usage and count of\n     * network operations set by {@link TrafficStats#incrementOperationCount}\n     * made over a mobile radio.\n     * The snapshot will not include any statistics that cannot be seen by\n     * the kernel, e.g. statistics reported by {@link NetworkStatsProvider}s.\n     *\n     * @hide\n     ",
    "links" : [ "#incrementOperationCount", "android.net.netstats.provider.NetworkStatsProvider" ]
  }, {
    "name" : "public android.net.NetworkStats getWifiUidStats()",
    "returnType" : "android.net.NetworkStats",
    "comment" : "\n     * Query realtime Wi-Fi network usage statistics.\n     *\n     * Return a snapshot of current UID network statistics, as it applies\n     * to the Wi-Fi radios of the device. The snapshot will include any\n     * tethering traffic, video calling data usage and count of\n     * network operations set by {@link TrafficStats#incrementOperationCount}\n     * made over a Wi-Fi radio.\n     * The snapshot will not include any statistics that cannot be seen by\n     * the kernel, e.g. statistics reported by {@link NetworkStatsProvider}s.\n     *\n     * @hide\n     ",
    "links" : [ "#incrementOperationCount", "android.net.netstats.provider.NetworkStatsProvider" ]
  }, {
    "name" : "public void registerUsageCallback(@NonNull NetworkTemplate template, long thresholdBytes, @NonNull @CallbackExecutor Executor executor, @NonNull UsageCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Registers to receive notifications about data usage on specified networks.\n     *\n     * <p>The callbacks will continue to be called as long as the process is alive or\n     * {@link #unregisterUsageCallback} is called.\n     *\n     * @param template Template used to match networks. See {@link NetworkTemplate}.\n     * @param thresholdBytes Threshold in bytes to be notified on. Provided values lower than 2MiB\n     *                       will be clamped for callers except callers with the NETWORK_STACK\n     *                       permission.\n     * @param executor The executor on which callback will be invoked. The provided {@link Executor}\n     *                 must run callback sequentially, otherwise the order of callbacks cannot be\n     *                 guaranteed.\n     * @param callback The {@link UsageCallback} that the system will call when data usage\n     *                 has exceeded the specified threshold.\n     * @hide\n     ",
    "links" : [ "#unregisterUsageCallback", "android.net.netstats.IUsageCallback", "android.annotation.CallbackExecutor", "android.net.NetworkTemplate" ]
  }, {
    "name" : "public void registerUsageCallback(int networkType, @Nullable String subscriberId, long thresholdBytes, @NonNull UsageCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Registers to receive notifications about data usage on specified networks.\n     *\n     * <p>The callbacks will continue to be called as long as the process is live or\n     * {@link #unregisterUsageCallback} is called.\n     *\n     * @param networkType Type of network to monitor. Either\n    {@link ConnectivityManager#TYPE_MOBILE} or {@link ConnectivityManager#TYPE_WIFI}.\n     * @param subscriberId If applicable, the subscriber id of the network interface.\n     *                     <p>Starting with API level 29, the {@code subscriberId} is guarded by\n     *                     additional restrictions. Calling apps that do not meet the new\n     *                     requirements to access the {@code subscriberId} can provide a {@code\n     *                     null} value when registering for the mobile network type to receive\n     *                     notifications for all mobile networks. For additional details see {@link\n     *                     TelephonyManager#getSubscriberId()}.\n     *                     <p>Starting with API level 31, calling apps can provide a\n     *                     {@code subscriberId} with wifi network type to receive usage for\n     *                     wifi networks which is under the given subscription if applicable.\n     *                     Otherwise, pass {@code null} when querying all wifi networks.\n     * @param thresholdBytes Threshold in bytes to be notified on.\n     * @param callback The {@link UsageCallback} that the system will call when data usage\n     *            has exceeded the specified threshold.\n     ",
    "links" : [ "#unregisterUsageCallback", "android.net.ConnectivityManager#TYPE_WIFI", "android.telephony.TelephonyManager#getSubscriberId()", "android.net.netstats.IUsageCallback", "android.net.ConnectivityManager#TYPE_MOBILE" ]
  }, {
    "name" : "public void registerUsageCallback(int networkType, @Nullable String subscriberId, long thresholdBytes, @NonNull UsageCallback callback, @Nullable Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Registers to receive notifications about data usage on specified networks.\n     *\n     * <p>The callbacks will continue to be called as long as the process is live or\n     * {@link #unregisterUsageCallback} is called.\n     *\n     * @param networkType Type of network to monitor. Either\n                  {@link ConnectivityManager#TYPE_MOBILE} or {@link ConnectivityManager#TYPE_WIFI}.\n     * @param subscriberId If applicable, the subscriber id of the network interface.\n     *                     <p>Starting with API level 29, the {@code subscriberId} is guarded by\n     *                     additional restrictions. Calling apps that do not meet the new\n     *                     requirements to access the {@code subscriberId} can provide a {@code\n     *                     null} value when registering for the mobile network type to receive\n     *                     notifications for all mobile networks. For additional details see {@link\n     *                     TelephonyManager#getSubscriberId()}.\n     *                     <p>Starting with API level 31, calling apps can provide a\n     *                     {@code subscriberId} with wifi network type to receive usage for\n     *                     wifi networks which is under the given subscription if applicable.\n     *                     Otherwise, pass {@code null} when querying all wifi networks.\n     * @param thresholdBytes Threshold in bytes to be notified on.\n     * @param callback The {@link UsageCallback} that the system will call when data usage\n     *            has exceeded the specified threshold.\n     * @param handler to dispatch callback events through, otherwise if {@code null} it uses\n     *            the calling thread.\n     ",
    "links" : [ "#unregisterUsageCallback", "android.net.ConnectivityManager#TYPE_WIFI", "android.telephony.TelephonyManager#getSubscriberId()", "android.net.netstats.IUsageCallback", "android.net.ConnectivityManager#TYPE_MOBILE" ]
  }, {
    "name" : "public void unregisterUsageCallback(@NonNull UsageCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters callbacks on data usage.\n     *\n     * @param callback The {@link UsageCallback} used when registering.\n     ",
    "links" : [ "android.net.netstats.IUsageCallback" ]
  }, {
    "name" : "public void registerNetworkStatsProvider(@NonNull String tag, @NonNull NetworkStatsProvider provider)",
    "returnType" : "void",
    "comment" : "\n     * Registers a custom provider of {@link android.net.NetworkStats} to provide network statistics\n     * to the system. To unregister, invoke {@link #unregisterNetworkStatsProvider}.\n     * Note that no de-duplication of statistics between providers is performed, so each provider\n     * must only report network traffic that is not being reported by any other provider. Also note\n     * that the provider cannot be re-registered after unregistering.\n     *\n     * @param tag a human readable identifier of the custom network stats provider. This is only\n     *            used for debugging.\n     * @param provider the subclass of {@link NetworkStatsProvider} that needs to be\n     *                 registered to the system.\n     * @hide\n     ",
    "links" : [ "android.net.NetworkStats", "#unregisterNetworkStatsProvider", "android.net.netstats.provider.NetworkStatsProvider" ]
  }, {
    "name" : "public void unregisterNetworkStatsProvider(@NonNull NetworkStatsProvider provider)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters an instance of {@link NetworkStatsProvider}.\n     *\n     * @param provider the subclass of {@link NetworkStatsProvider} that needs to be\n     *                 unregistered to the system.\n     * @hide\n     ",
    "links" : [ "android.net.netstats.provider.NetworkStatsProvider" ]
  }, {
    "name" : "private static NetworkTemplate createTemplate(int networkType, @Nullable String subscriberId)",
    "returnType" : "NetworkTemplate",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void notifyNetworkStatus(@NonNull List<Network> defaultNetworks, @NonNull List<NetworkStateSnapshot> networkStateSnapshots, @Nullable String activeIface, @NonNull List<UnderlyingNetworkInfo> underlyingNetworkInfos)",
    "returnType" : "void",
    "comment" : "\n     * Notify {@code NetworkStatsService} about network status changed.\n     *\n     * Notifies NetworkStatsService of network state changes for data usage accounting purposes.\n     *\n     * To avoid races that attribute data usage to wrong network, such as new network with\n     * the same interface after SIM hot-swap, this function will not return until\n     * {@code NetworkStatsService} finishes its work of retrieving traffic statistics from\n     * all data sources.\n     *\n     * @param defaultNetworks the list of all networks that could be used by network traffic that\n     *                        does not explicitly select a network.\n     * @param networkStateSnapshots a list of {@link NetworkStateSnapshot}s, one for\n     *                              each network that is currently connected.\n     * @param activeIface the active (i.e., connected) default network interface for the calling\n     *                    uid. Used to determine on which network future calls to\n     *                    {@link android.net.TrafficStats#incrementOperationCount} applies to.\n     * @param underlyingNetworkInfos the list of underlying network information for all\n     *                               currently-connected VPNs.\n     *\n     * @hide\n     ",
    "links" : [ "android.net.TrafficStats#incrementOperationCount", "android.net.NetworkStateSnapshot" ]
  }, {
    "name" : "public void noteUidForeground(int uid, boolean uidForeground)",
    "returnType" : "void",
    "comment" : "\n     * Mark given UID as being in foreground for stats purposes.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDefaultGlobalAlert(long alertBytes)",
    "returnType" : "void",
    "comment" : "\n     * Set default value of global alert bytes, the value will be clamped to [128kB, 2MB].\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void forceUpdate()",
    "returnType" : "void",
    "comment" : "\n     * Force update of statistics.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setStatsProviderWarningAndLimitAsync(@NonNull String iface, long warning, long limit)",
    "returnType" : "void",
    "comment" : "\n     * Set the warning and limit to all registered custom network stats providers.\n     * Note that invocation of any interface will be sent to all providers.\n     *\n     * Asynchronicity notes : because traffic may be happening on the device at the same time, it\n     * doesn't make sense to wait for the warning and limit to be set – a caller still wouldn't\n     * know when exactly it was effective. All that can matter is that it's done quickly. Also,\n     * this method can't fail, so there is no status to return. All providers will see the new\n     * values soon.\n     * As such, this method returns immediately and sends the warning and limit to all providers\n     * as soon as possible through a one-way binder call.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getCollapsedRatType(int ratType)",
    "returnType" : "int",
    "comment" : "\n     * Get a RAT type representative of a group of RAT types for network statistics.\n     *\n     * Collapse the given Radio Access Technology (RAT) type into a bucket that\n     * is representative of the original RAT type for network statistics. The\n     * mapping mostly corresponds to {@code TelephonyManager#NETWORK_CLASS_BIT_MASK_*}\n     * but with adaptations specific to the virtual types introduced by\n     * networks stats.\n     *\n     * @param ratType An integer defined in {@code TelephonyManager#NETWORK_TYPE_*}.\n     *\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public INetworkStatsService getBinder()", "public void setPollOnOpen(boolean pollOnOpen)", "public void setPollForce(boolean pollForce)", "public void setAugmentWithSubscriptionPlan(boolean augmentWithSubscriptionPlan)", "public Bucket querySummaryForDevice(@NonNull NetworkTemplate template, long startTime, long endTime)", "public Bucket querySummaryForDevice(int networkType, @Nullable String subscriberId, long startTime, long endTime) throws SecurityException, RemoteException", "public Bucket querySummaryForUser(int networkType, @Nullable String subscriberId, long startTime, long endTime) throws SecurityException, RemoteException", "public NetworkStats querySummary(int networkType, @Nullable String subscriberId, long startTime, long endTime) throws SecurityException, RemoteException", "public NetworkStats querySummary(@NonNull NetworkTemplate template, long startTime, long endTime) throws SecurityException", "public NetworkStats queryTaggedSummary(@NonNull NetworkTemplate template, long startTime, long endTime) throws SecurityException", "public NetworkStats queryDetailsForDevice(@NonNull NetworkTemplate template, long startTime, long endTime)", "public NetworkStats queryDetailsForUid(int networkType, @Nullable String subscriberId, long startTime, long endTime, int uid) throws SecurityException", "public NetworkStats queryDetailsForUid(@NonNull NetworkTemplate template, long startTime, long endTime, int uid) throws SecurityException", "public NetworkStats queryDetailsForUidTag(int networkType, @Nullable String subscriberId, long startTime, long endTime, int uid, int tag) throws SecurityException", "public NetworkStats queryDetailsForUidTagState(int networkType, @Nullable String subscriberId, long startTime, long endTime, int uid, int tag, int state) throws SecurityException", "public NetworkStats queryDetailsForUidTagState(@NonNull NetworkTemplate template, long startTime, long endTime, int uid, int tag, int state) throws SecurityException", "public NetworkStats queryDetails(int networkType, @Nullable String subscriberId, long startTime, long endTime) throws SecurityException, RemoteException", "public android.net.NetworkStats getMobileUidStats()", "public android.net.NetworkStats getWifiUidStats()", "public void registerUsageCallback(@NonNull NetworkTemplate template, long thresholdBytes, @NonNull @CallbackExecutor Executor executor, @NonNull UsageCallback callback)", "public void registerUsageCallback(int networkType, @Nullable String subscriberId, long thresholdBytes, @NonNull UsageCallback callback)", "public void registerUsageCallback(int networkType, @Nullable String subscriberId, long thresholdBytes, @NonNull UsageCallback callback, @Nullable Handler handler)", "public void unregisterUsageCallback(@NonNull UsageCallback callback)", "public void registerNetworkStatsProvider(@NonNull String tag, @NonNull NetworkStatsProvider provider)", "public void unregisterNetworkStatsProvider(@NonNull NetworkStatsProvider provider)", "private static NetworkTemplate createTemplate(int networkType, @Nullable String subscriberId)", "public void notifyNetworkStatus(@NonNull List<Network> defaultNetworks, @NonNull List<NetworkStateSnapshot> networkStateSnapshots, @Nullable String activeIface, @NonNull List<UnderlyingNetworkInfo> underlyingNetworkInfos)", "public void noteUidForeground(int uid, boolean uidForeground)", "public void setDefaultGlobalAlert(long alertBytes)", "public void forceUpdate()", "public void setStatsProviderWarningAndLimitAsync(@NonNull String iface, long warning, long limit)", "public static int getCollapsedRatType(int ratType)" ],
  "variableNames" : [ "TAG", "DBG", "CALLBACK_LIMIT_REACHED", "CALLBACK_RELEASED", "MIN_THRESHOLD_BYTES", "mContext", "mService", "PREFIX_DEV", "FLAG_POLL_ON_OPEN", "FLAG_POLL_FORCE", "FLAG_AUGMENT_WITH_SUBSCRIPTION_PLAN", "NETWORK_TYPE_5G_NSA", "mFlags" ]
}