{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/net/wifi/aware/DiscoverySession.java",
  "packageName" : "android.net.wifi.aware",
  "className" : "DiscoverySession",
  "comment" : "\n * A class representing a single publish or subscribe Aware session. This object\n * will not be created directly - only its child classes are available:\n * {@link PublishDiscoverySession} and {@link SubscribeDiscoverySession}. This\n * class provides functionality common to both publish and subscribe discovery sessions:\n * <ul>\n *      <li>Sending messages: {@link #sendMessage(PeerHandle, int, byte[])} method.\n *      <li>Creating a network-specifier when requesting a Aware connection using\n *      {@link WifiAwareNetworkSpecifier.Builder}.\n * </ul>\n * <p>\n * The {@link #close()} method must be called to destroy discovery sessions once they are\n * no longer needed.\n ",
  "links" : [ "WifiAwareNetworkSpecifier.Builder", "#sendMessage(PeerHandle", "#close()", "android.net.wifi.aware.SubscribeDiscoverySession", "android.net.wifi.aware.PublishDiscoverySession" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DBG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "VDBG",
    "type" : "boolean",
    "comment" : " STOPSHIP if true",
    "links" : [ ]
  }, {
    "name" : "MAX_SEND_RETRY_COUNT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMgr",
    "type" : "WeakReference<WifiAwareManager>",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "mClientId",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "mSessionId",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "mTerminated",
    "type" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "mCloseGuard",
    "type" : "CloseGuard",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static int getMaxSendRetryCount()",
    "returnType" : "int",
    "comment" : "\n     * Return the maximum permitted retry count when sending messages using\n     * {@link #sendMessage(PeerHandle, int, byte[], int)}.\n     *\n     * @return Maximum retry count when sending messages.\n     *\n     * @hide\n     ",
    "links" : [ "#sendMessage(PeerHandle" ]
  }, {
    "name" : "public void close()",
    "returnType" : "void",
    "comment" : "\n     * Destroy the publish or subscribe session - free any resources, and stop\n     * transmitting packets on-air (for an active session) or listening for\n     * matches (for a passive session). The session may not be used for any\n     * additional operations after its destruction.\n     * <p>\n     *     This operation must be done on a session which is no longer needed. Otherwise system\n     *     resources will continue to be utilized until the application exits. The only\n     *     exception is a session for which we received a termination callback,\n     *     {@link DiscoverySessionCallback#onSessionTerminated()}.\n     ",
    "links" : [ "android.net.wifi.aware.DiscoverySessionCallback#onSessionTerminated()" ]
  }, {
    "name" : "public void setTerminated()",
    "returnType" : "void",
    "comment" : "\n     * Sets the status of the session to terminated - i.e. an indication that\n     * already terminated rather than executing a termination.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void finalize() throws Throwable",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int getClientId()",
    "returnType" : "int",
    "comment" : "\n     * Access the client ID of the Aware session.\n     *\n     * Note: internal visibility for testing.\n     *\n     * @return The internal client ID.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getSessionId()",
    "returnType" : "int",
    "comment" : "\n     * Access the discovery session ID of the Aware session.\n     *\n     * Note: internal visibility for testing.\n     *\n     * @return The internal discovery session ID.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void sendMessage(@NonNull PeerHandle peerHandle, int messageId, @Nullable byte[] message, int retryCount)",
    "returnType" : "void",
    "comment" : "\n     * Sends a message to the specified destination. Aware messages are transmitted in the context\n     * of a discovery session - executed subsequent to a publish/subscribe\n     * {@link DiscoverySessionCallback#onServiceDiscovered(PeerHandle,\n     * byte[], java.util.List)} event.\n     * <p>\n     *     Aware messages are not guaranteed delivery. Callbacks on\n     *     {@link DiscoverySessionCallback} indicate message was transmitted successfully,\n     *     {@link DiscoverySessionCallback#onMessageSendSucceeded(int)}, or transmission\n     *     failed (possibly after several retries) -\n     *     {@link DiscoverySessionCallback#onMessageSendFailed(int)}.\n     * <p>\n     *     The peer will get a callback indicating a message was received using\n     *     {@link DiscoverySessionCallback#onMessageReceived(PeerHandle,\n     *     byte[])}.\n     *\n     * @param peerHandle The peer's handle for the message. Must be a result of an\n     * {@link DiscoverySessionCallback#onServiceDiscovered(PeerHandle,\n     * byte[], java.util.List)} or\n     * {@link DiscoverySessionCallback#onMessageReceived(PeerHandle,\n     * byte[])} events.\n     * @param messageId An arbitrary integer used by the caller to identify the message. The same\n     *            integer ID will be returned in the callbacks indicating message send success or\n     *            failure. The {@code messageId} is not used internally by the Aware service - it\n     *                  can be arbitrary and non-unique.\n     * @param message The message to be transmitted.\n     * @param retryCount An integer specifying how many additional service-level (as opposed to PHY\n     *            or MAC level) retries should be attempted if there is no ACK from the receiver\n     *            (note: no retransmissions are attempted in other failure cases). A value of 0\n     *            indicates no retries. Max permitted value is {@link #getMaxSendRetryCount()}.\n     *\n     * @hide\n     ",
    "links" : [ "#getMaxSendRetryCount()", "android.net.wifi.aware.DiscoverySessionCallback#onMessageReceived(PeerHandle", "android.net.wifi.aware.DiscoverySessionCallback#onMessageSendFailed(int)", "android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(PeerHandle", "android.net.wifi.aware.DiscoverySessionCallback", "android.net.wifi.aware.DiscoverySessionCallback#onMessageSendSucceeded(int)" ]
  }, {
    "name" : "public void sendMessage(@NonNull PeerHandle peerHandle, int messageId, @Nullable byte[] message)",
    "returnType" : "void",
    "comment" : "\n     * Sends a message to the specified destination. Aware messages are transmitted in the context\n     * of a discovery session - executed subsequent to a publish/subscribe\n     * {@link DiscoverySessionCallback#onServiceDiscovered(PeerHandle,\n     * byte[], java.util.List)} event.\n     * <p>\n     *     Aware messages are not guaranteed delivery. Callbacks on\n     *     {@link DiscoverySessionCallback} indicate message was transmitted successfully,\n     *     {@link DiscoverySessionCallback#onMessageSendSucceeded(int)}, or transmission\n     *     failed (possibly after several retries) -\n     *     {@link DiscoverySessionCallback#onMessageSendFailed(int)}.\n     * <p>\n     * The peer will get a callback indicating a message was received using\n     * {@link DiscoverySessionCallback#onMessageReceived(PeerHandle,\n     * byte[])}.\n     *\n     * @param peerHandle The peer's handle for the message. Must be a result of an\n     * {@link DiscoverySessionCallback#onServiceDiscovered(PeerHandle,\n     * byte[], java.util.List)} or\n     * {@link DiscoverySessionCallback#onMessageReceived(PeerHandle,\n     * byte[])} events.\n     * @param messageId An arbitrary integer used by the caller to identify the message. The same\n     *            integer ID will be returned in the callbacks indicating message send success or\n     *            failure. The {@code messageId} is not used internally by the Aware service - it\n     *                  can be arbitrary and non-unique.\n     * @param message The message to be transmitted.\n     ",
    "links" : [ "android.net.wifi.aware.DiscoverySessionCallback#onMessageReceived(PeerHandle", "android.net.wifi.aware.DiscoverySessionCallback#onMessageSendFailed(int)", "android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(PeerHandle", "android.net.wifi.aware.DiscoverySessionCallback", "android.net.wifi.aware.DiscoverySessionCallback#onMessageSendSucceeded(int)" ]
  }, {
    "name" : "public void initiatePairingRequest(@NonNull PeerHandle peerHandle, @NonNull String peerDeviceAlias, @Characteristics.WifiAwarePairingCipherSuites int cipherSuite, @Nullable String password)",
    "returnType" : "void",
    "comment" : "\n     * Initiate a Wi-Fi Aware Pairing setup request to create a pairing with the target peer.\n     * The Aware pairing request should be done in the context of a discovery session -\n     * after a publish/subscribe\n     * {@link DiscoverySessionCallback#onServiceDiscovered(ServiceDiscoveryInfo)} event is received.\n     * The peer will get a callback indicating a message was received using\n     * {@link DiscoverySessionCallback#onPairingSetupRequestReceived(PeerHandle, int)}.\n     * When the Aware Pairing setup is finished, both sides will receive\n     * {@link DiscoverySessionCallback#onPairingSetupSucceeded(PeerHandle, String)}\n     *\n     * @param peerHandle      The peer's handle for the pairing request. Must be a result of a\n     *                        {@link\n     *                        DiscoverySessionCallback#onServiceDiscovered(ServiceDiscoveryInfo)}\n     *                        or\n     *                        {@link DiscoverySessionCallback#onMessageReceived(PeerHandle, byte[])}\n     *                        events.\n     * @param peerDeviceAlias The alias of paired device set by caller, will help caller to identify\n     *                        the paired device.\n     * @param cipherSuite     The cipher suite to be used to encrypt the link.\n     * @param password        The password used for the pairing setup. If set to empty or null,\n     *                        opportunistic pairing will be used.\n     ",
    "links" : [ "android.net.wifi.aware.DiscoverySessionCallback#onMessageReceived(PeerHandle", "android.net.wifi.aware.DiscoverySessionCallback#onPairingSetupRequestReceived(PeerHandle", "android.net.wifi.aware.DiscoverySessionCallback#onPairingSetupSucceeded(PeerHandle", "android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(ServiceDiscoveryInfo)" ]
  }, {
    "name" : "public void acceptPairingRequest(int requestId, @NonNull PeerHandle peerHandle, @NonNull String peerDeviceAlias, @Characteristics.WifiAwarePairingCipherSuites int cipherSuite, @Nullable String password)",
    "returnType" : "void",
    "comment" : "\n     * Accept and respond to a Wi-Fi Aware Pairing setup request received from peer. This is the\n     * response to the\n     * {@link DiscoverySessionCallback#onPairingSetupRequestReceived(PeerHandle, int)}\n     * When the Aware Pairing setup is finished, both sides will receive\n     * {@link DiscoverySessionCallback#onPairingSetupSucceeded(PeerHandle, String)}\n     *\n     * @param requestId       Id to identify the received pairing session, obtained by\n     *                        {@link\n     *                        DiscoverySessionCallback#onPairingSetupRequestReceived(PeerHandle,\n     *                        int)}\n     * @param peerHandle      The peer's handle for the pairing request. Must be a result of a\n     *                        {@link\n     *                        DiscoverySessionCallback#onServiceDiscovered(ServiceDiscoveryInfo)}\n     *                        or\n     *                        {@link DiscoverySessionCallback#onMessageReceived(PeerHandle, byte[])}\n     *                        events.\n     * @param peerDeviceAlias The alias of paired device set by caller, will help caller to identify\n     *                        the paired device.\n     * @param cipherSuite     The cipher suite to be used to encrypt the link.\n     * @param password        The password is used for the pairing setup. If set to empty or null,\n     *                        opportunistic pairing will be used.\n     ",
    "links" : [ "android.net.wifi.aware.DiscoverySessionCallback#onMessageReceived(PeerHandle", "android.net.wifi.aware.DiscoverySessionCallback#onPairingSetupRequestReceived(PeerHandle", "android.net.wifi.aware.DiscoverySessionCallback#onPairingSetupSucceeded(PeerHandle", "android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(ServiceDiscoveryInfo)" ]
  }, {
    "name" : "public void rejectPairingRequest(int requestId, @NonNull PeerHandle peerHandle)",
    "returnType" : "void",
    "comment" : "\n     * Reject a Wi-Fi Aware Pairing setup request received from peer. This is the\n     * response to the\n     * {@link DiscoverySessionCallback#onPairingSetupRequestReceived(PeerHandle, int)}\n     *\n     * @param requestId       Id to identify the received pairing session, get by\n     *                        {@link\n     *                        DiscoverySessionCallback#onPairingSetupRequestReceived(PeerHandle,\n     *                        int)}\n     * @param peerHandle      The peer's handle for the pairing request. Must be a result of a\n     *                        {@link\n     *                        DiscoverySessionCallback#onServiceDiscovered(ServiceDiscoveryInfo)}\n     *                        or\n     *                        {@link DiscoverySessionCallback#onMessageReceived(PeerHandle, byte[])}\n     *                        events.\n     ",
    "links" : [ "android.net.wifi.aware.DiscoverySessionCallback#onMessageReceived(PeerHandle", "android.net.wifi.aware.DiscoverySessionCallback#onPairingSetupRequestReceived(PeerHandle", "android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(ServiceDiscoveryInfo)" ]
  }, {
    "name" : "public void initiateBootstrappingRequest(@NonNull PeerHandle peerHandle, @AwarePairingConfig.BootstrappingMethod int method)",
    "returnType" : "void",
    "comment" : "\n     * Initiate a Wi-Fi Aware bootstrapping setup request to create a pairing with the target peer.\n     * The Aware bootstrapping request should be done in the context of a discovery session -\n     * after a publish/subscribe\n     * {@link DiscoverySessionCallback#onServiceDiscovered(ServiceDiscoveryInfo)} event is received.\n     * The peer will check if the method can be fulfilled by\n     * {@link AwarePairingConfig.Builder#setBootstrappingMethods(int)}\n     * When the Aware Bootstrapping setup finished, both side will receive\n     * {@link DiscoverySessionCallback#onBootstrappingSucceeded(PeerHandle, int)}\n     * @param peerHandle The peer's handle for the pairing request. Must be a result of an\n     * {@link DiscoverySessionCallback#onServiceDiscovered(ServiceDiscoveryInfo)} or\n     * {@link DiscoverySessionCallback#onMessageReceived(PeerHandle, byte[])} events.\n     * @param method one of the AwarePairingConfig#PAIRING_BOOTSTRAPPING_ values, should be one of\n     *               the methods received from {@link ServiceDiscoveryInfo#getPairingConfig()}\n     *               {@link AwarePairingConfig#getBootstrappingMethods()}\n     ",
    "links" : [ "android.net.wifi.aware.ServiceDiscoveryInfo#getPairingConfig()", "android.net.wifi.aware.AwarePairingConfig#getBootstrappingMethods()", "android.net.wifi.aware.DiscoverySessionCallback#onMessageReceived(PeerHandle", "AwarePairingConfig.Builder#setBootstrappingMethods(int)", "android.net.wifi.aware.DiscoverySessionCallback#onBootstrappingSucceeded(PeerHandle", "android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(ServiceDiscoveryInfo)" ]
  }, {
    "name" : "public void suspend()",
    "returnType" : "void",
    "comment" : "\n     * Put Aware connection into suspension mode to save power. Suspend mode pauses all Wi-Fi Aware\n     * activities for this discovery session including any active NDPs.\n     * <p>\n     * This method would work only for a {@link DiscoverySession} which has been created using\n     * a suspendable {@link PublishConfig} or {@link SubscribeConfig}.\n     *\n     * @see PublishConfig#isSuspendable()\n     * @see SubscribeConfig#isSuspendable()\n     * @hide\n     ",
    "links" : [ "android.net.wifi.aware.DiscoverySession", "android.net.wifi.aware.PublishConfig", "android.net.wifi.aware.SubscribeConfig" ]
  }, {
    "name" : "public void resume()",
    "returnType" : "void",
    "comment" : "\n     * Wake up Aware connection from suspension mode to transmit data. Resumes all paused\n     * Wi-Fi Aware activities and any associated NDPs to a state before they were suspended. Resume\n     * operation will be faster than recreating the corresponding discovery session and NDPs with\n     * the same benefit of power.\n     * <p>\n     * This method would work only for a {@link DiscoverySession} which has been created using\n     * a suspendable {@link PublishConfig} or {@link SubscribeConfig}.\n     *\n     * @see PublishConfig#isSuspendable()\n     * @see SubscribeConfig#isSuspendable()\n     * @hide\n     ",
    "links" : [ "android.net.wifi.aware.DiscoverySession", "android.net.wifi.aware.PublishConfig", "android.net.wifi.aware.SubscribeConfig" ]
  }, {
    "name" : "public NetworkSpecifier createNetworkSpecifierOpen(@NonNull PeerHandle peerHandle)",
    "returnType" : "NetworkSpecifier",
    "comment" : "\n     * Create a {@link android.net.NetworkRequest.Builder#setNetworkSpecifier(NetworkSpecifier)} for\n     * an unencrypted WiFi Aware connection (link) to the specified peer. The\n     * {@link android.net.NetworkRequest.Builder#addTransportType(int)} should be set to\n     * {@link android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE}.\n     * <p>\n     * This method should be used when setting up a connection with a peer discovered through Aware\n     * discovery or communication (in such scenarios the MAC address of the peer is shielded by\n     * an opaque peer ID handle). If an Aware connection is needed to a peer discovered using other\n     * OOB (out-of-band) mechanism then use the alternative\n     * {@link WifiAwareSession#createNetworkSpecifierOpen(int, byte[])} method - which uses the\n     * peer's MAC address.\n     * <p>\n     * Note: per the Wi-Fi Aware specification the roles are fixed - a Subscriber is an INITIATOR\n     * and a Publisher is a RESPONDER.\n     * <p>\n     * To set up an encrypted link use the\n     * {@link #createNetworkSpecifierPassphrase(PeerHandle, String)} API.\n     * @deprecated Use the replacement {@link WifiAwareNetworkSpecifier.Builder}.\n     *\n     * @param peerHandle The peer's handle obtained through\n     * {@link DiscoverySessionCallback#onServiceDiscovered(PeerHandle, byte[], java.util.List)}\n     *                   or\n     *                   {@link DiscoverySessionCallback#onMessageReceived(PeerHandle, byte[])}.\n     *                   On a RESPONDER this value is used to gate the acceptance of a connection\n     *                   request from only that peer.\n     *\n     * @return A {@link NetworkSpecifier} to be used to construct\n     * {@link android.net.NetworkRequest.Builder#setNetworkSpecifier(NetworkSpecifier)} to pass to\n     * {@link android.net.ConnectivityManager#requestNetwork(android.net.NetworkRequest,\n     * android.net.ConnectivityManager.NetworkCallback)}\n     * [or other varieties of that API].\n     ",
    "links" : [ "android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierOpen(int", "android.net.wifi.aware.DiscoverySessionCallback#onMessageReceived(PeerHandle", "WifiAwareNetworkSpecifier.Builder", "android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(PeerHandle", "android.net.ConnectivityManager#requestNetwork(android.net.NetworkRequest", "android.net.NetworkRequest.Builder#addTransportType(int)", "#createNetworkSpecifierPassphrase(PeerHandle", "android.net.NetworkSpecifier", "android.net.NetworkRequest.Builder#setNetworkSpecifier(NetworkSpecifier)", "android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE" ]
  }, {
    "name" : "public NetworkSpecifier createNetworkSpecifierPassphrase(@NonNull PeerHandle peerHandle, @NonNull String passphrase)",
    "returnType" : "NetworkSpecifier",
    "comment" : "\n     * Create a {@link android.net.NetworkRequest.Builder#setNetworkSpecifier(NetworkSpecifier)} for\n     * an encrypted WiFi Aware connection (link) to the specified peer. The\n     * {@link android.net.NetworkRequest.Builder#addTransportType(int)} should be set to\n     * {@link android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE}.\n     * <p>\n     * This method should be used when setting up a connection with a peer discovered through Aware\n     * discovery or communication (in such scenarios the MAC address of the peer is shielded by\n     * an opaque peer ID handle). If an Aware connection is needed to a peer discovered using other\n     * OOB (out-of-band) mechanism then use the alternative\n     * {@link WifiAwareSession#createNetworkSpecifierPassphrase(int, byte[], String)} method -\n     * which uses the peer's MAC address.\n     * <p>\n     * Note: per the Wi-Fi Aware specification the roles are fixed - a Subscriber is an INITIATOR\n     * and a Publisher is a RESPONDER.\n     * @deprecated Use the replacement {@link WifiAwareNetworkSpecifier.Builder}.\n     *\n     * @param peerHandle The peer's handle obtained through\n     * {@link DiscoverySessionCallback#onServiceDiscovered(PeerHandle,\n     * byte[], java.util.List)} or\n     * {@link DiscoverySessionCallback#onMessageReceived(PeerHandle,\n     * byte[])}. On a RESPONDER this value is used to gate the acceptance of a connection request\n     *                   from only that peer.\n     * @param passphrase The passphrase to be used to encrypt the link. The PMK is generated from\n     *                   the passphrase. Use the\n     *                   {@link #createNetworkSpecifierOpen(PeerHandle)} API to\n     *                   specify an open (unencrypted) link.\n     *\n     * @return A {@link NetworkSpecifier} to be used to construct\n     * {@link android.net.NetworkRequest.Builder#setNetworkSpecifier(NetworkSpecifier)} to pass to\n     * {@link android.net.ConnectivityManager#requestNetwork(android.net.NetworkRequest,\n     * android.net.ConnectivityManager.NetworkCallback)}\n     * [or other varieties of that API].\n     ",
    "links" : [ "android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPassphrase(int", "android.net.wifi.aware.DiscoverySessionCallback#onMessageReceived(PeerHandle", "WifiAwareNetworkSpecifier.Builder", "android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(PeerHandle", "android.net.ConnectivityManager#requestNetwork(android.net.NetworkRequest", "android.net.NetworkRequest.Builder#addTransportType(int)", "#createNetworkSpecifierOpen(PeerHandle)", "android.net.NetworkSpecifier", "android.net.NetworkRequest.Builder#setNetworkSpecifier(NetworkSpecifier)", "android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE" ]
  }, {
    "name" : "public NetworkSpecifier createNetworkSpecifierPmk(@NonNull PeerHandle peerHandle, @NonNull byte[] pmk)",
    "returnType" : "NetworkSpecifier",
    "comment" : "\n     * Create a {@link android.net.NetworkRequest.Builder#setNetworkSpecifier(NetworkSpecifier)} for\n     * an encrypted WiFi Aware connection (link) to the specified peer. The\n     * {@link android.net.NetworkRequest.Builder#addTransportType(int)} should be set to\n     * {@link android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE}.\n     * <p>\n     * This method should be used when setting up a connection with a peer discovered through Aware\n     * discovery or communication (in such scenarios the MAC address of the peer is shielded by\n     * an opaque peer ID handle). If an Aware connection is needed to a peer discovered using other\n     * OOB (out-of-band) mechanism then use the alternative\n     * {@link WifiAwareSession#createNetworkSpecifierPmk(int, byte[], byte[])} method - which uses\n     * the peer's MAC address.\n     * <p>\n     * Note: per the Wi-Fi Aware specification the roles are fixed - a Subscriber is an INITIATOR\n     * and a Publisher is a RESPONDER.\n     * @deprecated Use the replacement {@link WifiAwareNetworkSpecifier.Builder}.\n     *\n     * @param peerHandle The peer's handle obtained through\n     * {@link DiscoverySessionCallback#onServiceDiscovered(PeerHandle,\n     * byte[], java.util.List)} or\n     * {@link DiscoverySessionCallback#onMessageReceived(PeerHandle,\n     * byte[])}. On a RESPONDER this value is used to gate the acceptance of a connection request\n     *                   from only that peer.\n     * @param pmk A PMK (pairwise master key, see IEEE 802.11i) specifying the key to use for\n     *            encrypting the data-path. Use the\n     *            {@link #createNetworkSpecifierPassphrase(PeerHandle, String)} to specify a\n     *            Passphrase or {@link #createNetworkSpecifierOpen(PeerHandle)} to specify an\n     *            open (unencrypted) link.\n     *\n     * @return A {@link NetworkSpecifier} to be used to construct\n     * {@link android.net.NetworkRequest.Builder#setNetworkSpecifier(NetworkSpecifier)} to pass to\n     * {@link android.net.ConnectivityManager#requestNetwork(android.net.NetworkRequest,\n     * android.net.ConnectivityManager.NetworkCallback)}\n     * [or other varieties of that API].\n     *\n     * @hide\n     ",
    "links" : [ "android.net.wifi.aware.DiscoverySessionCallback#onMessageReceived(PeerHandle", "WifiAwareNetworkSpecifier.Builder", "android.net.wifi.aware.DiscoverySessionCallback#onServiceDiscovered(PeerHandle", "android.net.ConnectivityManager#requestNetwork(android.net.NetworkRequest", "android.net.NetworkRequest.Builder#addTransportType(int)", "#createNetworkSpecifierPassphrase(PeerHandle", "#createNetworkSpecifierOpen(PeerHandle)", "android.net.NetworkSpecifier", "android.net.NetworkRequest.Builder#setNetworkSpecifier(NetworkSpecifier)", "android.net.NetworkCapabilities#TRANSPORT_WIFI_AWARE", "android.net.wifi.aware.WifiAwareSession#createNetworkSpecifierPmk(int" ]
  } ],
  "methodNames" : [ "public static int getMaxSendRetryCount()", "public void close()", "public void setTerminated()", "protected void finalize() throws Throwable", "public int getClientId()", "public int getSessionId()", "public void sendMessage(@NonNull PeerHandle peerHandle, int messageId, @Nullable byte[] message, int retryCount)", "public void sendMessage(@NonNull PeerHandle peerHandle, int messageId, @Nullable byte[] message)", "public void initiatePairingRequest(@NonNull PeerHandle peerHandle, @NonNull String peerDeviceAlias, @Characteristics.WifiAwarePairingCipherSuites int cipherSuite, @Nullable String password)", "public void acceptPairingRequest(int requestId, @NonNull PeerHandle peerHandle, @NonNull String peerDeviceAlias, @Characteristics.WifiAwarePairingCipherSuites int cipherSuite, @Nullable String password)", "public void rejectPairingRequest(int requestId, @NonNull PeerHandle peerHandle)", "public void initiateBootstrappingRequest(@NonNull PeerHandle peerHandle, @AwarePairingConfig.BootstrappingMethod int method)", "public void suspend()", "public void resume()", "public NetworkSpecifier createNetworkSpecifierOpen(@NonNull PeerHandle peerHandle)", "public NetworkSpecifier createNetworkSpecifierPassphrase(@NonNull PeerHandle peerHandle, @NonNull String passphrase)", "public NetworkSpecifier createNetworkSpecifierPmk(@NonNull PeerHandle peerHandle, @NonNull byte[] pmk)" ],
  "variableNames" : [ "TAG", "DBG", "VDBG", "MAX_SEND_RETRY_COUNT", "mMgr", "mClientId", "mSessionId", "mTerminated", "mCloseGuard" ]
}