{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/content/ContentProvider.java",
  "packageName" : "android.content",
  "className" : "ContentProvider",
  "comment" : "\n * Content providers are one of the primary building blocks of Android applications, providing\n * content to applications. They encapsulate data and provide it to applications through the single\n * {@link ContentResolver} interface. A content provider is only required if you need to share\n * data between multiple applications. For example, the contacts data is used by multiple\n * applications and must be stored in a content provider. If you don't need to share data amongst\n * multiple applications you can use a database directly via\n * {@link android.database.sqlite.SQLiteDatabase}.\n *\n * <p>When a request is made via\n * a {@link ContentResolver} the system inspects the authority of the given URI and passes the\n * request to the content provider registered with the authority. The content provider can interpret\n * the rest of the URI however it wants. The {@link UriMatcher} class is helpful for parsing\n * URIs.</p>\n *\n * <p>The primary methods that need to be implemented are:\n * <ul>\n *   <li>{@link #onCreate} which is called to initialize the provider</li>\n *   <li>{@link #query} which returns data to the caller</li>\n *   <li>{@link #insert} which inserts new data into the content provider</li>\n *   <li>{@link #update} which updates existing data in the content provider</li>\n *   <li>{@link #delete} which deletes data from the content provider</li>\n *   <li>{@link #getType} which returns the MIME type of data in the content provider</li>\n * </ul></p>\n *\n * <p class=\"caution\">Data access methods (such as {@link #insert} and\n * {@link #update}) may be called from many threads at once, and must be thread-safe.\n * Other methods (such as {@link #onCreate}) are only called from the application\n * main thread, and must avoid performing lengthy operations.  See the method\n * descriptions for their expected thread behavior.</p>\n *\n * <p>Requests to {@link ContentResolver} are automatically forwarded to the appropriate\n * ContentProvider instance, so subclasses don't have to worry about the details of\n * cross-process calls.</p>\n *\n * <div class=\"special reference\">\n * <h3>Developer Guides</h3>\n * <p>For more information about using content providers, read the\n * <a href=\"{@docRoot}guide/topics/providers/content-providers.html\">Content Providers</a>\n * developer guide.</p>\n * </div>\n ",
  "links" : [ "android.database.sqlite.SQLiteDatabase", "#getType", "android.content.ContentResolver", "#insert", "#update", "#onCreate", "android.content.UriMatcher", "#query", "#delete" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMyUid",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAuthority",
    "type" : "String",
    "comment" : " performance.",
    "links" : [ ]
  }, {
    "name" : "mAuthorities",
    "type" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mReadPermission",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWritePermission",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPathPermissions",
    "type" : "PathPermission[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mExported",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mNoPerms",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSingleUser",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSystemUserOnly",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUsersRedirectedToOwnerForMedia",
    "type" : "SparseBooleanArray",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCallingAttributionSource",
    "type" : "ThreadLocal<AttributionSource>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTransport",
    "type" : "Transport",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static boolean isAuthorityRedirectedForCloneProfile(String authority)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static ContentProvider coerceToLocalContentProvider(IContentProvider abstractInterface)",
    "returnType" : "ContentProvider",
    "comment" : "\n     * Given an IContentProvider, try to coerce it back to the real\n     * ContentProvider object if it is running in the local process.  This can\n     * be used if you know you are running in the same process as a provider,\n     * and want to get direct access to its implementation details.  Most\n     * clients should not nor have a reason to use it.\n     *\n     * @param abstractInterface The ContentProvider interface that is to be\n     *              coerced.\n     * @return If the IContentProvider is non-{@code null} and local, returns its actual\n     * ContentProvider instance.  Otherwise returns {@code null}.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean checkUser(int pid, int uid, Context context)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean isContentRedirectionAllowedForUser(int incomingUserId)",
    "returnType" : "boolean",
    "comment" : "\n     * Verify that content redirection is allowed or not.\n     * We check:\n     * 1. Type of Authority\n     * 2. UserProperties allow content sharing\n     *\n     * @param incomingUserId - Provider's user-id to be passed should be based upon:\n     *                       1. If client is a cloned app running in user 10, it should be that (10)\n     *                       2. If client is accessing content by hinting user space of content,\n     *                       like sysUi (residing in user 0) accessing 'content://11@media/external'\n     *                       then it should be 11.\n     ",
    "links" : [ ]
  }, {
    "name" : "private int checkPermission(String permission, @NonNull AttributionSource attributionSource)",
    "returnType" : "int",
    "comment" : "\n     * Verify that calling app holds both the given permission and any app-op\n     * associated with that permission.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected int enforceReadPermissionInner(Uri uri, @NonNull AttributionSource attributionSource) throws SecurityException",
    "returnType" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "protected int enforceWritePermissionInner(Uri uri, @NonNull AttributionSource attributionSource) throws SecurityException",
    "returnType" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public final Context getContext()",
    "returnType" : "Context",
    "comment" : "\n     * Retrieves the Context this provider is running in.  Only available once\n     * {@link #onCreate} has been called -- this will return {@code null} in the\n     * constructor.\n     ",
    "links" : [ "#onCreate" ]
  }, {
    "name" : "public final Context requireContext()",
    "returnType" : "Context",
    "comment" : "\n     * Retrieves a Non-Nullable Context this provider is running in, this is intended to be called\n     * after {@link #onCreate}. When called before context was created, an IllegalStateException\n     * will be thrown.\n     * <p>\n     * Note A provider must be declared in the manifest and created automatically by the system,\n     * and context is only available after {@link #onCreate} is called.\n     ",
    "links" : [ "#onCreate" ]
  }, {
    "name" : "private AttributionSource setCallingAttributionSource(@Nullable AttributionSource attributionSource)",
    "returnType" : "AttributionSource",
    "comment" : "\n     * Set the calling package/feature, returning the current value (or {@code null})\n     * which can be used later to restore the previous state.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final String getCallingPackage()",
    "returnType" : "String",
    "comment" : "\n     * Return the package name of the caller that initiated the request being\n     * processed on the current thread. The returned package will have been\n     * verified to belong to the calling UID. Returns {@code null} if not\n     * currently processing a request.\n     * <p>\n     * This will always return {@code null} when processing\n     * {@link #getTypeAnonymous(Uri)} requests\n     *\n     * For {@link #getType(Uri)}  requests, this will be only available for cases, where\n     * the caller can be identified. See {@link #getTypeAnonymous(Uri)}\n     *\n     * @see Binder#getCallingUid()\n     * @see Context#grantUriPermission(String, Uri, int)\n     * @throws SecurityException if the calling package doesn't belong to the\n     *             calling UID.\n     ",
    "links" : [ "#getTypeAnonymous(Uri)", "#getType(Uri)" ]
  }, {
    "name" : "public final AttributionSource getCallingAttributionSource()",
    "returnType" : "AttributionSource",
    "comment" : "\n     * Gets the attribution source of the calling app. If you want to attribute\n     * the data access to the calling app you can create an attribution context\n     * via {@link android.content.Context#createContext(ContextParams)} and passing\n     * this identity to {@link ContextParams.Builder#setNextAttributionSource(\n     * AttributionSource)}.\n     *\n     * @return The identity of the caller for permission purposes.\n     *\n     * @see ContextParams.Builder#setNextAttributionSource(AttributionSource)\n     * @see AttributionSource\n     ",
    "links" : [ "ContextParams.Builder#setNextAttributionSource(", "android.content.Context#createContext(ContextParams)" ]
  }, {
    "name" : "public final String getCallingAttributionTag()",
    "returnType" : "String",
    "comment" : "\n     * Return the attribution tag of the caller that initiated the request being\n     * processed on the current thread. Returns {@code null} if not currently processing\n     * a request of the request is for the default attribution.\n     * <p>\n     * This will always return {@code null} when processing\n     * {@link #getTypeAnonymous(Uri)} requests\n     *\n     * For {@link #getType(Uri)}  requests, this will be only available for cases, where\n     * the caller can be identified. See {@link #getTypeAnonymous(Uri)}\n     *\n     * @see #getCallingPackage\n     ",
    "links" : [ "#getTypeAnonymous(Uri)", "#getType(Uri)" ]
  }, {
    "name" : "public final String getCallingFeatureId()",
    "returnType" : "String",
    "comment" : "\n     * @removed\n     ",
    "links" : [ ]
  }, {
    "name" : "public final String getCallingPackageUnchecked()",
    "returnType" : "String",
    "comment" : "\n     * Return the package name of the caller that initiated the request being\n     * processed on the current thread. The returned package will have\n     * <em>not</em> been verified to belong to the calling UID. Returns\n     * {@code null} if not currently processing a request.\n     * <p>\n     * This will always return {@code null} when processing\n     * {@link #getTypeAnonymous(Uri)} requests\n     *\n     * For {@link #getType(Uri)}  requests, this will be only available for cases, where\n     * the caller can be identified. See {@link #getTypeAnonymous(Uri)}\n     *\n     * @see Binder#getCallingUid()\n     * @see Context#grantUriPermission(String, Uri, int)\n     ",
    "links" : [ "#getTypeAnonymous(Uri)", "#getType(Uri)" ]
  }, {
    "name" : "public void onCallingPackageChanged()",
    "returnType" : "void",
    "comment" : "\n     * Called whenever the value of {@link #getCallingPackage()} changes, giving\n     * the provider an opportunity to invalidate any security related caching it\n     * may be performing.\n     * <p>\n     * This typically happens when a {@link ContentProvider} makes a nested call\n     * back into itself when already processing a call from a remote process.\n     ",
    "links" : [ "#getCallingPackage()", "android.content.ContentProvider" ]
  }, {
    "name" : "public final CallingIdentity clearCallingIdentity()",
    "returnType" : "CallingIdentity",
    "comment" : "\n     * Reset the identity of the incoming IPC on the current thread.\n     * <p>\n     * Internally this calls {@link Binder#clearCallingIdentity()} and also\n     * clears any value stored in {@link #getCallingPackage()}.\n     *\n     * @return Returns an opaque token that can be used to restore the original\n     *         calling identity by passing it to\n     *         {@link #restoreCallingIdentity}.\n     ",
    "links" : [ "#getCallingPackage()", "android.os.Binder#clearCallingIdentity()", "#restoreCallingIdentity" ]
  }, {
    "name" : "public final void restoreCallingIdentity(@NonNull CallingIdentity identity)",
    "returnType" : "void",
    "comment" : "\n     * Restore the identity of the incoming IPC on the current thread back to a\n     * previously identity that was returned by {@link #clearCallingIdentity}.\n     * <p>\n     * Internally this calls {@link Binder#restoreCallingIdentity(long)} and\n     * also restores any value stored in {@link #getCallingPackage()}.\n     ",
    "links" : [ "#getCallingPackage()", "android.os.Binder#restoreCallingIdentity(long)", "#clearCallingIdentity" ]
  }, {
    "name" : "protected final void setAuthorities(String authorities)",
    "returnType" : "void",
    "comment" : "\n     * Change the authorities of the ContentProvider.\n     * This is normally set for you from its manifest information when the provider is first\n     * created.\n     * @hide\n     * @param authorities the semi-colon separated authorities of the ContentProvider.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected final boolean matchesOurAuthorities(String authority)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "protected final void setReadPermission(@Nullable String permission)",
    "returnType" : "void",
    "comment" : "\n     * Change the permission required to read data from the content\n     * provider.  This is normally set for you from its manifest information\n     * when the provider is first created.\n     *\n     * @param permission Name of the permission required for read-only access.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final String getReadPermission()",
    "returnType" : "String",
    "comment" : "\n     * Return the name of the permission required for read-only access to\n     * this content provider.  This method can be called from multiple\n     * threads, as described in\n     * <a href=\"{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads\">Processes\n     * and Threads</a>.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected final void setWritePermission(@Nullable String permission)",
    "returnType" : "void",
    "comment" : "\n     * Change the permission required to read and write data in the content\n     * provider.  This is normally set for you from its manifest information\n     * when the provider is first created.\n     *\n     * @param permission Name of the permission required for read/write access.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final String getWritePermission()",
    "returnType" : "String",
    "comment" : "\n     * Return the name of the permission required for read/write access to\n     * this content provider.  This method can be called from multiple\n     * threads, as described in\n     * <a href=\"{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads\">Processes\n     * and Threads</a>.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected final void setPathPermissions(@Nullable PathPermission[] permissions)",
    "returnType" : "void",
    "comment" : "\n     * Change the path-based permission required to read and/or write data in\n     * the content provider.  This is normally set for you from its manifest\n     * information when the provider is first created.\n     *\n     * @param permissions Array of path permission descriptions.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final PathPermission[] getPathPermissions()",
    "returnType" : "PathPermission[]",
    "comment" : "\n     * Return the path-based permissions required for read and/or write access to\n     * this content provider.  This method can be called from multiple\n     * threads, as described in\n     * <a href=\"{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads\">Processes\n     * and Threads</a>.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void setAppOps(int readOp, int writeOp)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public AppOpsManager getAppOpsManager()",
    "returnType" : "AppOpsManager",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public final void setTransportLoggingEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public abstract boolean onCreate()",
    "returnType" : "boolean",
    "comment" : "\n     * Implement this to initialize your content provider on startup.\n     * This method is called for all registered content providers on the\n     * application main thread at application launch time.  It must not perform\n     * lengthy operations, or application startup will be delayed.\n     *\n     * <p>You should defer nontrivial initialization (such as opening,\n     * upgrading, and scanning databases) until the content provider is used\n     * (via {@link #query}, {@link #insert}, etc).  Deferred initialization\n     * keeps application startup fast, avoids unnecessary work if the provider\n     * turns out not to be needed, and stops database errors (such as a full\n     * disk) from halting application launch.\n     *\n     * <p>If you use SQLite, {@link android.database.sqlite.SQLiteOpenHelper}\n     * is a helpful utility class that makes it easy to manage databases,\n     * and will automatically defer opening until first use.  If you do use\n     * SQLiteOpenHelper, make sure to avoid calling\n     * {@link android.database.sqlite.SQLiteOpenHelper#getReadableDatabase} or\n     * {@link android.database.sqlite.SQLiteOpenHelper#getWritableDatabase}\n     * from this method.  (Instead, override\n     * {@link android.database.sqlite.SQLiteOpenHelper#onOpen} to initialize the\n     * database when it is first opened.)\n     *\n     * @return true if the provider was successfully loaded, false otherwise\n     ",
    "links" : [ "android.database.sqlite.SQLiteOpenHelper#getReadableDatabase", "android.database.sqlite.SQLiteOpenHelper#onOpen", "android.database.sqlite.SQLiteOpenHelper", "#insert", "#query", "android.database.sqlite.SQLiteOpenHelper#getWritableDatabase" ]
  }, {
    "name" : "public void onConfigurationChanged(Configuration newConfig)",
    "returnType" : "void",
    "comment" : "\n     * {@inheritDoc}\n     * This method is always called on the application main thread, and must\n     * not perform lengthy operations.\n     *\n     * <p>The default content provider implementation does nothing.\n     * Override this method to take appropriate action.\n     * (Content providers do not usually care about things like screen\n     * orientation, but may want to know about locale changes.)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onLowMemory()",
    "returnType" : "void",
    "comment" : "\n     * {@inheritDoc}\n     * This method is always called on the application main thread, and must\n     * not perform lengthy operations.\n     *\n     * <p>The default content provider implementation does nothing.\n     * Subclasses may override this method to take appropriate action.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onTrimMemory(int level)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public abstract Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder)",
    "returnType" : "Cursor",
    "comment" : "\n     * Implement this to handle query requests from clients.\n     *\n     * <p>Apps targeting {@link android.os.Build.VERSION_CODES#O} or higher should override\n     * {@link #query(Uri, String[], Bundle, CancellationSignal)} and provide a stub\n     * implementation of this method.\n     *\n     * <p>This method can be called from multiple threads, as described in\n     * <a href=\"{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads\">Processes\n     * and Threads</a>.\n     * <p>\n     * Example client call:<p>\n     * <pre>// Request a specific record.\n     * Cursor managedCursor = managedQuery(\n                ContentUris.withAppendedId(Contacts.People.CONTENT_URI, 2),\n                projection,    // Which columns to return.\n                null,          // WHERE clause.\n                null,          // WHERE clause value substitution\n                People.NAME + \" ASC\");   // Sort order.</pre>\n     * Example implementation:<p>\n     * <pre>// SQLiteQueryBuilder is a helper class that creates the\n        // proper SQL syntax for us.\n        SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder();\n\n        // Guard against SQL injection attacks\n        qBuilder.setStrict(true);\n        qBuilder.setProjectionMap(MAP_OF_QUERYABLE_COLUMNS);\n        qBuilder.setStrictColumns(true);\n        qBuilder.setStrictGrammar(true);\n\n        // Set the table we're querying.\n        qBuilder.setTables(DATABASE_TABLE_NAME);\n\n        // If the query ends in a specific record number, we're\n        // being asked for a specific record, so set the\n        // WHERE clause in our query.\n        if((URI_MATCHER.match(uri)) == SPECIFIC_MESSAGE){\n            qBuilder.appendWhere(\"_id=\" + uri.getPathLeafId());\n        }\n\n        // Make the query.\n        Cursor c = qBuilder.query(mDb,\n                projection,\n                selection,\n                selectionArgs,\n                groupBy,\n                having,\n                sortOrder);\n        c.setNotificationUri(getContext().getContentResolver(), uri);\n        return c;</pre>\n     *\n     * @param uri The URI to query. This will be the full URI sent by the client;\n     *      if the client is requesting a specific record, the URI will end in a record number\n     *      that the implementation should parse and add to a WHERE or HAVING clause, specifying\n     *      that _id value.\n     * @param projection The list of columns to put into the cursor. If\n     *      {@code null} all columns are included.\n     * @param selection A selection criteria to apply when filtering rows.\n     *      If {@code null} then all rows are included.\n     * @param selectionArgs You may include ?s in selection, which will be replaced by\n     *      the values from selectionArgs, in order that they appear in the selection.\n     *      The values will be bound as Strings.\n     * @param sortOrder How the rows in the cursor should be sorted.\n     *      If {@code null} then the provider is free to define the sort order.\n     * @return a Cursor or {@code null}.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "#query(Uri" ]
  }, {
    "name" : "public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder, @Nullable CancellationSignal cancellationSignal)",
    "returnType" : "Cursor",
    "comment" : "\n     * Implement this to handle query requests from clients with support for cancellation.\n     *\n     * <p>Apps targeting {@link android.os.Build.VERSION_CODES#O} or higher should override\n     * {@link #query(Uri, String[], Bundle, CancellationSignal)} instead of this method.\n     *\n     * <p>This method can be called from multiple threads, as described in\n     * <a href=\"{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads\">Processes\n     * and Threads</a>.\n     * <p>\n     * Example client call:<p>\n     * <pre>// Request a specific record.\n     * Cursor managedCursor = managedQuery(\n                ContentUris.withAppendedId(Contacts.People.CONTENT_URI, 2),\n                projection,    // Which columns to return.\n                null,          // WHERE clause.\n                null,          // WHERE clause value substitution\n                People.NAME + \" ASC\");   // Sort order.</pre>\n     * Example implementation:<p>\n     * <pre>// SQLiteQueryBuilder is a helper class that creates the\n        // proper SQL syntax for us.\n        SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder();\n\n        // Guard against SQL injection attacks\n        qBuilder.setStrict(true);\n        qBuilder.setProjectionMap(MAP_OF_QUERYABLE_COLUMNS);\n        qBuilder.setStrictColumns(true);\n        qBuilder.setStrictGrammar(true);\n\n        // Set the table we're querying.\n        qBuilder.setTables(DATABASE_TABLE_NAME);\n\n        // If the query ends in a specific record number, we're\n        // being asked for a specific record, so set the\n        // WHERE clause in our query.\n        if((URI_MATCHER.match(uri)) == SPECIFIC_MESSAGE){\n            qBuilder.appendWhere(\"_id=\" + uri.getPathLeafId());\n        }\n\n        // Make the query.\n        Cursor c = qBuilder.query(mDb,\n                projection,\n                selection,\n                selectionArgs,\n                groupBy,\n                having,\n                sortOrder);\n        c.setNotificationUri(getContext().getContentResolver(), uri);\n        return c;</pre>\n     * <p>\n     * If you implement this method then you must also implement the version of\n     * {@link #query(Uri, String[], String, String[], String)} that does not take a cancellation\n     * signal to ensure correct operation on older versions of the Android Framework in\n     * which the cancellation signal overload was not available.\n     *\n     * @param uri The URI to query. This will be the full URI sent by the client;\n     *      if the client is requesting a specific record, the URI will end in a record number\n     *      that the implementation should parse and add to a WHERE or HAVING clause, specifying\n     *      that _id value.\n     * @param projection The list of columns to put into the cursor. If\n     *      {@code null} all columns are included.\n     * @param selection A selection criteria to apply when filtering rows.\n     *      If {@code null} then all rows are included.\n     * @param selectionArgs You may include ?s in selection, which will be replaced by\n     *      the values from selectionArgs, in order that they appear in the selection.\n     *      The values will be bound as Strings.\n     * @param sortOrder How the rows in the cursor should be sorted.\n     *      If {@code null} then the provider is free to define the sort order.\n     * @param cancellationSignal A signal to cancel the operation in progress, or {@code null} if none.\n     * If the operation is canceled, then {@link android.os.OperationCanceledException} will be thrown\n     * when the query is executed.\n     * @return a Cursor or {@code null}.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "android.os.OperationCanceledException", "#query(Uri" ]
  }, {
    "name" : "public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable Bundle queryArgs, @Nullable CancellationSignal cancellationSignal)",
    "returnType" : "Cursor",
    "comment" : "\n     * Implement this to handle query requests where the arguments are packed into a {@link Bundle}.\n     * Arguments may include traditional SQL style query arguments. When present these\n     * should be handled  according to the contract established in\n     * {@link #query(Uri, String[], String, String[], String, CancellationSignal)}.\n     *\n     * <p>Traditional SQL arguments can be found in the bundle using the following keys:\n     * <li>{@link android.content.ContentResolver#QUERY_ARG_SQL_SELECTION}\n     * <li>{@link android.content.ContentResolver#QUERY_ARG_SQL_SELECTION_ARGS}\n     * <li>{@link android.content.ContentResolver#QUERY_ARG_SQL_SORT_ORDER}\n     *\n     * <p>This method can be called from multiple threads, as described in\n     * <a href=\"{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads\">Processes\n     * and Threads</a>.\n     *\n     * <p>\n     * Example client call:<p>\n     * <pre>// Request 20 records starting at row index 30.\n       Bundle queryArgs = new Bundle();\n       queryArgs.putInt(ContentResolver.QUERY_ARG_OFFSET, 30);\n       queryArgs.putInt(ContentResolver.QUERY_ARG_LIMIT, 20);\n\n       Cursor cursor = getContentResolver().query(\n                contentUri,    // Content Uri is specific to individual content providers.\n                projection,    // String[] describing which columns to return.\n                queryArgs,     // Query arguments.\n                null);         // Cancellation signal.</pre>\n     *\n     * Example implementation:<p>\n     * <pre>\n\n        int recordsetSize = 0x1000;  // Actual value is implementation specific.\n        queryArgs = queryArgs != null ? queryArgs : Bundle.EMPTY;  // ensure queryArgs is non-null\n\n        int offset = queryArgs.getInt(ContentResolver.QUERY_ARG_OFFSET, 0);\n        int limit = queryArgs.getInt(ContentResolver.QUERY_ARG_LIMIT, Integer.MIN_VALUE);\n\n        MatrixCursor c = new MatrixCursor(PROJECTION, limit);\n\n        // Calculate the number of items to include in the cursor.\n        int numItems = MathUtils.constrain(recordsetSize - offset, 0, limit);\n\n        // Build the paged result set....\n        for (int i = offset; i < offset + numItems; i++) {\n            // populate row from your data.\n        }\n\n        Bundle extras = new Bundle();\n        c.setExtras(extras);\n\n        // Any QUERY_ARG_* key may be included if honored.\n        // In an actual implementation, include only keys that are both present in queryArgs\n        // and reflected in the Cursor output. For example, if QUERY_ARG_OFFSET were included\n        // in queryArgs, but was ignored because it contained an invalid value (like â€“273),\n        // then QUERY_ARG_OFFSET should be omitted.\n        extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, new String[] {\n            ContentResolver.QUERY_ARG_OFFSET,\n            ContentResolver.QUERY_ARG_LIMIT\n        });\n\n        extras.putInt(ContentResolver.EXTRA_TOTAL_COUNT, recordsetSize);\n\n        cursor.setNotificationUri(getContext().getContentResolver(), uri);\n\n        return cursor;</pre>\n     * <p>\n     * See {@link #query(Uri, String[], String, String[], String, CancellationSignal)}\n     * for implementation details.\n     *\n     * @param uri The URI to query. This will be the full URI sent by the client.\n     * @param projection The list of columns to put into the cursor.\n     *            If {@code null} provide a default set of columns.\n     * @param queryArgs A Bundle containing additional information necessary for\n     *            the operation. Arguments may include SQL style arguments, such\n     *            as {@link ContentResolver#QUERY_ARG_SQL_LIMIT}, but note that\n     *            the documentation for each individual provider will indicate\n     *            which arguments they support.\n     * @param cancellationSignal A signal to cancel the operation in progress,\n     *            or {@code null}.\n     * @return a Cursor or {@code null}.\n     ",
    "links" : [ "android.os.Bundle", "android.content.ContentResolver#QUERY_ARG_SQL_SELECTION", "android.content.ContentResolver#QUERY_ARG_SQL_SORT_ORDER", "android.content.ContentResolver#QUERY_ARG_SQL_SELECTION_ARGS", "#query(Uri", "android.content.ContentResolver#QUERY_ARG_SQL_LIMIT" ]
  }, {
    "name" : "public abstract String getType(@NonNull Uri uri)",
    "returnType" : "String",
    "comment" : "\n     * Implement this to handle requests for the MIME type of the data at the\n     * given URI.  The returned MIME type should start with\n     * <code>vnd.android.cursor.item</code> for a single record,\n     * or <code>vnd.android.cursor.dir/</code> for multiple items.\n     * This method can be called from multiple threads, as described in\n     * <a href=\"{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads\">Processes\n     * and Threads</a>.\n     *\n     * <p>Note that by default there are no permissions needed for an application to\n     * access this information; if your content provider requires read and/or\n     * write permissions, or is not exported, all applications can still call\n     * this method regardless of their access permissions. </p>\n     *\n     * <p>If your mime type reveals details that should be protected,\n     * then you should protect this method by implementing {@link #getTypeAnonymous}.\n     * Implementing {@link #getTypeAnonymous} ensures your {@link #getType} can be\n     * only accessed by caller's having associated readPermission for the URI. </p>\n     *\n     * @param uri the URI to query.\n     * @return a MIME type string, or {@code null} if there is no type.\n     ",
    "links" : [ "#getType", "#getTypeAnonymous" ]
  }, {
    "name" : "public String getTypeAnonymous(@NonNull Uri uri)",
    "returnType" : "String",
    "comment" : "\n     * Implement this to handle requests for MIME type of URIs, that does not need to\n     * reveal any internal information which should be protected by any permission.\n     *\n     * <p>If your mime type reveals details that should be protected, then you should protect those\n     * by implementing those in {@link #getType}, and in this function, only return types of\n     * URIs which can be obtained by anyone without any access.\n     *\n     * Implementing ths function will make sure {@link #getType} is protected by readPermission.\n     * This function by default works as the {@link #getType}</p>\n     *\n     * @param uri the URI to query.\n     * @return a MIME type string, or {@code null} if type needs to be protected.\n     ",
    "links" : [ "#getType" ]
  }, {
    "name" : "public Uri canonicalize(@NonNull Uri url)",
    "returnType" : "Uri",
    "comment" : "\n     * Implement this to support canonicalization of URIs that refer to your\n     * content provider.  A canonical URI is one that can be transported across\n     * devices, backup/restore, and other contexts, and still be able to refer\n     * to the same data item.  Typically this is implemented by adding query\n     * params to the URI allowing the content provider to verify that an incoming\n     * canonical URI references the same data as it was originally intended for and,\n     * if it doesn't, to find that data (if it exists) in the current environment.\n     *\n     * <p>For example, if the content provider holds people and a normal URI in it\n     * is created with a row index into that people database, the cananical representation\n     * may have an additional query param at the end which specifies the name of the\n     * person it is intended for.  Later calls into the provider with that URI will look\n     * up the row of that URI's base index and, if it doesn't match or its entry's\n     * name doesn't match the name in the query param, perform a query on its database\n     * to find the correct row to operate on.</p>\n     *\n     * <p>If you implement support for canonical URIs, <b>all</b> incoming calls with\n     * URIs (including this one) must perform this verification and recovery of any\n     * canonical URIs they receive.  In addition, you must also implement\n     * {@link #uncanonicalize} to strip the canonicalization of any of these URIs.</p>\n     *\n     * <p>The default implementation of this method returns null, indicating that\n     * canonical URIs are not supported.</p>\n     *\n     * @param url The Uri to canonicalize.\n     *\n     * @return Return the canonical representation of <var>url</var>, or null if\n     * canonicalization of that Uri is not supported.\n     ",
    "links" : [ "#uncanonicalize" ]
  }, {
    "name" : "public Uri uncanonicalize(@NonNull Uri url)",
    "returnType" : "Uri",
    "comment" : "\n     * Remove canonicalization from canonical URIs previously returned by\n     * {@link #canonicalize}.  For example, if your implementation is to add\n     * a query param to canonicalize a URI, this method can simply trip any\n     * query params on the URI.  The default implementation always returns the\n     * same <var>url</var> that was passed in.\n     *\n     * @param url The Uri to remove any canonicalization from.\n     *\n     * @return Return the non-canonical representation of <var>url</var>, return\n     * the <var>url</var> as-is if there is nothing to do, or return null if\n     * the data identified by the canonical representation can not be found in\n     * the current environment.\n     ",
    "links" : [ "#canonicalize" ]
  }, {
    "name" : "public boolean refresh(Uri uri, @Nullable Bundle extras, @Nullable CancellationSignal cancellationSignal)",
    "returnType" : "boolean",
    "comment" : "\n     * Implement this to support refresh of content identified by {@code uri}.\n     * By default, this method returns false; providers who wish to implement\n     * this should return true to signal the client that the provider has tried\n     * refreshing with its own implementation.\n     * <p>\n     * This allows clients to request an explicit refresh of content identified\n     * by {@code uri}.\n     * <p>\n     * Client code should only invoke this method when there is a strong\n     * indication (such as a user initiated pull to refresh gesture) that the\n     * content is stale.\n     * <p>\n     * Remember to send\n     * {@link ContentResolver#notifyChange(Uri, android.database.ContentObserver)}\n     * notifications when content changes.\n     *\n     * @param uri The Uri identifying the data to refresh.\n     * @param extras Additional options from the client. The definitions of\n     *            these are specific to the content provider being called.\n     * @param cancellationSignal A signal to cancel the operation in progress,\n     *            or {@code null} if none. For example, if you called refresh on\n     *            a particular uri, you should call\n     *            {@link CancellationSignal#throwIfCanceled()} to check whether\n     *            the client has canceled the refresh request.\n     * @return true if the provider actually tried refreshing.\n     ",
    "links" : [ "android.content.ContentResolver#notifyChange(Uri", "android.os.CancellationSignal#throwIfCanceled()" ]
  }, {
    "name" : "public int checkUriPermission(@NonNull Uri uri, int uid, @Intent.AccessUriMode int modeFlags)",
    "returnType" : "int",
    "comment" : "\n     * Perform a detailed internal check on a {@link Uri} to determine if a UID\n     * is able to access it with specific mode flags.\n     * <p>\n     * This method is typically used when the provider implements more dynamic\n     * access controls that cannot be expressed with {@code <path-permission>}\n     * style static rules.\n     * <p>\n     * Because validation of these dynamic access controls has significant\n     * system health impact, this feature is only available to providers that\n     * are built into the system.\n     *\n     * @param uri the {@link Uri} to perform an access check on.\n     * @param uid the UID to check the permission for.\n     * @param modeFlags the access flags to use for the access check, such as\n     *            {@link Intent#FLAG_GRANT_READ_URI_PERMISSION}.\n     * @return {@link PackageManager#PERMISSION_GRANTED} if access is allowed,\n     *         otherwise {@link PackageManager#PERMISSION_DENIED}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#PERMISSION_DENIED", "android.content.pm.PackageManager#PERMISSION_GRANTED", "android.net.Uri", "android.content.Intent#FLAG_GRANT_READ_URI_PERMISSION" ]
  }, {
    "name" : "public Uri rejectInsert(Uri uri, ContentValues values)",
    "returnType" : "Uri",
    "comment" : "\n     * @hide\n     * Implementation when a caller has performed an insert on the content\n     * provider, but that call has been rejected for the operation given\n     * to {@link #setAppOps(int, int)}.  The default implementation simply\n     * returns a URI that is the base URI with a 0 path element appended.\n     ",
    "links" : [ "#setAppOps(int" ]
  }, {
    "name" : "public abstract Uri insert(@NonNull Uri uri, @Nullable ContentValues values)",
    "returnType" : "Uri",
    "comment" : "\n     * Implement this to handle requests to insert a new row. As a courtesy,\n     * call\n     * {@link ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver)\n     * notifyChange()} after inserting. This method can be called from multiple\n     * threads, as described in <a href=\"\n     * {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads\">Processes\n     * and Threads</a>.\n     *\n     * @param uri The content:// URI of the insertion request.\n     * @param values A set of column_name/value pairs to add to the database.\n     * @return The URI for the newly inserted item.\n     ",
    "links" : [ "android.content.ContentResolver#notifyChange(android.net.Uri" ]
  }, {
    "name" : "public Uri insert(@NonNull Uri uri, @Nullable ContentValues values, @Nullable Bundle extras)",
    "returnType" : "Uri",
    "comment" : "\n     * Implement this to handle requests to insert a new row. As a courtesy,\n     * call\n     * {@link ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver)\n     * notifyChange()} after inserting. This method can be called from multiple\n     * threads, as described in <a href=\"\n     * {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads\">Processes\n     * and Threads</a>.\n     *\n     * @param uri The content:// URI of the insertion request.\n     * @param values A set of column_name/value pairs to add to the database.\n     * @param extras A Bundle containing additional information necessary for\n     *            the operation. Arguments may include SQL style arguments, such\n     *            as {@link ContentResolver#QUERY_ARG_SQL_LIMIT}, but note that\n     *            the documentation for each individual provider will indicate\n     *            which arguments they support.\n     * @return The URI for the newly inserted item.\n     * @throws IllegalArgumentException if the provider doesn't support one of\n     *             the requested Bundle arguments.\n     ",
    "links" : [ "android.content.ContentResolver#notifyChange(android.net.Uri", "android.content.ContentResolver#QUERY_ARG_SQL_LIMIT" ]
  }, {
    "name" : "public int bulkInsert(@NonNull Uri uri, @NonNull ContentValues[] values)",
    "returnType" : "int",
    "comment" : "\n     * Override this to handle requests to insert a set of new rows, or the\n     * default implementation will iterate over the values and call\n     * {@link #insert} on each of them.\n     * As a courtesy, call {@link ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()}\n     * after inserting.\n     * This method can be called from multiple threads, as described in\n     * <a href=\"{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads\">Processes\n     * and Threads</a>.\n     *\n     * @param uri The content:// URI of the insertion request.\n     * @param values An array of sets of column_name/value pairs to add to the database.\n     *    This must not be {@code null}.\n     * @return The number of values that were inserted.\n     ",
    "links" : [ "android.content.ContentResolver#notifyChange(android.net.Uri", "#insert" ]
  }, {
    "name" : "public abstract int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs)",
    "returnType" : "int",
    "comment" : "\n     * Implement this to handle requests to delete one or more rows. The\n     * implementation should apply the selection clause when performing\n     * deletion, allowing the operation to affect multiple rows in a directory.\n     * As a courtesy, call\n     * {@link ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver)\n     * notifyChange()} after deleting. This method can be called from multiple\n     * threads, as described in <a href=\"\n     * {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads\">Processes\n     * and Threads</a>.\n     * <p>\n     * The implementation is responsible for parsing out a row ID at the end of\n     * the URI, if a specific row is being deleted. That is, the client would\n     * pass in <code>content://contacts/people/22</code> and the implementation\n     * is responsible for parsing the record number (22) when creating a SQL\n     * statement.\n     *\n     * @param uri The full URI to query, including a row ID (if a specific\n     *            record is requested).\n     * @param selection An optional restriction to apply to rows when deleting.\n     * @return The number of rows affected.\n     * @throws SQLException\n     ",
    "links" : [ "android.content.ContentResolver#notifyChange(android.net.Uri" ]
  }, {
    "name" : "public int delete(@NonNull Uri uri, @Nullable Bundle extras)",
    "returnType" : "int",
    "comment" : "\n     * Implement this to handle requests to delete one or more rows. The\n     * implementation should apply the selection clause when performing\n     * deletion, allowing the operation to affect multiple rows in a directory.\n     * As a courtesy, call\n     * {@link ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver)\n     * notifyChange()} after deleting. This method can be called from multiple\n     * threads, as described in <a href=\"\n     * {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads\">Processes\n     * and Threads</a>.\n     * <p>\n     * The implementation is responsible for parsing out a row ID at the end of\n     * the URI, if a specific row is being deleted. That is, the client would\n     * pass in <code>content://contacts/people/22</code> and the implementation\n     * is responsible for parsing the record number (22) when creating a SQL\n     * statement.\n     *\n     * @param uri The full URI to query, including a row ID (if a specific\n     *            record is requested).\n     * @param extras A Bundle containing additional information necessary for\n     *            the operation. Arguments may include SQL style arguments, such\n     *            as {@link ContentResolver#QUERY_ARG_SQL_LIMIT}, but note that\n     *            the documentation for each individual provider will indicate\n     *            which arguments they support.\n     * @throws IllegalArgumentException if the provider doesn't support one of\n     *             the requested Bundle arguments.\n     * @throws SQLException\n     ",
    "links" : [ "android.content.ContentResolver#notifyChange(android.net.Uri", "android.content.ContentResolver#QUERY_ARG_SQL_LIMIT" ]
  }, {
    "name" : "public abstract int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs)",
    "returnType" : "int",
    "comment" : "\n     * Implement this to handle requests to update one or more rows. The\n     * implementation should update all rows matching the selection to set the\n     * columns according to the provided values map. As a courtesy, call\n     * {@link ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver)\n     * notifyChange()} after updating. This method can be called from multiple\n     * threads, as described in <a href=\"\n     * {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads\">Processes\n     * and Threads</a>.\n     *\n     * @param uri The URI to query. This can potentially have a record ID if\n     *            this is an update request for a specific record.\n     * @param values A set of column_name/value pairs to update in the database.\n     * @param selection An optional filter to match rows to update.\n     * @return the number of rows affected.\n     ",
    "links" : [ "android.content.ContentResolver#notifyChange(android.net.Uri" ]
  }, {
    "name" : "public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable Bundle extras)",
    "returnType" : "int",
    "comment" : "\n     * Implement this to handle requests to update one or more rows. The\n     * implementation should update all rows matching the selection to set the\n     * columns according to the provided values map. As a courtesy, call\n     * {@link ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver)\n     * notifyChange()} after updating. This method can be called from multiple\n     * threads, as described in <a href=\"\n     * {@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads\">Processes\n     * and Threads</a>.\n     *\n     * @param uri The URI to query. This can potentially have a record ID if\n     *            this is an update request for a specific record.\n     * @param values A set of column_name/value pairs to update in the database.\n     * @param extras A Bundle containing additional information necessary for\n     *            the operation. Arguments may include SQL style arguments, such\n     *            as {@link ContentResolver#QUERY_ARG_SQL_LIMIT}, but note that\n     *            the documentation for each individual provider will indicate\n     *            which arguments they support.\n     * @return the number of rows affected.\n     * @throws IllegalArgumentException if the provider doesn't support one of\n     *             the requested Bundle arguments.\n     ",
    "links" : [ "android.content.ContentResolver#notifyChange(android.net.Uri", "android.content.ContentResolver#QUERY_ARG_SQL_LIMIT" ]
  }, {
    "name" : "public ParcelFileDescriptor openFile(@NonNull Uri uri, @NonNull String mode) throws FileNotFoundException",
    "returnType" : "ParcelFileDescriptor",
    "comment" : "\n     * Override this to handle requests to open a file blob.\n     * The default implementation always throws {@link FileNotFoundException}.\n     * This method can be called from multiple threads, as described in\n     * <a href=\"{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads\">Processes\n     * and Threads</a>.\n     *\n     * <p>This method returns a ParcelFileDescriptor, which is returned directly\n     * to the caller.  This way large data (such as images and documents) can be\n     * returned without copying the content.\n     *\n     * <p>The returned ParcelFileDescriptor is owned by the caller, so it is\n     * their responsibility to close it when done.  That is, the implementation\n     * of this method should create a new ParcelFileDescriptor for each call.\n     * <p>\n     * If opened with the exclusive \"r\" or \"w\" modes, the returned\n     * ParcelFileDescriptor can be a pipe or socket pair to enable streaming\n     * of data. Opening with the \"rw\" or \"rwt\" modes implies a file on disk that\n     * supports seeking.\n     * <p>\n     * If you need to detect when the returned ParcelFileDescriptor has been\n     * closed, or if the remote process has crashed or encountered some other\n     * error, you can use {@link ParcelFileDescriptor#open(File, int,\n     * android.os.Handler, android.os.ParcelFileDescriptor.OnCloseListener)},\n     * {@link ParcelFileDescriptor#createReliablePipe()}, or\n     * {@link ParcelFileDescriptor#createReliableSocketPair()}.\n     * <p>\n     * If you need to return a large file that isn't backed by a real file on\n     * disk, such as a file on a network share or cloud storage service,\n     * consider using\n     * {@link StorageManager#openProxyFileDescriptor(int, android.os.ProxyFileDescriptorCallback, android.os.Handler)}\n     * which will let you to stream the content on-demand.\n     *\n     * <p class=\"note\">For use in Intents, you will want to implement {@link #getType}\n     * to return the appropriate MIME type for the data returned here with\n     * the same URI.  This will allow intent resolution to automatically determine the data MIME\n     * type and select the appropriate matching targets as part of its operation.</p>\n     *\n     * <p class=\"note\">For better interoperability with other applications, it is recommended\n     * that for any URIs that can be opened, you also support queries on them\n     * containing at least the columns specified by {@link android.provider.OpenableColumns}.\n     * You may also want to support other common columns if you have additional meta-data\n     * to supply, such as {@link android.provider.MediaStore.MediaColumns#DATE_ADDED}\n     * in {@link android.provider.MediaStore.MediaColumns}.</p>\n     *\n     * @param uri The URI whose file is to be opened.\n     * @param mode The string representation of the file mode. Can be \"r\", \"w\", \"wt\", \"wa\", \"rw\"\n     *             or \"rwt\". Please note the exact implementation of these may differ for each\n     *             Provider implementation - for example, \"w\" may or may not truncate.\n     *\n     * @return Returns a new ParcelFileDescriptor which you can use to access\n     * the file.\n     *\n     * @throws FileNotFoundException Throws FileNotFoundException if there is\n     * no file associated with the given URI or the mode is invalid.\n     * @throws SecurityException Throws SecurityException if the caller does\n     * not have permission to access the file.\n     *\n     * @see #openAssetFile(Uri, String)\n     * @see #openFileHelper(Uri, String)\n     * @see #getType(android.net.Uri)\n     * @see ParcelFileDescriptor#parseMode(String)\n     ",
    "links" : [ "#getType", "android.provider.MediaStore.MediaColumns", "android.os.ParcelFileDescriptor#createReliablePipe()", "android.provider.MediaStore.MediaColumns#DATE_ADDED", "android.provider.OpenableColumns", "java.io.FileNotFoundException", "android.os.ParcelFileDescriptor#open(File", "android.os.ParcelFileDescriptor#createReliableSocketPair()", "android.os.storage.StorageManager#openProxyFileDescriptor(int" ]
  }, {
    "name" : "public ParcelFileDescriptor openFile(@NonNull Uri uri, @NonNull String mode, @Nullable CancellationSignal signal) throws FileNotFoundException",
    "returnType" : "ParcelFileDescriptor",
    "comment" : "\n     * Override this to handle requests to open a file blob.\n     * The default implementation always throws {@link FileNotFoundException}.\n     * This method can be called from multiple threads, as described in\n     * <a href=\"{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads\">Processes\n     * and Threads</a>.\n     *\n     * <p>This method returns a ParcelFileDescriptor, which is returned directly\n     * to the caller.  This way large data (such as images and documents) can be\n     * returned without copying the content.\n     *\n     * <p>The returned ParcelFileDescriptor is owned by the caller, so it is\n     * their responsibility to close it when done.  That is, the implementation\n     * of this method should create a new ParcelFileDescriptor for each call.\n     * <p>\n     * If opened with the exclusive \"r\" or \"w\" modes, the returned\n     * ParcelFileDescriptor can be a pipe or socket pair to enable streaming\n     * of data. Opening with the \"rw\" or \"rwt\" modes implies a file on disk that\n     * supports seeking.\n     * <p>\n     * If you need to detect when the returned ParcelFileDescriptor has been\n     * closed, or if the remote process has crashed or encountered some other\n     * error, you can use {@link ParcelFileDescriptor#open(File, int,\n     * android.os.Handler, android.os.ParcelFileDescriptor.OnCloseListener)},\n     * {@link ParcelFileDescriptor#createReliablePipe()}, or\n     * {@link ParcelFileDescriptor#createReliableSocketPair()}.\n     *\n     * <p class=\"note\">For use in Intents, you will want to implement {@link #getType}\n     * to return the appropriate MIME type for the data returned here with\n     * the same URI.  This will allow intent resolution to automatically determine the data MIME\n     * type and select the appropriate matching targets as part of its operation.</p>\n     *\n     * <p class=\"note\">For better interoperability with other applications, it is recommended\n     * that for any URIs that can be opened, you also support queries on them\n     * containing at least the columns specified by {@link android.provider.OpenableColumns}.\n     * You may also want to support other common columns if you have additional meta-data\n     * to supply, such as {@link android.provider.MediaStore.MediaColumns#DATE_ADDED}\n     * in {@link android.provider.MediaStore.MediaColumns}.</p>\n     *\n     * @param uri The URI whose file is to be opened.\n     * @param mode The string representation of the file mode. Can be \"r\", \"w\", \"wt\", \"wa\", \"rw\"\n     *             or \"rwt\". Please note the exact implementation of these may differ for each\n     *             Provider implementation - for example, \"w\" may or may not truncate.\n     * @param signal A signal to cancel the operation in progress, or\n     *            {@code null} if none. For example, if you are downloading a\n     *            file from the network to service a \"rw\" mode request, you\n     *            should periodically call\n     *            {@link CancellationSignal#throwIfCanceled()} to check whether\n     *            the client has canceled the request and abort the download.\n     *\n     * @return Returns a new ParcelFileDescriptor which you can use to access\n     * the file.\n     *\n     * @throws FileNotFoundException Throws FileNotFoundException if there is\n     * no file associated with the given URI or the mode is invalid.\n     * @throws SecurityException Throws SecurityException if the caller does\n     * not have permission to access the file.\n     *\n     * @see #openAssetFile(Uri, String)\n     * @see #openFileHelper(Uri, String)\n     * @see #getType(android.net.Uri)\n     * @see ParcelFileDescriptor#parseMode(String)\n     ",
    "links" : [ "#getType", "android.provider.MediaStore.MediaColumns", "android.os.ParcelFileDescriptor#createReliablePipe()", "android.os.CancellationSignal#throwIfCanceled()", "android.provider.MediaStore.MediaColumns#DATE_ADDED", "android.provider.OpenableColumns", "java.io.FileNotFoundException", "android.os.ParcelFileDescriptor#open(File", "android.os.ParcelFileDescriptor#createReliableSocketPair()" ]
  }, {
    "name" : "public AssetFileDescriptor openAssetFile(@NonNull Uri uri, @NonNull String mode) throws FileNotFoundException",
    "returnType" : "AssetFileDescriptor",
    "comment" : "\n     * This is like {@link #openFile}, but can be implemented by providers\n     * that need to be able to return sub-sections of files, often assets\n     * inside of their .apk.\n     * This method can be called from multiple threads, as described in\n     * <a href=\"{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads\">Processes\n     * and Threads</a>.\n     *\n     * <p>If you implement this, your clients must be able to deal with such\n     * file slices, either directly with\n     * {@link ContentResolver#openAssetFileDescriptor}, or by using the higher-level\n     * {@link ContentResolver#openInputStream ContentResolver.openInputStream}\n     * or {@link ContentResolver#openOutputStream ContentResolver.openOutputStream}\n     * methods.\n     * <p>\n     * The returned AssetFileDescriptor can be a pipe or socket pair to enable\n     * streaming of data.\n     *\n     * <p class=\"note\">If you are implementing this to return a full file, you\n     * should create the AssetFileDescriptor with\n     * {@link AssetFileDescriptor#UNKNOWN_LENGTH} to be compatible with\n     * applications that cannot handle sub-sections of files.</p>\n     *\n     * <p class=\"note\">For use in Intents, you will want to implement {@link #getType}\n     * to return the appropriate MIME type for the data returned here with\n     * the same URI.  This will allow intent resolution to automatically determine the data MIME\n     * type and select the appropriate matching targets as part of its operation.</p>\n     *\n     * <p class=\"note\">For better interoperability with other applications, it is recommended\n     * that for any URIs that can be opened, you also support queries on them\n     * containing at least the columns specified by {@link android.provider.OpenableColumns}.</p>\n     *\n     * @param uri The URI whose file is to be opened.\n     * @param mode The string representation of the file mode. Can be \"r\", \"w\", \"wt\", \"wa\", \"rw\"\n     *             or \"rwt\". Please note the exact implementation of these may differ for each\n     *             Provider implementation - for example, \"w\" may or may not truncate.\n     *\n     * @return Returns a new AssetFileDescriptor which you can use to access\n     * the file.\n     *\n     * @throws FileNotFoundException Throws FileNotFoundException if there is\n     * no file associated with the given URI or the mode is invalid.\n     * @throws SecurityException Throws SecurityException if the caller does\n     * not have permission to access the file.\n     *\n     * @see #openFile(Uri, String)\n     * @see #openFileHelper(Uri, String)\n     * @see #getType(android.net.Uri)\n     ",
    "links" : [ "android.content.ContentResolver#openInputStream", "#getType", "android.content.res.AssetFileDescriptor#UNKNOWN_LENGTH", "#openFile", "android.content.ContentResolver#openAssetFileDescriptor", "android.provider.OpenableColumns", "android.content.ContentResolver#openOutputStream" ]
  }, {
    "name" : "public AssetFileDescriptor openAssetFile(@NonNull Uri uri, @NonNull String mode, @Nullable CancellationSignal signal) throws FileNotFoundException",
    "returnType" : "AssetFileDescriptor",
    "comment" : "\n     * This is like {@link #openFile}, but can be implemented by providers\n     * that need to be able to return sub-sections of files, often assets\n     * inside of their .apk.\n     * This method can be called from multiple threads, as described in\n     * <a href=\"{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads\">Processes\n     * and Threads</a>.\n     *\n     * <p>If you implement this, your clients must be able to deal with such\n     * file slices, either directly with\n     * {@link ContentResolver#openAssetFileDescriptor}, or by using the higher-level\n     * {@link ContentResolver#openInputStream ContentResolver.openInputStream}\n     * or {@link ContentResolver#openOutputStream ContentResolver.openOutputStream}\n     * methods.\n     * <p>\n     * The returned AssetFileDescriptor can be a pipe or socket pair to enable\n     * streaming of data.\n     *\n     * <p class=\"note\">If you are implementing this to return a full file, you\n     * should create the AssetFileDescriptor with\n     * {@link AssetFileDescriptor#UNKNOWN_LENGTH} to be compatible with\n     * applications that cannot handle sub-sections of files.</p>\n     *\n     * <p class=\"note\">For use in Intents, you will want to implement {@link #getType}\n     * to return the appropriate MIME type for the data returned here with\n     * the same URI.  This will allow intent resolution to automatically determine the data MIME\n     * type and select the appropriate matching targets as part of its operation.</p>\n     *\n     * <p class=\"note\">For better interoperability with other applications, it is recommended\n     * that for any URIs that can be opened, you also support queries on them\n     * containing at least the columns specified by {@link android.provider.OpenableColumns}.</p>\n     *\n     * @param uri The URI whose file is to be opened.\n     * @param mode The string representation of the file mode. Can be \"r\", \"w\", \"wt\", \"wa\", \"rw\"\n     *             or \"rwt\". Please note the exact implementation of these may differ for each\n     *             Provider implementation - for example, \"w\" may or may not truncate.\n     * @param signal A signal to cancel the operation in progress, or\n     *            {@code null} if none. For example, if you are downloading a\n     *            file from the network to service a \"rw\" mode request, you\n     *            should periodically call\n     *            {@link CancellationSignal#throwIfCanceled()} to check whether\n     *            the client has canceled the request and abort the download.\n     *\n     * @return Returns a new AssetFileDescriptor which you can use to access\n     * the file.\n     *\n     * @throws FileNotFoundException Throws FileNotFoundException if there is\n     * no file associated with the given URI or the mode is invalid.\n     * @throws SecurityException Throws SecurityException if the caller does\n     * not have permission to access the file.\n     *\n     * @see #openFile(Uri, String)\n     * @see #openFileHelper(Uri, String)\n     * @see #getType(android.net.Uri)\n     ",
    "links" : [ "android.content.ContentResolver#openInputStream", "#getType", "android.content.res.AssetFileDescriptor#UNKNOWN_LENGTH", "android.os.CancellationSignal#throwIfCanceled()", "#openFile", "android.content.ContentResolver#openAssetFileDescriptor", "android.provider.OpenableColumns", "android.content.ContentResolver#openOutputStream" ]
  }, {
    "name" : "protected final ParcelFileDescriptor openFileHelper(@NonNull Uri uri, @NonNull String mode) throws FileNotFoundException",
    "returnType" : "ParcelFileDescriptor",
    "comment" : "\n     * Convenience for subclasses that wish to implement {@link #openFile}\n     * by looking up a column named \"_data\" at the given URI.\n     *\n     * @param uri The URI to be opened.\n     * @param mode The string representation of the file mode. Can be \"r\", \"w\", \"wt\", \"wa\", \"rw\"\n     *             or \"rwt\". Please note the exact implementation of these may differ for each\n     *             Provider implementation - for example, \"w\" may or may not truncate.\n     *\n     * @return Returns a new ParcelFileDescriptor that can be used by the\n     * client to access the file.\n     ",
    "links" : [ "#openFile" ]
  }, {
    "name" : "public String[] getStreamTypes(@NonNull Uri uri, @NonNull String mimeTypeFilter)",
    "returnType" : "String[]",
    "comment" : "\n     * Called by a client to determine the types of data streams that this\n     * content provider supports for the given URI.  The default implementation\n     * returns {@code null}, meaning no types.  If your content provider stores data\n     * of a particular type, return that MIME type if it matches the given\n     * mimeTypeFilter.  If it can perform type conversions, return an array\n     * of all supported MIME types that match mimeTypeFilter.\n     *\n     * @param uri The data in the content provider being queried.\n     * @param mimeTypeFilter The type of data the client desires.  May be\n     * a pattern, such as *&#47;* to retrieve all possible data types.\n     * @return Returns {@code null} if there are no possible data streams for the\n     * given mimeTypeFilter.  Otherwise returns an array of all available\n     * concrete MIME types.\n     *\n     * @see #getType(Uri)\n     * @see #openTypedAssetFile(Uri, String, Bundle)\n     * @see ClipDescription#compareMimeTypes(String, String)\n     ",
    "links" : [ ]
  }, {
    "name" : "public AssetFileDescriptor openTypedAssetFile(@NonNull Uri uri, @NonNull String mimeTypeFilter, @Nullable Bundle opts) throws FileNotFoundException",
    "returnType" : "AssetFileDescriptor",
    "comment" : "\n     * Called by a client to open a read-only stream containing data of a\n     * particular MIME type.  This is like {@link #openAssetFile(Uri, String)},\n     * except the file can only be read-only and the content provider may\n     * perform data conversions to generate data of the desired type.\n     *\n     * <p>The default implementation compares the given mimeType against the\n     * result of {@link #getType(Uri)} and, if they match, simply calls\n     * {@link #openAssetFile(Uri, String)}.\n     *\n     * <p>See {@link ClipData} for examples of the use and implementation\n     * of this method.\n     * <p>\n     * The returned AssetFileDescriptor can be a pipe or socket pair to enable\n     * streaming of data.\n     *\n     * <p class=\"note\">For better interoperability with other applications, it is recommended\n     * that for any URIs that can be opened, you also support queries on them\n     * containing at least the columns specified by {@link android.provider.OpenableColumns}.\n     * You may also want to support other common columns if you have additional meta-data\n     * to supply, such as {@link android.provider.MediaStore.MediaColumns#DATE_ADDED}\n     * in {@link android.provider.MediaStore.MediaColumns}.</p>\n     *\n     * @param uri The data in the content provider being queried.\n     * @param mimeTypeFilter The type of data the client desires.  May be\n     * a pattern, such as *&#47;*, if the caller does not have specific type\n     * requirements; in this case the content provider will pick its best\n     * type matching the pattern.\n     * @param opts Additional options from the client.  The definitions of\n     * these are specific to the content provider being called.\n     *\n     * @return Returns a new AssetFileDescriptor from which the client can\n     * read data of the desired type.\n     *\n     * @throws FileNotFoundException Throws FileNotFoundException if there is\n     * no file associated with the given URI or the mode is invalid.\n     * @throws SecurityException Throws SecurityException if the caller does\n     * not have permission to access the data.\n     * @throws IllegalArgumentException Throws IllegalArgumentException if the\n     * content provider does not support the requested MIME type.\n     *\n     * @see #getStreamTypes(Uri, String)\n     * @see #openAssetFile(Uri, String)\n     * @see ClipDescription#compareMimeTypes(String, String)\n     ",
    "links" : [ "android.content.ClipData", "#openAssetFile(Uri", "android.provider.MediaStore.MediaColumns", "android.provider.MediaStore.MediaColumns#DATE_ADDED", "android.provider.OpenableColumns", "#getType(Uri)" ]
  }, {
    "name" : "public AssetFileDescriptor openTypedAssetFile(@NonNull Uri uri, @NonNull String mimeTypeFilter, @Nullable Bundle opts, @Nullable CancellationSignal signal) throws FileNotFoundException",
    "returnType" : "AssetFileDescriptor",
    "comment" : "\n     * Called by a client to open a read-only stream containing data of a\n     * particular MIME type.  This is like {@link #openAssetFile(Uri, String)},\n     * except the file can only be read-only and the content provider may\n     * perform data conversions to generate data of the desired type.\n     *\n     * <p>The default implementation compares the given mimeType against the\n     * result of {@link #getType(Uri)} and, if they match, simply calls\n     * {@link #openAssetFile(Uri, String)}.\n     *\n     * <p>See {@link ClipData} for examples of the use and implementation\n     * of this method.\n     * <p>\n     * The returned AssetFileDescriptor can be a pipe or socket pair to enable\n     * streaming of data.\n     *\n     * <p class=\"note\">For better interoperability with other applications, it is recommended\n     * that for any URIs that can be opened, you also support queries on them\n     * containing at least the columns specified by {@link android.provider.OpenableColumns}.\n     * You may also want to support other common columns if you have additional meta-data\n     * to supply, such as {@link android.provider.MediaStore.MediaColumns#DATE_ADDED}\n     * in {@link android.provider.MediaStore.MediaColumns}.</p>\n     *\n     * @param uri The data in the content provider being queried.\n     * @param mimeTypeFilter The type of data the client desires.  May be\n     * a pattern, such as *&#47;*, if the caller does not have specific type\n     * requirements; in this case the content provider will pick its best\n     * type matching the pattern.\n     * @param opts Additional options from the client.  The definitions of\n     * these are specific to the content provider being called.\n     * @param signal A signal to cancel the operation in progress, or\n     *            {@code null} if none. For example, if you are downloading a\n     *            file from the network to service a \"rw\" mode request, you\n     *            should periodically call\n     *            {@link CancellationSignal#throwIfCanceled()} to check whether\n     *            the client has canceled the request and abort the download.\n     *\n     * @return Returns a new AssetFileDescriptor from which the client can\n     * read data of the desired type.\n     *\n     * @throws FileNotFoundException Throws FileNotFoundException if there is\n     * no file associated with the given URI or the mode is invalid.\n     * @throws SecurityException Throws SecurityException if the caller does\n     * not have permission to access the data.\n     * @throws IllegalArgumentException Throws IllegalArgumentException if the\n     * content provider does not support the requested MIME type.\n     *\n     * @see #getStreamTypes(Uri, String)\n     * @see #openAssetFile(Uri, String)\n     * @see ClipDescription#compareMimeTypes(String, String)\n     ",
    "links" : [ "android.content.ClipData", "#openAssetFile(Uri", "android.provider.MediaStore.MediaColumns", "android.os.CancellationSignal#throwIfCanceled()", "android.provider.MediaStore.MediaColumns#DATE_ADDED", "android.provider.OpenableColumns", "#getType(Uri)" ]
  }, {
    "name" : "public ParcelFileDescriptor openPipeHelper(@NonNull final Uri uri, @NonNull final String mimeType, @Nullable final Bundle opts, @Nullable final T args, @NonNull final PipeDataWriter<T> func) throws FileNotFoundException",
    "returnType" : "ParcelFileDescriptor",
    "comment" : "\n     * A helper function for implementing {@link #openTypedAssetFile}, for\n     * creating a data pipe and background thread allowing you to stream\n     * generated data back to the client.  This function returns a new\n     * ParcelFileDescriptor that should be returned to the caller (the caller\n     * is responsible for closing it).\n     *\n     * @param uri The URI whose data is to be written.\n     * @param mimeType The desired type of data to be written.\n     * @param opts Options supplied by caller.\n     * @param args Your own custom arguments.\n     * @param func Interface implementing the function that will actually\n     * stream the data.\n     * @return Returns a new ParcelFileDescriptor holding the read side of\n     * the pipe.  This should be returned to the caller for reading; the caller\n     * is responsible for closing it when done.\n     ",
    "links" : [ "#openTypedAssetFile" ]
  }, {
    "name" : "protected boolean isTemporary()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if this instance is a temporary content provider.\n     * @return true if this instance is a temporary content provider\n     ",
    "links" : [ ]
  }, {
    "name" : "public IContentProvider getIContentProvider()",
    "returnType" : "IContentProvider",
    "comment" : "\n     * Returns the Binder object for this provider.\n     *\n     * @return the Binder object for this provider\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void attachInfoForTesting(Context context, ProviderInfo info)",
    "returnType" : "void",
    "comment" : "\n     * Like {@link #attachInfo(Context, android.content.pm.ProviderInfo)}, but for use\n     * when directly instantiating the provider for testing.\n     * @hide\n     ",
    "links" : [ "#attachInfo(Context" ]
  }, {
    "name" : "public void attachInfo(Context context, ProviderInfo info)",
    "returnType" : "void",
    "comment" : "\n     * After being instantiated, this is called to tell the content provider\n     * about itself.\n     *\n     * @param context The context this provider is running in\n     * @param info Registered information about this content provider\n     ",
    "links" : [ ]
  }, {
    "name" : "private void attachInfo(Context context, ProviderInfo info, boolean testing)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public ContentProviderResult[] applyBatch(@NonNull String authority, @NonNull ArrayList<ContentProviderOperation> operations) throws OperationApplicationException",
    "returnType" : "ContentProviderResult[]",
    "comment" : "\n     * Override this to handle requests to perform a batch of operations, or the\n     * default implementation will iterate over the operations and call\n     * {@link ContentProviderOperation#apply} on each of them.\n     * If all calls to {@link ContentProviderOperation#apply} succeed\n     * then a {@link ContentProviderResult} array with as many\n     * elements as there were operations will be returned.  If any of the calls\n     * fail, it is up to the implementation how many of the others take effect.\n     * This method can be called from multiple threads, as described in\n     * <a href=\"{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads\">Processes\n     * and Threads</a>.\n     *\n     * @param operations the operations to apply\n     * @return the results of the applications\n     * @throws OperationApplicationException thrown if any operation fails.\n     * @see ContentProviderOperation#apply\n     ",
    "links" : [ "android.content.ContentProviderResult", "android.content.ContentProviderOperation#apply" ]
  }, {
    "name" : "public ContentProviderResult[] applyBatch(@NonNull ArrayList<ContentProviderOperation> operations) throws OperationApplicationException",
    "returnType" : "ContentProviderResult[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Bundle call(@NonNull String authority, @NonNull String method, @Nullable String arg, @Nullable Bundle extras)",
    "returnType" : "Bundle",
    "comment" : "\n     * Call a provider-defined method.  This can be used to implement\n     * interfaces that are cheaper and/or unnatural for a table-like\n     * model.\n     *\n     * <p class=\"note\"><strong>WARNING:</strong> The framework does no permission checking\n     * on this entry into the content provider besides the basic ability for the application\n     * to get access to the provider at all.  For example, it has no idea whether the call\n     * being executed may read or write data in the provider, so can't enforce those\n     * individual permissions.  Any implementation of this method <strong>must</strong>\n     * do its own permission checks on incoming calls to make sure they are allowed.</p>\n     *\n     * @param method method name to call.  Opaque to framework, but should not be {@code null}.\n     * @param arg provider-defined String argument.  May be {@code null}.\n     * @param extras provider-defined Bundle argument.  May be {@code null}.\n     * @return provider-defined return value.  May be {@code null}, which is also\n     *   the default for providers which don't implement any call methods.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Bundle call(@NonNull String method, @Nullable String arg, @Nullable Bundle extras)",
    "returnType" : "Bundle",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void shutdown()",
    "returnType" : "void",
    "comment" : "\n     * Implement this to shut down the ContentProvider instance. You can then\n     * invoke this method in unit tests.\n     *\n     * <p>\n     * Android normally handles ContentProvider startup and shutdown\n     * automatically. You do not need to start up or shut down a\n     * ContentProvider. When you invoke a test method on a ContentProvider,\n     * however, a ContentProvider instance is started and keeps running after\n     * the test finishes, even if a succeeding test instantiates another\n     * ContentProvider. A conflict develops because the two instances are\n     * usually running against the same underlying data source (for example, an\n     * sqlite database).\n     * </p>\n     * <p>\n     * Implementing shutDown() avoids this conflict by providing a way to\n     * terminate the ContentProvider. This method can also prevent memory leaks\n     * from multiple instantiations of the ContentProvider, and it can ensure\n     * unit test isolation by allowing you to completely clean up the test\n     * fixture before moving on to the next test.\n     * </p>\n     ",
    "links" : [ ]
  }, {
    "name" : "public void dump(FileDescriptor fd, PrintWriter writer, String[] args)",
    "returnType" : "void",
    "comment" : "\n     * Print the Provider's state into the given stream.  This gets invoked if\n     * you run \"adb shell dumpsys activity provider &lt;provider_component_name&gt;\".\n     *\n     * @param fd The raw file descriptor that the dump is being sent to.\n     * @param writer The PrintWriter to which you should dump your state.  This will be\n     * closed for you after you return.\n     * @param args additional arguments to the dump request.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void validateIncomingAuthority(String authority) throws SecurityException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Uri validateIncomingUri(Uri uri) throws SecurityException",
    "returnType" : "Uri",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private Uri maybeGetUriWithoutUserId(Uri uri)",
    "returnType" : "Uri",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static int getUserIdFromAuthority(String auth, int defaultUserId)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static int getUserIdFromAuthority(String auth)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static int getUserIdFromUri(Uri uri, int defaultUserId)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static int getUserIdFromUri(Uri uri)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static UserHandle getUserHandleFromUri(@NonNull Uri uri)",
    "returnType" : "UserHandle",
    "comment" : "\n     * Returns the user associated with the given URI.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getAuthorityWithoutUserId(String auth)",
    "returnType" : "String",
    "comment" : "\n     * Removes userId part from authority string. Expects format:\n     * userId@some.authority\n     * If there is no userId in the authority, it symply returns the argument\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Uri getUriWithoutUserId(Uri uri)",
    "returnType" : "Uri",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static boolean uriHasUserId(Uri uri)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static Uri createContentUriForUser(@NonNull Uri contentUri, @NonNull UserHandle userHandle)",
    "returnType" : "Uri",
    "comment" : "\n     * Returns the given content URI explicitly associated with the given {@link UserHandle}.\n     *\n     * @param contentUri The content URI to be associated with a user handle.\n     * @param userHandle The user handle with which to associate the URI.\n     *\n     * @throws IllegalArgumentException if\n     * <ul>\n     *  <li>the given URI is not content URI (a content URI has {@link Uri#getScheme} equal to\n     *  {@link ContentResolver.SCHEME_CONTENT}) or</li>\n     *  <li>the given URI is already explicitly associated with a {@link UserHandle}, which is\n     *  different than the given one.</li>\n     *  </ul>\n     *\n     * @hide\n     ",
    "links" : [ "ContentResolver.SCHEME_CONTENT", "android.os.Process.myUserHandle", "android.net.Uri#getScheme" ]
  }, {
    "name" : "public static Uri maybeAddUserId(Uri uri, int userId)",
    "returnType" : "Uri",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private static void traceBegin(long traceTag, String methodName, String subInfo)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean deniedAccessSystemUserOnlyProvider(int callingUserId, boolean systemUserOnly)",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if access to content provider is denied because it's a SYSTEM user only\n     * provider and the calling user is not the SYSTEM user.\n     *\n     * @param callingUserId UserId of the caller accessing the content provider.\n     * @param systemUserOnly true when the content provider is only available for the SYSTEM user.\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public static boolean isAuthorityRedirectedForCloneProfile(String authority)", "public static ContentProvider coerceToLocalContentProvider(IContentProvider abstractInterface)", " boolean checkUser(int pid, int uid, Context context)", "private boolean isContentRedirectionAllowedForUser(int incomingUserId)", "private int checkPermission(String permission, @NonNull AttributionSource attributionSource)", "protected int enforceReadPermissionInner(Uri uri, @NonNull AttributionSource attributionSource) throws SecurityException", "protected int enforceWritePermissionInner(Uri uri, @NonNull AttributionSource attributionSource) throws SecurityException", "public final Context getContext()", "public final Context requireContext()", "private AttributionSource setCallingAttributionSource(@Nullable AttributionSource attributionSource)", "public final String getCallingPackage()", "public final AttributionSource getCallingAttributionSource()", "public final String getCallingAttributionTag()", "public final String getCallingFeatureId()", "public final String getCallingPackageUnchecked()", "public void onCallingPackageChanged()", "public final CallingIdentity clearCallingIdentity()", "public final void restoreCallingIdentity(@NonNull CallingIdentity identity)", "protected final void setAuthorities(String authorities)", "protected final boolean matchesOurAuthorities(String authority)", "protected final void setReadPermission(@Nullable String permission)", "public final String getReadPermission()", "protected final void setWritePermission(@Nullable String permission)", "public final String getWritePermission()", "protected final void setPathPermissions(@Nullable PathPermission[] permissions)", "public final PathPermission[] getPathPermissions()", "public final void setAppOps(int readOp, int writeOp)", "public AppOpsManager getAppOpsManager()", "public final void setTransportLoggingEnabled(boolean enabled)", "public abstract boolean onCreate()", "public void onConfigurationChanged(Configuration newConfig)", "public void onLowMemory()", "public void onTrimMemory(int level)", "public abstract Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder)", "public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder, @Nullable CancellationSignal cancellationSignal)", "public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable Bundle queryArgs, @Nullable CancellationSignal cancellationSignal)", "public abstract String getType(@NonNull Uri uri)", "public String getTypeAnonymous(@NonNull Uri uri)", "public Uri canonicalize(@NonNull Uri url)", "public Uri uncanonicalize(@NonNull Uri url)", "public boolean refresh(Uri uri, @Nullable Bundle extras, @Nullable CancellationSignal cancellationSignal)", "public int checkUriPermission(@NonNull Uri uri, int uid, @Intent.AccessUriMode int modeFlags)", "public Uri rejectInsert(Uri uri, ContentValues values)", "public abstract Uri insert(@NonNull Uri uri, @Nullable ContentValues values)", "public Uri insert(@NonNull Uri uri, @Nullable ContentValues values, @Nullable Bundle extras)", "public int bulkInsert(@NonNull Uri uri, @NonNull ContentValues[] values)", "public abstract int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs)", "public int delete(@NonNull Uri uri, @Nullable Bundle extras)", "public abstract int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs)", "public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable Bundle extras)", "public ParcelFileDescriptor openFile(@NonNull Uri uri, @NonNull String mode) throws FileNotFoundException", "public ParcelFileDescriptor openFile(@NonNull Uri uri, @NonNull String mode, @Nullable CancellationSignal signal) throws FileNotFoundException", "public AssetFileDescriptor openAssetFile(@NonNull Uri uri, @NonNull String mode) throws FileNotFoundException", "public AssetFileDescriptor openAssetFile(@NonNull Uri uri, @NonNull String mode, @Nullable CancellationSignal signal) throws FileNotFoundException", "protected final ParcelFileDescriptor openFileHelper(@NonNull Uri uri, @NonNull String mode) throws FileNotFoundException", "public String[] getStreamTypes(@NonNull Uri uri, @NonNull String mimeTypeFilter)", "public AssetFileDescriptor openTypedAssetFile(@NonNull Uri uri, @NonNull String mimeTypeFilter, @Nullable Bundle opts) throws FileNotFoundException", "public AssetFileDescriptor openTypedAssetFile(@NonNull Uri uri, @NonNull String mimeTypeFilter, @Nullable Bundle opts, @Nullable CancellationSignal signal) throws FileNotFoundException", "public ParcelFileDescriptor openPipeHelper(@NonNull final Uri uri, @NonNull final String mimeType, @Nullable final Bundle opts, @Nullable final T args, @NonNull final PipeDataWriter<T> func) throws FileNotFoundException", "protected boolean isTemporary()", "public IContentProvider getIContentProvider()", "public void attachInfoForTesting(Context context, ProviderInfo info)", "public void attachInfo(Context context, ProviderInfo info)", "private void attachInfo(Context context, ProviderInfo info, boolean testing)", "public ContentProviderResult[] applyBatch(@NonNull String authority, @NonNull ArrayList<ContentProviderOperation> operations) throws OperationApplicationException", "public ContentProviderResult[] applyBatch(@NonNull ArrayList<ContentProviderOperation> operations) throws OperationApplicationException", "public Bundle call(@NonNull String authority, @NonNull String method, @Nullable String arg, @Nullable Bundle extras)", "public Bundle call(@NonNull String method, @Nullable String arg, @Nullable Bundle extras)", "public void shutdown()", "public void dump(FileDescriptor fd, PrintWriter writer, String[] args)", "private void validateIncomingAuthority(String authority) throws SecurityException", "public Uri validateIncomingUri(Uri uri) throws SecurityException", "private Uri maybeGetUriWithoutUserId(Uri uri)", "public static int getUserIdFromAuthority(String auth, int defaultUserId)", "public static int getUserIdFromAuthority(String auth)", "public static int getUserIdFromUri(Uri uri, int defaultUserId)", "public static int getUserIdFromUri(Uri uri)", "public static UserHandle getUserHandleFromUri(@NonNull Uri uri)", "public static String getAuthorityWithoutUserId(String auth)", "public static Uri getUriWithoutUserId(Uri uri)", "public static boolean uriHasUserId(Uri uri)", "public static Uri createContentUriForUser(@NonNull Uri contentUri, @NonNull UserHandle userHandle)", "public static Uri maybeAddUserId(Uri uri, int userId)", "private static void traceBegin(long traceTag, String methodName, String subInfo)", "private static boolean deniedAccessSystemUserOnlyProvider(int callingUserId, boolean systemUserOnly)" ],
  "variableNames" : [ "TAG", "mContext", "mMyUid", "mAuthority", "mAuthorities", "mReadPermission", "mWritePermission", "mPathPermissions", "mExported", "mNoPerms", "mSingleUser", "mSystemUserOnly", "mUsersRedirectedToOwnerForMedia", "mCallingAttributionSource", "mTransport" ]
}