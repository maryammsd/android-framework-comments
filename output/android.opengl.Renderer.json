{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/opengl/GLSurfaceView.java",
  "packageName" : "android.opengl",
  "className" : "Renderer",
  "comment" : "\n     * A generic renderer interface.\n     * <p>\n     * The renderer is responsible for making OpenGL calls to render a frame.\n     * <p>\n     * GLSurfaceView clients typically create their own classes that implement\n     * this interface, and then call {@link GLSurfaceView#setRenderer} to\n     * register the renderer with the GLSurfaceView.\n     * <p>\n     *\n     * <div class=\"special reference\">\n     * <h3>Developer Guides</h3>\n     * <p>For more information about how to use OpenGL, read the\n     * <a href=\"{@docRoot}guide/topics/graphics/opengl.html\">OpenGL</a> developer guide.</p>\n     * </div>\n     *\n     * <h3>Threading</h3>\n     * The renderer will be called on a separate thread, so that rendering\n     * performance is decoupled from the UI thread. Clients typically need to\n     * communicate with the renderer from the UI thread, because that's where\n     * input events are received. Clients can communicate using any of the\n     * standard Java techniques for cross-thread communication, or they can\n     * use the {@link GLSurfaceView#queueEvent(Runnable)} convenience method.\n     * <p>\n     * <h3>EGL Context Lost</h3>\n     * There are situations where the EGL rendering context will be lost. This\n     * typically happens when device wakes up after going to sleep. When\n     * the EGL context is lost, all OpenGL resources (such as textures) that are\n     * associated with that context will be automatically deleted. In order to\n     * keep rendering correctly, a renderer must recreate any lost resources\n     * that it still needs. The {@link #onSurfaceCreated(GL10, EGLConfig)} method\n     * is a convenient place to do this.\n     *\n     *\n     * @see #setRenderer(Renderer)\n     ",
  "links" : [ "android.opengl.GLSurfaceView#setRenderer", "android.opengl.GLSurfaceView#queueEvent(Runnable)", "#onSurfaceCreated(GL10" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " void onSurfaceCreated(GL10 gl, EGLConfig config)",
    "returnType" : "void",
    "comment" : "\n         * Called when the surface is created or recreated.\n         * <p>\n         * Called when the rendering thread\n         * starts and whenever the EGL context is lost. The EGL context will typically\n         * be lost when the Android device awakes after going to sleep.\n         * <p>\n         * Since this method is called at the beginning of rendering, as well as\n         * every time the EGL context is lost, this method is a convenient place to put\n         * code to create resources that need to be created when the rendering\n         * starts, and that need to be recreated when the EGL context is lost.\n         * Textures are an example of a resource that you might want to create\n         * here.\n         * <p>\n         * Note that when the EGL context is lost, all OpenGL resources associated\n         * with that context will be automatically deleted. You do not need to call\n         * the corresponding \"glDelete\" methods such as glDeleteTextures to\n         * manually delete these lost resources.\n         * <p>\n         * @param gl the GL interface. Use <code>instanceof</code> to\n         * test if the interface supports GL11 or higher interfaces.\n         * @param config the EGLConfig of the created surface. Can be used\n         * to create matching pbuffers.\n         ",
    "links" : [ ]
  }, {
    "name" : " void onSurfaceChanged(GL10 gl, int width, int height)",
    "returnType" : "void",
    "comment" : "\n         * Called when the surface changed size.\n         * <p>\n         * Called after the surface is created and whenever\n         * the OpenGL ES surface size changes.\n         * <p>\n         * Typically you will set your viewport here. If your camera\n         * is fixed then you could also set your projection matrix here:\n         * <pre class=\"prettyprint\">\n         * void onSurfaceChanged(GL10 gl, int width, int height) {\n         *     gl.glViewport(0, 0, width, height);\n         *     // for a fixed camera, set the projection too\n         *     float ratio = (float) width / height;\n         *     gl.glMatrixMode(GL10.GL_PROJECTION);\n         *     gl.glLoadIdentity();\n         *     gl.glFrustumf(-ratio, ratio, -1, 1, 1, 10);\n         * }\n         * </pre>\n         * @param gl the GL interface. Use <code>instanceof</code> to\n         * test if the interface supports GL11 or higher interfaces.\n         * @param width\n         * @param height\n         ",
    "links" : [ ]
  }, {
    "name" : " void onDrawFrame(GL10 gl)",
    "returnType" : "void",
    "comment" : "\n         * Called to draw the current frame.\n         * <p>\n         * This method is responsible for drawing the current frame.\n         * <p>\n         * The implementation of this method typically looks like this:\n         * <pre class=\"prettyprint\">\n         * void onDrawFrame(GL10 gl) {\n         *     gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);\n         *     //... other gl calls to render the scene ...\n         * }\n         * </pre>\n         * @param gl the GL interface. Use <code>instanceof</code> to\n         * test if the interface supports GL11 or higher interfaces.\n         ",
    "links" : [ ]
  } ],
  "methodNames" : [ " void onSurfaceCreated(GL10 gl, EGLConfig config)", " void onSurfaceChanged(GL10 gl, int width, int height)", " void onDrawFrame(GL10 gl)" ],
  "variableNames" : [ ]
}