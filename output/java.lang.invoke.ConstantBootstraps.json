{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/lang/invoke/ConstantBootstraps.java",
  "packageName" : "java.lang.invoke",
  "className" : "ConstantBootstraps",
  "comment" : "\n * Bootstrap methods for dynamically-computed constants.\n *\n * <p>The bootstrap methods in this class will throw a\n * {@code NullPointerException} for any reference argument that is {@code null},\n * unless the argument is specified to be unused or specified to accept a\n * {@code null} value.\n *\n * @since 11\n ",
  "links" : [ ],
  "variables" : [ ],
  "methods" : [ {
    "name" : "public static Object nullConstant(MethodHandles.Lookup lookup, String name, Class<?> type)",
    "returnType" : "Object",
    "comment" : "\n     * Returns a {@code null} object reference for the reference type specified\n     * by {@code type}.\n     *\n     * @param lookup unused\n     * @param name unused\n     * @param type a reference type\n     * @return a {@code null} value\n     * @throws IllegalArgumentException if {@code type} is not a reference type\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Class<?> primitiveClass(MethodHandles.Lookup lookup, String name, Class<?> type)",
    "returnType" : "Class<?>",
    "comment" : "\n     * Returns a {@link Class} mirror for the primitive type whose type\n     * descriptor is specified by {@code name}.\n     *\n     * @param lookup unused\n     * @param name the descriptor (JVMS 4.3) of the desired primitive type\n     * @param type the required result type (must be {@code Class.class})\n     * @return the {@link Class} mirror\n     * @throws IllegalArgumentException if the name is not a descriptor for a\n     * primitive type or the type is not {@code Class.class}\n     ",
    "links" : [ "Class" ]
  }, {
    "name" : "public static E enumConstant(MethodHandles.Lookup lookup, String name, Class<E> type)",
    "returnType" : "E",
    "comment" : "\n     * Returns an {@code enum} constant of the type specified by {@code type}\n     * with the name specified by {@code name}.\n     *\n     * @param lookup the lookup context describing the class performing the\n     * operation (normally stacked by the JVM)\n     * @param name the name of the constant to return, which must exactly match\n     * an enum constant in the specified type.\n     * @param type the {@code Class} object describing the enum type for which\n     * a constant is to be returned\n     * @param <E> The enum type for which a constant value is to be returned\n     * @return the enum constant of the specified enum type with the\n     * specified name\n     * @throws IllegalAccessError if the declaring class or the field is not\n     * accessible to the class performing the operation\n     * @throws IllegalArgumentException if the specified enum type has\n     * no constant with the specified name, or the specified\n     * class object does not represent an enum type\n     * @see Enum#valueOf(Class, String)\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Object getStaticFinal(MethodHandles.Lookup lookup, String name, Class<?> type, Class<?> declaringClass)",
    "returnType" : "Object",
    "comment" : "\n     * Returns the value of a static final field.\n     *\n     * @param lookup the lookup context describing the class performing the\n     * operation (normally stacked by the JVM)\n     * @param name the name of the field\n     * @param type the type of the field\n     * @param declaringClass the class in which the field is declared\n     * @return the value of the field\n     * @throws IllegalAccessError if the declaring class or the field is not\n     * accessible to the class performing the operation\n     * @throws NoSuchFieldError if the specified field does not exist\n     * @throws IncompatibleClassChangeError if the specified field is not\n     * {@code final}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Object getStaticFinal(MethodHandles.Lookup lookup, String name, Class<?> type)",
    "returnType" : "Object",
    "comment" : "\n     * Returns the value of a static final field declared in the class which\n     * is the same as the field's type (or, for primitive-valued fields,\n     * declared in the wrapper class.)  This is a simplified form of\n     * {@link #getStaticFinal(MethodHandles.Lookup, String, Class, Class)}\n     * for the case where a class declares distinguished constant instances of\n     * itself.\n     *\n     * @param lookup the lookup context describing the class performing the\n     * operation (normally stacked by the JVM)\n     * @param name the name of the field\n     * @param type the type of the field\n     * @return the value of the field\n     * @throws IllegalAccessError if the declaring class or the field is not\n     * accessible to the class performing the operation\n     * @throws NoSuchFieldError if the specified field does not exist\n     * @throws IncompatibleClassChangeError if the specified field is not\n     * {@code final}\n     * @see #getStaticFinal(MethodHandles.Lookup, String, Class, Class)\n     ",
    "links" : [ "#getStaticFinal(MethodHandles.Lookup" ]
  }, {
    "name" : "public static Object invoke(MethodHandles.Lookup lookup, String name, Class<?> type, MethodHandle handle, Object... args) throws Throwable",
    "returnType" : "Object",
    "comment" : "\n     * Returns the result of invoking a method handle with the provided\n     * arguments.\n     * <p>\n     * This method behaves as if the method handle to be invoked is the result\n     * of adapting the given method handle, via {@link MethodHandle#asType}, to\n     * adjust the return type to the desired type.\n     *\n     * @param lookup unused\n     * @param name unused\n     * @param type the desired type of the value to be returned, which must be\n     * compatible with the return type of the method handle\n     * @param handle the method handle to be invoked\n     * @param args the arguments to pass to the method handle, as if with\n     * {@link MethodHandle#invokeWithArguments}.  Each argument may be\n     * {@code null}.\n     * @return the result of invoking the method handle\n     * @throws WrongMethodTypeException if the handle's method type cannot be\n     * adjusted to take the given number of arguments, or if the handle's return\n     * type cannot be adjusted to the desired type\n     * @throws ClassCastException if an argument or the result produced by\n     * invoking the handle cannot be converted by reference casting\n     * @throws Throwable anything thrown by the method handle invocation\n     ",
    "links" : [ "java.lang.invoke.MethodHandle#invokeWithArguments", "java.lang.invoke.MethodHandle#asType" ]
  }, {
    "name" : "public static VarHandle fieldVarHandle(MethodHandles.Lookup lookup, String name, Class<VarHandle> type, Class<?> declaringClass, Class<?> fieldType)",
    "returnType" : "VarHandle",
    "comment" : "\n     * Finds a {@link VarHandle} for an instance field.\n     *\n     * @param lookup the lookup context describing the class performing the\n     * operation (normally stacked by the JVM)\n     * @param name the name of the field\n     * @param type the required result type (must be {@code Class<VarHandle>})\n     * @param declaringClass the class in which the field is declared\n     * @param fieldType the type of the field\n     * @return the {@link VarHandle}\n     * @throws IllegalAccessError if the declaring class or the field is not\n     * accessible to the class performing the operation\n     * @throws NoSuchFieldError if the specified field does not exist\n     * @throws IllegalArgumentException if the type is not {@code VarHandle}\n     ",
    "links" : [ "java.lang.invoke.VarHandle" ]
  }, {
    "name" : "public static VarHandle staticFieldVarHandle(MethodHandles.Lookup lookup, String name, Class<VarHandle> type, Class<?> declaringClass, Class<?> fieldType)",
    "returnType" : "VarHandle",
    "comment" : "\n     * Finds a {@link VarHandle} for a static field.\n     *\n     * @param lookup the lookup context describing the class performing the\n     * operation (normally stacked by the JVM)\n     * @param name the name of the field\n     * @param type the required result type (must be {@code Class<VarHandle>})\n     * @param declaringClass the class in which the field is declared\n     * @param fieldType the type of the field\n     * @return the {@link VarHandle}\n     * @throws IllegalAccessError if the declaring class or the field is not\n     * accessible to the class performing the operation\n     * @throws NoSuchFieldError if the specified field does not exist\n     * @throws IllegalArgumentException if the type is not {@code VarHandle}\n     ",
    "links" : [ "java.lang.invoke.VarHandle" ]
  }, {
    "name" : "public static VarHandle arrayVarHandle(MethodHandles.Lookup lookup, String name, Class<VarHandle> type, Class<?> arrayClass)",
    "returnType" : "VarHandle",
    "comment" : "\n     * Finds a {@link VarHandle} for an array type.\n     *\n     * @param lookup the lookup context describing the class performing the\n     * operation (normally stacked by the JVM)\n     * @param name unused\n     * @param type the required result type (must be {@code Class<VarHandle>})\n     * @param arrayClass the type of the array\n     * @return the {@link VarHandle}\n     * @throws IllegalAccessError if the component type of the array is not\n     * accessible to the class performing the operation\n     * @throws IllegalArgumentException if the type is not {@code VarHandle}\n     ",
    "links" : [ "java.lang.invoke.VarHandle" ]
  }, {
    "name" : "public static Object explicitCast(MethodHandles.Lookup lookup, String name, Class<?> dstType, Object value) throws ClassCastException",
    "returnType" : "Object",
    "comment" : "\n     * Applies a conversion from a source type to a destination type.\n     * <p>\n     * Given a destination type {@code dstType} and an input\n     * value {@code value}, one of the following will happen:\n     * <ul>\n     * <li>If {@code dstType} is {@code void.class},\n     *     a {@link ClassCastException} is thrown.\n     * <li>If {@code dstType} is {@code Object.class}, {@code value} is returned as is.\n     * </ul>\n     * <p>\n     * Otherwise one of the following conversions is applied to {@code value}:\n     * <ol>\n     * <li>If {@code dstType} is a reference type, a reference cast\n     *     is applied to {@code value} as if by calling {@code dstType.cast(value)}.\n     * <li>If {@code dstType} is a primitive type, then, if the runtime type\n     *     of {@code value} is a primitive wrapper type (such as {@link Integer}),\n     *     a Java unboxing conversion is applied {@jls 5.1.8} followed by a\n     *     Java casting conversion {@jls 5.5} converting either directly to\n     *     {@code dstType}, or, if {@code dstType} is {@code boolean},\n     *     to {@code int}, which is then converted to either {@code true}\n     *     or {@code false} depending on whether the least-significant-bit\n     *     is 1 or 0 respectively. If the runtime type of {@code value} is\n     *     not a primitive wrapper type a {@link ClassCastException} is thrown.\n     * </ol>\n     * <p>\n     * The result is the same as when using the following code:\n     * <blockquote><pre>{@code\n     * MethodHandle id = MethodHandles.identity(dstType);\n     * MethodType mt = MethodType.methodType(dstType, Object.class);\n     * MethodHandle conv = MethodHandles.explicitCastArguments(id, mt);\n     * return conv.invoke(value);\n     * }</pre></blockquote>\n     *\n     * @param lookup unused\n     * @param name unused\n     * @param dstType the destination type of the conversion\n     * @param value the value to be converted\n     * @return the converted value\n     * @throws ClassCastException when {@code dstType} is {@code void},\n     *         when a cast per (1) fails, or when {@code dstType} is a primitive type\n     *         and the runtime type of {@code value} is not a primitive wrapper type\n     *         (such as {@link Integer})\n     *\n     * @since 15\n     ",
    "links" : [ "Integer", "ClassCastException" ]
  }, {
    "name" : "private static Class<T> validateClassAccess(MethodHandles.Lookup lookup, Class<T> type)",
    "returnType" : "Class<T>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ "public static Object nullConstant(MethodHandles.Lookup lookup, String name, Class<?> type)", "public static Class<?> primitiveClass(MethodHandles.Lookup lookup, String name, Class<?> type)", "public static E enumConstant(MethodHandles.Lookup lookup, String name, Class<E> type)", "public static Object getStaticFinal(MethodHandles.Lookup lookup, String name, Class<?> type, Class<?> declaringClass)", "public static Object getStaticFinal(MethodHandles.Lookup lookup, String name, Class<?> type)", "public static Object invoke(MethodHandles.Lookup lookup, String name, Class<?> type, MethodHandle handle, Object... args) throws Throwable", "public static VarHandle fieldVarHandle(MethodHandles.Lookup lookup, String name, Class<VarHandle> type, Class<?> declaringClass, Class<?> fieldType)", "public static VarHandle staticFieldVarHandle(MethodHandles.Lookup lookup, String name, Class<VarHandle> type, Class<?> declaringClass, Class<?> fieldType)", "public static VarHandle arrayVarHandle(MethodHandles.Lookup lookup, String name, Class<VarHandle> type, Class<?> arrayClass)", "public static Object explicitCast(MethodHandles.Lookup lookup, String name, Class<?> dstType, Object value) throws ClassCastException", "private static Class<T> validateClassAccess(MethodHandles.Lookup lookup, Class<T> type)" ],
  "variableNames" : [ ]
}