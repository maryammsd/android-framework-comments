{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/media/MediaMetadataRetriever.java",
  "packageName" : "android.media",
  "className" : "MediaMetadataRetriever",
  "comment" : "\n * MediaMetadataRetriever class provides a unified interface for retrieving\n * frame and meta data from an input media file.\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "STANDARD_GENRES",
    "type" : "String[]",
    "comment" : " borrowed from ExoPlayer",
    "links" : [ ]
  }, {
    "name" : "mNativeContext",
    "type" : "long",
    "comment" : " The field below is accessed by native methods",
    "links" : [ ]
  }, {
    "name" : "EMBEDDED_PICTURE_TYPE_ANY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "OPTION_PREVIOUS_SYNC",
    "type" : "int",
    "comment" : "\n     * This option is used with {@link #getFrameAtTime(long, int)} to retrieve\n     * a sync (or key) frame associated with a data source that is located\n     * right before or at the given time.\n     *\n     * @see #getFrameAtTime(long, int)\n     ",
    "links" : [ "#getFrameAtTime(long" ]
  }, {
    "name" : "OPTION_NEXT_SYNC",
    "type" : "int",
    "comment" : "\n     * This option is used with {@link #getFrameAtTime(long, int)} to retrieve\n     * a sync (or key) frame associated with a data source that is located\n     * right after or at the given time.\n     *\n     * @see #getFrameAtTime(long, int)\n     ",
    "links" : [ "#getFrameAtTime(long" ]
  }, {
    "name" : "OPTION_CLOSEST_SYNC",
    "type" : "int",
    "comment" : "\n     * This option is used with {@link #getFrameAtTime(long, int)} to retrieve\n     * a sync (or key) frame associated with a data source that is located\n     * closest to (in time) or at the given time.\n     *\n     * @see #getFrameAtTime(long, int)\n     ",
    "links" : [ "#getFrameAtTime(long" ]
  }, {
    "name" : "OPTION_CLOSEST",
    "type" : "int",
    "comment" : "\n     * This option is used with {@link #getFrameAtTime(long, int)} to retrieve\n     * a frame (not necessarily a key frame) associated with a data source that\n     * is located closest to or at the given time.\n     *\n     * @see #getFrameAtTime(long, int)\n     ",
    "links" : [ "#getFrameAtTime(long" ]
  }, {
    "name" : "METADATA_KEY_CD_TRACK_NUMBER",
    "type" : "int",
    "comment" : "\n     * The metadata key to retrieve the numeric string describing the\n     * order of the audio data source on its original recording.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_ALBUM",
    "type" : "int",
    "comment" : "\n     * The metadata key to retrieve the information about the album title\n     * of the data source.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_ARTIST",
    "type" : "int",
    "comment" : "\n     * The metadata key to retrieve the information about the artist of\n     * the data source.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_AUTHOR",
    "type" : "int",
    "comment" : "\n     * The metadata key to retrieve the information about the author of\n     * the data source.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_COMPOSER",
    "type" : "int",
    "comment" : "\n     * The metadata key to retrieve the information about the composer of\n     * the data source.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_DATE",
    "type" : "int",
    "comment" : "\n     * The metadata key to retrieve the date when the data source was created\n     * or modified.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_GENRE",
    "type" : "int",
    "comment" : "\n     * The metadata key to retrieve the content type or genre of the data\n     * source.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_TITLE",
    "type" : "int",
    "comment" : "\n     * The metadata key to retrieve the data source title.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_YEAR",
    "type" : "int",
    "comment" : "\n     * The metadata key to retrieve the year when the data source was created\n     * or modified.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_DURATION",
    "type" : "int",
    "comment" : "\n     * The metadata key to retrieve the playback duration (in ms) of the data source.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_NUM_TRACKS",
    "type" : "int",
    "comment" : "\n     * The metadata key to retrieve the number of tracks, such as audio, video,\n     * text, in the data source, such as a mp4 or 3gpp file.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_WRITER",
    "type" : "int",
    "comment" : "\n     * The metadata key to retrieve the information of the writer (such as\n     * lyricist) of the data source.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_MIMETYPE",
    "type" : "int",
    "comment" : "\n     * The metadata key to retrieve the mime type of the data source. Some\n     * example mime types include: \"video/mp4\", \"audio/mp4\", \"audio/amr-wb\",\n     * etc.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_ALBUMARTIST",
    "type" : "int",
    "comment" : "\n     * The metadata key to retrieve the information about the performers or\n     * artist associated with the data source.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_DISC_NUMBER",
    "type" : "int",
    "comment" : "\n     * The metadata key to retrieve the numberic string that describes which\n     * part of a set the audio data source comes from.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_COMPILATION",
    "type" : "int",
    "comment" : "\n     * The metadata key to retrieve the music album compilation status.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_HAS_AUDIO",
    "type" : "int",
    "comment" : "\n     * If this key exists the media contains audio content.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_HAS_VIDEO",
    "type" : "int",
    "comment" : "\n     * If this key exists the media contains video content.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_VIDEO_WIDTH",
    "type" : "int",
    "comment" : "\n     * If the media contains video, this key retrieves its width.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_VIDEO_HEIGHT",
    "type" : "int",
    "comment" : "\n     * If the media contains video, this key retrieves its height.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_BITRATE",
    "type" : "int",
    "comment" : "\n     * This key retrieves the average bitrate (in bits/sec), if available.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_TIMED_TEXT_LANGUAGES",
    "type" : "int",
    "comment" : "\n     * This key retrieves the language code of text tracks, if available.\n     * If multiple text tracks present, the return value will look like:\n     * \"eng:chi\"\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_IS_DRM",
    "type" : "int",
    "comment" : "\n     * If this key exists the media is drm-protected.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_LOCATION",
    "type" : "int",
    "comment" : "\n     * This key retrieves the location information, if available.\n     * The location should be specified according to ISO-6709 standard, under\n     * a mp4/3gp box \"@xyz\". Location with longitude of -90 degrees and latitude\n     * of 180 degrees will be retrieved as \"+180.0000-90.0000/\", for instance.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_VIDEO_ROTATION",
    "type" : "int",
    "comment" : "\n     * This key retrieves the video rotation angle in degrees, if available.\n     * The video rotation angle may be 0, 90, 180, or 270 degrees.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_CAPTURE_FRAMERATE",
    "type" : "int",
    "comment" : "\n     * This key retrieves the original capture framerate, if it's\n     * available. The capture framerate will be a floating point\n     * number.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_HAS_IMAGE",
    "type" : "int",
    "comment" : "\n     * If this key exists the media contains still image content.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_IMAGE_COUNT",
    "type" : "int",
    "comment" : "\n     * If the media contains still images, this key retrieves the number\n     * of still images.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_IMAGE_PRIMARY",
    "type" : "int",
    "comment" : "\n     * If the media contains still images, this key retrieves the image\n     * index of the primary image.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_IMAGE_WIDTH",
    "type" : "int",
    "comment" : "\n     * If the media contains still images, this key retrieves the width\n     * of the primary image.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_IMAGE_HEIGHT",
    "type" : "int",
    "comment" : "\n     * If the media contains still images, this key retrieves the height\n     * of the primary image.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_IMAGE_ROTATION",
    "type" : "int",
    "comment" : "\n     * If the media contains still images, this key retrieves the rotation\n     * angle (in degrees clockwise) of the primary image. The image rotation\n     * angle must be one of 0, 90, 180, or 270 degrees.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_VIDEO_FRAME_COUNT",
    "type" : "int",
    "comment" : "\n     * If the media contains video and this key exists, it retrieves the\n     * total number of frames in the video sequence.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_EXIF_OFFSET",
    "type" : "int",
    "comment" : "\n     * If the media contains EXIF data, this key retrieves the offset (in bytes)\n     * of the data.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_EXIF_LENGTH",
    "type" : "int",
    "comment" : "\n     * If the media contains EXIF data, this key retrieves the length (in bytes)\n     * of the data.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_COLOR_STANDARD",
    "type" : "int",
    "comment" : "\n     * This key retrieves the color standard, if available.\n     *\n     * @see MediaFormat#COLOR_STANDARD_BT709\n     * @see MediaFormat#COLOR_STANDARD_BT601_PAL\n     * @see MediaFormat#COLOR_STANDARD_BT601_NTSC\n     * @see MediaFormat#COLOR_STANDARD_BT2020\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_COLOR_TRANSFER",
    "type" : "int",
    "comment" : "\n     * This key retrieves the color transfer, if available.\n     *\n     * @see MediaFormat#COLOR_TRANSFER_LINEAR\n     * @see MediaFormat#COLOR_TRANSFER_SDR_VIDEO\n     * @see MediaFormat#COLOR_TRANSFER_ST2084\n     * @see MediaFormat#COLOR_TRANSFER_HLG\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_COLOR_RANGE",
    "type" : "int",
    "comment" : "\n     * This key retrieves the color range, if available.\n     *\n     * @see MediaFormat#COLOR_RANGE_LIMITED\n     * @see MediaFormat#COLOR_RANGE_FULL\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_SAMPLERATE",
    "type" : "int",
    "comment" : "\n     * This key retrieves the sample rate in Hz, if available.\n     * This is a signed 32-bit integer formatted as a string in base 10.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_BITS_PER_SAMPLE",
    "type" : "int",
    "comment" : "\n     * This key retrieves the bits per sample in numbers of bits, if available.\n     * This is a signed 32-bit integer formatted as a string in base 10.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_VIDEO_CODEC_MIME_TYPE",
    "type" : "int",
    "comment" : "\n     * This key retrieves the video codec mimetype if available.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_XMP_OFFSET",
    "type" : "int",
    "comment" : "\n     * If the media contains XMP data, this key retrieves the offset (in bytes)\n     * of the data.\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_KEY_XMP_LENGTH",
    "type" : "int",
    "comment" : "\n     * If the media contains XMP data, this key retrieves the length (in bytes)\n     * of the data.\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public void setDataSource(String path) throws IllegalArgumentException",
    "returnType" : "void",
    "comment" : "\n     * Sets the data source (file pathname) to use. Call this\n     * method before the rest of the methods in this class. This method may be\n     * time-consuming.\n     *\n     * @param path The path, or the URI (doesn't support streaming source currently)\n     * of the input media file.\n     * @throws IllegalArgumentException If the path is invalid.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDataSource(String uri, Map<String, String> headers) throws IllegalArgumentException",
    "returnType" : "void",
    "comment" : "\n     * Sets the data source (URI) to use. Call this\n     * method before the rest of the methods in this class. This method may be\n     * time-consuming.\n     *\n     * @param uri The URI of the input media.\n     * @param headers the headers to be sent together with the request for the data\n     * @throws IllegalArgumentException If the URI is invalid.\n     ",
    "links" : [ ]
  }, {
    "name" : "private native void _setDataSource(IBinder httpServiceBinder, String uri, String[] keys, String[] values) throws IllegalArgumentException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setDataSource(FileDescriptor fd, long offset, long length) throws IllegalArgumentException",
    "returnType" : "void",
    "comment" : "\n     * Sets the data source (FileDescriptor) to use.  It is the caller's\n     * responsibility to close the file descriptor. It is safe to do so as soon\n     * as this call returns. Call this method before the rest of the methods in\n     * this class. This method may be time-consuming.\n     *\n     * @param fd the FileDescriptor for the file you want to play\n     * @param offset the offset into the file where the data to be played starts,\n     * in bytes. It must be non-negative\n     * @param length the length in bytes of the data to be played. It must be\n     * non-negative.\n     * @throws IllegalArgumentException if the arguments are invalid\n     ",
    "links" : [ ]
  }, {
    "name" : "private native void _setDataSource(FileDescriptor fd, long offset, long length) throws IllegalArgumentException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setDataSource(FileDescriptor fd) throws IllegalArgumentException",
    "returnType" : "void",
    "comment" : "\n     * Sets the data source (FileDescriptor) to use. It is the caller's\n     * responsibility to close the file descriptor. It is safe to do so as soon\n     * as this call returns. Call this method before the rest of the methods in\n     * this class. This method may be time-consuming.\n     *\n     * @param fd the FileDescriptor for the file you want to play\n     * @throws IllegalArgumentException if the FileDescriptor is invalid\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDataSource(Context context, Uri uri) throws IllegalArgumentException, SecurityException",
    "returnType" : "void",
    "comment" : "\n     * Sets the data source as a content Uri. Call this method before\n     * the rest of the methods in this class. This method may be time-consuming.\n     *\n     * @param context the Context to use when resolving the Uri\n     * @param uri the Content URI of the data you want to play\n     * @throws IllegalArgumentException if the Uri is invalid\n     * @throws SecurityException if the Uri cannot be used due to lack of\n     * permission.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDataSource(MediaDataSource dataSource) throws IllegalArgumentException",
    "returnType" : "void",
    "comment" : "\n     * Sets the data source (MediaDataSource) to use.\n     *\n     * @param dataSource the MediaDataSource for the media you want to play\n     ",
    "links" : [ ]
  }, {
    "name" : "private native void _setDataSource(MediaDataSource dataSource) throws IllegalArgumentException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native String nativeExtractMetadata(int keyCode)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public String extractMetadata(int keyCode)",
    "returnType" : "String",
    "comment" : "\n     * Call this method after setDataSource(). This method retrieves the\n     * meta data value associated with the keyCode.\n     *\n     * The keyCode currently supported is listed below as METADATA_XXX\n     * constants. With any other value, it returns a null pointer.\n     *\n     * @param keyCode One of the constants listed below at the end of the class.\n     * @return The meta data value associate with the given keyCode on success;\n     * null on failure.\n     ",
    "links" : [ ]
  }, {
    "name" : "private String convertGenreTag(String meta)",
    "returnType" : "String",
    "comment" : "\n     * The id3v2 spec doesn't specify the syntax of the genre tag very precisely, so\n     * some assumptions are made. Using one possible interpretation of the id3v2\n     * spec, this method converts an id3 genre tag string to a human readable string,\n     * as follows:\n     * - if the first character of the tag is a digit, the entire tag is assumed to\n     *   be an id3v1 numeric genre code. If the tag does not parse to a number, or\n     *   the number is outside the range of defined standard genres, it is ignored.\n     * - if the tag does not start with a digit, it is assumed to be an id3v2 style\n     *   tag consisting of one or more genres, with each genre being either a parenthesized\n     *   integer referring to an id3v1 numeric genre code, the special indicators \"(CR)\" or\n     *   \"(RX)\" (for \"Cover\" or \"Remix\", respectively), or a custom genre string. When\n     *   a custom genre string is encountered, it is assumed to continue until the end\n     *   of the tag, unless it starts with \"((\" in which case it is assumed to continue\n     *   until the next close-parenthesis or the end of the tag. Any parse error in the tag\n     *   causes it to be ignored.\n     * The human-readable genre string is not localized, and uses the English genre names\n     * from the spec.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Bitmap getFrameAtTime(long timeUs, @Option int option)",
    "returnType" : "Bitmap",
    "comment" : "\n     * This method is similar to {@link #getFrameAtTime(long, int, BitmapParams)}\n     * except that the device will choose the actual {@link Bitmap.Config} to use.\n     *\n     * @param timeUs The time position where the frame will be retrieved.\n     * When retrieving the frame at the given time position, there is no\n     * guarantee that the data source has a frame located at the position.\n     * When this happens, a frame nearby will be returned. If timeUs is\n     * negative, time position and option will ignored, and any frame\n     * that the implementation considers as representative may be returned.\n     *\n     * @param option a hint on how the frame is found. Use\n     * {@link #OPTION_PREVIOUS_SYNC} if one wants to retrieve a sync frame\n     * that has a timestamp earlier than or the same as timeUs. Use\n     * {@link #OPTION_NEXT_SYNC} if one wants to retrieve a sync frame\n     * that has a timestamp later than or the same as timeUs. Use\n     * {@link #OPTION_CLOSEST_SYNC} if one wants to retrieve a sync frame\n     * that has a timestamp closest to or the same as timeUs. Use\n     * {@link #OPTION_CLOSEST} if one wants to retrieve a frame that may\n     * or may not be a sync frame but is closest to or the same as timeUs.\n     * {@link #OPTION_CLOSEST} often has larger performance overhead compared\n     * to the other options if there is no sync frame located at timeUs.\n     *\n     * @return A Bitmap containing a representative video frame, which can be null,\n     *         if such a frame cannot be retrieved. {@link Bitmap#getConfig()} can\n     *         be used to query the actual {@link Bitmap.Config}.\n     *\n     * @see #getFrameAtTime(long, int, BitmapParams)\n     ",
    "links" : [ "android.graphics.Bitmap#getConfig()", "#OPTION_NEXT_SYNC", "#OPTION_CLOSEST", "#OPTION_CLOSEST_SYNC", "Bitmap.Config", "#OPTION_PREVIOUS_SYNC", "#getFrameAtTime(long" ]
  }, {
    "name" : "public Bitmap getFrameAtTime(long timeUs, @Option int option, @NonNull BitmapParams params)",
    "returnType" : "Bitmap",
    "comment" : "\n     * Call this method after setDataSource(). This method finds a\n     * representative frame close to the given time position by considering\n     * the given option if possible, and returns it as a bitmap.\n     *\n     * <p>If you don't need a full-resolution\n     * frame (for example, because you need a thumbnail image), use\n     * {@link #getScaledFrameAtTime getScaledFrameAtTime()} instead of this\n     * method.</p>\n     *\n     * @param timeUs The time position where the frame will be retrieved.\n     * When retrieving the frame at the given time position, there is no\n     * guarantee that the data source has a frame located at the position.\n     * When this happens, a frame nearby will be returned. If timeUs is\n     * negative, time position and option will ignored, and any frame\n     * that the implementation considers as representative may be returned.\n     *\n     * @param option a hint on how the frame is found. Use\n     * {@link #OPTION_PREVIOUS_SYNC} if one wants to retrieve a sync frame\n     * that has a timestamp earlier than or the same as timeUs. Use\n     * {@link #OPTION_NEXT_SYNC} if one wants to retrieve a sync frame\n     * that has a timestamp later than or the same as timeUs. Use\n     * {@link #OPTION_CLOSEST_SYNC} if one wants to retrieve a sync frame\n     * that has a timestamp closest to or the same as timeUs. Use\n     * {@link #OPTION_CLOSEST} if one wants to retrieve a frame that may\n     * or may not be a sync frame but is closest to or the same as timeUs.\n     * {@link #OPTION_CLOSEST} often has larger performance overhead compared\n     * to the other options if there is no sync frame located at timeUs.\n     *\n     * @param params BitmapParams that controls the returned bitmap config\n     *        (such as pixel formats).\n     *\n     * @return A Bitmap containing a representative video frame, which\n     *         can be null, if such a frame cannot be retrieved.\n     *\n     * @see #getFrameAtTime(long, int)\n     ",
    "links" : [ "#getScaledFrameAtTime", "#OPTION_NEXT_SYNC", "#OPTION_CLOSEST", "#OPTION_CLOSEST_SYNC", "#OPTION_PREVIOUS_SYNC" ]
  }, {
    "name" : "public Bitmap getScaledFrameAtTime(long timeUs, @Option int option, @IntRange(from = 1) int dstWidth, @IntRange(from = 1) int dstHeight)",
    "returnType" : "Bitmap",
    "comment" : "\n     * This method is similar to {@link #getScaledFrameAtTime(long, int, int, int, BitmapParams)}\n     * except that the device will choose the actual {@link Bitmap.Config} to use.\n     *\n     * @param timeUs The time position in microseconds where the frame will be retrieved.\n     * When retrieving the frame at the given time position, there is no\n     * guarantee that the data source has a frame located at the position.\n     * When this happens, a frame nearby will be returned. If timeUs is\n     * negative, time position and option will ignored, and any frame\n     * that the implementation considers as representative may be returned.\n     *\n     * @param option a hint on how the frame is found. Use\n     * {@link #OPTION_PREVIOUS_SYNC} if one wants to retrieve a sync frame\n     * that has a timestamp earlier than or the same as timeUs. Use\n     * {@link #OPTION_NEXT_SYNC} if one wants to retrieve a sync frame\n     * that has a timestamp later than or the same as timeUs. Use\n     * {@link #OPTION_CLOSEST_SYNC} if one wants to retrieve a sync frame\n     * that has a timestamp closest to or the same as timeUs. Use\n     * {@link #OPTION_CLOSEST} if one wants to retrieve a frame that may\n     * or may not be a sync frame but is closest to or the same as timeUs.\n     * {@link #OPTION_CLOSEST} often has larger performance overhead compared\n     * to the other options if there is no sync frame located at timeUs.\n     *\n     * @param dstWidth expected output bitmap width\n     * @param dstHeight expected output bitmap height\n     * @return A Bitmap containing a representative video frame, which can be null,\n     *         if such a frame cannot be retrieved. {@link Bitmap#getConfig()} can\n     *         be used to query the actual {@link Bitmap.Config}.\n     * @throws IllegalArgumentException if passed in invalid option or width by height\n     *         is less than or equal to 0.\n     * @see #getScaledFrameAtTime(long, int, int, int, BitmapParams)\n     ",
    "links" : [ "android.graphics.Bitmap#getConfig()", "#getScaledFrameAtTime(long", "#OPTION_NEXT_SYNC", "#OPTION_CLOSEST", "#OPTION_CLOSEST_SYNC", "Bitmap.Config", "#OPTION_PREVIOUS_SYNC" ]
  }, {
    "name" : "public Bitmap getScaledFrameAtTime(long timeUs, @Option int option, @IntRange(from = 1) int dstWidth, @IntRange(from = 1) int dstHeight, @NonNull BitmapParams params)",
    "returnType" : "Bitmap",
    "comment" : "\n     * Retrieve a video frame near a given timestamp scaled to a desired size.\n     * Call this method after setDataSource(). This method finds a representative\n     * frame close to the given time position by considering the given option\n     * if possible, and returns it as a bitmap with same aspect ratio as the source\n     * while scaling it so that it fits into the desired size of dst_width by dst_height.\n     * This is useful for generating a thumbnail for an input data source or just to\n     * obtain a scaled frame at the given time position.\n     *\n     * @param timeUs The time position in microseconds where the frame will be retrieved.\n     * When retrieving the frame at the given time position, there is no\n     * guarantee that the data source has a frame located at the position.\n     * When this happens, a frame nearby will be returned. If timeUs is\n     * negative, time position and option will ignored, and any frame\n     * that the implementation considers as representative may be returned.\n     *\n     * @param option a hint on how the frame is found. Use\n     * {@link #OPTION_PREVIOUS_SYNC} if one wants to retrieve a sync frame\n     * that has a timestamp earlier than or the same as timeUs. Use\n     * {@link #OPTION_NEXT_SYNC} if one wants to retrieve a sync frame\n     * that has a timestamp later than or the same as timeUs. Use\n     * {@link #OPTION_CLOSEST_SYNC} if one wants to retrieve a sync frame\n     * that has a timestamp closest to or the same as timeUs. Use\n     * {@link #OPTION_CLOSEST} if one wants to retrieve a frame that may\n     * or may not be a sync frame but is closest to or the same as timeUs.\n     * {@link #OPTION_CLOSEST} often has larger performance overhead compared\n     * to the other options if there is no sync frame located at timeUs.\n     *\n     * @param dstWidth expected output bitmap width\n     * @param dstHeight expected output bitmap height\n     * @param params BitmapParams that controls the returned bitmap config\n     *        (such as pixel formats).\n     *\n     * @return A Bitmap of size not larger than dstWidth by dstHeight containing a\n     *         scaled video frame, which can be null, if such a frame cannot be retrieved.\n     * @throws IllegalArgumentException if passed in invalid option or width by height\n     *         is less than or equal to 0.\n     * @see #getScaledFrameAtTime(long, int, int, int)\n     ",
    "links" : [ "#OPTION_NEXT_SYNC", "#OPTION_CLOSEST", "#OPTION_CLOSEST_SYNC", "#OPTION_PREVIOUS_SYNC" ]
  }, {
    "name" : "private void validate(@Option int option, int dstWidth, int dstHeight)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Bitmap getFrameAtTime(long timeUs)",
    "returnType" : "Bitmap",
    "comment" : "\n     * Call this method after setDataSource(). This method finds a\n     * representative frame close to the given time position if possible,\n     * and returns it as a bitmap. Call this method if one does not care\n     * how the frame is found as long as it is close to the given time;\n     * otherwise, please call {@link #getFrameAtTime(long, int)}.\n     *\n     * <p>If you don't need a full-resolution\n     * frame (for example, because you need a thumbnail image), use\n     * {@link #getScaledFrameAtTime getScaledFrameAtTime()} instead of this\n     * method.</p>\n     *\n     * @param timeUs The time position where the frame will be retrieved.\n     * When retrieving the frame at the given time position, there is no\n     * guarentee that the data source has a frame located at the position.\n     * When this happens, a frame nearby will be returned. If timeUs is\n     * negative, time position and option will ignored, and any frame\n     * that the implementation considers as representative may be returned.\n     *\n     * @return A Bitmap of size dst_widthxdst_height containing a representative\n     *         video frame, which can be null, if such a frame cannot be retrieved.\n     *\n     * @see #getFrameAtTime(long, int)\n     ",
    "links" : [ "#getScaledFrameAtTime", "#getFrameAtTime(long" ]
  }, {
    "name" : "public Bitmap getFrameAtTime()",
    "returnType" : "Bitmap",
    "comment" : "\n     * Call this method after setDataSource(). This method finds a\n     * representative frame at any time position if possible,\n     * and returns it as a bitmap. Call this method if one does not\n     * care about where the frame is located; otherwise, please call\n     * {@link #getFrameAtTime(long)} or {@link #getFrameAtTime(long, int)}\n     *\n     * <p>If you don't need a full-resolution\n     * frame (for example, because you need a thumbnail image), use\n     * {@link #getScaledFrameAtTime getScaledFrameAtTime()} instead of this\n     * method.</p>\n     *\n     * @return A Bitmap containing a representative video frame, which\n     *         can be null, if such a frame cannot be retrieved.\n     *\n     * @see #getFrameAtTime(long)\n     * @see #getFrameAtTime(long, int)\n     ",
    "links" : [ "#getFrameAtTime(long)", "#getScaledFrameAtTime", "#getFrameAtTime(long" ]
  }, {
    "name" : "private native Bitmap _getFrameAtTime(long timeUs, int option, int width, int height, @Nullable BitmapParams params)",
    "returnType" : "Bitmap",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Bitmap getFrameAtIndex(int frameIndex, @NonNull BitmapParams params)",
    "returnType" : "Bitmap",
    "comment" : "\n     * This method retrieves a video frame by its index. It should only be called\n     * after {@link #setDataSource}.\n     *\n     * After the bitmap is returned, you can query the actual parameters that were\n     * used to create the bitmap from the {@code BitmapParams} argument, for instance\n     * to query the bitmap config used for the bitmap with {@link BitmapParams#getActualConfig}.\n     *\n     * @param frameIndex 0-based index of the video frame. The frame index must be that of\n     *        a valid frame. The total number of frames available for retrieval can be queried\n     *        via the {@link #METADATA_KEY_VIDEO_FRAME_COUNT} key.\n     * @param params BitmapParams that controls the returned bitmap config (such as pixel formats).\n     *\n     * @throws IllegalStateException if the container doesn't contain video or image sequences.\n     * @throws IllegalArgumentException if the requested frame index does not exist.\n     *\n     * @return A Bitmap containing the requested video frame, or null if the retrieval fails.\n     *\n     * @see #getFrameAtIndex(int)\n     * @see #getFramesAtIndex(int, int, BitmapParams)\n     * @see #getFramesAtIndex(int, int)\n     ",
    "links" : [ "#METADATA_KEY_VIDEO_FRAME_COUNT", "#getActualConfig", "#setDataSource" ]
  }, {
    "name" : "public Bitmap getFrameAtIndex(int frameIndex)",
    "returnType" : "Bitmap",
    "comment" : "\n     * This method is similar to {@link #getFrameAtIndex(int, BitmapParams)} except that\n     * the default for {@link BitmapParams} will be used.\n     *\n     * @param frameIndex 0-based index of the video frame. The frame index must be that of\n     *        a valid frame. The total number of frames available for retrieval can be queried\n     *        via the {@link #METADATA_KEY_VIDEO_FRAME_COUNT} key.\n     *\n     * @throws IllegalStateException if the container doesn't contain video or image sequences.\n     * @throws IllegalArgumentException if the requested frame index does not exist.\n     *\n     * @return A Bitmap containing the requested video frame, or null if the retrieval fails.\n     *\n     * @see #getFrameAtIndex(int, BitmapParams)\n     * @see #getFramesAtIndex(int, int, BitmapParams)\n     * @see #getFramesAtIndex(int, int)\n     ",
    "links" : [ "BitmapParams", "#getFrameAtIndex(int", "#METADATA_KEY_VIDEO_FRAME_COUNT" ]
  }, {
    "name" : "public List<Bitmap> getFramesAtIndex(int frameIndex, int numFrames, @NonNull BitmapParams params)",
    "returnType" : "List<Bitmap>",
    "comment" : "\n     * This method retrieves a consecutive set of video frames starting at the\n     * specified index. It should only be called after {@link #setDataSource}.\n     *\n     * If the caller intends to retrieve more than one consecutive video frames,\n     * this method is preferred over {@link #getFrameAtIndex(int, BitmapParams)} for efficiency.\n     *\n     * After the bitmaps are returned, you can query the actual parameters that were\n     * used to create the bitmaps from the {@code BitmapParams} argument, for instance\n     * to query the bitmap config used for the bitmaps with {@link BitmapParams#getActualConfig}.\n     *\n     * @param frameIndex 0-based index of the first video frame to retrieve. The frame index\n     *        must be that of a valid frame. The total number of frames available for retrieval\n     *        can be queried via the {@link #METADATA_KEY_VIDEO_FRAME_COUNT} key.\n     * @param numFrames number of consecutive video frames to retrieve. Must be a positive\n     *        value. The stream must contain at least numFrames frames starting at frameIndex.\n     * @param params BitmapParams that controls the returned bitmap config (such as pixel formats).\n     *\n     * @throws IllegalStateException if the container doesn't contain video or image sequences.\n     * @throws IllegalArgumentException if the frameIndex or numFrames is invalid, or the\n     *         stream doesn't contain at least numFrames starting at frameIndex.\n\n     * @return An list of Bitmaps containing the requested video frames. The returned\n     *         array could contain less frames than requested if the retrieval fails.\n     *\n     * @see #getFrameAtIndex(int, BitmapParams)\n     * @see #getFrameAtIndex(int)\n     * @see #getFramesAtIndex(int, int)\n     ",
    "links" : [ "#getFrameAtIndex(int", "#METADATA_KEY_VIDEO_FRAME_COUNT", "#getActualConfig", "#setDataSource" ]
  }, {
    "name" : "public List<Bitmap> getFramesAtIndex(int frameIndex, int numFrames)",
    "returnType" : "List<Bitmap>",
    "comment" : "\n     * This method is similar to {@link #getFramesAtIndex(int, int, BitmapParams)} except that\n     * the default for {@link BitmapParams} will be used.\n     *\n     * @param frameIndex 0-based index of the first video frame to retrieve. The frame index\n     *        must be that of a valid frame. The total number of frames available for retrieval\n     *        can be queried via the {@link #METADATA_KEY_VIDEO_FRAME_COUNT} key.\n     * @param numFrames number of consecutive video frames to retrieve. Must be a positive\n     *        value. The stream must contain at least numFrames frames starting at frameIndex.\n     *\n     * @throws IllegalStateException if the container doesn't contain video or image sequences.\n     * @throws IllegalArgumentException if the frameIndex or numFrames is invalid, or the\n     *         stream doesn't contain at least numFrames starting at frameIndex.\n\n     * @return An list of Bitmaps containing the requested video frames. The returned\n     *         array could contain less frames than requested if the retrieval fails.\n     *\n     * @see #getFrameAtIndex(int, BitmapParams)\n     * @see #getFrameAtIndex(int)\n     * @see #getFramesAtIndex(int, int, BitmapParams)\n     ",
    "links" : [ "BitmapParams", "#METADATA_KEY_VIDEO_FRAME_COUNT", "#getFramesAtIndex(int" ]
  }, {
    "name" : "private List<Bitmap> getFramesAtIndexInternal(int frameIndex, int numFrames, @Nullable BitmapParams params)",
    "returnType" : "List<Bitmap>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native List<Bitmap> _getFrameAtIndex(int frameIndex, int numFrames, @Nullable BitmapParams params)",
    "returnType" : "List<Bitmap>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Bitmap getImageAtIndex(int imageIndex, @NonNull BitmapParams params)",
    "returnType" : "Bitmap",
    "comment" : "\n     * This method retrieves a still image by its index. It should only be called\n     * after {@link #setDataSource}.\n     *\n     * After the bitmap is returned, you can query the actual parameters that were\n     * used to create the bitmap from the {@code BitmapParams} argument, for instance\n     * to query the bitmap config used for the bitmap with {@link BitmapParams#getActualConfig}.\n     *\n     * @param imageIndex 0-based index of the image.\n     * @param params BitmapParams that controls the returned bitmap config (such as pixel formats).\n     *\n     * @throws IllegalStateException if the container doesn't contain still images.\n     * @throws IllegalArgumentException if the requested image does not exist.\n     *\n     * @return the requested still image, or null if the image cannot be retrieved.\n     *\n     * @see #getImageAtIndex(int)\n     * @see #getPrimaryImage(BitmapParams)\n     * @see #getPrimaryImage()\n     ",
    "links" : [ "#getActualConfig", "#setDataSource" ]
  }, {
    "name" : "public native Bitmap getThumbnailImageAtIndex(int imageIndex, @NonNull BitmapParams params, int targetSize, int maxPixels)",
    "returnType" : "Bitmap",
    "comment" : "\n     * @hide\n     *\n     * This method retrieves the thumbnail image for a still image if it's available.\n     * It should only be called after {@link #setDataSource}.\n     *\n     * @param imageIndex 0-based index of the image, negative value indicates primary image.\n     * @param params BitmapParams that controls the returned bitmap config (such as pixel formats).\n     * @param targetSize intended size of one edge (wdith or height) of the thumbnail,\n     *                   this is a heuristic for the framework to decide whether the embedded\n     *                   thumbnail should be used.\n     * @param maxPixels maximum pixels of thumbnail, this is a heuristic for the frameowrk to\n     *                  decide whehther the embedded thumnbail (or a downscaled version of it)\n     *                  should be used.\n     * @return the retrieved thumbnail, or null if no suitable thumbnail is available.\n     ",
    "links" : [ "#setDataSource" ]
  }, {
    "name" : "public Bitmap getImageAtIndex(int imageIndex)",
    "returnType" : "Bitmap",
    "comment" : "\n     * This method is similar to {@link #getImageAtIndex(int, BitmapParams)} except that\n     * the default for {@link BitmapParams} will be used.\n     *\n     * @param imageIndex 0-based index of the image.\n     *\n     * @throws IllegalStateException if the container doesn't contain still images.\n     * @throws IllegalArgumentException if the requested image does not exist.\n     *\n     * @return the requested still image, or null if the image cannot be retrieved.\n     *\n     * @see #getImageAtIndex(int, BitmapParams)\n     * @see #getPrimaryImage(BitmapParams)\n     * @see #getPrimaryImage()\n     ",
    "links" : [ "BitmapParams", "#getImageAtIndex(int" ]
  }, {
    "name" : "public Bitmap getPrimaryImage(@NonNull BitmapParams params)",
    "returnType" : "Bitmap",
    "comment" : "\n     * This method retrieves the primary image of the media content. It should only\n     * be called after {@link #setDataSource}.\n     *\n     * After the bitmap is returned, you can query the actual parameters that were\n     * used to create the bitmap from the {@code BitmapParams} argument, for instance\n     * to query the bitmap config used for the bitmap with {@link BitmapParams#getActualConfig}.\n     *\n     * @param params BitmapParams that controls the returned bitmap config (such as pixel formats).\n     *\n     * @return the primary image, or null if it cannot be retrieved.\n     *\n     * @throws IllegalStateException if the container doesn't contain still images.\n     *\n     * @see #getImageAtIndex(int, BitmapParams)\n     * @see #getImageAtIndex(int)\n     * @see #getPrimaryImage()\n     ",
    "links" : [ "#getActualConfig", "#setDataSource" ]
  }, {
    "name" : "public Bitmap getPrimaryImage()",
    "returnType" : "Bitmap",
    "comment" : "\n     * This method is similar to {@link #getPrimaryImage(BitmapParams)} except that\n     * the default for {@link BitmapParams} will be used.\n     *\n     * @return the primary image, or null if it cannot be retrieved.\n     *\n     * @throws IllegalStateException if the container doesn't contain still images.\n     *\n     * @see #getImageAtIndex(int, BitmapParams)\n     * @see #getImageAtIndex(int)\n     * @see #getPrimaryImage(BitmapParams)\n     ",
    "links" : [ "#getPrimaryImage(BitmapParams)", "BitmapParams" ]
  }, {
    "name" : "private Bitmap getImageAtIndexInternal(int imageIndex, @Nullable BitmapParams params)",
    "returnType" : "Bitmap",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native Bitmap _getImageAtIndex(int imageIndex, @Nullable BitmapParams params)",
    "returnType" : "Bitmap",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public byte[] getEmbeddedPicture()",
    "returnType" : "byte[]",
    "comment" : "\n     * Call this method after setDataSource(). This method finds the optional\n     * graphic or album/cover art associated associated with the data source. If\n     * there are more than one pictures, (any) one of them is returned.\n     *\n     * @return null if no such graphic is found.\n     ",
    "links" : [ ]
  }, {
    "name" : "private native byte[] getEmbeddedPicture(int pictureType)",
    "returnType" : "byte[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void close() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Releases any acquired resources. Call it when done with the object.\n     *\n     * @throws IOException When an {@link IOException} is thrown while closing a {@link\n     * MediaDataSource} passed to {@link #setDataSource(MediaDataSource)}. This throws clause exists\n     * since API {@link android.os.Build.VERSION_CODES#TIRAMISU}, but this method can throw in\n     * earlier API versions where the exception is not declared.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#TIRAMISU", "android.media.MediaDataSource", "#setDataSource(MediaDataSource)", "java.io.IOException" ]
  }, {
    "name" : "public native void release() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Releases any acquired resources. Call it when done with the object.\n     *\n     * @throws IOException When an {@link IOException} is thrown while closing a {@link\n     * MediaDataSource} passed to {@link #setDataSource(MediaDataSource)}. This throws clause exists\n     * since API {@link android.os.Build.VERSION_CODES#TIRAMISU}, but this method can throw in\n     * earlier API versions where the exception is not declared.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#TIRAMISU", "android.media.MediaDataSource", "#setDataSource(MediaDataSource)", "java.io.IOException" ]
  }, {
    "name" : "private native void native_setup()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void native_init()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native void native_finalize()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void finalize() throws Throwable",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ "public void setDataSource(String path) throws IllegalArgumentException", "public void setDataSource(String uri, Map<String, String> headers) throws IllegalArgumentException", "private native void _setDataSource(IBinder httpServiceBinder, String uri, String[] keys, String[] values) throws IllegalArgumentException", "public void setDataSource(FileDescriptor fd, long offset, long length) throws IllegalArgumentException", "private native void _setDataSource(FileDescriptor fd, long offset, long length) throws IllegalArgumentException", "public void setDataSource(FileDescriptor fd) throws IllegalArgumentException", "public void setDataSource(Context context, Uri uri) throws IllegalArgumentException, SecurityException", "public void setDataSource(MediaDataSource dataSource) throws IllegalArgumentException", "private native void _setDataSource(MediaDataSource dataSource) throws IllegalArgumentException", "private native String nativeExtractMetadata(int keyCode)", "public String extractMetadata(int keyCode)", "private String convertGenreTag(String meta)", "public Bitmap getFrameAtTime(long timeUs, @Option int option)", "public Bitmap getFrameAtTime(long timeUs, @Option int option, @NonNull BitmapParams params)", "public Bitmap getScaledFrameAtTime(long timeUs, @Option int option, @IntRange(from = 1) int dstWidth, @IntRange(from = 1) int dstHeight)", "public Bitmap getScaledFrameAtTime(long timeUs, @Option int option, @IntRange(from = 1) int dstWidth, @IntRange(from = 1) int dstHeight, @NonNull BitmapParams params)", "private void validate(@Option int option, int dstWidth, int dstHeight)", "public Bitmap getFrameAtTime(long timeUs)", "public Bitmap getFrameAtTime()", "private native Bitmap _getFrameAtTime(long timeUs, int option, int width, int height, @Nullable BitmapParams params)", "public Bitmap getFrameAtIndex(int frameIndex, @NonNull BitmapParams params)", "public Bitmap getFrameAtIndex(int frameIndex)", "public List<Bitmap> getFramesAtIndex(int frameIndex, int numFrames, @NonNull BitmapParams params)", "public List<Bitmap> getFramesAtIndex(int frameIndex, int numFrames)", "private List<Bitmap> getFramesAtIndexInternal(int frameIndex, int numFrames, @Nullable BitmapParams params)", "private native List<Bitmap> _getFrameAtIndex(int frameIndex, int numFrames, @Nullable BitmapParams params)", "public Bitmap getImageAtIndex(int imageIndex, @NonNull BitmapParams params)", "public native Bitmap getThumbnailImageAtIndex(int imageIndex, @NonNull BitmapParams params, int targetSize, int maxPixels)", "public Bitmap getImageAtIndex(int imageIndex)", "public Bitmap getPrimaryImage(@NonNull BitmapParams params)", "public Bitmap getPrimaryImage()", "private Bitmap getImageAtIndexInternal(int imageIndex, @Nullable BitmapParams params)", "private native Bitmap _getImageAtIndex(int imageIndex, @Nullable BitmapParams params)", "public byte[] getEmbeddedPicture()", "private native byte[] getEmbeddedPicture(int pictureType)", "public void close() throws IOException", "public native void release() throws IOException", "private native void native_setup()", "private static native void native_init()", "private final native void native_finalize()", "protected void finalize() throws Throwable" ],
  "variableNames" : [ "TAG", "STANDARD_GENRES", "mNativeContext", "EMBEDDED_PICTURE_TYPE_ANY", "OPTION_PREVIOUS_SYNC", "OPTION_NEXT_SYNC", "OPTION_CLOSEST_SYNC", "OPTION_CLOSEST", "METADATA_KEY_CD_TRACK_NUMBER", "METADATA_KEY_ALBUM", "METADATA_KEY_ARTIST", "METADATA_KEY_AUTHOR", "METADATA_KEY_COMPOSER", "METADATA_KEY_DATE", "METADATA_KEY_GENRE", "METADATA_KEY_TITLE", "METADATA_KEY_YEAR", "METADATA_KEY_DURATION", "METADATA_KEY_NUM_TRACKS", "METADATA_KEY_WRITER", "METADATA_KEY_MIMETYPE", "METADATA_KEY_ALBUMARTIST", "METADATA_KEY_DISC_NUMBER", "METADATA_KEY_COMPILATION", "METADATA_KEY_HAS_AUDIO", "METADATA_KEY_HAS_VIDEO", "METADATA_KEY_VIDEO_WIDTH", "METADATA_KEY_VIDEO_HEIGHT", "METADATA_KEY_BITRATE", "METADATA_KEY_TIMED_TEXT_LANGUAGES", "METADATA_KEY_IS_DRM", "METADATA_KEY_LOCATION", "METADATA_KEY_VIDEO_ROTATION", "METADATA_KEY_CAPTURE_FRAMERATE", "METADATA_KEY_HAS_IMAGE", "METADATA_KEY_IMAGE_COUNT", "METADATA_KEY_IMAGE_PRIMARY", "METADATA_KEY_IMAGE_WIDTH", "METADATA_KEY_IMAGE_HEIGHT", "METADATA_KEY_IMAGE_ROTATION", "METADATA_KEY_VIDEO_FRAME_COUNT", "METADATA_KEY_EXIF_OFFSET", "METADATA_KEY_EXIF_LENGTH", "METADATA_KEY_COLOR_STANDARD", "METADATA_KEY_COLOR_TRANSFER", "METADATA_KEY_COLOR_RANGE", "METADATA_KEY_SAMPLERATE", "METADATA_KEY_BITS_PER_SAMPLE", "METADATA_KEY_VIDEO_CODEC_MIME_TYPE", "METADATA_KEY_XMP_OFFSET", "METADATA_KEY_XMP_LENGTH" ]
}