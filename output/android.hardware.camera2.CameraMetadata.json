{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/hardware/camera2/CameraMetadata.java",
  "packageName" : "android.hardware.camera2",
  "className" : "CameraMetadata",
  "comment" : "\n * The base class for camera controls and information.\n *\n * <p>\n * This class defines the basic key/value map used for querying for camera\n * characteristics or capture results, and for setting camera request\n * parameters.\n * </p>\n *\n * <p>\n * All instances of CameraMetadata are immutable. Beginning with API level 32, the list of keys\n * returned by {@link #getKeys()} may change depending on the state of the device, as may the\n * values returned by any key with {@code #get} throughout the lifetime of the object. For\n * information on whether a specific value is fixed, see the documentation for its key.\n * </p>\n *\n * @see CameraDevice\n * @see CameraManager\n * @see CameraCharacteristics\n *",
  "links" : [ "#getKeys()" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mNativeInstance",
    "type" : "CameraMetadataNative",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LENS_INFO_FOCUS_DISTANCE_CALIBRATION_UNCALIBRATED",
    "type" : "int",
    "comment" : "\n     * <p>The lens focus distance is not accurate, and the units used for\n     * {@link CaptureRequest#LENS_FOCUS_DISTANCE android.lens.focusDistance} do not correspond to any physical units.</p>\n     * <p>Setting the lens to the same focus distance on separate occasions may\n     * result in a different real focus distance, depending on factors such\n     * as the orientation of the device, the age of the focusing mechanism,\n     * and the device temperature. The focus distance value will still be\n     * in the range of <code>[0, {@link CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE android.lens.info.minimumFocusDistance}]</code>, where 0\n     * represents the farthest focus.</p>\n     *\n     * @see CaptureRequest#LENS_FOCUS_DISTANCE\n     * @see CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE\n     * @see CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE", "android.hardware.camera2.CaptureRequest#LENS_FOCUS_DISTANCE" ]
  }, {
    "name" : "LENS_INFO_FOCUS_DISTANCE_CALIBRATION_APPROXIMATE",
    "type" : "int",
    "comment" : "\n     * <p>The lens focus distance is measured in diopters.</p>\n     * <p>However, setting the lens to the same focus distance\n     * on separate occasions may result in a different real\n     * focus distance, depending on factors such as the\n     * orientation of the device, the age of the focusing\n     * mechanism, and the device temperature.</p>\n     * @see CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION\n     ",
    "links" : [ ]
  }, {
    "name" : "LENS_INFO_FOCUS_DISTANCE_CALIBRATION_CALIBRATED",
    "type" : "int",
    "comment" : "\n     * <p>The lens focus distance is measured in diopters, and\n     * is calibrated.</p>\n     * <p>The lens mechanism is calibrated so that setting the\n     * same focus distance is repeatable on multiple\n     * occasions with good accuracy, and the focus distance\n     * corresponds to the real physical distance to the plane\n     * of best focus.</p>\n     * @see CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION\n     ",
    "links" : [ ]
  }, {
    "name" : "LENS_FACING_FRONT",
    "type" : "int",
    "comment" : "\n     * <p>The camera device faces the same direction as the device's screen.</p>\n     * @see CameraCharacteristics#LENS_FACING\n     ",
    "links" : [ ]
  }, {
    "name" : "LENS_FACING_BACK",
    "type" : "int",
    "comment" : "\n     * <p>The camera device faces the opposite direction as the device's screen.</p>\n     * @see CameraCharacteristics#LENS_FACING\n     ",
    "links" : [ ]
  }, {
    "name" : "LENS_FACING_EXTERNAL",
    "type" : "int",
    "comment" : "\n     * <p>The camera device is an external camera, and has no fixed facing relative to the\n     * device's screen.</p>\n     * @see CameraCharacteristics#LENS_FACING\n     ",
    "links" : [ ]
  }, {
    "name" : "LENS_POSE_REFERENCE_PRIMARY_CAMERA",
    "type" : "int",
    "comment" : "\n     * <p>The value of {@link CameraCharacteristics#LENS_POSE_TRANSLATION android.lens.poseTranslation} is relative to the optical center of\n     * the largest camera device facing the same direction as this camera.</p>\n     * <p>This is the default value for API levels before Android P.</p>\n     *\n     * @see CameraCharacteristics#LENS_POSE_TRANSLATION\n     * @see CameraCharacteristics#LENS_POSE_REFERENCE\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#LENS_POSE_TRANSLATION" ]
  }, {
    "name" : "LENS_POSE_REFERENCE_GYROSCOPE",
    "type" : "int",
    "comment" : "\n     * <p>The value of {@link CameraCharacteristics#LENS_POSE_TRANSLATION android.lens.poseTranslation} is relative to the position of the\n     * primary gyroscope of this Android device.</p>\n     *\n     * @see CameraCharacteristics#LENS_POSE_TRANSLATION\n     * @see CameraCharacteristics#LENS_POSE_REFERENCE\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#LENS_POSE_TRANSLATION" ]
  }, {
    "name" : "LENS_POSE_REFERENCE_UNDEFINED",
    "type" : "int",
    "comment" : "\n     * <p>The camera device cannot represent the values of {@link CameraCharacteristics#LENS_POSE_TRANSLATION android.lens.poseTranslation}\n     * and {@link CameraCharacteristics#LENS_POSE_ROTATION android.lens.poseRotation} accurately enough. One such example is a camera device\n     * on the cover of a foldable phone: in order to measure the pose translation and rotation,\n     * some kind of hinge position sensor would be needed.</p>\n     * <p>The value of {@link CameraCharacteristics#LENS_POSE_TRANSLATION android.lens.poseTranslation} must be all zeros, and\n     * {@link CameraCharacteristics#LENS_POSE_ROTATION android.lens.poseRotation} must be values matching its default facing.</p>\n     *\n     * @see CameraCharacteristics#LENS_POSE_ROTATION\n     * @see CameraCharacteristics#LENS_POSE_TRANSLATION\n     * @see CameraCharacteristics#LENS_POSE_REFERENCE\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#LENS_POSE_ROTATION", "android.hardware.camera2.CameraCharacteristics#LENS_POSE_TRANSLATION" ]
  }, {
    "name" : "LENS_POSE_REFERENCE_AUTOMOTIVE",
    "type" : "int",
    "comment" : "\n     * <p>The value of {@link CameraCharacteristics#LENS_POSE_TRANSLATION android.lens.poseTranslation} is relative to the origin of the\n     * automotive sensor coordinate system, which is at the center of the rear axle.</p>\n     *\n     * @see CameraCharacteristics#LENS_POSE_TRANSLATION\n     * @see CameraCharacteristics#LENS_POSE_REFERENCE\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#LENS_POSE_TRANSLATION" ]
  }, {
    "name" : "REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE",
    "type" : "int",
    "comment" : "\n     * <p>The minimal set of capabilities that every camera\n     * device (regardless of {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel})\n     * supports.</p>\n     * <p>This capability is listed by all normal devices, and\n     * indicates that the camera device has a feature set\n     * that's comparable to the baseline requirements for the\n     * older android.hardware.Camera API.</p>\n     * <p>Devices with the DEPTH_OUTPUT capability might not list this\n     * capability, indicating that they support only depth measurement,\n     * not standard color output.</p>\n     *\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL" ]
  }, {
    "name" : "REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR",
    "type" : "int",
    "comment" : "\n     * <p>The camera device can be manually controlled (3A algorithms such\n     * as auto-exposure, and auto-focus can be bypassed).\n     * The camera device supports basic manual control of the sensor image\n     * acquisition related stages. This means the following controls are\n     * guaranteed to be supported:</p>\n     * <ul>\n     * <li>Manual frame duration control<ul>\n     * <li>{@link CaptureRequest#SENSOR_FRAME_DURATION android.sensor.frameDuration}</li>\n     * <li>{@link CameraCharacteristics#SENSOR_INFO_MAX_FRAME_DURATION android.sensor.info.maxFrameDuration}</li>\n     * </ul>\n     * </li>\n     * <li>Manual exposure control<ul>\n     * <li>{@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime}</li>\n     * <li>{@link CameraCharacteristics#SENSOR_INFO_EXPOSURE_TIME_RANGE android.sensor.info.exposureTimeRange}</li>\n     * </ul>\n     * </li>\n     * <li>Manual sensitivity control<ul>\n     * <li>{@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}</li>\n     * <li>{@link CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE android.sensor.info.sensitivityRange}</li>\n     * </ul>\n     * </li>\n     * <li>Manual lens control (if the lens is adjustable)<ul>\n     * <li>android.lens.*</li>\n     * </ul>\n     * </li>\n     * <li>Manual flash control (if a flash unit is present)<ul>\n     * <li>android.flash.*</li>\n     * </ul>\n     * </li>\n     * <li>Manual black level locking<ul>\n     * <li>{@link CaptureRequest#BLACK_LEVEL_LOCK android.blackLevel.lock}</li>\n     * </ul>\n     * </li>\n     * <li>Auto exposure lock<ul>\n     * <li>{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock}</li>\n     * </ul>\n     * </li>\n     * </ul>\n     * <p>If any of the above 3A algorithms are enabled, then the camera\n     * device will accurately report the values applied by 3A in the\n     * result.</p>\n     * <p>A given camera device may also support additional manual sensor controls,\n     * but this capability only covers the above list of controls.</p>\n     * <p>If this is supported, {@link CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP android.scaler.streamConfigurationMap} will\n     * additionally return a min frame duration that is greater than\n     * zero for each supported size-format combination.</p>\n     * <p>For camera devices with LOGICAL_MULTI_CAMERA capability, when the underlying active\n     * physical camera switches, exposureTime, sensitivity, and lens properties may change\n     * even if AE/AF is locked. However, the overall auto exposure and auto focus experience\n     * for users will be consistent. Refer to LOGICAL_MULTI_CAMERA capability for details.</p>\n     *\n     * @see CaptureRequest#BLACK_LEVEL_LOCK\n     * @see CaptureRequest#CONTROL_AE_LOCK\n     * @see CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP\n     * @see CaptureRequest#SENSOR_EXPOSURE_TIME\n     * @see CaptureRequest#SENSOR_FRAME_DURATION\n     * @see CameraCharacteristics#SENSOR_INFO_EXPOSURE_TIME_RANGE\n     * @see CameraCharacteristics#SENSOR_INFO_MAX_FRAME_DURATION\n     * @see CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE\n     * @see CaptureRequest#SENSOR_SENSITIVITY\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#SENSOR_SENSITIVITY", "android.hardware.camera2.CaptureRequest#SENSOR_FRAME_DURATION", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_MAX_FRAME_DURATION", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE", "android.hardware.camera2.CaptureRequest#CONTROL_AE_LOCK", "android.hardware.camera2.CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP", "android.hardware.camera2.CaptureRequest#SENSOR_EXPOSURE_TIME", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_EXPOSURE_TIME_RANGE", "android.hardware.camera2.CaptureRequest#BLACK_LEVEL_LOCK" ]
  }, {
    "name" : "REQUEST_AVAILABLE_CAPABILITIES_MANUAL_POST_PROCESSING",
    "type" : "int",
    "comment" : "\n     * <p>The camera device post-processing stages can be manually controlled.\n     * The camera device supports basic manual control of the image post-processing\n     * stages. This means the following controls are guaranteed to be supported:</p>\n     * <ul>\n     * <li>\n     * <p>Manual tonemap control</p>\n     * <ul>\n     * <li>{@link CaptureRequest#TONEMAP_CURVE android.tonemap.curve}</li>\n     * <li>{@link CaptureRequest#TONEMAP_MODE android.tonemap.mode}</li>\n     * <li>{@link CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS android.tonemap.maxCurvePoints}</li>\n     * <li>{@link CaptureRequest#TONEMAP_GAMMA android.tonemap.gamma}</li>\n     * <li>{@link CaptureRequest#TONEMAP_PRESET_CURVE android.tonemap.presetCurve}</li>\n     * </ul>\n     * </li>\n     * <li>\n     * <p>Manual white balance control</p>\n     * <ul>\n     * <li>{@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}</li>\n     * <li>{@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains}</li>\n     * </ul>\n     * </li>\n     * <li>Manual lens shading map control<ul>\n     * <li>{@link CaptureRequest#SHADING_MODE android.shading.mode}</li>\n     * <li>{@link CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE android.statistics.lensShadingMapMode}</li>\n     * <li>android.statistics.lensShadingMap</li>\n     * <li>android.lens.info.shadingMapSize</li>\n     * </ul>\n     * </li>\n     * <li>Manual aberration correction control (if aberration correction is supported)<ul>\n     * <li>{@link CaptureRequest#COLOR_CORRECTION_ABERRATION_MODE android.colorCorrection.aberrationMode}</li>\n     * <li>{@link CameraCharacteristics#COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES android.colorCorrection.availableAberrationModes}</li>\n     * </ul>\n     * </li>\n     * <li>Auto white balance lock<ul>\n     * <li>{@link CaptureRequest#CONTROL_AWB_LOCK android.control.awbLock}</li>\n     * </ul>\n     * </li>\n     * </ul>\n     * <p>If auto white balance is enabled, then the camera device\n     * will accurately report the values applied by AWB in the result.</p>\n     * <p>A given camera device may also support additional post-processing\n     * controls, but this capability only covers the above list of controls.</p>\n     * <p>For camera devices with LOGICAL_MULTI_CAMERA capability, when underlying active\n     * physical camera switches, tonemap, white balance, and shading map may change even if\n     * awb is locked. However, the overall post-processing experience for users will be\n     * consistent. Refer to LOGICAL_MULTI_CAMERA capability for details.</p>\n     *\n     * @see CaptureRequest#COLOR_CORRECTION_ABERRATION_MODE\n     * @see CameraCharacteristics#COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES\n     * @see CaptureRequest#COLOR_CORRECTION_GAINS\n     * @see CaptureRequest#COLOR_CORRECTION_TRANSFORM\n     * @see CaptureRequest#CONTROL_AWB_LOCK\n     * @see CaptureRequest#SHADING_MODE\n     * @see CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE\n     * @see CaptureRequest#TONEMAP_CURVE\n     * @see CaptureRequest#TONEMAP_GAMMA\n     * @see CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS\n     * @see CaptureRequest#TONEMAP_MODE\n     * @see CaptureRequest#TONEMAP_PRESET_CURVE\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_ABERRATION_MODE", "android.hardware.camera2.CaptureRequest#TONEMAP_CURVE", "android.hardware.camera2.CaptureRequest#TONEMAP_PRESET_CURVE", "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_GAINS", "android.hardware.camera2.CaptureRequest#TONEMAP_GAMMA", "android.hardware.camera2.CaptureRequest#SHADING_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_AWB_LOCK", "android.hardware.camera2.CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE", "android.hardware.camera2.CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS", "android.hardware.camera2.CameraCharacteristics#COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES", "android.hardware.camera2.CaptureRequest#TONEMAP_MODE", "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_TRANSFORM" ]
  }, {
    "name" : "REQUEST_AVAILABLE_CAPABILITIES_RAW",
    "type" : "int",
    "comment" : "\n     * <p>The camera device supports outputting RAW buffers and\n     * metadata for interpreting them.</p>\n     * <p>Devices supporting the RAW capability allow both for\n     * saving DNG files, and for direct application processing of\n     * raw sensor images.</p>\n     * <ul>\n     * <li>RAW_SENSOR is supported as an output format.</li>\n     * <li>The maximum available resolution for RAW_SENSOR streams\n     *   will match either the value in\n     *   {@link CameraCharacteristics#SENSOR_INFO_PIXEL_ARRAY_SIZE android.sensor.info.pixelArraySize} or\n     *   {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}.</li>\n     * <li>All DNG-related optional metadata entries are provided\n     *   by the camera device.</li>\n     * </ul>\n     *\n     * @see CameraCharacteristics#SENSOR_INFO_PIXEL_ARRAY_SIZE\n     * @see CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_PIXEL_ARRAY_SIZE", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE" ]
  }, {
    "name" : "REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING",
    "type" : "int",
    "comment" : "\n     * <p>The camera device supports the Zero Shutter Lag reprocessing use case.</p>\n     * <ul>\n     * <li>One input stream is supported, that is, <code>{@link CameraCharacteristics#REQUEST_MAX_NUM_INPUT_STREAMS android.request.maxNumInputStreams} == 1</code>.</li>\n     * <li>{@link android.graphics.ImageFormat#PRIVATE } is supported as an output/input format,\n     *   that is, {@link android.graphics.ImageFormat#PRIVATE } is included in the lists of\n     *   formats returned by {@link android.hardware.camera2.params.StreamConfigurationMap#getInputFormats } and {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputFormats }.</li>\n     * <li>{@link android.hardware.camera2.params.StreamConfigurationMap#getValidOutputFormatsForInput }\n     *   returns non-empty int[] for each supported input format returned by {@link android.hardware.camera2.params.StreamConfigurationMap#getInputFormats }.</li>\n     * <li>Each size returned by {@link android.hardware.camera2.params.StreamConfigurationMap#getInputSizes getInputSizes(ImageFormat.PRIVATE)} is also included in {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputSizes getOutputSizes(ImageFormat.PRIVATE)}</li>\n     * <li>Using {@link android.graphics.ImageFormat#PRIVATE } does not cause a frame rate drop\n     *   relative to the sensor's maximum capture rate (at that resolution).</li>\n     * <li>{@link android.graphics.ImageFormat#PRIVATE } will be reprocessable into both\n     *   {@link android.graphics.ImageFormat#YUV_420_888 } and\n     *   {@link android.graphics.ImageFormat#JPEG } formats.</li>\n     * <li>For a MONOCHROME camera supporting Y8 format, {@link android.graphics.ImageFormat#PRIVATE } will be reprocessable into\n     *   {@link android.graphics.ImageFormat#Y8 }.</li>\n     * <li>The maximum available resolution for PRIVATE streams\n     *   (both input/output) will match the maximum available\n     *   resolution of JPEG streams.</li>\n     * <li>Static metadata {@link CameraCharacteristics#REPROCESS_MAX_CAPTURE_STALL android.reprocess.maxCaptureStall}.</li>\n     * <li>Only below controls are effective for reprocessing requests and\n     *   will be present in capture results, other controls in reprocess\n     *   requests will be ignored by the camera device.<ul>\n     * <li>android.jpeg.*</li>\n     * <li>{@link CaptureRequest#NOISE_REDUCTION_MODE android.noiseReduction.mode}</li>\n     * <li>{@link CaptureRequest#EDGE_MODE android.edge.mode}</li>\n     * </ul>\n     * </li>\n     * <li>{@link CameraCharacteristics#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES android.noiseReduction.availableNoiseReductionModes} and\n     *   {@link CameraCharacteristics#EDGE_AVAILABLE_EDGE_MODES android.edge.availableEdgeModes} will both list ZERO_SHUTTER_LAG as a supported mode.</li>\n     * </ul>\n     *\n     * @see CameraCharacteristics#EDGE_AVAILABLE_EDGE_MODES\n     * @see CaptureRequest#EDGE_MODE\n     * @see CameraCharacteristics#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES\n     * @see CaptureRequest#NOISE_REDUCTION_MODE\n     * @see CameraCharacteristics#REPROCESS_MAX_CAPTURE_STALL\n     * @see CameraCharacteristics#REQUEST_MAX_NUM_INPUT_STREAMS\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     ",
    "links" : [ "android.graphics.ImageFormat#JPEG", "android.hardware.camera2.CaptureRequest#NOISE_REDUCTION_MODE", "android.graphics.ImageFormat#Y8", "android.hardware.camera2.params.StreamConfigurationMap#getOutputSizes", "android.graphics.ImageFormat#YUV_420_888", "android.hardware.camera2.CameraCharacteristics#EDGE_AVAILABLE_EDGE_MODES", "android.hardware.camera2.params.StreamConfigurationMap#getValidOutputFormatsForInput", "android.hardware.camera2.params.StreamConfigurationMap#getInputFormats", "android.graphics.ImageFormat#PRIVATE", "android.hardware.camera2.CaptureRequest#EDGE_MODE", "android.hardware.camera2.CameraCharacteristics#REQUEST_MAX_NUM_INPUT_STREAMS", "android.hardware.camera2.params.StreamConfigurationMap#getInputSizes", "android.hardware.camera2.CameraCharacteristics#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES", "android.hardware.camera2.params.StreamConfigurationMap#getOutputFormats", "android.hardware.camera2.CameraCharacteristics#REPROCESS_MAX_CAPTURE_STALL" ]
  }, {
    "name" : "REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS",
    "type" : "int",
    "comment" : "\n     * <p>The camera device supports accurately reporting the sensor settings for many of\n     * the sensor controls while the built-in 3A algorithm is running.  This allows\n     * reporting of sensor settings even when these settings cannot be manually changed.</p>\n     * <p>The values reported for the following controls are guaranteed to be available\n     * in the CaptureResult, including when 3A is enabled:</p>\n     * <ul>\n     * <li>Exposure control<ul>\n     * <li>{@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime}</li>\n     * </ul>\n     * </li>\n     * <li>Sensitivity control<ul>\n     * <li>{@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}</li>\n     * </ul>\n     * </li>\n     * <li>Lens controls (if the lens is adjustable)<ul>\n     * <li>{@link CaptureRequest#LENS_FOCUS_DISTANCE android.lens.focusDistance}</li>\n     * <li>{@link CaptureRequest#LENS_APERTURE android.lens.aperture}</li>\n     * </ul>\n     * </li>\n     * </ul>\n     * <p>This capability is a subset of the MANUAL_SENSOR control capability, and will\n     * always be included if the MANUAL_SENSOR capability is available.</p>\n     *\n     * @see CaptureRequest#LENS_APERTURE\n     * @see CaptureRequest#LENS_FOCUS_DISTANCE\n     * @see CaptureRequest#SENSOR_EXPOSURE_TIME\n     * @see CaptureRequest#SENSOR_SENSITIVITY\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#SENSOR_SENSITIVITY", "android.hardware.camera2.CaptureRequest#LENS_APERTURE", "android.hardware.camera2.CaptureRequest#LENS_FOCUS_DISTANCE", "android.hardware.camera2.CaptureRequest#SENSOR_EXPOSURE_TIME" ]
  }, {
    "name" : "REQUEST_AVAILABLE_CAPABILITIES_BURST_CAPTURE",
    "type" : "int",
    "comment" : "\n     * <p>The camera device supports capturing high-resolution images at &gt;= 20 frames per\n     * second, in at least the uncompressed YUV format, when post-processing settings are\n     * set to FAST. Additionally, all image resolutions less than 24 megapixels can be\n     * captured at &gt;= 10 frames per second. Here, 'high resolution' means at least 8\n     * megapixels, or the maximum resolution of the device, whichever is smaller.</p>\n     * <p>More specifically, this means that a size matching the camera device's active array\n     * size is listed as a supported size for the {@link android.graphics.ImageFormat#YUV_420_888 } format in either {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputSizes } or {@link android.hardware.camera2.params.StreamConfigurationMap#getHighResolutionOutputSizes },\n     * with a minimum frame duration for that format and size of either &lt;= 1/20 s, or\n     * &lt;= 1/10 s if the image size is less than 24 megapixels, respectively; and\n     * the {@link CameraCharacteristics#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES android.control.aeAvailableTargetFpsRanges} entry lists at least one FPS range\n     * where the minimum FPS is &gt;= 1 / minimumFrameDuration for the maximum-size\n     * YUV_420_888 format.  If that maximum size is listed in {@link android.hardware.camera2.params.StreamConfigurationMap#getHighResolutionOutputSizes },\n     * then the list of resolutions for YUV_420_888 from {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputSizes } contains at\n     * least one resolution &gt;= 8 megapixels, with a minimum frame duration of &lt;= 1/20\n     * s.</p>\n     * <p>If the device supports the {@link android.graphics.ImageFormat#RAW10 }, {@link android.graphics.ImageFormat#RAW12 }, {@link android.graphics.ImageFormat#Y8 }, then those can also be\n     * captured at the same rate as the maximum-size YUV_420_888 resolution is.</p>\n     * <p>If the device supports the PRIVATE_REPROCESSING capability, then the same guarantees\n     * as for the YUV_420_888 format also apply to the {@link android.graphics.ImageFormat#PRIVATE } format.</p>\n     * <p>In addition, the {@link CameraCharacteristics#SYNC_MAX_LATENCY android.sync.maxLatency} field is guaranteed to have a value between 0\n     * and 4, inclusive. {@link CameraCharacteristics#CONTROL_AE_LOCK_AVAILABLE android.control.aeLockAvailable} and {@link CameraCharacteristics#CONTROL_AWB_LOCK_AVAILABLE android.control.awbLockAvailable}\n     * are also guaranteed to be <code>true</code> so burst capture with these two locks ON yields\n     * consistent image output.</p>\n     *\n     * @see CameraCharacteristics#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES\n     * @see CameraCharacteristics#CONTROL_AE_LOCK_AVAILABLE\n     * @see CameraCharacteristics#CONTROL_AWB_LOCK_AVAILABLE\n     * @see CameraCharacteristics#SYNC_MAX_LATENCY\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     ",
    "links" : [ "android.graphics.ImageFormat#PRIVATE", "android.graphics.ImageFormat#Y8", "android.hardware.camera2.CameraCharacteristics#CONTROL_AWB_LOCK_AVAILABLE", "android.hardware.camera2.params.StreamConfigurationMap#getOutputSizes", "android.graphics.ImageFormat#YUV_420_888", "android.hardware.camera2.params.StreamConfigurationMap#getHighResolutionOutputSizes", "android.hardware.camera2.CameraCharacteristics#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES", "android.graphics.ImageFormat#RAW12", "android.hardware.camera2.CameraCharacteristics#SYNC_MAX_LATENCY", "android.hardware.camera2.CameraCharacteristics#CONTROL_AE_LOCK_AVAILABLE", "android.graphics.ImageFormat#RAW10" ]
  }, {
    "name" : "REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING",
    "type" : "int",
    "comment" : "\n     * <p>The camera device supports the YUV_420_888 reprocessing use case, similar as\n     * PRIVATE_REPROCESSING, This capability requires the camera device to support the\n     * following:</p>\n     * <ul>\n     * <li>One input stream is supported, that is, <code>{@link CameraCharacteristics#REQUEST_MAX_NUM_INPUT_STREAMS android.request.maxNumInputStreams} == 1</code>.</li>\n     * <li>{@link android.graphics.ImageFormat#YUV_420_888 } is supported as an output/input\n     *   format, that is, YUV_420_888 is included in the lists of formats returned by {@link android.hardware.camera2.params.StreamConfigurationMap#getInputFormats } and {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputFormats }.</li>\n     * <li>{@link android.hardware.camera2.params.StreamConfigurationMap#getValidOutputFormatsForInput }\n     *   returns non-empty int[] for each supported input format returned by {@link android.hardware.camera2.params.StreamConfigurationMap#getInputFormats }.</li>\n     * <li>Each size returned by {@link android.hardware.camera2.params.StreamConfigurationMap#getInputSizes getInputSizes(YUV_420_888)} is also included in {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputSizes getOutputSizes(YUV_420_888)}</li>\n     * <li>Using {@link android.graphics.ImageFormat#YUV_420_888 } does not cause a frame rate\n     *   drop relative to the sensor's maximum capture rate (at that resolution).</li>\n     * <li>{@link android.graphics.ImageFormat#YUV_420_888 } will be reprocessable into both\n     *   {@link android.graphics.ImageFormat#YUV_420_888 } and {@link android.graphics.ImageFormat#JPEG } formats.</li>\n     * <li>The maximum available resolution for {@link android.graphics.ImageFormat#YUV_420_888 } streams (both input/output) will match the\n     *   maximum available resolution of {@link android.graphics.ImageFormat#JPEG } streams.</li>\n     * <li>For a MONOCHROME camera with Y8 format support, all the requirements mentioned\n     *   above for YUV_420_888 apply for Y8 format as well.</li>\n     * <li>Static metadata {@link CameraCharacteristics#REPROCESS_MAX_CAPTURE_STALL android.reprocess.maxCaptureStall}.</li>\n     * <li>Only the below controls are effective for reprocessing requests and will be present\n     *   in capture results. The reprocess requests are from the original capture results\n     *   that are associated with the intermediate {@link android.graphics.ImageFormat#YUV_420_888 } output buffers.  All other controls in the\n     *   reprocess requests will be ignored by the camera device.<ul>\n     * <li>android.jpeg.*</li>\n     * <li>{@link CaptureRequest#NOISE_REDUCTION_MODE android.noiseReduction.mode}</li>\n     * <li>{@link CaptureRequest#EDGE_MODE android.edge.mode}</li>\n     * <li>{@link CaptureRequest#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR android.reprocess.effectiveExposureFactor}</li>\n     * </ul>\n     * </li>\n     * <li>{@link CameraCharacteristics#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES android.noiseReduction.availableNoiseReductionModes} and\n     *   {@link CameraCharacteristics#EDGE_AVAILABLE_EDGE_MODES android.edge.availableEdgeModes} will both list ZERO_SHUTTER_LAG as a supported mode.</li>\n     * </ul>\n     *\n     * @see CameraCharacteristics#EDGE_AVAILABLE_EDGE_MODES\n     * @see CaptureRequest#EDGE_MODE\n     * @see CameraCharacteristics#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES\n     * @see CaptureRequest#NOISE_REDUCTION_MODE\n     * @see CaptureRequest#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR\n     * @see CameraCharacteristics#REPROCESS_MAX_CAPTURE_STALL\n     * @see CameraCharacteristics#REQUEST_MAX_NUM_INPUT_STREAMS\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     ",
    "links" : [ "android.graphics.ImageFormat#JPEG", "android.hardware.camera2.CaptureRequest#NOISE_REDUCTION_MODE", "android.hardware.camera2.params.StreamConfigurationMap#getOutputSizes", "android.graphics.ImageFormat#YUV_420_888", "android.hardware.camera2.CameraCharacteristics#EDGE_AVAILABLE_EDGE_MODES", "android.hardware.camera2.params.StreamConfigurationMap#getValidOutputFormatsForInput", "android.hardware.camera2.params.StreamConfigurationMap#getInputFormats", "android.hardware.camera2.CaptureRequest#EDGE_MODE", "android.hardware.camera2.CameraCharacteristics#REQUEST_MAX_NUM_INPUT_STREAMS", "android.hardware.camera2.params.StreamConfigurationMap#getInputSizes", "android.hardware.camera2.CameraCharacteristics#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES", "android.hardware.camera2.params.StreamConfigurationMap#getOutputFormats", "android.hardware.camera2.CameraCharacteristics#REPROCESS_MAX_CAPTURE_STALL", "android.hardware.camera2.CaptureRequest#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR" ]
  }, {
    "name" : "REQUEST_AVAILABLE_CAPABILITIES_DEPTH_OUTPUT",
    "type" : "int",
    "comment" : "\n     * <p>The camera device can produce depth measurements from its field of view.</p>\n     * <p>This capability requires the camera device to support the following:</p>\n     * <ul>\n     * <li>{@link android.graphics.ImageFormat#DEPTH16 } is supported as\n     *   an output format.</li>\n     * <li>{@link android.graphics.ImageFormat#DEPTH_POINT_CLOUD } is\n     *   optionally supported as an output format.</li>\n     * <li>This camera device, and all camera devices with the same {@link CameraCharacteristics#LENS_FACING android.lens.facing}, will\n     *   list the following calibration metadata entries in both {@link android.hardware.camera2.CameraCharacteristics }\n     *   and {@link android.hardware.camera2.CaptureResult }:<ul>\n     * <li>{@link CameraCharacteristics#LENS_POSE_TRANSLATION android.lens.poseTranslation}</li>\n     * <li>{@link CameraCharacteristics#LENS_POSE_ROTATION android.lens.poseRotation}</li>\n     * <li>{@link CameraCharacteristics#LENS_INTRINSIC_CALIBRATION android.lens.intrinsicCalibration}</li>\n     * <li>{@link CameraCharacteristics#LENS_DISTORTION android.lens.distortion}</li>\n     * </ul>\n     * </li>\n     * <li>The {@link CameraCharacteristics#DEPTH_DEPTH_IS_EXCLUSIVE android.depth.depthIsExclusive} entry is listed by this device.</li>\n     * <li>As of Android P, the {@link CameraCharacteristics#LENS_POSE_REFERENCE android.lens.poseReference} entry is listed by this device.</li>\n     * <li>A LIMITED camera with only the DEPTH_OUTPUT capability does not have to support\n     *   normal YUV_420_888, Y8, JPEG, and PRIV-format outputs. It only has to support the\n     *   DEPTH16 format.</li>\n     * </ul>\n     * <p>Generally, depth output operates at a slower frame rate than standard color capture,\n     * so the DEPTH16 and DEPTH_POINT_CLOUD formats will commonly have a stall duration that\n     * should be accounted for (see {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputStallDuration }).\n     * On a device that supports both depth and color-based output, to enable smooth preview,\n     * using a repeating burst is recommended, where a depth-output target is only included\n     * once every N frames, where N is the ratio between preview output rate and depth output\n     * rate, including depth stall time.</p>\n     *\n     * @see CameraCharacteristics#DEPTH_DEPTH_IS_EXCLUSIVE\n     * @see CameraCharacteristics#LENS_DISTORTION\n     * @see CameraCharacteristics#LENS_FACING\n     * @see CameraCharacteristics#LENS_INTRINSIC_CALIBRATION\n     * @see CameraCharacteristics#LENS_POSE_REFERENCE\n     * @see CameraCharacteristics#LENS_POSE_ROTATION\n     * @see CameraCharacteristics#LENS_POSE_TRANSLATION\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#LENS_FACING", "android.hardware.camera2.CaptureResult", "android.hardware.camera2.CameraCharacteristics#DEPTH_DEPTH_IS_EXCLUSIVE", "android.graphics.ImageFormat#DEPTH16", "android.graphics.ImageFormat#DEPTH_POINT_CLOUD", "android.hardware.camera2.CameraCharacteristics", "android.hardware.camera2.CameraCharacteristics#LENS_DISTORTION", "android.hardware.camera2.CameraCharacteristics#LENS_POSE_REFERENCE", "android.hardware.camera2.CameraCharacteristics#LENS_POSE_ROTATION", "android.hardware.camera2.CameraCharacteristics#LENS_INTRINSIC_CALIBRATION", "android.hardware.camera2.params.StreamConfigurationMap#getOutputStallDuration", "android.hardware.camera2.CameraCharacteristics#LENS_POSE_TRANSLATION" ]
  }, {
    "name" : "REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO",
    "type" : "int",
    "comment" : "\n     * <p>The device supports constrained high speed video recording (frame rate &gt;=120fps) use\n     * case. The camera device will support high speed capture session created by {@link android.hardware.camera2.CameraDevice#createConstrainedHighSpeedCaptureSession }, which\n     * only accepts high speed request lists created by {@link android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList }.</p>\n     * <p>A camera device can still support high speed video streaming by advertising the high\n     * speed FPS ranges in {@link CameraCharacteristics#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES android.control.aeAvailableTargetFpsRanges}. For this case, all\n     * normal capture request per frame control and synchronization requirements will apply\n     * to the high speed fps ranges, the same as all other fps ranges. This capability\n     * describes the capability of a specialized operating mode with many limitations (see\n     * below), which is only targeted at high speed video recording.</p>\n     * <p>The supported high speed video sizes and fps ranges are specified in {@link android.hardware.camera2.params.StreamConfigurationMap#getHighSpeedVideoFpsRanges }.\n     * To get desired output frame rates, the application is only allowed to select video\n     * size and FPS range combinations provided by {@link android.hardware.camera2.params.StreamConfigurationMap#getHighSpeedVideoSizes }.  The\n     * fps range can be controlled via {@link CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE android.control.aeTargetFpsRange}.</p>\n     * <p>In this capability, the camera device will override aeMode, awbMode, and afMode to\n     * ON, AUTO, and CONTINUOUS_VIDEO, respectively. All post-processing block mode\n     * controls will be overridden to be FAST. Therefore, no manual control of capture\n     * and post-processing parameters is possible. All other controls operate the\n     * same as when {@link CaptureRequest#CONTROL_MODE android.control.mode} == AUTO. This means that all other\n     * android.control.* fields continue to work, such as</p>\n     * <ul>\n     * <li>{@link CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE android.control.aeTargetFpsRange}</li>\n     * <li>{@link CaptureRequest#CONTROL_AE_EXPOSURE_COMPENSATION android.control.aeExposureCompensation}</li>\n     * <li>{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock}</li>\n     * <li>{@link CaptureRequest#CONTROL_AWB_LOCK android.control.awbLock}</li>\n     * <li>{@link CaptureRequest#CONTROL_EFFECT_MODE android.control.effectMode}</li>\n     * <li>{@link CaptureRequest#CONTROL_AE_REGIONS android.control.aeRegions}</li>\n     * <li>{@link CaptureRequest#CONTROL_AF_REGIONS android.control.afRegions}</li>\n     * <li>{@link CaptureRequest#CONTROL_AWB_REGIONS android.control.awbRegions}</li>\n     * <li>{@link CaptureRequest#CONTROL_AF_TRIGGER android.control.afTrigger}</li>\n     * <li>{@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger}</li>\n     * <li>{@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio}</li>\n     * </ul>\n     * <p>Outside of android.control.*, the following controls will work:</p>\n     * <ul>\n     * <li>{@link CaptureRequest#FLASH_MODE android.flash.mode} (TORCH mode only, automatic flash for still capture will not\n     * work since aeMode is ON)</li>\n     * <li>{@link CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE android.lens.opticalStabilizationMode} (if it is supported)</li>\n     * <li>{@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion}</li>\n     * <li>{@link CaptureRequest#STATISTICS_FACE_DETECT_MODE android.statistics.faceDetectMode} (if it is supported)</li>\n     * </ul>\n     * <p>For high speed recording use case, the actual maximum supported frame rate may\n     * be lower than what camera can output, depending on the destination Surfaces for\n     * the image data. For example, if the destination surface is from video encoder,\n     * the application need check if the video encoder is capable of supporting the\n     * high frame rate for a given video size, or it will end up with lower recording\n     * frame rate. If the destination surface is from preview window, the actual preview frame\n     * rate will be bounded by the screen refresh rate.</p>\n     * <p>The camera device will only support up to 2 high speed simultaneous output surfaces\n     * (preview and recording surfaces) in this mode. Above controls will be effective only\n     * if all of below conditions are true:</p>\n     * <ul>\n     * <li>The application creates a camera capture session with no more than 2 surfaces via\n     * {@link android.hardware.camera2.CameraDevice#createConstrainedHighSpeedCaptureSession }. The\n     * targeted surfaces must be preview surface (either from {@link android.view.SurfaceView } or {@link android.graphics.SurfaceTexture }) or recording\n     * surface(either from {@link android.media.MediaRecorder#getSurface } or {@link android.media.MediaCodec#createInputSurface }).</li>\n     * <li>The stream sizes are selected from the sizes reported by\n     * {@link android.hardware.camera2.params.StreamConfigurationMap#getHighSpeedVideoSizes }.</li>\n     * <li>The FPS ranges are selected from {@link android.hardware.camera2.params.StreamConfigurationMap#getHighSpeedVideoFpsRanges }.</li>\n     * </ul>\n     * <p>When above conditions are NOT satisfied,\n     * {@link android.hardware.camera2.CameraDevice#createConstrainedHighSpeedCaptureSession }\n     * will fail.</p>\n     * <p>Switching to a FPS range that has different maximum FPS may trigger some camera device\n     * reconfigurations, which may introduce extra latency. It is recommended that\n     * the application avoids unnecessary maximum target FPS changes as much as possible\n     * during high speed streaming.</p>\n     *\n     * @see CameraCharacteristics#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES\n     * @see CaptureRequest#CONTROL_AE_EXPOSURE_COMPENSATION\n     * @see CaptureRequest#CONTROL_AE_LOCK\n     * @see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER\n     * @see CaptureRequest#CONTROL_AE_REGIONS\n     * @see CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE\n     * @see CaptureRequest#CONTROL_AF_REGIONS\n     * @see CaptureRequest#CONTROL_AF_TRIGGER\n     * @see CaptureRequest#CONTROL_AWB_LOCK\n     * @see CaptureRequest#CONTROL_AWB_REGIONS\n     * @see CaptureRequest#CONTROL_EFFECT_MODE\n     * @see CaptureRequest#CONTROL_MODE\n     * @see CaptureRequest#CONTROL_ZOOM_RATIO\n     * @see CaptureRequest#FLASH_MODE\n     * @see CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE\n     * @see CaptureRequest#SCALER_CROP_REGION\n     * @see CaptureRequest#STATISTICS_FACE_DETECT_MODE\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     ",
    "links" : [ "android.view.SurfaceView", "android.hardware.camera2.CaptureRequest#CONTROL_AE_LOCK", "android.media.MediaCodec#createInputSurface", "android.hardware.camera2.CameraCharacteristics#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES", "android.hardware.camera2.CaptureRequest#FLASH_MODE", "android.media.MediaRecorder#getSurface", "android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList", "android.hardware.camera2.CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE", "android.hardware.camera2.params.StreamConfigurationMap#getHighSpeedVideoFpsRanges", "android.hardware.camera2.CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE", "android.hardware.camera2.CaptureRequest#SCALER_CROP_REGION", "android.hardware.camera2.CameraDevice#createConstrainedHighSpeedCaptureSession", "android.hardware.camera2.CaptureRequest#CONTROL_AF_TRIGGER", "android.hardware.camera2.CaptureRequest#STATISTICS_FACE_DETECT_MODE", "android.graphics.SurfaceTexture", "android.hardware.camera2.CaptureRequest#CONTROL_AWB_REGIONS", "android.hardware.camera2.CaptureRequest#CONTROL_AWB_LOCK", "android.hardware.camera2.CaptureRequest#CONTROL_AE_EXPOSURE_COMPENSATION", "android.hardware.camera2.CaptureRequest#CONTROL_AE_REGIONS", "android.hardware.camera2.params.StreamConfigurationMap#getHighSpeedVideoSizes", "android.hardware.camera2.CaptureRequest#CONTROL_EFFECT_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_AF_REGIONS", "android.hardware.camera2.CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER", "android.hardware.camera2.CaptureRequest#CONTROL_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_ZOOM_RATIO" ]
  }, {
    "name" : "REQUEST_AVAILABLE_CAPABILITIES_MOTION_TRACKING",
    "type" : "int",
    "comment" : "\n     * <p>The camera device supports the MOTION_TRACKING value for\n     * {@link CaptureRequest#CONTROL_CAPTURE_INTENT android.control.captureIntent}, which limits maximum exposure time to 20 ms.</p>\n     * <p>This limits the motion blur of capture images, resulting in better image tracking\n     * results for use cases such as image stabilization or augmented reality.</p>\n     *\n     * @see CaptureRequest#CONTROL_CAPTURE_INTENT\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#CONTROL_CAPTURE_INTENT" ]
  }, {
    "name" : "REQUEST_AVAILABLE_CAPABILITIES_LOGICAL_MULTI_CAMERA",
    "type" : "int",
    "comment" : "\n     * <p>The camera device is a logical camera backed by two or more physical cameras.</p>\n     * <p>In API level 28, the physical cameras must also be exposed to the application via\n     * {@link android.hardware.camera2.CameraManager#getCameraIdList }.</p>\n     * <p>Starting from API level 29:</p>\n     * <ul>\n     * <li>Some or all physical cameras may not be independently exposed to the application,\n     * in which case the physical camera IDs will not be available in\n     * {@link android.hardware.camera2.CameraManager#getCameraIdList }. But the\n     * application can still query the physical cameras' characteristics by calling\n     * {@link android.hardware.camera2.CameraManager#getCameraCharacteristics }.</li>\n     * <li>If a physical camera is hidden from camera ID list, the mandatory stream\n     * combinations for that physical camera must be supported through the logical camera\n     * using physical streams. One exception is that in API level 30, a physical camera\n     * may become unavailable via\n     * {@link CameraManager.AvailabilityCallback#onPhysicalCameraUnavailable }\n     * callback.</li>\n     * </ul>\n     * <p>Combinations of logical and physical streams, or physical streams from different\n     * physical cameras are not guaranteed. However, if the camera device supports\n     * {@link CameraDevice#isSessionConfigurationSupported },\n     * application must be able to query whether a stream combination involving physical\n     * streams is supported by calling\n     * {@link CameraDevice#isSessionConfigurationSupported }.</p>\n     * <p>Camera application shouldn't assume that there are at most 1 rear camera and 1 front\n     * camera in the system. For an application that switches between front and back cameras,\n     * the recommendation is to switch between the first rear camera and the first front\n     * camera in the list of supported camera devices.</p>\n     * <p>This capability requires the camera device to support the following:</p>\n     * <ul>\n     * <li>The IDs of underlying physical cameras are returned via\n     *   {@link android.hardware.camera2.CameraCharacteristics#getPhysicalCameraIds }.</li>\n     * <li>This camera device must list static metadata\n     *   {@link CameraCharacteristics#LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE android.logicalMultiCamera.sensorSyncType} in\n     *   {@link android.hardware.camera2.CameraCharacteristics }.</li>\n     * <li>The underlying physical cameras' static metadata must list the following entries,\n     *   so that the application can correlate pixels from the physical streams:<ul>\n     * <li>{@link CameraCharacteristics#LENS_POSE_REFERENCE android.lens.poseReference}</li>\n     * <li>{@link CameraCharacteristics#LENS_POSE_ROTATION android.lens.poseRotation}</li>\n     * <li>{@link CameraCharacteristics#LENS_POSE_TRANSLATION android.lens.poseTranslation}</li>\n     * <li>{@link CameraCharacteristics#LENS_INTRINSIC_CALIBRATION android.lens.intrinsicCalibration}</li>\n     * <li>{@link CameraCharacteristics#LENS_DISTORTION android.lens.distortion}</li>\n     * </ul>\n     * </li>\n     * <li>The SENSOR_INFO_TIMESTAMP_SOURCE of the logical device and physical devices must be\n     *   the same.</li>\n     * <li>The logical camera must be LIMITED or higher device.</li>\n     * </ul>\n     * <p>A logical camera device's dynamic metadata may contain\n     * {@link CaptureResult#LOGICAL_MULTI_CAMERA_ACTIVE_PHYSICAL_ID android.logicalMultiCamera.activePhysicalId} to notify the application of the current\n     * active physical camera Id. An active physical camera is the physical camera from which\n     * the logical camera's main image data outputs (YUV or RAW) and metadata come from.\n     * In addition, this serves as an indication which physical camera is used to output to\n     * a RAW stream, or in case only physical cameras support RAW, which physical RAW stream\n     * the application should request.</p>\n     * <p>Logical camera's static metadata tags below describe the default active physical\n     * camera. An active physical camera is default if it's used when application directly\n     * uses requests built from a template. All templates will default to the same active\n     * physical camera.</p>\n     * <ul>\n     * <li>{@link CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE android.sensor.info.sensitivityRange}</li>\n     * <li>{@link CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT android.sensor.info.colorFilterArrangement}</li>\n     * <li>{@link CameraCharacteristics#SENSOR_INFO_EXPOSURE_TIME_RANGE android.sensor.info.exposureTimeRange}</li>\n     * <li>{@link CameraCharacteristics#SENSOR_INFO_MAX_FRAME_DURATION android.sensor.info.maxFrameDuration}</li>\n     * <li>{@link CameraCharacteristics#SENSOR_INFO_PHYSICAL_SIZE android.sensor.info.physicalSize}</li>\n     * <li>{@link CameraCharacteristics#SENSOR_INFO_WHITE_LEVEL android.sensor.info.whiteLevel}</li>\n     * <li>{@link CameraCharacteristics#SENSOR_INFO_LENS_SHADING_APPLIED android.sensor.info.lensShadingApplied}</li>\n     * <li>{@link CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1 android.sensor.referenceIlluminant1}</li>\n     * <li>{@link CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT2 android.sensor.referenceIlluminant2}</li>\n     * <li>{@link CameraCharacteristics#SENSOR_CALIBRATION_TRANSFORM1 android.sensor.calibrationTransform1}</li>\n     * <li>{@link CameraCharacteristics#SENSOR_CALIBRATION_TRANSFORM2 android.sensor.calibrationTransform2}</li>\n     * <li>{@link CameraCharacteristics#SENSOR_COLOR_TRANSFORM1 android.sensor.colorTransform1}</li>\n     * <li>{@link CameraCharacteristics#SENSOR_COLOR_TRANSFORM2 android.sensor.colorTransform2}</li>\n     * <li>{@link CameraCharacteristics#SENSOR_FORWARD_MATRIX1 android.sensor.forwardMatrix1}</li>\n     * <li>{@link CameraCharacteristics#SENSOR_FORWARD_MATRIX2 android.sensor.forwardMatrix2}</li>\n     * <li>{@link CameraCharacteristics#SENSOR_BLACK_LEVEL_PATTERN android.sensor.blackLevelPattern}</li>\n     * <li>{@link CameraCharacteristics#SENSOR_MAX_ANALOG_SENSITIVITY android.sensor.maxAnalogSensitivity}</li>\n     * <li>{@link CameraCharacteristics#SENSOR_OPTICAL_BLACK_REGIONS android.sensor.opticalBlackRegions}</li>\n     * <li>{@link CameraCharacteristics#SENSOR_AVAILABLE_TEST_PATTERN_MODES android.sensor.availableTestPatternModes}</li>\n     * <li>{@link CameraCharacteristics#LENS_INFO_HYPERFOCAL_DISTANCE android.lens.info.hyperfocalDistance}</li>\n     * <li>{@link CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE android.lens.info.minimumFocusDistance}</li>\n     * <li>{@link CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION android.lens.info.focusDistanceCalibration}</li>\n     * <li>{@link CameraCharacteristics#LENS_POSE_ROTATION android.lens.poseRotation}</li>\n     * <li>{@link CameraCharacteristics#LENS_POSE_TRANSLATION android.lens.poseTranslation}</li>\n     * <li>{@link CameraCharacteristics#LENS_INTRINSIC_CALIBRATION android.lens.intrinsicCalibration}</li>\n     * <li>{@link CameraCharacteristics#LENS_POSE_REFERENCE android.lens.poseReference}</li>\n     * <li>{@link CameraCharacteristics#LENS_DISTORTION android.lens.distortion}</li>\n     * </ul>\n     * <p>The field of view of non-RAW physical streams must not be smaller than that of the\n     * non-RAW logical streams, or the maximum field-of-view of the physical camera,\n     * whichever is smaller. The application should check the physical capture result\n     * metadata for how the physical streams are cropped or zoomed. More specifically, given\n     * the physical camera result metadata, the effective horizontal field-of-view of the\n     * physical camera is:</p>\n     * <pre><code>fov = 2 * atan2(cropW * sensorW / (2 * zoomRatio * activeArrayW), focalLength)\n     * </code></pre>\n     * <p>where the equation parameters are the physical camera's crop region width, physical\n     * sensor width, zoom ratio, active array width, and focal length respectively. Typically\n     * the physical stream of active physical camera has the same field-of-view as the\n     * logical streams. However, the same may not be true for physical streams from\n     * non-active physical cameras. For example, if the logical camera has a wide-ultrawide\n     * configuration where the wide lens is the default, when the crop region is set to the\n     * logical camera's active array size, (and the zoom ratio set to 1.0 starting from\n     * Android 11), a physical stream for the ultrawide camera may prefer outputting images\n     * with larger field-of-view than that of the wide camera for better stereo matching\n     * margin or more robust motion tracking. At the same time, the physical non-RAW streams'\n     * field of view must not be smaller than the requested crop region and zoom ratio, as\n     * long as it's within the physical lens' capability. For example, for a logical camera\n     * with wide-tele lens configuration where the wide lens is the default, if the logical\n     * camera's crop region is set to maximum size, and zoom ratio set to 1.0, the physical\n     * stream for the tele lens will be configured to its maximum size crop region (no zoom).</p>\n     * <p><em>Deprecated:</em> Prior to Android 11, the field of view of all non-RAW physical streams\n     * cannot be larger than that of non-RAW logical streams. If the logical camera has a\n     * wide-ultrawide lens configuration where the wide lens is the default, when the logical\n     * camera's crop region is set to maximum size, the FOV of the physical streams for the\n     * ultrawide lens will be the same as the logical stream, by making the crop region\n     * smaller than its active array size to compensate for the smaller focal length.</p>\n     * <p>For a logical camera, typically the underlying physical cameras have different RAW\n     * capabilities (such as resolution or CFA pattern). There are two ways for the\n     * application to capture RAW images from the logical camera:</p>\n     * <ul>\n     * <li>If the logical camera has RAW capability, the application can create and use RAW\n     * streams in the same way as before. In case a RAW stream is configured, to maintain\n     * backward compatibility, the camera device makes sure the default active physical\n     * camera remains active and does not switch to other physical cameras. (One exception\n     * is that, if the logical camera consists of identical image sensors and advertises\n     * multiple focalLength due to different lenses, the camera device may generate RAW\n     * images from different physical cameras based on the focalLength being set by the\n     * application.) This backward-compatible approach usually results in loss of optical\n     * zoom, to telephoto lens or to ultrawide lens.</li>\n     * <li>Alternatively, if supported by the device,\n     * {@link android.hardware.camera2.MultiResolutionImageReader }\n     * can be used to capture RAW images from one of the underlying physical cameras (\n     * depending on current zoom level). Because different physical cameras may have\n     * different RAW characteristics, the application needs to use the characteristics\n     * and result metadata of the active physical camera for the relevant RAW metadata.</li>\n     * </ul>\n     * <p>The capture request and result metadata tags required for backward compatible camera\n     * functionalities will be solely based on the logical camera capability. On the other\n     * hand, the use of manual capture controls (sensor or post-processing) with a\n     * logical camera may result in unexpected behavior when the HAL decides to switch\n     * between physical cameras with different characteristics under the hood. For example,\n     * when the application manually sets exposure time and sensitivity while zooming in,\n     * the brightness of the camera images may suddenly change because HAL switches from one\n     * physical camera to the other.</p>\n     *\n     * @see CameraCharacteristics#LENS_DISTORTION\n     * @see CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION\n     * @see CameraCharacteristics#LENS_INFO_HYPERFOCAL_DISTANCE\n     * @see CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE\n     * @see CameraCharacteristics#LENS_INTRINSIC_CALIBRATION\n     * @see CameraCharacteristics#LENS_POSE_REFERENCE\n     * @see CameraCharacteristics#LENS_POSE_ROTATION\n     * @see CameraCharacteristics#LENS_POSE_TRANSLATION\n     * @see CaptureResult#LOGICAL_MULTI_CAMERA_ACTIVE_PHYSICAL_ID\n     * @see CameraCharacteristics#LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE\n     * @see CameraCharacteristics#SENSOR_AVAILABLE_TEST_PATTERN_MODES\n     * @see CameraCharacteristics#SENSOR_BLACK_LEVEL_PATTERN\n     * @see CameraCharacteristics#SENSOR_CALIBRATION_TRANSFORM1\n     * @see CameraCharacteristics#SENSOR_CALIBRATION_TRANSFORM2\n     * @see CameraCharacteristics#SENSOR_COLOR_TRANSFORM1\n     * @see CameraCharacteristics#SENSOR_COLOR_TRANSFORM2\n     * @see CameraCharacteristics#SENSOR_FORWARD_MATRIX1\n     * @see CameraCharacteristics#SENSOR_FORWARD_MATRIX2\n     * @see CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT\n     * @see CameraCharacteristics#SENSOR_INFO_EXPOSURE_TIME_RANGE\n     * @see CameraCharacteristics#SENSOR_INFO_LENS_SHADING_APPLIED\n     * @see CameraCharacteristics#SENSOR_INFO_MAX_FRAME_DURATION\n     * @see CameraCharacteristics#SENSOR_INFO_PHYSICAL_SIZE\n     * @see CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE\n     * @see CameraCharacteristics#SENSOR_INFO_WHITE_LEVEL\n     * @see CameraCharacteristics#SENSOR_MAX_ANALOG_SENSITIVITY\n     * @see CameraCharacteristics#SENSOR_OPTICAL_BLACK_REGIONS\n     * @see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1\n     * @see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT2\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     ",
    "links" : [ "android.hardware.camera2.CaptureResult#LOGICAL_MULTI_CAMERA_ACTIVE_PHYSICAL_ID", "android.hardware.camera2.CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT2", "android.hardware.camera2.CameraCharacteristics#SENSOR_COLOR_TRANSFORM1", "android.hardware.camera2.CameraCharacteristics#SENSOR_COLOR_TRANSFORM2", "android.hardware.camera2.CameraCharacteristics#LENS_DISTORTION", "CameraManager.AvailabilityCallback#onPhysicalCameraUnavailable", "android.hardware.camera2.CameraCharacteristics#LENS_POSE_TRANSLATION", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_EXPOSURE_TIME_RANGE", "android.hardware.camera2.CameraCharacteristics#SENSOR_BLACK_LEVEL_PATTERN", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_WHITE_LEVEL", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_MAX_FRAME_DURATION", "android.hardware.camera2.CameraCharacteristics#SENSOR_MAX_ANALOG_SENSITIVITY", "android.hardware.camera2.CameraManager#getCameraIdList", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE", "android.hardware.camera2.CameraCharacteristics", "android.hardware.camera2.CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION", "android.hardware.camera2.CameraCharacteristics#getPhysicalCameraIds", "android.hardware.camera2.MultiResolutionImageReader", "android.hardware.camera2.CameraCharacteristics#LENS_POSE_ROTATION", "android.hardware.camera2.CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1", "android.hardware.camera2.CameraCharacteristics#SENSOR_CALIBRATION_TRANSFORM1", "android.hardware.camera2.CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE", "android.hardware.camera2.CameraCharacteristics#LENS_POSE_REFERENCE", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_PHYSICAL_SIZE", "android.hardware.camera2.CameraCharacteristics#LENS_INTRINSIC_CALIBRATION", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT", "android.hardware.camera2.CameraCharacteristics#LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE", "android.hardware.camera2.CameraCharacteristics#SENSOR_CALIBRATION_TRANSFORM2", "android.hardware.camera2.CameraCharacteristics#SENSOR_OPTICAL_BLACK_REGIONS", "android.hardware.camera2.CameraDevice#isSessionConfigurationSupported", "android.hardware.camera2.CameraCharacteristics#SENSOR_AVAILABLE_TEST_PATTERN_MODES", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_LENS_SHADING_APPLIED", "android.hardware.camera2.CameraManager#getCameraCharacteristics", "android.hardware.camera2.CameraCharacteristics#SENSOR_FORWARD_MATRIX2", "android.hardware.camera2.CameraCharacteristics#LENS_INFO_HYPERFOCAL_DISTANCE", "android.hardware.camera2.CameraCharacteristics#SENSOR_FORWARD_MATRIX1" ]
  }, {
    "name" : "REQUEST_AVAILABLE_CAPABILITIES_MONOCHROME",
    "type" : "int",
    "comment" : "\n     * <p>The camera device is a monochrome camera that doesn't contain a color filter array,\n     * and for YUV_420_888 stream, the pixel values on U and V planes are all 128.</p>\n     * <p>A MONOCHROME camera must support the guaranteed stream combinations required for\n     * its device level and capabilities. Additionally, if the monochrome camera device\n     * supports Y8 format, all mandatory stream combination requirements related to {@link android.graphics.ImageFormat#YUV_420_888 YUV_420_888} apply\n     * to {@link android.graphics.ImageFormat#Y8 Y8} as well. There are no\n     * mandatory stream combination requirements with regard to\n     * {@link android.graphics.ImageFormat#Y8 Y8} for Bayer camera devices.</p>\n     * <p>Starting from Android Q, the SENSOR_INFO_COLOR_FILTER_ARRANGEMENT of a MONOCHROME\n     * camera will be either MONO or NIR.</p>\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     ",
    "links" : [ "android.graphics.ImageFormat#Y8", "android.graphics.ImageFormat#YUV_420_888" ]
  }, {
    "name" : "REQUEST_AVAILABLE_CAPABILITIES_SECURE_IMAGE_DATA",
    "type" : "int",
    "comment" : "\n     * <p>The camera device is capable of writing image data into a region of memory\n     * inaccessible to Android userspace or the Android kernel, and only accessible to\n     * trusted execution environments (TEE).</p>\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_AVAILABLE_CAPABILITIES_SYSTEM_CAMERA",
    "type" : "int",
    "comment" : "\n     * <p>The camera device is only accessible by Android's system components and privileged\n     * applications. Processes need to have the android.permission.SYSTEM_CAMERA in\n     * addition to android.permission.CAMERA in order to connect to this camera device.</p>\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_AVAILABLE_CAPABILITIES_OFFLINE_PROCESSING",
    "type" : "int",
    "comment" : "\n     * <p>The camera device supports the OFFLINE_PROCESSING use case.</p>\n     * <p>With OFFLINE_PROCESSING capability, the application can switch an ongoing\n     * capture session to offline mode by calling the\n     * CameraCaptureSession#switchToOffline method and specify streams to be kept in offline\n     * mode. The camera will then stop currently active repeating requests, prepare for\n     * some requests to go into offline mode, and return an offline session object. After\n     * the switchToOffline call returns, the original capture session is in closed state as\n     * if the CameraCaptureSession#close method has been called.\n     * In the offline mode, all inflight requests will continue to be processed in the\n     * background, and the application can immediately close the camera or create a new\n     * capture session without losing those requests' output images and capture results.</p>\n     * <p>While the camera device is processing offline requests, it\n     * might not be able to support all stream configurations it can support\n     * without offline requests. When that happens, the createCaptureSession\n     * method call will fail. The following stream configurations are guaranteed to work\n     * without hitting the resource busy exception:</p>\n     * <ul>\n     * <li>One ongoing offline session: target one output surface of YUV or\n     * JPEG format, any resolution.</li>\n     * <li>The active camera capture session:<ol>\n     * <li>One preview surface (SurfaceView or SurfaceTexture) up to 1920 width</li>\n     * <li>One YUV ImageReader surface up to 1920 width</li>\n     * <li>One Jpeg ImageReader, any resolution: the camera device is\n     *    allowed to slow down JPEG output speed by 50% if there is any ongoing offline\n     *    session.</li>\n     * <li>If the device supports PRIVATE_REPROCESSING, one pair of ImageWriter/ImageReader\n     *    surfaces of private format, with the same resolution that is larger or equal to\n     *    the JPEG ImageReader resolution above.</li>\n     * </ol>\n     * </li>\n     * <li>Alternatively, the active camera session above can be replaced by an legacy\n     * {@link android.hardware.Camera Camera} with the following parameter settings:<ol>\n     * <li>Preview size up to 1920 width</li>\n     * <li>Preview callback size up to 1920 width</li>\n     * <li>Video size up to 1920 width</li>\n     * <li>Picture size, any resolution: the camera device is\n     *     allowed to slow down JPEG output speed by 50% if there is any ongoing offline\n     *     session.</li>\n     * </ol>\n     * </li>\n     * </ul>\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     ",
    "links" : [ "android.hardware.Camera" ]
  }, {
    "name" : "REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR",
    "type" : "int",
    "comment" : "\n     * <p>This camera device is capable of producing ultra high resolution images in\n     * addition to the image sizes described in the\n     * {@link CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP android.scaler.streamConfigurationMap}.\n     * It can operate in 'default' mode and 'max resolution' mode. It generally does this\n     * by binning pixels in 'default' mode and not binning them in 'max resolution' mode.\n     * <code>{@link CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP android.scaler.streamConfigurationMap}</code> describes the streams supported in 'default'\n     * mode.\n     * The stream configurations supported in 'max resolution' mode are described by\n     * <code>{@link CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP_MAXIMUM_RESOLUTION android.scaler.streamConfigurationMapMaximumResolution}</code>.\n     * The maximum resolution mode pixel array size of a camera device\n     * (<code>{@link CameraCharacteristics#SENSOR_INFO_PIXEL_ARRAY_SIZE android.sensor.info.pixelArraySize}</code>) with this capability,\n     * will be at least 24 megapixels.</p>\n     *\n     * @see CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP\n     * @see CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP_MAXIMUM_RESOLUTION\n     * @see CameraCharacteristics#SENSOR_INFO_PIXEL_ARRAY_SIZE\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_PIXEL_ARRAY_SIZE", "android.hardware.camera2.CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP_MAXIMUM_RESOLUTION", "android.hardware.camera2.CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP" ]
  }, {
    "name" : "REQUEST_AVAILABLE_CAPABILITIES_REMOSAIC_REPROCESSING",
    "type" : "int",
    "comment" : "\n     * <p>The device supports reprocessing from the <code>RAW_SENSOR</code> format with a bayer pattern\n     * given by {@link CameraCharacteristics#SENSOR_INFO_BINNING_FACTOR android.sensor.info.binningFactor} (m x n group of pixels with the same\n     * color filter) to a remosaiced regular bayer pattern.</p>\n     * <p>This capability will only be present for devices with\n     * {@link android.hardware.camera2.CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR }\n     * capability. When\n     * {@link android.hardware.camera2.CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR }\n     * devices do not advertise this capability,\n     * {@link android.graphics.ImageFormat#RAW_SENSOR } images will already have a\n     * regular bayer pattern.</p>\n     * <p>If a <code>RAW_SENSOR</code> stream is requested along with another non-RAW stream in a\n     * {@link android.hardware.camera2.CaptureRequest } (if multiple streams are supported\n     * when {@link CaptureRequest#SENSOR_PIXEL_MODE android.sensor.pixelMode} is set to\n     * {@link android.hardware.camera2.CameraMetadata#SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION }),\n     * the <code>RAW_SENSOR</code> stream will have a regular bayer pattern.</p>\n     * <p>This capability requires the camera device to support the following :</p>\n     * <ul>\n     * <li>The {@link android.hardware.camera2.params.StreamConfigurationMap } mentioned below\n     *   refers to the one, described by\n     *   <code>{@link CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP_MAXIMUM_RESOLUTION android.scaler.streamConfigurationMapMaximumResolution}</code>.</li>\n     * <li>One input stream is supported, that is, <code>{@link CameraCharacteristics#REQUEST_MAX_NUM_INPUT_STREAMS android.request.maxNumInputStreams} == 1</code>.</li>\n     * <li>{@link android.graphics.ImageFormat#RAW_SENSOR } is supported as an output/input\n     *   format, that is, {@link android.graphics.ImageFormat#RAW_SENSOR } is included in the\n     *   lists of formats returned by {@link android.hardware.camera2.params.StreamConfigurationMap#getInputFormats } and {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputFormats }.</li>\n     * <li>{@link android.hardware.camera2.params.StreamConfigurationMap#getValidOutputFormatsForInput }\n     *   returns non-empty int[] for each supported input format returned by {@link android.hardware.camera2.params.StreamConfigurationMap#getInputFormats }.</li>\n     * <li>Each size returned by {@link android.hardware.camera2.params.StreamConfigurationMap#getInputSizes getInputSizes(ImageFormat.RAW_SENSOR)} is also included in {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputSizes getOutputSizes(ImageFormat.RAW_SENSOR)}</li>\n     * <li>Using {@link android.graphics.ImageFormat#RAW_SENSOR } does not cause a frame rate\n     *   drop relative to the sensor's maximum capture rate (at that resolution).</li>\n     * <li>No CaptureRequest controls will be applicable when a request has an input target\n     *   with {@link android.graphics.ImageFormat#RAW_SENSOR } format.</li>\n     * </ul>\n     *\n     * @see CameraCharacteristics#REQUEST_MAX_NUM_INPUT_STREAMS\n     * @see CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP_MAXIMUM_RESOLUTION\n     * @see CameraCharacteristics#SENSOR_INFO_BINNING_FACTOR\n     * @see CaptureRequest#SENSOR_PIXEL_MODE\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     ",
    "links" : [ "android.graphics.ImageFormat#RAW_SENSOR", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_BINNING_FACTOR", "android.hardware.camera2.params.StreamConfigurationMap", "android.hardware.camera2.params.StreamConfigurationMap#getOutputSizes", "android.hardware.camera2.CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR", "android.hardware.camera2.params.StreamConfigurationMap#getValidOutputFormatsForInput", "android.hardware.camera2.params.StreamConfigurationMap#getInputFormats", "android.hardware.camera2.CameraCharacteristics#SCALER_STREAM_CONFIGURATION_MAP_MAXIMUM_RESOLUTION", "android.hardware.camera2.CameraCharacteristics#REQUEST_MAX_NUM_INPUT_STREAMS", "android.hardware.camera2.CameraMetadata#SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION", "android.hardware.camera2.params.StreamConfigurationMap#getInputSizes", "android.hardware.camera2.params.StreamConfigurationMap#getOutputFormats", "android.hardware.camera2.CaptureRequest", "android.hardware.camera2.CaptureRequest#SENSOR_PIXEL_MODE" ]
  }, {
    "name" : "REQUEST_AVAILABLE_CAPABILITIES_DYNAMIC_RANGE_TEN_BIT",
    "type" : "int",
    "comment" : "\n     * <p>The device supports one or more 10-bit camera outputs according to the dynamic range\n     * profiles specified in\n     * {@link android.hardware.camera2.params.DynamicRangeProfiles#getSupportedProfiles }.\n     * They can be configured as part of the capture session initialization via\n     * {@link android.hardware.camera2.params.OutputConfiguration#setDynamicRangeProfile }.\n     * Cameras that enable this capability must also support the following:</p>\n     * <ul>\n     * <li>Profile {@link android.hardware.camera2.params.DynamicRangeProfiles#HLG10 }</li>\n     * <li>All mandatory stream combinations for this specific capability as per\n     *   <a href=\"https://developer.android.com/reference/android/hardware/camera2/CameraDevice#10-bit-output-additional-guaranteed-configurations\">documentation</a></li>\n     * <li>In case the device is not able to capture some combination of supported\n     *   standard 8-bit and/or 10-bit dynamic range profiles within the same capture request,\n     *   then those constraints must be listed in\n     *   {@link android.hardware.camera2.params.DynamicRangeProfiles#getProfileCaptureRequestConstraints }</li>\n     * <li>Recommended dynamic range profile listed in\n     *   {@link android.hardware.camera2.CameraCharacteristics#REQUEST_RECOMMENDED_TEN_BIT_DYNAMIC_RANGE_PROFILE }.</li>\n     * </ul>\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     ",
    "links" : [ "android.hardware.camera2.params.DynamicRangeProfiles#getSupportedProfiles", "android.hardware.camera2.CameraCharacteristics#REQUEST_RECOMMENDED_TEN_BIT_DYNAMIC_RANGE_PROFILE", "android.hardware.camera2.params.DynamicRangeProfiles#getProfileCaptureRequestConstraints", "android.hardware.camera2.params.DynamicRangeProfiles#HLG10", "android.hardware.camera2.params.OutputConfiguration#setDynamicRangeProfile" ]
  }, {
    "name" : "REQUEST_AVAILABLE_CAPABILITIES_STREAM_USE_CASE",
    "type" : "int",
    "comment" : "\n     * <p>The camera device supports selecting a per-stream use case via\n     * {@link android.hardware.camera2.params.OutputConfiguration#setStreamUseCase }\n     * so that the device can optimize camera pipeline parameters such as tuning, sensor\n     * mode, or ISP settings for a specific user scenario.\n     * Some sample usages of this capability are:</p>\n     * <ul>\n     * <li>Distinguish high quality YUV captures from a regular YUV stream where\n     *   the image quality may not be as good as the JPEG stream, or</li>\n     * <li>Use one stream to serve multiple purposes: viewfinder, video recording and\n     *   still capture. This is common with applications that wish to apply edits equally\n     *   to preview, saved images, and saved videos.</li>\n     * </ul>\n     * <p>This capability requires the camera device to support the following\n     * stream use cases:</p>\n     * <ul>\n     * <li>DEFAULT for backward compatibility where the application doesn't set\n     *   a stream use case</li>\n     * <li>PREVIEW for live viewfinder and in-app image analysis</li>\n     * <li>STILL_CAPTURE for still photo capture</li>\n     * <li>VIDEO_RECORD for recording video clips</li>\n     * <li>PREVIEW_VIDEO_STILL for one single stream used for viewfinder, video\n     *   recording, and still capture.</li>\n     * <li>VIDEO_CALL for long running video calls</li>\n     * </ul>\n     * <p>{@link android.hardware.camera2.CameraCharacteristics#SCALER_AVAILABLE_STREAM_USE_CASES }\n     * lists all of the supported stream use cases.</p>\n     * <p>Refer to the\n     * <a href=\"https://developer.android.com/reference/android/hardware/camera2/CameraDevice#stream-use-case-capability-additional-guaranteed-configurations\">guideline</a>\n     * for the mandatory stream combinations involving stream use cases, which can also be\n     * queried via {@link android.hardware.camera2.params.MandatoryStreamCombination }.</p>\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     ",
    "links" : [ "android.hardware.camera2.params.MandatoryStreamCombination", "android.hardware.camera2.CameraCharacteristics#SCALER_AVAILABLE_STREAM_USE_CASES", "android.hardware.camera2.params.OutputConfiguration#setStreamUseCase" ]
  }, {
    "name" : "REQUEST_AVAILABLE_CAPABILITIES_COLOR_SPACE_PROFILES",
    "type" : "int",
    "comment" : "\n     * <p>The device supports querying the possible combinations of color spaces, image\n     * formats, and dynamic range profiles supported by the camera and requesting a\n     * particular color space for a session via\n     * {@link android.hardware.camera2.params.SessionConfiguration#setColorSpace }.</p>\n     * <p>Cameras that enable this capability may or may not also implement dynamic range\n     * profiles. If they don't,\n     * {@link android.hardware.camera2.params.ColorSpaceProfiles#getSupportedDynamicRangeProfiles }\n     * will return only\n     * {@link android.hardware.camera2.params.DynamicRangeProfiles#STANDARD } and\n     * {@link android.hardware.camera2.params.ColorSpaceProfiles#getSupportedColorSpacesForDynamicRange }\n     * will assume support of the\n     * {@link android.hardware.camera2.params.DynamicRangeProfiles#STANDARD }\n     * profile in all combinations of color spaces and image formats.</p>\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     ",
    "links" : [ "android.hardware.camera2.params.ColorSpaceProfiles#getSupportedColorSpacesForDynamicRange", "android.hardware.camera2.params.DynamicRangeProfiles#STANDARD", "android.hardware.camera2.params.ColorSpaceProfiles#getSupportedDynamicRangeProfiles", "android.hardware.camera2.params.SessionConfiguration#setColorSpace" ]
  }, {
    "name" : "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD",
    "type" : "int",
    "comment" : "\n     * <p>8-bit SDR profile which is the default for all non 10-bit output capable devices.</p>\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HLG10",
    "type" : "int",
    "comment" : "\n     * <p>10-bit pixel samples encoded using the Hybrid log-gamma transfer function.</p>\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HDR10",
    "type" : "int",
    "comment" : "\n     * <p>10-bit pixel samples encoded using the SMPTE ST 2084 transfer function.\n     * This profile utilizes internal static metadata to increase the quality\n     * of the capture.</p>\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HDR10_PLUS",
    "type" : "int",
    "comment" : "\n     * <p>10-bit pixel samples encoded using the SMPTE ST 2084 transfer function.\n     * In contrast to HDR10, this profile uses internal per-frame metadata\n     * to further enhance the quality of the capture.</p>\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_REF",
    "type" : "int",
    "comment" : "\n     * <p>This is a camera mode for Dolby Vision capture optimized for a more scene\n     * accurate capture. This would typically differ from what a specific device\n     * might want to tune for a consumer optimized Dolby Vision general capture.</p>\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_REF_PO",
    "type" : "int",
    "comment" : "\n     * <p>This is the power optimized mode for 10-bit Dolby Vision HDR Reference Mode.</p>\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_OEM",
    "type" : "int",
    "comment" : "\n     * <p>This is the camera mode for the default Dolby Vision capture mode for the\n     * specific device. This would be tuned by each specific device for consumer\n     * pleasing results that resonate with their particular audience. We expect\n     * that each specific device would have a different look for their default\n     * Dolby Vision capture.</p>\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_OEM_PO",
    "type" : "int",
    "comment" : "\n     * <p>This is the power optimized mode for 10-bit Dolby Vision HDR device specific\n     * capture Mode.</p>\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_REF",
    "type" : "int",
    "comment" : "\n     * <p>This is the 8-bit version of the Dolby Vision reference capture mode optimized\n     * for scene accuracy.</p>\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_REF_PO",
    "type" : "int",
    "comment" : "\n     * <p>This is the power optimized mode for 8-bit Dolby Vision HDR Reference Mode.</p>\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_OEM",
    "type" : "int",
    "comment" : "\n     * <p>This is the 8-bit version of device specific tuned and optimized Dolby Vision\n     * capture mode.</p>\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_OEM_PO",
    "type" : "int",
    "comment" : "\n     * <p>This is the power optimized mode for 8-bit Dolby Vision HDR device specific\n     * capture Mode.</p>\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_MAX",
    "type" : "int",
    "comment" : "\n     *\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_AVAILABLE_COLOR_SPACE_PROFILES_MAP_UNSPECIFIED",
    "type" : "int",
    "comment" : "\n     * <p>Default value, when not explicitly specified. The Camera device will choose the color\n     * space to employ.</p>\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_COLOR_SPACE_PROFILES_MAP\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SCALER_CROPPING_TYPE_CENTER_ONLY",
    "type" : "int",
    "comment" : "\n     * <p>The camera device only supports centered crop regions.</p>\n     * @see CameraCharacteristics#SCALER_CROPPING_TYPE\n     ",
    "links" : [ ]
  }, {
    "name" : "SCALER_CROPPING_TYPE_FREEFORM",
    "type" : "int",
    "comment" : "\n     * <p>The camera device supports arbitrarily chosen crop regions.</p>\n     * @see CameraCharacteristics#SCALER_CROPPING_TYPE\n     ",
    "links" : [ ]
  }, {
    "name" : "SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT",
    "type" : "int",
    "comment" : "\n     * <p>Default stream use case.</p>\n     * <p>This use case is the same as when the application doesn't set any use case for\n     * the stream. The camera device uses the properties of the output target, such as\n     * format, dataSpace, or surface class type, to optimize the image processing pipeline.</p>\n     * @see CameraCharacteristics#SCALER_AVAILABLE_STREAM_USE_CASES\n     ",
    "links" : [ ]
  }, {
    "name" : "SCALER_AVAILABLE_STREAM_USE_CASES_PREVIEW",
    "type" : "int",
    "comment" : "\n     * <p>Live stream shown to the user.</p>\n     * <p>Optimized for performance and usability as a viewfinder, but not necessarily for\n     * image quality. The output is not meant to be persisted as saved images or video.</p>\n     * <p>No stall if android.control.* are set to FAST. There may be stall if\n     * they are set to HIGH_QUALITY. This use case has the same behavior as the\n     * default SurfaceView and SurfaceTexture targets. Additionally, this use case can be\n     * used for in-app image analysis.</p>\n     * @see CameraCharacteristics#SCALER_AVAILABLE_STREAM_USE_CASES\n     ",
    "links" : [ ]
  }, {
    "name" : "SCALER_AVAILABLE_STREAM_USE_CASES_STILL_CAPTURE",
    "type" : "int",
    "comment" : "\n     * <p>Still photo capture.</p>\n     * <p>Optimized for high-quality high-resolution capture, and not expected to maintain\n     * preview-like frame rates.</p>\n     * <p>The stream may have stalls regardless of whether android.control.* is HIGH_QUALITY.\n     * This use case has the same behavior as the default JPEG and RAW related formats.</p>\n     * @see CameraCharacteristics#SCALER_AVAILABLE_STREAM_USE_CASES\n     ",
    "links" : [ ]
  }, {
    "name" : "SCALER_AVAILABLE_STREAM_USE_CASES_VIDEO_RECORD",
    "type" : "int",
    "comment" : "\n     * <p>Recording video clips.</p>\n     * <p>Optimized for high-quality video capture, including high-quality image stabilization\n     * if supported by the device and enabled by the application. As a result, may produce\n     * output frames with a substantial lag from real time, to allow for highest-quality\n     * stabilization or other processing. As such, such an output is not suitable for drawing\n     * to screen directly, and is expected to be persisted to disk or similar for later\n     * playback or processing. Only streams that set the VIDEO_RECORD use case are guaranteed\n     * to have video stabilization applied when the video stabilization control is set\n     * to ON, as opposed to PREVIEW_STABILIZATION.</p>\n     * <p>This use case has the same behavior as the default MediaRecorder and MediaCodec\n     * targets.</p>\n     * @see CameraCharacteristics#SCALER_AVAILABLE_STREAM_USE_CASES\n     ",
    "links" : [ ]
  }, {
    "name" : "SCALER_AVAILABLE_STREAM_USE_CASES_PREVIEW_VIDEO_STILL",
    "type" : "int",
    "comment" : "\n     * <p>One single stream used for combined purposes of preview, video, and still capture.</p>\n     * <p>For such multi-purpose streams, the camera device aims to make the best tradeoff\n     * between the individual use cases. For example, the STILL_CAPTURE use case by itself\n     * may have stalls for achieving best image quality. But if combined with PREVIEW and\n     * VIDEO_RECORD, the camera device needs to trade off the additional image processing\n     * for speed so that preview and video recording aren't slowed down.</p>\n     * <p>Similarly, VIDEO_RECORD may produce frames with a substantial lag, but\n     * PREVIEW_VIDEO_STILL must have minimal output delay. This means that to enable video\n     * stabilization with this use case, the device must support and the app must select the\n     * PREVIEW_STABILIZATION mode for video stabilization.</p>\n     * @see CameraCharacteristics#SCALER_AVAILABLE_STREAM_USE_CASES\n     ",
    "links" : [ ]
  }, {
    "name" : "SCALER_AVAILABLE_STREAM_USE_CASES_VIDEO_CALL",
    "type" : "int",
    "comment" : "\n     * <p>Long-running video call optimized for both power efficiency and video quality.</p>\n     * <p>The camera sensor may run in a lower-resolution mode to reduce power consumption\n     * at the cost of some image and digital zoom quality. Unlike VIDEO_RECORD, VIDEO_CALL\n     * outputs are expected to work in dark conditions, so are usually accompanied with\n     * variable frame rate settings to allow sufficient exposure time in low light.</p>\n     * @see CameraCharacteristics#SCALER_AVAILABLE_STREAM_USE_CASES\n     ",
    "links" : [ ]
  }, {
    "name" : "SCALER_AVAILABLE_STREAM_USE_CASES_CROPPED_RAW",
    "type" : "int",
    "comment" : "\n     * <p>Cropped RAW stream when the client chooses to crop the field of view.</p>\n     * <p>Certain types of image sensors can run in binned modes in order to improve signal to\n     * noise ratio while capturing frames. However, at certain zoom levels and / or when\n     * other scene conditions are deemed fit, the camera sub-system may choose to un-bin and\n     * remosaic the sensor's output. This results in a RAW frame which is cropped in field\n     * of view and yet has the same number of pixels as full field of view RAW, thereby\n     * improving image detail.</p>\n     * <p>The resultant field of view of the RAW stream will be greater than or equal to\n     * croppable non-RAW streams. The effective crop region for this RAW stream will be\n     * reflected in the CaptureResult key {@link CaptureResult#SCALER_RAW_CROP_REGION android.scaler.rawCropRegion}.</p>\n     * <p>If this stream use case is set on a non-RAW stream, i.e. not one of :</p>\n     * <ul>\n     * <li>{@link android.graphics.ImageFormat#RAW_SENSOR RAW_SENSOR}</li>\n     * <li>{@link android.graphics.ImageFormat#RAW10 RAW10}</li>\n     * <li>{@link android.graphics.ImageFormat#RAW12 RAW12}</li>\n     * </ul>\n     * <p>session configuration is not guaranteed to succeed.</p>\n     * <p>This stream use case may not be supported on some devices.</p>\n     *\n     * @see CaptureResult#SCALER_RAW_CROP_REGION\n     * @see CameraCharacteristics#SCALER_AVAILABLE_STREAM_USE_CASES\n     ",
    "links" : [ "android.graphics.ImageFormat#RAW_SENSOR", "android.hardware.camera2.CaptureResult#SCALER_RAW_CROP_REGION", "android.graphics.ImageFormat#RAW12", "android.graphics.ImageFormat#RAW10" ]
  }, {
    "name" : "SCALER_AVAILABLE_STREAM_USE_CASES_VENDOR_START",
    "type" : "int",
    "comment" : "\n     * <p>Vendor defined use cases. These depend on the vendor implementation.</p>\n     * @see CameraCharacteristics#SCALER_AVAILABLE_STREAM_USE_CASES\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGGB",
    "type" : "int",
    "comment" : "\n     * @see CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GRBG",
    "type" : "int",
    "comment" : "\n     * @see CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GBRG",
    "type" : "int",
    "comment" : "\n     * @see CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_BGGR",
    "type" : "int",
    "comment" : "\n     * @see CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGB",
    "type" : "int",
    "comment" : "\n     * <p>Sensor is not Bayer; output has 3 16-bit\n     * values for each pixel, instead of just 1 16-bit value\n     * per pixel.</p>\n     * @see CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_MONO",
    "type" : "int",
    "comment" : "\n     * <p>Sensor doesn't have any Bayer color filter.\n     * Such sensor captures visible light in monochrome. The exact weighting and\n     * wavelengths captured is not specified, but generally only includes the visible\n     * frequencies. This value implies a MONOCHROME camera.</p>\n     * @see CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_NIR",
    "type" : "int",
    "comment" : "\n     * <p>Sensor has a near infrared filter capturing light with wavelength between\n     * roughly 750nm and 1400nm, and the same filter covers the whole sensor array. This\n     * value implies a MONOCHROME camera.</p>\n     * @see CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_INFO_TIMESTAMP_SOURCE_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * <p>Timestamps from {@link CaptureResult#SENSOR_TIMESTAMP android.sensor.timestamp} are in nanoseconds and monotonic, but can\n     * not be compared to timestamps from other subsystems (e.g. accelerometer, gyro etc.),\n     * or other instances of the same or different camera devices in the same system with\n     * accuracy. However, the timestamps are roughly in the same timebase as\n     * {@link android.os.SystemClock#uptimeMillis }.  The accuracy is sufficient for tasks\n     * like A/V synchronization for video recording, at least, and the timestamps can be\n     * directly used together with timestamps from the audio subsystem for that task.</p>\n     * <p>Timestamps between streams and results for a single camera instance are comparable,\n     * and the timestamps for all buffers and the result metadata generated by a single\n     * capture are identical.</p>\n     *\n     * @see CaptureResult#SENSOR_TIMESTAMP\n     * @see CameraCharacteristics#SENSOR_INFO_TIMESTAMP_SOURCE\n     ",
    "links" : [ "android.os.SystemClock#uptimeMillis", "android.hardware.camera2.CaptureResult#SENSOR_TIMESTAMP" ]
  }, {
    "name" : "SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME",
    "type" : "int",
    "comment" : "\n     * <p>Timestamps from {@link CaptureResult#SENSOR_TIMESTAMP android.sensor.timestamp} are in the same timebase as\n     * {@link android.os.SystemClock#elapsedRealtimeNanos },\n     * and they can be compared to other timestamps using that base.</p>\n     * <p>When buffers from a REALTIME device are passed directly to a video encoder from the\n     * camera, automatic compensation is done to account for differing timebases of the\n     * audio and camera subsystems.  If the application is receiving buffers and then later\n     * sending them to a video encoder or other application where they are compared with\n     * audio subsystem timestamps or similar, this compensation is not present.  In those\n     * cases, applications need to adjust the timestamps themselves.  Since {@link android.os.SystemClock#elapsedRealtimeNanos } and {@link android.os.SystemClock#uptimeMillis } only diverge while the device is asleep, an\n     * offset between the two sources can be measured once per active session and applied\n     * to timestamps for sufficient accuracy for A/V sync.</p>\n     *\n     * @see CaptureResult#SENSOR_TIMESTAMP\n     * @see CameraCharacteristics#SENSOR_INFO_TIMESTAMP_SOURCE\n     ",
    "links" : [ "android.os.SystemClock#elapsedRealtimeNanos", "android.os.SystemClock#uptimeMillis", "android.hardware.camera2.CaptureResult#SENSOR_TIMESTAMP" ]
  }, {
    "name" : "SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT",
    "type" : "int",
    "comment" : "\n     * @see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_REFERENCE_ILLUMINANT1_FLUORESCENT",
    "type" : "int",
    "comment" : "\n     * @see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_REFERENCE_ILLUMINANT1_TUNGSTEN",
    "type" : "int",
    "comment" : "\n     * <p>Incandescent light</p>\n     * @see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_REFERENCE_ILLUMINANT1_FLASH",
    "type" : "int",
    "comment" : "\n     * @see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_REFERENCE_ILLUMINANT1_FINE_WEATHER",
    "type" : "int",
    "comment" : "\n     * @see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_REFERENCE_ILLUMINANT1_CLOUDY_WEATHER",
    "type" : "int",
    "comment" : "\n     * @see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_REFERENCE_ILLUMINANT1_SHADE",
    "type" : "int",
    "comment" : "\n     * @see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT_FLUORESCENT",
    "type" : "int",
    "comment" : "\n     * <p>D 5700 - 7100K</p>\n     * @see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_REFERENCE_ILLUMINANT1_DAY_WHITE_FLUORESCENT",
    "type" : "int",
    "comment" : "\n     * <p>N 4600 - 5400K</p>\n     * @see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_REFERENCE_ILLUMINANT1_COOL_WHITE_FLUORESCENT",
    "type" : "int",
    "comment" : "\n     * <p>W 3900 - 4500K</p>\n     * @see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_REFERENCE_ILLUMINANT1_WHITE_FLUORESCENT",
    "type" : "int",
    "comment" : "\n     * <p>WW 3200 - 3700K</p>\n     * @see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_REFERENCE_ILLUMINANT1_STANDARD_A",
    "type" : "int",
    "comment" : "\n     * @see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_REFERENCE_ILLUMINANT1_STANDARD_B",
    "type" : "int",
    "comment" : "\n     * @see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_REFERENCE_ILLUMINANT1_STANDARD_C",
    "type" : "int",
    "comment" : "\n     * @see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_REFERENCE_ILLUMINANT1_D55",
    "type" : "int",
    "comment" : "\n     * @see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_REFERENCE_ILLUMINANT1_D65",
    "type" : "int",
    "comment" : "\n     * @see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_REFERENCE_ILLUMINANT1_D75",
    "type" : "int",
    "comment" : "\n     * @see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_REFERENCE_ILLUMINANT1_D50",
    "type" : "int",
    "comment" : "\n     * @see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_REFERENCE_ILLUMINANT1_ISO_STUDIO_TUNGSTEN",
    "type" : "int",
    "comment" : "\n     * @see CameraCharacteristics#SENSOR_REFERENCE_ILLUMINANT1\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_READOUT_TIMESTAMP_NOT_SUPPORTED",
    "type" : "int",
    "comment" : "\n     * <p>This camera device doesn't support readout timestamp and onReadoutStarted\n     * callback.</p>\n     * @see CameraCharacteristics#SENSOR_READOUT_TIMESTAMP\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_READOUT_TIMESTAMP_HARDWARE",
    "type" : "int",
    "comment" : "\n     * <p>This camera device supports the onReadoutStarted callback as well as outputting\n     * readout timestamps. The readout timestamp is generated by the camera hardware and it\n     * has the same accuracy and timing characteristics of the start-of-exposure time.</p>\n     * @see CameraCharacteristics#SENSOR_READOUT_TIMESTAMP\n     ",
    "links" : [ ]
  }, {
    "name" : "LED_AVAILABLE_LEDS_TRANSMIT",
    "type" : "int",
    "comment" : "\n     * <p>android.led.transmit control is used.</p>\n     * @see CameraCharacteristics#LED_AVAILABLE_LEDS\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED",
    "type" : "int",
    "comment" : "\n     * <p>This camera device does not have enough capabilities to qualify as a <code>FULL</code> device or\n     * better.</p>\n     * <p>Only the stream configurations listed in the <code>LEGACY</code> and <code>LIMITED</code>\n     * <a href=\"https://developer.android.com/reference/android/hardware/camera2/CameraDevice#limited-level-additional-guaranteed-configurations\">tables</a>\n     * in the documentation are guaranteed to be supported.</p>\n     * <p>All <code>LIMITED</code> devices support the <code>BACKWARDS_COMPATIBLE</code> capability, indicating basic\n     * support for color image capture. The only exception is that the device may\n     * alternatively support only the <code>DEPTH_OUTPUT</code> capability, if it can only output depth\n     * measurements and not color images.</p>\n     * <p><code>LIMITED</code> devices and above require the use of {@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger}\n     * to lock exposure metering (and calculate flash power, for cameras with flash) before\n     * capturing a high-quality still image.</p>\n     * <p>A <code>LIMITED</code> device that only lists the <code>BACKWARDS_COMPATIBLE</code> capability is only\n     * required to support full-automatic operation and post-processing (<code>OFF</code> is not\n     * supported for {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode}, {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode}, or\n     * {@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode})</p>\n     * <p>Additional capabilities may optionally be supported by a <code>LIMITED</code>-level device, and\n     * can be checked for in {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities}.</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER\n     * @see CaptureRequest#CONTROL_AF_MODE\n     * @see CaptureRequest#CONTROL_AWB_MODE\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES", "android.hardware.camera2.CaptureRequest#CONTROL_AE_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_AF_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_AWB_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER" ]
  }, {
    "name" : "INFO_SUPPORTED_HARDWARE_LEVEL_FULL",
    "type" : "int",
    "comment" : "\n     * <p>This camera device is capable of supporting advanced imaging applications.</p>\n     * <p>The stream configurations listed in the <code>FULL</code>, <code>LEGACY</code> and <code>LIMITED</code>\n     * <a href=\"https://developer.android.com/reference/android/hardware/camera2/CameraDevice#full-level-additional-guaranteed-configurations\">tables</a>\n     * in the documentation are guaranteed to be supported.</p>\n     * <p>A <code>FULL</code> device will support below capabilities:</p>\n     * <ul>\n     * <li><code>BURST_CAPTURE</code> capability ({@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} contains\n     *   <code>BURST_CAPTURE</code>)</li>\n     * <li>Per frame control ({@link CameraCharacteristics#SYNC_MAX_LATENCY android.sync.maxLatency} <code>==</code> PER_FRAME_CONTROL)</li>\n     * <li>Manual sensor control ({@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} contains <code>MANUAL_SENSOR</code>)</li>\n     * <li>Manual post-processing control ({@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} contains\n     *   <code>MANUAL_POST_PROCESSING</code>)</li>\n     * <li>The required exposure time range defined in {@link CameraCharacteristics#SENSOR_INFO_EXPOSURE_TIME_RANGE android.sensor.info.exposureTimeRange}</li>\n     * <li>The required maxFrameDuration defined in {@link CameraCharacteristics#SENSOR_INFO_MAX_FRAME_DURATION android.sensor.info.maxFrameDuration}</li>\n     * </ul>\n     * <p>Note:\n     * Pre-API level 23, FULL devices also supported arbitrary cropping region\n     * ({@link CameraCharacteristics#SCALER_CROPPING_TYPE android.scaler.croppingType} <code>== FREEFORM</code>); this requirement was relaxed in API level\n     * 23, and <code>FULL</code> devices may only support <code>CENTERED</code> cropping.</p>\n     *\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     * @see CameraCharacteristics#SCALER_CROPPING_TYPE\n     * @see CameraCharacteristics#SENSOR_INFO_EXPOSURE_TIME_RANGE\n     * @see CameraCharacteristics#SENSOR_INFO_MAX_FRAME_DURATION\n     * @see CameraCharacteristics#SYNC_MAX_LATENCY\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_MAX_FRAME_DURATION", "android.hardware.camera2.CameraCharacteristics#SYNC_MAX_LATENCY", "android.hardware.camera2.CameraCharacteristics#SCALER_CROPPING_TYPE", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_EXPOSURE_TIME_RANGE" ]
  }, {
    "name" : "INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY",
    "type" : "int",
    "comment" : "\n     * <p>This camera device is running in backward compatibility mode.</p>\n     * <p>Only the stream configurations listed in the <code>LEGACY</code>\n     * <a href=\"https://developer.android.com/reference/android/hardware/camera2/CameraDevice#legacy-level-guaranteed-configurations\">table</a>\n     * in the documentation are supported.</p>\n     * <p>A <code>LEGACY</code> device does not support per-frame control, manual sensor control, manual\n     * post-processing, arbitrary cropping regions, and has relaxed performance constraints.\n     * No additional capabilities beyond <code>BACKWARD_COMPATIBLE</code> will ever be listed by a\n     * <code>LEGACY</code> device in {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities}.</p>\n     * <p>In addition, the {@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger} is not functional on <code>LEGACY</code>\n     * devices. Instead, every request that includes a JPEG-format output target is treated\n     * as triggering a still capture, internally executing a precapture trigger.  This may\n     * fire the flash for flash power metering during precapture, and then fire the flash\n     * for the final capture, if a flash is available on the device and the AE mode is set to\n     * enable the flash.</p>\n     * <p>Devices that initially shipped with Android version {@link android.os.Build.VERSION_CODES#Q Q} or newer will not include any LEGACY-level devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES", "android.os.Build.VERSION_CODES#Q", "android.hardware.camera2.CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER" ]
  }, {
    "name" : "INFO_SUPPORTED_HARDWARE_LEVEL_3",
    "type" : "int",
    "comment" : "\n     * <p>This camera device is capable of YUV reprocessing and RAW data capture, in addition to\n     * FULL-level capabilities.</p>\n     * <p>The stream configurations listed in the <code>LEVEL_3</code>, <code>RAW</code>, <code>FULL</code>, <code>LEGACY</code> and\n     * <code>LIMITED</code>\n     * <a href=\"https://developer.android.com/reference/android/hardware/camera2/CameraDevice#level-3-additional-guaranteed-configurations\">tables</a>\n     * in the documentation are guaranteed to be supported.</p>\n     * <p>The following additional capabilities are guaranteed to be supported:</p>\n     * <ul>\n     * <li><code>YUV_REPROCESSING</code> capability ({@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} contains\n     *   <code>YUV_REPROCESSING</code>)</li>\n     * <li><code>RAW</code> capability ({@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} contains\n     *   <code>RAW</code>)</li>\n     * </ul>\n     *\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES" ]
  }, {
    "name" : "INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL",
    "type" : "int",
    "comment" : "\n     * <p>This camera device is backed by an external camera connected to this Android device.</p>\n     * <p>The device has capability identical to a LIMITED level device, with the following\n     * exceptions:</p>\n     * <ul>\n     * <li>The device may not report lens/sensor related information such as<ul>\n     * <li>{@link CaptureRequest#LENS_FOCAL_LENGTH android.lens.focalLength}</li>\n     * <li>{@link CameraCharacteristics#LENS_INFO_HYPERFOCAL_DISTANCE android.lens.info.hyperfocalDistance}</li>\n     * <li>{@link CameraCharacteristics#SENSOR_INFO_PHYSICAL_SIZE android.sensor.info.physicalSize}</li>\n     * <li>{@link CameraCharacteristics#SENSOR_INFO_WHITE_LEVEL android.sensor.info.whiteLevel}</li>\n     * <li>{@link CameraCharacteristics#SENSOR_BLACK_LEVEL_PATTERN android.sensor.blackLevelPattern}</li>\n     * <li>{@link CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT android.sensor.info.colorFilterArrangement}</li>\n     * <li>{@link CaptureResult#SENSOR_ROLLING_SHUTTER_SKEW android.sensor.rollingShutterSkew}</li>\n     * </ul>\n     * </li>\n     * <li>The device will report 0 for {@link CameraCharacteristics#SENSOR_ORIENTATION android.sensor.orientation}</li>\n     * <li>The device has less guarantee on stable framerate, as the framerate partly depends\n     *   on the external camera being used.</li>\n     * </ul>\n     *\n     * @see CaptureRequest#LENS_FOCAL_LENGTH\n     * @see CameraCharacteristics#LENS_INFO_HYPERFOCAL_DISTANCE\n     * @see CameraCharacteristics#SENSOR_BLACK_LEVEL_PATTERN\n     * @see CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT\n     * @see CameraCharacteristics#SENSOR_INFO_PHYSICAL_SIZE\n     * @see CameraCharacteristics#SENSOR_INFO_WHITE_LEVEL\n     * @see CameraCharacteristics#SENSOR_ORIENTATION\n     * @see CaptureResult#SENSOR_ROLLING_SHUTTER_SKEW\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_WHITE_LEVEL", "android.hardware.camera2.CaptureRequest#LENS_FOCAL_LENGTH", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_PHYSICAL_SIZE", "android.hardware.camera2.CameraCharacteristics#SENSOR_ORIENTATION", "android.hardware.camera2.CameraCharacteristics#LENS_INFO_HYPERFOCAL_DISTANCE", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT", "android.hardware.camera2.CaptureResult#SENSOR_ROLLING_SHUTTER_SKEW", "android.hardware.camera2.CameraCharacteristics#SENSOR_BLACK_LEVEL_PATTERN" ]
  }, {
    "name" : "SYNC_MAX_LATENCY_PER_FRAME_CONTROL",
    "type" : "int",
    "comment" : "\n     * <p>Every frame has the requests immediately applied.</p>\n     * <p>Changing controls over multiple requests one after another will\n     * produce results that have those controls applied atomically\n     * each frame.</p>\n     * <p>All FULL capability devices will have this as their maxLatency.</p>\n     * @see CameraCharacteristics#SYNC_MAX_LATENCY\n     ",
    "links" : [ ]
  }, {
    "name" : "SYNC_MAX_LATENCY_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * <p>Each new frame has some subset (potentially the entire set)\n     * of the past requests applied to the camera settings.</p>\n     * <p>By submitting a series of identical requests, the camera device\n     * will eventually have the camera settings applied, but it is\n     * unknown when that exact point will be.</p>\n     * <p>All LEGACY capability devices will have this as their maxLatency.</p>\n     * @see CameraCharacteristics#SYNC_MAX_LATENCY\n     ",
    "links" : [ ]
  }, {
    "name" : "LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_APPROXIMATE",
    "type" : "int",
    "comment" : "\n     * <p>A software mechanism is used to synchronize between the physical cameras. As a result,\n     * the timestamp of an image from a physical stream is only an approximation of the\n     * image sensor start-of-exposure time.</p>\n     * @see CameraCharacteristics#LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE\n     ",
    "links" : [ ]
  }, {
    "name" : "LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_CALIBRATED",
    "type" : "int",
    "comment" : "\n     * <p>The camera device supports frame timestamp synchronization at the hardware level,\n     * and the timestamp of a physical stream image accurately reflects its\n     * start-of-exposure time.</p>\n     * @see CameraCharacteristics#LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTOMOTIVE_LENS_FACING_EXTERIOR_OTHER",
    "type" : "int",
    "comment" : "\n     * <p>The camera device faces the outside of the vehicle body frame but not exactly\n     * one of the exterior sides defined by this enum.  Applications should determine\n     * the exact facing direction from {@link CameraCharacteristics#LENS_POSE_ROTATION android.lens.poseRotation} and\n     * {@link CameraCharacteristics#LENS_POSE_TRANSLATION android.lens.poseTranslation}.</p>\n     *\n     * @see CameraCharacteristics#LENS_POSE_ROTATION\n     * @see CameraCharacteristics#LENS_POSE_TRANSLATION\n     * @see CameraCharacteristics#AUTOMOTIVE_LENS_FACING\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#LENS_POSE_ROTATION", "android.hardware.camera2.CameraCharacteristics#LENS_POSE_TRANSLATION" ]
  }, {
    "name" : "AUTOMOTIVE_LENS_FACING_EXTERIOR_FRONT",
    "type" : "int",
    "comment" : "\n     * <p>The camera device faces the front of the vehicle body frame.</p>\n     * @see CameraCharacteristics#AUTOMOTIVE_LENS_FACING\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTOMOTIVE_LENS_FACING_EXTERIOR_REAR",
    "type" : "int",
    "comment" : "\n     * <p>The camera device faces the rear of the vehicle body frame.</p>\n     * @see CameraCharacteristics#AUTOMOTIVE_LENS_FACING\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTOMOTIVE_LENS_FACING_EXTERIOR_LEFT",
    "type" : "int",
    "comment" : "\n     * <p>The camera device faces the left side of the vehicle body frame.</p>\n     * @see CameraCharacteristics#AUTOMOTIVE_LENS_FACING\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTOMOTIVE_LENS_FACING_EXTERIOR_RIGHT",
    "type" : "int",
    "comment" : "\n     * <p>The camera device faces the right side of the vehicle body frame.</p>\n     * @see CameraCharacteristics#AUTOMOTIVE_LENS_FACING\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTOMOTIVE_LENS_FACING_INTERIOR_OTHER",
    "type" : "int",
    "comment" : "\n     * <p>The camera device faces the inside of the vehicle body frame but not exactly\n     * one of seats described by this enum.  Applications should determine the exact\n     * facing direction from {@link CameraCharacteristics#LENS_POSE_ROTATION android.lens.poseRotation} and {@link CameraCharacteristics#LENS_POSE_TRANSLATION android.lens.poseTranslation}.</p>\n     *\n     * @see CameraCharacteristics#LENS_POSE_ROTATION\n     * @see CameraCharacteristics#LENS_POSE_TRANSLATION\n     * @see CameraCharacteristics#AUTOMOTIVE_LENS_FACING\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#LENS_POSE_ROTATION", "android.hardware.camera2.CameraCharacteristics#LENS_POSE_TRANSLATION" ]
  }, {
    "name" : "AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_1_LEFT",
    "type" : "int",
    "comment" : "\n     * <p>The camera device faces the left side seat of the first row.</p>\n     * @see CameraCharacteristics#AUTOMOTIVE_LENS_FACING\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_1_CENTER",
    "type" : "int",
    "comment" : "\n     * <p>The camera device faces the center seat of the first row.</p>\n     * @see CameraCharacteristics#AUTOMOTIVE_LENS_FACING\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_1_RIGHT",
    "type" : "int",
    "comment" : "\n     * <p>The camera device faces the right seat of the first row.</p>\n     * @see CameraCharacteristics#AUTOMOTIVE_LENS_FACING\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_2_LEFT",
    "type" : "int",
    "comment" : "\n     * <p>The camera device faces the left side seat of the second row.</p>\n     * @see CameraCharacteristics#AUTOMOTIVE_LENS_FACING\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_2_CENTER",
    "type" : "int",
    "comment" : "\n     * <p>The camera device faces the center seat of the second row.</p>\n     * @see CameraCharacteristics#AUTOMOTIVE_LENS_FACING\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_2_RIGHT",
    "type" : "int",
    "comment" : "\n     * <p>The camera device faces the right side seat of the second row.</p>\n     * @see CameraCharacteristics#AUTOMOTIVE_LENS_FACING\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_3_LEFT",
    "type" : "int",
    "comment" : "\n     * <p>The camera device faces the left side seat of the third row.</p>\n     * @see CameraCharacteristics#AUTOMOTIVE_LENS_FACING\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_3_CENTER",
    "type" : "int",
    "comment" : "\n     * <p>The camera device faces the center seat of the third row.</p>\n     * @see CameraCharacteristics#AUTOMOTIVE_LENS_FACING\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_3_RIGHT",
    "type" : "int",
    "comment" : "\n     * <p>The camera device faces the right seat of the third row.</p>\n     * @see CameraCharacteristics#AUTOMOTIVE_LENS_FACING\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTOMOTIVE_LOCATION_INTERIOR",
    "type" : "int",
    "comment" : "\n     * <p>The camera device exists inside of the vehicle cabin.</p>\n     * @see CameraCharacteristics#AUTOMOTIVE_LOCATION\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTOMOTIVE_LOCATION_EXTERIOR_OTHER",
    "type" : "int",
    "comment" : "\n     * <p>The camera exists outside of the vehicle body frame but not exactly on one of the\n     * exterior locations this enum defines.  The applications should determine the exact\n     * location from {@link CameraCharacteristics#LENS_POSE_TRANSLATION android.lens.poseTranslation}.</p>\n     *\n     * @see CameraCharacteristics#LENS_POSE_TRANSLATION\n     * @see CameraCharacteristics#AUTOMOTIVE_LOCATION\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#LENS_POSE_TRANSLATION" ]
  }, {
    "name" : "AUTOMOTIVE_LOCATION_EXTERIOR_FRONT",
    "type" : "int",
    "comment" : "\n     * <p>The camera device exists outside of the vehicle body frame and on its front side.</p>\n     * @see CameraCharacteristics#AUTOMOTIVE_LOCATION\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTOMOTIVE_LOCATION_EXTERIOR_REAR",
    "type" : "int",
    "comment" : "\n     * <p>The camera device exists outside of the vehicle body frame and on its rear side.</p>\n     * @see CameraCharacteristics#AUTOMOTIVE_LOCATION\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTOMOTIVE_LOCATION_EXTERIOR_LEFT",
    "type" : "int",
    "comment" : "\n     * <p>The camera device exists outside and on left side of the vehicle body frame.</p>\n     * @see CameraCharacteristics#AUTOMOTIVE_LOCATION\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTOMOTIVE_LOCATION_EXTERIOR_RIGHT",
    "type" : "int",
    "comment" : "\n     * <p>The camera device exists outside and on right side of the vehicle body frame.</p>\n     * @see CameraCharacteristics#AUTOMOTIVE_LOCATION\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTOMOTIVE_LOCATION_EXTRA_OTHER",
    "type" : "int",
    "comment" : "\n     * <p>The camera device exists on an extra vehicle, such as the trailer, but not exactly\n     * on one of front, rear, left, or right side.  Applications should determine the exact\n     * location from {@link CameraCharacteristics#LENS_POSE_TRANSLATION android.lens.poseTranslation}.</p>\n     *\n     * @see CameraCharacteristics#LENS_POSE_TRANSLATION\n     * @see CameraCharacteristics#AUTOMOTIVE_LOCATION\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#LENS_POSE_TRANSLATION" ]
  }, {
    "name" : "AUTOMOTIVE_LOCATION_EXTRA_FRONT",
    "type" : "int",
    "comment" : "\n     * <p>The camera device exists outside of the extra vehicle's body frame and on its front\n     * side.</p>\n     * @see CameraCharacteristics#AUTOMOTIVE_LOCATION\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTOMOTIVE_LOCATION_EXTRA_REAR",
    "type" : "int",
    "comment" : "\n     * <p>The camera device exists outside of the extra vehicle's body frame and on its rear\n     * side.</p>\n     * @see CameraCharacteristics#AUTOMOTIVE_LOCATION\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTOMOTIVE_LOCATION_EXTRA_LEFT",
    "type" : "int",
    "comment" : "\n     * <p>The camera device exists outside and on left side of the extra vehicle body.</p>\n     * @see CameraCharacteristics#AUTOMOTIVE_LOCATION\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTOMOTIVE_LOCATION_EXTRA_RIGHT",
    "type" : "int",
    "comment" : "\n     * <p>The camera device exists outside and on right side of the extra vehicle body.</p>\n     * @see CameraCharacteristics#AUTOMOTIVE_LOCATION\n     ",
    "links" : [ ]
  }, {
    "name" : "COLOR_CORRECTION_MODE_TRANSFORM_MATRIX",
    "type" : "int",
    "comment" : "\n     * <p>Use the {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform} matrix\n     * and {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} to do color conversion.</p>\n     * <p>All advanced white balance adjustments (not specified\n     * by our white balance pipeline) must be disabled.</p>\n     * <p>If AWB is enabled with <code>{@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode} != OFF</code>, then\n     * TRANSFORM_MATRIX is ignored. The camera device will override\n     * this value to either FAST or HIGH_QUALITY.</p>\n     *\n     * @see CaptureRequest#COLOR_CORRECTION_GAINS\n     * @see CaptureRequest#COLOR_CORRECTION_TRANSFORM\n     * @see CaptureRequest#CONTROL_AWB_MODE\n     * @see CaptureRequest#COLOR_CORRECTION_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#CONTROL_AWB_MODE", "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_GAINS", "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_TRANSFORM" ]
  }, {
    "name" : "COLOR_CORRECTION_MODE_FAST",
    "type" : "int",
    "comment" : "\n     * <p>Color correction processing must not slow down\n     * capture rate relative to sensor raw output.</p>\n     * <p>Advanced white balance adjustments above and beyond\n     * the specified white balance pipeline may be applied.</p>\n     * <p>If AWB is enabled with <code>{@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode} != OFF</code>, then\n     * the camera device uses the last frame's AWB values\n     * (or defaults if AWB has never been run).</p>\n     *\n     * @see CaptureRequest#CONTROL_AWB_MODE\n     * @see CaptureRequest#COLOR_CORRECTION_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#CONTROL_AWB_MODE" ]
  }, {
    "name" : "COLOR_CORRECTION_MODE_HIGH_QUALITY",
    "type" : "int",
    "comment" : "\n     * <p>Color correction processing operates at improved\n     * quality but the capture rate might be reduced (relative to sensor\n     * raw output rate)</p>\n     * <p>Advanced white balance adjustments above and beyond\n     * the specified white balance pipeline may be applied.</p>\n     * <p>If AWB is enabled with <code>{@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode} != OFF</code>, then\n     * the camera device uses the last frame's AWB values\n     * (or defaults if AWB has never been run).</p>\n     *\n     * @see CaptureRequest#CONTROL_AWB_MODE\n     * @see CaptureRequest#COLOR_CORRECTION_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#CONTROL_AWB_MODE" ]
  }, {
    "name" : "COLOR_CORRECTION_ABERRATION_MODE_OFF",
    "type" : "int",
    "comment" : "\n     * <p>No aberration correction is applied.</p>\n     * @see CaptureRequest#COLOR_CORRECTION_ABERRATION_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "COLOR_CORRECTION_ABERRATION_MODE_FAST",
    "type" : "int",
    "comment" : "\n     * <p>Aberration correction will not slow down capture rate\n     * relative to sensor raw output.</p>\n     * @see CaptureRequest#COLOR_CORRECTION_ABERRATION_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY",
    "type" : "int",
    "comment" : "\n     * <p>Aberration correction operates at improved quality but the capture rate might be\n     * reduced (relative to sensor raw output rate)</p>\n     * @see CaptureRequest#COLOR_CORRECTION_ABERRATION_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AE_ANTIBANDING_MODE_OFF",
    "type" : "int",
    "comment" : "\n     * <p>The camera device will not adjust exposure duration to\n     * avoid banding problems.</p>\n     * @see CaptureRequest#CONTROL_AE_ANTIBANDING_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AE_ANTIBANDING_MODE_50HZ",
    "type" : "int",
    "comment" : "\n     * <p>The camera device will adjust exposure duration to\n     * avoid banding problems with 50Hz illumination sources.</p>\n     * @see CaptureRequest#CONTROL_AE_ANTIBANDING_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AE_ANTIBANDING_MODE_60HZ",
    "type" : "int",
    "comment" : "\n     * <p>The camera device will adjust exposure duration to\n     * avoid banding problems with 60Hz illumination\n     * sources.</p>\n     * @see CaptureRequest#CONTROL_AE_ANTIBANDING_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AE_ANTIBANDING_MODE_AUTO",
    "type" : "int",
    "comment" : "\n     * <p>The camera device will automatically adapt its\n     * antibanding routine to the current illumination\n     * condition. This is the default mode if AUTO is\n     * available on given camera device.</p>\n     * @see CaptureRequest#CONTROL_AE_ANTIBANDING_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AE_MODE_OFF",
    "type" : "int",
    "comment" : "\n     * <p>The camera device's autoexposure routine is disabled.</p>\n     * <p>The application-selected {@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime},\n     * {@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity} and\n     * {@link CaptureRequest#SENSOR_FRAME_DURATION android.sensor.frameDuration} are used by the camera\n     * device, along with android.flash.* fields, if there's\n     * a flash unit for this camera device.</p>\n     * <p>Note that auto-white balance (AWB) and auto-focus (AF)\n     * behavior is device dependent when AE is in OFF mode.\n     * To have consistent behavior across different devices,\n     * it is recommended to either set AWB and AF to OFF mode\n     * or lock AWB and AF before setting AE to OFF.\n     * See {@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode}, {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode},\n     * {@link CaptureRequest#CONTROL_AWB_LOCK android.control.awbLock}, and {@link CaptureRequest#CONTROL_AF_TRIGGER android.control.afTrigger}\n     * for more details.</p>\n     * <p>LEGACY devices do not support the OFF mode and will\n     * override attempts to use this value to ON.</p>\n     *\n     * @see CaptureRequest#CONTROL_AF_MODE\n     * @see CaptureRequest#CONTROL_AF_TRIGGER\n     * @see CaptureRequest#CONTROL_AWB_LOCK\n     * @see CaptureRequest#CONTROL_AWB_MODE\n     * @see CaptureRequest#SENSOR_EXPOSURE_TIME\n     * @see CaptureRequest#SENSOR_FRAME_DURATION\n     * @see CaptureRequest#SENSOR_SENSITIVITY\n     * @see CaptureRequest#CONTROL_AE_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#SENSOR_SENSITIVITY", "android.hardware.camera2.CaptureRequest#SENSOR_FRAME_DURATION", "android.hardware.camera2.CaptureRequest#CONTROL_AF_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_AWB_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_AWB_LOCK", "android.hardware.camera2.CaptureRequest#CONTROL_AF_TRIGGER", "android.hardware.camera2.CaptureRequest#SENSOR_EXPOSURE_TIME" ]
  }, {
    "name" : "CONTROL_AE_MODE_ON",
    "type" : "int",
    "comment" : "\n     * <p>The camera device's autoexposure routine is active,\n     * with no flash control.</p>\n     * <p>The application's values for\n     * {@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime},\n     * {@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}, and\n     * {@link CaptureRequest#SENSOR_FRAME_DURATION android.sensor.frameDuration} are ignored. The\n     * application has control over the various\n     * android.flash.* fields.</p>\n     *\n     * @see CaptureRequest#SENSOR_EXPOSURE_TIME\n     * @see CaptureRequest#SENSOR_FRAME_DURATION\n     * @see CaptureRequest#SENSOR_SENSITIVITY\n     * @see CaptureRequest#CONTROL_AE_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#SENSOR_SENSITIVITY", "android.hardware.camera2.CaptureRequest#SENSOR_FRAME_DURATION", "android.hardware.camera2.CaptureRequest#SENSOR_EXPOSURE_TIME" ]
  }, {
    "name" : "CONTROL_AE_MODE_ON_AUTO_FLASH",
    "type" : "int",
    "comment" : "\n     * <p>Like ON, except that the camera device also controls\n     * the camera's flash unit, firing it in low-light\n     * conditions.</p>\n     * <p>The flash may be fired during a precapture sequence\n     * (triggered by {@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger}) and\n     * may be fired for captures for which the\n     * {@link CaptureRequest#CONTROL_CAPTURE_INTENT android.control.captureIntent} field is set to\n     * STILL_CAPTURE</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER\n     * @see CaptureRequest#CONTROL_CAPTURE_INTENT\n     * @see CaptureRequest#CONTROL_AE_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#CONTROL_CAPTURE_INTENT", "android.hardware.camera2.CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER" ]
  }, {
    "name" : "CONTROL_AE_MODE_ON_ALWAYS_FLASH",
    "type" : "int",
    "comment" : "\n     * <p>Like ON, except that the camera device also controls\n     * the camera's flash unit, always firing it for still\n     * captures.</p>\n     * <p>The flash may be fired during a precapture sequence\n     * (triggered by {@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger}) and\n     * will always be fired for captures for which the\n     * {@link CaptureRequest#CONTROL_CAPTURE_INTENT android.control.captureIntent} field is set to\n     * STILL_CAPTURE</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER\n     * @see CaptureRequest#CONTROL_CAPTURE_INTENT\n     * @see CaptureRequest#CONTROL_AE_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#CONTROL_CAPTURE_INTENT", "android.hardware.camera2.CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER" ]
  }, {
    "name" : "CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE",
    "type" : "int",
    "comment" : "\n     * <p>Like ON_AUTO_FLASH, but with automatic red eye\n     * reduction.</p>\n     * <p>If deemed necessary by the camera device, a red eye\n     * reduction flash will fire during the precapture\n     * sequence.</p>\n     * @see CaptureRequest#CONTROL_AE_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AE_MODE_ON_EXTERNAL_FLASH",
    "type" : "int",
    "comment" : "\n     * <p>An external flash has been turned on.</p>\n     * <p>It informs the camera device that an external flash has been turned on, and that\n     * metering (and continuous focus if active) should be quickly recalculated to account\n     * for the external flash. Otherwise, this mode acts like ON.</p>\n     * <p>When the external flash is turned off, AE mode should be changed to one of the\n     * other available AE modes.</p>\n     * <p>If the camera device supports AE external flash mode, {@link CaptureResult#CONTROL_AE_STATE android.control.aeState} must\n     * be FLASH_REQUIRED after the camera device finishes AE scan and it's too dark without\n     * flash.</p>\n     *\n     * @see CaptureResult#CONTROL_AE_STATE\n     * @see CaptureRequest#CONTROL_AE_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureResult#CONTROL_AE_STATE" ]
  }, {
    "name" : "CONTROL_AE_MODE_ON_LOW_LIGHT_BOOST_BRIGHTNESS_PRIORITY",
    "type" : "int",
    "comment" : "\n     * <p>Like 'ON' but applies additional brightness boost in low light scenes.</p>\n     * <p>When the scene lighting conditions are within the range defined by\n     * {@link CameraCharacteristics#CONTROL_LOW_LIGHT_BOOST_INFO_LUMINANCE_RANGE android.control.lowLightBoostInfoLuminanceRange} this mode will apply additional\n     * brightness boost.</p>\n     * <p>This mode will automatically adjust the intensity of low light boost applied\n     * according to the scene lighting conditions. A darker scene will receive more boost\n     * while a brighter scene will receive less boost.</p>\n     * <p>This mode can ignore the set target frame rate to allow more light to be captured\n     * which can result in choppier motion. The frame rate can extend to lower than the\n     * {@link CameraCharacteristics#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES android.control.aeAvailableTargetFpsRanges} but will not go below 10 FPS. This mode\n     * can also increase the sensor sensitivity gain which can result in increased luma\n     * and chroma noise. The sensor sensitivity gain can extend to higher values beyond\n     * {@link CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE android.sensor.info.sensitivityRange}. This mode may also apply additional\n     * processing to recover details in dark and bright areas of the image,and noise\n     * reduction at high sensitivity gain settings to manage the trade-off between light\n     * sensitivity and capture noise.</p>\n     * <p>This mode is restricted to two output surfaces. One output surface type can either\n     * be SurfaceView or TextureView. Another output surface type can either be MediaCodec\n     * or MediaRecorder. This mode cannot be used with a target FPS range higher than 30\n     * FPS.</p>\n     * <p>If the session configuration is not supported, the AE mode reported in the\n     * CaptureResult will be 'ON' instead of 'ON_LOW_LIGHT_BOOST_BRIGHTNESS_PRIORITY'.</p>\n     * <p>When this AE mode is enabled, the CaptureResult field\n     * {@link CaptureResult#CONTROL_LOW_LIGHT_BOOST_STATE android.control.lowLightBoostState} will be present and not null. Otherwise, the\n     * {@link CaptureResult#CONTROL_LOW_LIGHT_BOOST_STATE android.control.lowLightBoostState} field will not be present in the CaptureResult.</p>\n     * <p>The application can observe the CaptureResult field\n     * {@link CaptureResult#CONTROL_LOW_LIGHT_BOOST_STATE android.control.lowLightBoostState} to determine when low light boost is 'ACTIVE' or\n     * 'INACTIVE'.</p>\n     * <p>The low light boost is 'ACTIVE' once the scene lighting condition is less than the\n     * upper bound lux value defined by {@link CameraCharacteristics#CONTROL_LOW_LIGHT_BOOST_INFO_LUMINANCE_RANGE android.control.lowLightBoostInfoLuminanceRange}.\n     * This mode will be 'INACTIVE' once the scene lighting condition is greater than the\n     * upper bound lux value defined by {@link CameraCharacteristics#CONTROL_LOW_LIGHT_BOOST_INFO_LUMINANCE_RANGE android.control.lowLightBoostInfoLuminanceRange}.</p>\n     *\n     * @see CameraCharacteristics#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES\n     * @see CameraCharacteristics#CONTROL_LOW_LIGHT_BOOST_INFO_LUMINANCE_RANGE\n     * @see CaptureResult#CONTROL_LOW_LIGHT_BOOST_STATE\n     * @see CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE\n     * @see CaptureRequest#CONTROL_AE_MODE\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE", "android.hardware.camera2.CaptureResult#CONTROL_LOW_LIGHT_BOOST_STATE", "android.hardware.camera2.CameraCharacteristics#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES", "android.hardware.camera2.CameraCharacteristics#CONTROL_LOW_LIGHT_BOOST_INFO_LUMINANCE_RANGE" ]
  }, {
    "name" : "CONTROL_AE_PRECAPTURE_TRIGGER_IDLE",
    "type" : "int",
    "comment" : "\n     * <p>The trigger is idle.</p>\n     * @see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AE_PRECAPTURE_TRIGGER_START",
    "type" : "int",
    "comment" : "\n     * <p>The precapture metering sequence will be started\n     * by the camera device.</p>\n     * <p>The exact effect of the precapture trigger depends on\n     * the current AE mode and state.</p>\n     * @see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AE_PRECAPTURE_TRIGGER_CANCEL",
    "type" : "int",
    "comment" : "\n     * <p>The camera device will cancel any currently active or completed\n     * precapture metering sequence, the auto-exposure routine will return to its\n     * initial state.</p>\n     * @see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AF_MODE_OFF",
    "type" : "int",
    "comment" : "\n     * <p>The auto-focus routine does not control the lens;\n     * {@link CaptureRequest#LENS_FOCUS_DISTANCE android.lens.focusDistance} is controlled by the\n     * application.</p>\n     *\n     * @see CaptureRequest#LENS_FOCUS_DISTANCE\n     * @see CaptureRequest#CONTROL_AF_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#LENS_FOCUS_DISTANCE" ]
  }, {
    "name" : "CONTROL_AF_MODE_AUTO",
    "type" : "int",
    "comment" : "\n     * <p>Basic automatic focus mode.</p>\n     * <p>In this mode, the lens does not move unless\n     * the autofocus trigger action is called. When that trigger\n     * is activated, AF will transition to ACTIVE_SCAN, then to\n     * the outcome of the scan (FOCUSED or NOT_FOCUSED).</p>\n     * <p>Always supported if lens is not fixed focus.</p>\n     * <p>Use {@link CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE android.lens.info.minimumFocusDistance} to determine if lens\n     * is fixed-focus.</p>\n     * <p>Triggering AF_CANCEL resets the lens position to default,\n     * and sets the AF state to INACTIVE.</p>\n     *\n     * @see CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE\n     * @see CaptureRequest#CONTROL_AF_MODE\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE" ]
  }, {
    "name" : "CONTROL_AF_MODE_MACRO",
    "type" : "int",
    "comment" : "\n     * <p>Close-up focusing mode.</p>\n     * <p>In this mode, the lens does not move unless the\n     * autofocus trigger action is called. When that trigger is\n     * activated, AF will transition to ACTIVE_SCAN, then to\n     * the outcome of the scan (FOCUSED or NOT_FOCUSED). This\n     * mode is optimized for focusing on objects very close to\n     * the camera.</p>\n     * <p>When that trigger is activated, AF will transition to\n     * ACTIVE_SCAN, then to the outcome of the scan (FOCUSED or\n     * NOT_FOCUSED). Triggering cancel AF resets the lens\n     * position to default, and sets the AF state to\n     * INACTIVE.</p>\n     * @see CaptureRequest#CONTROL_AF_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AF_MODE_CONTINUOUS_VIDEO",
    "type" : "int",
    "comment" : "\n     * <p>In this mode, the AF algorithm modifies the lens\n     * position continually to attempt to provide a\n     * constantly-in-focus image stream.</p>\n     * <p>The focusing behavior should be suitable for good quality\n     * video recording; typically this means slower focus\n     * movement and no overshoots. When the AF trigger is not\n     * involved, the AF algorithm should start in INACTIVE state,\n     * and then transition into PASSIVE_SCAN and PASSIVE_FOCUSED\n     * states as appropriate. When the AF trigger is activated,\n     * the algorithm should immediately transition into\n     * AF_FOCUSED or AF_NOT_FOCUSED as appropriate, and lock the\n     * lens position until a cancel AF trigger is received.</p>\n     * <p>Once cancel is received, the algorithm should transition\n     * back to INACTIVE and resume passive scan. Note that this\n     * behavior is not identical to CONTINUOUS_PICTURE, since an\n     * ongoing PASSIVE_SCAN must immediately be\n     * canceled.</p>\n     * @see CaptureRequest#CONTROL_AF_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AF_MODE_CONTINUOUS_PICTURE",
    "type" : "int",
    "comment" : "\n     * <p>In this mode, the AF algorithm modifies the lens\n     * position continually to attempt to provide a\n     * constantly-in-focus image stream.</p>\n     * <p>The focusing behavior should be suitable for still image\n     * capture; typically this means focusing as fast as\n     * possible. When the AF trigger is not involved, the AF\n     * algorithm should start in INACTIVE state, and then\n     * transition into PASSIVE_SCAN and PASSIVE_FOCUSED states as\n     * appropriate as it attempts to maintain focus. When the AF\n     * trigger is activated, the algorithm should finish its\n     * PASSIVE_SCAN if active, and then transition into\n     * AF_FOCUSED or AF_NOT_FOCUSED as appropriate, and lock the\n     * lens position until a cancel AF trigger is received.</p>\n     * <p>When the AF cancel trigger is activated, the algorithm\n     * should transition back to INACTIVE and then act as if it\n     * has just been started.</p>\n     * @see CaptureRequest#CONTROL_AF_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AF_MODE_EDOF",
    "type" : "int",
    "comment" : "\n     * <p>Extended depth of field (digital focus) mode.</p>\n     * <p>The camera device will produce images with an extended\n     * depth of field automatically; no special focusing\n     * operations need to be done before taking a picture.</p>\n     * <p>AF triggers are ignored, and the AF state will always be\n     * INACTIVE.</p>\n     * @see CaptureRequest#CONTROL_AF_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AF_TRIGGER_IDLE",
    "type" : "int",
    "comment" : "\n     * <p>The trigger is idle.</p>\n     * @see CaptureRequest#CONTROL_AF_TRIGGER\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AF_TRIGGER_START",
    "type" : "int",
    "comment" : "\n     * <p>Autofocus will trigger now.</p>\n     * @see CaptureRequest#CONTROL_AF_TRIGGER\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AF_TRIGGER_CANCEL",
    "type" : "int",
    "comment" : "\n     * <p>Autofocus will return to its initial\n     * state, and cancel any currently active trigger.</p>\n     * @see CaptureRequest#CONTROL_AF_TRIGGER\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AWB_MODE_OFF",
    "type" : "int",
    "comment" : "\n     * <p>The camera device's auto-white balance routine is disabled.</p>\n     * <p>The application-selected color transform matrix\n     * ({@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}) and gains\n     * ({@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains}) are used by the camera\n     * device for manual white balance control.</p>\n     *\n     * @see CaptureRequest#COLOR_CORRECTION_GAINS\n     * @see CaptureRequest#COLOR_CORRECTION_TRANSFORM\n     * @see CaptureRequest#CONTROL_AWB_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_GAINS", "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_TRANSFORM" ]
  }, {
    "name" : "CONTROL_AWB_MODE_AUTO",
    "type" : "int",
    "comment" : "\n     * <p>The camera device's auto-white balance routine is active.</p>\n     * <p>The application's values for {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}\n     * and {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} are ignored.\n     * For devices that support the MANUAL_POST_PROCESSING capability, the\n     * values used by the camera device for the transform and gains\n     * will be available in the capture result for this request.</p>\n     *\n     * @see CaptureRequest#COLOR_CORRECTION_GAINS\n     * @see CaptureRequest#COLOR_CORRECTION_TRANSFORM\n     * @see CaptureRequest#CONTROL_AWB_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_GAINS", "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_TRANSFORM" ]
  }, {
    "name" : "CONTROL_AWB_MODE_INCANDESCENT",
    "type" : "int",
    "comment" : "\n     * <p>The camera device's auto-white balance routine is disabled;\n     * the camera device uses incandescent light as the assumed scene\n     * illumination for white balance.</p>\n     * <p>While the exact white balance transforms are up to the\n     * camera device, they will approximately match the CIE\n     * standard illuminant A.</p>\n     * <p>The application's values for {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}\n     * and {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} are ignored.\n     * For devices that support the MANUAL_POST_PROCESSING capability, the\n     * values used by the camera device for the transform and gains\n     * will be available in the capture result for this request.</p>\n     *\n     * @see CaptureRequest#COLOR_CORRECTION_GAINS\n     * @see CaptureRequest#COLOR_CORRECTION_TRANSFORM\n     * @see CaptureRequest#CONTROL_AWB_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_GAINS", "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_TRANSFORM" ]
  }, {
    "name" : "CONTROL_AWB_MODE_FLUORESCENT",
    "type" : "int",
    "comment" : "\n     * <p>The camera device's auto-white balance routine is disabled;\n     * the camera device uses fluorescent light as the assumed scene\n     * illumination for white balance.</p>\n     * <p>While the exact white balance transforms are up to the\n     * camera device, they will approximately match the CIE\n     * standard illuminant F2.</p>\n     * <p>The application's values for {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}\n     * and {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} are ignored.\n     * For devices that support the MANUAL_POST_PROCESSING capability, the\n     * values used by the camera device for the transform and gains\n     * will be available in the capture result for this request.</p>\n     *\n     * @see CaptureRequest#COLOR_CORRECTION_GAINS\n     * @see CaptureRequest#COLOR_CORRECTION_TRANSFORM\n     * @see CaptureRequest#CONTROL_AWB_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_GAINS", "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_TRANSFORM" ]
  }, {
    "name" : "CONTROL_AWB_MODE_WARM_FLUORESCENT",
    "type" : "int",
    "comment" : "\n     * <p>The camera device's auto-white balance routine is disabled;\n     * the camera device uses warm fluorescent light as the assumed scene\n     * illumination for white balance.</p>\n     * <p>While the exact white balance transforms are up to the\n     * camera device, they will approximately match the CIE\n     * standard illuminant F4.</p>\n     * <p>The application's values for {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}\n     * and {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} are ignored.\n     * For devices that support the MANUAL_POST_PROCESSING capability, the\n     * values used by the camera device for the transform and gains\n     * will be available in the capture result for this request.</p>\n     *\n     * @see CaptureRequest#COLOR_CORRECTION_GAINS\n     * @see CaptureRequest#COLOR_CORRECTION_TRANSFORM\n     * @see CaptureRequest#CONTROL_AWB_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_GAINS", "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_TRANSFORM" ]
  }, {
    "name" : "CONTROL_AWB_MODE_DAYLIGHT",
    "type" : "int",
    "comment" : "\n     * <p>The camera device's auto-white balance routine is disabled;\n     * the camera device uses daylight light as the assumed scene\n     * illumination for white balance.</p>\n     * <p>While the exact white balance transforms are up to the\n     * camera device, they will approximately match the CIE\n     * standard illuminant D65.</p>\n     * <p>The application's values for {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}\n     * and {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} are ignored.\n     * For devices that support the MANUAL_POST_PROCESSING capability, the\n     * values used by the camera device for the transform and gains\n     * will be available in the capture result for this request.</p>\n     *\n     * @see CaptureRequest#COLOR_CORRECTION_GAINS\n     * @see CaptureRequest#COLOR_CORRECTION_TRANSFORM\n     * @see CaptureRequest#CONTROL_AWB_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_GAINS", "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_TRANSFORM" ]
  }, {
    "name" : "CONTROL_AWB_MODE_CLOUDY_DAYLIGHT",
    "type" : "int",
    "comment" : "\n     * <p>The camera device's auto-white balance routine is disabled;\n     * the camera device uses cloudy daylight light as the assumed scene\n     * illumination for white balance.</p>\n     * <p>The application's values for {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}\n     * and {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} are ignored.\n     * For devices that support the MANUAL_POST_PROCESSING capability, the\n     * values used by the camera device for the transform and gains\n     * will be available in the capture result for this request.</p>\n     *\n     * @see CaptureRequest#COLOR_CORRECTION_GAINS\n     * @see CaptureRequest#COLOR_CORRECTION_TRANSFORM\n     * @see CaptureRequest#CONTROL_AWB_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_GAINS", "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_TRANSFORM" ]
  }, {
    "name" : "CONTROL_AWB_MODE_TWILIGHT",
    "type" : "int",
    "comment" : "\n     * <p>The camera device's auto-white balance routine is disabled;\n     * the camera device uses twilight light as the assumed scene\n     * illumination for white balance.</p>\n     * <p>The application's values for {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}\n     * and {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} are ignored.\n     * For devices that support the MANUAL_POST_PROCESSING capability, the\n     * values used by the camera device for the transform and gains\n     * will be available in the capture result for this request.</p>\n     *\n     * @see CaptureRequest#COLOR_CORRECTION_GAINS\n     * @see CaptureRequest#COLOR_CORRECTION_TRANSFORM\n     * @see CaptureRequest#CONTROL_AWB_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_GAINS", "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_TRANSFORM" ]
  }, {
    "name" : "CONTROL_AWB_MODE_SHADE",
    "type" : "int",
    "comment" : "\n     * <p>The camera device's auto-white balance routine is disabled;\n     * the camera device uses shade light as the assumed scene\n     * illumination for white balance.</p>\n     * <p>The application's values for {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}\n     * and {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} are ignored.\n     * For devices that support the MANUAL_POST_PROCESSING capability, the\n     * values used by the camera device for the transform and gains\n     * will be available in the capture result for this request.</p>\n     *\n     * @see CaptureRequest#COLOR_CORRECTION_GAINS\n     * @see CaptureRequest#COLOR_CORRECTION_TRANSFORM\n     * @see CaptureRequest#CONTROL_AWB_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_GAINS", "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_TRANSFORM" ]
  }, {
    "name" : "CONTROL_CAPTURE_INTENT_CUSTOM",
    "type" : "int",
    "comment" : "\n     * <p>The goal of this request doesn't fall into the other\n     * categories. The camera device will default to preview-like\n     * behavior.</p>\n     * @see CaptureRequest#CONTROL_CAPTURE_INTENT\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_CAPTURE_INTENT_PREVIEW",
    "type" : "int",
    "comment" : "\n     * <p>This request is for a preview-like use case.</p>\n     * <p>The precapture trigger may be used to start off a metering\n     * w/flash sequence.</p>\n     * @see CaptureRequest#CONTROL_CAPTURE_INTENT\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_CAPTURE_INTENT_STILL_CAPTURE",
    "type" : "int",
    "comment" : "\n     * <p>This request is for a still capture-type\n     * use case.</p>\n     * <p>If the flash unit is under automatic control, it may fire as needed.</p>\n     * @see CaptureRequest#CONTROL_CAPTURE_INTENT\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_CAPTURE_INTENT_VIDEO_RECORD",
    "type" : "int",
    "comment" : "\n     * <p>This request is for a video recording\n     * use case.</p>\n     * @see CaptureRequest#CONTROL_CAPTURE_INTENT\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_CAPTURE_INTENT_VIDEO_SNAPSHOT",
    "type" : "int",
    "comment" : "\n     * <p>This request is for a video snapshot (still\n     * image while recording video) use case.</p>\n     * <p>The camera device should take the highest-quality image\n     * possible (given the other settings) without disrupting the\n     * frame rate of video recording.  </p>\n     * @see CaptureRequest#CONTROL_CAPTURE_INTENT\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_CAPTURE_INTENT_ZERO_SHUTTER_LAG",
    "type" : "int",
    "comment" : "\n     * <p>This request is for a ZSL usecase; the\n     * application will stream full-resolution images and\n     * reprocess one or several later for a final\n     * capture.</p>\n     * @see CaptureRequest#CONTROL_CAPTURE_INTENT\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_CAPTURE_INTENT_MANUAL",
    "type" : "int",
    "comment" : "\n     * <p>This request is for manual capture use case where\n     * the applications want to directly control the capture parameters.</p>\n     * <p>For example, the application may wish to manually control\n     * {@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime}, {@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}, etc.</p>\n     *\n     * @see CaptureRequest#SENSOR_EXPOSURE_TIME\n     * @see CaptureRequest#SENSOR_SENSITIVITY\n     * @see CaptureRequest#CONTROL_CAPTURE_INTENT\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#SENSOR_SENSITIVITY", "android.hardware.camera2.CaptureRequest#SENSOR_EXPOSURE_TIME" ]
  }, {
    "name" : "CONTROL_CAPTURE_INTENT_MOTION_TRACKING",
    "type" : "int",
    "comment" : "\n     * <p>This request is for a motion tracking use case, where\n     * the application will use camera and inertial sensor data to\n     * locate and track objects in the world.</p>\n     * <p>The camera device auto-exposure routine will limit the exposure time\n     * of the camera to no more than 20 milliseconds, to minimize motion blur.</p>\n     * @see CaptureRequest#CONTROL_CAPTURE_INTENT\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_EFFECT_MODE_OFF",
    "type" : "int",
    "comment" : "\n     * <p>No color effect will be applied.</p>\n     * @see CaptureRequest#CONTROL_EFFECT_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_EFFECT_MODE_MONO",
    "type" : "int",
    "comment" : "\n     * <p>A \"monocolor\" effect where the image is mapped into\n     * a single color.</p>\n     * <p>This will typically be grayscale.</p>\n     * @see CaptureRequest#CONTROL_EFFECT_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_EFFECT_MODE_NEGATIVE",
    "type" : "int",
    "comment" : "\n     * <p>A \"photo-negative\" effect where the image's colors\n     * are inverted.</p>\n     * @see CaptureRequest#CONTROL_EFFECT_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_EFFECT_MODE_SOLARIZE",
    "type" : "int",
    "comment" : "\n     * <p>A \"solarisation\" effect (Sabattier effect) where the\n     * image is wholly or partially reversed in\n     * tone.</p>\n     * @see CaptureRequest#CONTROL_EFFECT_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_EFFECT_MODE_SEPIA",
    "type" : "int",
    "comment" : "\n     * <p>A \"sepia\" effect where the image is mapped into warm\n     * gray, red, and brown tones.</p>\n     * @see CaptureRequest#CONTROL_EFFECT_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_EFFECT_MODE_POSTERIZE",
    "type" : "int",
    "comment" : "\n     * <p>A \"posterization\" effect where the image uses\n     * discrete regions of tone rather than a continuous\n     * gradient of tones.</p>\n     * @see CaptureRequest#CONTROL_EFFECT_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_EFFECT_MODE_WHITEBOARD",
    "type" : "int",
    "comment" : "\n     * <p>A \"whiteboard\" effect where the image is typically displayed\n     * as regions of white, with black or grey details.</p>\n     * @see CaptureRequest#CONTROL_EFFECT_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_EFFECT_MODE_BLACKBOARD",
    "type" : "int",
    "comment" : "\n     * <p>A \"blackboard\" effect where the image is typically displayed\n     * as regions of black, with white or grey details.</p>\n     * @see CaptureRequest#CONTROL_EFFECT_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_EFFECT_MODE_AQUA",
    "type" : "int",
    "comment" : "\n     * <p>An \"aqua\" effect where a blue hue is added to the image.</p>\n     * @see CaptureRequest#CONTROL_EFFECT_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_MODE_OFF",
    "type" : "int",
    "comment" : "\n     * <p>Full application control of pipeline.</p>\n     * <p>All control by the device's metering and focusing (3A)\n     * routines is disabled, and no other settings in\n     * android.control.* have any effect, except that\n     * {@link CaptureRequest#CONTROL_CAPTURE_INTENT android.control.captureIntent} may be used by the camera\n     * device to select post-processing values for processing\n     * blocks that do not allow for manual control, or are not\n     * exposed by the camera API.</p>\n     * <p>However, the camera device's 3A routines may continue to\n     * collect statistics and update their internal state so that\n     * when control is switched to AUTO mode, good control values\n     * can be immediately applied.</p>\n     *\n     * @see CaptureRequest#CONTROL_CAPTURE_INTENT\n     * @see CaptureRequest#CONTROL_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#CONTROL_CAPTURE_INTENT" ]
  }, {
    "name" : "CONTROL_MODE_AUTO",
    "type" : "int",
    "comment" : "\n     * <p>Use settings for each individual 3A routine.</p>\n     * <p>Manual control of capture parameters is disabled. All\n     * controls in android.control.* besides sceneMode take\n     * effect.</p>\n     * @see CaptureRequest#CONTROL_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_MODE_USE_SCENE_MODE",
    "type" : "int",
    "comment" : "\n     * <p>Use a specific scene mode.</p>\n     * <p>Enabling this disables control.aeMode, control.awbMode and\n     * control.afMode controls; the camera device will ignore\n     * those settings while USE_SCENE_MODE is active (except for\n     * FACE_PRIORITY scene mode). Other control entries are still active.\n     * This setting can only be used if scene mode is supported (i.e.\n     * {@link CameraCharacteristics#CONTROL_AVAILABLE_SCENE_MODES android.control.availableSceneModes}\n     * contain some modes other than DISABLED).</p>\n     * <p>For extended scene modes such as BOKEH, please use USE_EXTENDED_SCENE_MODE instead.</p>\n     *\n     * @see CameraCharacteristics#CONTROL_AVAILABLE_SCENE_MODES\n     * @see CaptureRequest#CONTROL_MODE\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#CONTROL_AVAILABLE_SCENE_MODES" ]
  }, {
    "name" : "CONTROL_MODE_OFF_KEEP_STATE",
    "type" : "int",
    "comment" : "\n     * <p>Same as OFF mode, except that this capture will not be\n     * used by camera device background auto-exposure, auto-white balance and\n     * auto-focus algorithms (3A) to update their statistics.</p>\n     * <p>Specifically, the 3A routines are locked to the last\n     * values set from a request with AUTO, OFF, or\n     * USE_SCENE_MODE, and any statistics or state updates\n     * collected from manual captures with OFF_KEEP_STATE will be\n     * discarded by the camera device.</p>\n     * @see CaptureRequest#CONTROL_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_MODE_USE_EXTENDED_SCENE_MODE",
    "type" : "int",
    "comment" : "\n     * <p>Use a specific extended scene mode.</p>\n     * <p>When extended scene mode is on, the camera device may override certain control\n     * parameters, such as targetFpsRange, AE, AWB, and AF modes, to achieve best power and\n     * quality tradeoffs. Only the mandatory stream combinations of LIMITED hardware level\n     * are guaranteed.</p>\n     * <p>This setting can only be used if extended scene mode is supported (i.e.\n     * android.control.availableExtendedSceneModes\n     * contains some modes other than DISABLED).</p>\n     * @see CaptureRequest#CONTROL_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_SCENE_MODE_DISABLED",
    "type" : "int",
    "comment" : "\n     * <p>Indicates that no scene modes are set for a given capture request.</p>\n     * @see CaptureRequest#CONTROL_SCENE_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_SCENE_MODE_FACE_PRIORITY",
    "type" : "int",
    "comment" : "\n     * <p>If face detection support exists, use face\n     * detection data for auto-focus, auto-white balance, and\n     * auto-exposure routines.</p>\n     * <p>If face detection statistics are disabled\n     * (i.e. {@link CaptureRequest#STATISTICS_FACE_DETECT_MODE android.statistics.faceDetectMode} is set to OFF),\n     * this should still operate correctly (but will not return\n     * face detection statistics to the framework).</p>\n     * <p>Unlike the other scene modes, {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode},\n     * {@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode}, and {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode}\n     * remain active when FACE_PRIORITY is set.</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CaptureRequest#CONTROL_AF_MODE\n     * @see CaptureRequest#CONTROL_AWB_MODE\n     * @see CaptureRequest#STATISTICS_FACE_DETECT_MODE\n     * @see CaptureRequest#CONTROL_SCENE_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#STATISTICS_FACE_DETECT_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_AE_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_AF_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_AWB_MODE" ]
  }, {
    "name" : "CONTROL_SCENE_MODE_ACTION",
    "type" : "int",
    "comment" : "\n     * <p>Optimized for photos of quickly moving objects.</p>\n     * <p>Similar to SPORTS.</p>\n     * @see CaptureRequest#CONTROL_SCENE_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_SCENE_MODE_PORTRAIT",
    "type" : "int",
    "comment" : "\n     * <p>Optimized for still photos of people.</p>\n     * @see CaptureRequest#CONTROL_SCENE_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_SCENE_MODE_LANDSCAPE",
    "type" : "int",
    "comment" : "\n     * <p>Optimized for photos of distant macroscopic objects.</p>\n     * @see CaptureRequest#CONTROL_SCENE_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_SCENE_MODE_NIGHT",
    "type" : "int",
    "comment" : "\n     * <p>Optimized for low-light settings.</p>\n     * @see CaptureRequest#CONTROL_SCENE_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_SCENE_MODE_NIGHT_PORTRAIT",
    "type" : "int",
    "comment" : "\n     * <p>Optimized for still photos of people in low-light\n     * settings.</p>\n     * @see CaptureRequest#CONTROL_SCENE_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_SCENE_MODE_THEATRE",
    "type" : "int",
    "comment" : "\n     * <p>Optimized for dim, indoor settings where flash must\n     * remain off.</p>\n     * @see CaptureRequest#CONTROL_SCENE_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_SCENE_MODE_BEACH",
    "type" : "int",
    "comment" : "\n     * <p>Optimized for bright, outdoor beach settings.</p>\n     * @see CaptureRequest#CONTROL_SCENE_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_SCENE_MODE_SNOW",
    "type" : "int",
    "comment" : "\n     * <p>Optimized for bright, outdoor settings containing snow.</p>\n     * @see CaptureRequest#CONTROL_SCENE_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_SCENE_MODE_SUNSET",
    "type" : "int",
    "comment" : "\n     * <p>Optimized for scenes of the setting sun.</p>\n     * @see CaptureRequest#CONTROL_SCENE_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_SCENE_MODE_STEADYPHOTO",
    "type" : "int",
    "comment" : "\n     * <p>Optimized to avoid blurry photos due to small amounts of\n     * device motion (for example: due to hand shake).</p>\n     * @see CaptureRequest#CONTROL_SCENE_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_SCENE_MODE_FIREWORKS",
    "type" : "int",
    "comment" : "\n     * <p>Optimized for nighttime photos of fireworks.</p>\n     * @see CaptureRequest#CONTROL_SCENE_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_SCENE_MODE_SPORTS",
    "type" : "int",
    "comment" : "\n     * <p>Optimized for photos of quickly moving people.</p>\n     * <p>Similar to ACTION.</p>\n     * @see CaptureRequest#CONTROL_SCENE_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_SCENE_MODE_PARTY",
    "type" : "int",
    "comment" : "\n     * <p>Optimized for dim, indoor settings with multiple moving\n     * people.</p>\n     * @see CaptureRequest#CONTROL_SCENE_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_SCENE_MODE_CANDLELIGHT",
    "type" : "int",
    "comment" : "\n     * <p>Optimized for dim settings where the main light source\n     * is a candle.</p>\n     * @see CaptureRequest#CONTROL_SCENE_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_SCENE_MODE_BARCODE",
    "type" : "int",
    "comment" : "\n     * <p>Optimized for accurately capturing a photo of barcode\n     * for use by camera applications that wish to read the\n     * barcode value.</p>\n     * @see CaptureRequest#CONTROL_SCENE_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_SCENE_MODE_HIGH_SPEED_VIDEO",
    "type" : "int",
    "comment" : "\n     * <p>This is deprecated, please use {@link android.hardware.camera2.CameraDevice#createConstrainedHighSpeedCaptureSession }\n     * and {@link android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList }\n     * for high speed video recording.</p>\n     * <p>Optimized for high speed video recording (frame rate &gt;=60fps) use case.</p>\n     * <p>The supported high speed video sizes and fps ranges are specified in\n     * android.control.availableHighSpeedVideoConfigurations. To get desired\n     * output frame rates, the application is only allowed to select video size\n     * and fps range combinations listed in this static metadata. The fps range\n     * can be control via {@link CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE android.control.aeTargetFpsRange}.</p>\n     * <p>In this mode, the camera device will override aeMode, awbMode, and afMode to\n     * ON, ON, and CONTINUOUS_VIDEO, respectively. All post-processing block mode\n     * controls will be overridden to be FAST. Therefore, no manual control of capture\n     * and post-processing parameters is possible. All other controls operate the\n     * same as when {@link CaptureRequest#CONTROL_MODE android.control.mode} == AUTO. This means that all other\n     * android.control.* fields continue to work, such as</p>\n     * <ul>\n     * <li>{@link CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE android.control.aeTargetFpsRange}</li>\n     * <li>{@link CaptureRequest#CONTROL_AE_EXPOSURE_COMPENSATION android.control.aeExposureCompensation}</li>\n     * <li>{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock}</li>\n     * <li>{@link CaptureRequest#CONTROL_AWB_LOCK android.control.awbLock}</li>\n     * <li>{@link CaptureRequest#CONTROL_EFFECT_MODE android.control.effectMode}</li>\n     * <li>{@link CaptureRequest#CONTROL_AE_REGIONS android.control.aeRegions}</li>\n     * <li>{@link CaptureRequest#CONTROL_AF_REGIONS android.control.afRegions}</li>\n     * <li>{@link CaptureRequest#CONTROL_AWB_REGIONS android.control.awbRegions}</li>\n     * <li>{@link CaptureRequest#CONTROL_AF_TRIGGER android.control.afTrigger}</li>\n     * <li>{@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger}</li>\n     * <li>{@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio}</li>\n     * </ul>\n     * <p>Outside of android.control.*, the following controls will work:</p>\n     * <ul>\n     * <li>{@link CaptureRequest#FLASH_MODE android.flash.mode} (automatic flash for still capture will not work since aeMode is ON)</li>\n     * <li>{@link CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE android.lens.opticalStabilizationMode} (if it is supported)</li>\n     * <li>{@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion}</li>\n     * <li>{@link CaptureRequest#STATISTICS_FACE_DETECT_MODE android.statistics.faceDetectMode}</li>\n     * </ul>\n     * <p>For high speed recording use case, the actual maximum supported frame rate may\n     * be lower than what camera can output, depending on the destination Surfaces for\n     * the image data. For example, if the destination surface is from video encoder,\n     * the application need check if the video encoder is capable of supporting the\n     * high frame rate for a given video size, or it will end up with lower recording\n     * frame rate. If the destination surface is from preview window, the preview frame\n     * rate will be bounded by the screen refresh rate.</p>\n     * <p>The camera device will only support up to 2 output high speed streams\n     * (processed non-stalling format defined in android.request.maxNumOutputStreams)\n     * in this mode. This control will be effective only if all of below conditions are true:</p>\n     * <ul>\n     * <li>The application created no more than maxNumHighSpeedStreams processed non-stalling\n     * format output streams, where maxNumHighSpeedStreams is calculated as\n     * min(2, android.request.maxNumOutputStreams[Processed (but not-stalling)]).</li>\n     * <li>The stream sizes are selected from the sizes reported by\n     * android.control.availableHighSpeedVideoConfigurations.</li>\n     * <li>No processed non-stalling or raw streams are configured.</li>\n     * </ul>\n     * <p>When above conditions are NOT satisfied, the controls of this mode and\n     * {@link CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE android.control.aeTargetFpsRange} will be ignored by the camera device,\n     * the camera device will fall back to {@link CaptureRequest#CONTROL_MODE android.control.mode} <code>==</code> AUTO,\n     * and the returned capture result metadata will give the fps range chosen\n     * by the camera device.</p>\n     * <p>Switching into or out of this mode may trigger some camera ISP/sensor\n     * reconfigurations, which may introduce extra latency. It is recommended that\n     * the application avoids unnecessary scene mode switch as much as possible.</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_EXPOSURE_COMPENSATION\n     * @see CaptureRequest#CONTROL_AE_LOCK\n     * @see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER\n     * @see CaptureRequest#CONTROL_AE_REGIONS\n     * @see CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE\n     * @see CaptureRequest#CONTROL_AF_REGIONS\n     * @see CaptureRequest#CONTROL_AF_TRIGGER\n     * @see CaptureRequest#CONTROL_AWB_LOCK\n     * @see CaptureRequest#CONTROL_AWB_REGIONS\n     * @see CaptureRequest#CONTROL_EFFECT_MODE\n     * @see CaptureRequest#CONTROL_MODE\n     * @see CaptureRequest#CONTROL_ZOOM_RATIO\n     * @see CaptureRequest#FLASH_MODE\n     * @see CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE\n     * @see CaptureRequest#SCALER_CROP_REGION\n     * @see CaptureRequest#STATISTICS_FACE_DETECT_MODE\n     * @see CaptureRequest#CONTROL_SCENE_MODE\n     * @deprecated Please refer to this API documentation to find the alternatives\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#STATISTICS_FACE_DETECT_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_AWB_REGIONS", "android.hardware.camera2.CaptureRequest#CONTROL_AWB_LOCK", "android.hardware.camera2.CaptureRequest#CONTROL_AE_EXPOSURE_COMPENSATION", "android.hardware.camera2.CaptureRequest#CONTROL_AE_LOCK", "android.hardware.camera2.CaptureRequest#CONTROL_AE_REGIONS", "android.hardware.camera2.CaptureRequest#CONTROL_EFFECT_MODE", "android.hardware.camera2.CaptureRequest#FLASH_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_AF_REGIONS", "android.hardware.camera2.CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER", "android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession#createHighSpeedRequestList", "android.hardware.camera2.CaptureRequest#CONTROL_MODE", "android.hardware.camera2.CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE", "android.hardware.camera2.CaptureRequest#SCALER_CROP_REGION", "android.hardware.camera2.CameraDevice#createConstrainedHighSpeedCaptureSession", "android.hardware.camera2.CaptureRequest#CONTROL_AF_TRIGGER", "android.hardware.camera2.CaptureRequest#CONTROL_ZOOM_RATIO" ]
  }, {
    "name" : "CONTROL_SCENE_MODE_HDR",
    "type" : "int",
    "comment" : "\n     * <p>Turn on a device-specific high dynamic range (HDR) mode.</p>\n     * <p>In this scene mode, the camera device captures images\n     * that keep a larger range of scene illumination levels\n     * visible in the final image. For example, when taking a\n     * picture of a object in front of a bright window, both\n     * the object and the scene through the window may be\n     * visible when using HDR mode, while in normal AUTO mode,\n     * one or the other may be poorly exposed. As a tradeoff,\n     * HDR mode generally takes much longer to capture a single\n     * image, has no user control, and may have other artifacts\n     * depending on the HDR method used.</p>\n     * <p>Therefore, HDR captures operate at a much slower rate\n     * than regular captures.</p>\n     * <p>In this mode, on LIMITED or FULL devices, when a request\n     * is made with a {@link CaptureRequest#CONTROL_CAPTURE_INTENT android.control.captureIntent} of\n     * STILL_CAPTURE, the camera device will capture an image\n     * using a high dynamic range capture technique.  On LEGACY\n     * devices, captures that target a JPEG-format output will\n     * be captured with HDR, and the capture intent is not\n     * relevant.</p>\n     * <p>The HDR capture may involve the device capturing a burst\n     * of images internally and combining them into one, or it\n     * may involve the device using specialized high dynamic\n     * range capture hardware. In all cases, a single image is\n     * produced in response to a capture request submitted\n     * while in HDR mode.</p>\n     * <p>Since substantial post-processing is generally needed to\n     * produce an HDR image, only YUV, PRIVATE, and JPEG\n     * outputs are supported for LIMITED/FULL device HDR\n     * captures, and only JPEG outputs are supported for LEGACY\n     * HDR captures. Using a RAW output for HDR capture is not\n     * supported.</p>\n     * <p>Some devices may also support always-on HDR, which\n     * applies HDR processing at full frame rate.  For these\n     * devices, intents other than STILL_CAPTURE will also\n     * produce an HDR output with no frame rate impact compared\n     * to normal operation, though the quality may be lower\n     * than for STILL_CAPTURE intents.</p>\n     * <p>If SCENE_MODE_HDR is used with unsupported output types\n     * or capture intents, the images captured will be as if\n     * the SCENE_MODE was not enabled at all.</p>\n     *\n     * @see CaptureRequest#CONTROL_CAPTURE_INTENT\n     * @see CaptureRequest#CONTROL_SCENE_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#CONTROL_CAPTURE_INTENT" ]
  }, {
    "name" : "CONTROL_SCENE_MODE_FACE_PRIORITY_LOW_LIGHT",
    "type" : "int",
    "comment" : "\n     * <p>Same as FACE_PRIORITY scene mode, except that the camera\n     * device will choose higher sensitivity values ({@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity})\n     * under low light conditions.</p>\n     * <p>The camera device may be tuned to expose the images in a reduced\n     * sensitivity range to produce the best quality images. For example,\n     * if the {@link CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE android.sensor.info.sensitivityRange} gives range of [100, 1600],\n     * the camera device auto-exposure routine tuning process may limit the actual\n     * exposure sensitivity range to [100, 1200] to ensure that the noise level isn't\n     * excessive in order to preserve the image quality. Under this situation, the image under\n     * low light may be under-exposed when the sensor max exposure time (bounded by the\n     * {@link CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE android.control.aeTargetFpsRange} when {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} is one of the\n     * ON_* modes) and effective max sensitivity are reached. This scene mode allows the\n     * camera device auto-exposure routine to increase the sensitivity up to the max\n     * sensitivity specified by {@link CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE android.sensor.info.sensitivityRange} when the scene is too\n     * dark and the max exposure time is reached. The captured images may be noisier\n     * compared with the images captured in normal FACE_PRIORITY mode; therefore, it is\n     * recommended that the application only use this scene mode when it is capable of\n     * reducing the noise level of the captured images.</p>\n     * <p>Unlike the other scene modes, {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode},\n     * {@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode}, and {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode}\n     * remain active when FACE_PRIORITY_LOW_LIGHT is set.</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE\n     * @see CaptureRequest#CONTROL_AF_MODE\n     * @see CaptureRequest#CONTROL_AWB_MODE\n     * @see CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE\n     * @see CaptureRequest#SENSOR_SENSITIVITY\n     * @see CaptureRequest#CONTROL_SCENE_MODE\n     * @hide\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#SENSOR_SENSITIVITY", "android.hardware.camera2.CaptureRequest#CONTROL_AE_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_AE_TARGET_FPS_RANGE", "android.hardware.camera2.CaptureRequest#CONTROL_AF_MODE", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE", "android.hardware.camera2.CaptureRequest#CONTROL_AWB_MODE" ]
  }, {
    "name" : "CONTROL_SCENE_MODE_DEVICE_CUSTOM_START",
    "type" : "int",
    "comment" : "\n     * <p>Scene mode values within the range of\n     * <code>[DEVICE_CUSTOM_START, DEVICE_CUSTOM_END]</code> are reserved for device specific\n     * customized scene modes.</p>\n     * @see CaptureRequest#CONTROL_SCENE_MODE\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_SCENE_MODE_DEVICE_CUSTOM_END",
    "type" : "int",
    "comment" : "\n     * <p>Scene mode values within the range of\n     * <code>[DEVICE_CUSTOM_START, DEVICE_CUSTOM_END]</code> are reserved for device specific\n     * customized scene modes.</p>\n     * @see CaptureRequest#CONTROL_SCENE_MODE\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_VIDEO_STABILIZATION_MODE_OFF",
    "type" : "int",
    "comment" : "\n     * <p>Video stabilization is disabled.</p>\n     * @see CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_VIDEO_STABILIZATION_MODE_ON",
    "type" : "int",
    "comment" : "\n     * <p>Video stabilization is enabled.</p>\n     * @see CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_VIDEO_STABILIZATION_MODE_PREVIEW_STABILIZATION",
    "type" : "int",
    "comment" : "\n     * <p>Preview stabilization, where the preview in addition to all other non-RAW streams are\n     * stabilized with the same quality of stabilization, is enabled. This mode aims to give\n     * clients a 'what you see is what you get' effect. In this mode, the FoV reduction will\n     * be a maximum of 20 % both horizontally and vertically\n     * (10% from left, right, top, bottom) for the given zoom ratio / crop region.\n     * The resultant FoV will also be the same across all processed streams\n     * (that have the same aspect ratio).</p>\n     * @see CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_EXTENDED_SCENE_MODE_DISABLED",
    "type" : "int",
    "comment" : "\n     * <p>Extended scene mode is disabled.</p>\n     * @see CaptureRequest#CONTROL_EXTENDED_SCENE_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_EXTENDED_SCENE_MODE_BOKEH_STILL_CAPTURE",
    "type" : "int",
    "comment" : "\n     * <p>High quality bokeh mode is enabled for all non-raw streams (including YUV,\n     * JPEG, and IMPLEMENTATION_DEFINED) when capture intent is STILL_CAPTURE. Due to the\n     * extra image processing, this mode may introduce additional stall to non-raw streams.\n     * This mode should be used in high quality still capture use case.</p>\n     * @see CaptureRequest#CONTROL_EXTENDED_SCENE_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_EXTENDED_SCENE_MODE_BOKEH_CONTINUOUS",
    "type" : "int",
    "comment" : "\n     * <p>Bokeh effect must not slow down capture rate relative to sensor raw output,\n     * and the effect is applied to all processed streams no larger than the maximum\n     * streaming dimension. This mode should be used if performance and power are a\n     * priority, such as video recording.</p>\n     * @see CaptureRequest#CONTROL_EXTENDED_SCENE_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_EXTENDED_SCENE_MODE_VENDOR_START",
    "type" : "int",
    "comment" : "\n     * <p>Vendor defined extended scene modes. These depend on vendor implementation.</p>\n     * @see CaptureRequest#CONTROL_EXTENDED_SCENE_MODE\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_SETTINGS_OVERRIDE_OFF",
    "type" : "int",
    "comment" : "\n     * <p>No keys are applied sooner than the other keys when applying CaptureRequest\n     * settings to the camera device. This is the default value.</p>\n     * @see CaptureRequest#CONTROL_SETTINGS_OVERRIDE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_SETTINGS_OVERRIDE_ZOOM",
    "type" : "int",
    "comment" : "\n     * <p>Zoom related keys are applied sooner than the other keys in the CaptureRequest. The\n     * zoom related keys are:</p>\n     * <ul>\n     * <li>{@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio}</li>\n     * <li>{@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion}</li>\n     * <li>{@link CaptureRequest#CONTROL_AE_REGIONS android.control.aeRegions}</li>\n     * <li>{@link CaptureRequest#CONTROL_AWB_REGIONS android.control.awbRegions}</li>\n     * <li>{@link CaptureRequest#CONTROL_AF_REGIONS android.control.afRegions}</li>\n     * </ul>\n     * <p>Even though {@link CaptureRequest#CONTROL_AE_REGIONS android.control.aeRegions}, {@link CaptureRequest#CONTROL_AWB_REGIONS android.control.awbRegions},\n     * and {@link CaptureRequest#CONTROL_AF_REGIONS android.control.afRegions} are not directly zoom related, applications\n     * typically scale these regions together with {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} to have a\n     * consistent mapping within the current field of view. In this aspect, they are\n     * related to {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} and {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio}.</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_REGIONS\n     * @see CaptureRequest#CONTROL_AF_REGIONS\n     * @see CaptureRequest#CONTROL_AWB_REGIONS\n     * @see CaptureRequest#CONTROL_ZOOM_RATIO\n     * @see CaptureRequest#SCALER_CROP_REGION\n     * @see CaptureRequest#CONTROL_SETTINGS_OVERRIDE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#CONTROL_AWB_REGIONS", "android.hardware.camera2.CaptureRequest#SCALER_CROP_REGION", "android.hardware.camera2.CaptureRequest#CONTROL_AE_REGIONS", "android.hardware.camera2.CaptureRequest#CONTROL_ZOOM_RATIO", "android.hardware.camera2.CaptureRequest#CONTROL_AF_REGIONS" ]
  }, {
    "name" : "CONTROL_SETTINGS_OVERRIDE_VENDOR_START",
    "type" : "int",
    "comment" : "\n     * <p>Vendor defined settingsOverride. These depend on vendor implementation.</p>\n     * @see CaptureRequest#CONTROL_SETTINGS_OVERRIDE\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AUTOFRAMING_OFF",
    "type" : "int",
    "comment" : "\n     * <p>Disable autoframing.</p>\n     * @see CaptureRequest#CONTROL_AUTOFRAMING\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AUTOFRAMING_ON",
    "type" : "int",
    "comment" : "\n     * <p>Enable autoframing to keep people in the frame's field of view.</p>\n     * @see CaptureRequest#CONTROL_AUTOFRAMING\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AUTOFRAMING_AUTO",
    "type" : "int",
    "comment" : "\n     * <p>Automatically select ON or OFF based on the system level preferences.</p>\n     * @see CaptureRequest#CONTROL_AUTOFRAMING\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EDGE_MODE_OFF",
    "type" : "int",
    "comment" : "\n     * <p>No edge enhancement is applied.</p>\n     * @see CaptureRequest#EDGE_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "EDGE_MODE_FAST",
    "type" : "int",
    "comment" : "\n     * <p>Apply edge enhancement at a quality level that does not slow down frame rate\n     * relative to sensor output. It may be the same as OFF if edge enhancement will\n     * slow down frame rate relative to sensor.</p>\n     * @see CaptureRequest#EDGE_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "EDGE_MODE_HIGH_QUALITY",
    "type" : "int",
    "comment" : "\n     * <p>Apply high-quality edge enhancement, at a cost of possibly reduced output frame rate.</p>\n     * @see CaptureRequest#EDGE_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "EDGE_MODE_ZERO_SHUTTER_LAG",
    "type" : "int",
    "comment" : "\n     * <p>Edge enhancement is applied at different\n     * levels for different output streams, based on resolution. Streams at maximum recording\n     * resolution (see {@link android.hardware.camera2.CameraDevice#createCaptureSession })\n     * or below have edge enhancement applied, while higher-resolution streams have no edge\n     * enhancement applied. The level of edge enhancement for low-resolution streams is tuned\n     * so that frame rate is not impacted, and the quality is equal to or better than FAST\n     * (since it is only applied to lower-resolution outputs, quality may improve from FAST).</p>\n     * <p>This mode is intended to be used by applications operating in a zero-shutter-lag mode\n     * with YUV or PRIVATE reprocessing, where the application continuously captures\n     * high-resolution intermediate buffers into a circular buffer, from which a final image is\n     * produced via reprocessing when a user takes a picture.  For such a use case, the\n     * high-resolution buffers must not have edge enhancement applied to maximize efficiency of\n     * preview and to avoid double-applying enhancement when reprocessed, while low-resolution\n     * buffers (used for recording or preview, generally) need edge enhancement applied for\n     * reasonable preview quality.</p>\n     * <p>This mode is guaranteed to be supported by devices that support either the\n     * YUV_REPROCESSING or PRIVATE_REPROCESSING capabilities\n     * ({@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} lists either of those capabilities) and it will\n     * be the default mode for CAMERA3_TEMPLATE_ZERO_SHUTTER_LAG template.</p>\n     *\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     * @see CaptureRequest#EDGE_MODE\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES", "android.hardware.camera2.CameraDevice#createCaptureSession" ]
  }, {
    "name" : "FLASH_MODE_OFF",
    "type" : "int",
    "comment" : "\n     * <p>Do not fire the flash for this capture.</p>\n     * @see CaptureRequest#FLASH_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "FLASH_MODE_SINGLE",
    "type" : "int",
    "comment" : "\n     * <p>If the flash is available and charged, fire flash\n     * for this capture.</p>\n     * @see CaptureRequest#FLASH_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "FLASH_MODE_TORCH",
    "type" : "int",
    "comment" : "\n     * <p>Transition flash to continuously on.</p>\n     * @see CaptureRequest#FLASH_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "HOT_PIXEL_MODE_OFF",
    "type" : "int",
    "comment" : "\n     * <p>No hot pixel correction is applied.</p>\n     * <p>The frame rate must not be reduced relative to sensor raw output\n     * for this option.</p>\n     * <p>The hotpixel map may be returned in {@link CaptureResult#STATISTICS_HOT_PIXEL_MAP android.statistics.hotPixelMap}.</p>\n     *\n     * @see CaptureResult#STATISTICS_HOT_PIXEL_MAP\n     * @see CaptureRequest#HOT_PIXEL_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureResult#STATISTICS_HOT_PIXEL_MAP" ]
  }, {
    "name" : "HOT_PIXEL_MODE_FAST",
    "type" : "int",
    "comment" : "\n     * <p>Hot pixel correction is applied, without reducing frame\n     * rate relative to sensor raw output.</p>\n     * <p>The hotpixel map may be returned in {@link CaptureResult#STATISTICS_HOT_PIXEL_MAP android.statistics.hotPixelMap}.</p>\n     *\n     * @see CaptureResult#STATISTICS_HOT_PIXEL_MAP\n     * @see CaptureRequest#HOT_PIXEL_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureResult#STATISTICS_HOT_PIXEL_MAP" ]
  }, {
    "name" : "HOT_PIXEL_MODE_HIGH_QUALITY",
    "type" : "int",
    "comment" : "\n     * <p>High-quality hot pixel correction is applied, at a cost\n     * of possibly reduced frame rate relative to sensor raw output.</p>\n     * <p>The hotpixel map may be returned in {@link CaptureResult#STATISTICS_HOT_PIXEL_MAP android.statistics.hotPixelMap}.</p>\n     *\n     * @see CaptureResult#STATISTICS_HOT_PIXEL_MAP\n     * @see CaptureRequest#HOT_PIXEL_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureResult#STATISTICS_HOT_PIXEL_MAP" ]
  }, {
    "name" : "LENS_OPTICAL_STABILIZATION_MODE_OFF",
    "type" : "int",
    "comment" : "\n     * <p>Optical stabilization is unavailable.</p>\n     * @see CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "LENS_OPTICAL_STABILIZATION_MODE_ON",
    "type" : "int",
    "comment" : "\n     * <p>Optical stabilization is enabled.</p>\n     * @see CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "NOISE_REDUCTION_MODE_OFF",
    "type" : "int",
    "comment" : "\n     * <p>No noise reduction is applied.</p>\n     * @see CaptureRequest#NOISE_REDUCTION_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "NOISE_REDUCTION_MODE_FAST",
    "type" : "int",
    "comment" : "\n     * <p>Noise reduction is applied without reducing frame rate relative to sensor\n     * output. It may be the same as OFF if noise reduction will reduce frame rate\n     * relative to sensor.</p>\n     * @see CaptureRequest#NOISE_REDUCTION_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "NOISE_REDUCTION_MODE_HIGH_QUALITY",
    "type" : "int",
    "comment" : "\n     * <p>High-quality noise reduction is applied, at the cost of possibly reduced frame\n     * rate relative to sensor output.</p>\n     * @see CaptureRequest#NOISE_REDUCTION_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "NOISE_REDUCTION_MODE_MINIMAL",
    "type" : "int",
    "comment" : "\n     * <p>MINIMAL noise reduction is applied without reducing frame rate relative to\n     * sensor output. </p>\n     * @see CaptureRequest#NOISE_REDUCTION_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "NOISE_REDUCTION_MODE_ZERO_SHUTTER_LAG",
    "type" : "int",
    "comment" : "\n     * <p>Noise reduction is applied at different levels for different output streams,\n     * based on resolution. Streams at maximum recording resolution (see {@link android.hardware.camera2.CameraDevice#createCaptureSession })\n     * or below have noise reduction applied, while higher-resolution streams have MINIMAL (if\n     * supported) or no noise reduction applied (if MINIMAL is not supported.) The degree of\n     * noise reduction for low-resolution streams is tuned so that frame rate is not impacted,\n     * and the quality is equal to or better than FAST (since it is only applied to\n     * lower-resolution outputs, quality may improve from FAST).</p>\n     * <p>This mode is intended to be used by applications operating in a zero-shutter-lag mode\n     * with YUV or PRIVATE reprocessing, where the application continuously captures\n     * high-resolution intermediate buffers into a circular buffer, from which a final image is\n     * produced via reprocessing when a user takes a picture.  For such a use case, the\n     * high-resolution buffers must not have noise reduction applied to maximize efficiency of\n     * preview and to avoid over-applying noise filtering when reprocessing, while\n     * low-resolution buffers (used for recording or preview, generally) need noise reduction\n     * applied for reasonable preview quality.</p>\n     * <p>This mode is guaranteed to be supported by devices that support either the\n     * YUV_REPROCESSING or PRIVATE_REPROCESSING capabilities\n     * ({@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} lists either of those capabilities) and it will\n     * be the default mode for CAMERA3_TEMPLATE_ZERO_SHUTTER_LAG template.</p>\n     *\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     * @see CaptureRequest#NOISE_REDUCTION_MODE\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES", "android.hardware.camera2.CameraDevice#createCaptureSession" ]
  }, {
    "name" : "SCALER_ROTATE_AND_CROP_NONE",
    "type" : "int",
    "comment" : "\n     * <p>No rotate and crop is applied. Processed outputs are in the sensor orientation.</p>\n     * @see CaptureRequest#SCALER_ROTATE_AND_CROP\n     ",
    "links" : [ ]
  }, {
    "name" : "SCALER_ROTATE_AND_CROP_90",
    "type" : "int",
    "comment" : "\n     * <p>Processed images are rotated by 90 degrees clockwise, and then cropped\n     * to the original aspect ratio.</p>\n     * @see CaptureRequest#SCALER_ROTATE_AND_CROP\n     ",
    "links" : [ ]
  }, {
    "name" : "SCALER_ROTATE_AND_CROP_180",
    "type" : "int",
    "comment" : "\n     * <p>Processed images are rotated by 180 degrees.  Since the aspect ratio does not\n     * change, no cropping is performed.</p>\n     * @see CaptureRequest#SCALER_ROTATE_AND_CROP\n     ",
    "links" : [ ]
  }, {
    "name" : "SCALER_ROTATE_AND_CROP_270",
    "type" : "int",
    "comment" : "\n     * <p>Processed images are rotated by 270 degrees clockwise, and then cropped\n     * to the original aspect ratio.</p>\n     * @see CaptureRequest#SCALER_ROTATE_AND_CROP\n     ",
    "links" : [ ]
  }, {
    "name" : "SCALER_ROTATE_AND_CROP_AUTO",
    "type" : "int",
    "comment" : "\n     * <p>The camera API automatically selects the best concrete value for\n     * rotate-and-crop based on the application's support for resizability and the current\n     * multi-window mode.</p>\n     * <p>If the application does not support resizing but the display mode for its main\n     * Activity is not in a typical orientation, the camera API will set <code>ROTATE_AND_CROP_90</code>\n     * or some other supported rotation value, depending on device configuration,\n     * to ensure preview and captured images are correctly shown to the user. Otherwise,\n     * <code>ROTATE_AND_CROP_NONE</code> will be selected.</p>\n     * <p>When a value other than NONE is selected, several metadata fields will also be parsed\n     * differently to ensure that coordinates are correctly handled for features like drawing\n     * face detection boxes or passing in tap-to-focus coordinates.  The camera API will\n     * convert positions in the active array coordinate system to/from the cropped-and-rotated\n     * coordinate system to make the operation transparent for applications.</p>\n     * <p>No coordinate mapping will be done when the application selects a non-AUTO mode.</p>\n     * @see CaptureRequest#SCALER_ROTATE_AND_CROP\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_TEST_PATTERN_MODE_OFF",
    "type" : "int",
    "comment" : "\n     * <p>No test pattern mode is used, and the camera\n     * device returns captures from the image sensor.</p>\n     * <p>This is the default if the key is not set.</p>\n     * @see CaptureRequest#SENSOR_TEST_PATTERN_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_TEST_PATTERN_MODE_SOLID_COLOR",
    "type" : "int",
    "comment" : "\n     * <p>Each pixel in <code>[R, G_even, G_odd, B]</code> is replaced by its\n     * respective color channel provided in\n     * {@link CaptureRequest#SENSOR_TEST_PATTERN_DATA android.sensor.testPatternData}.</p>\n     * <p>For example:</p>\n     * <pre><code>{@link CaptureRequest#SENSOR_TEST_PATTERN_DATA android.sensor.testPatternData} = [0, 0xFFFFFFFF, 0xFFFFFFFF, 0]\n     * </code></pre>\n     * <p>All green pixels are 100% green. All red/blue pixels are black.</p>\n     * <pre><code>{@link CaptureRequest#SENSOR_TEST_PATTERN_DATA android.sensor.testPatternData} = [0xFFFFFFFF, 0, 0xFFFFFFFF, 0]\n     * </code></pre>\n     * <p>All red pixels are 100% red. Only the odd green pixels\n     * are 100% green. All blue pixels are 100% black.</p>\n     *\n     * @see CaptureRequest#SENSOR_TEST_PATTERN_DATA\n     * @see CaptureRequest#SENSOR_TEST_PATTERN_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#SENSOR_TEST_PATTERN_DATA" ]
  }, {
    "name" : "SENSOR_TEST_PATTERN_MODE_COLOR_BARS",
    "type" : "int",
    "comment" : "\n     * <p>All pixel data is replaced with an 8-bar color pattern.</p>\n     * <p>The vertical bars (left-to-right) are as follows:</p>\n     * <ul>\n     * <li>100% white</li>\n     * <li>yellow</li>\n     * <li>cyan</li>\n     * <li>green</li>\n     * <li>magenta</li>\n     * <li>red</li>\n     * <li>blue</li>\n     * <li>black</li>\n     * </ul>\n     * <p>In general the image would look like the following:</p>\n     * <pre><code>W Y C G M R B K\n     * W Y C G M R B K\n     * W Y C G M R B K\n     * W Y C G M R B K\n     * W Y C G M R B K\n     * . . . . . . . .\n     * . . . . . . . .\n     * . . . . . . . .\n     *\n     * (B = Blue, K = Black)\n     * </code></pre>\n     * <p>Each bar should take up 1/8 of the sensor pixel array width.\n     * When this is not possible, the bar size should be rounded\n     * down to the nearest integer and the pattern can repeat\n     * on the right side.</p>\n     * <p>Each bar's height must always take up the full sensor\n     * pixel array height.</p>\n     * <p>Each pixel in this test pattern must be set to either\n     * 0% intensity or 100% intensity.</p>\n     * @see CaptureRequest#SENSOR_TEST_PATTERN_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_TEST_PATTERN_MODE_COLOR_BARS_FADE_TO_GRAY",
    "type" : "int",
    "comment" : "\n     * <p>The test pattern is similar to COLOR_BARS, except that\n     * each bar should start at its specified color at the top,\n     * and fade to gray at the bottom.</p>\n     * <p>Furthermore each bar is further subdivided into a left and\n     * right half. The left half should have a smooth gradient,\n     * and the right half should have a quantized gradient.</p>\n     * <p>In particular, the right half's should consist of blocks of the\n     * same color for 1/16th active sensor pixel array width.</p>\n     * <p>The least significant bits in the quantized gradient should\n     * be copied from the most significant bits of the smooth gradient.</p>\n     * <p>The height of each bar should always be a multiple of 128.\n     * When this is not the case, the pattern should repeat at the bottom\n     * of the image.</p>\n     * @see CaptureRequest#SENSOR_TEST_PATTERN_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_TEST_PATTERN_MODE_PN9",
    "type" : "int",
    "comment" : "\n     * <p>All pixel data is replaced by a pseudo-random sequence\n     * generated from a PN9 512-bit sequence (typically implemented\n     * in hardware with a linear feedback shift register).</p>\n     * <p>The generator should be reset at the beginning of each frame,\n     * and thus each subsequent raw frame with this test pattern should\n     * be exactly the same as the last.</p>\n     * @see CaptureRequest#SENSOR_TEST_PATTERN_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_TEST_PATTERN_MODE_BLACK",
    "type" : "int",
    "comment" : "\n     * <p>All pixel data is replaced by 0% intensity (black) values.</p>\n     * <p>This test pattern is identical to SOLID_COLOR with a value of <code>[0, 0, 0, 0]</code> for\n     * {@link CaptureRequest#SENSOR_TEST_PATTERN_DATA android.sensor.testPatternData}.  It is recommended that devices implement full\n     * SOLID_COLOR support instead, but BLACK can be used to provide minimal support for a\n     * test pattern suitable for privacy use cases.</p>\n     *\n     * @see CaptureRequest#SENSOR_TEST_PATTERN_DATA\n     * @see CaptureRequest#SENSOR_TEST_PATTERN_MODE\n     * @hide\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#SENSOR_TEST_PATTERN_DATA" ]
  }, {
    "name" : "SENSOR_TEST_PATTERN_MODE_CUSTOM1",
    "type" : "int",
    "comment" : "\n     * <p>The first custom test pattern. All custom patterns that are\n     * available only on this camera device are at least this numeric\n     * value.</p>\n     * <p>All of the custom test patterns will be static\n     * (that is the raw image must not vary from frame to frame).</p>\n     * @see CaptureRequest#SENSOR_TEST_PATTERN_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_PIXEL_MODE_DEFAULT",
    "type" : "int",
    "comment" : "\n     * <p>This is the default sensor pixel mode.</p>\n     * @see CaptureRequest#SENSOR_PIXEL_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION",
    "type" : "int",
    "comment" : "\n     * <p>In this mode, sensors typically do not bin pixels, as a result can offer larger\n     * image sizes.</p>\n     * @see CaptureRequest#SENSOR_PIXEL_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "SHADING_MODE_OFF",
    "type" : "int",
    "comment" : "\n     * <p>No lens shading correction is applied.</p>\n     * @see CaptureRequest#SHADING_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "SHADING_MODE_FAST",
    "type" : "int",
    "comment" : "\n     * <p>Apply lens shading corrections, without slowing\n     * frame rate relative to sensor raw output</p>\n     * @see CaptureRequest#SHADING_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "SHADING_MODE_HIGH_QUALITY",
    "type" : "int",
    "comment" : "\n     * <p>Apply high-quality lens shading correction, at the\n     * cost of possibly reduced frame rate.</p>\n     * @see CaptureRequest#SHADING_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "STATISTICS_FACE_DETECT_MODE_OFF",
    "type" : "int",
    "comment" : "\n     * <p>Do not include face detection statistics in capture\n     * results.</p>\n     * @see CaptureRequest#STATISTICS_FACE_DETECT_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "STATISTICS_FACE_DETECT_MODE_SIMPLE",
    "type" : "int",
    "comment" : "\n     * <p>Return face rectangle and confidence values only.</p>\n     * @see CaptureRequest#STATISTICS_FACE_DETECT_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "STATISTICS_FACE_DETECT_MODE_FULL",
    "type" : "int",
    "comment" : "\n     * <p>Return all face\n     * metadata.</p>\n     * <p>In this mode, face rectangles, scores, landmarks, and face IDs are all valid.</p>\n     * @see CaptureRequest#STATISTICS_FACE_DETECT_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "STATISTICS_LENS_SHADING_MAP_MODE_OFF",
    "type" : "int",
    "comment" : "\n     * <p>Do not include a lens shading map in the capture result.</p>\n     * @see CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "STATISTICS_LENS_SHADING_MAP_MODE_ON",
    "type" : "int",
    "comment" : "\n     * <p>Include a lens shading map in the capture result.</p>\n     * @see CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "STATISTICS_OIS_DATA_MODE_OFF",
    "type" : "int",
    "comment" : "\n     * <p>Do not include OIS data in the capture result.</p>\n     * @see CaptureRequest#STATISTICS_OIS_DATA_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "STATISTICS_OIS_DATA_MODE_ON",
    "type" : "int",
    "comment" : "\n     * <p>Include OIS data in the capture result.</p>\n     * <p>{@link CaptureResult#STATISTICS_OIS_SAMPLES android.statistics.oisSamples} provides OIS sample data in the\n     * output result metadata.</p>\n     *\n     * @see CaptureResult#STATISTICS_OIS_SAMPLES\n     * @see CaptureRequest#STATISTICS_OIS_DATA_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureResult#STATISTICS_OIS_SAMPLES" ]
  }, {
    "name" : "TONEMAP_MODE_CONTRAST_CURVE",
    "type" : "int",
    "comment" : "\n     * <p>Use the tone mapping curve specified in\n     * the {@link CaptureRequest#TONEMAP_CURVE android.tonemap.curve}* entries.</p>\n     * <p>All color enhancement and tonemapping must be disabled, except\n     * for applying the tonemapping curve specified by\n     * {@link CaptureRequest#TONEMAP_CURVE android.tonemap.curve}.</p>\n     * <p>Must not slow down frame rate relative to raw\n     * sensor output.</p>\n     *\n     * @see CaptureRequest#TONEMAP_CURVE\n     * @see CaptureRequest#TONEMAP_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#TONEMAP_CURVE" ]
  }, {
    "name" : "TONEMAP_MODE_FAST",
    "type" : "int",
    "comment" : "\n     * <p>Advanced gamma mapping and color enhancement may be applied, without\n     * reducing frame rate compared to raw sensor output.</p>\n     * @see CaptureRequest#TONEMAP_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "TONEMAP_MODE_HIGH_QUALITY",
    "type" : "int",
    "comment" : "\n     * <p>High-quality gamma mapping and color enhancement will be applied, at\n     * the cost of possibly reduced frame rate compared to raw sensor output.</p>\n     * @see CaptureRequest#TONEMAP_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "TONEMAP_MODE_GAMMA_VALUE",
    "type" : "int",
    "comment" : "\n     * <p>Use the gamma value specified in {@link CaptureRequest#TONEMAP_GAMMA android.tonemap.gamma} to perform\n     * tonemapping.</p>\n     * <p>All color enhancement and tonemapping must be disabled, except\n     * for applying the tonemapping curve specified by {@link CaptureRequest#TONEMAP_GAMMA android.tonemap.gamma}.</p>\n     * <p>Must not slow down frame rate relative to raw sensor output.</p>\n     *\n     * @see CaptureRequest#TONEMAP_GAMMA\n     * @see CaptureRequest#TONEMAP_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#TONEMAP_GAMMA" ]
  }, {
    "name" : "TONEMAP_MODE_PRESET_CURVE",
    "type" : "int",
    "comment" : "\n     * <p>Use the preset tonemapping curve specified in\n     * {@link CaptureRequest#TONEMAP_PRESET_CURVE android.tonemap.presetCurve} to perform tonemapping.</p>\n     * <p>All color enhancement and tonemapping must be disabled, except\n     * for applying the tonemapping curve specified by\n     * {@link CaptureRequest#TONEMAP_PRESET_CURVE android.tonemap.presetCurve}.</p>\n     * <p>Must not slow down frame rate relative to raw sensor output.</p>\n     *\n     * @see CaptureRequest#TONEMAP_PRESET_CURVE\n     * @see CaptureRequest#TONEMAP_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#TONEMAP_PRESET_CURVE" ]
  }, {
    "name" : "TONEMAP_PRESET_CURVE_SRGB",
    "type" : "int",
    "comment" : "\n     * <p>Tonemapping curve is defined by sRGB</p>\n     * @see CaptureRequest#TONEMAP_PRESET_CURVE\n     ",
    "links" : [ ]
  }, {
    "name" : "TONEMAP_PRESET_CURVE_REC709",
    "type" : "int",
    "comment" : "\n     * <p>Tonemapping curve is defined by ITU-R BT.709</p>\n     * @see CaptureRequest#TONEMAP_PRESET_CURVE\n     ",
    "links" : [ ]
  }, {
    "name" : "DISTORTION_CORRECTION_MODE_OFF",
    "type" : "int",
    "comment" : "\n     * <p>No distortion correction is applied.</p>\n     * @see CaptureRequest#DISTORTION_CORRECTION_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "DISTORTION_CORRECTION_MODE_FAST",
    "type" : "int",
    "comment" : "\n     * <p>Lens distortion correction is applied without reducing frame rate\n     * relative to sensor output. It may be the same as OFF if distortion correction would\n     * reduce frame rate relative to sensor.</p>\n     * @see CaptureRequest#DISTORTION_CORRECTION_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "DISTORTION_CORRECTION_MODE_HIGH_QUALITY",
    "type" : "int",
    "comment" : "\n     * <p>High-quality distortion correction is applied, at the cost of\n     * possibly reduced frame rate relative to sensor output.</p>\n     * @see CaptureRequest#DISTORTION_CORRECTION_MODE\n     ",
    "links" : [ ]
  }, {
    "name" : "EFV_STABILIZATION_MODE_OFF",
    "type" : "int",
    "comment" : "\n     * <p>No stabilization.</p>\n     * @see CaptureRequest#EFV_STABILIZATION_MODE\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EFV_STABILIZATION_MODE_GIMBAL",
    "type" : "int",
    "comment" : "\n     * <p>Gimbal stabilization mode.</p>\n     * @see CaptureRequest#EFV_STABILIZATION_MODE\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EFV_STABILIZATION_MODE_LOCKED",
    "type" : "int",
    "comment" : "\n     * <p>Locked stabilization mode which uses the\n     * {@link android.hardware.camera2.CameraExtensionCharacteristics#EXTENSION_EYES_FREE_VIDEOGRAPHY }\n     * stabilization to directionally steady the target region.</p>\n     * @see CaptureRequest#EFV_STABILIZATION_MODE\n     * @hide\n     ",
    "links" : [ "android.hardware.camera2.CameraExtensionCharacteristics#EXTENSION_EYES_FREE_VIDEOGRAPHY" ]
  }, {
    "name" : "CONTROL_AE_STATE_INACTIVE",
    "type" : "int",
    "comment" : "\n     * <p>AE is off or recently reset.</p>\n     * <p>When a camera device is opened, it starts in\n     * this state. This is a transient state, the camera device may skip reporting\n     * this state in capture result.</p>\n     * @see CaptureResult#CONTROL_AE_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AE_STATE_SEARCHING",
    "type" : "int",
    "comment" : "\n     * <p>AE doesn't yet have a good set of control values\n     * for the current scene.</p>\n     * <p>This is a transient state, the camera device may skip\n     * reporting this state in capture result.</p>\n     * @see CaptureResult#CONTROL_AE_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AE_STATE_CONVERGED",
    "type" : "int",
    "comment" : "\n     * <p>AE has a good set of control values for the\n     * current scene.</p>\n     * @see CaptureResult#CONTROL_AE_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AE_STATE_LOCKED",
    "type" : "int",
    "comment" : "\n     * <p>AE has been locked.</p>\n     * @see CaptureResult#CONTROL_AE_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AE_STATE_FLASH_REQUIRED",
    "type" : "int",
    "comment" : "\n     * <p>AE has a good set of control values, but flash\n     * needs to be fired for good quality still\n     * capture.</p>\n     * @see CaptureResult#CONTROL_AE_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AE_STATE_PRECAPTURE",
    "type" : "int",
    "comment" : "\n     * <p>AE has been asked to do a precapture sequence\n     * and is currently executing it.</p>\n     * <p>Precapture can be triggered through setting\n     * {@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger} to START. Currently\n     * active and completed (if it causes camera device internal AE lock) precapture\n     * metering sequence can be canceled through setting\n     * {@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger} to CANCEL.</p>\n     * <p>Once PRECAPTURE completes, AE will transition to CONVERGED\n     * or FLASH_REQUIRED as appropriate. This is a transient\n     * state, the camera device may skip reporting this state in\n     * capture result.</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER\n     * @see CaptureResult#CONTROL_AE_STATE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER" ]
  }, {
    "name" : "CONTROL_AF_STATE_INACTIVE",
    "type" : "int",
    "comment" : "\n     * <p>AF is off or has not yet tried to scan/been asked\n     * to scan.</p>\n     * <p>When a camera device is opened, it starts in this\n     * state. This is a transient state, the camera device may\n     * skip reporting this state in capture\n     * result.</p>\n     * @see CaptureResult#CONTROL_AF_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AF_STATE_PASSIVE_SCAN",
    "type" : "int",
    "comment" : "\n     * <p>AF is currently performing an AF scan initiated the\n     * camera device in a continuous autofocus mode.</p>\n     * <p>Only used by CONTINUOUS_* AF modes. This is a transient\n     * state, the camera device may skip reporting this state in\n     * capture result.</p>\n     * @see CaptureResult#CONTROL_AF_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AF_STATE_PASSIVE_FOCUSED",
    "type" : "int",
    "comment" : "\n     * <p>AF currently believes it is in focus, but may\n     * restart scanning at any time.</p>\n     * <p>Only used by CONTINUOUS_* AF modes. This is a transient\n     * state, the camera device may skip reporting this state in\n     * capture result.</p>\n     * @see CaptureResult#CONTROL_AF_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AF_STATE_ACTIVE_SCAN",
    "type" : "int",
    "comment" : "\n     * <p>AF is performing an AF scan because it was\n     * triggered by AF trigger.</p>\n     * <p>Only used by AUTO or MACRO AF modes. This is a transient\n     * state, the camera device may skip reporting this state in\n     * capture result.</p>\n     * @see CaptureResult#CONTROL_AF_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AF_STATE_FOCUSED_LOCKED",
    "type" : "int",
    "comment" : "\n     * <p>AF believes it is focused correctly and has locked\n     * focus.</p>\n     * <p>This state is reached only after an explicit START AF trigger has been\n     * sent ({@link CaptureRequest#CONTROL_AF_TRIGGER android.control.afTrigger}), when good focus has been obtained.</p>\n     * <p>The lens will remain stationary until the AF mode ({@link CaptureRequest#CONTROL_AF_MODE android.control.afMode}) is changed or\n     * a new AF trigger is sent to the camera device ({@link CaptureRequest#CONTROL_AF_TRIGGER android.control.afTrigger}).</p>\n     *\n     * @see CaptureRequest#CONTROL_AF_MODE\n     * @see CaptureRequest#CONTROL_AF_TRIGGER\n     * @see CaptureResult#CONTROL_AF_STATE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#CONTROL_AF_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_AF_TRIGGER" ]
  }, {
    "name" : "CONTROL_AF_STATE_NOT_FOCUSED_LOCKED",
    "type" : "int",
    "comment" : "\n     * <p>AF has failed to focus successfully and has locked\n     * focus.</p>\n     * <p>This state is reached only after an explicit START AF trigger has been\n     * sent ({@link CaptureRequest#CONTROL_AF_TRIGGER android.control.afTrigger}), when good focus cannot be obtained.</p>\n     * <p>The lens will remain stationary until the AF mode ({@link CaptureRequest#CONTROL_AF_MODE android.control.afMode}) is changed or\n     * a new AF trigger is sent to the camera device ({@link CaptureRequest#CONTROL_AF_TRIGGER android.control.afTrigger}).</p>\n     *\n     * @see CaptureRequest#CONTROL_AF_MODE\n     * @see CaptureRequest#CONTROL_AF_TRIGGER\n     * @see CaptureResult#CONTROL_AF_STATE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#CONTROL_AF_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_AF_TRIGGER" ]
  }, {
    "name" : "CONTROL_AF_STATE_PASSIVE_UNFOCUSED",
    "type" : "int",
    "comment" : "\n     * <p>AF finished a passive scan without finding focus,\n     * and may restart scanning at any time.</p>\n     * <p>Only used by CONTINUOUS_* AF modes. This is a transient state, the camera\n     * device may skip reporting this state in capture result.</p>\n     * <p>LEGACY camera devices do not support this state. When a passive\n     * scan has finished, it will always go to PASSIVE_FOCUSED.</p>\n     * @see CaptureResult#CONTROL_AF_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AWB_STATE_INACTIVE",
    "type" : "int",
    "comment" : "\n     * <p>AWB is not in auto mode, or has not yet started metering.</p>\n     * <p>When a camera device is opened, it starts in this\n     * state. This is a transient state, the camera device may\n     * skip reporting this state in capture\n     * result.</p>\n     * @see CaptureResult#CONTROL_AWB_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AWB_STATE_SEARCHING",
    "type" : "int",
    "comment" : "\n     * <p>AWB doesn't yet have a good set of control\n     * values for the current scene.</p>\n     * <p>This is a transient state, the camera device\n     * may skip reporting this state in capture result.</p>\n     * @see CaptureResult#CONTROL_AWB_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AWB_STATE_CONVERGED",
    "type" : "int",
    "comment" : "\n     * <p>AWB has a good set of control values for the\n     * current scene.</p>\n     * @see CaptureResult#CONTROL_AWB_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AWB_STATE_LOCKED",
    "type" : "int",
    "comment" : "\n     * <p>AWB has been locked.</p>\n     * @see CaptureResult#CONTROL_AWB_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AF_SCENE_CHANGE_NOT_DETECTED",
    "type" : "int",
    "comment" : "\n     * <p>Scene change is not detected within the AF region(s).</p>\n     * @see CaptureResult#CONTROL_AF_SCENE_CHANGE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AF_SCENE_CHANGE_DETECTED",
    "type" : "int",
    "comment" : "\n     * <p>Scene change is detected within the AF region(s).</p>\n     * @see CaptureResult#CONTROL_AF_SCENE_CHANGE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AUTOFRAMING_STATE_INACTIVE",
    "type" : "int",
    "comment" : "\n     * <p>Auto-framing is inactive.</p>\n     * @see CaptureResult#CONTROL_AUTOFRAMING_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AUTOFRAMING_STATE_FRAMING",
    "type" : "int",
    "comment" : "\n     * <p>Auto-framing is in process - either zooming in, zooming out or pan is taking place.</p>\n     * @see CaptureResult#CONTROL_AUTOFRAMING_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_AUTOFRAMING_STATE_CONVERGED",
    "type" : "int",
    "comment" : "\n     * <p>Auto-framing has reached a stable state (frame/fov is not being adjusted). The state\n     * may transition back to FRAMING if the scene changes.</p>\n     * @see CaptureResult#CONTROL_AUTOFRAMING_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_LOW_LIGHT_BOOST_STATE_INACTIVE",
    "type" : "int",
    "comment" : "\n     * <p>The AE mode 'ON_LOW_LIGHT_BOOST_BRIGHTNESS_PRIORITY' is enabled but not applied.</p>\n     * @see CaptureResult#CONTROL_LOW_LIGHT_BOOST_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTROL_LOW_LIGHT_BOOST_STATE_ACTIVE",
    "type" : "int",
    "comment" : "\n     * <p>The AE mode 'ON_LOW_LIGHT_BOOST_BRIGHTNESS_PRIORITY' is enabled and applied.</p>\n     * @see CaptureResult#CONTROL_LOW_LIGHT_BOOST_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "FLASH_STATE_UNAVAILABLE",
    "type" : "int",
    "comment" : "\n     * <p>No flash on camera.</p>\n     * @see CaptureResult#FLASH_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "FLASH_STATE_CHARGING",
    "type" : "int",
    "comment" : "\n     * <p>Flash is charging and cannot be fired.</p>\n     * @see CaptureResult#FLASH_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "FLASH_STATE_READY",
    "type" : "int",
    "comment" : "\n     * <p>Flash is ready to fire.</p>\n     * @see CaptureResult#FLASH_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "FLASH_STATE_FIRED",
    "type" : "int",
    "comment" : "\n     * <p>Flash fired for this capture.</p>\n     * @see CaptureResult#FLASH_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "FLASH_STATE_PARTIAL",
    "type" : "int",
    "comment" : "\n     * <p>Flash partially illuminated this frame.</p>\n     * <p>This is usually due to the next or previous frame having\n     * the flash fire, and the flash spilling into this capture\n     * due to hardware limitations.</p>\n     * @see CaptureResult#FLASH_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "LENS_STATE_STATIONARY",
    "type" : "int",
    "comment" : "\n     * <p>The lens parameters ({@link CaptureRequest#LENS_FOCAL_LENGTH android.lens.focalLength}, {@link CaptureRequest#LENS_FOCUS_DISTANCE android.lens.focusDistance},\n     * {@link CaptureRequest#LENS_FILTER_DENSITY android.lens.filterDensity} and {@link CaptureRequest#LENS_APERTURE android.lens.aperture}) are not changing.</p>\n     *\n     * @see CaptureRequest#LENS_APERTURE\n     * @see CaptureRequest#LENS_FILTER_DENSITY\n     * @see CaptureRequest#LENS_FOCAL_LENGTH\n     * @see CaptureRequest#LENS_FOCUS_DISTANCE\n     * @see CaptureResult#LENS_STATE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#LENS_APERTURE", "android.hardware.camera2.CaptureRequest#LENS_FOCAL_LENGTH", "android.hardware.camera2.CaptureRequest#LENS_FILTER_DENSITY", "android.hardware.camera2.CaptureRequest#LENS_FOCUS_DISTANCE" ]
  }, {
    "name" : "LENS_STATE_MOVING",
    "type" : "int",
    "comment" : "\n     * <p>One or several of the lens parameters\n     * ({@link CaptureRequest#LENS_FOCAL_LENGTH android.lens.focalLength}, {@link CaptureRequest#LENS_FOCUS_DISTANCE android.lens.focusDistance},\n     * {@link CaptureRequest#LENS_FILTER_DENSITY android.lens.filterDensity} or {@link CaptureRequest#LENS_APERTURE android.lens.aperture}) is\n     * currently changing.</p>\n     *\n     * @see CaptureRequest#LENS_APERTURE\n     * @see CaptureRequest#LENS_FILTER_DENSITY\n     * @see CaptureRequest#LENS_FOCAL_LENGTH\n     * @see CaptureRequest#LENS_FOCUS_DISTANCE\n     * @see CaptureResult#LENS_STATE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#LENS_APERTURE", "android.hardware.camera2.CaptureRequest#LENS_FOCAL_LENGTH", "android.hardware.camera2.CaptureRequest#LENS_FILTER_DENSITY", "android.hardware.camera2.CaptureRequest#LENS_FOCUS_DISTANCE" ]
  }, {
    "name" : "STATISTICS_SCENE_FLICKER_NONE",
    "type" : "int",
    "comment" : "\n     * <p>The camera device does not detect any flickering illumination\n     * in the current scene.</p>\n     * @see CaptureResult#STATISTICS_SCENE_FLICKER\n     ",
    "links" : [ ]
  }, {
    "name" : "STATISTICS_SCENE_FLICKER_50HZ",
    "type" : "int",
    "comment" : "\n     * <p>The camera device detects illumination flickering at 50Hz\n     * in the current scene.</p>\n     * @see CaptureResult#STATISTICS_SCENE_FLICKER\n     ",
    "links" : [ ]
  }, {
    "name" : "STATISTICS_SCENE_FLICKER_60HZ",
    "type" : "int",
    "comment" : "\n     * <p>The camera device detects illumination flickering at 60Hz\n     * in the current scene.</p>\n     * @see CaptureResult#STATISTICS_SCENE_FLICKER\n     ",
    "links" : [ ]
  }, {
    "name" : "SYNC_FRAME_NUMBER_CONVERGING",
    "type" : "int",
    "comment" : "\n     * <p>The current result is not yet fully synchronized to any request.</p>\n     * <p>Synchronization is in progress, and reading metadata from this\n     * result may include a mix of data that have taken effect since the\n     * last synchronization time.</p>\n     * <p>In some future result, within {@link CameraCharacteristics#SYNC_MAX_LATENCY android.sync.maxLatency} frames,\n     * this value will update to the actual frame number frame number\n     * the result is guaranteed to be synchronized to (as long as the\n     * request settings remain constant).</p>\n     *\n     * @see CameraCharacteristics#SYNC_MAX_LATENCY\n     * @see CaptureResult#SYNC_FRAME_NUMBER\n     * @hide\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#SYNC_MAX_LATENCY" ]
  }, {
    "name" : "SYNC_FRAME_NUMBER_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * <p>The current result's synchronization status is unknown.</p>\n     * <p>The result may have already converged, or it may be in\n     * progress.  Reading from this result may include some mix\n     * of settings from past requests.</p>\n     * <p>After a settings change, the new settings will eventually all\n     * take effect for the output buffers and results. However, this\n     * value will not change when that happens. Altering settings\n     * rapidly may provide outcomes using mixes of settings from recent\n     * requests.</p>\n     * <p>This value is intended primarily for backwards compatibility with\n     * the older camera implementations (for android.hardware.Camera).</p>\n     * @see CaptureResult#SYNC_FRAME_NUMBER\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "protected abstract T getProtected(TKey key)",
    "returnType" : "T",
    "comment" : "\n     * Get a camera metadata field value.\n     *\n     * <p>The field definitions can be\n     * found in {@link CameraCharacteristics}, {@link CaptureResult}, and\n     * {@link CaptureRequest}.</p>\n     *\n     * <p>Querying the value for the same key more than once will return a value\n     * which is equal to the previous queried value.</p>\n     *\n     * @throws IllegalArgumentException if the key was not valid\n     *\n     * @param key The metadata field to read.\n     * @return The value of that key, or {@code null} if the field is not set.\n     *\n     * @hide\n     ",
    "links" : [ "android.hardware.camera2.CaptureResult", "android.hardware.camera2.CameraCharacteristics", "android.hardware.camera2.CaptureRequest" ]
  }, {
    "name" : "protected void setNativeInstance(CameraMetadataNative nativeInstance)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getNativeMetadataPtr()",
    "returnType" : "long",
    "comment" : "\n     * Retrieves the native std::shared_ptr<CameraMetadata*>* as a Java long.\n     * Returns 0 if mNativeInstance is null.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public CameraMetadataNative getNativeMetadata()",
    "returnType" : "CameraMetadataNative",
    "comment" : "\n     * Retrieves the CameraMetadataNative instance.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected abstract Class<TKey> getKeyClass()",
    "returnType" : "Class<TKey>",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<TKey> getKeys()",
    "returnType" : "List<TKey>",
    "comment" : "\n     * Returns a list of the keys contained in this map.\n     *\n     * <p>The list returned is not modifiable, so any attempts to modify it will throw\n     * a {@code UnsupportedOperationException}.</p>\n     *\n     * <p>All values retrieved by a key from this list with {@code #get} are guaranteed to be\n     * non-{@code null}. Each key is only listed once in the list. The order of the keys\n     * is undefined.</p>\n     *\n     * @return List of the keys contained in this map.\n     ",
    "links" : [ ]
  }, {
    "name" : " ArrayList<TKey> getKeys(Class<?> type, Class<TKey> keyClass, CameraMetadata<TKey> instance, int[] filterTags, boolean includeSynthetic)",
    "returnType" : "ArrayList<TKey>",
    "comment" : "package",
    "links" : [ ]
  }, {
    "name" : "private static boolean shouldKeyBeAdded(TKey key, Field field, int[] filterTags, boolean includeSynthetic)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ "protected abstract T getProtected(TKey key)", "protected void setNativeInstance(CameraMetadataNative nativeInstance)", "public long getNativeMetadataPtr()", "public CameraMetadataNative getNativeMetadata()", "protected abstract Class<TKey> getKeyClass()", "public List<TKey> getKeys()", " ArrayList<TKey> getKeys(Class<?> type, Class<TKey> keyClass, CameraMetadata<TKey> instance, int[] filterTags, boolean includeSynthetic)", "private static boolean shouldKeyBeAdded(TKey key, Field field, int[] filterTags, boolean includeSynthetic)" ],
  "variableNames" : [ "TAG", "DEBUG", "mNativeInstance", "LENS_INFO_FOCUS_DISTANCE_CALIBRATION_UNCALIBRATED", "LENS_INFO_FOCUS_DISTANCE_CALIBRATION_APPROXIMATE", "LENS_INFO_FOCUS_DISTANCE_CALIBRATION_CALIBRATED", "LENS_FACING_FRONT", "LENS_FACING_BACK", "LENS_FACING_EXTERNAL", "LENS_POSE_REFERENCE_PRIMARY_CAMERA", "LENS_POSE_REFERENCE_GYROSCOPE", "LENS_POSE_REFERENCE_UNDEFINED", "LENS_POSE_REFERENCE_AUTOMOTIVE", "REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE", "REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR", "REQUEST_AVAILABLE_CAPABILITIES_MANUAL_POST_PROCESSING", "REQUEST_AVAILABLE_CAPABILITIES_RAW", "REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING", "REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS", "REQUEST_AVAILABLE_CAPABILITIES_BURST_CAPTURE", "REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING", "REQUEST_AVAILABLE_CAPABILITIES_DEPTH_OUTPUT", "REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO", "REQUEST_AVAILABLE_CAPABILITIES_MOTION_TRACKING", "REQUEST_AVAILABLE_CAPABILITIES_LOGICAL_MULTI_CAMERA", "REQUEST_AVAILABLE_CAPABILITIES_MONOCHROME", "REQUEST_AVAILABLE_CAPABILITIES_SECURE_IMAGE_DATA", "REQUEST_AVAILABLE_CAPABILITIES_SYSTEM_CAMERA", "REQUEST_AVAILABLE_CAPABILITIES_OFFLINE_PROCESSING", "REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR", "REQUEST_AVAILABLE_CAPABILITIES_REMOSAIC_REPROCESSING", "REQUEST_AVAILABLE_CAPABILITIES_DYNAMIC_RANGE_TEN_BIT", "REQUEST_AVAILABLE_CAPABILITIES_STREAM_USE_CASE", "REQUEST_AVAILABLE_CAPABILITIES_COLOR_SPACE_PROFILES", "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD", "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HLG10", "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HDR10", "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HDR10_PLUS", "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_REF", "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_REF_PO", "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_OEM", "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_OEM_PO", "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_REF", "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_REF_PO", "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_OEM", "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_OEM_PO", "REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_MAX", "REQUEST_AVAILABLE_COLOR_SPACE_PROFILES_MAP_UNSPECIFIED", "SCALER_CROPPING_TYPE_CENTER_ONLY", "SCALER_CROPPING_TYPE_FREEFORM", "SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT", "SCALER_AVAILABLE_STREAM_USE_CASES_PREVIEW", "SCALER_AVAILABLE_STREAM_USE_CASES_STILL_CAPTURE", "SCALER_AVAILABLE_STREAM_USE_CASES_VIDEO_RECORD", "SCALER_AVAILABLE_STREAM_USE_CASES_PREVIEW_VIDEO_STILL", "SCALER_AVAILABLE_STREAM_USE_CASES_VIDEO_CALL", "SCALER_AVAILABLE_STREAM_USE_CASES_CROPPED_RAW", "SCALER_AVAILABLE_STREAM_USE_CASES_VENDOR_START", "SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGGB", "SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GRBG", "SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GBRG", "SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_BGGR", "SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGB", "SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_MONO", "SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_NIR", "SENSOR_INFO_TIMESTAMP_SOURCE_UNKNOWN", "SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME", "SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT", "SENSOR_REFERENCE_ILLUMINANT1_FLUORESCENT", "SENSOR_REFERENCE_ILLUMINANT1_TUNGSTEN", "SENSOR_REFERENCE_ILLUMINANT1_FLASH", "SENSOR_REFERENCE_ILLUMINANT1_FINE_WEATHER", "SENSOR_REFERENCE_ILLUMINANT1_CLOUDY_WEATHER", "SENSOR_REFERENCE_ILLUMINANT1_SHADE", "SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT_FLUORESCENT", "SENSOR_REFERENCE_ILLUMINANT1_DAY_WHITE_FLUORESCENT", "SENSOR_REFERENCE_ILLUMINANT1_COOL_WHITE_FLUORESCENT", "SENSOR_REFERENCE_ILLUMINANT1_WHITE_FLUORESCENT", "SENSOR_REFERENCE_ILLUMINANT1_STANDARD_A", "SENSOR_REFERENCE_ILLUMINANT1_STANDARD_B", "SENSOR_REFERENCE_ILLUMINANT1_STANDARD_C", "SENSOR_REFERENCE_ILLUMINANT1_D55", "SENSOR_REFERENCE_ILLUMINANT1_D65", "SENSOR_REFERENCE_ILLUMINANT1_D75", "SENSOR_REFERENCE_ILLUMINANT1_D50", "SENSOR_REFERENCE_ILLUMINANT1_ISO_STUDIO_TUNGSTEN", "SENSOR_READOUT_TIMESTAMP_NOT_SUPPORTED", "SENSOR_READOUT_TIMESTAMP_HARDWARE", "LED_AVAILABLE_LEDS_TRANSMIT", "INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED", "INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY", "INFO_SUPPORTED_HARDWARE_LEVEL_3", "INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL", "SYNC_MAX_LATENCY_PER_FRAME_CONTROL", "SYNC_MAX_LATENCY_UNKNOWN", "LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_APPROXIMATE", "LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_CALIBRATED", "AUTOMOTIVE_LENS_FACING_EXTERIOR_OTHER", "AUTOMOTIVE_LENS_FACING_EXTERIOR_FRONT", "AUTOMOTIVE_LENS_FACING_EXTERIOR_REAR", "AUTOMOTIVE_LENS_FACING_EXTERIOR_LEFT", "AUTOMOTIVE_LENS_FACING_EXTERIOR_RIGHT", "AUTOMOTIVE_LENS_FACING_INTERIOR_OTHER", "AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_1_LEFT", "AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_1_CENTER", "AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_1_RIGHT", "AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_2_LEFT", "AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_2_CENTER", "AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_2_RIGHT", "AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_3_LEFT", "AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_3_CENTER", "AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_3_RIGHT", "AUTOMOTIVE_LOCATION_INTERIOR", "AUTOMOTIVE_LOCATION_EXTERIOR_OTHER", "AUTOMOTIVE_LOCATION_EXTERIOR_FRONT", "AUTOMOTIVE_LOCATION_EXTERIOR_REAR", "AUTOMOTIVE_LOCATION_EXTERIOR_LEFT", "AUTOMOTIVE_LOCATION_EXTERIOR_RIGHT", "AUTOMOTIVE_LOCATION_EXTRA_OTHER", "AUTOMOTIVE_LOCATION_EXTRA_FRONT", "AUTOMOTIVE_LOCATION_EXTRA_REAR", "AUTOMOTIVE_LOCATION_EXTRA_LEFT", "AUTOMOTIVE_LOCATION_EXTRA_RIGHT", "COLOR_CORRECTION_MODE_TRANSFORM_MATRIX", "COLOR_CORRECTION_MODE_FAST", "COLOR_CORRECTION_MODE_HIGH_QUALITY", "COLOR_CORRECTION_ABERRATION_MODE_OFF", "COLOR_CORRECTION_ABERRATION_MODE_FAST", "COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY", "CONTROL_AE_ANTIBANDING_MODE_OFF", "CONTROL_AE_ANTIBANDING_MODE_50HZ", "CONTROL_AE_ANTIBANDING_MODE_60HZ", "CONTROL_AE_ANTIBANDING_MODE_AUTO", "CONTROL_AE_MODE_OFF", "CONTROL_AE_MODE_ON", "CONTROL_AE_MODE_ON_AUTO_FLASH", "CONTROL_AE_MODE_ON_ALWAYS_FLASH", "CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE", "CONTROL_AE_MODE_ON_EXTERNAL_FLASH", "CONTROL_AE_MODE_ON_LOW_LIGHT_BOOST_BRIGHTNESS_PRIORITY", "CONTROL_AE_PRECAPTURE_TRIGGER_IDLE", "CONTROL_AE_PRECAPTURE_TRIGGER_START", "CONTROL_AE_PRECAPTURE_TRIGGER_CANCEL", "CONTROL_AF_MODE_OFF", "CONTROL_AF_MODE_AUTO", "CONTROL_AF_MODE_MACRO", "CONTROL_AF_MODE_CONTINUOUS_VIDEO", "CONTROL_AF_MODE_CONTINUOUS_PICTURE", "CONTROL_AF_MODE_EDOF", "CONTROL_AF_TRIGGER_IDLE", "CONTROL_AF_TRIGGER_START", "CONTROL_AF_TRIGGER_CANCEL", "CONTROL_AWB_MODE_OFF", "CONTROL_AWB_MODE_AUTO", "CONTROL_AWB_MODE_INCANDESCENT", "CONTROL_AWB_MODE_FLUORESCENT", "CONTROL_AWB_MODE_WARM_FLUORESCENT", "CONTROL_AWB_MODE_DAYLIGHT", "CONTROL_AWB_MODE_CLOUDY_DAYLIGHT", "CONTROL_AWB_MODE_TWILIGHT", "CONTROL_AWB_MODE_SHADE", "CONTROL_CAPTURE_INTENT_CUSTOM", "CONTROL_CAPTURE_INTENT_PREVIEW", "CONTROL_CAPTURE_INTENT_STILL_CAPTURE", "CONTROL_CAPTURE_INTENT_VIDEO_RECORD", "CONTROL_CAPTURE_INTENT_VIDEO_SNAPSHOT", "CONTROL_CAPTURE_INTENT_ZERO_SHUTTER_LAG", "CONTROL_CAPTURE_INTENT_MANUAL", "CONTROL_CAPTURE_INTENT_MOTION_TRACKING", "CONTROL_EFFECT_MODE_OFF", "CONTROL_EFFECT_MODE_MONO", "CONTROL_EFFECT_MODE_NEGATIVE", "CONTROL_EFFECT_MODE_SOLARIZE", "CONTROL_EFFECT_MODE_SEPIA", "CONTROL_EFFECT_MODE_POSTERIZE", "CONTROL_EFFECT_MODE_WHITEBOARD", "CONTROL_EFFECT_MODE_BLACKBOARD", "CONTROL_EFFECT_MODE_AQUA", "CONTROL_MODE_OFF", "CONTROL_MODE_AUTO", "CONTROL_MODE_USE_SCENE_MODE", "CONTROL_MODE_OFF_KEEP_STATE", "CONTROL_MODE_USE_EXTENDED_SCENE_MODE", "CONTROL_SCENE_MODE_DISABLED", "CONTROL_SCENE_MODE_FACE_PRIORITY", "CONTROL_SCENE_MODE_ACTION", "CONTROL_SCENE_MODE_PORTRAIT", "CONTROL_SCENE_MODE_LANDSCAPE", "CONTROL_SCENE_MODE_NIGHT", "CONTROL_SCENE_MODE_NIGHT_PORTRAIT", "CONTROL_SCENE_MODE_THEATRE", "CONTROL_SCENE_MODE_BEACH", "CONTROL_SCENE_MODE_SNOW", "CONTROL_SCENE_MODE_SUNSET", "CONTROL_SCENE_MODE_STEADYPHOTO", "CONTROL_SCENE_MODE_FIREWORKS", "CONTROL_SCENE_MODE_SPORTS", "CONTROL_SCENE_MODE_PARTY", "CONTROL_SCENE_MODE_CANDLELIGHT", "CONTROL_SCENE_MODE_BARCODE", "CONTROL_SCENE_MODE_HIGH_SPEED_VIDEO", "CONTROL_SCENE_MODE_HDR", "CONTROL_SCENE_MODE_FACE_PRIORITY_LOW_LIGHT", "CONTROL_SCENE_MODE_DEVICE_CUSTOM_START", "CONTROL_SCENE_MODE_DEVICE_CUSTOM_END", "CONTROL_VIDEO_STABILIZATION_MODE_OFF", "CONTROL_VIDEO_STABILIZATION_MODE_ON", "CONTROL_VIDEO_STABILIZATION_MODE_PREVIEW_STABILIZATION", "CONTROL_EXTENDED_SCENE_MODE_DISABLED", "CONTROL_EXTENDED_SCENE_MODE_BOKEH_STILL_CAPTURE", "CONTROL_EXTENDED_SCENE_MODE_BOKEH_CONTINUOUS", "CONTROL_EXTENDED_SCENE_MODE_VENDOR_START", "CONTROL_SETTINGS_OVERRIDE_OFF", "CONTROL_SETTINGS_OVERRIDE_ZOOM", "CONTROL_SETTINGS_OVERRIDE_VENDOR_START", "CONTROL_AUTOFRAMING_OFF", "CONTROL_AUTOFRAMING_ON", "CONTROL_AUTOFRAMING_AUTO", "EDGE_MODE_OFF", "EDGE_MODE_FAST", "EDGE_MODE_HIGH_QUALITY", "EDGE_MODE_ZERO_SHUTTER_LAG", "FLASH_MODE_OFF", "FLASH_MODE_SINGLE", "FLASH_MODE_TORCH", "HOT_PIXEL_MODE_OFF", "HOT_PIXEL_MODE_FAST", "HOT_PIXEL_MODE_HIGH_QUALITY", "LENS_OPTICAL_STABILIZATION_MODE_OFF", "LENS_OPTICAL_STABILIZATION_MODE_ON", "NOISE_REDUCTION_MODE_OFF", "NOISE_REDUCTION_MODE_FAST", "NOISE_REDUCTION_MODE_HIGH_QUALITY", "NOISE_REDUCTION_MODE_MINIMAL", "NOISE_REDUCTION_MODE_ZERO_SHUTTER_LAG", "SCALER_ROTATE_AND_CROP_NONE", "SCALER_ROTATE_AND_CROP_90", "SCALER_ROTATE_AND_CROP_180", "SCALER_ROTATE_AND_CROP_270", "SCALER_ROTATE_AND_CROP_AUTO", "SENSOR_TEST_PATTERN_MODE_OFF", "SENSOR_TEST_PATTERN_MODE_SOLID_COLOR", "SENSOR_TEST_PATTERN_MODE_COLOR_BARS", "SENSOR_TEST_PATTERN_MODE_COLOR_BARS_FADE_TO_GRAY", "SENSOR_TEST_PATTERN_MODE_PN9", "SENSOR_TEST_PATTERN_MODE_BLACK", "SENSOR_TEST_PATTERN_MODE_CUSTOM1", "SENSOR_PIXEL_MODE_DEFAULT", "SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION", "SHADING_MODE_OFF", "SHADING_MODE_FAST", "SHADING_MODE_HIGH_QUALITY", "STATISTICS_FACE_DETECT_MODE_OFF", "STATISTICS_FACE_DETECT_MODE_SIMPLE", "STATISTICS_FACE_DETECT_MODE_FULL", "STATISTICS_LENS_SHADING_MAP_MODE_OFF", "STATISTICS_LENS_SHADING_MAP_MODE_ON", "STATISTICS_OIS_DATA_MODE_OFF", "STATISTICS_OIS_DATA_MODE_ON", "TONEMAP_MODE_CONTRAST_CURVE", "TONEMAP_MODE_FAST", "TONEMAP_MODE_HIGH_QUALITY", "TONEMAP_MODE_GAMMA_VALUE", "TONEMAP_MODE_PRESET_CURVE", "TONEMAP_PRESET_CURVE_SRGB", "TONEMAP_PRESET_CURVE_REC709", "DISTORTION_CORRECTION_MODE_OFF", "DISTORTION_CORRECTION_MODE_FAST", "DISTORTION_CORRECTION_MODE_HIGH_QUALITY", "EFV_STABILIZATION_MODE_OFF", "EFV_STABILIZATION_MODE_GIMBAL", "EFV_STABILIZATION_MODE_LOCKED", "CONTROL_AE_STATE_INACTIVE", "CONTROL_AE_STATE_SEARCHING", "CONTROL_AE_STATE_CONVERGED", "CONTROL_AE_STATE_LOCKED", "CONTROL_AE_STATE_FLASH_REQUIRED", "CONTROL_AE_STATE_PRECAPTURE", "CONTROL_AF_STATE_INACTIVE", "CONTROL_AF_STATE_PASSIVE_SCAN", "CONTROL_AF_STATE_PASSIVE_FOCUSED", "CONTROL_AF_STATE_ACTIVE_SCAN", "CONTROL_AF_STATE_FOCUSED_LOCKED", "CONTROL_AF_STATE_NOT_FOCUSED_LOCKED", "CONTROL_AF_STATE_PASSIVE_UNFOCUSED", "CONTROL_AWB_STATE_INACTIVE", "CONTROL_AWB_STATE_SEARCHING", "CONTROL_AWB_STATE_CONVERGED", "CONTROL_AWB_STATE_LOCKED", "CONTROL_AF_SCENE_CHANGE_NOT_DETECTED", "CONTROL_AF_SCENE_CHANGE_DETECTED", "CONTROL_AUTOFRAMING_STATE_INACTIVE", "CONTROL_AUTOFRAMING_STATE_FRAMING", "CONTROL_AUTOFRAMING_STATE_CONVERGED", "CONTROL_LOW_LIGHT_BOOST_STATE_INACTIVE", "CONTROL_LOW_LIGHT_BOOST_STATE_ACTIVE", "FLASH_STATE_UNAVAILABLE", "FLASH_STATE_CHARGING", "FLASH_STATE_READY", "FLASH_STATE_FIRED", "FLASH_STATE_PARTIAL", "LENS_STATE_STATIONARY", "LENS_STATE_MOVING", "STATISTICS_SCENE_FLICKER_NONE", "STATISTICS_SCENE_FLICKER_50HZ", "STATISTICS_SCENE_FLICKER_60HZ", "SYNC_FRAME_NUMBER_CONVERGING", "SYNC_FRAME_NUMBER_UNKNOWN" ]
}