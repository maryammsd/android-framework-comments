{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/media/MediaRecorder.java",
  "packageName" : "android.media",
  "className" : "MediaRecorder",
  "comment" : "\n * Used to record audio and video. The recording control is based on a\n * simple state machine (see below).\n *\n * <p><img src=\"{@docRoot}images/mediarecorder_state_diagram.gif\" border=\"0\" />\n * </p>\n *\n * <p>A common case of using MediaRecorder to record audio works as follows:\n *\n * <pre>\n * MediaRecorder recorder = new MediaRecorder(context);\n * recorder.setAudioSource(MediaRecorder.AudioSource.MIC);\n * recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);\n * recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);\n * recorder.setOutputFile(PATH_NAME);\n * recorder.prepare();\n * recorder.start();   // Recording is now started\n * ...\n * recorder.stop();\n * recorder.reset();   // You can reuse the object by going back to setAudioSource() step\n * recorder.release(); // Now the object cannot be reused\n * </pre>\n *\n * <p>Applications may want to register for informational and error\n * events in order to be informed of some internal update and possible\n * runtime errors during recording. Registration for such events is\n * done by setting the appropriate listeners (via calls\n * (to {@link #setOnInfoListener(OnInfoListener)}setOnInfoListener and/or\n * {@link #setOnErrorListener(OnErrorListener)}setOnErrorListener).\n * In order to receive the respective callback associated with these listeners,\n * applications are required to create MediaRecorder objects on threads with a\n * Looper running (the main UI thread by default already has a Looper running).\n *\n * <p><strong>Note:</strong> Currently, MediaRecorder does not work on the emulator.\n *\n * <div class=\"special reference\">\n * <h3>Developer Guides</h3>\n * <p>For more information about how to use MediaRecorder for recording video, read the\n * <a href=\"{@docRoot}guide/topics/media/camera.html#capture-video\">Camera</a> developer guide.\n * For more information about how to use MediaRecorder for recording sound, read the\n * <a href=\"{@docRoot}guide/topics/media/audio-capture.html\">Audio Capture</a> developer guide.</p>\n * </div>\n ",
  "links" : [ "#setOnInfoListener(OnInfoListener)", "#setOnErrorListener(OnErrorListener)" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mNativeContext",
    "type" : "long",
    "comment" : " The two fields below are accessed by native methods",
    "links" : [ ]
  }, {
    "name" : "mSurface",
    "type" : "Surface",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPath",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFd",
    "type" : "FileDescriptor",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFile",
    "type" : "File",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mEventHandler",
    "type" : "EventHandler",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOnErrorListener",
    "type" : "OnErrorListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOnInfoListener",
    "type" : "OnInfoListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mChannelCount",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLogSessionId",
    "type" : "LogSessionId",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MEDIA_RECORDER_ERROR_UNKNOWN",
    "type" : "int",
    "comment" : " Unspecified media recorder error.\n     * @see android.media.MediaRecorder.OnErrorListener\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_ERROR_SERVER_DIED",
    "type" : "int",
    "comment" : " Media server died. In this case, the application must release the\n     * MediaRecorder object and instantiate a new one.\n     * @see android.media.MediaRecorder.OnErrorListener\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_RECORDER_INFO_UNKNOWN",
    "type" : "int",
    "comment" : " Unspecified media recorder info.\n     * @see android.media.MediaRecorder.OnInfoListener\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_RECORDER_INFO_MAX_DURATION_REACHED",
    "type" : "int",
    "comment" : " A maximum duration had been setup and has now been reached.\n     * @see android.media.MediaRecorder.OnInfoListener\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED",
    "type" : "int",
    "comment" : " A maximum filesize had been setup and has now been reached.\n     * Note: This event will not be sent if application already set\n     * next output file through {@link #setNextOutputFile}.\n     * @see android.media.MediaRecorder.OnInfoListener\n     ",
    "links" : [ "#setNextOutputFile" ]
  }, {
    "name" : "MEDIA_RECORDER_INFO_MAX_FILESIZE_APPROACHING",
    "type" : "int",
    "comment" : " A maximum filesize had been setup and current recorded file size\n     * has reached 90% of the limit. This is sent once per file upon\n     * reaching/passing the 90% limit. To continue the recording, applicaiton\n     * should use {@link #setNextOutputFile} to set the next output file.\n     * Otherwise, recording will stop when reaching maximum file size.\n     * @see android.media.MediaRecorder.OnInfoListener\n     ",
    "links" : [ "#setNextOutputFile" ]
  }, {
    "name" : "MEDIA_RECORDER_INFO_NEXT_OUTPUT_FILE_STARTED",
    "type" : "int",
    "comment" : " A maximum filesize had been reached and MediaRecorder has switched\n     * output to a new file set by application {@link #setNextOutputFile}.\n     * For best practice, application should use this event to keep track\n     * of whether the file previously set has been used or not.\n     * @see android.media.MediaRecorder.OnInfoListener\n     ",
    "links" : [ "#setNextOutputFile" ]
  }, {
    "name" : "MEDIA_RECORDER_TRACK_INFO_LIST_START",
    "type" : "int",
    "comment" : " informational events for individual tracks, for testing purpose.\n     * The track informational event usually contains two parts in the ext1\n     * arg of the onInfo() callback: bit 31-28 contains the track id; and\n     * the rest of the 28 bits contains the informational event defined here.\n     * For example, ext1 = (1 << 28 | MEDIA_RECORDER_TRACK_INFO_TYPE) if the\n     * track id is 1 for informational event MEDIA_RECORDER_TRACK_INFO_TYPE;\n     * while ext1 = (0 << 28 | MEDIA_RECORDER_TRACK_INFO_TYPE) if the track\n     * id is 0 for informational event MEDIA_RECORDER_TRACK_INFO_TYPE. The\n     * application should extract the track id and the type of informational\n     * event from ext1, accordingly.\n     *\n     * FIXME:\n     * Please update the comment for onInfo also when these\n     * events are unhidden so that application knows how to extract the track\n     * id and the informational event type from onInfo callback.\n     *\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_RECORDER_TRACK_INFO_COMPLETION_STATUS",
    "type" : "int",
    "comment" : " Signal the completion of the track for the recording session.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_RECORDER_TRACK_INFO_PROGRESS_IN_TIME",
    "type" : "int",
    "comment" : " Indicate the recording progress in time (ms) during recording.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_RECORDER_TRACK_INFO_TYPE",
    "type" : "int",
    "comment" : " Indicate the track type: 0 for Audio and 1 for Video.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_RECORDER_TRACK_INFO_DURATION_MS",
    "type" : "int",
    "comment" : " Provide the track duration information.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_RECORDER_TRACK_INFO_MAX_CHUNK_DUR_MS",
    "type" : "int",
    "comment" : " Provide the max chunk duration in time (ms) for the given track.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_RECORDER_TRACK_INFO_ENCODED_FRAMES",
    "type" : "int",
    "comment" : " Provide the total number of recordd frames.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_RECORDER_TRACK_INTER_CHUNK_TIME_MS",
    "type" : "int",
    "comment" : " Provide the max spacing between neighboring chunks for the given track.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_RECORDER_TRACK_INFO_INITIAL_DELAY_MS",
    "type" : "int",
    "comment" : " Provide the elapsed time measuring from the start of the recording\n     * till the first output frame of the given track is received, excluding\n     * any intentional start time offset of a recording session for the\n     * purpose of eliminating the recording sound in the recorded file.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_RECORDER_TRACK_INFO_START_OFFSET_MS",
    "type" : "int",
    "comment" : " Provide the start time difference (delay) betweeen this track and\n     * the start of the movie.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_RECORDER_TRACK_INFO_DATA_KBYTES",
    "type" : "int",
    "comment" : " Provide the total number of data (in kilo-bytes) encoded.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_RECORDER_TRACK_INFO_LIST_END",
    "type" : "int",
    "comment" : "\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "mPreferredDevice",
    "type" : "AudioDeviceInfo",
    "comment" : "--------------------",
    "links" : [ ]
  }, {
    "name" : "mRoutingChangeListeners",
    "type" : "ArrayMap<AudioRouting.OnRoutingChangedListener, NativeRoutingEventHandlerDelegate>",
    "comment" : "\n     * The list of AudioRouting.OnRoutingChangedListener interfaces added (with\n     * {@link #addOnRoutingChangedListener(android.media.AudioRouting.OnRoutingChangedListener, Handler)}\n     * by an app to receive (re)routing notifications.\n     ",
    "links" : [ "#addOnRoutingChangedListener(android.media.AudioRouting.OnRoutingChangedListener" ]
  }, {
    "name" : "mRecordingInfoImpl",
    "type" : "AudioRecordingMonitorImpl",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public void setLogSessionId(@NonNull LogSessionId id)",
    "returnType" : "void",
    "comment" : "\n     *\n     * Sets the {@link LogSessionId} for MediaRecorder.\n     *\n     * <p>The log session ID is a random 32-byte hexadecimal string that is used for monitoring the\n     * MediaRecorder performance.</p>\n     *\n     * @param id the global ID for monitoring the MediaRecorder performance\n     ",
    "links" : [ "android.media.metrics.LogSessionId" ]
  }, {
    "name" : "public LogSessionId getLogSessionId()",
    "returnType" : "LogSessionId",
    "comment" : "\n     * Returns the {@link LogSessionId} for MediaRecorder.\n     *\n     * @return the global ID for monitoring the MediaRecorder performance\n     ",
    "links" : [ "android.media.metrics.LogSessionId" ]
  }, {
    "name" : "public native void setCamera(Camera c)",
    "returnType" : "void",
    "comment" : "\n     * Sets a {@link android.hardware.Camera} to use for recording.\n     *\n     * <p>Use this function to switch quickly between preview and capture mode without a teardown of\n     * the camera object. {@link android.hardware.Camera#unlock()} should be called before\n     * this. Must call before {@link #prepare}.</p>\n     *\n     * @param c the Camera to use for recording\n     * @deprecated Use {@link #getSurface} and the {@link android.hardware.camera2} API instead.\n     ",
    "links" : [ "#getSurface", "android.hardware.Camera#unlock()", "#prepare", "android.hardware.camera2", "android.hardware.Camera" ]
  }, {
    "name" : "public native Surface getSurface()",
    "returnType" : "Surface",
    "comment" : "\n     * Gets the surface to record from when using SURFACE video source.\n     *\n     * <p> May only be called after {@link #prepare}. Frames rendered to the Surface before\n     * {@link #start} will be discarded.</p>\n     *\n     * @throws IllegalStateException if it is called before {@link #prepare}, after\n     * {@link #stop}, or is called when VideoSource is not set to SURFACE.\n     * @see android.media.MediaRecorder.VideoSource\n     ",
    "links" : [ "#stop", "#prepare", "#start" ]
  }, {
    "name" : "public void setInputSurface(@NonNull Surface surface)",
    "returnType" : "void",
    "comment" : "\n     * Configures the recorder to use a persistent surface when using SURFACE video source.\n     * <p> May only be called before {@link #prepare}. If called, {@link #getSurface} should\n     * not be used and will throw IllegalStateException. Frames rendered to the Surface\n     * before {@link #start} will be discarded.</p>\n\n     * @param surface a persistent input surface created by\n     *           {@link MediaCodec#createPersistentInputSurface}\n     * @throws IllegalStateException if it is called after {@link #prepare} and before\n     * {@link #stop}.\n     * @throws IllegalArgumentException if the surface was not created by\n     *           {@link MediaCodec#createPersistentInputSurface}.\n     * @see MediaCodec#createPersistentInputSurface\n     * @see MediaRecorder.VideoSource\n     ",
    "links" : [ "#getSurface", "android.media.MediaCodec#createPersistentInputSurface", "#stop", "#prepare", "#start" ]
  }, {
    "name" : "private final native void native_setInputSurface(@NonNull Surface surface)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setPreviewDisplay(Surface sv)",
    "returnType" : "void",
    "comment" : "\n     * Sets a Surface to show a preview of recorded media (video). Calls this\n     * before prepare() to make sure that the desirable preview display is\n     * set. If {@link #setCamera(Camera)} is used and the surface has been\n     * already set to the camera, application do not need to call this. If\n     * this is called with non-null surface, the preview surface of the camera\n     * will be replaced by the new surface. If this method is called with null\n     * surface or not called at all, media recorder will not change the preview\n     * surface of the camera.\n     *\n     * @param sv the Surface to use for the preview\n     * @see android.hardware.Camera#setPreviewDisplay(android.view.SurfaceHolder)\n     ",
    "links" : [ "#setCamera(Camera)" ]
  }, {
    "name" : "public static boolean isSystemOnlyAudioSource(int source)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * @param source An audio source to test\n     * @return true if the source is only visible to system components\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isValidAudioSource(int source)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * @param source An audio source to test\n     * @return true if the source is a valid one\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final String toLogFriendlyAudioSource(int source)",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public native void setAudioSource(@Source int audioSource) throws IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Sets the audio source to be used for recording. If this method is not\n     * called, the output file will not contain an audio track. The source needs\n     * to be specified before setting recording-parameters or encoders. Call\n     * this only before setOutputFormat().\n     *\n     * @param audioSource the audio source to use\n     * @throws IllegalStateException if it is called after setOutputFormat()\n     * @see android.media.MediaRecorder.AudioSource\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final int getAudioSourceMax()",
    "returnType" : "int",
    "comment" : "\n     * Gets the maximum value for audio sources.\n     * @see android.media.MediaRecorder.AudioSource\n     ",
    "links" : [ ]
  }, {
    "name" : "public native void setPrivacySensitive(boolean privacySensitive)",
    "returnType" : "void",
    "comment" : "\n     * Indicates that this capture request is privacy sensitive and that\n     * any concurrent capture is not permitted.\n     * <p>\n     * The default is not privacy sensitive except when the audio source set with\n     * {@link #setAudioSource(int)} is {@link AudioSource#VOICE_COMMUNICATION} or\n     * {@link AudioSource#CAMCORDER}.\n     * <p>\n     * Always takes precedence over default from audio source when set explicitly.\n     * <p>\n     * Using this API is only permitted when the audio source is one of:\n     * <ul>\n     * <li>{@link AudioSource#MIC}</li>\n     * <li>{@link AudioSource#CAMCORDER}</li>\n     * <li>{@link AudioSource#VOICE_RECOGNITION}</li>\n     * <li>{@link AudioSource#VOICE_COMMUNICATION}</li>\n     * <li>{@link AudioSource#UNPROCESSED}</li>\n     * <li>{@link AudioSource#VOICE_PERFORMANCE}</li>\n     * </ul>\n     * Invoking {@link #prepare()} will throw an IOException if this\n     * condition is not met.\n     * <p>\n     * Must be called after {@link #setAudioSource(int)} and before {@link #setOutputFormat(int)}.\n     * @param privacySensitive True if capture from this MediaRecorder must be marked as privacy\n     * sensitive, false otherwise.\n     * @throws IllegalStateException if called before {@link #setAudioSource(int)}\n     * or after {@link #setOutputFormat(int)}\n     ",
    "links" : [ "android.media.AudioSource#VOICE_COMMUNICATION", "#setOutputFormat(int)", "#prepare()", "android.media.AudioSource#MIC", "android.media.AudioSource#UNPROCESSED", "#setAudioSource(int)", "android.media.AudioSource#CAMCORDER", "android.media.AudioSource#VOICE_RECOGNITION", "android.media.AudioSource#VOICE_PERFORMANCE" ]
  }, {
    "name" : "public native boolean isPrivacySensitive()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether this MediaRecorder is marked as privacy sensitive or not with\n     * regard to audio capture.\n     * <p>\n     * See {@link #setPrivacySensitive(boolean)}\n     * <p>\n     * @return true if privacy sensitive, false otherwise\n     ",
    "links" : [ "#setPrivacySensitive(boolean)" ]
  }, {
    "name" : "public native void setVideoSource(int video_source) throws IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Sets the video source to be used for recording. If this method is not\n     * called, the output file will not contain an video track. The source needs\n     * to be specified before setting recording-parameters or encoders. Call\n     * this only before setOutputFormat().\n     *\n     * @param video_source the video source to use\n     * @throws IllegalStateException if it is called after setOutputFormat()\n     * @see android.media.MediaRecorder.VideoSource\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setProfile(CamcorderProfile profile)",
    "returnType" : "void",
    "comment" : "\n     * Uses the settings from a CamcorderProfile object for recording. This method should\n     * be called after the video AND audio sources are set, and before setOutputFile().\n     * If a time lapse CamcorderProfile is used, audio related source or recording\n     * parameters are ignored.\n     *\n     * @param profile the CamcorderProfile to use\n     * @see android.media.CamcorderProfile\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAudioProfile(@NonNull EncoderProfiles.AudioProfile profile)",
    "returnType" : "void",
    "comment" : "\n     * Uses the settings from an AudioProfile for recording.\n     * <p>\n     * This method should be called after the video AND audio sources are set, and before\n     * setOutputFile().\n     * <p>\n     * This method can be used instead of {@link #setProfile} when using EncoderProfiles.\n     *\n     * @param profile the AudioProfile to use\n     * @see android.media.EncoderProfiles\n     * @see android.media.CamcorderProfile#getAll\n     ",
    "links" : [ "#setProfile" ]
  }, {
    "name" : "public void setVideoProfile(@NonNull EncoderProfiles.VideoProfile profile)",
    "returnType" : "void",
    "comment" : "\n     * Uses the settings from a VideoProfile object for recording.\n     * <p>\n     * This method should be called after the video AND audio sources are set, and before\n     * setOutputFile().\n     * <p>\n     * This method can be used instead of {@link #setProfile} when using EncoderProfiles.\n     *\n     * @param profile the VideoProfile to use\n     * @see android.media.EncoderProfiles\n     * @see android.media.CamcorderProfile#getAll\n     ",
    "links" : [ "#setProfile" ]
  }, {
    "name" : "public void setCaptureRate(double fps)",
    "returnType" : "void",
    "comment" : "\n     * Set video frame capture rate. This can be used to set a different video frame capture\n     * rate than the recorded video's playback rate. This method also sets the recording mode\n     * to time lapse. In time lapse video recording, only video is recorded. Audio related\n     * parameters are ignored when a time lapse recording session starts, if an application\n     * sets them.\n     *\n     * @param fps Rate at which frames should be captured in frames per second.\n     * The fps can go as low as desired. However the fastest fps will be limited by the hardware.\n     * For resolutions that can be captured by the video camera, the fastest fps can be computed using\n     * {@link android.hardware.Camera.Parameters#getPreviewFpsRange(int[])}. For higher\n     * resolutions the fastest fps may be more restrictive.\n     * Note that the recorder cannot guarantee that frames will be captured at the\n     * given rate due to camera/encoder limitations. However it tries to be as close as\n     * possible.\n     ",
    "links" : [ "android.hardware.Camera.Parameters#getPreviewFpsRange(int" ]
  }, {
    "name" : "public void setOrientationHint(int degrees)",
    "returnType" : "void",
    "comment" : "\n     * Sets the orientation hint for output video playback.\n     * This method should be called before prepare(). This method will not\n     * trigger the source video frame to rotate during video recording, but to\n     * add a composition matrix containing the rotation angle in the output\n     * video if the output format is OutputFormat.THREE_GPP or\n     * OutputFormat.MPEG_4 so that a video player can choose the proper\n     * orientation for playback. Note that some video players may choose\n     * to ignore the compostion matrix in a video during playback.\n     *\n     * @param degrees the angle to be rotated clockwise in degrees.\n     * The supported angles are 0, 90, 180, and 270 degrees.\n     * @throws IllegalArgumentException if the angle is not supported.\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setLocation(float latitude, float longitude)",
    "returnType" : "void",
    "comment" : "\n     * Set and store the geodata (latitude and longitude) in the output file.\n     * This method should be called before prepare(). The geodata is\n     * stored in udta box if the output format is OutputFormat.THREE_GPP\n     * or OutputFormat.MPEG_4, and is ignored for other output formats.\n     * The geodata is stored according to ISO-6709 standard.\n     *\n     * @param latitude latitude in degrees. Its value must be in the\n     * range [-90, 90].\n     * @param longitude longitude in degrees. Its value must be in the\n     * range [-180, 180].\n     *\n     * @throws IllegalArgumentException if the given latitude or\n     * longitude is out of range.\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "public native void setOutputFormat(@OutputFormatValues int output_format) throws IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Sets the format of the output file produced during recording. Call this\n     * after setAudioSource()/setVideoSource() but before prepare().\n     *\n     * <p>It is recommended to always use 3GP format when using the H.263\n     * video encoder and AMR audio encoder. Using an MPEG-4 container format\n     * may confuse some desktop players.</p>\n     *\n     * @param output_format the output format to use. The output format\n     * needs to be specified before setting recording-parameters or encoders.\n     * @throws IllegalStateException if it is called after prepare() or before\n     * setAudioSource()/setVideoSource().\n     * @see android.media.MediaRecorder.OutputFormat\n     ",
    "links" : [ ]
  }, {
    "name" : "public native void setVideoSize(int width, int height) throws IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Sets the width and height of the video to be captured.  Must be called\n     * after setVideoSource(). Call this after setOutputFormat() but before\n     * prepare().\n     *\n     * @param width the width of the video to be captured\n     * @param height the height of the video to be captured\n     * @throws IllegalStateException if it is called after\n     * prepare() or before setOutputFormat()\n     ",
    "links" : [ ]
  }, {
    "name" : "public native void setVideoFrameRate(int rate) throws IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Sets the frame rate of the video to be captured.  Must be called\n     * after setVideoSource(). Call this after setOutputFormat() but before\n     * prepare().\n     *\n     * <p>NOTE: On some devices that have auto-frame rate, this sets the\n     * maximum frame rate, not a constant frame rate. Actual frame rate\n     * will vary according to lighting conditions.</p>\n     *\n     * @param rate the number of frames per second of video to capture\n     * @throws IllegalStateException if it is called after\n     * prepare() or before setOutputFormat().\n     ",
    "links" : [ ]
  }, {
    "name" : "public native void setMaxDuration(int max_duration_ms) throws IllegalArgumentException",
    "returnType" : "void",
    "comment" : "\n     * Sets the maximum duration (in ms) of the recording session.\n     * Call this after setOutputFormat() but before prepare().\n     * After recording reaches the specified duration, a notification\n     * will be sent to the {@link android.media.MediaRecorder.OnInfoListener}\n     * with a \"what\" code of {@link #MEDIA_RECORDER_INFO_MAX_DURATION_REACHED}\n     * and recording will be stopped. Stopping happens asynchronously, there\n     * is no guarantee that the recorder will have stopped by the time the\n     * listener is notified.\n     *\n     * <p>When using MPEG-4 container ({@link #setOutputFormat(int)} with\n     * {@link OutputFormat#MPEG_4}), it is recommended to set maximum duration that fits the use\n     * case. Setting a larger than required duration may result in a larger than needed output file\n     * because of space reserved for MOOV box expecting large movie data in this recording session.\n     *  Unused space of MOOV box is turned into FREE box in the output file.</p>\n     *\n     * @param max_duration_ms the maximum duration in ms (if zero or negative, disables the duration limit)\n     *\n     ",
    "links" : [ "#setOutputFormat(int)", "#MPEG_4", "#MEDIA_RECORDER_INFO_MAX_DURATION_REACHED", "android.media.MediaRecorder.OnInfoListener" ]
  }, {
    "name" : "public native void setMaxFileSize(long max_filesize_bytes) throws IllegalArgumentException",
    "returnType" : "void",
    "comment" : "\n     * Sets the maximum filesize (in bytes) of the recording session.\n     * Call this after setOutputFormat() but before prepare().\n     * After recording reaches the specified filesize, a notification\n     * will be sent to the {@link android.media.MediaRecorder.OnInfoListener}\n     * with a \"what\" code of {@link #MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED}\n     * and recording will be stopped. Stopping happens asynchronously, there\n     * is no guarantee that the recorder will have stopped by the time the\n     * listener is notified.\n     *\n     * <p>When using MPEG-4 container ({@link #setOutputFormat(int)} with\n     * {@link OutputFormat#MPEG_4}), it is recommended to set maximum filesize that fits the use\n     * case. Setting a larger than required filesize may result in a larger than needed output file\n     * because of space reserved for MOOV box expecting large movie data in this recording session.\n     * Unused space of MOOV box is turned into FREE box in the output file.</p>\n     *\n     * @param max_filesize_bytes the maximum filesize in bytes (if zero or negative, disables the limit)\n     *\n     ",
    "links" : [ "#setOutputFormat(int)", "#MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED", "#MPEG_4", "android.media.MediaRecorder.OnInfoListener" ]
  }, {
    "name" : "public native void setAudioEncoder(@AudioEncoderValues int audio_encoder) throws IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Sets the audio encoder to be used for recording. If this method is not\n     * called, the output file will not contain an audio track. Call this after\n     * setOutputFormat() but before prepare().\n     *\n     * @param audio_encoder the audio encoder to use.\n     * @throws IllegalStateException if it is called before\n     * setOutputFormat() or after prepare().\n     * @see android.media.MediaRecorder.AudioEncoder\n     ",
    "links" : [ ]
  }, {
    "name" : "public native void setVideoEncoder(@VideoEncoderValues int video_encoder) throws IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Sets the video encoder to be used for recording. If this method is not\n     * called, the output file will not contain an video track. Call this after\n     * setOutputFormat() and before prepare().\n     *\n     * @param video_encoder the video encoder to use.\n     * @throws IllegalStateException if it is called before\n     * setOutputFormat() or after prepare()\n     * @see android.media.MediaRecorder.VideoEncoder\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAudioSamplingRate(int samplingRate)",
    "returnType" : "void",
    "comment" : "\n     * Sets the audio sampling rate for recording. Call this method before prepare().\n     * Prepare() may perform additional checks on the parameter to make sure whether\n     * the specified audio sampling rate is applicable. The sampling rate really depends\n     * on the format for the audio recording, as well as the capabilities of the platform.\n     * For instance, the sampling rate supported by AAC audio coding standard ranges\n     * from 8 to 96 kHz, the sampling rate supported by AMRNB is 8kHz, and the sampling\n     * rate supported by AMRWB is 16kHz. Please consult with the related audio coding\n     * standard for the supported audio sampling rate.\n     *\n     * @param samplingRate the sampling rate for audio in samples per second.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAudioChannels(int numChannels)",
    "returnType" : "void",
    "comment" : "\n     * Sets the number of audio channels for recording. Call this method before prepare().\n     * Prepare() may perform additional checks on the parameter to make sure whether the\n     * specified number of audio channels are applicable.\n     *\n     * @param numChannels the number of audio channels. Usually it is either 1 (mono) or 2\n     * (stereo).\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAudioEncodingBitRate(int bitRate)",
    "returnType" : "void",
    "comment" : "\n     * Sets the audio encoding bit rate for recording. Call this method before prepare().\n     * Prepare() may perform additional checks on the parameter to make sure whether the\n     * specified bit rate is applicable, and sometimes the passed bitRate will be clipped\n     * internally to ensure the audio recording can proceed smoothly based on the\n     * capabilities of the platform.\n     *\n     * @param bitRate the audio encoding bit rate in bits per second.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setVideoEncodingBitRate(int bitRate)",
    "returnType" : "void",
    "comment" : "\n     * Sets the video encoding bit rate for recording. Call this method before prepare().\n     * Prepare() may perform additional checks on the parameter to make sure whether the\n     * specified bit rate is applicable, and sometimes the passed bitRate will be\n     * clipped internally to ensure the video recording can proceed smoothly based on\n     * the capabilities of the platform.\n     *\n     * <p>\n     * NB: the actual bitrate and other encoding characteristics may be affected by\n     * the minimum quality floor behavior introduced in\n     * {@link android.os.Build.VERSION_CODES#S}. More detail on how and where this\n     * impacts video encoding can be found in the\n     * {@link MediaCodec} page and looking for \"quality floor\" (near the top of the page).\n     *\n     * @param bitRate the video encoding bit rate in bits per second.\n     ",
    "links" : [ "android.media.MediaCodec", "android.os.Build.VERSION_CODES#S" ]
  }, {
    "name" : "public void setVideoEncodingProfileLevel(int profile, int level)",
    "returnType" : "void",
    "comment" : "\n     * Sets the desired video encoding profile and level for recording. The profile and level\n     * must be valid for the video encoder set by {@link #setVideoEncoder}. This method can\n     * called before or after {@link #setVideoEncoder} but it must be called before {@link #prepare}.\n     * {@code prepare()} may perform additional checks on the parameter to make sure that the specified\n     * profile and level are applicable, and sometimes the passed profile or level will be\n     * discarded due to codec capablity or to ensure the video recording can proceed smoothly\n     * based on the capabilities of the platform. <br>Application can also use the\n     * {@link MediaCodecInfo.CodecCapabilities#profileLevels} to query applicable combination of profile\n     * and level for the corresponding format. Note that the requested profile/level may not be supported by\n     * the codec that is actually being used by this MediaRecorder instance.\n     * @param profile declared in {@link MediaCodecInfo.CodecProfileLevel}.\n     * @param level declared in {@link MediaCodecInfo.CodecProfileLevel}.\n     * @throws IllegalArgumentException when an invalid profile or level value is used.\n     ",
    "links" : [ "MediaCodecInfo.CodecProfileLevel", "MediaCodecInfo.CodecCapabilities#profileLevels", "#setVideoEncoder", "#prepare" ]
  }, {
    "name" : "public void setAuxiliaryOutputFile(FileDescriptor fd)",
    "returnType" : "void",
    "comment" : "\n     * Currently not implemented. It does nothing.\n     * @deprecated Time lapse mode video recording using camera still image capture\n     * is not desirable, and will not be supported.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAuxiliaryOutputFile(String path)",
    "returnType" : "void",
    "comment" : "\n     * Currently not implemented. It does nothing.\n     * @deprecated Time lapse mode video recording using camera still image capture\n     * is not desirable, and will not be supported.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOutputFile(FileDescriptor fd) throws IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Pass in the file descriptor of the file to be written. Call this after\n     * setOutputFormat() but before prepare().\n     *\n     * @param fd an open file descriptor to be written into.\n     * @throws IllegalStateException if it is called before\n     * setOutputFormat() or after prepare()\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOutputFile(File file)",
    "returnType" : "void",
    "comment" : "\n     * Pass in the file object to be written. Call this after setOutputFormat() but before prepare().\n     * File should be seekable. After setting the next output file, application should not use the\n     * file until {@link #stop}. Application is responsible for cleaning up unused files after\n     * {@link #stop} is called.\n     *\n     * @param file the file object to be written into.\n     ",
    "links" : [ "#stop" ]
  }, {
    "name" : "public void setNextOutputFile(FileDescriptor fd) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Sets the next output file descriptor to be used when the maximum filesize is reached\n     * on the prior output {@link #setOutputFile} or {@link #setNextOutputFile}). File descriptor\n     * must be seekable and writable. After setting the next output file, application should not\n     * use the file referenced by this file descriptor until {@link #stop}. It is the application's\n     * responsibility to close the file descriptor. It is safe to do so as soon as this call returns.\n     * Application must call this after receiving on the\n     * {@link android.media.MediaRecorder.OnInfoListener} a \"what\" code of\n     * {@link #MEDIA_RECORDER_INFO_MAX_FILESIZE_APPROACHING} and before receiving a \"what\" code of\n     * {@link #MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED}. The file is not used until switching to\n     * that output. Application will receive{@link #MEDIA_RECORDER_INFO_NEXT_OUTPUT_FILE_STARTED}\n     * when the next output file is used. Application will not be able to set a new output file if\n     * the previous one has not been used. Application is responsible for cleaning up unused files\n     * after {@link #stop} is called.\n     *\n     * @param fd an open file descriptor to be written into.\n     * @throws IllegalStateException if it is called before prepare().\n     * @throws IOException if setNextOutputFile fails otherwise.\n     ",
    "links" : [ "#stop", "#MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED", "#MEDIA_RECORDER_INFO_MAX_FILESIZE_APPROACHING", "#MEDIA_RECORDER_INFO_NEXT_OUTPUT_FILE_STARTED", "#setNextOutputFile", "#setOutputFile", "android.media.MediaRecorder.OnInfoListener" ]
  }, {
    "name" : "public void setOutputFile(String path) throws IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Sets the path of the output file to be produced. Call this after\n     * setOutputFormat() but before prepare().\n     *\n     * @param path The pathname to use.\n     * @throws IllegalStateException if it is called before\n     * setOutputFormat() or after prepare()\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setNextOutputFile(File file) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Sets the next output file to be used when the maximum filesize is reached on the prior\n     * output {@link #setOutputFile} or {@link #setNextOutputFile}). File should be seekable.\n     * After setting the next output file, application should not use the file until {@link #stop}.\n     * Application must call this after receiving on the\n     * {@link android.media.MediaRecorder.OnInfoListener} a \"what\" code of\n     * {@link #MEDIA_RECORDER_INFO_MAX_FILESIZE_APPROACHING} and before receiving a \"what\" code of\n     * {@link #MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED}. The file is not used until switching to\n     * that output. Application will receive {@link #MEDIA_RECORDER_INFO_NEXT_OUTPUT_FILE_STARTED}\n     * when the next output file is used. Application will not be able to set a new output file if\n     * the previous one has not been used. Application is responsible for cleaning up unused files\n     * after {@link #stop} is called.\n     *\n     * @param  file The file to use.\n     * @throws IllegalStateException if it is called before prepare().\n     * @throws IOException if setNextOutputFile fails otherwise.\n     ",
    "links" : [ "#stop", "#MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED", "#MEDIA_RECORDER_INFO_MAX_FILESIZE_APPROACHING", "#MEDIA_RECORDER_INFO_NEXT_OUTPUT_FILE_STARTED", "#setNextOutputFile", "#setOutputFile", "android.media.MediaRecorder.OnInfoListener" ]
  }, {
    "name" : "private native void _setOutputFile(FileDescriptor fd) throws IllegalStateException, IOException",
    "returnType" : "void",
    "comment" : " native implementation",
    "links" : [ ]
  }, {
    "name" : "private native void _setNextOutputFile(FileDescriptor fd) throws IllegalStateException, IOException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native void _prepare() throws IllegalStateException, IOException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void prepare() throws IllegalStateException, IOException",
    "returnType" : "void",
    "comment" : "\n     * Prepares the recorder to begin capturing and encoding data. This method\n     * must be called after setting up the desired audio and video sources,\n     * encoders, file format, etc., but before start().\n     *\n     * @throws IllegalStateException if it is called after\n     * start() or before setOutputFormat().\n     * @throws IOException if prepare fails otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public native void start() throws IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Begins capturing and encoding data to the file specified with\n     * setOutputFile(). Call this after prepare().\n     *\n     * <p>Since API level 13, if applications set a camera via\n     * {@link #setCamera(Camera)}, the apps can use the camera after this method\n     * call. The apps do not need to lock the camera again. However, if this\n     * method fails, the apps should still lock the camera back. The apps should\n     * not start another recording session during recording.\n     *\n     * @throws IllegalStateException if it is called before\n     * prepare() or when the camera is already in use by another app.\n     ",
    "links" : [ "#setCamera(Camera)" ]
  }, {
    "name" : "public native void stop() throws IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Stops recording. Call this after start(). Once recording is stopped,\n     * you will have to configure it again as if it has just been constructed.\n     * Note that a RuntimeException is intentionally thrown to the\n     * application, if no valid audio/video data has been received when stop()\n     * is called. This happens if stop() is called immediately after\n     * start(). The failure lets the application take action accordingly to\n     * clean up the output file (delete the output file, for instance), since\n     * the output file is not properly constructed when this happens.\n     *\n     * @throws IllegalStateException if it is called before start()\n     ",
    "links" : [ ]
  }, {
    "name" : "public native void pause() throws IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Pauses recording. Call this after start(). You may resume recording\n     * with resume() without reconfiguration, as opposed to stop(). It does\n     * nothing if the recording is already paused.\n     *\n     * When the recording is paused and resumed, the resulting output would\n     * be as if nothing happend during paused period, immediately switching\n     * to the resumed scene.\n     *\n     * @throws IllegalStateException if it is called before start() or after\n     * stop()\n     ",
    "links" : [ ]
  }, {
    "name" : "public native void resume() throws IllegalStateException",
    "returnType" : "void",
    "comment" : "\n     * Resumes recording. Call this after start(). It does nothing if the\n     * recording is not paused.\n     *\n     * @throws IllegalStateException if it is called before start() or after\n     * stop()\n     * @see android.media.MediaRecorder#pause\n     ",
    "links" : [ ]
  }, {
    "name" : "public void reset()",
    "returnType" : "void",
    "comment" : "\n     * Restarts the MediaRecorder to its idle state. After calling\n     * this method, you will have to configure it again as if it had just been\n     * constructed.\n     ",
    "links" : [ ]
  }, {
    "name" : "private native void native_reset()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public native int getMaxAmplitude() throws IllegalStateException",
    "returnType" : "int",
    "comment" : "\n     * Returns the maximum absolute amplitude that was sampled since the last\n     * call to this method. Call this only after the setAudioSource().\n     *\n     * @return the maximum absolute amplitude measured since the last call, or\n     * 0 when called for the first time\n     * @throws IllegalStateException if it is called before\n     * the audio source has been set.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOnErrorListener(OnErrorListener l)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be invoked when an error occurs while\n     * recording.\n     *\n     * @param l the callback that will be run\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOnInfoListener(OnInfoListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be invoked when an informational event occurs while\n     * recording.\n     *\n     * @param listener the callback that will be run\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setPreferredDevice(AudioDeviceInfo deviceInfo)",
    "returnType" : "boolean",
    "comment" : "\n     * Specifies an audio device (via an {@link AudioDeviceInfo} object) to route\n     * the input from this MediaRecorder.\n     * @param deviceInfo The {@link AudioDeviceInfo} specifying the audio source.\n     *  If deviceInfo is null, default routing is restored.\n     * @return true if succesful, false if the specified {@link AudioDeviceInfo} is non-null and\n     * does not correspond to a valid audio input device.\n     ",
    "links" : [ "android.media.AudioDeviceInfo" ]
  }, {
    "name" : "public AudioDeviceInfo getPreferredDevice()",
    "returnType" : "AudioDeviceInfo",
    "comment" : "\n     * Returns the selected input device specified by {@link #setPreferredDevice}. Note that this\n     * is not guaranteed to correspond to the actual device being used for recording.\n     ",
    "links" : [ "#setPreferredDevice" ]
  }, {
    "name" : "public AudioDeviceInfo getRoutedDevice()",
    "returnType" : "AudioDeviceInfo",
    "comment" : "\n     * Returns an {@link AudioDeviceInfo} identifying the current routing of this MediaRecorder\n     * Note: The query is only valid if the MediaRecorder is currently recording.\n     * If the recorder is not recording, the returned device can be null or correspond to previously\n     * selected device when the recorder was last active.\n     ",
    "links" : [ "android.media.AudioDeviceInfo" ]
  }, {
    "name" : "private void enableNativeRoutingCallbacksLocked(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Call BEFORE adding a routing callback handler or AFTER removing a routing callback handler.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addOnRoutingChangedListener(AudioRouting.OnRoutingChangedListener listener, Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Adds an {@link AudioRouting.OnRoutingChangedListener} to receive notifications of routing\n     * changes on this MediaRecorder.\n     * @param listener The {@link AudioRouting.OnRoutingChangedListener} interface to receive\n     * notifications of rerouting events.\n     * @param handler  Specifies the {@link Handler} object for the thread on which to execute\n     * the callback. If <code>null</code>, the handler on the main looper will be used.\n     ",
    "links" : [ "android.os.Handler", "AudioRouting.OnRoutingChangedListener" ]
  }, {
    "name" : "public void removeOnRoutingChangedListener(AudioRouting.OnRoutingChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes an {@link AudioRouting.OnRoutingChangedListener} which has been previously added\n     * to receive rerouting notifications.\n     * @param listener The previously added {@link AudioRouting.OnRoutingChangedListener} interface\n     * to remove.\n     ",
    "links" : [ "AudioRouting.OnRoutingChangedListener" ]
  }, {
    "name" : "private final native boolean native_setInputDevice(int deviceId)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native int native_getRoutedDeviceId()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private final native void native_enableDeviceCallback(boolean enabled)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public List<MicrophoneInfo> getActiveMicrophones() throws IOException",
    "returnType" : "List<MicrophoneInfo>",
    "comment" : "\n     * Return A lists of {@link MicrophoneInfo} representing the active microphones.\n     * By querying channel mapping for each active microphone, developer can know how\n     * the microphone is used by each channels or a capture stream.\n     *\n     * @return a lists of {@link MicrophoneInfo} representing the active microphones\n     * @throws IOException if an error occurs\n     ",
    "links" : [ "android.media.MicrophoneInfo" ]
  }, {
    "name" : "private final native int native_getActiveMicrophones(ArrayList<MicrophoneInfo> activeMicrophones)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean setPreferredMicrophoneDirection(@DirectionMode int direction)",
    "returnType" : "boolean",
    "comment" : "\n     * Specifies the logical microphone (for processing).\n     *\n     * @param direction Direction constant.\n     * @return true if sucessful.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setPreferredMicrophoneFieldDimension(@FloatRange(from = -1.0, to = 1.0) float zoom)",
    "returnType" : "boolean",
    "comment" : "\n     * Specifies the zoom factor (i.e. the field dimension) for the selected microphone\n     * (for processing). The selected microphone is determined by the use-case for the stream.\n     *\n     * @param zoom the desired field dimension of microphone capture. Range is from -1 (wide angle),\n     * though 0 (no zoom) to 1 (maximum zoom).\n     * @return true if sucessful.\n     ",
    "links" : [ ]
  }, {
    "name" : "private native int native_setPreferredMicrophoneDirection(int direction)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int native_setPreferredMicrophoneFieldDimension(float zoom)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void registerAudioRecordingCallback(@NonNull @CallbackExecutor Executor executor, @NonNull AudioManager.AudioRecordingCallback cb)",
    "returnType" : "void",
    "comment" : "\n     * Register a callback to be notified of audio capture changes via a\n     * {@link AudioManager.AudioRecordingCallback}. A callback is received when the capture path\n     * configuration changes (pre-processing, format, sampling rate...) or capture is\n     * silenced/unsilenced by the system.\n     * @param executor {@link Executor} to handle the callbacks.\n     * @param cb non-null callback to register\n     ",
    "links" : [ "AudioManager.AudioRecordingCallback", "android.annotation.CallbackExecutor" ]
  }, {
    "name" : "public void unregisterAudioRecordingCallback(@NonNull AudioManager.AudioRecordingCallback cb)",
    "returnType" : "void",
    "comment" : "\n     * Unregister an audio recording callback previously registered with\n     * {@link #registerAudioRecordingCallback(Executor, AudioManager.AudioRecordingCallback)}.\n     * @param cb non-null callback to unregister\n     ",
    "links" : [ "#registerAudioRecordingCallback(Executor" ]
  }, {
    "name" : "public AudioRecordingConfiguration getActiveRecordingConfiguration()",
    "returnType" : "AudioRecordingConfiguration",
    "comment" : "\n     * Returns the current active audio recording for this audio recorder.\n     * @return a valid {@link AudioRecordingConfiguration} if this recorder is active\n     * or null otherwise.\n     * @see AudioRecordingConfiguration\n     ",
    "links" : [ "android.media.AudioRecordingConfiguration" ]
  }, {
    "name" : "public int getPortId()",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private native int native_getPortId()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void postEventFromNative(Object mediarecorder_ref, int what, int arg1, int arg2, Object obj)",
    "returnType" : "void",
    "comment" : "\n     * Called from native code when an interesting event happens.  This method\n     * just uses the EventHandler system to post the event back to the main app thread.\n     * We use a weak reference to the original MediaRecorder object so that the native\n     * code is safe from the object disappearing from underneath it.  (This is\n     * the cookie passed to native_setup().)\n     ",
    "links" : [ ]
  }, {
    "name" : "public native void release()",
    "returnType" : "void",
    "comment" : "\n     * Releases resources associated with this MediaRecorder object.\n     * It is good practice to call this method when you're done\n     * using the MediaRecorder. In particular, whenever an Activity\n     * of an application is paused (its onPause() method is called),\n     * or stopped (its onStop() method is called), this method should be\n     * invoked to release the MediaRecorder object, unless the application\n     * has a special need to keep the object around. In addition to\n     * unnecessary resources (such as memory and instances of codecs)\n     * being held, failure to call this method immediately if a\n     * MediaRecorder object is no longer needed may also lead to\n     * continuous battery consumption for mobile devices, and recording\n     * failure for other applications if no multiple instances of the\n     * same codec are supported on a device. Even if multiple instances\n     * of the same codec are supported, some performance degradation\n     * may be expected when unnecessary multiple instances are used\n     * at the same time.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static final native void native_init()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void native_setup(Object mediarecorderThis, String clientName, String opPackageName) throws IllegalStateException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native void native_setup(Object mediarecorderThis, String clientName, @NonNull Parcel attributionSource) throws IllegalStateException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native void native_finalize()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native void setParameter(String nameValuePair)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public PersistableBundle getMetrics()",
    "returnType" : "PersistableBundle",
    "comment" : "\n     *  Return Metrics data about the current Mediarecorder instance.\n     *\n     * @return a {@link PersistableBundle} containing the set of attributes and values\n     * available for the media being generated by this instance of\n     * MediaRecorder.\n     * The attributes are descibed in {@link MetricsConstants}.\n     *\n     *  Additional vendor-specific fields may also be present in\n     *  the return value.\n     ",
    "links" : [ "MetricsConstants", "android.os.PersistableBundle" ]
  }, {
    "name" : "private native PersistableBundle native_getMetrics()",
    "returnType" : "PersistableBundle",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void finalize()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ "public void setLogSessionId(@NonNull LogSessionId id)", "public LogSessionId getLogSessionId()", "public native void setCamera(Camera c)", "public native Surface getSurface()", "public void setInputSurface(@NonNull Surface surface)", "private final native void native_setInputSurface(@NonNull Surface surface)", "public void setPreviewDisplay(Surface sv)", "public static boolean isSystemOnlyAudioSource(int source)", "public static boolean isValidAudioSource(int source)", "public static final String toLogFriendlyAudioSource(int source)", "public native void setAudioSource(@Source int audioSource) throws IllegalStateException", "public static final int getAudioSourceMax()", "public native void setPrivacySensitive(boolean privacySensitive)", "public native boolean isPrivacySensitive()", "public native void setVideoSource(int video_source) throws IllegalStateException", "public void setProfile(CamcorderProfile profile)", "public void setAudioProfile(@NonNull EncoderProfiles.AudioProfile profile)", "public void setVideoProfile(@NonNull EncoderProfiles.VideoProfile profile)", "public void setCaptureRate(double fps)", "public void setOrientationHint(int degrees)", "public void setLocation(float latitude, float longitude)", "public native void setOutputFormat(@OutputFormatValues int output_format) throws IllegalStateException", "public native void setVideoSize(int width, int height) throws IllegalStateException", "public native void setVideoFrameRate(int rate) throws IllegalStateException", "public native void setMaxDuration(int max_duration_ms) throws IllegalArgumentException", "public native void setMaxFileSize(long max_filesize_bytes) throws IllegalArgumentException", "public native void setAudioEncoder(@AudioEncoderValues int audio_encoder) throws IllegalStateException", "public native void setVideoEncoder(@VideoEncoderValues int video_encoder) throws IllegalStateException", "public void setAudioSamplingRate(int samplingRate)", "public void setAudioChannels(int numChannels)", "public void setAudioEncodingBitRate(int bitRate)", "public void setVideoEncodingBitRate(int bitRate)", "public void setVideoEncodingProfileLevel(int profile, int level)", "public void setAuxiliaryOutputFile(FileDescriptor fd)", "public void setAuxiliaryOutputFile(String path)", "public void setOutputFile(FileDescriptor fd) throws IllegalStateException", "public void setOutputFile(File file)", "public void setNextOutputFile(FileDescriptor fd) throws IOException", "public void setOutputFile(String path) throws IllegalStateException", "public void setNextOutputFile(File file) throws IOException", "private native void _setOutputFile(FileDescriptor fd) throws IllegalStateException, IOException", "private native void _setNextOutputFile(FileDescriptor fd) throws IllegalStateException, IOException", "private native void _prepare() throws IllegalStateException, IOException", "public void prepare() throws IllegalStateException, IOException", "public native void start() throws IllegalStateException", "public native void stop() throws IllegalStateException", "public native void pause() throws IllegalStateException", "public native void resume() throws IllegalStateException", "public void reset()", "private native void native_reset()", "public native int getMaxAmplitude() throws IllegalStateException", "public void setOnErrorListener(OnErrorListener l)", "public void setOnInfoListener(OnInfoListener listener)", "public boolean setPreferredDevice(AudioDeviceInfo deviceInfo)", "public AudioDeviceInfo getPreferredDevice()", "public AudioDeviceInfo getRoutedDevice()", "private void enableNativeRoutingCallbacksLocked(boolean enabled)", "public void addOnRoutingChangedListener(AudioRouting.OnRoutingChangedListener listener, Handler handler)", "public void removeOnRoutingChangedListener(AudioRouting.OnRoutingChangedListener listener)", "private final native boolean native_setInputDevice(int deviceId)", "private final native int native_getRoutedDeviceId()", "private final native void native_enableDeviceCallback(boolean enabled)", "public List<MicrophoneInfo> getActiveMicrophones() throws IOException", "private final native int native_getActiveMicrophones(ArrayList<MicrophoneInfo> activeMicrophones)", "public boolean setPreferredMicrophoneDirection(@DirectionMode int direction)", "public boolean setPreferredMicrophoneFieldDimension(@FloatRange(from = -1.0, to = 1.0) float zoom)", "private native int native_setPreferredMicrophoneDirection(int direction)", "private native int native_setPreferredMicrophoneFieldDimension(float zoom)", "public void registerAudioRecordingCallback(@NonNull @CallbackExecutor Executor executor, @NonNull AudioManager.AudioRecordingCallback cb)", "public void unregisterAudioRecordingCallback(@NonNull AudioManager.AudioRecordingCallback cb)", "public AudioRecordingConfiguration getActiveRecordingConfiguration()", "public int getPortId()", "private native int native_getPortId()", "private static void postEventFromNative(Object mediarecorder_ref, int what, int arg1, int arg2, Object obj)", "public native void release()", "private static final native void native_init()", "private void native_setup(Object mediarecorderThis, String clientName, String opPackageName) throws IllegalStateException", "private native void native_setup(Object mediarecorderThis, String clientName, @NonNull Parcel attributionSource) throws IllegalStateException", "private native void native_finalize()", "private native void setParameter(String nameValuePair)", "public PersistableBundle getMetrics()", "private native PersistableBundle native_getMetrics()", "protected void finalize()" ],
  "variableNames" : [ "TAG", "mNativeContext", "mSurface", "mPath", "mFd", "mFile", "mEventHandler", "mOnErrorListener", "mOnInfoListener", "mChannelCount", "mLogSessionId", "MEDIA_RECORDER_ERROR_UNKNOWN", "MEDIA_ERROR_SERVER_DIED", "MEDIA_RECORDER_INFO_UNKNOWN", "MEDIA_RECORDER_INFO_MAX_DURATION_REACHED", "MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED", "MEDIA_RECORDER_INFO_MAX_FILESIZE_APPROACHING", "MEDIA_RECORDER_INFO_NEXT_OUTPUT_FILE_STARTED", "MEDIA_RECORDER_TRACK_INFO_LIST_START", "MEDIA_RECORDER_TRACK_INFO_COMPLETION_STATUS", "MEDIA_RECORDER_TRACK_INFO_PROGRESS_IN_TIME", "MEDIA_RECORDER_TRACK_INFO_TYPE", "MEDIA_RECORDER_TRACK_INFO_DURATION_MS", "MEDIA_RECORDER_TRACK_INFO_MAX_CHUNK_DUR_MS", "MEDIA_RECORDER_TRACK_INFO_ENCODED_FRAMES", "MEDIA_RECORDER_TRACK_INTER_CHUNK_TIME_MS", "MEDIA_RECORDER_TRACK_INFO_INITIAL_DELAY_MS", "MEDIA_RECORDER_TRACK_INFO_START_OFFSET_MS", "MEDIA_RECORDER_TRACK_INFO_DATA_KBYTES", "MEDIA_RECORDER_TRACK_INFO_LIST_END", "mPreferredDevice", "mRoutingChangeListeners", "mRecordingInfoImpl" ]
}