{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/nio/file/spi/FileSystemProvider.java",
  "packageName" : "java.nio.file.spi",
  "className" : "FileSystemProvider",
  "comment" : "",
  "links" : [ ],
  "variables" : [ {
    "name" : "lock",
    "type" : "Object",
    "comment" : " lock using when loading providers",
    "links" : [ ]
  }, {
    "name" : "installedProviders",
    "type" : "List<FileSystemProvider>",
    "comment" : " installed providers",
    "links" : [ ]
  }, {
    "name" : "loadingProviders",
    "type" : "boolean",
    "comment" : " used to avoid recursive loading of instaled providers",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private static Void checkPermission()",
    "returnType" : "Void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static List<FileSystemProvider> loadInstalledProviders()",
    "returnType" : "List<FileSystemProvider>",
    "comment" : " loads all installed providers",
    "links" : [ ]
  }, {
    "name" : "public static List<FileSystemProvider> installedProviders()",
    "returnType" : "List<FileSystemProvider>",
    "comment" : "\n     * Returns a list of the installed file system providers.\n     *\n     * <p> The first invocation of this method causes the default provider to be\n     * initialized (if not already initialized) and loads any other installed\n     * providers as described by the {@link FileSystems} class.\n     *\n     * @return  An unmodifiable list of the installed file system providers. The\n     *          list contains at least one element, that is the default file\n     *          system provider\n     *\n     * @throws  ServiceConfigurationError\n     *          When an error occurs while loading a service provider\n     ",
    "links" : [ "FileSystems" ]
  }, {
    "name" : "public abstract String getScheme()",
    "returnType" : "String",
    "comment" : "\n     * Returns the URI scheme that identifies this provider.\n     *\n     * @return  The URI scheme\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract FileSystem newFileSystem(URI uri, Map<String, ?> env) throws IOException",
    "returnType" : "FileSystem",
    "comment" : "\n     * Constructs a new {@code FileSystem} object identified by a URI. This\n     * method is invoked by the {@link FileSystems#newFileSystem(URI,Map)}\n     * method to open a new file system identified by a URI.\n     *\n     * <p> The {@code uri} parameter is an absolute, hierarchical URI, with a\n     * scheme equal (without regard to case) to the scheme supported by this\n     * provider. The exact form of the URI is highly provider dependent. The\n     * {@code env} parameter is a map of provider specific properties to configure\n     * the file system.\n     *\n     * <p> This method throws {@link FileSystemAlreadyExistsException} if the\n     * file system already exists because it was previously created by an\n     * invocation of this method. Once a file system is {@link\n     * java.nio.file.FileSystem#close closed} it is provider-dependent if the\n     * provider allows a new file system to be created with the same URI as a\n     * file system it previously created.\n     *\n     * @param   uri\n     *          URI reference\n     * @param   env\n     *          A map of provider specific properties to configure the file system;\n     *          may be empty\n     *\n     * @return  A new file system\n     *\n     * @throws  IllegalArgumentException\n     *          If the pre-conditions for the {@code uri} parameter aren't met,\n     *          or the {@code env} parameter does not contain properties required\n     *          by the provider, or a property value is invalid\n     * @throws  IOException\n     *          An I/O error occurs creating the file system\n     * @throws  SecurityException\n     *          If a security manager is installed and it denies an unspecified\n     *          permission required by the file system provider implementation\n     * @throws  FileSystemAlreadyExistsException\n     *          If the file system has already been created\n     ",
    "links" : [ "#newFileSystem(URI", "java.nio.file.FileSystem#close", "FileSystemAlreadyExistsException" ]
  }, {
    "name" : "public abstract FileSystem getFileSystem(URI uri)",
    "returnType" : "FileSystem",
    "comment" : "\n     * Returns an existing {@code FileSystem} created by this provider.\n     *\n     * <p> This method returns a reference to a {@code FileSystem} that was\n     * created by invoking the {@link #newFileSystem(URI,Map) newFileSystem(URI,Map)}\n     * method. File systems created the {@link #newFileSystem(Path,Map)\n     * newFileSystem(Path,Map)} method are not returned by this method.\n     * The file system is identified by its {@code URI}. Its exact form\n     * is highly provider dependent. In the case of the default provider the URI's\n     * path component is {@code \"/\"} and the authority, query and fragment components\n     * are undefined (Undefined components are represented by {@code null}).\n     *\n     * <p> Once a file system created by this provider is {@link\n     * java.nio.file.FileSystem#close closed} it is provider-dependent if this\n     * method returns a reference to the closed file system or throws {@link\n     * FileSystemNotFoundException}. If the provider allows a new file system to\n     * be created with the same URI as a file system it previously created then\n     * this method throws the exception if invoked after the file system is\n     * closed (and before a new instance is created by the {@link #newFileSystem\n     * newFileSystem} method).\n     *\n     * <p> If a security manager is installed then a provider implementation\n     * may require to check a permission before returning a reference to an\n     * existing file system. In the case of the {@link FileSystems#getDefault\n     * default} file system, no permission check is required.\n     *\n     * @param   uri\n     *          URI reference\n     *\n     * @return  The file system\n     *\n     * @throws  IllegalArgumentException\n     *          If the pre-conditions for the {@code uri} parameter aren't met\n     * @throws  FileSystemNotFoundException\n     *          If the file system does not exist\n     * @throws  SecurityException\n     *          If a security manager is installed and it denies an unspecified\n     *          permission.\n     ",
    "links" : [ "#newFileSystemnewFileSystem", "#newFileSystem(URI", "FileSystemNotFoundException", "java.nio.file.FileSystem#close", "#newFileSystem(Path", "#getDefaultdefault" ]
  }, {
    "name" : "public abstract Path getPath(URI uri)",
    "returnType" : "Path",
    "comment" : "\n     * Return a {@code Path} object by converting the given {@link URI}. The\n     * resulting {@code Path} is associated with a {@link FileSystem} that\n     * already exists or is constructed automatically.\n     *\n     * <p> The exact form of the URI is file system provider dependent. In the\n     * case of the default provider, the URI scheme is {@code \"file\"} and the\n     * given URI has a non-empty path component, and undefined query, and\n     * fragment components. The resulting {@code Path} is associated with the\n     * default {@link FileSystems#getDefault default} {@code FileSystem}.\n     *\n     * <p> If a security manager is installed then a provider implementation\n     * may require to check a permission. In the case of the {@link\n     * FileSystems#getDefault default} file system, no permission check is\n     * required.\n     *\n     * @param   uri\n     *          The URI to convert\n     *\n     * @return  The resulting {@code Path}\n     *\n     * @throws  IllegalArgumentException\n     *          If the URI scheme does not identify this provider or other\n     *          preconditions on the uri parameter do not hold\n     * @throws  FileSystemNotFoundException\n     *          The file system, identified by the URI, does not exist and\n     *          cannot be created automatically\n     * @throws  SecurityException\n     *          If a security manager is installed and it denies an unspecified\n     *          permission.\n     ",
    "links" : [ "FileSystem", "java.net.URI", "#getDefault" ]
  }, {
    "name" : "public FileSystem newFileSystem(Path path, Map<String, ?> env) throws IOException",
    "returnType" : "FileSystem",
    "comment" : "\n     * Constructs a new {@code FileSystem} to access the contents of a file as a\n     * file system.\n     *\n     * <p> This method is intended for specialized providers of pseudo file\n     * systems where the contents of one or more files is treated as a file\n     * system. The {@code env} parameter is a map of provider specific properties\n     * to configure the file system.\n     *\n     * <p> If this provider does not support the creation of such file systems\n     * or if the provider does not recognize the file type of the given file then\n     * it throws {@code UnsupportedOperationException}. The default implementation\n     * of this method throws {@code UnsupportedOperationException}.\n     *\n     * @param   path\n     *          The path to the file\n     * @param   env\n     *          A map of provider specific properties to configure the file system;\n     *          may be empty\n     *\n     * @return  A new file system\n     *\n     * @throws  UnsupportedOperationException\n     *          If this provider does not support access to the contents as a\n     *          file system or it does not recognize the file type of the\n     *          given file\n     * @throws  IllegalArgumentException\n     *          If the {@code env} parameter does not contain properties required\n     *          by the provider, or a property value is invalid\n     * @throws  IOException\n     *          If an I/O error occurs\n     * @throws  SecurityException\n     *          If a security manager is installed and it denies an unspecified\n     *          permission.\n     ",
    "links" : [ ]
  }, {
    "name" : "public InputStream newInputStream(Path path, OpenOption... options) throws IOException",
    "returnType" : "InputStream",
    "comment" : "\n     * Opens a file, returning an input stream to read from the file. This\n     * method works in exactly the manner specified by the {@link\n     * Files#newInputStream} method.\n     *\n     * <p> The default implementation of this method opens a channel to the file\n     * as if by invoking the {@link #newByteChannel} method and constructs a\n     * stream that reads bytes from the channel. This method should be overridden\n     * where appropriate.\n     *\n     * @param   path\n     *          the path to the file to open\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new input stream\n     *\n     * @throws  IllegalArgumentException\n     *          if an invalid combination of options is specified\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     ",
    "links" : [ "#newInputStream", "#newByteChannel", "#checkRead(String)" ]
  }, {
    "name" : "public OutputStream newOutputStream(Path path, OpenOption... options) throws IOException",
    "returnType" : "OutputStream",
    "comment" : "\n     * Opens or creates a file, returning an output stream that may be used to\n     * write bytes to the file. This method works in exactly the manner\n     * specified by the {@link Files#newOutputStream} method.\n     *\n     * <p> The default implementation of this method opens a channel to the file\n     * as if by invoking the {@link #newByteChannel} method and constructs a\n     * stream that writes bytes to the channel. This method should be overridden\n     * where appropriate.\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new output stream\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     ",
    "links" : [ "#newByteChannel", "#checkDelete(String)", "#newOutputStream", "#checkWrite(String)" ]
  }, {
    "name" : "public FileChannel newFileChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException",
    "returnType" : "FileChannel",
    "comment" : "\n     * Opens or creates a file for reading and/or writing, returning a file\n     * channel to access the file. This method works in exactly the manner\n     * specified by the {@link FileChannel#open(Path,Set,FileAttribute[])\n     * FileChannel.open} method. A provider that does not support all the\n     * features required to construct a file channel throws {@code\n     * UnsupportedOperationException}. The default provider is required to\n     * support the creation of file channels. When not overridden, the default\n     * implementation throws {@code UnsupportedOperationException}.\n     *\n     * @param   path\n     *          the path of the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  a new file channel\n     *\n     * @throws  IllegalArgumentException\n     *          If the set contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          If this provider that does not support creating file channels,\n     *          or an unsupported open option or file attribute is specified\n     * @throws  IOException\n     *          If an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default file system, the {@link\n     *          SecurityManager#checkRead(String)} method is invoked to check\n     *          read access if the file is opened for reading. The {@link\n     *          SecurityManager#checkWrite(String)} method is invoked to check\n     *          write access if the file is opened for writing\n     ",
    "links" : [ "#checkRead(String)", "#checkWrite(String)", "#open(Path" ]
  }, {
    "name" : "public AsynchronousFileChannel newAsynchronousFileChannel(Path path, Set<? extends OpenOption> options, ExecutorService executor, FileAttribute<?>... attrs) throws IOException",
    "returnType" : "AsynchronousFileChannel",
    "comment" : "\n     * Opens or creates a file for reading and/or writing, returning an\n     * asynchronous file channel to access the file. This method works in\n     * exactly the manner specified by the {@link\n     * AsynchronousFileChannel#open(Path,Set,ExecutorService,FileAttribute[])\n     * AsynchronousFileChannel.open} method.\n     * A provider that does not support all the features required to construct\n     * an asynchronous file channel throws {@code UnsupportedOperationException}.\n     * The default provider is required to support the creation of asynchronous\n     * file channels. When not overridden, the default implementation of this\n     * method throws {@code UnsupportedOperationException}.\n     *\n     * @param   path\n     *          the path of the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     * @param   executor\n     *          the thread pool or {@code null} to associate the channel with\n     *          the default thread pool\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  a new asynchronous file channel\n     *\n     * @throws  IllegalArgumentException\n     *          If the set contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          If this provider that does not support creating asynchronous file\n     *          channels, or an unsupported open option or file attribute is\n     *          specified\n     * @throws  IOException\n     *          If an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default file system, the {@link\n     *          SecurityManager#checkRead(String)} method is invoked to check\n     *          read access if the file is opened for reading. The {@link\n     *          SecurityManager#checkWrite(String)} method is invoked to check\n     *          write access if the file is opened for writing\n     ",
    "links" : [ "#checkRead(String)", "#checkWrite(String)", "#open(Path" ]
  }, {
    "name" : "public abstract SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException",
    "returnType" : "SeekableByteChannel",
    "comment" : "\n     * Opens or creates a file, returning a seekable byte channel to access the\n     * file. This method works in exactly the manner specified by the {@link\n     * Files#newByteChannel(Path,Set,FileAttribute[])} method.\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  a new seekable byte channel\n     *\n     * @throws  IllegalArgumentException\n     *          if the set contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported open option is specified or the array contains\n     *          attributes that cannot be set atomically when creating the file\n     * @throws  FileAlreadyExistsException\n     *          if a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          <i>(optional specific exception)</i>\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the path if the file is\n     *          opened for reading. The {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method is invoked to check write access to the path\n     *          if the file is opened for writing. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     ",
    "links" : [ "#newByteChannel(Path", "#checkRead(String)", "#checkDelete(String)", "#checkWrite(String)", "#CREATE_NEW" ]
  }, {
    "name" : "public abstract DirectoryStream<Path> newDirectoryStream(Path dir, DirectoryStream.Filter<? super Path> filter) throws IOException",
    "returnType" : "DirectoryStream<Path>",
    "comment" : "\n     * Opens a directory, returning a {@code DirectoryStream} to iterate over\n     * the entries in the directory. This method works in exactly the manner\n     * specified by the {@link\n     * Files#newDirectoryStream(java.nio.file.Path, java.nio.file.DirectoryStream.Filter)}\n     * method.\n     *\n     * @param   dir\n     *          the path to the directory\n     * @param   filter\n     *          the directory stream filter\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory <i>(optional specific exception)</i>\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     ",
    "links" : [ "#checkRead(String)", "#newDirectoryStream(java.nio.file.Path" ]
  }, {
    "name" : "public abstract void createDirectory(Path dir, FileAttribute<?>... attrs) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Creates a new directory. This method works in exactly the manner\n     * specified by the {@link Files#createDirectory} method.\n     *\n     * @param   dir\n     *          the directory to create\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  FileAlreadyExistsException\n     *          if a directory could not otherwise be created because a file of\n     *          that name already exists <i>(optional specific exception)</i>\n     * @throws  IOException\n     *          if an I/O error occurs or the parent directory does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the new directory.\n     ",
    "links" : [ "#createDirectory", "#checkWrite(String)" ]
  }, {
    "name" : "public void createSymbolicLink(Path link, Path target, FileAttribute<?>... attrs) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Creates a symbolic link to a target. This method works in exactly the\n     * manner specified by the {@link Files#createSymbolicLink} method.\n     *\n     * <p> The default implementation of this method throws {@code\n     * UnsupportedOperationException}.\n     *\n     * @param   link\n     *          the path of the symbolic link to create\n     * @param   target\n     *          the target of the symbolic link\n     * @param   attrs\n     *          the array of attributes to set atomically when creating the\n     *          symbolic link\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support symbolic links or the\n     *          array contains an attribute that cannot be set atomically when\n     *          creating the symbolic link\n     * @throws  FileAlreadyExistsException\n     *          if a file with the name already exists <i>(optional specific\n     *          exception)</i>\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it denies {@link LinkPermission}<tt>(\"symbolic\")</tt>\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the path of the symbolic link.\n     ",
    "links" : [ "#createSymbolicLink", "LinkPermission", "#checkWrite(String)" ]
  }, {
    "name" : "public void createLink(Path link, Path existing) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Creates a new link (directory entry) for an existing file. This method\n     * works in exactly the manner specified by the {@link Files#createLink}\n     * method.\n     *\n     * <p> The default implementation of this method throws {@code\n     * UnsupportedOperationException}.\n     *\n     * @param   link\n     *          the link (directory entry) to create\n     * @param   existing\n     *          a path to an existing file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support adding an existing file\n     *          to a directory\n     * @throws  FileAlreadyExistsException\n     *          if the entry could not otherwise be created because a file of\n     *          that name already exists <i>(optional specific exception)</i>\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it denies {@link LinkPermission}<tt>(\"hard\")</tt>\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to either the  link or the\n     *          existing file.\n     ",
    "links" : [ "LinkPermission", "#createLink", "#checkWrite(String)" ]
  }, {
    "name" : "public abstract void delete(Path path) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Deletes a file. This method works in exactly the  manner specified by the\n     * {@link Files#delete} method.\n     *\n     * @param   path\n     *          the path to the file to delete\n     *\n     * @throws  NoSuchFileException\n     *          if the file does not exist <i>(optional specific exception)</i>\n     * @throws  DirectoryNotEmptyException\n     *          if the file is a directory and could not otherwise be deleted\n     *          because the directory is not empty <i>(optional specific\n     *          exception)</i>\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkDelete(String)} method\n     *          is invoked to check delete access to the file\n     ",
    "links" : [ "#checkDelete(String)", "#delete" ]
  }, {
    "name" : "public boolean deleteIfExists(Path path) throws IOException",
    "returnType" : "boolean",
    "comment" : "\n     * Deletes a file if it exists. This method works in exactly the manner\n     * specified by the {@link Files#deleteIfExists} method.\n     *\n     * <p> The default implementation of this method simply invokes {@link\n     * #delete} ignoring the {@code NoSuchFileException} when the file does not\n     * exist. It may be overridden where appropriate.\n     *\n     * @param   path\n     *          the path to the file to delete\n     *\n     * @return  {@code true} if the file was deleted by this method; {@code\n     *          false} if the file could not be deleted because it did not\n     *          exist\n     *\n     * @throws  DirectoryNotEmptyException\n     *          if the file is a directory and could not otherwise be deleted\n     *          because the directory is not empty <i>(optional specific\n     *          exception)</i>\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkDelete(String)} method\n     *          is invoked to check delete access to the file\n     ",
    "links" : [ "#deleteIfExists", "#checkDelete(String)", "#delete" ]
  }, {
    "name" : "public Path readSymbolicLink(Path link) throws IOException",
    "returnType" : "Path",
    "comment" : "\n     * Reads the target of a symbolic link. This method works in exactly the\n     * manner specified by the {@link Files#readSymbolicLink} method.\n     *\n     * <p> The default implementation of this method throws {@code\n     * UnsupportedOperationException}.\n     *\n     * @param   link\n     *          the path to the symbolic link\n     *\n     * @return  The target of the symbolic link\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support symbolic links\n     * @throws  NotLinkException\n     *          if the target could otherwise not be read because the file\n     *          is not a symbolic link <i>(optional specific exception)</i>\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it checks that {@code FilePermission} has been\n     *          granted with the \"{@code readlink}\" action to read the link.\n     ",
    "links" : [ "#readSymbolicLink" ]
  }, {
    "name" : "public abstract void copy(Path source, Path target, CopyOption... options) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Copy a file to a target file. This method works in exactly the manner\n     * specified by the {@link Files#copy(Path,Path,CopyOption[])} method\n     * except that both the source and target paths must be associated with\n     * this provider.\n     *\n     * @param   source\n     *          the path to the file to copy\n     * @param   target\n     *          the path to the target file\n     * @param   options\n     *          options specifying how the copy should be done\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains a copy option that is not supported\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified <i>(optional\n     *          specific exception)</i>\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory\n     *          <i>(optional specific exception)</i>\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the source file, the\n     *          {@link SecurityManager#checkWrite(String) checkWrite} is invoked\n     *          to check write access to the target file. If a symbolic link is\n     *          copied the security manager is invoked to check {@link\n     *          LinkPermission}{@code (\"symbolic\")}.\n     ",
    "links" : [ "LinkPermission", "#copy(Path", "#checkRead(String)", "#checkWrite(String)" ]
  }, {
    "name" : "public abstract void move(Path source, Path target, CopyOption... options) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Move or rename a file to a target file. This method works in exactly the\n     * manner specified by the {@link Files#move} method except that both the\n     * source and target paths must be associated with this provider.\n     *\n     * @param   source\n     *          the path to the file to move\n     * @param   target\n     *          the path to the target file\n     * @param   options\n     *          options specifying how the move should be done\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains a copy option that is not supported\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified <i>(optional\n     *          specific exception)</i>\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory\n     *          <i>(optional specific exception)</i>\n     * @throws  AtomicMoveNotSupportedException\n     *          if the options array contains the {@code ATOMIC_MOVE} option but\n     *          the file cannot be moved as an atomic file system operation.\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to both the source and\n     *          target file.\n     ",
    "links" : [ "#move", "#checkWrite(String)" ]
  }, {
    "name" : "public abstract boolean isSameFile(Path path, Path path2) throws IOException",
    "returnType" : "boolean",
    "comment" : "\n     * Tests if two paths locate the same file. This method works in exactly the\n     * manner specified by the {@link Files#isSameFile} method.\n     *\n     * @param   path\n     *          one path to the file\n     * @param   path2\n     *          the other path\n     *\n     * @return  {@code true} if, and only if, the two paths locate the same file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to both files.\n     ",
    "links" : [ "#checkRead(String)", "#isSameFile" ]
  }, {
    "name" : "public abstract boolean isHidden(Path path) throws IOException",
    "returnType" : "boolean",
    "comment" : "\n     * Tells whether or not a file is considered <em>hidden</em>. This method\n     * works in exactly the manner specified by the {@link Files#isHidden}\n     * method.\n     *\n     * <p> This method is invoked by the {@link Files#isHidden isHidden} method.\n     *\n     * @param   path\n     *          the path to the file to test\n     *\n     * @return  {@code true} if the file is considered hidden\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     ",
    "links" : [ "#isHidden", "#checkRead(String)" ]
  }, {
    "name" : "public abstract FileStore getFileStore(Path path) throws IOException",
    "returnType" : "FileStore",
    "comment" : "\n     * Returns the {@link FileStore} representing the file store where a file\n     * is located. This method works in exactly the manner specified by the\n     * {@link Files#getFileStore} method.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the file store where the file is stored\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file, and in\n     *          addition it checks {@link RuntimePermission}<tt>\n     *          (\"getFileStoreAttributes\")</tt>\n     ",
    "links" : [ "FileStore", "#checkRead(String)", "RuntimePermission", "#getFileStore" ]
  }, {
    "name" : "public abstract void checkAccess(Path path, AccessMode... modes) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Checks the existence, and optionally the accessibility, of a file.\n     *\n     * <p> This method may be used by the {@link Files#isReadable isReadable},\n     * {@link Files#isWritable isWritable} and {@link Files#isExecutable\n     * isExecutable} methods to check the accessibility of a file.\n     *\n     * <p> This method checks the existence of a file and that this Java virtual\n     * machine has appropriate privileges that would allow it access the file\n     * according to all of access modes specified in the {@code modes} parameter\n     * as follows:\n     *\n     * <table border=1 cellpadding=5 summary=\"\">\n     * <tr> <th>Value</th> <th>Description</th> </tr>\n     * <tr>\n     *   <td> {@link AccessMode#READ READ} </td>\n     *   <td> Checks that the file exists and that the Java virtual machine has\n     *     permission to read the file. </td>\n     * </tr>\n     * <tr>\n     *   <td> {@link AccessMode#WRITE WRITE} </td>\n     *   <td> Checks that the file exists and that the Java virtual machine has\n     *     permission to write to the file, </td>\n     * </tr>\n     * <tr>\n     *   <td> {@link AccessMode#EXECUTE EXECUTE} </td>\n     *   <td> Checks that the file exists and that the Java virtual machine has\n     *     permission to {@link Runtime#exec execute} the file. The semantics\n     *     may differ when checking access to a directory. For example, on UNIX\n     *     systems, checking for {@code EXECUTE} access checks that the Java\n     *     virtual machine has permission to search the directory in order to\n     *     access file or subdirectories. </td>\n     * </tr>\n     * </table>\n     *\n     * <p> If the {@code modes} parameter is of length zero, then the existence\n     * of the file is checked.\n     *\n     * <p> This method follows symbolic links if the file referenced by this\n     * object is a symbolic link. Depending on the implementation, this method\n     * may require to read file permissions, access control lists, or other\n     * file attributes in order to check the effective access to the file. To\n     * determine the effective access to a file may require access to several\n     * attributes and so in some implementations this method may not be atomic\n     * with respect to other file system operations.\n     *\n     * @param   path\n     *          the path to the file to check\n     * @param   modes\n     *          The access modes to check; may have zero elements\n     *\n     * @throws  UnsupportedOperationException\n     *          an implementation is required to support checking for\n     *          {@code READ}, {@code WRITE}, and {@code EXECUTE} access. This\n     *          exception is specified to allow for the {@code Access} enum to\n     *          be extended in future releases.\n     * @throws  NoSuchFileException\n     *          if a file does not exist <i>(optional specific exception)</i>\n     * @throws  AccessDeniedException\n     *          the requested access would be denied or the access cannot be\n     *          determined because the Java virtual machine has insufficient\n     *          privileges or other reasons. <i>(optional specific exception)</i>\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          is invoked when checking read access to the file or only the\n     *          existence of the file, the {@link SecurityManager#checkWrite(String)\n     *          checkWrite} is invoked when checking write access to the file,\n     *          and {@link SecurityManager#checkExec(String) checkExec} is invoked\n     *          when checking execute access.\n     ",
    "links" : [ "#isReadable", "#checkExec(String)", "#WRITE", "#isWritable", "#checkRead(String)", "#isExecutableisExecutable", "#exec", "#READ", "#checkWrite(String)", "#EXECUTE" ]
  }, {
    "name" : "public abstract V getFileAttributeView(Path path, Class<V> type, LinkOption... options)",
    "returnType" : "V",
    "comment" : "\n     * Returns a file attribute view of a given type. This method works in\n     * exactly the manner specified by the {@link Files#getFileAttributeView}\n     * method.\n     *\n     * @param   <V>\n     *          The {@code FileAttributeView} type\n     * @param   path\n     *          the path to the file\n     * @param   type\n     *          the {@code Class} object corresponding to the file attribute view\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a file attribute view of the specified type, or {@code null} if\n     *          the attribute view type is not available\n     ",
    "links" : [ "#getFileAttributeView" ]
  }, {
    "name" : "public abstract A readAttributes(Path path, Class<A> type, LinkOption... options) throws IOException",
    "returnType" : "A",
    "comment" : "\n     * Reads a file's attributes as a bulk operation. This method works in\n     * exactly the manner specified by the {@link\n     * Files#readAttributes(Path,Class,LinkOption[])} method.\n     *\n     * @param   <A>\n     *          The {@code BasicFileAttributes} type\n     * @param   path\n     *          the path to the file\n     * @param   type\n     *          the {@code Class} of the file attributes required\n     *          to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the file attributes\n     *\n     * @throws  UnsupportedOperationException\n     *          if an attributes of the given type are not supported\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file\n     ",
    "links" : [ "#readAttributes(Path", "#checkRead(String)" ]
  }, {
    "name" : "public abstract Map<String, Object> readAttributes(Path path, String attributes, LinkOption... options) throws IOException",
    "returnType" : "Map<String, Object>",
    "comment" : "\n     * Reads a set of file attributes as a bulk operation. This method works in\n     * exactly the manner specified by the {@link\n     * Files#readAttributes(Path,String,LinkOption[])} method.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attributes\n     *          the attributes to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a map of the attributes returned; may be empty. The map's keys\n     *          are the attribute names, its values are the attribute values\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if no attributes are specified or an unrecognized attributes is\n     *          specified\n     * @throws  IOException\n     *          If an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file. If this method is invoked\n     *          to read security sensitive attributes then the security manager\n     *          may be invoke to check for additional permissions.\n     ",
    "links" : [ "#readAttributes(Path", "#checkRead(String)" ]
  }, {
    "name" : "public abstract void setAttribute(Path path, String attribute, Object value, LinkOption... options) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Sets the value of a file attribute. This method works in exactly the\n     * manner specified by the {@link Files#setAttribute} method.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attribute\n     *          the attribute to set\n     * @param   value\n     *          the attribute value\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if the attribute name is not specified, or is not recognized, or\n     *          the attribute value is of the correct type but has an\n     *          inappropriate value\n     * @throws  ClassCastException\n     *          If the attribute value is not of the expected type or is a\n     *          collection containing elements that are not of the expected\n     *          type\n     * @throws  IOException\n     *          If an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file. If this method is invoked\n     *          to set security sensitive attributes then the security manager\n     *          may be invoked to check for additional permissions.\n     ",
    "links" : [ "#checkWrite(String)", "#setAttribute" ]
  } ],
  "methodNames" : [ "private static Void checkPermission()", "private static List<FileSystemProvider> loadInstalledProviders()", "public static List<FileSystemProvider> installedProviders()", "public abstract String getScheme()", "public abstract FileSystem newFileSystem(URI uri, Map<String, ?> env) throws IOException", "public abstract FileSystem getFileSystem(URI uri)", "public abstract Path getPath(URI uri)", "public FileSystem newFileSystem(Path path, Map<String, ?> env) throws IOException", "public InputStream newInputStream(Path path, OpenOption... options) throws IOException", "public OutputStream newOutputStream(Path path, OpenOption... options) throws IOException", "public FileChannel newFileChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException", "public AsynchronousFileChannel newAsynchronousFileChannel(Path path, Set<? extends OpenOption> options, ExecutorService executor, FileAttribute<?>... attrs) throws IOException", "public abstract SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException", "public abstract DirectoryStream<Path> newDirectoryStream(Path dir, DirectoryStream.Filter<? super Path> filter) throws IOException", "public abstract void createDirectory(Path dir, FileAttribute<?>... attrs) throws IOException", "public void createSymbolicLink(Path link, Path target, FileAttribute<?>... attrs) throws IOException", "public void createLink(Path link, Path existing) throws IOException", "public abstract void delete(Path path) throws IOException", "public boolean deleteIfExists(Path path) throws IOException", "public Path readSymbolicLink(Path link) throws IOException", "public abstract void copy(Path source, Path target, CopyOption... options) throws IOException", "public abstract void move(Path source, Path target, CopyOption... options) throws IOException", "public abstract boolean isSameFile(Path path, Path path2) throws IOException", "public abstract boolean isHidden(Path path) throws IOException", "public abstract FileStore getFileStore(Path path) throws IOException", "public abstract void checkAccess(Path path, AccessMode... modes) throws IOException", "public abstract V getFileAttributeView(Path path, Class<V> type, LinkOption... options)", "public abstract A readAttributes(Path path, Class<A> type, LinkOption... options) throws IOException", "public abstract Map<String, Object> readAttributes(Path path, String attributes, LinkOption... options) throws IOException", "public abstract void setAttribute(Path path, String attribute, Object value, LinkOption... options) throws IOException" ],
  "variableNames" : [ "lock", "installedProviders", "loadingProviders" ]
}