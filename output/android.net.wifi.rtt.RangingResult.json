{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/net/wifi/rtt/RangingResult.java",
  "packageName" : "android.net.wifi.rtt",
  "className" : "RangingResult",
  "comment" : "\n * Ranging result for a request started by\n * {@link WifiRttManager#startRanging(RangingRequest, java.util.concurrent.Executor, RangingResultCallback)}.\n * Results are returned in {@link RangingResultCallback#onRangingResults(List)}.\n * <p>\n * A ranging result is the distance measurement result for a single device specified in the\n * {@link RangingRequest}.\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EMPTY_BYTE_ARRAY",
    "type" : "byte[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "STATUS_SUCCESS",
    "type" : "int",
    "comment" : "\n     * Individual range request status, {@link #getStatus()}. Indicates ranging operation was\n     * successful and distance value is valid.\n     ",
    "links" : [ "#getStatus()" ]
  }, {
    "name" : "STATUS_FAIL",
    "type" : "int",
    "comment" : "\n     * Individual range request status, {@link #getStatus()}. Indicates ranging operation failed\n     * and the distance value is invalid.\n     ",
    "links" : [ "#getStatus()" ]
  }, {
    "name" : "STATUS_RESPONDER_DOES_NOT_SUPPORT_IEEE80211MC",
    "type" : "int",
    "comment" : "\n     * Individual range request status, {@link #getStatus()}. Indicates that the ranging operation\n     * failed because the specified peer does not support IEEE 802.11mc RTT operations. Support by\n     * an Access Point can be confirmed using\n     * {@link android.net.wifi.ScanResult#is80211mcResponder()}.\n     * <p>\n     * On such a failure, the individual result fields of {@link RangingResult} such as\n     * {@link RangingResult#getDistanceMm()} are invalid.\n     ",
    "links" : [ "android.net.wifi.rtt.RangingResult#getDistanceMm()", "android.net.wifi.ScanResult#is80211mcResponder()", "android.net.wifi.rtt.RangingResult", "#getStatus()" ]
  }, {
    "name" : "mStatus",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMac",
    "type" : "MacAddress",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPeerHandle",
    "type" : "PeerHandle",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDistanceMm",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDistanceStdDevMm",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRssi",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mNumAttemptedMeasurements",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mNumSuccessfulMeasurements",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLci",
    "type" : "byte[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLcr",
    "type" : "byte[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mResponderLocation",
    "type" : "ResponderLocation",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTimestamp",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CREATOR",
    "type" : "Creator<RangingResult>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public int getStatus()",
    "returnType" : "int",
    "comment" : "\n     * @return The status of ranging measurement: {@link #STATUS_SUCCESS} in case of success, and\n     * {@link #STATUS_FAIL} in case of failure.\n     ",
    "links" : [ "#STATUS_FAIL", "#STATUS_SUCCESS" ]
  }, {
    "name" : "public MacAddress getMacAddress()",
    "returnType" : "MacAddress",
    "comment" : "\n     * @return The MAC address of the device whose range measurement was requested. Will correspond\n     * to the MAC address of the device in the {@link RangingRequest}.\n     * <p>\n     * Will return a {@code null} for results corresponding to requests issued using a {@code\n     * PeerHandle}, i.e. using the {@link RangingRequest.Builder#addWifiAwarePeer(PeerHandle)} API.\n     ",
    "links" : [ "RangingRequest.Builder#addWifiAwarePeer(PeerHandle)", "android.net.wifi.rtt.RangingRequest" ]
  }, {
    "name" : "public PeerHandle getPeerHandle()",
    "returnType" : "PeerHandle",
    "comment" : "\n     * @return The PeerHandle of the device whose reange measurement was requested. Will correspond\n     * to the PeerHandle of the devices requested using\n     * {@link RangingRequest.Builder#addWifiAwarePeer(PeerHandle)}.\n     * <p>\n     * Will return a {@code null} for results corresponding to requests issued using a MAC address.\n     ",
    "links" : [ "RangingRequest.Builder#addWifiAwarePeer(PeerHandle)" ]
  }, {
    "name" : "public int getDistanceMm()",
    "returnType" : "int",
    "comment" : "\n     * @return The distance (in mm) to the device specified by {@link #getMacAddress()} or\n     * {@link #getPeerHandle()}.\n     * <p>\n     * Note: the measured distance may be negative for very close devices.\n     * <p>\n     * Only valid if {@link #getStatus()} returns {@link #STATUS_SUCCESS}, otherwise will throw an\n     * exception.\n     ",
    "links" : [ "#getMacAddress()", "#STATUS_SUCCESS", "#getStatus()", "#getPeerHandle()" ]
  }, {
    "name" : "public int getDistanceStdDevMm()",
    "returnType" : "int",
    "comment" : "\n     * @return The standard deviation of the measured distance (in mm) to the device specified by\n     * {@link #getMacAddress()} or {@link #getPeerHandle()}. The standard deviation is calculated\n     * over the measurements executed in a single RTT burst. The number of measurements is returned\n     * by {@link #getNumSuccessfulMeasurements()} - 0 successful measurements indicate that the\n     * standard deviation is not valid (a valid standard deviation requires at least 2 data points).\n     * <p>\n     * Only valid if {@link #getStatus()} returns {@link #STATUS_SUCCESS}, otherwise will throw an\n     * exception.\n     ",
    "links" : [ "#getMacAddress()", "#STATUS_SUCCESS", "#getStatus()", "#getNumSuccessfulMeasurements()", "#getPeerHandle()" ]
  }, {
    "name" : "public int getRssi()",
    "returnType" : "int",
    "comment" : "\n     * @return The average RSSI, in units of dBm, observed during the RTT measurement.\n     * <p>\n     * Only valid if {@link #getStatus()} returns {@link #STATUS_SUCCESS}, otherwise will throw an\n     * exception.\n     ",
    "links" : [ "#STATUS_SUCCESS", "#getStatus()" ]
  }, {
    "name" : "public int getNumAttemptedMeasurements()",
    "returnType" : "int",
    "comment" : "\n     * @return The number of attempted measurements used in the RTT exchange resulting in this set\n     * of results. The number of successful measurements is returned by\n     * {@link #getNumSuccessfulMeasurements()} which at most, if there are no errors, will be 1 less\n     * that the number of attempted measurements.\n     * <p>\n     * Only valid if {@link #getStatus()} returns {@link #STATUS_SUCCESS}, otherwise will throw an\n     * exception.\n     ",
    "links" : [ "#STATUS_SUCCESS", "#getStatus()", "#getNumSuccessfulMeasurements()" ]
  }, {
    "name" : "public int getNumSuccessfulMeasurements()",
    "returnType" : "int",
    "comment" : "\n     * @return The number of successful measurements used to calculate the distance and standard\n     * deviation. If the number of successful measurements if 1 then then standard deviation,\n     * returned by {@link #getDistanceStdDevMm()}, is not valid (a 0 is returned for the standard\n     * deviation).\n     * <p>\n     * The total number of measurement attempts is returned by\n     * {@link #getNumAttemptedMeasurements()}. The number of successful measurements will be at\n     * most 1 less then the number of attempted measurements.\n     * <p>\n     * Only valid if {@link #getStatus()} returns {@link #STATUS_SUCCESS}, otherwise will throw an\n     * exception.\n     ",
    "links" : [ "#getNumAttemptedMeasurements()", "#getDistanceStdDevMm()", "#STATUS_SUCCESS", "#getStatus()" ]
  }, {
    "name" : "public ResponderLocation getUnverifiedResponderLocation()",
    "returnType" : "ResponderLocation",
    "comment" : "\n     * @return The unverified responder location represented as {@link ResponderLocation} which\n     * captures location information the responder is programmed to broadcast. The responder\n     * location is referred to as unverified, because we are relying on the device/site\n     * administrator to correctly configure its location data.\n     * <p>\n     * Will return a {@code null} when the location information cannot be parsed.\n     * <p>\n     * Only valid if {@link #getStatus()} returns {@link #STATUS_SUCCESS}, otherwise will throw an\n     * exception.\n     ",
    "links" : [ "android.net.wifi.rtt.ResponderLocation", "#STATUS_SUCCESS", "#getStatus()" ]
  }, {
    "name" : "public byte[] getLci()",
    "returnType" : "byte[]",
    "comment" : "\n     * @return The Location Configuration Information (LCI) as self-reported by the peer. The format\n     * is specified in the IEEE 802.11-2016 specifications, section 9.4.2.22.10.\n     * <p>\n     * Note: the information is NOT validated - use with caution. Consider validating it with\n     * other sources of information before using it.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public byte[] getLcr()",
    "returnType" : "byte[]",
    "comment" : "\n     * @return The Location Civic report (LCR) as self-reported by the peer. The format\n     * is specified in the IEEE 802.11-2016 specifications, section 9.4.2.22.13.\n     * <p>\n     * Note: the information is NOT validated - use with caution. Consider validating it with\n     * other sources of information before using it.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getRangingTimestampMillis()",
    "returnType" : "long",
    "comment" : "\n     * @return The timestamp at which the ranging operation was performed. The timestamp is in\n     * milliseconds since boot, including time spent in sleep, corresponding to values provided by\n     * {@link android.os.SystemClock#elapsedRealtime()}.\n     * <p>\n     * Only valid if {@link #getStatus()} returns {@link #STATUS_SUCCESS}, otherwise will throw an\n     * exception.\n     ",
    "links" : [ "#STATUS_SUCCESS", "android.os.SystemClock#elapsedRealtime()", "#getStatus()" ]
  }, {
    "name" : "public int describeContents()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void writeToParcel(Parcel dest, int flags)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean equals(Object o)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int hashCode()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "EMPTY_BYTE_ARRAY", "STATUS_SUCCESS", "STATUS_FAIL", "STATUS_RESPONDER_DOES_NOT_SUPPORT_IEEE80211MC", "mStatus", "mMac", "mPeerHandle", "mDistanceMm", "mDistanceStdDevMm", "mRssi", "mNumAttemptedMeasurements", "mNumSuccessfulMeasurements", "mLci", "mLcr", "mResponderLocation", "mTimestamp", "CREATOR" ],
  "methodNames" : [ "public int getStatus()", "public MacAddress getMacAddress()", "public PeerHandle getPeerHandle()", "public int getDistanceMm()", "public int getDistanceStdDevMm()", "public int getRssi()", "public int getNumAttemptedMeasurements()", "public int getNumSuccessfulMeasurements()", "public ResponderLocation getUnverifiedResponderLocation()", "public byte[] getLci()", "public byte[] getLcr()", "public long getRangingTimestampMillis()", "public int describeContents()", "public void writeToParcel(Parcel dest, int flags)", "public String toString()", "public boolean equals(Object o)", "public int hashCode()" ]
}