{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/companion/CompanionDeviceManager.java",
  "packageName" : "android.companion",
  "className" : "CompanionDeviceManager",
  "comment" : "\n * Public interfaces for managing companion devices.\n *\n * <p>The interfaces in this class allow companion apps to\n * {@link #associate(AssociationRequest, Executor, Callback)} discover and request device profiles}\n * for companion devices, {@link #startObservingDevicePresence(String) listen to device presence\n * events}, {@link #startSystemDataTransfer(int, Executor, OutcomeReceiver) transfer system level\n * data} via {@link #attachSystemDataTransport(int, InputStream, OutputStream) the reported\n * channel} and more.</p>\n *\n * <div class=\"special reference\">\n * <h3>Developer Guides</h3>\n * <p>For more information about managing companion devices, read the <a href=\n * \"{@docRoot}guide/topics/connectivity/companion-device-pairing\">Companion Device Pairing</a>\n * developer guide.\n * </div>\n ",
  "links" : [ "#startSystemDataTransfer(int", "#associate(AssociationRequest", "#attachSystemDataTransport(int", "#startObservingDevicePresence(String)" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RESULT_OK",
    "type" : "int",
    "comment" : "\n     * The result code to propagate back to the user activity, indicates the association\n     * is created successfully.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_CANCELED",
    "type" : "int",
    "comment" : "\n     * The result code to propagate back to the user activity, indicates if the association dialog\n     * is implicitly cancelled.\n     * E.g. phone is locked, switch to another app or press outside the dialog.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_USER_REJECTED",
    "type" : "int",
    "comment" : "\n     * The result code to propagate back to the user activity, indicates the association dialog\n     * is explicitly declined by the users.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_DISCOVERY_TIMEOUT",
    "type" : "int",
    "comment" : "\n     * The result code to propagate back to the user activity, indicates the association\n     * dialog is dismissed if there's no device found after 20 seconds.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_INTERNAL_ERROR",
    "type" : "int",
    "comment" : "\n     * The result code to propagate back to the user activity, indicates the internal error\n     * in CompanionDeviceManager.\n     ",
    "links" : [ ]
  }, {
    "name" : "REASON_USER_REJECTED",
    "type" : "String",
    "comment" : "\n     * Requesting applications will receive the String in {@link Callback#onFailure} if the\n     * association dialog is explicitly declined by the users. E.g. press the Don't allow\n     * button.\n     *\n     * @hide\n     ",
    "links" : [ "#onFailure" ]
  }, {
    "name" : "REASON_DISCOVERY_TIMEOUT",
    "type" : "String",
    "comment" : "\n     * Requesting applications will receive the String in {@link Callback#onFailure} if there's\n     * no devices found after 20 seconds.\n     *\n     * @hide\n     ",
    "links" : [ "#onFailure" ]
  }, {
    "name" : "REASON_INTERNAL_ERROR",
    "type" : "String",
    "comment" : "\n     * Requesting applications will receive the String in {@link Callback#onFailure} if there's\n     * an internal error.\n     *\n     * @hide\n     ",
    "links" : [ "#onFailure" ]
  }, {
    "name" : "REASON_CANCELED",
    "type" : "String",
    "comment" : "\n     * Requesting applications will receive the String in {@link Callback#onFailure} if the\n     * association dialog is implicitly cancelled. E.g. phone is locked, switch to\n     * another app or press outside the dialog.\n     *\n     * @hide\n     ",
    "links" : [ "#onFailure" ]
  }, {
    "name" : "FLAG_CALL_METADATA",
    "type" : "int",
    "comment" : "\n     * Used by {@link #enableSystemDataSyncForTypes(int, int)}}.\n     * Sync call metadata like muting, ending and silencing a call.\n     *\n     ",
    "links" : [ "#enableSystemDataSyncForTypes(int" ]
  }, {
    "name" : "EXTRA_DEVICE",
    "type" : "String",
    "comment" : "\n     * A device, returned in the activity result of the {@link IntentSender} received in\n     * {@link Callback#onDeviceFound}\n     *\n     * Type is:\n     * <ul>\n     *     <li>for classic Bluetooth - {@link android.bluetooth.BluetoothDevice}</li>\n     *     <li>for Bluetooth LE - {@link android.bluetooth.le.ScanResult}</li>\n     *     <li>for WiFi - {@link android.net.wifi.ScanResult}</li>\n     * </ul>\n     *\n     * @deprecated use {@link AssociationInfo#getAssociatedDevice()} instead.\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice", "android.net.wifi.ScanResult", "android.content.IntentSender", "#onDeviceFound", "android.companion.AssociationInfo#getAssociatedDevice()", "android.bluetooth.le.ScanResult" ]
  }, {
    "name" : "EXTRA_ASSOCIATION",
    "type" : "String",
    "comment" : "\n     * Extra field name for the {@link AssociationInfo} object, included into\n     * {@link android.content.Intent} which application receive in\n     * {@link Activity#onActivityResult(int, int, Intent)} after the application's\n     * {@link AssociationRequest} was successfully processed and an association was created.\n     ",
    "links" : [ "android.companion.AssociationInfo", "android.app.Activity#onActivityResult(int", "android.content.Intent", "android.companion.AssociationRequest" ]
  }, {
    "name" : "MESSAGE_REQUEST_PING",
    "type" : "int",
    "comment" : " ?PIN",
    "links" : [ ]
  }, {
    "name" : "MESSAGE_ONEWAY_PING",
    "type" : "int",
    "comment" : " +PIN",
    "links" : [ ]
  }, {
    "name" : "MESSAGE_REQUEST_REMOTE_AUTHENTICATION",
    "type" : "int",
    "comment" : " ?RMA",
    "links" : [ ]
  }, {
    "name" : "MESSAGE_REQUEST_CONTEXT_SYNC",
    "type" : "int",
    "comment" : " ?CXS",
    "links" : [ ]
  }, {
    "name" : "MESSAGE_REQUEST_PERMISSION_RESTORE",
    "type" : "int",
    "comment" : " ?RES",
    "links" : [ ]
  }, {
    "name" : "MESSAGE_ONEWAY_FROM_WEARABLE",
    "type" : "int",
    "comment" : " +FRW",
    "links" : [ ]
  }, {
    "name" : "MESSAGE_ONEWAY_TO_WEARABLE",
    "type" : "int",
    "comment" : " +TOW",
    "links" : [ ]
  }, {
    "name" : "ASSOCIATION_TAG_LENGTH_LIMIT",
    "type" : "int",
    "comment" : "\n     * The length limit of Association tag.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "mService",
    "type" : "ICompanionDeviceManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mListeners",
    "type" : "ArrayList<OnAssociationsChangedListenerProxy>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTransportsChangedListeners",
    "type" : "ArrayList<OnTransportsChangedListenerProxy>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTransports",
    "type" : "SparseArray<Transport>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public void associate(@NonNull AssociationRequest request, @NonNull Callback callback, @Nullable Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Request to associate this app with a companion device.\n     *\n     * <p>Note that before creating establishing association the system may need to show UI to\n     * collect user confirmation.</p>\n     *\n     * <p>If the app needs to be excluded from battery optimizations (run in the background)\n     * or to have unrestricted data access (use data in the background) it should declare use of\n     * {@link android.Manifest.permission#REQUEST_COMPANION_RUN_IN_BACKGROUND} and\n     * {@link android.Manifest.permission#REQUEST_COMPANION_USE_DATA_IN_BACKGROUND} in its\n     * AndroidManifest.xml respectively.\n     * Note that these special capabilities have a negative effect on the device's battery and\n     * user's data usage, therefore you should request them when absolutely necessary.</p>\n     *\n     * <p>Application can use {@link #getMyAssociations()} for retrieving the list of currently\n     * {@link AssociationInfo} objects, that represent their existing associations.\n     * Applications can also use {@link #disassociate(int)} to remove an association, and are\n     * recommended to do when an association is no longer relevant to avoid unnecessary battery\n     * and/or data drain resulting from special privileges that the association provides</p>\n     *\n     * <p>Calling this API requires a uses-feature\n     * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>\n     **\n     * @param request A request object that describes details of the request.\n     * @param callback The callback used to notify application when the association is created.\n     * @param handler The handler which will be used to invoke the callback.\n     *\n     * @see AssociationRequest.Builder\n     * @see #getMyAssociations()\n     * @see #disassociate(int)\n     * @see #associate(AssociationRequest, Executor, Callback)\n     ",
    "links" : [ "android.Manifest.permission#REQUEST_COMPANION_RUN_IN_BACKGROUND", "android.companion.AssociationInfo", "android.Manifest.permission#REQUEST_COMPANION_USE_DATA_IN_BACKGROUND", "#getMyAssociations()", "#disassociate(int)", "android.content.pm.PackageManager#FEATURE_COMPANION_DEVICE_SETUP" ]
  }, {
    "name" : "public void associate(@NonNull AssociationRequest request, @NonNull Executor executor, @NonNull Callback callback)",
    "returnType" : "void",
    "comment" : "\n     * Request to associate this app with a companion device.\n     *\n     * <p>Note that before creating establishing association the system may need to show UI to\n     * collect user confirmation.</p>\n     *\n     * <p>If the app needs to be excluded from battery optimizations (run in the background)\n     * or to have unrestricted data access (use data in the background) it should declare use of\n     * {@link android.Manifest.permission#REQUEST_COMPANION_RUN_IN_BACKGROUND} and\n     * {@link android.Manifest.permission#REQUEST_COMPANION_USE_DATA_IN_BACKGROUND} in its\n     * AndroidManifest.xml respectively.\n     * Note that these special capabilities have a negative effect on the device's battery and\n     * user's data usage, therefore you should request them when absolutely necessary.</p>\n     *\n     * <p>Application can use {@link #getMyAssociations()} for retrieving the list of currently\n     * {@link AssociationInfo} objects, that represent their existing associations.\n     * Applications can also use {@link #disassociate(int)} to remove an association, and are\n     * recommended to do when an association is no longer relevant to avoid unnecessary battery\n     * and/or data drain resulting from special privileges that the association provides</p>\n     *\n     * <p>Note that if you use this api to associate with a Bluetooth device, please make sure\n     * to cancel your own Bluetooth discovery before calling this api, otherwise the callback\n     * may fail to return the desired device.</p>\n     *\n     * <p>Calling this API requires a uses-feature\n     * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>\n     **\n     * @param request A request object that describes details of the request.\n     * @param executor The executor which will be used to invoke the callback.\n     * @param callback The callback used to notify application when the association is created.\n     *\n     * @see AssociationRequest.Builder\n     * @see #getMyAssociations()\n     * @see #disassociate(int)\n     * @see BluetoothAdapter#cancelDiscovery()\n     ",
    "links" : [ "android.Manifest.permission#REQUEST_COMPANION_RUN_IN_BACKGROUND", "android.companion.AssociationInfo", "android.Manifest.permission#REQUEST_COMPANION_USE_DATA_IN_BACKGROUND", "#getMyAssociations()", "#disassociate(int)", "android.content.pm.PackageManager#FEATURE_COMPANION_DEVICE_SETUP" ]
  }, {
    "name" : "public IntentSender buildAssociationCancellationIntent()",
    "returnType" : "IntentSender",
    "comment" : "\n     * Cancel the current association activity.\n     *\n     * <p>The app should launch the returned {@code intentSender} by calling\n     * {@link Activity#startIntentSenderForResult(IntentSender, int, Intent, int, int, int)} to\n     * cancel the current association activity</p>\n     *\n     * <p>Calling this API requires a uses-feature\n     * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>\n     *\n     * @return An {@link IntentSender} that the app should use to launch in order to cancel the\n     * current association activity\n     ",
    "links" : [ "android.content.IntentSender", "android.content.pm.PackageManager#FEATURE_COMPANION_DEVICE_SETUP", "android.app.Activity#startIntentSenderForResult(IntentSender" ]
  }, {
    "name" : "public void enableSystemDataSyncForTypes(int associationId, @DataSyncTypes int flags)",
    "returnType" : "void",
    "comment" : "\n     * <p>Enable system data sync (it only supports call metadata sync for now).\n     * By default all supported system data types are enabled.</p>\n     *\n     * <p>Calling this API requires a uses-feature\n     * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>\n     *\n     * @param associationId id of the device association.\n     * @param flags system data types to be enabled.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_COMPANION_DEVICE_SETUP" ]
  }, {
    "name" : "public void disableSystemDataSyncForTypes(int associationId, @DataSyncTypes int flags)",
    "returnType" : "void",
    "comment" : "\n     * <p>Disable system data sync (it only supports call metadata sync for now).\n     * By default all supported system data types are enabled.</p>\n     *\n     * <p>Calling this API requires a uses-feature\n     * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>\n     *\n     * @param associationId id of the device association.\n     * @param flags system data types to be disabled.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_COMPANION_DEVICE_SETUP" ]
  }, {
    "name" : "public void enablePermissionsSync(int associationId)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void disablePermissionsSync(int associationId)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public PermissionSyncRequest getPermissionSyncRequest(int associationId)",
    "returnType" : "PermissionSyncRequest",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<String> getAssociations()",
    "returnType" : "List<String>",
    "comment" : "\n     * <p>Calling this API requires a uses-feature\n     * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>\n     *\n     * @return a list of MAC addresses of devices that have been previously associated with the\n     * current app are managed by CompanionDeviceManager (ie. does not include devices managed by\n     * application itself even if they have a MAC address).\n     *\n     * @deprecated use {@link #getMyAssociations()}\n     ",
    "links" : [ "#getMyAssociations()", "android.content.pm.PackageManager#FEATURE_COMPANION_DEVICE_SETUP" ]
  }, {
    "name" : "public List<AssociationInfo> getMyAssociations()",
    "returnType" : "List<AssociationInfo>",
    "comment" : "\n     * <p>Calling this API requires a uses-feature\n     * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>\n     *\n     * @return a list of associations that have been previously associated with the current app.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_COMPANION_DEVICE_SETUP" ]
  }, {
    "name" : "public void disassociate(@NonNull String deviceMacAddress)",
    "returnType" : "void",
    "comment" : "\n     * Remove the association between this app and the device with the given mac address.\n     *\n     * <p>Any privileges provided via being associated with a given device will be revoked</p>\n     *\n     * <p>Consider doing so when the\n     * association is no longer relevant to avoid unnecessary battery and/or data drain resulting\n     * from special privileges that the association provides</p>\n     *\n     * <p>Calling this API requires a uses-feature\n     * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>\n     *\n     * @param deviceMacAddress the MAC address of device to disassociate from this app. Device\n     * address is case-sensitive in API level &lt; 33.\n     *\n     * @deprecated use {@link #disassociate(int)}\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_COMPANION_DEVICE_SETUP", "#disassociate(int)" ]
  }, {
    "name" : "public void disassociate(int associationId)",
    "returnType" : "void",
    "comment" : "\n     * Remove an association.\n     *\n     * <p>Any privileges provided via being associated with a given device will be revoked</p>\n     *\n     * <p>Calling this API requires a uses-feature\n     * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>\n     *\n     * @param associationId id of the association to be removed.\n     *\n     * @see #associate(AssociationRequest, Executor, Callback)\n     * @see AssociationInfo#getId()\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_COMPANION_DEVICE_SETUP" ]
  }, {
    "name" : "public void requestNotificationAccess(ComponentName component)",
    "returnType" : "void",
    "comment" : "\n     * Request notification access for the given component.\n     *\n     * The given component must follow the protocol specified in {@link NotificationListenerService}\n     *\n     * Only components from the same {@link ComponentName#getPackageName package} as the calling app\n     * are allowed.\n     *\n     * Your app must have an association with a device before calling this API.\n     *\n     * Side-loaded apps must allow restricted settings before requesting notification access.\n     *\n     * <p>Calling this API requires a uses-feature\n     * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_COMPANION_DEVICE_SETUP", "android.content.ComponentName#getPackageName", "android.service.notification.NotificationListenerService" ]
  }, {
    "name" : "public boolean hasNotificationAccess(ComponentName component)",
    "returnType" : "boolean",
    "comment" : "\n     * Check whether the given component can access the notifications via a\n     * {@link NotificationListenerService}\n     *\n     * Your app must have an association with a device before calling this API\n     *\n     * <p>Calling this API requires a uses-feature\n     * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>\n     *\n     * @param component the name of the component\n     * @return whether the given component has the notification listener permission\n     *\n     * @deprecated Use\n     * {@link NotificationManager#isNotificationListenerAccessGranted(ComponentName)} instead.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_COMPANION_DEVICE_SETUP", "android.service.notification.NotificationListenerService", "android.app.NotificationManager#isNotificationListenerAccessGranted(ComponentName)" ]
  }, {
    "name" : "public boolean isDeviceAssociatedForWifiConnection(@NonNull String packageName, @NonNull MacAddress macAddress, @NonNull UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if a given package was {@link #associate associated} with a device with given\n     * Wi-Fi MAC address for a given user.\n     *\n     * <p>This is a system API protected by the\n     * {@link android.Manifest.permission#MANAGE_COMPANION_DEVICES} permission, that’s currently\n     * called by the Android Wi-Fi stack to determine whether user consent is required to connect\n     * to a Wi-Fi network. Devices that have been pre-registered as companion devices will not\n     * require user consent to connect.</p>\n     *\n     * <p>Note if the caller has the\n     * {@link android.Manifest.permission#COMPANION_APPROVE_WIFI_CONNECTIONS} permission, this\n     * method will return true by default.</p>\n     *\n     * @param packageName the name of the package that has the association with the companion device\n     * @param macAddress the Wi-Fi MAC address or BSSID of the companion device to check for\n     * @param user the user handle that currently hosts the package being queried for a companion\n     *             device association\n     * @return whether a corresponding association record exists\n     *\n     * @hide\n     ",
    "links" : [ "#associate", "android.Manifest.permission#COMPANION_APPROVE_WIFI_CONNECTIONS", "android.Manifest.permission#MANAGE_COMPANION_DEVICES" ]
  }, {
    "name" : "public List<AssociationInfo> getAllAssociations()",
    "returnType" : "List<AssociationInfo>",
    "comment" : "\n     * Gets all package-device {@link AssociationInfo}s for the current user.\n     *\n     * @return the associations list\n     * @see #addOnAssociationsChangedListener(Executor, OnAssociationsChangedListener)\n     * @see #removeOnAssociationsChangedListener(OnAssociationsChangedListener)\n     * @hide\n     ",
    "links" : [ "android.companion.AssociationInfo" ]
  }, {
    "name" : "public List<AssociationInfo> getAllAssociations(@UserIdInt int userId)",
    "returnType" : "List<AssociationInfo>",
    "comment" : "\n     * Per-user version of {@link #getAllAssociations()}.\n     *\n     * @hide\n     ",
    "links" : [ "#getAllAssociations()" ]
  }, {
    "name" : "public void addOnAssociationsChangedListener(@NonNull Executor executor, @NonNull OnAssociationsChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register listener for any changes to {@link AssociationInfo}.\n     *\n     * @see #getAllAssociations()\n     * @hide\n     ",
    "links" : [ "android.companion.AssociationInfo" ]
  }, {
    "name" : "public void addOnAssociationsChangedListener(@NonNull Executor executor, @NonNull OnAssociationsChangedListener listener, @UserIdInt int userId)",
    "returnType" : "void",
    "comment" : "\n     * Per-user version of\n     * {@link #addOnAssociationsChangedListener(Executor, OnAssociationsChangedListener)}.\n     *\n     * @hide\n     ",
    "links" : [ "#addOnAssociationsChangedListener(Executor" ]
  }, {
    "name" : "public void removeOnAssociationsChangedListener(@NonNull OnAssociationsChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Unregister listener for any changes to {@link AssociationInfo}.\n     *\n     * @see #getAllAssociations()\n     * @hide\n     ",
    "links" : [ "android.companion.AssociationInfo" ]
  }, {
    "name" : "public void addOnTransportsChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<List<AssociationInfo>> listener)",
    "returnType" : "void",
    "comment" : "\n     * Adds a listener for any changes to the list of attached transports.\n     * Registered listener will be triggered with a list of existing transports when a transport\n     * is detached or a new transport is attached.\n     *\n     * @param executor The executor which will be used to invoke the listener.\n     * @param listener Called when a transport is attached or detached. Contains the updated list of\n     *                 associations which have connected transports.\n     * @see com.android.server.companion.transport.Transport\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeOnTransportsChangedListener(@NonNull Consumer<List<AssociationInfo>> listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes the registered listener for any changes to the list of attached transports.\n     *\n     * @see com.android.server.companion.transport.Transport\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void sendMessage(int messageType, @NonNull byte[] data, @NonNull int[] associationIds)",
    "returnType" : "void",
    "comment" : "\n     * Sends a message to associated remote devices. The target associations must already have a\n     * connected transport.\n     *\n     * @see #attachSystemDataTransport(int, InputStream, OutputStream)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addOnMessageReceivedListener(@NonNull @CallbackExecutor Executor executor, int messageType, @NonNull BiConsumer<Integer, byte[]> listener)",
    "returnType" : "void",
    "comment" : "\n     * Adds a listener that triggers when messages of given type are received.\n     *\n     * @param executor The executor which will be used to invoke the listener.\n     * @param messageType Message type to be subscribed to.\n     * @param listener Called when a message is received. Contains the association ID of the message\n     *                 sender and the message payload as a byte array.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeOnMessageReceivedListener(int messageType, @NonNull BiConsumer<Integer, byte[]> listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes the registered listener for received messages of given type.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean canPairWithoutPrompt(@NonNull String packageName, @NonNull String deviceMacAddress, @NonNull UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether the bluetooth device represented by the mac address was recently associated\n     * with the companion app. This allows these devices to skip the Bluetooth pairing dialog if\n     * their pairing variant is {@link BluetoothDevice#PAIRING_VARIANT_CONSENT}.\n     *\n     * @param packageName the package name of the calling app\n     * @param deviceMacAddress the bluetooth device's mac address\n     * @param user the user handle that currently hosts the package being queried for a companion\n     *             device association\n     * @return true if it was recently associated and we can bypass the dialog, false otherwise\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice#PAIRING_VARIANT_CONSENT" ]
  }, {
    "name" : "public void startObservingDevicePresence(@NonNull String deviceAddress) throws DeviceNotAssociatedException",
    "returnType" : "void",
    "comment" : "\n     * Register to receive callbacks whenever the associated device comes in and out of range.\n     *\n     * <p>The provided device must be {@link #associate associated} with the calling app before\n     * calling this method.</p>\n     *\n     * <p>Caller must implement a single {@link CompanionDeviceService} which will be bound to and\n     * receive callbacks to {@link CompanionDeviceService#onDeviceAppeared} and\n     * {@link CompanionDeviceService#onDeviceDisappeared}.\n     * The app doesn't need to remain running in order to receive its callbacks.</p>\n     *\n     * <p>Calling app must declare uses-permission\n     * {@link android.Manifest.permission#REQUEST_OBSERVE_COMPANION_DEVICE_PRESENCE}.</p>\n     *\n     * <p>Calling app must check for feature presence of\n     * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} before calling this API.</p>\n     *\n     * <p>For Bluetooth LE devices, this is based on scanning for device with the given address.\n     * The system will scan for the device when Bluetooth is ON or Bluetooth scanning is ON.</p>\n     *\n     * <p>For Bluetooth classic devices this is triggered when the device connects/disconnects.\n     * WiFi devices are not supported.</p>\n     *\n     * <p>If a Bluetooth LE device wants to use a rotating mac address, it is recommended to use\n     * Resolvable Private Address, and ensure the device is bonded to the phone so that android OS\n     * is able to resolve the address.</p>\n     *\n     * @param deviceAddress a previously-associated companion device's address\n     *\n     * @throws DeviceNotAssociatedException if the given device was not previously associated\n     * with this app.\n     ",
    "links" : [ "#associate", "android.companion.CompanionDeviceService#onDeviceDisappeared", "android.companion.CompanionDeviceService#onDeviceAppeared", "android.Manifest.permission#REQUEST_OBSERVE_COMPANION_DEVICE_PRESENCE", "android.content.pm.PackageManager#FEATURE_COMPANION_DEVICE_SETUP", "android.companion.CompanionDeviceService" ]
  }, {
    "name" : "public void stopObservingDevicePresence(@NonNull String deviceAddress) throws DeviceNotAssociatedException",
    "returnType" : "void",
    "comment" : "\n     * Unregister for receiving callbacks whenever the associated device comes in and out of range.\n     *\n     * The provided device must be {@link #associate associated} with the calling app before\n     * calling this method.\n     *\n     * Calling app must declare uses-permission\n     * {@link android.Manifest.permission#REQUEST_OBSERVE_COMPANION_DEVICE_PRESENCE}.\n     *\n     * Calling app must check for feature presence of\n     * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} before calling this API.\n     *\n     * @param deviceAddress a previously-associated companion device's address\n     *\n     * @throws DeviceNotAssociatedException if the given device was not previously associated\n     * with this app.\n     ",
    "links" : [ "#associate", "android.Manifest.permission#REQUEST_OBSERVE_COMPANION_DEVICE_PRESENCE", "android.content.pm.PackageManager#FEATURE_COMPANION_DEVICE_SETUP" ]
  }, {
    "name" : "public void startObservingDevicePresence(@NonNull ObservingDevicePresenceRequest request)",
    "returnType" : "void",
    "comment" : "\n     * Register to receive callbacks whenever the associated device comes in and out of range.\n     *\n     * <p>The app doesn't need to remain running in order to receive its callbacks.</p>\n     *\n     * <p>Calling app must check for feature presence of\n     * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} before calling this API.</p>\n     *\n     * <p>For Bluetooth LE devices, this is based on scanning for device with the given address.\n     * The system will scan for the device when Bluetooth is ON or Bluetooth scanning is ON.</p>\n     *\n     * <p>For Bluetooth classic devices this is triggered when the device connects/disconnects.</p>\n     *\n     * <p>WiFi devices are not supported.</p>\n     *\n     * <p>If a Bluetooth LE device wants to use a rotating mac address, it is recommended to use\n     * Resolvable Private Address, and ensure the device is bonded to the phone so that android OS\n     * is able to resolve the address.</p>\n     *\n     * @param request A request for setting the types of device for observing device presence.\n     *\n     * @see ObservingDevicePresenceRequest.Builder\n     * @see CompanionDeviceService#onDevicePresenceEvent(DevicePresenceEvent)\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_COMPANION_DEVICE_SETUP" ]
  }, {
    "name" : "public void stopObservingDevicePresence(@NonNull ObservingDevicePresenceRequest request)",
    "returnType" : "void",
    "comment" : "\n     * Unregister for receiving callbacks whenever the associated device comes in and out of range.\n     *\n     * Calling app must check for feature presence of\n     * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} before calling this API.\n     *\n     * @param request A request for setting the types of device for observing device presence.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_COMPANION_DEVICE_SETUP" ]
  }, {
    "name" : "public void dispatchMessage(int messageId, int associationId, @NonNull byte[] message) throws DeviceNotAssociatedException",
    "returnType" : "void",
    "comment" : "\n     * Dispatch a message to system for processing. It should only be called by\n     * {@link CompanionDeviceService#dispatchMessageToSystem(int, int, byte[])}\n     *\n     * <p>Calling app must declare uses-permission\n     * {@link android.Manifest.permission#DELIVER_COMPANION_MESSAGES}</p>\n     *\n     * @param messageId id of the message\n     * @param associationId association id of the associated device where data is coming from\n     * @param message message received from the associated device\n     *\n     * @throws DeviceNotAssociatedException if the given device was not previously associated with\n     * this app\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#DELIVER_COMPANION_MESSAGES", "android.companion.CompanionDeviceService#dispatchMessageToSystem(int" ]
  }, {
    "name" : "public void attachSystemDataTransport(int associationId, @NonNull InputStream in, @NonNull OutputStream out) throws DeviceNotAssociatedException",
    "returnType" : "void",
    "comment" : "\n     * Attach a bidirectional communication stream to be used as a transport channel for\n     * transporting system data between associated devices.\n     *\n     * @param associationId id of the associated device.\n     * @param in Already connected stream of data incoming from remote\n     *           associated device.\n     * @param out Already connected stream of data outgoing to remote associated\n     *            device.\n     * @throws DeviceNotAssociatedException Thrown if the associationId was not previously\n     * associated with this app.\n     *\n     * @see #buildPermissionTransferUserConsentIntent(int)\n     * @see #startSystemDataTransfer(int, Executor, OutcomeReceiver)\n     * @see #detachSystemDataTransport(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void detachSystemDataTransport(int associationId) throws DeviceNotAssociatedException",
    "returnType" : "void",
    "comment" : "\n     * Detach the transport channel that's previously attached for the associated device. The system\n     * will stop transferring any system data when this method is called.\n     *\n     * @param associationId id of the associated device.\n     * @throws DeviceNotAssociatedException Thrown if the associationId was not previously\n     * associated with this app.\n     *\n     * @see #attachSystemDataTransport(int, InputStream, OutputStream)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void associate(@NonNull String packageName, @NonNull MacAddress macAddress, @NonNull byte[] certificate)",
    "returnType" : "void",
    "comment" : "\n     * Associates given device with given app for the given user directly, without UI prompt.\n     *\n     * @param packageName package name of the companion app\n     * @param macAddress mac address of the device to associate\n     * @param certificate The SHA256 digest of the companion app's signing certificate\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void notifyDeviceAppeared(int associationId)",
    "returnType" : "void",
    "comment" : "\n     * Notify the system that the given self-managed association has just appeared.\n     * This causes the system to bind to the companion app to keep it running until the association\n     * is reported as disappeared\n     *\n     * <p>This API is only available for the companion apps that manage the connectivity by\n     * themselves.</p>\n     *\n     * @param associationId the unique {@link AssociationInfo#getId ID} assigned to the Association\n     * recorded by CompanionDeviceManager\n     *\n     * @hide\n     ",
    "links" : [ "android.companion.AssociationInfo#getId" ]
  }, {
    "name" : "public void notifyDeviceDisappeared(int associationId)",
    "returnType" : "void",
    "comment" : "\n     * Notify the system that the given self-managed association has just disappeared.\n     * This causes the system to unbind to the companion app.\n     *\n     * <p>This API is only available for the companion apps that manage the connectivity by\n     * themselves.</p>\n     *\n     * @param associationId the unique {@link AssociationInfo#getId ID} assigned to the Association\n     * recorded by CompanionDeviceManager\n\n     * @hide\n     ",
    "links" : [ "android.companion.AssociationInfo#getId" ]
  }, {
    "name" : "public IntentSender buildPermissionTransferUserConsentIntent(int associationId) throws DeviceNotAssociatedException",
    "returnType" : "IntentSender",
    "comment" : "\n     * Build a permission sync user consent dialog.\n     *\n     * <p>Only the companion app which owns the association can call this method. Otherwise a null\n     * IntentSender will be returned from this method and an error will be logged.\n     * The app should launch the {@link Activity} in the returned {@code intentSender}\n     * {@link IntentSender} by calling\n     * {@link Activity#startIntentSenderForResult(IntentSender, int, Intent, int, int, int)}.</p>\n     *\n     * <p>The permission transfer doesn't happen immediately after the call or when the user\n     * consents. The app needs to call\n     * {@link #attachSystemDataTransport(int, InputStream, OutputStream)} to attach a transport\n     * channel and\n     * {@link #startSystemDataTransfer(int, Executor, OutcomeReceiver)} to trigger the system data\n     * transfer}.</p>\n     *\n     * @param associationId The unique {@link AssociationInfo#getId ID} assigned to the association\n     *                      of the companion device recorded by CompanionDeviceManager\n     * @return An {@link IntentSender} that the app should use to launch the UI for\n     *         the user to confirm the system data transfer request.\n     *\n     * @see #attachSystemDataTransport(int, InputStream, OutputStream)\n     * @see #startSystemDataTransfer(int, Executor, OutcomeReceiver)\n     ",
    "links" : [ "android.companion.AssociationInfo#getId", "android.content.IntentSender", "#startSystemDataTransfer(int", "#attachSystemDataTransport(int", "android.app.Activity#startIntentSenderForResult(IntentSender", "android.app.Activity" ]
  }, {
    "name" : "public boolean isPermissionTransferUserConsented(int associationId)",
    "returnType" : "boolean",
    "comment" : "\n     * Return the current state of consent for permission transfer for the association.\n     * True if the user has allowed permission transfer for the association, false otherwise.\n     *\n     * <p>\n     * Note: The initial user consent is collected via\n     * {@link #buildPermissionTransferUserConsentIntent(int) a permission transfer user consent dialog}.\n     * After the user has made their initial selection, they can toggle the permission transfer\n     * feature in the settings.\n     * This method always returns the state of the toggle setting.\n     * </p>\n     *\n     * @param associationId The unique {@link AssociationInfo#getId ID} assigned to the association\n     *                      of the companion device recorded by CompanionDeviceManager\n     * @return True if the user has consented to the permission transfer, or false otherwise.\n     * @throws DeviceNotAssociatedException Exception if the companion device is not associated with\n     *                                      the user or the calling app.\n     ",
    "links" : [ "android.companion.AssociationInfo#getId", "#buildPermissionTransferUserConsentIntent(int)" ]
  }, {
    "name" : "public void startSystemDataTransfer(int associationId) throws DeviceNotAssociatedException",
    "returnType" : "void",
    "comment" : "\n     * Start system data transfer which has been previously approved by the user.\n     *\n     * <p>Before calling this method, the app needs to make sure there's a communication channel\n     * between two devices, and has prompted user consent dialogs built by one of these methods:\n     * {@link #buildPermissionTransferUserConsentIntent(int)}.\n     * The transfer may fail if the communication channel is disconnected during the transfer.</p>\n     *\n     * @param associationId The unique {@link AssociationInfo#getId ID} assigned to the Association\n     *                      of the companion device recorded by CompanionDeviceManager\n     * @throws DeviceNotAssociatedException Exception if the companion device is not associated\n     * @deprecated Use {@link #startSystemDataTransfer(int, Executor, OutcomeReceiver)} instead.\n     * @hide\n     ",
    "links" : [ "android.companion.AssociationInfo#getId", "#startSystemDataTransfer(int", "#buildPermissionTransferUserConsentIntent(int)" ]
  }, {
    "name" : "public void startSystemDataTransfer(int associationId, @NonNull Executor executor, @NonNull OutcomeReceiver<Void, CompanionException> result) throws DeviceNotAssociatedException",
    "returnType" : "void",
    "comment" : "\n     * Start system data transfer which has been previously approved by the user.\n     *\n     * <p>Before calling this method, the app needs to make sure\n     * {@link #attachSystemDataTransport(int, InputStream, OutputStream) the transport channel is\n     * attached}, and\n     * {@link #buildPermissionTransferUserConsentIntent(int) the user consent dialog has prompted to\n     * the user}.\n     * The transfer will fail if the transport channel is disconnected or\n     * {@link #detachSystemDataTransport(int) detached} during the transfer.</p>\n     *\n     * @param associationId The unique {@link AssociationInfo#getId ID} assigned to the Association\n     *                      of the companion device recorded by CompanionDeviceManager\n     * @param executor The executor which will be used to invoke the result callback.\n     * @param result The callback to notify the app of the result of the system data transfer.\n     * @throws DeviceNotAssociatedException Exception if the companion device is not associated\n     ",
    "links" : [ "#detachSystemDataTransport(int)", "android.companion.AssociationInfo#getId", "#buildPermissionTransferUserConsentIntent(int)", "#attachSystemDataTransport(int" ]
  }, {
    "name" : "public boolean isCompanionApplicationBound()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether the calling companion application is currently bound.\n     *\n     * @return true if application is bound, false otherwise\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void enableSecureTransport(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Enables or disables secure transport for testing. Defaults to being enabled.\n     * Should not be used outside of testing.\n     *\n     * @param enabled true to enable. false to disable.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAssociationTag(int associationId, @NonNull String tag)",
    "returnType" : "void",
    "comment" : "\n     * Sets the {@link AssociationInfo#getTag() tag} for this association.\n     *\n     * <p>The length of the tag must be at most 1024 characters to save disk space.\n     *\n     * <p>This allows to store useful information about the associated devices.\n     *\n     * @param associationId The unique {@link AssociationInfo#getId ID} assigned to the Association\n     *                          of the companion device recorded by CompanionDeviceManager\n     * @param tag the tag of this association\n     ",
    "links" : [ "android.companion.AssociationInfo#getId", "android.companion.AssociationInfo#getTag()" ]
  }, {
    "name" : "public void clearAssociationTag(int associationId)",
    "returnType" : "void",
    "comment" : "\n     * Clears the {@link AssociationInfo#getTag() tag} for this association.\n     *\n     * <p>The tag will be set to null for this association when calling this API.\n     *\n     * @param associationId The unique {@link AssociationInfo#getId ID} assigned to the Association\n     *                          of the companion device recorded by CompanionDeviceManager\n     * @see CompanionDeviceManager#setAssociationTag(int, String)\n     ",
    "links" : [ "android.companion.AssociationInfo#getId", "android.companion.AssociationInfo#getTag()" ]
  } ],
  "methodNames" : [ "public void associate(@NonNull AssociationRequest request, @NonNull Callback callback, @Nullable Handler handler)", "public void associate(@NonNull AssociationRequest request, @NonNull Executor executor, @NonNull Callback callback)", "public IntentSender buildAssociationCancellationIntent()", "public void enableSystemDataSyncForTypes(int associationId, @DataSyncTypes int flags)", "public void disableSystemDataSyncForTypes(int associationId, @DataSyncTypes int flags)", "public void enablePermissionsSync(int associationId)", "public void disablePermissionsSync(int associationId)", "public PermissionSyncRequest getPermissionSyncRequest(int associationId)", "public List<String> getAssociations()", "public List<AssociationInfo> getMyAssociations()", "public void disassociate(@NonNull String deviceMacAddress)", "public void disassociate(int associationId)", "public void requestNotificationAccess(ComponentName component)", "public boolean hasNotificationAccess(ComponentName component)", "public boolean isDeviceAssociatedForWifiConnection(@NonNull String packageName, @NonNull MacAddress macAddress, @NonNull UserHandle user)", "public List<AssociationInfo> getAllAssociations()", "public List<AssociationInfo> getAllAssociations(@UserIdInt int userId)", "public void addOnAssociationsChangedListener(@NonNull Executor executor, @NonNull OnAssociationsChangedListener listener)", "public void addOnAssociationsChangedListener(@NonNull Executor executor, @NonNull OnAssociationsChangedListener listener, @UserIdInt int userId)", "public void removeOnAssociationsChangedListener(@NonNull OnAssociationsChangedListener listener)", "public void addOnTransportsChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<List<AssociationInfo>> listener)", "public void removeOnTransportsChangedListener(@NonNull Consumer<List<AssociationInfo>> listener)", "public void sendMessage(int messageType, @NonNull byte[] data, @NonNull int[] associationIds)", "public void addOnMessageReceivedListener(@NonNull @CallbackExecutor Executor executor, int messageType, @NonNull BiConsumer<Integer, byte[]> listener)", "public void removeOnMessageReceivedListener(int messageType, @NonNull BiConsumer<Integer, byte[]> listener)", "public boolean canPairWithoutPrompt(@NonNull String packageName, @NonNull String deviceMacAddress, @NonNull UserHandle user)", "public void startObservingDevicePresence(@NonNull String deviceAddress) throws DeviceNotAssociatedException", "public void stopObservingDevicePresence(@NonNull String deviceAddress) throws DeviceNotAssociatedException", "public void startObservingDevicePresence(@NonNull ObservingDevicePresenceRequest request)", "public void stopObservingDevicePresence(@NonNull ObservingDevicePresenceRequest request)", "public void dispatchMessage(int messageId, int associationId, @NonNull byte[] message) throws DeviceNotAssociatedException", "public void attachSystemDataTransport(int associationId, @NonNull InputStream in, @NonNull OutputStream out) throws DeviceNotAssociatedException", "public void detachSystemDataTransport(int associationId) throws DeviceNotAssociatedException", "public void associate(@NonNull String packageName, @NonNull MacAddress macAddress, @NonNull byte[] certificate)", "public void notifyDeviceAppeared(int associationId)", "public void notifyDeviceDisappeared(int associationId)", "public IntentSender buildPermissionTransferUserConsentIntent(int associationId) throws DeviceNotAssociatedException", "public boolean isPermissionTransferUserConsented(int associationId)", "public void startSystemDataTransfer(int associationId) throws DeviceNotAssociatedException", "public void startSystemDataTransfer(int associationId, @NonNull Executor executor, @NonNull OutcomeReceiver<Void, CompanionException> result) throws DeviceNotAssociatedException", "public boolean isCompanionApplicationBound()", "public void enableSecureTransport(boolean enabled)", "public void setAssociationTag(int associationId, @NonNull String tag)", "public void clearAssociationTag(int associationId)" ],
  "variableNames" : [ "TAG", "RESULT_OK", "RESULT_CANCELED", "RESULT_USER_REJECTED", "RESULT_DISCOVERY_TIMEOUT", "RESULT_INTERNAL_ERROR", "REASON_USER_REJECTED", "REASON_DISCOVERY_TIMEOUT", "REASON_INTERNAL_ERROR", "REASON_CANCELED", "FLAG_CALL_METADATA", "EXTRA_DEVICE", "EXTRA_ASSOCIATION", "MESSAGE_REQUEST_PING", "MESSAGE_ONEWAY_PING", "MESSAGE_REQUEST_REMOTE_AUTHENTICATION", "MESSAGE_REQUEST_CONTEXT_SYNC", "MESSAGE_REQUEST_PERMISSION_RESTORE", "MESSAGE_ONEWAY_FROM_WEARABLE", "MESSAGE_ONEWAY_TO_WEARABLE", "ASSOCIATION_TAG_LENGTH_LIMIT", "mService", "mContext", "mListeners", "mTransportsChangedListeners", "mTransports" ]
}