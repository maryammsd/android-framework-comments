{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/util/Arrays.java",
  "packageName" : "java.util",
  "className" : "Arrays",
  "comment" : "\n * This class contains various methods for manipulating arrays (such as\n * sorting and searching). This class also contains a static factory\n * that allows arrays to be viewed as lists.\n *\n * <p>The methods in this class all throw a {@code NullPointerException},\n * if the specified array reference is null, except where noted.\n *\n * <p>The documentation for the methods contained in this class includes\n * brief descriptions of the <i>implementations</i>. Such descriptions should\n * be regarded as <i>implementation notes</i>, rather than parts of the\n * <i>specification</i>. Implementors should feel free to substitute other\n * algorithms, so long as the specification itself is adhered to. (For\n * example, the algorithm used by {@code sort(Object[])} does not have to be\n * a MergeSort, but it does have to be <i>stable</i>.)\n *\n * <p>This class is a member of the\n * <a href=\"{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework\">\n * Java Collections Framework</a>.\n *\n * @author Josh Bloch\n * @author Neal Gafter\n * @author John Rose\n * @since  1.2\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "MIN_ARRAY_SORT_GRAN",
    "type" : "int",
    "comment" : " ArraysTest).",
    "links" : [ ]
  }, {
    "name" : "INSERTIONSORT_THRESHOLD",
    "type" : "int",
    "comment" : "\n     * Tuning parameter: list size at or below which insertion sort will be\n     * used in preference to mergesort.\n     * To be removed in a future release.\n     ",
    "links" : [ ]
  }, {
    "name" : "DO_NOT_CLONE_IN_ARRAYS_AS_LIST",
    "type" : "long",
    "comment" : "\n     * Since Android 15 Arrays.asList(...).toArray()'s component type is {@link Object},\n     * not the underlying array's elements type. So the following code will throw\n     * {@link ClassCastException}:\n     * <pre>{@code\n     * String[] elements = (String[]) Arrays.asList(\"one\", \"two\").toArray();\n     * }</pre>\n     * You can overcome this by using {@link Collection#toArray(Object[])}:\n     * <pre>{@code\n     * String[] elements = Arrays.asList(\"two\", \"one\").toArray(new String[0]);\n     * }</pre>\n     * @hide\n     ",
    "links" : [ "ClassCastException", "java.util.Collection#toArray(Object", "Object" ]
  } ],
  "methods" : [ {
    "name" : "public static void sort(int[] a)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified array into ascending numerical order.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void sort(int[] a, int fromIndex, int toIndex)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified range of the array into ascending order. The range\n     * to be sorted extends from the index {@code fromIndex}, inclusive, to\n     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},\n     * the range to be sorted is empty.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     * @param fromIndex the index of the first element, inclusive, to be sorted\n     * @param toIndex the index of the last element, exclusive, to be sorted\n     *\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *     if {@code fromIndex < 0} or {@code toIndex > a.length}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void sort(long[] a)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified array into ascending numerical order.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void sort(long[] a, int fromIndex, int toIndex)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified range of the array into ascending order. The range\n     * to be sorted extends from the index {@code fromIndex}, inclusive, to\n     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},\n     * the range to be sorted is empty.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     * @param fromIndex the index of the first element, inclusive, to be sorted\n     * @param toIndex the index of the last element, exclusive, to be sorted\n     *\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *     if {@code fromIndex < 0} or {@code toIndex > a.length}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void sort(short[] a)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified array into ascending numerical order.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void sort(short[] a, int fromIndex, int toIndex)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified range of the array into ascending order. The range\n     * to be sorted extends from the index {@code fromIndex}, inclusive, to\n     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},\n     * the range to be sorted is empty.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     * @param fromIndex the index of the first element, inclusive, to be sorted\n     * @param toIndex the index of the last element, exclusive, to be sorted\n     *\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *     if {@code fromIndex < 0} or {@code toIndex > a.length}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void sort(char[] a)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified array into ascending numerical order.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void sort(char[] a, int fromIndex, int toIndex)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified range of the array into ascending order. The range\n     * to be sorted extends from the index {@code fromIndex}, inclusive, to\n     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},\n     * the range to be sorted is empty.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     * @param fromIndex the index of the first element, inclusive, to be sorted\n     * @param toIndex the index of the last element, exclusive, to be sorted\n     *\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *     if {@code fromIndex < 0} or {@code toIndex > a.length}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void sort(byte[] a)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified array into ascending numerical order.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void sort(byte[] a, int fromIndex, int toIndex)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified range of the array into ascending order. The range\n     * to be sorted extends from the index {@code fromIndex}, inclusive, to\n     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},\n     * the range to be sorted is empty.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     * @param fromIndex the index of the first element, inclusive, to be sorted\n     * @param toIndex the index of the last element, exclusive, to be sorted\n     *\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *     if {@code fromIndex < 0} or {@code toIndex > a.length}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void sort(float[] a)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified array into ascending numerical order.\n     *\n     * <p>The {@code <} relation does not provide a total order on all float\n     * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}\n     * value compares neither less than, greater than, nor equal to any value,\n     * even itself. This method uses the total order imposed by the method\n     * {@link Float#compareTo}: {@code -0.0f} is treated as less than value\n     * {@code 0.0f} and {@code Float.NaN} is considered greater than any\n     * other value and all {@code Float.NaN} values are considered equal.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     ",
    "links" : [ "#compareTo" ]
  }, {
    "name" : "public static void sort(float[] a, int fromIndex, int toIndex)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified range of the array into ascending order. The range\n     * to be sorted extends from the index {@code fromIndex}, inclusive, to\n     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},\n     * the range to be sorted is empty.\n     *\n     * <p>The {@code <} relation does not provide a total order on all float\n     * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}\n     * value compares neither less than, greater than, nor equal to any value,\n     * even itself. This method uses the total order imposed by the method\n     * {@link Float#compareTo}: {@code -0.0f} is treated as less than value\n     * {@code 0.0f} and {@code Float.NaN} is considered greater than any\n     * other value and all {@code Float.NaN} values are considered equal.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     * @param fromIndex the index of the first element, inclusive, to be sorted\n     * @param toIndex the index of the last element, exclusive, to be sorted\n     *\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *     if {@code fromIndex < 0} or {@code toIndex > a.length}\n     ",
    "links" : [ "#compareTo" ]
  }, {
    "name" : "public static void sort(double[] a)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified array into ascending numerical order.\n     *\n     * <p>The {@code <} relation does not provide a total order on all double\n     * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}\n     * value compares neither less than, greater than, nor equal to any value,\n     * even itself. This method uses the total order imposed by the method\n     * {@link Double#compareTo}: {@code -0.0d} is treated as less than value\n     * {@code 0.0d} and {@code Double.NaN} is considered greater than any\n     * other value and all {@code Double.NaN} values are considered equal.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     ",
    "links" : [ "#compareTo" ]
  }, {
    "name" : "public static void sort(double[] a, int fromIndex, int toIndex)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified range of the array into ascending order. The range\n     * to be sorted extends from the index {@code fromIndex}, inclusive, to\n     * the index {@code toIndex}, exclusive. If {@code fromIndex == toIndex},\n     * the range to be sorted is empty.\n     *\n     * <p>The {@code <} relation does not provide a total order on all double\n     * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}\n     * value compares neither less than, greater than, nor equal to any value,\n     * even itself. This method uses the total order imposed by the method\n     * {@link Double#compareTo}: {@code -0.0d} is treated as less than value\n     * {@code 0.0d} and {@code Double.NaN} is considered greater than any\n     * other value and all {@code Double.NaN} values are considered equal.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort\n     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     * @param fromIndex the index of the first element, inclusive, to be sorted\n     * @param toIndex the index of the last element, exclusive, to be sorted\n     *\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *     if {@code fromIndex < 0} or {@code toIndex > a.length}\n     ",
    "links" : [ "#compareTo" ]
  }, {
    "name" : "public static void parallelSort(byte[] a)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified array into ascending numerical order.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     *\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void parallelSort(byte[] a, int fromIndex, int toIndex)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified range of the array into ascending numerical order.\n     * The range to be sorted extends from the index {@code fromIndex},\n     * inclusive, to the index {@code toIndex}, exclusive. If\n     * {@code fromIndex == toIndex}, the range to be sorted is empty.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     * @param fromIndex the index of the first element, inclusive, to be sorted\n     * @param toIndex the index of the last element, exclusive, to be sorted\n     *\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *     if {@code fromIndex < 0} or {@code toIndex > a.length}\n     *\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void parallelSort(char[] a)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified array into ascending numerical order.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     *\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void parallelSort(char[] a, int fromIndex, int toIndex)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified range of the array into ascending numerical order.\n     * The range to be sorted extends from the index {@code fromIndex},\n     * inclusive, to the index {@code toIndex}, exclusive. If\n     * {@code fromIndex == toIndex}, the range to be sorted is empty.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     * @param fromIndex the index of the first element, inclusive, to be sorted\n     * @param toIndex the index of the last element, exclusive, to be sorted\n     *\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *     if {@code fromIndex < 0} or {@code toIndex > a.length}\n     *\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void parallelSort(short[] a)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified array into ascending numerical order.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     *\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void parallelSort(short[] a, int fromIndex, int toIndex)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified range of the array into ascending numerical order.\n     * The range to be sorted extends from the index {@code fromIndex},\n     * inclusive, to the index {@code toIndex}, exclusive. If\n     * {@code fromIndex == toIndex}, the range to be sorted is empty.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     * @param fromIndex the index of the first element, inclusive, to be sorted\n     * @param toIndex the index of the last element, exclusive, to be sorted\n     *\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *     if {@code fromIndex < 0} or {@code toIndex > a.length}\n     *\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void parallelSort(int[] a)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified array into ascending numerical order.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     *\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void parallelSort(int[] a, int fromIndex, int toIndex)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified range of the array into ascending numerical order.\n     * The range to be sorted extends from the index {@code fromIndex},\n     * inclusive, to the index {@code toIndex}, exclusive. If\n     * {@code fromIndex == toIndex}, the range to be sorted is empty.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     * @param fromIndex the index of the first element, inclusive, to be sorted\n     * @param toIndex the index of the last element, exclusive, to be sorted\n     *\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *     if {@code fromIndex < 0} or {@code toIndex > a.length}\n     *\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void parallelSort(long[] a)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified array into ascending numerical order.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     *\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void parallelSort(long[] a, int fromIndex, int toIndex)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified range of the array into ascending numerical order.\n     * The range to be sorted extends from the index {@code fromIndex},\n     * inclusive, to the index {@code toIndex}, exclusive. If\n     * {@code fromIndex == toIndex}, the range to be sorted is empty.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     * @param fromIndex the index of the first element, inclusive, to be sorted\n     * @param toIndex the index of the last element, exclusive, to be sorted\n     *\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *     if {@code fromIndex < 0} or {@code toIndex > a.length}\n     *\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void parallelSort(float[] a)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified array into ascending numerical order.\n     *\n     * <p>The {@code <} relation does not provide a total order on all float\n     * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}\n     * value compares neither less than, greater than, nor equal to any value,\n     * even itself. This method uses the total order imposed by the method\n     * {@link Float#compareTo}: {@code -0.0f} is treated as less than value\n     * {@code 0.0f} and {@code Float.NaN} is considered greater than any\n     * other value and all {@code Float.NaN} values are considered equal.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     *\n     * @since 1.8\n     ",
    "links" : [ "#compareTo" ]
  }, {
    "name" : "public static void parallelSort(float[] a, int fromIndex, int toIndex)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified range of the array into ascending numerical order.\n     * The range to be sorted extends from the index {@code fromIndex},\n     * inclusive, to the index {@code toIndex}, exclusive. If\n     * {@code fromIndex == toIndex}, the range to be sorted is empty.\n     *\n     * <p>The {@code <} relation does not provide a total order on all float\n     * values: {@code -0.0f == 0.0f} is {@code true} and a {@code Float.NaN}\n     * value compares neither less than, greater than, nor equal to any value,\n     * even itself. This method uses the total order imposed by the method\n     * {@link Float#compareTo}: {@code -0.0f} is treated as less than value\n     * {@code 0.0f} and {@code Float.NaN} is considered greater than any\n     * other value and all {@code Float.NaN} values are considered equal.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     * @param fromIndex the index of the first element, inclusive, to be sorted\n     * @param toIndex the index of the last element, exclusive, to be sorted\n     *\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *     if {@code fromIndex < 0} or {@code toIndex > a.length}\n     *\n     * @since 1.8\n     ",
    "links" : [ "#compareTo" ]
  }, {
    "name" : "public static void parallelSort(double[] a)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified array into ascending numerical order.\n     *\n     * <p>The {@code <} relation does not provide a total order on all double\n     * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}\n     * value compares neither less than, greater than, nor equal to any value,\n     * even itself. This method uses the total order imposed by the method\n     * {@link Double#compareTo}: {@code -0.0d} is treated as less than value\n     * {@code 0.0d} and {@code Double.NaN} is considered greater than any\n     * other value and all {@code Double.NaN} values are considered equal.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     *\n     * @since 1.8\n     ",
    "links" : [ "#compareTo" ]
  }, {
    "name" : "public static void parallelSort(double[] a, int fromIndex, int toIndex)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified range of the array into ascending numerical order.\n     * The range to be sorted extends from the index {@code fromIndex},\n     * inclusive, to the index {@code toIndex}, exclusive. If\n     * {@code fromIndex == toIndex}, the range to be sorted is empty.\n     *\n     * <p>The {@code <} relation does not provide a total order on all double\n     * values: {@code -0.0d == 0.0d} is {@code true} and a {@code Double.NaN}\n     * value compares neither less than, greater than, nor equal to any value,\n     * even itself. This method uses the total order imposed by the method\n     * {@link Double#compareTo}: {@code -0.0d} is treated as less than value\n     * {@code 0.0d} and {@code Double.NaN} is considered greater than any\n     * other value and all {@code Double.NaN} values are considered equal.\n     *\n     * @implNote The sorting algorithm is a Dual-Pivot Quicksort by\n     * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\n     * offers O(n log(n)) performance on all data sets, and is typically\n     * faster than traditional (one-pivot) Quicksort implementations.\n     *\n     * @param a the array to be sorted\n     * @param fromIndex the index of the first element, inclusive, to be sorted\n     * @param toIndex the index of the last element, exclusive, to be sorted\n     *\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *     if {@code fromIndex < 0} or {@code toIndex > a.length}\n     *\n     * @since 1.8\n     ",
    "links" : [ "#compareTo" ]
  }, {
    "name" : " static void rangeCheck(int arrayLength, int fromIndex, int toIndex)",
    "returnType" : "void",
    "comment" : "\n     * Checks that {@code fromIndex} and {@code toIndex} are in\n     * the range and throws an exception if they aren't.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void parallelSort(T[] a)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified array of objects into ascending order, according\n     * to the {@linkplain Comparable natural ordering} of its elements.\n     * All elements in the array must implement the {@link Comparable}\n     * interface.  Furthermore, all elements in the array must be\n     * <i>mutually comparable</i> (that is, {@code e1.compareTo(e2)} must\n     * not throw a {@code ClassCastException} for any elements {@code e1}\n     * and {@code e2} in the array).\n     *\n     * <p>This sort is guaranteed to be <i>stable</i>:  equal elements will\n     * not be reordered as a result of the sort.\n     *\n     * @implNote The sorting algorithm is a parallel sort-merge that breaks the\n     * array into sub-arrays that are themselves sorted and then merged. When\n     * the sub-array length reaches a minimum granularity, the sub-array is\n     * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}\n     * method. If the length of the specified array is less than the minimum\n     * granularity, then it is sorted using the appropriate {@link\n     * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a\n     * working space no greater than the size of the original array. The\n     * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to\n     * execute any parallel tasks.\n     *\n     * @param <T> the class of the objects to be sorted\n     * @param a the array to be sorted\n     *\n     * @throws ClassCastException if the array contains elements that are not\n     *         <i>mutually comparable</i> (for example, strings and integers)\n     * @throws IllegalArgumentException (optional) if the natural\n     *         ordering of the array elements is found to violate the\n     *         {@link Comparable} contract\n     *\n     * @since 1.8\n     ",
    "links" : [ "Comparable", "java.util.concurrent.ForkJoinPool#commonPool()", "java.util.Arrays#sort(Object" ]
  }, {
    "name" : "public static void parallelSort(T[] a, int fromIndex, int toIndex)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified range of the specified array of objects into\n     * ascending order, according to the\n     * {@linkplain Comparable natural ordering} of its\n     * elements.  The range to be sorted extends from index\n     * {@code fromIndex}, inclusive, to index {@code toIndex}, exclusive.\n     * (If {@code fromIndex==toIndex}, the range to be sorted is empty.)  All\n     * elements in this range must implement the {@link Comparable}\n     * interface.  Furthermore, all elements in this range must be <i>mutually\n     * comparable</i> (that is, {@code e1.compareTo(e2)} must not throw a\n     * {@code ClassCastException} for any elements {@code e1} and\n     * {@code e2} in the array).\n     *\n     * <p>This sort is guaranteed to be <i>stable</i>:  equal elements will\n     * not be reordered as a result of the sort.\n     *\n     * @implNote The sorting algorithm is a parallel sort-merge that breaks the\n     * array into sub-arrays that are themselves sorted and then merged. When\n     * the sub-array length reaches a minimum granularity, the sub-array is\n     * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}\n     * method. If the length of the specified array is less than the minimum\n     * granularity, then it is sorted using the appropriate {@link\n     * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a working\n     * space no greater than the size of the specified range of the original\n     * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is\n     * used to execute any parallel tasks.\n     *\n     * @param <T> the class of the objects to be sorted\n     * @param a the array to be sorted\n     * @param fromIndex the index of the first element (inclusive) to be\n     *        sorted\n     * @param toIndex the index of the last element (exclusive) to be sorted\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex} or\n     *         (optional) if the natural ordering of the array elements is\n     *         found to violate the {@link Comparable} contract\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or\n     *         {@code toIndex > a.length}\n     * @throws ClassCastException if the array contains elements that are\n     *         not <i>mutually comparable</i> (for example, strings and\n     *         integers).\n     *\n     * @since 1.8\n     ",
    "links" : [ "Comparable", "java.util.concurrent.ForkJoinPool#commonPool()", "java.util.Arrays#sort(Object" ]
  }, {
    "name" : "public static void parallelSort(T[] a, Comparator<? super T> cmp)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified array of objects according to the order induced by\n     * the specified comparator.  All elements in the array must be\n     * <i>mutually comparable</i> by the specified comparator (that is,\n     * {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}\n     * for any elements {@code e1} and {@code e2} in the array).\n     *\n     * <p>This sort is guaranteed to be <i>stable</i>:  equal elements will\n     * not be reordered as a result of the sort.\n     *\n     * @implNote The sorting algorithm is a parallel sort-merge that breaks the\n     * array into sub-arrays that are themselves sorted and then merged. When\n     * the sub-array length reaches a minimum granularity, the sub-array is\n     * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}\n     * method. If the length of the specified array is less than the minimum\n     * granularity, then it is sorted using the appropriate {@link\n     * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a\n     * working space no greater than the size of the original array. The\n     * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to\n     * execute any parallel tasks.\n     *\n     * @param <T> the class of the objects to be sorted\n     * @param a the array to be sorted\n     * @param cmp the comparator to determine the order of the array.  A\n     *        {@code null} value indicates that the elements'\n     *        {@linkplain Comparable natural ordering} should be used.\n     * @throws ClassCastException if the array contains elements that are\n     *         not <i>mutually comparable</i> using the specified comparator\n     * @throws IllegalArgumentException (optional) if the comparator is\n     *         found to violate the {@link java.util.Comparator} contract\n     *\n     * @since 1.8\n     ",
    "links" : [ "java.util.Comparator", "java.util.concurrent.ForkJoinPool#commonPool()", "java.util.Arrays#sort(Object" ]
  }, {
    "name" : "public static void parallelSort(T[] a, int fromIndex, int toIndex, Comparator<? super T> cmp)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified range of the specified array of objects according\n     * to the order induced by the specified comparator.  The range to be\n     * sorted extends from index {@code fromIndex}, inclusive, to index\n     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\n     * range to be sorted is empty.)  All elements in the range must be\n     * <i>mutually comparable</i> by the specified comparator (that is,\n     * {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}\n     * for any elements {@code e1} and {@code e2} in the range).\n     *\n     * <p>This sort is guaranteed to be <i>stable</i>:  equal elements will\n     * not be reordered as a result of the sort.\n     *\n     * @implNote The sorting algorithm is a parallel sort-merge that breaks the\n     * array into sub-arrays that are themselves sorted and then merged. When\n     * the sub-array length reaches a minimum granularity, the sub-array is\n     * sorted using the appropriate {@link Arrays#sort(Object[]) Arrays.sort}\n     * method. If the length of the specified array is less than the minimum\n     * granularity, then it is sorted using the appropriate {@link\n     * Arrays#sort(Object[]) Arrays.sort} method. The algorithm requires a working\n     * space no greater than the size of the specified range of the original\n     * array. The {@link ForkJoinPool#commonPool() ForkJoin common pool} is\n     * used to execute any parallel tasks.\n     *\n     * @param <T> the class of the objects to be sorted\n     * @param a the array to be sorted\n     * @param fromIndex the index of the first element (inclusive) to be\n     *        sorted\n     * @param toIndex the index of the last element (exclusive) to be sorted\n     * @param cmp the comparator to determine the order of the array.  A\n     *        {@code null} value indicates that the elements'\n     *        {@linkplain Comparable natural ordering} should be used.\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex} or\n     *         (optional) if the natural ordering of the array elements is\n     *         found to violate the {@link Comparable} contract\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or\n     *         {@code toIndex > a.length}\n     * @throws ClassCastException if the array contains elements that are\n     *         not <i>mutually comparable</i> (for example, strings and\n     *         integers).\n     *\n     * @since 1.8\n     ",
    "links" : [ "Comparable", "java.util.concurrent.ForkJoinPool#commonPool()", "java.util.Arrays#sort(Object" ]
  }, {
    "name" : "public static void sort(Object[] a)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified array of objects into ascending order, according\n     * to the {@linkplain Comparable natural ordering} of its elements.\n     * All elements in the array must implement the {@link Comparable}\n     * interface.  Furthermore, all elements in the array must be\n     * <i>mutually comparable</i> (that is, {@code e1.compareTo(e2)} must\n     * not throw a {@code ClassCastException} for any elements {@code e1}\n     * and {@code e2} in the array).\n     *\n     * <p>This sort is guaranteed to be <i>stable</i>:  equal elements will\n     * not be reordered as a result of the sort.\n     *\n     * <p>Implementation note: This implementation is a stable, adaptive,\n     * iterative mergesort that requires far fewer than n lg(n) comparisons\n     * when the input array is partially sorted, while offering the\n     * performance of a traditional mergesort when the input array is\n     * randomly ordered.  If the input array is nearly sorted, the\n     * implementation requires approximately n comparisons.  Temporary\n     * storage requirements vary from a small constant for nearly sorted\n     * input arrays to n/2 object references for randomly ordered input\n     * arrays.\n     *\n     * <p>The implementation takes equal advantage of ascending and\n     * descending order in its input array, and can take advantage of\n     * ascending and descending order in different parts of the same\n     * input array.  It is well-suited to merging two or more sorted arrays:\n     * simply concatenate the arrays and sort the resulting array.\n     *\n     * <p>The implementation was adapted from Tim Peters's list sort for Python\n     * (<a href=\"http://svn.python.org/projects/python/trunk/Objects/listsort.txt\">\n     * TimSort</a>).  It uses techniques from Peter McIlroy's \"Optimistic\n     * Sorting and Information Theoretic Complexity\", in Proceedings of the\n     * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,\n     * January 1993.\n     *\n     * @param a the array to be sorted\n     * @throws ClassCastException if the array contains elements that are not\n     *         <i>mutually comparable</i> (for example, strings and integers)\n     * @throws IllegalArgumentException (optional) if the natural\n     *         ordering of the array elements is found to violate the\n     *         {@link Comparable} contract\n     ",
    "links" : [ "Comparable" ]
  }, {
    "name" : "public static void sort(Object[] a, int fromIndex, int toIndex)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified range of the specified array of objects into\n     * ascending order, according to the\n     * {@linkplain Comparable natural ordering} of its\n     * elements.  The range to be sorted extends from index\n     * {@code fromIndex}, inclusive, to index {@code toIndex}, exclusive.\n     * (If {@code fromIndex==toIndex}, the range to be sorted is empty.)  All\n     * elements in this range must implement the {@link Comparable}\n     * interface.  Furthermore, all elements in this range must be <i>mutually\n     * comparable</i> (that is, {@code e1.compareTo(e2)} must not throw a\n     * {@code ClassCastException} for any elements {@code e1} and\n     * {@code e2} in the array).\n     *\n     * <p>This sort is guaranteed to be <i>stable</i>:  equal elements will\n     * not be reordered as a result of the sort.\n     *\n     * <p>Implementation note: This implementation is a stable, adaptive,\n     * iterative mergesort that requires far fewer than n lg(n) comparisons\n     * when the input array is partially sorted, while offering the\n     * performance of a traditional mergesort when the input array is\n     * randomly ordered.  If the input array is nearly sorted, the\n     * implementation requires approximately n comparisons.  Temporary\n     * storage requirements vary from a small constant for nearly sorted\n     * input arrays to n/2 object references for randomly ordered input\n     * arrays.\n     *\n     * <p>The implementation takes equal advantage of ascending and\n     * descending order in its input array, and can take advantage of\n     * ascending and descending order in different parts of the same\n     * input array.  It is well-suited to merging two or more sorted arrays:\n     * simply concatenate the arrays and sort the resulting array.\n     *\n     * <p>The implementation was adapted from Tim Peters's list sort for Python\n     * (<a href=\"http://svn.python.org/projects/python/trunk/Objects/listsort.txt\">\n     * TimSort</a>).  It uses techniques from Peter McIlroy's \"Optimistic\n     * Sorting and Information Theoretic Complexity\", in Proceedings of the\n     * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,\n     * January 1993.\n     *\n     * @param a the array to be sorted\n     * @param fromIndex the index of the first element (inclusive) to be\n     *        sorted\n     * @param toIndex the index of the last element (exclusive) to be sorted\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex} or\n     *         (optional) if the natural ordering of the array elements is\n     *         found to violate the {@link Comparable} contract\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or\n     *         {@code toIndex > a.length}\n     * @throws ClassCastException if the array contains elements that are\n     *         not <i>mutually comparable</i> (for example, strings and\n     *         integers).\n     ",
    "links" : [ "Comparable" ]
  }, {
    "name" : "private static void mergeSort(Object[] src, Object[] dest, int low, int high, int off)",
    "returnType" : "void",
    "comment" : "\n     * Src is the source array that starts at index 0\n     * Dest is the (possibly larger) array destination with a possible offset\n     * low is the index in dest to start sorting\n     * high is the end index in dest to end sorting\n     * off is the offset to generate corresponding low, high in src\n     * To be removed in a future release.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void swap(Object[] x, int a, int b)",
    "returnType" : "void",
    "comment" : "\n     * Swaps x[a] with x[b].\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void sort(T[] a, Comparator<? super T> c)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified array of objects according to the order induced by\n     * the specified comparator.  All elements in the array must be\n     * <i>mutually comparable</i> by the specified comparator (that is,\n     * {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}\n     * for any elements {@code e1} and {@code e2} in the array).\n     *\n     * <p>This sort is guaranteed to be <i>stable</i>:  equal elements will\n     * not be reordered as a result of the sort.\n     *\n     * <p>Implementation note: This implementation is a stable, adaptive,\n     * iterative mergesort that requires far fewer than n lg(n) comparisons\n     * when the input array is partially sorted, while offering the\n     * performance of a traditional mergesort when the input array is\n     * randomly ordered.  If the input array is nearly sorted, the\n     * implementation requires approximately n comparisons.  Temporary\n     * storage requirements vary from a small constant for nearly sorted\n     * input arrays to n/2 object references for randomly ordered input\n     * arrays.\n     *\n     * <p>The implementation takes equal advantage of ascending and\n     * descending order in its input array, and can take advantage of\n     * ascending and descending order in different parts of the same\n     * input array.  It is well-suited to merging two or more sorted arrays:\n     * simply concatenate the arrays and sort the resulting array.\n     *\n     * <p>The implementation was adapted from Tim Peters's list sort for Python\n     * (<a href=\"http://svn.python.org/projects/python/trunk/Objects/listsort.txt\">\n     * TimSort</a>).  It uses techniques from Peter McIlroy's \"Optimistic\n     * Sorting and Information Theoretic Complexity\", in Proceedings of the\n     * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,\n     * January 1993.\n     *\n     * @param <T> the class of the objects to be sorted\n     * @param a the array to be sorted\n     * @param c the comparator to determine the order of the array.  A\n     *        {@code null} value indicates that the elements'\n     *        {@linkplain Comparable natural ordering} should be used.\n     * @throws ClassCastException if the array contains elements that are\n     *         not <i>mutually comparable</i> using the specified comparator\n     * @throws IllegalArgumentException (optional) if the comparator is\n     *         found to violate the {@link Comparator} contract\n     ",
    "links" : [ "java.util.Comparator" ]
  }, {
    "name" : "public static void sort(T[] a, int fromIndex, int toIndex, Comparator<? super T> c)",
    "returnType" : "void",
    "comment" : "\n     * Sorts the specified range of the specified array of objects according\n     * to the order induced by the specified comparator.  The range to be\n     * sorted extends from index {@code fromIndex}, inclusive, to index\n     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\n     * range to be sorted is empty.)  All elements in the range must be\n     * <i>mutually comparable</i> by the specified comparator (that is,\n     * {@code c.compare(e1, e2)} must not throw a {@code ClassCastException}\n     * for any elements {@code e1} and {@code e2} in the range).\n     *\n     * <p>This sort is guaranteed to be <i>stable</i>:  equal elements will\n     * not be reordered as a result of the sort.\n     *\n     * <p>Implementation note: This implementation is a stable, adaptive,\n     * iterative mergesort that requires far fewer than n lg(n) comparisons\n     * when the input array is partially sorted, while offering the\n     * performance of a traditional mergesort when the input array is\n     * randomly ordered.  If the input array is nearly sorted, the\n     * implementation requires approximately n comparisons.  Temporary\n     * storage requirements vary from a small constant for nearly sorted\n     * input arrays to n/2 object references for randomly ordered input\n     * arrays.\n     *\n     * <p>The implementation takes equal advantage of ascending and\n     * descending order in its input array, and can take advantage of\n     * ascending and descending order in different parts of the same\n     * input array.  It is well-suited to merging two or more sorted arrays:\n     * simply concatenate the arrays and sort the resulting array.\n     *\n     * <p>The implementation was adapted from Tim Peters's list sort for Python\n     * (<a href=\"http://svn.python.org/projects/python/trunk/Objects/listsort.txt\">\n     * TimSort</a>).  It uses techniques from Peter McIlroy's \"Optimistic\n     * Sorting and Information Theoretic Complexity\", in Proceedings of the\n     * Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,\n     * January 1993.\n     *\n     * @param <T> the class of the objects to be sorted\n     * @param a the array to be sorted\n     * @param fromIndex the index of the first element (inclusive) to be\n     *        sorted\n     * @param toIndex the index of the last element (exclusive) to be sorted\n     * @param c the comparator to determine the order of the array.  A\n     *        {@code null} value indicates that the elements'\n     *        {@linkplain Comparable natural ordering} should be used.\n     * @throws ClassCastException if the array contains elements that are not\n     *         <i>mutually comparable</i> using the specified comparator.\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex} or\n     *         (optional) if the comparator is found to violate the\n     *         {@link Comparator} contract\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or\n     *         {@code toIndex > a.length}\n     ",
    "links" : [ "java.util.Comparator" ]
  }, {
    "name" : "public static void parallelPrefix(T[] array, BinaryOperator<T> op)",
    "returnType" : "void",
    "comment" : "\n     * Cumulates, in parallel, each element of the given array in place,\n     * using the supplied function. For example if the array initially\n     * holds {@code [2, 1, 0, 3]} and the operation performs addition,\n     * then upon return the array holds {@code [2, 3, 3, 6]}.\n     * Parallel prefix computation is usually more efficient than\n     * sequential loops for large arrays.\n     *\n     * @param <T> the class of the objects in the array\n     * @param array the array, which is modified in-place by this method\n     * @param op a side-effect-free, associative function to perform the\n     * cumulation\n     * @throws NullPointerException if the specified array or function is null\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void parallelPrefix(T[] array, int fromIndex, int toIndex, BinaryOperator<T> op)",
    "returnType" : "void",
    "comment" : "\n     * Performs {@link #parallelPrefix(Object[], BinaryOperator)}\n     * for the given subrange of the array.\n     *\n     * @param <T> the class of the objects in the array\n     * @param array the array\n     * @param fromIndex the index of the first element, inclusive\n     * @param toIndex the index of the last element, exclusive\n     * @param op a side-effect-free, associative function to perform the\n     * cumulation\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *     if {@code fromIndex < 0} or {@code toIndex > array.length}\n     * @throws NullPointerException if the specified array or function is null\n     * @since 1.8\n     ",
    "links" : [ "#parallelPrefix(Object" ]
  }, {
    "name" : "public static void parallelPrefix(long[] array, LongBinaryOperator op)",
    "returnType" : "void",
    "comment" : "\n     * Cumulates, in parallel, each element of the given array in place,\n     * using the supplied function. For example if the array initially\n     * holds {@code [2, 1, 0, 3]} and the operation performs addition,\n     * then upon return the array holds {@code [2, 3, 3, 6]}.\n     * Parallel prefix computation is usually more efficient than\n     * sequential loops for large arrays.\n     *\n     * @param array the array, which is modified in-place by this method\n     * @param op a side-effect-free, associative function to perform the\n     * cumulation\n     * @throws NullPointerException if the specified array or function is null\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void parallelPrefix(long[] array, int fromIndex, int toIndex, LongBinaryOperator op)",
    "returnType" : "void",
    "comment" : "\n     * Performs {@link #parallelPrefix(long[], LongBinaryOperator)}\n     * for the given subrange of the array.\n     *\n     * @param array the array\n     * @param fromIndex the index of the first element, inclusive\n     * @param toIndex the index of the last element, exclusive\n     * @param op a side-effect-free, associative function to perform the\n     * cumulation\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *     if {@code fromIndex < 0} or {@code toIndex > array.length}\n     * @throws NullPointerException if the specified array or function is null\n     * @since 1.8\n     ",
    "links" : [ "#parallelPrefix(long" ]
  }, {
    "name" : "public static void parallelPrefix(double[] array, DoubleBinaryOperator op)",
    "returnType" : "void",
    "comment" : "\n     * Cumulates, in parallel, each element of the given array in place,\n     * using the supplied function. For example if the array initially\n     * holds {@code [2.0, 1.0, 0.0, 3.0]} and the operation performs addition,\n     * then upon return the array holds {@code [2.0, 3.0, 3.0, 6.0]}.\n     * Parallel prefix computation is usually more efficient than\n     * sequential loops for large arrays.\n     *\n     * <p> Because floating-point operations may not be strictly associative,\n     * the returned result may not be identical to the value that would be\n     * obtained if the operation was performed sequentially.\n     *\n     * @param array the array, which is modified in-place by this method\n     * @param op a side-effect-free function to perform the cumulation\n     * @throws NullPointerException if the specified array or function is null\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void parallelPrefix(double[] array, int fromIndex, int toIndex, DoubleBinaryOperator op)",
    "returnType" : "void",
    "comment" : "\n     * Performs {@link #parallelPrefix(double[], DoubleBinaryOperator)}\n     * for the given subrange of the array.\n     *\n     * @param array the array\n     * @param fromIndex the index of the first element, inclusive\n     * @param toIndex the index of the last element, exclusive\n     * @param op a side-effect-free, associative function to perform the\n     * cumulation\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *     if {@code fromIndex < 0} or {@code toIndex > array.length}\n     * @throws NullPointerException if the specified array or function is null\n     * @since 1.8\n     ",
    "links" : [ "#parallelPrefix(double" ]
  }, {
    "name" : "public static void parallelPrefix(int[] array, IntBinaryOperator op)",
    "returnType" : "void",
    "comment" : "\n     * Cumulates, in parallel, each element of the given array in place,\n     * using the supplied function. For example if the array initially\n     * holds {@code [2, 1, 0, 3]} and the operation performs addition,\n     * then upon return the array holds {@code [2, 3, 3, 6]}.\n     * Parallel prefix computation is usually more efficient than\n     * sequential loops for large arrays.\n     *\n     * @param array the array, which is modified in-place by this method\n     * @param op a side-effect-free, associative function to perform the\n     * cumulation\n     * @throws NullPointerException if the specified array or function is null\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void parallelPrefix(int[] array, int fromIndex, int toIndex, IntBinaryOperator op)",
    "returnType" : "void",
    "comment" : "\n     * Performs {@link #parallelPrefix(int[], IntBinaryOperator)}\n     * for the given subrange of the array.\n     *\n     * @param array the array\n     * @param fromIndex the index of the first element, inclusive\n     * @param toIndex the index of the last element, exclusive\n     * @param op a side-effect-free, associative function to perform the\n     * cumulation\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *     if {@code fromIndex < 0} or {@code toIndex > array.length}\n     * @throws NullPointerException if the specified array or function is null\n     * @since 1.8\n     ",
    "links" : [ "#parallelPrefix(int" ]
  }, {
    "name" : "public static int binarySearch(long[] a, long key)",
    "returnType" : "int",
    "comment" : "\n     * Searches the specified array of longs for the specified value using the\n     * binary search algorithm.  The array must be sorted (as\n     * by the {@link #sort(long[])} method) prior to making this call.  If it\n     * is not sorted, the results are undefined.  If the array contains\n     * multiple elements with the specified value, there is no guarantee which\n     * one will be found.\n     *\n     * @param a the array to be searched\n     * @param key the value to be searched for\n     * @return index of the search key, if it is contained in the array;\n     *         otherwise, <code>(-(<i>insertion point</i>) - 1)</code>.  The\n     *         <i>insertion point</i> is defined as the point at which the\n     *         key would be inserted into the array: the index of the first\n     *         element greater than the key, or {@code a.length} if all\n     *         elements in the array are less than the specified key.  Note\n     *         that this guarantees that the return value will be &gt;= 0 if\n     *         and only if the key is found.\n     ",
    "links" : [ "#sort(long" ]
  }, {
    "name" : "public static int binarySearch(long[] a, int fromIndex, int toIndex, long key)",
    "returnType" : "int",
    "comment" : "\n     * Searches a range of\n     * the specified array of longs for the specified value using the\n     * binary search algorithm.\n     * The range must be sorted (as\n     * by the {@link #sort(long[], int, int)} method)\n     * prior to making this call.  If it\n     * is not sorted, the results are undefined.  If the range contains\n     * multiple elements with the specified value, there is no guarantee which\n     * one will be found.\n     *\n     * @param a the array to be searched\n     * @param fromIndex the index of the first element (inclusive) to be\n     *          searched\n     * @param toIndex the index of the last element (exclusive) to be searched\n     * @param key the value to be searched for\n     * @return index of the search key, if it is contained in the array\n     *         within the specified range;\n     *         otherwise, <code>(-(<i>insertion point</i>) - 1)</code>.  The\n     *         <i>insertion point</i> is defined as the point at which the\n     *         key would be inserted into the array: the index of the first\n     *         element in the range greater than the key,\n     *         or {@code toIndex} if all\n     *         elements in the range are less than the specified key.  Note\n     *         that this guarantees that the return value will be &gt;= 0 if\n     *         and only if the key is found.\n     * @throws IllegalArgumentException\n     *         if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code fromIndex < 0 or toIndex > a.length}\n     * @since 1.6\n     ",
    "links" : [ "#sort(long" ]
  }, {
    "name" : "private static int binarySearch0(long[] a, int fromIndex, int toIndex, long key)",
    "returnType" : "int",
    "comment" : " Like public version, but without range checks.",
    "links" : [ ]
  }, {
    "name" : "public static int binarySearch(int[] a, int key)",
    "returnType" : "int",
    "comment" : "\n     * Searches the specified array of ints for the specified value using the\n     * binary search algorithm.  The array must be sorted (as\n     * by the {@link #sort(int[])} method) prior to making this call.  If it\n     * is not sorted, the results are undefined.  If the array contains\n     * multiple elements with the specified value, there is no guarantee which\n     * one will be found.\n     *\n     * @param a the array to be searched\n     * @param key the value to be searched for\n     * @return index of the search key, if it is contained in the array;\n     *         otherwise, <code>(-(<i>insertion point</i>) - 1)</code>.  The\n     *         <i>insertion point</i> is defined as the point at which the\n     *         key would be inserted into the array: the index of the first\n     *         element greater than the key, or {@code a.length} if all\n     *         elements in the array are less than the specified key.  Note\n     *         that this guarantees that the return value will be &gt;= 0 if\n     *         and only if the key is found.\n     ",
    "links" : [ "#sort(int" ]
  }, {
    "name" : "public static int binarySearch(int[] a, int fromIndex, int toIndex, int key)",
    "returnType" : "int",
    "comment" : "\n     * Searches a range of\n     * the specified array of ints for the specified value using the\n     * binary search algorithm.\n     * The range must be sorted (as\n     * by the {@link #sort(int[], int, int)} method)\n     * prior to making this call.  If it\n     * is not sorted, the results are undefined.  If the range contains\n     * multiple elements with the specified value, there is no guarantee which\n     * one will be found.\n     *\n     * @param a the array to be searched\n     * @param fromIndex the index of the first element (inclusive) to be\n     *          searched\n     * @param toIndex the index of the last element (exclusive) to be searched\n     * @param key the value to be searched for\n     * @return index of the search key, if it is contained in the array\n     *         within the specified range;\n     *         otherwise, <code>(-(<i>insertion point</i>) - 1)</code>.  The\n     *         <i>insertion point</i> is defined as the point at which the\n     *         key would be inserted into the array: the index of the first\n     *         element in the range greater than the key,\n     *         or {@code toIndex} if all\n     *         elements in the range are less than the specified key.  Note\n     *         that this guarantees that the return value will be &gt;= 0 if\n     *         and only if the key is found.\n     * @throws IllegalArgumentException\n     *         if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code fromIndex < 0 or toIndex > a.length}\n     * @since 1.6\n     ",
    "links" : [ "#sort(int" ]
  }, {
    "name" : "private static int binarySearch0(int[] a, int fromIndex, int toIndex, int key)",
    "returnType" : "int",
    "comment" : " Like public version, but without range checks.",
    "links" : [ ]
  }, {
    "name" : "public static int binarySearch(short[] a, short key)",
    "returnType" : "int",
    "comment" : "\n     * Searches the specified array of shorts for the specified value using\n     * the binary search algorithm.  The array must be sorted\n     * (as by the {@link #sort(short[])} method) prior to making this call.  If\n     * it is not sorted, the results are undefined.  If the array contains\n     * multiple elements with the specified value, there is no guarantee which\n     * one will be found.\n     *\n     * @param a the array to be searched\n     * @param key the value to be searched for\n     * @return index of the search key, if it is contained in the array;\n     *         otherwise, <code>(-(<i>insertion point</i>) - 1)</code>.  The\n     *         <i>insertion point</i> is defined as the point at which the\n     *         key would be inserted into the array: the index of the first\n     *         element greater than the key, or {@code a.length} if all\n     *         elements in the array are less than the specified key.  Note\n     *         that this guarantees that the return value will be &gt;= 0 if\n     *         and only if the key is found.\n     ",
    "links" : [ "#sort(short" ]
  }, {
    "name" : "public static int binarySearch(short[] a, int fromIndex, int toIndex, short key)",
    "returnType" : "int",
    "comment" : "\n     * Searches a range of\n     * the specified array of shorts for the specified value using\n     * the binary search algorithm.\n     * The range must be sorted\n     * (as by the {@link #sort(short[], int, int)} method)\n     * prior to making this call.  If\n     * it is not sorted, the results are undefined.  If the range contains\n     * multiple elements with the specified value, there is no guarantee which\n     * one will be found.\n     *\n     * @param a the array to be searched\n     * @param fromIndex the index of the first element (inclusive) to be\n     *          searched\n     * @param toIndex the index of the last element (exclusive) to be searched\n     * @param key the value to be searched for\n     * @return index of the search key, if it is contained in the array\n     *         within the specified range;\n     *         otherwise, <code>(-(<i>insertion point</i>) - 1)</code>.  The\n     *         <i>insertion point</i> is defined as the point at which the\n     *         key would be inserted into the array: the index of the first\n     *         element in the range greater than the key,\n     *         or {@code toIndex} if all\n     *         elements in the range are less than the specified key.  Note\n     *         that this guarantees that the return value will be &gt;= 0 if\n     *         and only if the key is found.\n     * @throws IllegalArgumentException\n     *         if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code fromIndex < 0 or toIndex > a.length}\n     * @since 1.6\n     ",
    "links" : [ "#sort(short" ]
  }, {
    "name" : "private static int binarySearch0(short[] a, int fromIndex, int toIndex, short key)",
    "returnType" : "int",
    "comment" : " Like public version, but without range checks.",
    "links" : [ ]
  }, {
    "name" : "public static int binarySearch(char[] a, char key)",
    "returnType" : "int",
    "comment" : "\n     * Searches the specified array of chars for the specified value using the\n     * binary search algorithm.  The array must be sorted (as\n     * by the {@link #sort(char[])} method) prior to making this call.  If it\n     * is not sorted, the results are undefined.  If the array contains\n     * multiple elements with the specified value, there is no guarantee which\n     * one will be found.\n     *\n     * @param a the array to be searched\n     * @param key the value to be searched for\n     * @return index of the search key, if it is contained in the array;\n     *         otherwise, <code>(-(<i>insertion point</i>) - 1)</code>.  The\n     *         <i>insertion point</i> is defined as the point at which the\n     *         key would be inserted into the array: the index of the first\n     *         element greater than the key, or {@code a.length} if all\n     *         elements in the array are less than the specified key.  Note\n     *         that this guarantees that the return value will be &gt;= 0 if\n     *         and only if the key is found.\n     ",
    "links" : [ "#sort(char" ]
  }, {
    "name" : "public static int binarySearch(char[] a, int fromIndex, int toIndex, char key)",
    "returnType" : "int",
    "comment" : "\n     * Searches a range of\n     * the specified array of chars for the specified value using the\n     * binary search algorithm.\n     * The range must be sorted (as\n     * by the {@link #sort(char[], int, int)} method)\n     * prior to making this call.  If it\n     * is not sorted, the results are undefined.  If the range contains\n     * multiple elements with the specified value, there is no guarantee which\n     * one will be found.\n     *\n     * @param a the array to be searched\n     * @param fromIndex the index of the first element (inclusive) to be\n     *          searched\n     * @param toIndex the index of the last element (exclusive) to be searched\n     * @param key the value to be searched for\n     * @return index of the search key, if it is contained in the array\n     *         within the specified range;\n     *         otherwise, <code>(-(<i>insertion point</i>) - 1)</code>.  The\n     *         <i>insertion point</i> is defined as the point at which the\n     *         key would be inserted into the array: the index of the first\n     *         element in the range greater than the key,\n     *         or {@code toIndex} if all\n     *         elements in the range are less than the specified key.  Note\n     *         that this guarantees that the return value will be &gt;= 0 if\n     *         and only if the key is found.\n     * @throws IllegalArgumentException\n     *         if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code fromIndex < 0 or toIndex > a.length}\n     * @since 1.6\n     ",
    "links" : [ "#sort(char" ]
  }, {
    "name" : "private static int binarySearch0(char[] a, int fromIndex, int toIndex, char key)",
    "returnType" : "int",
    "comment" : " Like public version, but without range checks.",
    "links" : [ ]
  }, {
    "name" : "public static int binarySearch(byte[] a, byte key)",
    "returnType" : "int",
    "comment" : "\n     * Searches the specified array of bytes for the specified value using the\n     * binary search algorithm.  The array must be sorted (as\n     * by the {@link #sort(byte[])} method) prior to making this call.  If it\n     * is not sorted, the results are undefined.  If the array contains\n     * multiple elements with the specified value, there is no guarantee which\n     * one will be found.\n     *\n     * @param a the array to be searched\n     * @param key the value to be searched for\n     * @return index of the search key, if it is contained in the array;\n     *         otherwise, <code>(-(<i>insertion point</i>) - 1)</code>.  The\n     *         <i>insertion point</i> is defined as the point at which the\n     *         key would be inserted into the array: the index of the first\n     *         element greater than the key, or {@code a.length} if all\n     *         elements in the array are less than the specified key.  Note\n     *         that this guarantees that the return value will be &gt;= 0 if\n     *         and only if the key is found.\n     ",
    "links" : [ "#sort(byte" ]
  }, {
    "name" : "public static int binarySearch(byte[] a, int fromIndex, int toIndex, byte key)",
    "returnType" : "int",
    "comment" : "\n     * Searches a range of\n     * the specified array of bytes for the specified value using the\n     * binary search algorithm.\n     * The range must be sorted (as\n     * by the {@link #sort(byte[], int, int)} method)\n     * prior to making this call.  If it\n     * is not sorted, the results are undefined.  If the range contains\n     * multiple elements with the specified value, there is no guarantee which\n     * one will be found.\n     *\n     * @param a the array to be searched\n     * @param fromIndex the index of the first element (inclusive) to be\n     *          searched\n     * @param toIndex the index of the last element (exclusive) to be searched\n     * @param key the value to be searched for\n     * @return index of the search key, if it is contained in the array\n     *         within the specified range;\n     *         otherwise, <code>(-(<i>insertion point</i>) - 1)</code>.  The\n     *         <i>insertion point</i> is defined as the point at which the\n     *         key would be inserted into the array: the index of the first\n     *         element in the range greater than the key,\n     *         or {@code toIndex} if all\n     *         elements in the range are less than the specified key.  Note\n     *         that this guarantees that the return value will be &gt;= 0 if\n     *         and only if the key is found.\n     * @throws IllegalArgumentException\n     *         if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code fromIndex < 0 or toIndex > a.length}\n     * @since 1.6\n     ",
    "links" : [ "#sort(byte" ]
  }, {
    "name" : "private static int binarySearch0(byte[] a, int fromIndex, int toIndex, byte key)",
    "returnType" : "int",
    "comment" : " Like public version, but without range checks.",
    "links" : [ ]
  }, {
    "name" : "public static int binarySearch(double[] a, double key)",
    "returnType" : "int",
    "comment" : "\n     * Searches the specified array of doubles for the specified value using\n     * the binary search algorithm.  The array must be sorted\n     * (as by the {@link #sort(double[])} method) prior to making this call.\n     * If it is not sorted, the results are undefined.  If the array contains\n     * multiple elements with the specified value, there is no guarantee which\n     * one will be found.  This method considers all NaN values to be\n     * equivalent and equal.\n     *\n     * @param a the array to be searched\n     * @param key the value to be searched for\n     * @return index of the search key, if it is contained in the array;\n     *         otherwise, <code>(-(<i>insertion point</i>) - 1)</code>.  The\n     *         <i>insertion point</i> is defined as the point at which the\n     *         key would be inserted into the array: the index of the first\n     *         element greater than the key, or {@code a.length} if all\n     *         elements in the array are less than the specified key.  Note\n     *         that this guarantees that the return value will be &gt;= 0 if\n     *         and only if the key is found.\n     ",
    "links" : [ "#sort(double" ]
  }, {
    "name" : "public static int binarySearch(double[] a, int fromIndex, int toIndex, double key)",
    "returnType" : "int",
    "comment" : "\n     * Searches a range of\n     * the specified array of doubles for the specified value using\n     * the binary search algorithm.\n     * The range must be sorted\n     * (as by the {@link #sort(double[], int, int)} method)\n     * prior to making this call.\n     * If it is not sorted, the results are undefined.  If the range contains\n     * multiple elements with the specified value, there is no guarantee which\n     * one will be found.  This method considers all NaN values to be\n     * equivalent and equal.\n     *\n     * @param a the array to be searched\n     * @param fromIndex the index of the first element (inclusive) to be\n     *          searched\n     * @param toIndex the index of the last element (exclusive) to be searched\n     * @param key the value to be searched for\n     * @return index of the search key, if it is contained in the array\n     *         within the specified range;\n     *         otherwise, <code>(-(<i>insertion point</i>) - 1)</code>.  The\n     *         <i>insertion point</i> is defined as the point at which the\n     *         key would be inserted into the array: the index of the first\n     *         element in the range greater than the key,\n     *         or {@code toIndex} if all\n     *         elements in the range are less than the specified key.  Note\n     *         that this guarantees that the return value will be &gt;= 0 if\n     *         and only if the key is found.\n     * @throws IllegalArgumentException\n     *         if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code fromIndex < 0 or toIndex > a.length}\n     * @since 1.6\n     ",
    "links" : [ "#sort(double" ]
  }, {
    "name" : "private static int binarySearch0(double[] a, int fromIndex, int toIndex, double key)",
    "returnType" : "int",
    "comment" : " Like public version, but without range checks.",
    "links" : [ ]
  }, {
    "name" : "public static int binarySearch(float[] a, float key)",
    "returnType" : "int",
    "comment" : "\n     * Searches the specified array of floats for the specified value using\n     * the binary search algorithm. The array must be sorted\n     * (as by the {@link #sort(float[])} method) prior to making this call. If\n     * it is not sorted, the results are undefined. If the array contains\n     * multiple elements with the specified value, there is no guarantee which\n     * one will be found. This method considers all NaN values to be\n     * equivalent and equal.\n     *\n     * @param a the array to be searched\n     * @param key the value to be searched for\n     * @return index of the search key, if it is contained in the array;\n     *         otherwise, <code>(-(<i>insertion point</i>) - 1)</code>. The\n     *         <i>insertion point</i> is defined as the point at which the\n     *         key would be inserted into the array: the index of the first\n     *         element greater than the key, or {@code a.length} if all\n     *         elements in the array are less than the specified key. Note\n     *         that this guarantees that the return value will be &gt;= 0 if\n     *         and only if the key is found.\n     ",
    "links" : [ "#sort(float" ]
  }, {
    "name" : "public static int binarySearch(float[] a, int fromIndex, int toIndex, float key)",
    "returnType" : "int",
    "comment" : "\n     * Searches a range of\n     * the specified array of floats for the specified value using\n     * the binary search algorithm.\n     * The range must be sorted\n     * (as by the {@link #sort(float[], int, int)} method)\n     * prior to making this call. If\n     * it is not sorted, the results are undefined. If the range contains\n     * multiple elements with the specified value, there is no guarantee which\n     * one will be found. This method considers all NaN values to be\n     * equivalent and equal.\n     *\n     * @param a the array to be searched\n     * @param fromIndex the index of the first element (inclusive) to be\n     *          searched\n     * @param toIndex the index of the last element (exclusive) to be searched\n     * @param key the value to be searched for\n     * @return index of the search key, if it is contained in the array\n     *         within the specified range;\n     *         otherwise, <code>(-(<i>insertion point</i>) - 1)</code>. The\n     *         <i>insertion point</i> is defined as the point at which the\n     *         key would be inserted into the array: the index of the first\n     *         element in the range greater than the key,\n     *         or {@code toIndex} if all\n     *         elements in the range are less than the specified key. Note\n     *         that this guarantees that the return value will be &gt;= 0 if\n     *         and only if the key is found.\n     * @throws IllegalArgumentException\n     *         if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code fromIndex < 0 or toIndex > a.length}\n     * @since 1.6\n     ",
    "links" : [ "#sort(float" ]
  }, {
    "name" : "private static int binarySearch0(float[] a, int fromIndex, int toIndex, float key)",
    "returnType" : "int",
    "comment" : " Like public version, but without range checks.",
    "links" : [ ]
  }, {
    "name" : "public static int binarySearch(Object[] a, Object key)",
    "returnType" : "int",
    "comment" : "\n     * Searches the specified array for the specified object using the binary\n     * search algorithm. The array must be sorted into ascending order\n     * according to the\n     * {@linkplain Comparable natural ordering}\n     * of its elements (as by the\n     * {@link #sort(Object[])} method) prior to making this call.\n     * If it is not sorted, the results are undefined.\n     * (If the array contains elements that are not mutually comparable (for\n     * example, strings and integers), it <i>cannot</i> be sorted according\n     * to the natural ordering of its elements, hence results are undefined.)\n     * If the array contains multiple\n     * elements equal to the specified object, there is no guarantee which\n     * one will be found.\n     *\n     * @param a the array to be searched\n     * @param key the value to be searched for\n     * @return index of the search key, if it is contained in the array;\n     *         otherwise, <code>(-(<i>insertion point</i>) - 1)</code>.  The\n     *         <i>insertion point</i> is defined as the point at which the\n     *         key would be inserted into the array: the index of the first\n     *         element greater than the key, or {@code a.length} if all\n     *         elements in the array are less than the specified key.  Note\n     *         that this guarantees that the return value will be &gt;= 0 if\n     *         and only if the key is found.\n     * @throws ClassCastException if the search key is not comparable to the\n     *         elements of the array.\n     ",
    "links" : [ "#sort(Object" ]
  }, {
    "name" : "public static int binarySearch(Object[] a, int fromIndex, int toIndex, Object key)",
    "returnType" : "int",
    "comment" : "\n     * Searches a range of\n     * the specified array for the specified object using the binary\n     * search algorithm.\n     * The range must be sorted into ascending order\n     * according to the\n     * {@linkplain Comparable natural ordering}\n     * of its elements (as by the\n     * {@link #sort(Object[], int, int)} method) prior to making this\n     * call.  If it is not sorted, the results are undefined.\n     * (If the range contains elements that are not mutually comparable (for\n     * example, strings and integers), it <i>cannot</i> be sorted according\n     * to the natural ordering of its elements, hence results are undefined.)\n     * If the range contains multiple\n     * elements equal to the specified object, there is no guarantee which\n     * one will be found.\n     *\n     * @param a the array to be searched\n     * @param fromIndex the index of the first element (inclusive) to be\n     *          searched\n     * @param toIndex the index of the last element (exclusive) to be searched\n     * @param key the value to be searched for\n     * @return index of the search key, if it is contained in the array\n     *         within the specified range;\n     *         otherwise, <code>(-(<i>insertion point</i>) - 1)</code>.  The\n     *         <i>insertion point</i> is defined as the point at which the\n     *         key would be inserted into the array: the index of the first\n     *         element in the range greater than the key,\n     *         or {@code toIndex} if all\n     *         elements in the range are less than the specified key.  Note\n     *         that this guarantees that the return value will be &gt;= 0 if\n     *         and only if the key is found.\n     * @throws ClassCastException if the search key is not comparable to the\n     *         elements of the array within the specified range.\n     * @throws IllegalArgumentException\n     *         if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code fromIndex < 0 or toIndex > a.length}\n     * @since 1.6\n     ",
    "links" : [ "#sort(Object" ]
  }, {
    "name" : "private static int binarySearch0(Object[] a, int fromIndex, int toIndex, Object key)",
    "returnType" : "int",
    "comment" : " Like public version, but without range checks.",
    "links" : [ ]
  }, {
    "name" : "public static int binarySearch(T[] a, T key, Comparator<? super T> c)",
    "returnType" : "int",
    "comment" : "\n     * Searches the specified array for the specified object using the binary\n     * search algorithm.  The array must be sorted into ascending order\n     * according to the specified comparator (as by the\n     * {@link #sort(Object[], Comparator) sort(T[], Comparator)}\n     * method) prior to making this call.  If it is\n     * not sorted, the results are undefined.\n     * If the array contains multiple\n     * elements equal to the specified object, there is no guarantee which one\n     * will be found.\n     *\n     * @param <T> the class of the objects in the array\n     * @param a the array to be searched\n     * @param key the value to be searched for\n     * @param c the comparator by which the array is ordered.  A\n     *        {@code null} value indicates that the elements'\n     *        {@linkplain Comparable natural ordering} should be used.\n     * @return index of the search key, if it is contained in the array;\n     *         otherwise, <code>(-(<i>insertion point</i>) - 1)</code>.  The\n     *         <i>insertion point</i> is defined as the point at which the\n     *         key would be inserted into the array: the index of the first\n     *         element greater than the key, or {@code a.length} if all\n     *         elements in the array are less than the specified key.  Note\n     *         that this guarantees that the return value will be &gt;= 0 if\n     *         and only if the key is found.\n     * @throws ClassCastException if the array contains elements that are not\n     *         <i>mutually comparable</i> using the specified comparator,\n     *         or the search key is not comparable to the\n     *         elements of the array using this comparator.\n     ",
    "links" : [ "#sort(Object" ]
  }, {
    "name" : "public static int binarySearch(T[] a, int fromIndex, int toIndex, T key, Comparator<? super T> c)",
    "returnType" : "int",
    "comment" : "\n     * Searches a range of\n     * the specified array for the specified object using the binary\n     * search algorithm.\n     * The range must be sorted into ascending order\n     * according to the specified comparator (as by the\n     * {@link #sort(Object[], int, int, Comparator)\n     * sort(T[], int, int, Comparator)}\n     * method) prior to making this call.\n     * If it is not sorted, the results are undefined.\n     * If the range contains multiple elements equal to the specified object,\n     * there is no guarantee which one will be found.\n     *\n     * @param <T> the class of the objects in the array\n     * @param a the array to be searched\n     * @param fromIndex the index of the first element (inclusive) to be\n     *          searched\n     * @param toIndex the index of the last element (exclusive) to be searched\n     * @param key the value to be searched for\n     * @param c the comparator by which the array is ordered.  A\n     *        {@code null} value indicates that the elements'\n     *        {@linkplain Comparable natural ordering} should be used.\n     * @return index of the search key, if it is contained in the array\n     *         within the specified range;\n     *         otherwise, <code>(-(<i>insertion point</i>) - 1)</code>.  The\n     *         <i>insertion point</i> is defined as the point at which the\n     *         key would be inserted into the array: the index of the first\n     *         element in the range greater than the key,\n     *         or {@code toIndex} if all\n     *         elements in the range are less than the specified key.  Note\n     *         that this guarantees that the return value will be &gt;= 0 if\n     *         and only if the key is found.\n     * @throws ClassCastException if the range contains elements that are not\n     *         <i>mutually comparable</i> using the specified comparator,\n     *         or the search key is not comparable to the\n     *         elements in the range using this comparator.\n     * @throws IllegalArgumentException\n     *         if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code fromIndex < 0 or toIndex > a.length}\n     * @since 1.6\n     ",
    "links" : [ "#sort(Object" ]
  }, {
    "name" : "private static int binarySearch0(T[] a, int fromIndex, int toIndex, T key, Comparator<? super T> c)",
    "returnType" : "int",
    "comment" : " Like public version, but without range checks.",
    "links" : [ ]
  }, {
    "name" : "public static boolean equals(long[] a, long[] a2)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the two specified arrays of longs are\n     * <i>equal</i> to one another.  Two arrays are considered equal if both\n     * arrays contain the same number of elements, and all corresponding pairs\n     * of elements in the two arrays are equal.  In other words, two arrays\n     * are equal if they contain the same elements in the same order.  Also,\n     * two array references are considered equal if both are {@code null}.\n     *\n     * @param a one array to be tested for equality\n     * @param a2 the other array to be tested for equality\n     * @return {@code true} if the two arrays are equal\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean equals(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the two specified arrays of longs, over the specified\n     * ranges, are <i>equal</i> to one another.\n     *\n     * <p>Two arrays are considered equal if the number of elements covered by\n     * each range is the same, and all corresponding pairs of elements over the\n     * specified ranges in the two arrays are equal.  In other words, two arrays\n     * are equal if they contain, over the specified ranges, the same elements\n     * in the same order.\n     *\n     * @param a the first array to be tested for equality\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be tested\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be tested\n     * @param b the second array to be tested for equality\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be tested\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be tested\n     * @return {@code true} if the two arrays, over the specified ranges, are\n     *         equal\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean equals(int[] a, int[] a2)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the two specified arrays of ints are\n     * <i>equal</i> to one another.  Two arrays are considered equal if both\n     * arrays contain the same number of elements, and all corresponding pairs\n     * of elements in the two arrays are equal.  In other words, two arrays\n     * are equal if they contain the same elements in the same order.  Also,\n     * two array references are considered equal if both are {@code null}.\n     *\n     * @param a one array to be tested for equality\n     * @param a2 the other array to be tested for equality\n     * @return {@code true} if the two arrays are equal\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean equals(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the two specified arrays of ints, over the specified\n     * ranges, are <i>equal</i> to one another.\n     *\n     * <p>Two arrays are considered equal if the number of elements covered by\n     * each range is the same, and all corresponding pairs of elements over the\n     * specified ranges in the two arrays are equal.  In other words, two arrays\n     * are equal if they contain, over the specified ranges, the same elements\n     * in the same order.\n     *\n     * @param a the first array to be tested for equality\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be tested\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be tested\n     * @param b the second array to be tested for equality\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be tested\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be tested\n     * @return {@code true} if the two arrays, over the specified ranges, are\n     *         equal\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean equals(short[] a, short[] a2)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the two specified arrays of shorts are\n     * <i>equal</i> to one another.  Two arrays are considered equal if both\n     * arrays contain the same number of elements, and all corresponding pairs\n     * of elements in the two arrays are equal.  In other words, two arrays\n     * are equal if they contain the same elements in the same order.  Also,\n     * two array references are considered equal if both are {@code null}.\n     *\n     * @param a one array to be tested for equality\n     * @param a2 the other array to be tested for equality\n     * @return {@code true} if the two arrays are equal\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean equals(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the two specified arrays of shorts, over the specified\n     * ranges, are <i>equal</i> to one another.\n     *\n     * <p>Two arrays are considered equal if the number of elements covered by\n     * each range is the same, and all corresponding pairs of elements over the\n     * specified ranges in the two arrays are equal.  In other words, two arrays\n     * are equal if they contain, over the specified ranges, the same elements\n     * in the same order.\n     *\n     * @param a the first array to be tested for equality\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be tested\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be tested\n     * @param b the second array to be tested for equality\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be tested\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be tested\n     * @return {@code true} if the two arrays, over the specified ranges, are\n     *         equal\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean equals(char[] a, char[] a2)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the two specified arrays of chars are\n     * <i>equal</i> to one another.  Two arrays are considered equal if both\n     * arrays contain the same number of elements, and all corresponding pairs\n     * of elements in the two arrays are equal.  In other words, two arrays\n     * are equal if they contain the same elements in the same order.  Also,\n     * two array references are considered equal if both are {@code null}.\n     *\n     * @param a one array to be tested for equality\n     * @param a2 the other array to be tested for equality\n     * @return {@code true} if the two arrays are equal\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean equals(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the two specified arrays of chars, over the specified\n     * ranges, are <i>equal</i> to one another.\n     *\n     * <p>Two arrays are considered equal if the number of elements covered by\n     * each range is the same, and all corresponding pairs of elements over the\n     * specified ranges in the two arrays are equal.  In other words, two arrays\n     * are equal if they contain, over the specified ranges, the same elements\n     * in the same order.\n     *\n     * @param a the first array to be tested for equality\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be tested\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be tested\n     * @param b the second array to be tested for equality\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be tested\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be tested\n     * @return {@code true} if the two arrays, over the specified ranges, are\n     *         equal\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean equals(byte[] a, byte[] a2)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the two specified arrays of bytes are\n     * <i>equal</i> to one another.  Two arrays are considered equal if both\n     * arrays contain the same number of elements, and all corresponding pairs\n     * of elements in the two arrays are equal.  In other words, two arrays\n     * are equal if they contain the same elements in the same order.  Also,\n     * two array references are considered equal if both are {@code null}.\n     *\n     * @param a one array to be tested for equality\n     * @param a2 the other array to be tested for equality\n     * @return {@code true} if the two arrays are equal\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean equals(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the two specified arrays of bytes, over the specified\n     * ranges, are <i>equal</i> to one another.\n     *\n     * <p>Two arrays are considered equal if the number of elements covered by\n     * each range is the same, and all corresponding pairs of elements over the\n     * specified ranges in the two arrays are equal.  In other words, two arrays\n     * are equal if they contain, over the specified ranges, the same elements\n     * in the same order.\n     *\n     * @param a the first array to be tested for equality\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be tested\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be tested\n     * @param b the second array to be tested for equality\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be tested\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be tested\n     * @return {@code true} if the two arrays, over the specified ranges, are\n     *         equal\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean equals(boolean[] a, boolean[] a2)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the two specified arrays of booleans are\n     * <i>equal</i> to one another.  Two arrays are considered equal if both\n     * arrays contain the same number of elements, and all corresponding pairs\n     * of elements in the two arrays are equal.  In other words, two arrays\n     * are equal if they contain the same elements in the same order.  Also,\n     * two array references are considered equal if both are {@code null}.\n     *\n     * @param a one array to be tested for equality\n     * @param a2 the other array to be tested for equality\n     * @return {@code true} if the two arrays are equal\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean equals(boolean[] a, int aFromIndex, int aToIndex, boolean[] b, int bFromIndex, int bToIndex)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the two specified arrays of booleans, over the specified\n     * ranges, are <i>equal</i> to one another.\n     *\n     * <p>Two arrays are considered equal if the number of elements covered by\n     * each range is the same, and all corresponding pairs of elements over the\n     * specified ranges in the two arrays are equal.  In other words, two arrays\n     * are equal if they contain, over the specified ranges, the same elements\n     * in the same order.\n     *\n     * @param a the first array to be tested for equality\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be tested\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be tested\n     * @param b the second array to be tested for equality\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be tested\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be tested\n     * @return {@code true} if the two arrays, over the specified ranges, are\n     *         equal\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean equals(double[] a, double[] a2)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the two specified arrays of doubles are\n     * <i>equal</i> to one another.  Two arrays are considered equal if both\n     * arrays contain the same number of elements, and all corresponding pairs\n     * of elements in the two arrays are equal.  In other words, two arrays\n     * are equal if they contain the same elements in the same order.  Also,\n     * two array references are considered equal if both are {@code null}.\n     *\n     * Two doubles {@code d1} and {@code d2} are considered equal if:\n     * <pre>    {@code new Double(d1).equals(new Double(d2))}</pre>\n     * (Unlike the {@code ==} operator, this method considers\n     * {@code NaN} equal to itself, and 0.0d unequal to -0.0d.)\n     *\n     * @param a one array to be tested for equality\n     * @param a2 the other array to be tested for equality\n     * @return {@code true} if the two arrays are equal\n     * @see Double#equals(Object)\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean equals(double[] a, int aFromIndex, int aToIndex, double[] b, int bFromIndex, int bToIndex)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the two specified arrays of doubles, over the specified\n     * ranges, are <i>equal</i> to one another.\n     *\n     * <p>Two arrays are considered equal if the number of elements covered by\n     * each range is the same, and all corresponding pairs of elements over the\n     * specified ranges in the two arrays are equal.  In other words, two arrays\n     * are equal if they contain, over the specified ranges, the same elements\n     * in the same order.\n     *\n     * <p>Two doubles {@code d1} and {@code d2} are considered equal if:\n     * <pre>    {@code new Double(d1).equals(new Double(d2))}</pre>\n     * (Unlike the {@code ==} operator, this method considers\n     * {@code NaN} equal to itself, and 0.0d unequal to -0.0d.)\n     *\n     * @param a the first array to be tested for equality\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be tested\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be tested\n     * @param b the second array to be tested for equality\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be tested\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be tested\n     * @return {@code true} if the two arrays, over the specified ranges, are\n     *         equal\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @see Double#equals(Object)\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean equals(float[] a, float[] a2)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the two specified arrays of floats are\n     * <i>equal</i> to one another.  Two arrays are considered equal if both\n     * arrays contain the same number of elements, and all corresponding pairs\n     * of elements in the two arrays are equal.  In other words, two arrays\n     * are equal if they contain the same elements in the same order.  Also,\n     * two array references are considered equal if both are {@code null}.\n     *\n     * Two floats {@code f1} and {@code f2} are considered equal if:\n     * <pre>    {@code new Float(f1).equals(new Float(f2))}</pre>\n     * (Unlike the {@code ==} operator, this method considers\n     * {@code NaN} equal to itself, and 0.0f unequal to -0.0f.)\n     *\n     * @param a one array to be tested for equality\n     * @param a2 the other array to be tested for equality\n     * @return {@code true} if the two arrays are equal\n     * @see Float#equals(Object)\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean equals(float[] a, int aFromIndex, int aToIndex, float[] b, int bFromIndex, int bToIndex)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the two specified arrays of floats, over the specified\n     * ranges, are <i>equal</i> to one another.\n     *\n     * <p>Two arrays are considered equal if the number of elements covered by\n     * each range is the same, and all corresponding pairs of elements over the\n     * specified ranges in the two arrays are equal.  In other words, two arrays\n     * are equal if they contain, over the specified ranges, the same elements\n     * in the same order.\n     *\n     * <p>Two floats {@code f1} and {@code f2} are considered equal if:\n     * <pre>    {@code new Float(f1).equals(new Float(f2))}</pre>\n     * (Unlike the {@code ==} operator, this method considers\n     * {@code NaN} equal to itself, and 0.0f unequal to -0.0f.)\n     *\n     * @param a the first array to be tested for equality\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be tested\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be tested\n     * @param b the second array to be tested for equality\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be tested\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be tested\n     * @return {@code true} if the two arrays, over the specified ranges, are\n     *         equal\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @see Float#equals(Object)\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean equals(Object[] a, Object[] a2)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the two specified arrays of Objects are\n     * <i>equal</i> to one another.  The two arrays are considered equal if\n     * both arrays contain the same number of elements, and all corresponding\n     * pairs of elements in the two arrays are equal.  Two objects {@code e1}\n     * and {@code e2} are considered <i>equal</i> if\n     * {@code Objects.equals(e1, e2)}.\n     * In other words, the two arrays are equal if\n     * they contain the same elements in the same order.  Also, two array\n     * references are considered equal if both are {@code null}.\n     *\n     * @param a one array to be tested for equality\n     * @param a2 the other array to be tested for equality\n     * @return {@code true} if the two arrays are equal\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean equals(Object[] a, int aFromIndex, int aToIndex, Object[] b, int bFromIndex, int bToIndex)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the two specified arrays of Objects, over the specified\n     * ranges, are <i>equal</i> to one another.\n     *\n     * <p>Two arrays are considered equal if the number of elements covered by\n     * each range is the same, and all corresponding pairs of elements over the\n     * specified ranges in the two arrays are equal.  In other words, two arrays\n     * are equal if they contain, over the specified ranges, the same elements\n     * in the same order.\n     *\n     * <p>Two objects {@code e1} and {@code e2} are considered <i>equal</i> if\n     * {@code Objects.equals(e1, e2)}.\n     *\n     * @param a the first array to be tested for equality\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be tested\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be tested\n     * @param b the second array to be tested for equality\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be tested\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be tested\n     * @return {@code true} if the two arrays, over the specified ranges, are\n     *         equal\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean equals(T[] a, T[] a2, Comparator<? super T> cmp)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the two specified arrays of Objects are\n     * <i>equal</i> to one another.\n     *\n     * <p>Two arrays are considered equal if both arrays contain the same number\n     * of elements, and all corresponding pairs of elements in the two arrays\n     * are equal.  In other words, the two arrays are equal if they contain the\n     * same elements in the same order.  Also, two array references are\n     * considered equal if both are {@code null}.\n     *\n     * <p>Two objects {@code e1} and {@code e2} are considered <i>equal</i> if,\n     * given the specified comparator, {@code cmp.compare(e1, e2) == 0}.\n     *\n     * @param a one array to be tested for equality\n     * @param a2 the other array to be tested for equality\n     * @param cmp the comparator to compare array elements\n     * @param <T> the type of array elements\n     * @return {@code true} if the two arrays are equal\n     * @throws NullPointerException if the comparator is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean equals(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator<? super T> cmp)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the two specified arrays of Objects, over the specified\n     * ranges, are <i>equal</i> to one another.\n     *\n     * <p>Two arrays are considered equal if the number of elements covered by\n     * each range is the same, and all corresponding pairs of elements over the\n     * specified ranges in the two arrays are equal.  In other words, two arrays\n     * are equal if they contain, over the specified ranges, the same elements\n     * in the same order.\n     *\n     * <p>Two objects {@code e1} and {@code e2} are considered <i>equal</i> if,\n     * given the specified comparator, {@code cmp.compare(e1, e2) == 0}.\n     *\n     * @param a the first array to be tested for equality\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be tested\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be tested\n     * @param b the second array to be tested for equality\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be tested\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be tested\n     * @param cmp the comparator to compare array elements\n     * @param <T> the type of array elements\n     * @return {@code true} if the two arrays, over the specified ranges, are\n     *         equal\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array or the comparator is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void fill(long[] a, long val)",
    "returnType" : "void",
    "comment" : "\n     * Assigns the specified long value to each element of the specified array\n     * of longs.\n     *\n     * @param a the array to be filled\n     * @param val the value to be stored in all elements of the array\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void fill(long[] a, int fromIndex, int toIndex, long val)",
    "returnType" : "void",
    "comment" : "\n     * Assigns the specified long value to each element of the specified\n     * range of the specified array of longs.  The range to be filled\n     * extends from index {@code fromIndex}, inclusive, to index\n     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\n     * range to be filled is empty.)\n     *\n     * @param a the array to be filled\n     * @param fromIndex the index of the first element (inclusive) to be\n     *        filled with the specified value\n     * @param toIndex the index of the last element (exclusive) to be\n     *        filled with the specified value\n     * @param val the value to be stored in all elements of the array\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or\n     *         {@code toIndex > a.length}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void fill(int[] a, int val)",
    "returnType" : "void",
    "comment" : "\n     * Assigns the specified int value to each element of the specified array\n     * of ints.\n     *\n     * @param a the array to be filled\n     * @param val the value to be stored in all elements of the array\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void fill(int[] a, int fromIndex, int toIndex, int val)",
    "returnType" : "void",
    "comment" : "\n     * Assigns the specified int value to each element of the specified\n     * range of the specified array of ints.  The range to be filled\n     * extends from index {@code fromIndex}, inclusive, to index\n     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\n     * range to be filled is empty.)\n     *\n     * @param a the array to be filled\n     * @param fromIndex the index of the first element (inclusive) to be\n     *        filled with the specified value\n     * @param toIndex the index of the last element (exclusive) to be\n     *        filled with the specified value\n     * @param val the value to be stored in all elements of the array\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or\n     *         {@code toIndex > a.length}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void fill(short[] a, short val)",
    "returnType" : "void",
    "comment" : "\n     * Assigns the specified short value to each element of the specified array\n     * of shorts.\n     *\n     * @param a the array to be filled\n     * @param val the value to be stored in all elements of the array\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void fill(short[] a, int fromIndex, int toIndex, short val)",
    "returnType" : "void",
    "comment" : "\n     * Assigns the specified short value to each element of the specified\n     * range of the specified array of shorts.  The range to be filled\n     * extends from index {@code fromIndex}, inclusive, to index\n     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\n     * range to be filled is empty.)\n     *\n     * @param a the array to be filled\n     * @param fromIndex the index of the first element (inclusive) to be\n     *        filled with the specified value\n     * @param toIndex the index of the last element (exclusive) to be\n     *        filled with the specified value\n     * @param val the value to be stored in all elements of the array\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or\n     *         {@code toIndex > a.length}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void fill(char[] a, char val)",
    "returnType" : "void",
    "comment" : "\n     * Assigns the specified char value to each element of the specified array\n     * of chars.\n     *\n     * @param a the array to be filled\n     * @param val the value to be stored in all elements of the array\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void fill(char[] a, int fromIndex, int toIndex, char val)",
    "returnType" : "void",
    "comment" : "\n     * Assigns the specified char value to each element of the specified\n     * range of the specified array of chars.  The range to be filled\n     * extends from index {@code fromIndex}, inclusive, to index\n     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\n     * range to be filled is empty.)\n     *\n     * @param a the array to be filled\n     * @param fromIndex the index of the first element (inclusive) to be\n     *        filled with the specified value\n     * @param toIndex the index of the last element (exclusive) to be\n     *        filled with the specified value\n     * @param val the value to be stored in all elements of the array\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or\n     *         {@code toIndex > a.length}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void fill(byte[] a, byte val)",
    "returnType" : "void",
    "comment" : "\n     * Assigns the specified byte value to each element of the specified array\n     * of bytes.\n     *\n     * @param a the array to be filled\n     * @param val the value to be stored in all elements of the array\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void fill(byte[] a, int fromIndex, int toIndex, byte val)",
    "returnType" : "void",
    "comment" : "\n     * Assigns the specified byte value to each element of the specified\n     * range of the specified array of bytes.  The range to be filled\n     * extends from index {@code fromIndex}, inclusive, to index\n     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\n     * range to be filled is empty.)\n     *\n     * @param a the array to be filled\n     * @param fromIndex the index of the first element (inclusive) to be\n     *        filled with the specified value\n     * @param toIndex the index of the last element (exclusive) to be\n     *        filled with the specified value\n     * @param val the value to be stored in all elements of the array\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or\n     *         {@code toIndex > a.length}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void fill(boolean[] a, boolean val)",
    "returnType" : "void",
    "comment" : "\n     * Assigns the specified boolean value to each element of the specified\n     * array of booleans.\n     *\n     * @param a the array to be filled\n     * @param val the value to be stored in all elements of the array\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void fill(boolean[] a, int fromIndex, int toIndex, boolean val)",
    "returnType" : "void",
    "comment" : "\n     * Assigns the specified boolean value to each element of the specified\n     * range of the specified array of booleans.  The range to be filled\n     * extends from index {@code fromIndex}, inclusive, to index\n     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\n     * range to be filled is empty.)\n     *\n     * @param a the array to be filled\n     * @param fromIndex the index of the first element (inclusive) to be\n     *        filled with the specified value\n     * @param toIndex the index of the last element (exclusive) to be\n     *        filled with the specified value\n     * @param val the value to be stored in all elements of the array\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or\n     *         {@code toIndex > a.length}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void fill(double[] a, double val)",
    "returnType" : "void",
    "comment" : "\n     * Assigns the specified double value to each element of the specified\n     * array of doubles.\n     *\n     * @param a the array to be filled\n     * @param val the value to be stored in all elements of the array\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void fill(double[] a, int fromIndex, int toIndex, double val)",
    "returnType" : "void",
    "comment" : "\n     * Assigns the specified double value to each element of the specified\n     * range of the specified array of doubles.  The range to be filled\n     * extends from index {@code fromIndex}, inclusive, to index\n     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\n     * range to be filled is empty.)\n     *\n     * @param a the array to be filled\n     * @param fromIndex the index of the first element (inclusive) to be\n     *        filled with the specified value\n     * @param toIndex the index of the last element (exclusive) to be\n     *        filled with the specified value\n     * @param val the value to be stored in all elements of the array\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or\n     *         {@code toIndex > a.length}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void fill(float[] a, float val)",
    "returnType" : "void",
    "comment" : "\n     * Assigns the specified float value to each element of the specified array\n     * of floats.\n     *\n     * @param a the array to be filled\n     * @param val the value to be stored in all elements of the array\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void fill(float[] a, int fromIndex, int toIndex, float val)",
    "returnType" : "void",
    "comment" : "\n     * Assigns the specified float value to each element of the specified\n     * range of the specified array of floats.  The range to be filled\n     * extends from index {@code fromIndex}, inclusive, to index\n     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\n     * range to be filled is empty.)\n     *\n     * @param a the array to be filled\n     * @param fromIndex the index of the first element (inclusive) to be\n     *        filled with the specified value\n     * @param toIndex the index of the last element (exclusive) to be\n     *        filled with the specified value\n     * @param val the value to be stored in all elements of the array\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or\n     *         {@code toIndex > a.length}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void fill(Object[] a, Object val)",
    "returnType" : "void",
    "comment" : "\n     * Assigns the specified Object reference to each element of the specified\n     * array of Objects.\n     *\n     * @param a the array to be filled\n     * @param val the value to be stored in all elements of the array\n     * @throws ArrayStoreException if the specified value is not of a\n     *         runtime type that can be stored in the specified array\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void fill(Object[] a, int fromIndex, int toIndex, Object val)",
    "returnType" : "void",
    "comment" : "\n     * Assigns the specified Object reference to each element of the specified\n     * range of the specified array of Objects.  The range to be filled\n     * extends from index {@code fromIndex}, inclusive, to index\n     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the\n     * range to be filled is empty.)\n     *\n     * @param a the array to be filled\n     * @param fromIndex the index of the first element (inclusive) to be\n     *        filled with the specified value\n     * @param toIndex the index of the last element (exclusive) to be\n     *        filled with the specified value\n     * @param val the value to be stored in all elements of the array\n     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or\n     *         {@code toIndex > a.length}\n     * @throws ArrayStoreException if the specified value is not of a\n     *         runtime type that can be stored in the specified array\n     ",
    "links" : [ ]
  }, {
    "name" : "public static T[] copyOf(T[] original, int newLength)",
    "returnType" : "T[]",
    "comment" : "\n     * Copies the specified array, truncating or padding with nulls (if necessary)\n     * so the copy has the specified length.  For all indices that are\n     * valid in both the original array and the copy, the two arrays will\n     * contain identical values.  For any indices that are valid in the\n     * copy but not the original, the copy will contain {@code null}.\n     * Such indices will exist if and only if the specified length\n     * is greater than that of the original array.\n     * The resulting array is of exactly the same class as the original array.\n     *\n     * @param <T> the class of the objects in the array\n     * @param original the array to be copied\n     * @param newLength the length of the copy to be returned\n     * @return a copy of the original array, truncated or padded with nulls\n     *     to obtain the specified length\n     * @throws NegativeArraySizeException if {@code newLength} is negative\n     * @throws NullPointerException if {@code original} is null\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "public static T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType)",
    "returnType" : "T[]",
    "comment" : "\n     * Copies the specified array, truncating or padding with nulls (if necessary)\n     * so the copy has the specified length.  For all indices that are\n     * valid in both the original array and the copy, the two arrays will\n     * contain identical values.  For any indices that are valid in the\n     * copy but not the original, the copy will contain {@code null}.\n     * Such indices will exist if and only if the specified length\n     * is greater than that of the original array.\n     * The resulting array is of the class {@code newType}.\n     *\n     * @param <U> the class of the objects in the original array\n     * @param <T> the class of the objects in the returned array\n     * @param original the array to be copied\n     * @param newLength the length of the copy to be returned\n     * @param newType the class of the copy to be returned\n     * @return a copy of the original array, truncated or padded with nulls\n     *     to obtain the specified length\n     * @throws NegativeArraySizeException if {@code newLength} is negative\n     * @throws NullPointerException if {@code original} is null\n     * @throws ArrayStoreException if an element copied from\n     *     {@code original} is not of a runtime type that can be stored in\n     *     an array of class {@code newType}\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "public static byte[] copyOf(byte[] original, int newLength)",
    "returnType" : "byte[]",
    "comment" : "\n     * Copies the specified array, truncating or padding with zeros (if necessary)\n     * so the copy has the specified length.  For all indices that are\n     * valid in both the original array and the copy, the two arrays will\n     * contain identical values.  For any indices that are valid in the\n     * copy but not the original, the copy will contain {@code (byte)0}.\n     * Such indices will exist if and only if the specified length\n     * is greater than that of the original array.\n     *\n     * @param original the array to be copied\n     * @param newLength the length of the copy to be returned\n     * @return a copy of the original array, truncated or padded with zeros\n     *     to obtain the specified length\n     * @throws NegativeArraySizeException if {@code newLength} is negative\n     * @throws NullPointerException if {@code original} is null\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "public static short[] copyOf(short[] original, int newLength)",
    "returnType" : "short[]",
    "comment" : "\n     * Copies the specified array, truncating or padding with zeros (if necessary)\n     * so the copy has the specified length.  For all indices that are\n     * valid in both the original array and the copy, the two arrays will\n     * contain identical values.  For any indices that are valid in the\n     * copy but not the original, the copy will contain {@code (short)0}.\n     * Such indices will exist if and only if the specified length\n     * is greater than that of the original array.\n     *\n     * @param original the array to be copied\n     * @param newLength the length of the copy to be returned\n     * @return a copy of the original array, truncated or padded with zeros\n     *     to obtain the specified length\n     * @throws NegativeArraySizeException if {@code newLength} is negative\n     * @throws NullPointerException if {@code original} is null\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int[] copyOf(int[] original, int newLength)",
    "returnType" : "int[]",
    "comment" : "\n     * Copies the specified array, truncating or padding with zeros (if necessary)\n     * so the copy has the specified length.  For all indices that are\n     * valid in both the original array and the copy, the two arrays will\n     * contain identical values.  For any indices that are valid in the\n     * copy but not the original, the copy will contain {@code 0}.\n     * Such indices will exist if and only if the specified length\n     * is greater than that of the original array.\n     *\n     * @param original the array to be copied\n     * @param newLength the length of the copy to be returned\n     * @return a copy of the original array, truncated or padded with zeros\n     *     to obtain the specified length\n     * @throws NegativeArraySizeException if {@code newLength} is negative\n     * @throws NullPointerException if {@code original} is null\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "public static long[] copyOf(long[] original, int newLength)",
    "returnType" : "long[]",
    "comment" : "\n     * Copies the specified array, truncating or padding with zeros (if necessary)\n     * so the copy has the specified length.  For all indices that are\n     * valid in both the original array and the copy, the two arrays will\n     * contain identical values.  For any indices that are valid in the\n     * copy but not the original, the copy will contain {@code 0L}.\n     * Such indices will exist if and only if the specified length\n     * is greater than that of the original array.\n     *\n     * @param original the array to be copied\n     * @param newLength the length of the copy to be returned\n     * @return a copy of the original array, truncated or padded with zeros\n     *     to obtain the specified length\n     * @throws NegativeArraySizeException if {@code newLength} is negative\n     * @throws NullPointerException if {@code original} is null\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "public static char[] copyOf(char[] original, int newLength)",
    "returnType" : "char[]",
    "comment" : "\n     * Copies the specified array, truncating or padding with null characters (if necessary)\n     * so the copy has the specified length.  For all indices that are valid\n     * in both the original array and the copy, the two arrays will contain\n     * identical values.  For any indices that are valid in the copy but not\n     * the original, the copy will contain {@code '\\u005cu0000'}.  Such indices\n     * will exist if and only if the specified length is greater than that of\n     * the original array.\n     *\n     * @param original the array to be copied\n     * @param newLength the length of the copy to be returned\n     * @return a copy of the original array, truncated or padded with null characters\n     *     to obtain the specified length\n     * @throws NegativeArraySizeException if {@code newLength} is negative\n     * @throws NullPointerException if {@code original} is null\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "public static float[] copyOf(float[] original, int newLength)",
    "returnType" : "float[]",
    "comment" : "\n     * Copies the specified array, truncating or padding with zeros (if necessary)\n     * so the copy has the specified length.  For all indices that are\n     * valid in both the original array and the copy, the two arrays will\n     * contain identical values.  For any indices that are valid in the\n     * copy but not the original, the copy will contain {@code 0f}.\n     * Such indices will exist if and only if the specified length\n     * is greater than that of the original array.\n     *\n     * @param original the array to be copied\n     * @param newLength the length of the copy to be returned\n     * @return a copy of the original array, truncated or padded with zeros\n     *     to obtain the specified length\n     * @throws NegativeArraySizeException if {@code newLength} is negative\n     * @throws NullPointerException if {@code original} is null\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "public static double[] copyOf(double[] original, int newLength)",
    "returnType" : "double[]",
    "comment" : "\n     * Copies the specified array, truncating or padding with zeros (if necessary)\n     * so the copy has the specified length.  For all indices that are\n     * valid in both the original array and the copy, the two arrays will\n     * contain identical values.  For any indices that are valid in the\n     * copy but not the original, the copy will contain {@code 0d}.\n     * Such indices will exist if and only if the specified length\n     * is greater than that of the original array.\n     *\n     * @param original the array to be copied\n     * @param newLength the length of the copy to be returned\n     * @return a copy of the original array, truncated or padded with zeros\n     *     to obtain the specified length\n     * @throws NegativeArraySizeException if {@code newLength} is negative\n     * @throws NullPointerException if {@code original} is null\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean[] copyOf(boolean[] original, int newLength)",
    "returnType" : "boolean[]",
    "comment" : "\n     * Copies the specified array, truncating or padding with {@code false} (if necessary)\n     * so the copy has the specified length.  For all indices that are\n     * valid in both the original array and the copy, the two arrays will\n     * contain identical values.  For any indices that are valid in the\n     * copy but not the original, the copy will contain {@code false}.\n     * Such indices will exist if and only if the specified length\n     * is greater than that of the original array.\n     *\n     * @param original the array to be copied\n     * @param newLength the length of the copy to be returned\n     * @return a copy of the original array, truncated or padded with false elements\n     *     to obtain the specified length\n     * @throws NegativeArraySizeException if {@code newLength} is negative\n     * @throws NullPointerException if {@code original} is null\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "public static T[] copyOfRange(T[] original, int from, int to)",
    "returnType" : "T[]",
    "comment" : "\n     * Copies the specified range of the specified array into a new array.\n     * The initial index of the range ({@code from}) must lie between zero\n     * and {@code original.length}, inclusive.  The value at\n     * {@code original[from]} is placed into the initial element of the copy\n     * (unless {@code from == original.length} or {@code from == to}).\n     * Values from subsequent elements in the original array are placed into\n     * subsequent elements in the copy.  The final index of the range\n     * ({@code to}), which must be greater than or equal to {@code from},\n     * may be greater than {@code original.length}, in which case\n     * {@code null} is placed in all elements of the copy whose index is\n     * greater than or equal to {@code original.length - from}.  The length\n     * of the returned array will be {@code to - from}.\n     * <p>\n     * The resulting array is of exactly the same class as the original array.\n     *\n     * @param <T> the class of the objects in the array\n     * @param original the array from which a range is to be copied\n     * @param from the initial index of the range to be copied, inclusive\n     * @param to the final index of the range to be copied, exclusive.\n     *     (This index may lie outside the array.)\n     * @return a new array containing the specified range from the original array,\n     *     truncated or padded with nulls to obtain the required length\n     * @throws ArrayIndexOutOfBoundsException if {@code from < 0}\n     *     or {@code from > original.length}\n     * @throws IllegalArgumentException if {@code from > to}\n     * @throws NullPointerException if {@code original} is null\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "public static T[] copyOfRange(U[] original, int from, int to, Class<? extends T[]> newType)",
    "returnType" : "T[]",
    "comment" : "\n     * Copies the specified range of the specified array into a new array.\n     * The initial index of the range ({@code from}) must lie between zero\n     * and {@code original.length}, inclusive.  The value at\n     * {@code original[from]} is placed into the initial element of the copy\n     * (unless {@code from == original.length} or {@code from == to}).\n     * Values from subsequent elements in the original array are placed into\n     * subsequent elements in the copy.  The final index of the range\n     * ({@code to}), which must be greater than or equal to {@code from},\n     * may be greater than {@code original.length}, in which case\n     * {@code null} is placed in all elements of the copy whose index is\n     * greater than or equal to {@code original.length - from}.  The length\n     * of the returned array will be {@code to - from}.\n     * The resulting array is of the class {@code newType}.\n     *\n     * @param <U> the class of the objects in the original array\n     * @param <T> the class of the objects in the returned array\n     * @param original the array from which a range is to be copied\n     * @param from the initial index of the range to be copied, inclusive\n     * @param to the final index of the range to be copied, exclusive.\n     *     (This index may lie outside the array.)\n     * @param newType the class of the copy to be returned\n     * @return a new array containing the specified range from the original array,\n     *     truncated or padded with nulls to obtain the required length\n     * @throws ArrayIndexOutOfBoundsException if {@code from < 0}\n     *     or {@code from > original.length}\n     * @throws IllegalArgumentException if {@code from > to}\n     * @throws NullPointerException if {@code original} is null\n     * @throws ArrayStoreException if an element copied from\n     *     {@code original} is not of a runtime type that can be stored in\n     *     an array of class {@code newType}.\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "public static byte[] copyOfRange(byte[] original, int from, int to)",
    "returnType" : "byte[]",
    "comment" : "\n     * Copies the specified range of the specified array into a new array.\n     * The initial index of the range ({@code from}) must lie between zero\n     * and {@code original.length}, inclusive.  The value at\n     * {@code original[from]} is placed into the initial element of the copy\n     * (unless {@code from == original.length} or {@code from == to}).\n     * Values from subsequent elements in the original array are placed into\n     * subsequent elements in the copy.  The final index of the range\n     * ({@code to}), which must be greater than or equal to {@code from},\n     * may be greater than {@code original.length}, in which case\n     * {@code (byte)0} is placed in all elements of the copy whose index is\n     * greater than or equal to {@code original.length - from}.  The length\n     * of the returned array will be {@code to - from}.\n     *\n     * @param original the array from which a range is to be copied\n     * @param from the initial index of the range to be copied, inclusive\n     * @param to the final index of the range to be copied, exclusive.\n     *     (This index may lie outside the array.)\n     * @return a new array containing the specified range from the original array,\n     *     truncated or padded with zeros to obtain the required length\n     * @throws ArrayIndexOutOfBoundsException if {@code from < 0}\n     *     or {@code from > original.length}\n     * @throws IllegalArgumentException if {@code from > to}\n     * @throws NullPointerException if {@code original} is null\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "public static short[] copyOfRange(short[] original, int from, int to)",
    "returnType" : "short[]",
    "comment" : "\n     * Copies the specified range of the specified array into a new array.\n     * The initial index of the range ({@code from}) must lie between zero\n     * and {@code original.length}, inclusive.  The value at\n     * {@code original[from]} is placed into the initial element of the copy\n     * (unless {@code from == original.length} or {@code from == to}).\n     * Values from subsequent elements in the original array are placed into\n     * subsequent elements in the copy.  The final index of the range\n     * ({@code to}), which must be greater than or equal to {@code from},\n     * may be greater than {@code original.length}, in which case\n     * {@code (short)0} is placed in all elements of the copy whose index is\n     * greater than or equal to {@code original.length - from}.  The length\n     * of the returned array will be {@code to - from}.\n     *\n     * @param original the array from which a range is to be copied\n     * @param from the initial index of the range to be copied, inclusive\n     * @param to the final index of the range to be copied, exclusive.\n     *     (This index may lie outside the array.)\n     * @return a new array containing the specified range from the original array,\n     *     truncated or padded with zeros to obtain the required length\n     * @throws ArrayIndexOutOfBoundsException if {@code from < 0}\n     *     or {@code from > original.length}\n     * @throws IllegalArgumentException if {@code from > to}\n     * @throws NullPointerException if {@code original} is null\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int[] copyOfRange(int[] original, int from, int to)",
    "returnType" : "int[]",
    "comment" : "\n     * Copies the specified range of the specified array into a new array.\n     * The initial index of the range ({@code from}) must lie between zero\n     * and {@code original.length}, inclusive.  The value at\n     * {@code original[from]} is placed into the initial element of the copy\n     * (unless {@code from == original.length} or {@code from == to}).\n     * Values from subsequent elements in the original array are placed into\n     * subsequent elements in the copy.  The final index of the range\n     * ({@code to}), which must be greater than or equal to {@code from},\n     * may be greater than {@code original.length}, in which case\n     * {@code 0} is placed in all elements of the copy whose index is\n     * greater than or equal to {@code original.length - from}.  The length\n     * of the returned array will be {@code to - from}.\n     *\n     * @param original the array from which a range is to be copied\n     * @param from the initial index of the range to be copied, inclusive\n     * @param to the final index of the range to be copied, exclusive.\n     *     (This index may lie outside the array.)\n     * @return a new array containing the specified range from the original array,\n     *     truncated or padded with zeros to obtain the required length\n     * @throws ArrayIndexOutOfBoundsException if {@code from < 0}\n     *     or {@code from > original.length}\n     * @throws IllegalArgumentException if {@code from > to}\n     * @throws NullPointerException if {@code original} is null\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "public static long[] copyOfRange(long[] original, int from, int to)",
    "returnType" : "long[]",
    "comment" : "\n     * Copies the specified range of the specified array into a new array.\n     * The initial index of the range ({@code from}) must lie between zero\n     * and {@code original.length}, inclusive.  The value at\n     * {@code original[from]} is placed into the initial element of the copy\n     * (unless {@code from == original.length} or {@code from == to}).\n     * Values from subsequent elements in the original array are placed into\n     * subsequent elements in the copy.  The final index of the range\n     * ({@code to}), which must be greater than or equal to {@code from},\n     * may be greater than {@code original.length}, in which case\n     * {@code 0L} is placed in all elements of the copy whose index is\n     * greater than or equal to {@code original.length - from}.  The length\n     * of the returned array will be {@code to - from}.\n     *\n     * @param original the array from which a range is to be copied\n     * @param from the initial index of the range to be copied, inclusive\n     * @param to the final index of the range to be copied, exclusive.\n     *     (This index may lie outside the array.)\n     * @return a new array containing the specified range from the original array,\n     *     truncated or padded with zeros to obtain the required length\n     * @throws ArrayIndexOutOfBoundsException if {@code from < 0}\n     *     or {@code from > original.length}\n     * @throws IllegalArgumentException if {@code from > to}\n     * @throws NullPointerException if {@code original} is null\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "public static char[] copyOfRange(char[] original, int from, int to)",
    "returnType" : "char[]",
    "comment" : "\n     * Copies the specified range of the specified array into a new array.\n     * The initial index of the range ({@code from}) must lie between zero\n     * and {@code original.length}, inclusive.  The value at\n     * {@code original[from]} is placed into the initial element of the copy\n     * (unless {@code from == original.length} or {@code from == to}).\n     * Values from subsequent elements in the original array are placed into\n     * subsequent elements in the copy.  The final index of the range\n     * ({@code to}), which must be greater than or equal to {@code from},\n     * may be greater than {@code original.length}, in which case\n     * {@code '\\u005cu0000'} is placed in all elements of the copy whose index is\n     * greater than or equal to {@code original.length - from}.  The length\n     * of the returned array will be {@code to - from}.\n     *\n     * @param original the array from which a range is to be copied\n     * @param from the initial index of the range to be copied, inclusive\n     * @param to the final index of the range to be copied, exclusive.\n     *     (This index may lie outside the array.)\n     * @return a new array containing the specified range from the original array,\n     *     truncated or padded with null characters to obtain the required length\n     * @throws ArrayIndexOutOfBoundsException if {@code from < 0}\n     *     or {@code from > original.length}\n     * @throws IllegalArgumentException if {@code from > to}\n     * @throws NullPointerException if {@code original} is null\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "public static float[] copyOfRange(float[] original, int from, int to)",
    "returnType" : "float[]",
    "comment" : "\n     * Copies the specified range of the specified array into a new array.\n     * The initial index of the range ({@code from}) must lie between zero\n     * and {@code original.length}, inclusive.  The value at\n     * {@code original[from]} is placed into the initial element of the copy\n     * (unless {@code from == original.length} or {@code from == to}).\n     * Values from subsequent elements in the original array are placed into\n     * subsequent elements in the copy.  The final index of the range\n     * ({@code to}), which must be greater than or equal to {@code from},\n     * may be greater than {@code original.length}, in which case\n     * {@code 0f} is placed in all elements of the copy whose index is\n     * greater than or equal to {@code original.length - from}.  The length\n     * of the returned array will be {@code to - from}.\n     *\n     * @param original the array from which a range is to be copied\n     * @param from the initial index of the range to be copied, inclusive\n     * @param to the final index of the range to be copied, exclusive.\n     *     (This index may lie outside the array.)\n     * @return a new array containing the specified range from the original array,\n     *     truncated or padded with zeros to obtain the required length\n     * @throws ArrayIndexOutOfBoundsException if {@code from < 0}\n     *     or {@code from > original.length}\n     * @throws IllegalArgumentException if {@code from > to}\n     * @throws NullPointerException if {@code original} is null\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "public static double[] copyOfRange(double[] original, int from, int to)",
    "returnType" : "double[]",
    "comment" : "\n     * Copies the specified range of the specified array into a new array.\n     * The initial index of the range ({@code from}) must lie between zero\n     * and {@code original.length}, inclusive.  The value at\n     * {@code original[from]} is placed into the initial element of the copy\n     * (unless {@code from == original.length} or {@code from == to}).\n     * Values from subsequent elements in the original array are placed into\n     * subsequent elements in the copy.  The final index of the range\n     * ({@code to}), which must be greater than or equal to {@code from},\n     * may be greater than {@code original.length}, in which case\n     * {@code 0d} is placed in all elements of the copy whose index is\n     * greater than or equal to {@code original.length - from}.  The length\n     * of the returned array will be {@code to - from}.\n     *\n     * @param original the array from which a range is to be copied\n     * @param from the initial index of the range to be copied, inclusive\n     * @param to the final index of the range to be copied, exclusive.\n     *     (This index may lie outside the array.)\n     * @return a new array containing the specified range from the original array,\n     *     truncated or padded with zeros to obtain the required length\n     * @throws ArrayIndexOutOfBoundsException if {@code from < 0}\n     *     or {@code from > original.length}\n     * @throws IllegalArgumentException if {@code from > to}\n     * @throws NullPointerException if {@code original} is null\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean[] copyOfRange(boolean[] original, int from, int to)",
    "returnType" : "boolean[]",
    "comment" : "\n     * Copies the specified range of the specified array into a new array.\n     * The initial index of the range ({@code from}) must lie between zero\n     * and {@code original.length}, inclusive.  The value at\n     * {@code original[from]} is placed into the initial element of the copy\n     * (unless {@code from == original.length} or {@code from == to}).\n     * Values from subsequent elements in the original array are placed into\n     * subsequent elements in the copy.  The final index of the range\n     * ({@code to}), which must be greater than or equal to {@code from},\n     * may be greater than {@code original.length}, in which case\n     * {@code false} is placed in all elements of the copy whose index is\n     * greater than or equal to {@code original.length - from}.  The length\n     * of the returned array will be {@code to - from}.\n     *\n     * @param original the array from which a range is to be copied\n     * @param from the initial index of the range to be copied, inclusive\n     * @param to the final index of the range to be copied, exclusive.\n     *     (This index may lie outside the array.)\n     * @return a new array containing the specified range from the original array,\n     *     truncated or padded with false elements to obtain the required length\n     * @throws ArrayIndexOutOfBoundsException if {@code from < 0}\n     *     or {@code from > original.length}\n     * @throws IllegalArgumentException if {@code from > to}\n     * @throws NullPointerException if {@code original} is null\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "public static List<T> asList(T... a)",
    "returnType" : "List<T>",
    "comment" : "\n     * Returns a fixed-size list backed by the specified array. Changes made to\n     * the array will be visible in the returned list, and changes made to the\n     * list will be visible in the array. The returned list is\n     * {@link Serializable} and implements {@link RandomAccess}.\n     *\n     * <p>The returned list implements the optional {@code Collection} methods, except\n     * those that would change the size of the returned list. Those methods leave\n     * the list unchanged and throw {@link UnsupportedOperationException}.\n     *\n     * @apiNote\n     * This method acts as bridge between array-based and collection-based\n     * APIs, in combination with {@link Collection#toArray}.\n     *\n     * <p>This method provides a way to wrap an existing array:\n     * <pre>{@code\n     *     Integer[] numbers = ...\n     *     ...\n     *     List<Integer> values = Arrays.asList(numbers);\n     * }</pre>\n     *\n     * <p>This method also provides a convenient way to create a fixed-size\n     * list initialized to contain several elements:\n     * <pre>{@code\n     *     List<String> stooges = Arrays.asList(\"Larry\", \"Moe\", \"Curly\");\n     * }</pre>\n     *\n     * <p><em>The list returned by this method is modifiable.</em>\n     * To create an unmodifiable list, use\n     * {@link Collections#unmodifiableList Collections.unmodifiableList}\n     * or <a href=\"List.html#unmodifiable\">Unmodifiable Lists</a>.\n     *\n     * @param <T> the class of the objects in the array\n     * @param a the array by which the list will be backed\n     * @return a list view of the specified array\n     * @throws NullPointerException if the specified array is {@code null}\n     ",
    "links" : [ "java.util.RandomAccess", "java.util.Collection#toArray", "java.util.Collections#unmodifiableList", "java.io.Serializable", "UnsupportedOperationException" ]
  }, {
    "name" : "public static int hashCode(long[] a)",
    "returnType" : "int",
    "comment" : "\n     * Returns a hash code based on the contents of the specified array.\n     * For any two {@code long} arrays {@code a} and {@code b}\n     * such that {@code Arrays.equals(a, b)}, it is also the case that\n     * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.\n     *\n     * <p>The value returned by this method is the same value that would be\n     * obtained by invoking the {@link List#hashCode() hashCode}\n     * method on a {@link List} containing a sequence of {@link Long}\n     * instances representing the elements of {@code a} in the same order.\n     * If {@code a} is {@code null}, this method returns 0.\n     *\n     * @param a the array whose hash value to compute\n     * @return a content-based hash code for {@code a}\n     * @since 1.5\n     ",
    "links" : [ "java.util.List", "java.util.List#hashCode()", "Long" ]
  }, {
    "name" : "public static int hashCode(int[] a)",
    "returnType" : "int",
    "comment" : "\n     * Returns a hash code based on the contents of the specified array.\n     * For any two non-null {@code int} arrays {@code a} and {@code b}\n     * such that {@code Arrays.equals(a, b)}, it is also the case that\n     * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.\n     *\n     * <p>The value returned by this method is the same value that would be\n     * obtained by invoking the {@link List#hashCode() hashCode}\n     * method on a {@link List} containing a sequence of {@link Integer}\n     * instances representing the elements of {@code a} in the same order.\n     * If {@code a} is {@code null}, this method returns 0.\n     *\n     * @param a the array whose hash value to compute\n     * @return a content-based hash code for {@code a}\n     * @since 1.5\n     ",
    "links" : [ "Integer", "java.util.List", "java.util.List#hashCode()" ]
  }, {
    "name" : "public static int hashCode(short[] a)",
    "returnType" : "int",
    "comment" : "\n     * Returns a hash code based on the contents of the specified array.\n     * For any two {@code short} arrays {@code a} and {@code b}\n     * such that {@code Arrays.equals(a, b)}, it is also the case that\n     * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.\n     *\n     * <p>The value returned by this method is the same value that would be\n     * obtained by invoking the {@link List#hashCode() hashCode}\n     * method on a {@link List} containing a sequence of {@link Short}\n     * instances representing the elements of {@code a} in the same order.\n     * If {@code a} is {@code null}, this method returns 0.\n     *\n     * @param a the array whose hash value to compute\n     * @return a content-based hash code for {@code a}\n     * @since 1.5\n     ",
    "links" : [ "java.util.List", "java.util.List#hashCode()", "Short" ]
  }, {
    "name" : "public static int hashCode(char[] a)",
    "returnType" : "int",
    "comment" : "\n     * Returns a hash code based on the contents of the specified array.\n     * For any two {@code char} arrays {@code a} and {@code b}\n     * such that {@code Arrays.equals(a, b)}, it is also the case that\n     * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.\n     *\n     * <p>The value returned by this method is the same value that would be\n     * obtained by invoking the {@link List#hashCode() hashCode}\n     * method on a {@link List} containing a sequence of {@link Character}\n     * instances representing the elements of {@code a} in the same order.\n     * If {@code a} is {@code null}, this method returns 0.\n     *\n     * @param a the array whose hash value to compute\n     * @return a content-based hash code for {@code a}\n     * @since 1.5\n     ",
    "links" : [ "java.util.List", "Character", "java.util.List#hashCode()" ]
  }, {
    "name" : "public static int hashCode(byte[] a)",
    "returnType" : "int",
    "comment" : "\n     * Returns a hash code based on the contents of the specified array.\n     * For any two {@code byte} arrays {@code a} and {@code b}\n     * such that {@code Arrays.equals(a, b)}, it is also the case that\n     * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.\n     *\n     * <p>The value returned by this method is the same value that would be\n     * obtained by invoking the {@link List#hashCode() hashCode}\n     * method on a {@link List} containing a sequence of {@link Byte}\n     * instances representing the elements of {@code a} in the same order.\n     * If {@code a} is {@code null}, this method returns 0.\n     *\n     * @param a the array whose hash value to compute\n     * @return a content-based hash code for {@code a}\n     * @since 1.5\n     ",
    "links" : [ "java.util.List", "Byte", "java.util.List#hashCode()" ]
  }, {
    "name" : "public static int hashCode(boolean[] a)",
    "returnType" : "int",
    "comment" : "\n     * Returns a hash code based on the contents of the specified array.\n     * For any two {@code boolean} arrays {@code a} and {@code b}\n     * such that {@code Arrays.equals(a, b)}, it is also the case that\n     * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.\n     *\n     * <p>The value returned by this method is the same value that would be\n     * obtained by invoking the {@link List#hashCode() hashCode}\n     * method on a {@link List} containing a sequence of {@link Boolean}\n     * instances representing the elements of {@code a} in the same order.\n     * If {@code a} is {@code null}, this method returns 0.\n     *\n     * @param a the array whose hash value to compute\n     * @return a content-based hash code for {@code a}\n     * @since 1.5\n     ",
    "links" : [ "java.util.List", "java.util.List#hashCode()", "Boolean" ]
  }, {
    "name" : "public static int hashCode(float[] a)",
    "returnType" : "int",
    "comment" : "\n     * Returns a hash code based on the contents of the specified array.\n     * For any two {@code float} arrays {@code a} and {@code b}\n     * such that {@code Arrays.equals(a, b)}, it is also the case that\n     * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.\n     *\n     * <p>The value returned by this method is the same value that would be\n     * obtained by invoking the {@link List#hashCode() hashCode}\n     * method on a {@link List} containing a sequence of {@link Float}\n     * instances representing the elements of {@code a} in the same order.\n     * If {@code a} is {@code null}, this method returns 0.\n     *\n     * @param a the array whose hash value to compute\n     * @return a content-based hash code for {@code a}\n     * @since 1.5\n     ",
    "links" : [ "Float", "java.util.List", "java.util.List#hashCode()" ]
  }, {
    "name" : "public static int hashCode(double[] a)",
    "returnType" : "int",
    "comment" : "\n     * Returns a hash code based on the contents of the specified array.\n     * For any two {@code double} arrays {@code a} and {@code b}\n     * such that {@code Arrays.equals(a, b)}, it is also the case that\n     * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.\n     *\n     * <p>The value returned by this method is the same value that would be\n     * obtained by invoking the {@link List#hashCode() hashCode}\n     * method on a {@link List} containing a sequence of {@link Double}\n     * instances representing the elements of {@code a} in the same order.\n     * If {@code a} is {@code null}, this method returns 0.\n     *\n     * @param a the array whose hash value to compute\n     * @return a content-based hash code for {@code a}\n     * @since 1.5\n     ",
    "links" : [ "java.util.List", "java.util.List#hashCode()", "Double" ]
  }, {
    "name" : "public static int hashCode(Object[] a)",
    "returnType" : "int",
    "comment" : "\n     * Returns a hash code based on the contents of the specified array.  If\n     * the array contains other arrays as elements, the hash code is based on\n     * their identities rather than their contents.  It is therefore\n     * acceptable to invoke this method on an array that contains itself as an\n     * element,  either directly or indirectly through one or more levels of\n     * arrays.\n     *\n     * <p>For any two arrays {@code a} and {@code b} such that\n     * {@code Arrays.equals(a, b)}, it is also the case that\n     * {@code Arrays.hashCode(a) == Arrays.hashCode(b)}.\n     *\n     * <p>The value returned by this method is equal to the value that would\n     * be returned by {@code Arrays.asList(a).hashCode()}, unless {@code a}\n     * is {@code null}, in which case {@code 0} is returned.\n     *\n     * @param a the array whose content-based hash code to compute\n     * @return a content-based hash code for {@code a}\n     * @see #deepHashCode(Object[])\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int deepHashCode(Object[] a)",
    "returnType" : "int",
    "comment" : "\n     * Returns a hash code based on the \"deep contents\" of the specified\n     * array.  If the array contains other arrays as elements, the\n     * hash code is based on their contents and so on, ad infinitum.\n     * It is therefore unacceptable to invoke this method on an array that\n     * contains itself as an element, either directly or indirectly through\n     * one or more levels of arrays.  The behavior of such an invocation is\n     * undefined.\n     *\n     * <p>For any two arrays {@code a} and {@code b} such that\n     * {@code Arrays.deepEquals(a, b)}, it is also the case that\n     * {@code Arrays.deepHashCode(a) == Arrays.deepHashCode(b)}.\n     *\n     * <p>The computation of the value returned by this method is similar to\n     * that of the value returned by {@link List#hashCode()} on a list\n     * containing the same elements as {@code a} in the same order, with one\n     * difference: If an element {@code e} of {@code a} is itself an array,\n     * its hash code is computed not by calling {@code e.hashCode()}, but as\n     * by calling the appropriate overloading of {@code Arrays.hashCode(e)}\n     * if {@code e} is an array of a primitive type, or as by calling\n     * {@code Arrays.deepHashCode(e)} recursively if {@code e} is an array\n     * of a reference type.  If {@code a} is {@code null}, this method\n     * returns 0.\n     *\n     * @param a the array whose deep-content-based hash code to compute\n     * @return a deep-content-based hash code for {@code a}\n     * @see #hashCode(Object[])\n     * @since 1.5\n     ",
    "links" : [ "java.util.List#hashCode()" ]
  }, {
    "name" : "private static int primitiveArrayHashCode(Object a, Class<?> cl)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean deepEquals(Object[] a1, Object[] a2)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the two specified arrays are <i>deeply\n     * equal</i> to one another.  Unlike the {@link #equals(Object[],Object[])}\n     * method, this method is appropriate for use with nested arrays of\n     * arbitrary depth.\n     *\n     * <p>Two array references are considered deeply equal if both\n     * are {@code null}, or if they refer to arrays that contain the same\n     * number of elements and all corresponding pairs of elements in the two\n     * arrays are deeply equal.\n     *\n     * <p>Two possibly {@code null} elements {@code e1} and {@code e2} are\n     * deeply equal if any of the following conditions hold:\n     * <ul>\n     *    <li> {@code e1} and {@code e2} are both arrays of object reference\n     *         types, and {@code Arrays.deepEquals(e1, e2) would return true}\n     *    <li> {@code e1} and {@code e2} are arrays of the same primitive\n     *         type, and the appropriate overloading of\n     *         {@code Arrays.equals(e1, e2)} would return true.\n     *    <li> {@code e1 == e2}\n     *    <li> {@code e1.equals(e2)} would return true.\n     * </ul>\n     * Note that this definition permits {@code null} elements at any depth.\n     *\n     * <p>If either of the specified arrays contain themselves as elements\n     * either directly or indirectly through one or more levels of arrays,\n     * the behavior of this method is undefined.\n     *\n     * @param a1 one array to be tested for equality\n     * @param a2 the other array to be tested for equality\n     * @return {@code true} if the two arrays are equal\n     * @see #equals(Object[],Object[])\n     * @see Objects#deepEquals(Object, Object)\n     * @since 1.5\n     ",
    "links" : [ "#equals(Object" ]
  }, {
    "name" : " static boolean deepEquals0(Object e1, Object e2)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static String toString(long[] a)",
    "returnType" : "String",
    "comment" : "\n     * Returns a string representation of the contents of the specified array.\n     * The string representation consists of a list of the array's elements,\n     * enclosed in square brackets ({@code \"[]\"}).  Adjacent elements are\n     * separated by the characters {@code \", \"} (a comma followed by a\n     * space).  Elements are converted to strings as by\n     * {@code String.valueOf(long)}.  Returns {@code \"null\"} if {@code a}\n     * is {@code null}.\n     *\n     * @param a the array whose string representation to return\n     * @return a string representation of {@code a}\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String toString(int[] a)",
    "returnType" : "String",
    "comment" : "\n     * Returns a string representation of the contents of the specified array.\n     * The string representation consists of a list of the array's elements,\n     * enclosed in square brackets ({@code \"[]\"}).  Adjacent elements are\n     * separated by the characters {@code \", \"} (a comma followed by a\n     * space).  Elements are converted to strings as by\n     * {@code String.valueOf(int)}.  Returns {@code \"null\"} if {@code a} is\n     * {@code null}.\n     *\n     * @param a the array whose string representation to return\n     * @return a string representation of {@code a}\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String toString(short[] a)",
    "returnType" : "String",
    "comment" : "\n     * Returns a string representation of the contents of the specified array.\n     * The string representation consists of a list of the array's elements,\n     * enclosed in square brackets ({@code \"[]\"}).  Adjacent elements are\n     * separated by the characters {@code \", \"} (a comma followed by a\n     * space).  Elements are converted to strings as by\n     * {@code String.valueOf(short)}.  Returns {@code \"null\"} if {@code a}\n     * is {@code null}.\n     *\n     * @param a the array whose string representation to return\n     * @return a string representation of {@code a}\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String toString(char[] a)",
    "returnType" : "String",
    "comment" : "\n     * Returns a string representation of the contents of the specified array.\n     * The string representation consists of a list of the array's elements,\n     * enclosed in square brackets ({@code \"[]\"}).  Adjacent elements are\n     * separated by the characters {@code \", \"} (a comma followed by a\n     * space).  Elements are converted to strings as by\n     * {@code String.valueOf(char)}.  Returns {@code \"null\"} if {@code a}\n     * is {@code null}.\n     *\n     * @param a the array whose string representation to return\n     * @return a string representation of {@code a}\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String toString(byte[] a)",
    "returnType" : "String",
    "comment" : "\n     * Returns a string representation of the contents of the specified array.\n     * The string representation consists of a list of the array's elements,\n     * enclosed in square brackets ({@code \"[]\"}).  Adjacent elements\n     * are separated by the characters {@code \", \"} (a comma followed\n     * by a space).  Elements are converted to strings as by\n     * {@code String.valueOf(byte)}.  Returns {@code \"null\"} if\n     * {@code a} is {@code null}.\n     *\n     * @param a the array whose string representation to return\n     * @return a string representation of {@code a}\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String toString(boolean[] a)",
    "returnType" : "String",
    "comment" : "\n     * Returns a string representation of the contents of the specified array.\n     * The string representation consists of a list of the array's elements,\n     * enclosed in square brackets ({@code \"[]\"}).  Adjacent elements are\n     * separated by the characters {@code \", \"} (a comma followed by a\n     * space).  Elements are converted to strings as by\n     * {@code String.valueOf(boolean)}.  Returns {@code \"null\"} if\n     * {@code a} is {@code null}.\n     *\n     * @param a the array whose string representation to return\n     * @return a string representation of {@code a}\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String toString(float[] a)",
    "returnType" : "String",
    "comment" : "\n     * Returns a string representation of the contents of the specified array.\n     * The string representation consists of a list of the array's elements,\n     * enclosed in square brackets ({@code \"[]\"}).  Adjacent elements are\n     * separated by the characters {@code \", \"} (a comma followed by a\n     * space).  Elements are converted to strings as by\n     * {@code String.valueOf(float)}.  Returns {@code \"null\"} if {@code a}\n     * is {@code null}.\n     *\n     * @param a the array whose string representation to return\n     * @return a string representation of {@code a}\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String toString(double[] a)",
    "returnType" : "String",
    "comment" : "\n     * Returns a string representation of the contents of the specified array.\n     * The string representation consists of a list of the array's elements,\n     * enclosed in square brackets ({@code \"[]\"}).  Adjacent elements are\n     * separated by the characters {@code \", \"} (a comma followed by a\n     * space).  Elements are converted to strings as by\n     * {@code String.valueOf(double)}.  Returns {@code \"null\"} if {@code a}\n     * is {@code null}.\n     *\n     * @param a the array whose string representation to return\n     * @return a string representation of {@code a}\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String toString(Object[] a)",
    "returnType" : "String",
    "comment" : "\n     * Returns a string representation of the contents of the specified array.\n     * If the array contains other arrays as elements, they are converted to\n     * strings by the {@link Object#toString} method inherited from\n     * {@code Object}, which describes their <i>identities</i> rather than\n     * their contents.\n     *\n     * <p>The value returned by this method is equal to the value that would\n     * be returned by {@code Arrays.asList(a).toString()}, unless {@code a}\n     * is {@code null}, in which case {@code \"null\"} is returned.\n     *\n     * @param a the array whose string representation to return\n     * @return a string representation of {@code a}\n     * @see #deepToString(Object[])\n     * @since 1.5\n     ",
    "links" : [ "#toString" ]
  }, {
    "name" : "public static String deepToString(Object[] a)",
    "returnType" : "String",
    "comment" : "\n     * Returns a string representation of the \"deep contents\" of the specified\n     * array.  If the array contains other arrays as elements, the string\n     * representation contains their contents and so on.  This method is\n     * designed for converting multidimensional arrays to strings.\n     *\n     * <p>The string representation consists of a list of the array's\n     * elements, enclosed in square brackets ({@code \"[]\"}).  Adjacent\n     * elements are separated by the characters {@code \", \"} (a comma\n     * followed by a space).  Elements are converted to strings as by\n     * {@code String.valueOf(Object)}, unless they are themselves\n     * arrays.\n     *\n     * <p>If an element {@code e} is an array of a primitive type, it is\n     * converted to a string as by invoking the appropriate overloading of\n     * {@code Arrays.toString(e)}.  If an element {@code e} is an array of a\n     * reference type, it is converted to a string as by invoking\n     * this method recursively.\n     *\n     * <p>To avoid infinite recursion, if the specified array contains itself\n     * as an element, or contains an indirect reference to itself through one\n     * or more levels of arrays, the self-reference is converted to the string\n     * {@code \"[...]\"}.  For example, an array containing only a reference\n     * to itself would be rendered as {@code \"[[...]]\"}.\n     *\n     * <p>This method returns {@code \"null\"} if the specified array\n     * is {@code null}.\n     *\n     * @param a the array whose string representation to return\n     * @return a string representation of {@code a}\n     * @see #toString(Object[])\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void deepToString(Object[] a, StringBuilder buf, Set<Object[]> dejaVu)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static void setAll(T[] array, IntFunction<? extends T> generator)",
    "returnType" : "void",
    "comment" : "\n     * Set all elements of the specified array, using the provided\n     * generator function to compute each element.\n     *\n     * <p>If the generator function throws an exception, it is relayed to\n     * the caller and the array is left in an indeterminate state.\n     *\n     * @apiNote\n     * Setting a subrange of an array, using a generator function to compute\n     * each element, can be written as follows:\n     * <pre>{@code\n     * IntStream.range(startInclusive, endExclusive)\n     *          .forEach(i -> array[i] = generator.apply(i));\n     * }</pre>\n     *\n     * @param <T> type of elements of the array\n     * @param array array to be initialized\n     * @param generator a function accepting an index and producing the desired\n     *        value for that position\n     * @throws NullPointerException if the generator is null\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void parallelSetAll(T[] array, IntFunction<? extends T> generator)",
    "returnType" : "void",
    "comment" : "\n     * Set all elements of the specified array, in parallel, using the\n     * provided generator function to compute each element.\n     *\n     * <p>If the generator function throws an exception, an unchecked exception\n     * is thrown from {@code parallelSetAll} and the array is left in an\n     * indeterminate state.\n     *\n     * @apiNote\n     * Setting a subrange of an array, in parallel, using a generator function\n     * to compute each element, can be written as follows:\n     * <pre>{@code\n     * IntStream.range(startInclusive, endExclusive)\n     *          .parallel()\n     *          .forEach(i -> array[i] = generator.apply(i));\n     * }</pre>\n     *\n     * @param <T> type of elements of the array\n     * @param array array to be initialized\n     * @param generator a function accepting an index and producing the desired\n     *        value for that position\n     * @throws NullPointerException if the generator is null\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void setAll(int[] array, IntUnaryOperator generator)",
    "returnType" : "void",
    "comment" : "\n     * Set all elements of the specified array, using the provided\n     * generator function to compute each element.\n     *\n     * <p>If the generator function throws an exception, it is relayed to\n     * the caller and the array is left in an indeterminate state.\n     *\n     * @apiNote\n     * Setting a subrange of an array, using a generator function to compute\n     * each element, can be written as follows:\n     * <pre>{@code\n     * IntStream.range(startInclusive, endExclusive)\n     *          .forEach(i -> array[i] = generator.applyAsInt(i));\n     * }</pre>\n     *\n     * @param array array to be initialized\n     * @param generator a function accepting an index and producing the desired\n     *        value for that position\n     * @throws NullPointerException if the generator is null\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void parallelSetAll(int[] array, IntUnaryOperator generator)",
    "returnType" : "void",
    "comment" : "\n     * Set all elements of the specified array, in parallel, using the\n     * provided generator function to compute each element.\n     *\n     * <p>If the generator function throws an exception, an unchecked exception\n     * is thrown from {@code parallelSetAll} and the array is left in an\n     * indeterminate state.\n     *\n     * @apiNote\n     * Setting a subrange of an array, in parallel, using a generator function\n     * to compute each element, can be written as follows:\n     * <pre>{@code\n     * IntStream.range(startInclusive, endExclusive)\n     *          .parallel()\n     *          .forEach(i -> array[i] = generator.applyAsInt(i));\n     * }</pre>\n     *\n     * @param array array to be initialized\n     * @param generator a function accepting an index and producing the desired\n     * value for that position\n     * @throws NullPointerException if the generator is null\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void setAll(long[] array, IntToLongFunction generator)",
    "returnType" : "void",
    "comment" : "\n     * Set all elements of the specified array, using the provided\n     * generator function to compute each element.\n     *\n     * <p>If the generator function throws an exception, it is relayed to\n     * the caller and the array is left in an indeterminate state.\n     *\n     * @apiNote\n     * Setting a subrange of an array, using a generator function to compute\n     * each element, can be written as follows:\n     * <pre>{@code\n     * IntStream.range(startInclusive, endExclusive)\n     *          .forEach(i -> array[i] = generator.applyAsLong(i));\n     * }</pre>\n     *\n     * @param array array to be initialized\n     * @param generator a function accepting an index and producing the desired\n     *        value for that position\n     * @throws NullPointerException if the generator is null\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void parallelSetAll(long[] array, IntToLongFunction generator)",
    "returnType" : "void",
    "comment" : "\n     * Set all elements of the specified array, in parallel, using the\n     * provided generator function to compute each element.\n     *\n     * <p>If the generator function throws an exception, an unchecked exception\n     * is thrown from {@code parallelSetAll} and the array is left in an\n     * indeterminate state.\n     *\n     * @apiNote\n     * Setting a subrange of an array, in parallel, using a generator function\n     * to compute each element, can be written as follows:\n     * <pre>{@code\n     * IntStream.range(startInclusive, endExclusive)\n     *          .parallel()\n     *          .forEach(i -> array[i] = generator.applyAsLong(i));\n     * }</pre>\n     *\n     * @param array array to be initialized\n     * @param generator a function accepting an index and producing the desired\n     *        value for that position\n     * @throws NullPointerException if the generator is null\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void setAll(double[] array, IntToDoubleFunction generator)",
    "returnType" : "void",
    "comment" : "\n     * Set all elements of the specified array, using the provided\n     * generator function to compute each element.\n     *\n     * <p>If the generator function throws an exception, it is relayed to\n     * the caller and the array is left in an indeterminate state.\n     *\n     * @apiNote\n     * Setting a subrange of an array, using a generator function to compute\n     * each element, can be written as follows:\n     * <pre>{@code\n     * IntStream.range(startInclusive, endExclusive)\n     *          .forEach(i -> array[i] = generator.applyAsDouble(i));\n     * }</pre>\n     *\n     * @param array array to be initialized\n     * @param generator a function accepting an index and producing the desired\n     *        value for that position\n     * @throws NullPointerException if the generator is null\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void parallelSetAll(double[] array, IntToDoubleFunction generator)",
    "returnType" : "void",
    "comment" : "\n     * Set all elements of the specified array, in parallel, using the\n     * provided generator function to compute each element.\n     *\n     * <p>If the generator function throws an exception, an unchecked exception\n     * is thrown from {@code parallelSetAll} and the array is left in an\n     * indeterminate state.\n     *\n     * @apiNote\n     * Setting a subrange of an array, in parallel, using a generator function\n     * to compute each element, can be written as follows:\n     * <pre>{@code\n     * IntStream.range(startInclusive, endExclusive)\n     *          .parallel()\n     *          .forEach(i -> array[i] = generator.applyAsDouble(i));\n     * }</pre>\n     *\n     * @param array array to be initialized\n     * @param generator a function accepting an index and producing the desired\n     *        value for that position\n     * @throws NullPointerException if the generator is null\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Spliterator<T> spliterator(T[] array)",
    "returnType" : "Spliterator<T>",
    "comment" : "\n     * Returns a {@link Spliterator} covering all of the specified array.\n     *\n     * <p>The spliterator reports {@link Spliterator#SIZED},\n     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and\n     * {@link Spliterator#IMMUTABLE}.\n     *\n     * @param <T> type of elements\n     * @param array the array, assumed to be unmodified during use\n     * @return a spliterator for the array elements\n     * @since 1.8\n     ",
    "links" : [ "java.util.Spliterator#SIZED", "java.util.Spliterator#IMMUTABLE", "java.util.Spliterator#SUBSIZED", "java.util.Spliterator", "java.util.Spliterator#ORDERED" ]
  }, {
    "name" : "public static Spliterator<T> spliterator(T[] array, int startInclusive, int endExclusive)",
    "returnType" : "Spliterator<T>",
    "comment" : "\n     * Returns a {@link Spliterator} covering the specified range of the\n     * specified array.\n     *\n     * <p>The spliterator reports {@link Spliterator#SIZED},\n     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and\n     * {@link Spliterator#IMMUTABLE}.\n     *\n     * @param <T> type of elements\n     * @param array the array, assumed to be unmodified during use\n     * @param startInclusive the first index to cover, inclusive\n     * @param endExclusive index immediately past the last index to cover\n     * @return a spliterator for the array elements\n     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is\n     *         negative, {@code endExclusive} is less than\n     *         {@code startInclusive}, or {@code endExclusive} is greater than\n     *         the array size\n     * @since 1.8\n     ",
    "links" : [ "java.util.Spliterator#SIZED", "java.util.Spliterator#IMMUTABLE", "java.util.Spliterator#SUBSIZED", "java.util.Spliterator", "java.util.Spliterator#ORDERED" ]
  }, {
    "name" : "public static Spliterator.OfInt spliterator(int[] array)",
    "returnType" : "Spliterator.OfInt",
    "comment" : "\n     * Returns a {@link Spliterator.OfInt} covering all of the specified array.\n     *\n     * <p>The spliterator reports {@link Spliterator#SIZED},\n     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and\n     * {@link Spliterator#IMMUTABLE}.\n     *\n     * @param array the array, assumed to be unmodified during use\n     * @return a spliterator for the array elements\n     * @since 1.8\n     ",
    "links" : [ "Spliterator.OfInt", "java.util.Spliterator#SIZED", "java.util.Spliterator#IMMUTABLE", "java.util.Spliterator#SUBSIZED", "java.util.Spliterator#ORDERED" ]
  }, {
    "name" : "public static Spliterator.OfInt spliterator(int[] array, int startInclusive, int endExclusive)",
    "returnType" : "Spliterator.OfInt",
    "comment" : "\n     * Returns a {@link Spliterator.OfInt} covering the specified range of the\n     * specified array.\n     *\n     * <p>The spliterator reports {@link Spliterator#SIZED},\n     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and\n     * {@link Spliterator#IMMUTABLE}.\n     *\n     * @param array the array, assumed to be unmodified during use\n     * @param startInclusive the first index to cover, inclusive\n     * @param endExclusive index immediately past the last index to cover\n     * @return a spliterator for the array elements\n     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is\n     *         negative, {@code endExclusive} is less than\n     *         {@code startInclusive}, or {@code endExclusive} is greater than\n     *         the array size\n     * @since 1.8\n     ",
    "links" : [ "Spliterator.OfInt", "java.util.Spliterator#SIZED", "java.util.Spliterator#IMMUTABLE", "java.util.Spliterator#SUBSIZED", "java.util.Spliterator#ORDERED" ]
  }, {
    "name" : "public static Spliterator.OfLong spliterator(long[] array)",
    "returnType" : "Spliterator.OfLong",
    "comment" : "\n     * Returns a {@link Spliterator.OfLong} covering all of the specified array.\n     *\n     * <p>The spliterator reports {@link Spliterator#SIZED},\n     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and\n     * {@link Spliterator#IMMUTABLE}.\n     *\n     * @param array the array, assumed to be unmodified during use\n     * @return the spliterator for the array elements\n     * @since 1.8\n     ",
    "links" : [ "Spliterator.OfLong", "java.util.Spliterator#SIZED", "java.util.Spliterator#IMMUTABLE", "java.util.Spliterator#SUBSIZED", "java.util.Spliterator#ORDERED" ]
  }, {
    "name" : "public static Spliterator.OfLong spliterator(long[] array, int startInclusive, int endExclusive)",
    "returnType" : "Spliterator.OfLong",
    "comment" : "\n     * Returns a {@link Spliterator.OfLong} covering the specified range of the\n     * specified array.\n     *\n     * <p>The spliterator reports {@link Spliterator#SIZED},\n     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and\n     * {@link Spliterator#IMMUTABLE}.\n     *\n     * @param array the array, assumed to be unmodified during use\n     * @param startInclusive the first index to cover, inclusive\n     * @param endExclusive index immediately past the last index to cover\n     * @return a spliterator for the array elements\n     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is\n     *         negative, {@code endExclusive} is less than\n     *         {@code startInclusive}, or {@code endExclusive} is greater than\n     *         the array size\n     * @since 1.8\n     ",
    "links" : [ "Spliterator.OfLong", "java.util.Spliterator#SIZED", "java.util.Spliterator#IMMUTABLE", "java.util.Spliterator#SUBSIZED", "java.util.Spliterator#ORDERED" ]
  }, {
    "name" : "public static Spliterator.OfDouble spliterator(double[] array)",
    "returnType" : "Spliterator.OfDouble",
    "comment" : "\n     * Returns a {@link Spliterator.OfDouble} covering all of the specified\n     * array.\n     *\n     * <p>The spliterator reports {@link Spliterator#SIZED},\n     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and\n     * {@link Spliterator#IMMUTABLE}.\n     *\n     * @param array the array, assumed to be unmodified during use\n     * @return a spliterator for the array elements\n     * @since 1.8\n     ",
    "links" : [ "Spliterator.OfDouble", "java.util.Spliterator#SIZED", "java.util.Spliterator#IMMUTABLE", "java.util.Spliterator#SUBSIZED", "java.util.Spliterator#ORDERED" ]
  }, {
    "name" : "public static Spliterator.OfDouble spliterator(double[] array, int startInclusive, int endExclusive)",
    "returnType" : "Spliterator.OfDouble",
    "comment" : "\n     * Returns a {@link Spliterator.OfDouble} covering the specified range of\n     * the specified array.\n     *\n     * <p>The spliterator reports {@link Spliterator#SIZED},\n     * {@link Spliterator#SUBSIZED}, {@link Spliterator#ORDERED}, and\n     * {@link Spliterator#IMMUTABLE}.\n     *\n     * @param array the array, assumed to be unmodified during use\n     * @param startInclusive the first index to cover, inclusive\n     * @param endExclusive index immediately past the last index to cover\n     * @return a spliterator for the array elements\n     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is\n     *         negative, {@code endExclusive} is less than\n     *         {@code startInclusive}, or {@code endExclusive} is greater than\n     *         the array size\n     * @since 1.8\n     ",
    "links" : [ "Spliterator.OfDouble", "java.util.Spliterator#SIZED", "java.util.Spliterator#IMMUTABLE", "java.util.Spliterator#SUBSIZED", "java.util.Spliterator#ORDERED" ]
  }, {
    "name" : "public static Stream<T> stream(T[] array)",
    "returnType" : "Stream<T>",
    "comment" : "\n     * Returns a sequential {@link Stream} with the specified array as its\n     * source.\n     *\n     * @param <T> The type of the array elements\n     * @param array The array, assumed to be unmodified during use\n     * @return a {@code Stream} for the array\n     * @since 1.8\n     ",
    "links" : [ "java.util.stream.DoubleStream" ]
  }, {
    "name" : "public static Stream<T> stream(T[] array, int startInclusive, int endExclusive)",
    "returnType" : "Stream<T>",
    "comment" : "\n     * Returns a sequential {@link Stream} with the specified range of the\n     * specified array as its source.\n     *\n     * @param <T> the type of the array elements\n     * @param array the array, assumed to be unmodified during use\n     * @param startInclusive the first index to cover, inclusive\n     * @param endExclusive index immediately past the last index to cover\n     * @return a {@code Stream} for the array range\n     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is\n     *         negative, {@code endExclusive} is less than\n     *         {@code startInclusive}, or {@code endExclusive} is greater than\n     *         the array size\n     * @since 1.8\n     ",
    "links" : [ "java.util.stream.DoubleStream" ]
  }, {
    "name" : "public static IntStream stream(int[] array)",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns a sequential {@link IntStream} with the specified array as its\n     * source.\n     *\n     * @param array the array, assumed to be unmodified during use\n     * @return an {@code IntStream} for the array\n     * @since 1.8\n     ",
    "links" : [ "java.util.stream.IntStream" ]
  }, {
    "name" : "public static IntStream stream(int[] array, int startInclusive, int endExclusive)",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns a sequential {@link IntStream} with the specified range of the\n     * specified array as its source.\n     *\n     * @param array the array, assumed to be unmodified during use\n     * @param startInclusive the first index to cover, inclusive\n     * @param endExclusive index immediately past the last index to cover\n     * @return an {@code IntStream} for the array range\n     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is\n     *         negative, {@code endExclusive} is less than\n     *         {@code startInclusive}, or {@code endExclusive} is greater than\n     *         the array size\n     * @since 1.8\n     ",
    "links" : [ "java.util.stream.IntStream" ]
  }, {
    "name" : "public static LongStream stream(long[] array)",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns a sequential {@link LongStream} with the specified array as its\n     * source.\n     *\n     * @param array the array, assumed to be unmodified during use\n     * @return a {@code LongStream} for the array\n     * @since 1.8\n     ",
    "links" : [ "java.util.stream.LongStream" ]
  }, {
    "name" : "public static LongStream stream(long[] array, int startInclusive, int endExclusive)",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns a sequential {@link LongStream} with the specified range of the\n     * specified array as its source.\n     *\n     * @param array the array, assumed to be unmodified during use\n     * @param startInclusive the first index to cover, inclusive\n     * @param endExclusive index immediately past the last index to cover\n     * @return a {@code LongStream} for the array range\n     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is\n     *         negative, {@code endExclusive} is less than\n     *         {@code startInclusive}, or {@code endExclusive} is greater than\n     *         the array size\n     * @since 1.8\n     ",
    "links" : [ "java.util.stream.LongStream" ]
  }, {
    "name" : "public static DoubleStream stream(double[] array)",
    "returnType" : "DoubleStream",
    "comment" : "\n     * Returns a sequential {@link DoubleStream} with the specified array as its\n     * source.\n     *\n     * @param array the array, assumed to be unmodified during use\n     * @return a {@code DoubleStream} for the array\n     * @since 1.8\n     ",
    "links" : [ "java.util.stream.DoubleStream" ]
  }, {
    "name" : "public static DoubleStream stream(double[] array, int startInclusive, int endExclusive)",
    "returnType" : "DoubleStream",
    "comment" : "\n     * Returns a sequential {@link DoubleStream} with the specified range of the\n     * specified array as its source.\n     *\n     * @param array the array, assumed to be unmodified during use\n     * @param startInclusive the first index to cover, inclusive\n     * @param endExclusive index immediately past the last index to cover\n     * @return a {@code DoubleStream} for the array range\n     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is\n     *         negative, {@code endExclusive} is less than\n     *         {@code startInclusive}, or {@code endExclusive} is greater than\n     *         the array size\n     * @since 1.8\n     ",
    "links" : [ "java.util.stream.DoubleStream" ]
  }, {
    "name" : "public static int compare(boolean[] a, boolean[] b)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code boolean} arrays lexicographically.\n     *\n     * <p>If the two arrays share a common prefix then the lexicographic\n     * comparison is the result of comparing two elements, as if by\n     * {@link Boolean#compare(boolean, boolean)}, at an index within the\n     * respective arrays that is the prefix length.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two array lengths.\n     * (See {@link #mismatch(boolean[], boolean[])} for the definition of a\n     * common and proper prefix.)\n     *\n     * <p>A {@code null} array reference is considered lexicographically less\n     * than a non-{@code null} array reference.  Two {@code null} array\n     * references are considered equal.\n     *\n     * <p>The comparison is consistent with {@link #equals(boolean[], boolean[]) equals},\n     * more specifically the following holds for arrays {@code a} and {@code b}:\n     * <pre>{@code\n     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\n     * }</pre>\n     *\n     * @apiNote\n     * <p>This method behaves as if (for non-{@code null} array references):\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, b);\n     *     if (i >= 0 && i < Math.min(a.length, b.length))\n     *         return Boolean.compare(a[i], b[i]);\n     *     return a.length - b.length;\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param b the second array to compare\n     * @return the value {@code 0} if the first and second array are equal and\n     *         contain the same elements in the same order;\n     *         a value less than {@code 0} if the first array is\n     *         lexicographically less than the second array; and\n     *         a value greater than {@code 0} if the first array is\n     *         lexicographically greater than the second array\n     * @since 9\n     ",
    "links" : [ "#equals(boolean", "#compare(boolean", "#mismatch(boolean" ]
  }, {
    "name" : "public static int compare(boolean[] a, int aFromIndex, int aToIndex, boolean[] b, int bFromIndex, int bToIndex)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code boolean} arrays lexicographically over the specified\n     * ranges.\n     *\n     * <p>If the two arrays, over the specified ranges, share a common prefix\n     * then the lexicographic comparison is the result of comparing two\n     * elements, as if by {@link Boolean#compare(boolean, boolean)}, at a\n     * relative index within the respective arrays that is the length of the\n     * prefix.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two range lengths.\n     * (See {@link #mismatch(boolean[], int, int, boolean[], int, int)} for the\n     * definition of a common and proper prefix.)\n     *\n     * <p>The comparison is consistent with\n     * {@link #equals(boolean[], int, int, boolean[], int, int) equals}, more\n     * specifically the following holds for arrays {@code a} and {@code b} with\n     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively:\n     * <pre>{@code\n     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\n     * }</pre>\n     *\n     * @apiNote\n     * <p>This method behaves as if:\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\n     *                             b, bFromIndex, bToIndex);\n     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n     *         return Boolean.compare(a[aFromIndex + i], b[bFromIndex + i]);\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be compared\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be compared\n     * @param b the second array to compare\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be compared\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be compared\n     * @return the value {@code 0} if, over the specified ranges, the first and\n     *         second array are equal and contain the same elements in the same\n     *         order;\n     *         a value less than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically less than the second array; and\n     *         a value greater than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically greater than the second array\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ "#equals(boolean", "#compare(boolean", "#mismatch(boolean" ]
  }, {
    "name" : "public static int compare(byte[] a, byte[] b)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code byte} arrays lexicographically.\n     *\n     * <p>If the two arrays share a common prefix then the lexicographic\n     * comparison is the result of comparing two elements, as if by\n     * {@link Byte#compare(byte, byte)}, at an index within the respective\n     * arrays that is the prefix length.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two array lengths.\n     * (See {@link #mismatch(byte[], byte[])} for the definition of a common and\n     * proper prefix.)\n     *\n     * <p>A {@code null} array reference is considered lexicographically less\n     * than a non-{@code null} array reference.  Two {@code null} array\n     * references are considered equal.\n     *\n     * <p>The comparison is consistent with {@link #equals(byte[], byte[]) equals},\n     * more specifically the following holds for arrays {@code a} and {@code b}:\n     * <pre>{@code\n     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\n     * }</pre>\n     *\n     * @apiNote\n     * <p>This method behaves as if (for non-{@code null} array references):\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, b);\n     *     if (i >= 0 && i < Math.min(a.length, b.length))\n     *         return Byte.compare(a[i], b[i]);\n     *     return a.length - b.length;\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param b the second array to compare\n     * @return the value {@code 0} if the first and second array are equal and\n     *         contain the same elements in the same order;\n     *         a value less than {@code 0} if the first array is\n     *         lexicographically less than the second array; and\n     *         a value greater than {@code 0} if the first array is\n     *         lexicographically greater than the second array\n     * @since 9\n     ",
    "links" : [ "#compare(byte", "#equals(byte", "#mismatch(byte" ]
  }, {
    "name" : "public static int compare(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code byte} arrays lexicographically over the specified\n     * ranges.\n     *\n     * <p>If the two arrays, over the specified ranges, share a common prefix\n     * then the lexicographic comparison is the result of comparing two\n     * elements, as if by {@link Byte#compare(byte, byte)}, at a relative index\n     * within the respective arrays that is the length of the prefix.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two range lengths.\n     * (See {@link #mismatch(byte[], int, int, byte[], int, int)} for the\n     * definition of a common and proper prefix.)\n     *\n     * <p>The comparison is consistent with\n     * {@link #equals(byte[], int, int, byte[], int, int) equals}, more\n     * specifically the following holds for arrays {@code a} and {@code b} with\n     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively:\n     * <pre>{@code\n     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\n     * }</pre>\n     *\n     * @apiNote\n     * <p>This method behaves as if:\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\n     *                             b, bFromIndex, bToIndex);\n     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n     *         return Byte.compare(a[aFromIndex + i], b[bFromIndex + i]);\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be compared\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be compared\n     * @param b the second array to compare\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be compared\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be compared\n     * @return the value {@code 0} if, over the specified ranges, the first and\n     *         second array are equal and contain the same elements in the same\n     *         order;\n     *         a value less than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically less than the second array; and\n     *         a value greater than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically greater than the second array\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ "#compare(byte", "#equals(byte", "#mismatch(byte" ]
  }, {
    "name" : "public static int compareUnsigned(byte[] a, byte[] b)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code byte} arrays lexicographically, numerically treating\n     * elements as unsigned.\n     *\n     * <p>If the two arrays share a common prefix then the lexicographic\n     * comparison is the result of comparing two elements, as if by\n     * {@link Byte#compareUnsigned(byte, byte)}, at an index within the\n     * respective arrays that is the prefix length.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two array lengths.\n     * (See {@link #mismatch(byte[], byte[])} for the definition of a common\n     * and proper prefix.)\n     *\n     * <p>A {@code null} array reference is considered lexicographically less\n     * than a non-{@code null} array reference.  Two {@code null} array\n     * references are considered equal.\n     *\n     * @apiNote\n     * <p>This method behaves as if (for non-{@code null} array references):\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, b);\n     *     if (i >= 0 && i < Math.min(a.length, b.length))\n     *         return Byte.compareUnsigned(a[i], b[i]);\n     *     return a.length - b.length;\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param b the second array to compare\n     * @return the value {@code 0} if the first and second array are\n     *         equal and contain the same elements in the same order;\n     *         a value less than {@code 0} if the first array is\n     *         lexicographically less than the second array; and\n     *         a value greater than {@code 0} if the first array is\n     *         lexicographically greater than the second array\n     * @since 9\n     ",
    "links" : [ "#compareUnsigned(byte", "#mismatch(byte" ]
  }, {
    "name" : "public static int compareUnsigned(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code byte} arrays lexicographically over the specified\n     * ranges, numerically treating elements as unsigned.\n     *\n     * <p>If the two arrays, over the specified ranges, share a common prefix\n     * then the lexicographic comparison is the result of comparing two\n     * elements, as if by {@link Byte#compareUnsigned(byte, byte)}, at a\n     * relative index within the respective arrays that is the length of the\n     * prefix.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two range lengths.\n     * (See {@link #mismatch(byte[], int, int, byte[], int, int)} for the\n     * definition of a common and proper prefix.)\n     *\n     * @apiNote\n     * <p>This method behaves as if:\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\n     *                             b, bFromIndex, bToIndex);\n     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n     *         return Byte.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be compared\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be compared\n     * @param b the second array to compare\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be compared\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be compared\n     * @return the value {@code 0} if, over the specified ranges, the first and\n     *         second array are equal and contain the same elements in the same\n     *         order;\n     *         a value less than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically less than the second array; and\n     *         a value greater than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically greater than the second array\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is null\n     * @since 9\n     ",
    "links" : [ "#compareUnsigned(byte", "#mismatch(byte" ]
  }, {
    "name" : "public static int compare(short[] a, short[] b)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code short} arrays lexicographically.\n     *\n     * <p>If the two arrays share a common prefix then the lexicographic\n     * comparison is the result of comparing two elements, as if by\n     * {@link Short#compare(short, short)}, at an index within the respective\n     * arrays that is the prefix length.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two array lengths.\n     * (See {@link #mismatch(short[], short[])} for the definition of a common\n     * and proper prefix.)\n     *\n     * <p>A {@code null} array reference is considered lexicographically less\n     * than a non-{@code null} array reference.  Two {@code null} array\n     * references are considered equal.\n     *\n     * <p>The comparison is consistent with {@link #equals(short[], short[]) equals},\n     * more specifically the following holds for arrays {@code a} and {@code b}:\n     * <pre>{@code\n     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\n     * }</pre>\n     *\n     * @apiNote\n     * <p>This method behaves as if (for non-{@code null} array references):\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, b);\n     *     if (i >= 0 && i < Math.min(a.length, b.length))\n     *         return Short.compare(a[i], b[i]);\n     *     return a.length - b.length;\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param b the second array to compare\n     * @return the value {@code 0} if the first and second array are equal and\n     *         contain the same elements in the same order;\n     *         a value less than {@code 0} if the first array is\n     *         lexicographically less than the second array; and\n     *         a value greater than {@code 0} if the first array is\n     *         lexicographically greater than the second array\n     * @since 9\n     ",
    "links" : [ "#compare(short", "#equals(short", "#mismatch(short" ]
  }, {
    "name" : "public static int compare(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code short} arrays lexicographically over the specified\n     * ranges.\n     *\n     * <p>If the two arrays, over the specified ranges, share a common prefix\n     * then the lexicographic comparison is the result of comparing two\n     * elements, as if by {@link Short#compare(short, short)}, at a relative\n     * index within the respective arrays that is the length of the prefix.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two range lengths.\n     * (See {@link #mismatch(short[], int, int, short[], int, int)} for the\n     * definition of a common and proper prefix.)\n     *\n     * <p>The comparison is consistent with\n     * {@link #equals(short[], int, int, short[], int, int) equals}, more\n     * specifically the following holds for arrays {@code a} and {@code b} with\n     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively:\n     * <pre>{@code\n     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\n     * }</pre>\n     *\n     * @apiNote\n     * <p>This method behaves as if:\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\n     *                             b, bFromIndex, bToIndex);\n     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n     *         return Short.compare(a[aFromIndex + i], b[bFromIndex + i]);\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be compared\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be compared\n     * @param b the second array to compare\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be compared\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be compared\n     * @return the value {@code 0} if, over the specified ranges, the first and\n     *         second array are equal and contain the same elements in the same\n     *         order;\n     *         a value less than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically less than the second array; and\n     *         a value greater than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically greater than the second array\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ "#compare(short", "#equals(short", "#mismatch(short" ]
  }, {
    "name" : "public static int compareUnsigned(short[] a, short[] b)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code short} arrays lexicographically, numerically treating\n     * elements as unsigned.\n     *\n     * <p>If the two arrays share a common prefix then the lexicographic\n     * comparison is the result of comparing two elements, as if by\n     * {@link Short#compareUnsigned(short, short)}, at an index within the\n     * respective arrays that is the prefix length.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two array lengths.\n     * (See {@link #mismatch(short[], short[])} for the definition of a common\n     * and proper prefix.)\n     *\n     * <p>A {@code null} array reference is considered lexicographically less\n     * than a non-{@code null} array reference.  Two {@code null} array\n     * references are considered equal.\n     *\n     * @apiNote\n     * <p>This method behaves as if (for non-{@code null} array references):\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, b);\n     *     if (i >= 0 && i < Math.min(a.length, b.length))\n     *         return Short.compareUnsigned(a[i], b[i]);\n     *     return a.length - b.length;\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param b the second array to compare\n     * @return the value {@code 0} if the first and second array are\n     *         equal and contain the same elements in the same order;\n     *         a value less than {@code 0} if the first array is\n     *         lexicographically less than the second array; and\n     *         a value greater than {@code 0} if the first array is\n     *         lexicographically greater than the second array\n     * @since 9\n     ",
    "links" : [ "#compareUnsigned(short", "#mismatch(short" ]
  }, {
    "name" : "public static int compareUnsigned(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code short} arrays lexicographically over the specified\n     * ranges, numerically treating elements as unsigned.\n     *\n     * <p>If the two arrays, over the specified ranges, share a common prefix\n     * then the lexicographic comparison is the result of comparing two\n     * elements, as if by {@link Short#compareUnsigned(short, short)}, at a\n     * relative index within the respective arrays that is the length of the\n     * prefix.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two range lengths.\n     * (See {@link #mismatch(short[], int, int, short[], int, int)} for the\n     * definition of a common and proper prefix.)\n     *\n     * @apiNote\n     * <p>This method behaves as if:\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\n     *                             b, bFromIndex, bToIndex);\n     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n     *         return Short.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be compared\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be compared\n     * @param b the second array to compare\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be compared\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be compared\n     * @return the value {@code 0} if, over the specified ranges, the first and\n     *         second array are equal and contain the same elements in the same\n     *         order;\n     *         a value less than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically less than the second array; and\n     *         a value greater than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically greater than the second array\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is null\n     * @since 9\n     ",
    "links" : [ "#compareUnsigned(short", "#mismatch(short" ]
  }, {
    "name" : "public static int compare(char[] a, char[] b)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code char} arrays lexicographically.\n     *\n     * <p>If the two arrays share a common prefix then the lexicographic\n     * comparison is the result of comparing two elements, as if by\n     * {@link Character#compare(char, char)}, at an index within the respective\n     * arrays that is the prefix length.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two array lengths.\n     * (See {@link #mismatch(char[], char[])} for the definition of a common and\n     * proper prefix.)\n     *\n     * <p>A {@code null} array reference is considered lexicographically less\n     * than a non-{@code null} array reference.  Two {@code null} array\n     * references are considered equal.\n     *\n     * <p>The comparison is consistent with {@link #equals(char[], char[]) equals},\n     * more specifically the following holds for arrays {@code a} and {@code b}:\n     * <pre>{@code\n     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\n     * }</pre>\n     *\n     * @apiNote\n     * <p>This method behaves as if (for non-{@code null} array references):\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, b);\n     *     if (i >= 0 && i < Math.min(a.length, b.length))\n     *         return Character.compare(a[i], b[i]);\n     *     return a.length - b.length;\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param b the second array to compare\n     * @return the value {@code 0} if the first and second array are equal and\n     *         contain the same elements in the same order;\n     *         a value less than {@code 0} if the first array is\n     *         lexicographically less than the second array; and\n     *         a value greater than {@code 0} if the first array is\n     *         lexicographically greater than the second array\n     * @since 9\n     ",
    "links" : [ "#equals(char", "#mismatch(char", "#compare(char" ]
  }, {
    "name" : "public static int compare(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code char} arrays lexicographically over the specified\n     * ranges.\n     *\n     * <p>If the two arrays, over the specified ranges, share a common prefix\n     * then the lexicographic comparison is the result of comparing two\n     * elements, as if by {@link Character#compare(char, char)}, at a relative\n     * index within the respective arrays that is the length of the prefix.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two range lengths.\n     * (See {@link #mismatch(char[], int, int, char[], int, int)} for the\n     * definition of a common and proper prefix.)\n     *\n     * <p>The comparison is consistent with\n     * {@link #equals(char[], int, int, char[], int, int) equals}, more\n     * specifically the following holds for arrays {@code a} and {@code b} with\n     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively:\n     * <pre>{@code\n     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\n     * }</pre>\n     *\n     * @apiNote\n     * <p>This method behaves as if:\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\n     *                             b, bFromIndex, bToIndex);\n     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n     *         return Character.compare(a[aFromIndex + i], b[bFromIndex + i]);\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be compared\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be compared\n     * @param b the second array to compare\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be compared\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be compared\n     * @return the value {@code 0} if, over the specified ranges, the first and\n     *         second array are equal and contain the same elements in the same\n     *         order;\n     *         a value less than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically less than the second array; and\n     *         a value greater than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically greater than the second array\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ "#equals(char", "#mismatch(char", "#compare(char" ]
  }, {
    "name" : "public static int compare(int[] a, int[] b)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code int} arrays lexicographically.\n     *\n     * <p>If the two arrays share a common prefix then the lexicographic\n     * comparison is the result of comparing two elements, as if by\n     * {@link Integer#compare(int, int)}, at an index within the respective\n     * arrays that is the prefix length.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two array lengths.\n     * (See {@link #mismatch(int[], int[])} for the definition of a common and\n     * proper prefix.)\n     *\n     * <p>A {@code null} array reference is considered lexicographically less\n     * than a non-{@code null} array reference.  Two {@code null} array\n     * references are considered equal.\n     *\n     * <p>The comparison is consistent with {@link #equals(int[], int[]) equals},\n     * more specifically the following holds for arrays {@code a} and {@code b}:\n     * <pre>{@code\n     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\n     * }</pre>\n     *\n     * @apiNote\n     * <p>This method behaves as if (for non-{@code null} array references):\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, b);\n     *     if (i >= 0 && i < Math.min(a.length, b.length))\n     *         return Integer.compare(a[i], b[i]);\n     *     return a.length - b.length;\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param b the second array to compare\n     * @return the value {@code 0} if the first and second array are equal and\n     *         contain the same elements in the same order;\n     *         a value less than {@code 0} if the first array is\n     *         lexicographically less than the second array; and\n     *         a value greater than {@code 0} if the first array is\n     *         lexicographically greater than the second array\n     * @since 9\n     ",
    "links" : [ "#mismatch(int", "#equals(int", "#compare(int" ]
  }, {
    "name" : "public static int compare(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code int} arrays lexicographically over the specified\n     * ranges.\n     *\n     * <p>If the two arrays, over the specified ranges, share a common prefix\n     * then the lexicographic comparison is the result of comparing two\n     * elements, as if by {@link Integer#compare(int, int)}, at a relative index\n     * within the respective arrays that is the length of the prefix.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two range lengths.\n     * (See {@link #mismatch(int[], int, int, int[], int, int)} for the\n     * definition of a common and proper prefix.)\n     *\n     * <p>The comparison is consistent with\n     * {@link #equals(int[], int, int, int[], int, int) equals}, more\n     * specifically the following holds for arrays {@code a} and {@code b} with\n     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively:\n     * <pre>{@code\n     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\n     * }</pre>\n     *\n     * @apiNote\n     * <p>This method behaves as if:\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\n     *                             b, bFromIndex, bToIndex);\n     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n     *         return Integer.compare(a[aFromIndex + i], b[bFromIndex + i]);\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be compared\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be compared\n     * @param b the second array to compare\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be compared\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be compared\n     * @return the value {@code 0} if, over the specified ranges, the first and\n     *         second array are equal and contain the same elements in the same\n     *         order;\n     *         a value less than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically less than the second array; and\n     *         a value greater than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically greater than the second array\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ "#mismatch(int", "#equals(int", "#compare(int" ]
  }, {
    "name" : "public static int compareUnsigned(int[] a, int[] b)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code int} arrays lexicographically, numerically treating\n     * elements as unsigned.\n     *\n     * <p>If the two arrays share a common prefix then the lexicographic\n     * comparison is the result of comparing two elements, as if by\n     * {@link Integer#compareUnsigned(int, int)}, at an index within the\n     * respective arrays that is the prefix length.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two array lengths.\n     * (See {@link #mismatch(int[], int[])} for the definition of a common\n     * and proper prefix.)\n     *\n     * <p>A {@code null} array reference is considered lexicographically less\n     * than a non-{@code null} array reference.  Two {@code null} array\n     * references are considered equal.\n     *\n     * @apiNote\n     * <p>This method behaves as if (for non-{@code null} array references):\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, b);\n     *     if (i >= 0 && i < Math.min(a.length, b.length))\n     *         return Integer.compareUnsigned(a[i], b[i]);\n     *     return a.length - b.length;\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param b the second array to compare\n     * @return the value {@code 0} if the first and second array are\n     *         equal and contain the same elements in the same order;\n     *         a value less than {@code 0} if the first array is\n     *         lexicographically less than the second array; and\n     *         a value greater than {@code 0} if the first array is\n     *         lexicographically greater than the second array\n     * @since 9\n     ",
    "links" : [ "#mismatch(int", "#compareUnsigned(int" ]
  }, {
    "name" : "public static int compareUnsigned(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code int} arrays lexicographically over the specified\n     * ranges, numerically treating elements as unsigned.\n     *\n     * <p>If the two arrays, over the specified ranges, share a common prefix\n     * then the lexicographic comparison is the result of comparing two\n     * elements, as if by {@link Integer#compareUnsigned(int, int)}, at a\n     * relative index within the respective arrays that is the length of the\n     * prefix.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two range lengths.\n     * (See {@link #mismatch(int[], int, int, int[], int, int)} for the\n     * definition of a common and proper prefix.)\n     *\n     * @apiNote\n     * <p>This method behaves as if:\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\n     *                             b, bFromIndex, bToIndex);\n     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n     *         return Integer.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be compared\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be compared\n     * @param b the second array to compare\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be compared\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be compared\n     * @return the value {@code 0} if, over the specified ranges, the first and\n     *         second array are equal and contain the same elements in the same\n     *         order;\n     *         a value less than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically less than the second array; and\n     *         a value greater than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically greater than the second array\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is null\n     * @since 9\n     ",
    "links" : [ "#mismatch(int", "#compareUnsigned(int" ]
  }, {
    "name" : "public static int compare(long[] a, long[] b)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code long} arrays lexicographically.\n     *\n     * <p>If the two arrays share a common prefix then the lexicographic\n     * comparison is the result of comparing two elements, as if by\n     * {@link Long#compare(long, long)}, at an index within the respective\n     * arrays that is the prefix length.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two array lengths.\n     * (See {@link #mismatch(long[], long[])} for the definition of a common and\n     * proper prefix.)\n     *\n     * <p>A {@code null} array reference is considered lexicographically less\n     * than a non-{@code null} array reference.  Two {@code null} array\n     * references are considered equal.\n     *\n     * <p>The comparison is consistent with {@link #equals(long[], long[]) equals},\n     * more specifically the following holds for arrays {@code a} and {@code b}:\n     * <pre>{@code\n     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\n     * }</pre>\n     *\n     * @apiNote\n     * <p>This method behaves as if (for non-{@code null} array references):\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, b);\n     *     if (i >= 0 && i < Math.min(a.length, b.length))\n     *         return Long.compare(a[i], b[i]);\n     *     return a.length - b.length;\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param b the second array to compare\n     * @return the value {@code 0} if the first and second array are equal and\n     *         contain the same elements in the same order;\n     *         a value less than {@code 0} if the first array is\n     *         lexicographically less than the second array; and\n     *         a value greater than {@code 0} if the first array is\n     *         lexicographically greater than the second array\n     * @since 9\n     ",
    "links" : [ "#compare(long", "#mismatch(long", "#equals(long" ]
  }, {
    "name" : "public static int compare(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code long} arrays lexicographically over the specified\n     * ranges.\n     *\n     * <p>If the two arrays, over the specified ranges, share a common prefix\n     * then the lexicographic comparison is the result of comparing two\n     * elements, as if by {@link Long#compare(long, long)}, at a relative index\n     * within the respective arrays that is the length of the prefix.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two range lengths.\n     * (See {@link #mismatch(long[], int, int, long[], int, int)} for the\n     * definition of a common and proper prefix.)\n     *\n     * <p>The comparison is consistent with\n     * {@link #equals(long[], int, int, long[], int, int) equals}, more\n     * specifically the following holds for arrays {@code a} and {@code b} with\n     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively:\n     * <pre>{@code\n     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\n     * }</pre>\n     *\n     * @apiNote\n     * <p>This method behaves as if:\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\n     *                             b, bFromIndex, bToIndex);\n     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n     *         return Long.compare(a[aFromIndex + i], b[bFromIndex + i]);\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be compared\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be compared\n     * @param b the second array to compare\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be compared\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be compared\n     * @return the value {@code 0} if, over the specified ranges, the first and\n     *         second array are equal and contain the same elements in the same\n     *         order;\n     *         a value less than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically less than the second array; and\n     *         a value greater than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically greater than the second array\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ "#compare(long", "#mismatch(long", "#equals(long" ]
  }, {
    "name" : "public static int compareUnsigned(long[] a, long[] b)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code long} arrays lexicographically, numerically treating\n     * elements as unsigned.\n     *\n     * <p>If the two arrays share a common prefix then the lexicographic\n     * comparison is the result of comparing two elements, as if by\n     * {@link Long#compareUnsigned(long, long)}, at an index within the\n     * respective arrays that is the prefix length.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two array lengths.\n     * (See {@link #mismatch(long[], long[])} for the definition of a common\n     * and proper prefix.)\n     *\n     * <p>A {@code null} array reference is considered lexicographically less\n     * than a non-{@code null} array reference.  Two {@code null} array\n     * references are considered equal.\n     *\n     * @apiNote\n     * <p>This method behaves as if (for non-{@code null} array references):\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, b);\n     *     if (i >= 0 && i < Math.min(a.length, b.length))\n     *         return Long.compareUnsigned(a[i], b[i]);\n     *     return a.length - b.length;\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param b the second array to compare\n     * @return the value {@code 0} if the first and second array are\n     *         equal and contain the same elements in the same order;\n     *         a value less than {@code 0} if the first array is\n     *         lexicographically less than the second array; and\n     *         a value greater than {@code 0} if the first array is\n     *         lexicographically greater than the second array\n     * @since 9\n     ",
    "links" : [ "#compareUnsigned(long", "#mismatch(long" ]
  }, {
    "name" : "public static int compareUnsigned(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code long} arrays lexicographically over the specified\n     * ranges, numerically treating elements as unsigned.\n     *\n     * <p>If the two arrays, over the specified ranges, share a common prefix\n     * then the lexicographic comparison is the result of comparing two\n     * elements, as if by {@link Long#compareUnsigned(long, long)}, at a\n     * relative index within the respective arrays that is the length of the\n     * prefix.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two range lengths.\n     * (See {@link #mismatch(long[], int, int, long[], int, int)} for the\n     * definition of a common and proper prefix.)\n     *\n     * @apiNote\n     * <p>This method behaves as if:\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\n     *                             b, bFromIndex, bToIndex);\n     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n     *         return Long.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be compared\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be compared\n     * @param b the second array to compare\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be compared\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be compared\n     * @return the value {@code 0} if, over the specified ranges, the first and\n     *         second array are equal and contain the same elements in the same\n     *         order;\n     *         a value less than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically less than the second array; and\n     *         a value greater than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically greater than the second array\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is null\n     * @since 9\n     ",
    "links" : [ "#compareUnsigned(long", "#mismatch(long" ]
  }, {
    "name" : "public static int compare(float[] a, float[] b)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code float} arrays lexicographically.\n     *\n     * <p>If the two arrays share a common prefix then the lexicographic\n     * comparison is the result of comparing two elements, as if by\n     * {@link Float#compare(float, float)}, at an index within the respective\n     * arrays that is the prefix length.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two array lengths.\n     * (See {@link #mismatch(float[], float[])} for the definition of a common\n     * and proper prefix.)\n     *\n     * <p>A {@code null} array reference is considered lexicographically less\n     * than a non-{@code null} array reference.  Two {@code null} array\n     * references are considered equal.\n     *\n     * <p>The comparison is consistent with {@link #equals(float[], float[]) equals},\n     * more specifically the following holds for arrays {@code a} and {@code b}:\n     * <pre>{@code\n     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\n     * }</pre>\n     *\n     * @apiNote\n     * <p>This method behaves as if (for non-{@code null} array references):\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, b);\n     *     if (i >= 0 && i < Math.min(a.length, b.length))\n     *         return Float.compare(a[i], b[i]);\n     *     return a.length - b.length;\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param b the second array to compare\n     * @return the value {@code 0} if the first and second array are equal and\n     *         contain the same elements in the same order;\n     *         a value less than {@code 0} if the first array is\n     *         lexicographically less than the second array; and\n     *         a value greater than {@code 0} if the first array is\n     *         lexicographically greater than the second array\n     * @since 9\n     ",
    "links" : [ "#compare(float", "#equals(float", "#mismatch(float" ]
  }, {
    "name" : "public static int compare(float[] a, int aFromIndex, int aToIndex, float[] b, int bFromIndex, int bToIndex)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code float} arrays lexicographically over the specified\n     * ranges.\n     *\n     * <p>If the two arrays, over the specified ranges, share a common prefix\n     * then the lexicographic comparison is the result of comparing two\n     * elements, as if by {@link Float#compare(float, float)}, at a relative\n     * index within the respective arrays that is the length of the prefix.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two range lengths.\n     * (See {@link #mismatch(float[], int, int, float[], int, int)} for the\n     * definition of a common and proper prefix.)\n     *\n     * <p>The comparison is consistent with\n     * {@link #equals(float[], int, int, float[], int, int) equals}, more\n     * specifically the following holds for arrays {@code a} and {@code b} with\n     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively:\n     * <pre>{@code\n     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\n     * }</pre>\n     *\n     * @apiNote\n     * <p>This method behaves as if:\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\n     *                             b, bFromIndex, bToIndex);\n     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n     *         return Float.compare(a[aFromIndex + i], b[bFromIndex + i]);\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be compared\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be compared\n     * @param b the second array to compare\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be compared\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be compared\n     * @return the value {@code 0} if, over the specified ranges, the first and\n     *         second array are equal and contain the same elements in the same\n     *         order;\n     *         a value less than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically less than the second array; and\n     *         a value greater than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically greater than the second array\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ "#compare(float", "#equals(float", "#mismatch(float" ]
  }, {
    "name" : "public static int compare(double[] a, double[] b)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code double} arrays lexicographically.\n     *\n     * <p>If the two arrays share a common prefix then the lexicographic\n     * comparison is the result of comparing two elements, as if by\n     * {@link Double#compare(double, double)}, at an index within the respective\n     * arrays that is the prefix length.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two array lengths.\n     * (See {@link #mismatch(double[], double[])} for the definition of a common\n     * and proper prefix.)\n     *\n     * <p>A {@code null} array reference is considered lexicographically less\n     * than a non-{@code null} array reference.  Two {@code null} array\n     * references are considered equal.\n     *\n     * <p>The comparison is consistent with {@link #equals(double[], double[]) equals},\n     * more specifically the following holds for arrays {@code a} and {@code b}:\n     * <pre>{@code\n     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\n     * }</pre>\n     *\n     * @apiNote\n     * <p>This method behaves as if (for non-{@code null} array references):\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, b);\n     *     if (i >= 0 && i < Math.min(a.length, b.length))\n     *         return Double.compare(a[i], b[i]);\n     *     return a.length - b.length;\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param b the second array to compare\n     * @return the value {@code 0} if the first and second array are equal and\n     *         contain the same elements in the same order;\n     *         a value less than {@code 0} if the first array is\n     *         lexicographically less than the second array; and\n     *         a value greater than {@code 0} if the first array is\n     *         lexicographically greater than the second array\n     * @since 9\n     ",
    "links" : [ "#equals(double", "#compare(double", "#mismatch(double" ]
  }, {
    "name" : "public static int compare(double[] a, int aFromIndex, int aToIndex, double[] b, int bFromIndex, int bToIndex)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code double} arrays lexicographically over the specified\n     * ranges.\n     *\n     * <p>If the two arrays, over the specified ranges, share a common prefix\n     * then the lexicographic comparison is the result of comparing two\n     * elements, as if by {@link Double#compare(double, double)}, at a relative\n     * index within the respective arrays that is the length of the prefix.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two range lengths.\n     * (See {@link #mismatch(double[], int, int, double[], int, int)} for the\n     * definition of a common and proper prefix.)\n     *\n     * <p>The comparison is consistent with\n     * {@link #equals(double[], int, int, double[], int, int) equals}, more\n     * specifically the following holds for arrays {@code a} and {@code b} with\n     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively:\n     * <pre>{@code\n     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\n     * }</pre>\n     *\n     * @apiNote\n     * <p>This method behaves as if:\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\n     *                             b, bFromIndex, bToIndex);\n     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n     *         return Double.compare(a[aFromIndex + i], b[bFromIndex + i]);\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be compared\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be compared\n     * @param b the second array to compare\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be compared\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be compared\n     * @return the value {@code 0} if, over the specified ranges, the first and\n     *         second array are equal and contain the same elements in the same\n     *         order;\n     *         a value less than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically less than the second array; and\n     *         a value greater than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically greater than the second array\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ "#equals(double", "#compare(double", "#mismatch(double" ]
  }, {
    "name" : "public static int compare(T[] a, T[] b)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code Object} arrays, within comparable elements,\n     * lexicographically.\n     *\n     * <p>If the two arrays share a common prefix then the lexicographic\n     * comparison is the result of comparing two elements of type {@code T} at\n     * an index {@code i} within the respective arrays that is the prefix\n     * length, as if by:\n     * <pre>{@code\n     *     Comparator.nullsFirst(Comparator.<T>naturalOrder()).\n     *         compare(a[i], b[i])\n     * }</pre>\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two array lengths.\n     * (See {@link #mismatch(Object[], Object[])} for the definition of a common\n     * and proper prefix.)\n     *\n     * <p>A {@code null} array reference is considered lexicographically less\n     * than a non-{@code null} array reference. Two {@code null} array\n     * references are considered equal.\n     * A {@code null} array element is considered lexicographically less than a\n     * non-{@code null} array element. Two {@code null} array elements are\n     * considered equal.\n     *\n     * <p>The comparison is consistent with {@link #equals(Object[], Object[]) equals},\n     * more specifically the following holds for arrays {@code a} and {@code b}:\n     * <pre>{@code\n     *     Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)\n     * }</pre>\n     *\n     * @apiNote\n     * <p>This method behaves as if (for non-{@code null} array references\n     * and elements):\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, b);\n     *     if (i >= 0 && i < Math.min(a.length, b.length))\n     *         return a[i].compareTo(b[i]);\n     *     return a.length - b.length;\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param b the second array to compare\n     * @param <T> the type of comparable array elements\n     * @return the value {@code 0} if the first and second array are equal and\n     *         contain the same elements in the same order;\n     *         a value less than {@code 0} if the first array is\n     *         lexicographically less than the second array; and\n     *         a value greater than {@code 0} if the first array is\n     *         lexicographically greater than the second array\n     * @since 9\n     ",
    "links" : [ "#mismatch(Object", "#equals(Object" ]
  }, {
    "name" : "public static int compare(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code Object} arrays lexicographically over the specified\n     * ranges.\n     *\n     * <p>If the two arrays, over the specified ranges, share a common prefix\n     * then the lexicographic comparison is the result of comparing two\n     * elements of type {@code T} at a relative index {@code i} within the\n     * respective arrays that is the prefix length, as if by:\n     * <pre>{@code\n     *     Comparator.nullsFirst(Comparator.<T>naturalOrder()).\n     *         compare(a[aFromIndex + i, b[bFromIndex + i])\n     * }</pre>\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two range lengths.\n     * (See {@link #mismatch(Object[], int, int, Object[], int, int)} for the\n     * definition of a common and proper prefix.)\n     *\n     * <p>The comparison is consistent with\n     * {@link #equals(Object[], int, int, Object[], int, int) equals}, more\n     * specifically the following holds for arrays {@code a} and {@code b} with\n     * specified ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively:\n     * <pre>{@code\n     *     Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==\n     *         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)\n     * }</pre>\n     *\n     * @apiNote\n     * <p>This method behaves as if (for non-{@code null} array elements):\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\n     *                             b, bFromIndex, bToIndex);\n     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n     *         return a[aFromIndex + i].compareTo(b[bFromIndex + i]);\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be compared\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be compared\n     * @param b the second array to compare\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be compared\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be compared\n     * @param <T> the type of comparable array elements\n     * @return the value {@code 0} if, over the specified ranges, the first and\n     *         second array are equal and contain the same elements in the same\n     *         order;\n     *         a value less than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically less than the second array; and\n     *         a value greater than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically greater than the second array\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ "#mismatch(Object", "#equals(Object" ]
  }, {
    "name" : "public static int compare(T[] a, T[] b, Comparator<? super T> cmp)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code Object} arrays lexicographically using a specified\n     * comparator.\n     *\n     * <p>If the two arrays share a common prefix then the lexicographic\n     * comparison is the result of comparing with the specified comparator two\n     * elements at an index within the respective arrays that is the prefix\n     * length.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two array lengths.\n     * (See {@link #mismatch(Object[], Object[])} for the definition of a common\n     * and proper prefix.)\n     *\n     * <p>A {@code null} array reference is considered lexicographically less\n     * than a non-{@code null} array reference.  Two {@code null} array\n     * references are considered equal.\n     *\n     * @apiNote\n     * <p>This method behaves as if (for non-{@code null} array references):\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, b, cmp);\n     *     if (i >= 0 && i < Math.min(a.length, b.length))\n     *         return cmp.compare(a[i], b[i]);\n     *     return a.length - b.length;\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param b the second array to compare\n     * @param cmp the comparator to compare array elements\n     * @param <T> the type of array elements\n     * @return the value {@code 0} if the first and second array are equal and\n     *         contain the same elements in the same order;\n     *         a value less than {@code 0} if the first array is\n     *         lexicographically less than the second array; and\n     *         a value greater than {@code 0} if the first array is\n     *         lexicographically greater than the second array\n     * @throws NullPointerException if the comparator is {@code null}\n     * @since 9\n     ",
    "links" : [ "#mismatch(Object" ]
  }, {
    "name" : "public static int compare(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator<? super T> cmp)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code Object} arrays lexicographically over the specified\n     * ranges.\n     *\n     * <p>If the two arrays, over the specified ranges, share a common prefix\n     * then the lexicographic comparison is the result of comparing with the\n     * specified comparator two elements at a relative index within the\n     * respective arrays that is the prefix length.\n     * Otherwise, one array is a proper prefix of the other and, lexicographic\n     * comparison is the result of comparing the two range lengths.\n     * (See {@link #mismatch(Object[], int, int, Object[], int, int)} for the\n     * definition of a common and proper prefix.)\n     *\n     * @apiNote\n     * <p>This method behaves as if (for non-{@code null} array elements):\n     * <pre>{@code\n     *     int i = Arrays.mismatch(a, aFromIndex, aToIndex,\n     *                             b, bFromIndex, bToIndex, cmp);\n     *     if (i >= 0 && i < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n     *         return cmp.compare(a[aFromIndex + i], b[bFromIndex + i]);\n     *     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);\n     * }</pre>\n     *\n     * @param a the first array to compare\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be compared\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be compared\n     * @param b the second array to compare\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be compared\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be compared\n     * @param cmp the comparator to compare array elements\n     * @param <T> the type of array elements\n     * @return the value {@code 0} if, over the specified ranges, the first and\n     *         second array are equal and contain the same elements in the same\n     *         order;\n     *         a value less than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically less than the second array; and\n     *         a value greater than {@code 0} if, over the specified ranges, the\n     *         first array is lexicographically greater than the second array\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array or the comparator is {@code null}\n     * @since 9\n     ",
    "links" : [ "#mismatch(Object" ]
  }, {
    "name" : "public static int mismatch(boolean[] a, boolean[] b)",
    "returnType" : "int",
    "comment" : "\n     * Finds and returns the index of the first mismatch between two\n     * {@code boolean} arrays, otherwise return -1 if no mismatch is found.  The\n     * index will be in the range of 0 (inclusive) up to the length (inclusive)\n     * of the smaller array.\n     *\n     * <p>If the two arrays share a common prefix then the returned index is the\n     * length of the common prefix and it follows that there is a mismatch\n     * between the two elements at that index within the respective arrays.\n     * If one array is a proper prefix of the other then the returned index is\n     * the length of the smaller array and it follows that the index is only\n     * valid for the larger array.\n     * Otherwise, there is no mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a common\n     * prefix of length {@code pl} if the following expression is true:\n     * <pre>{@code\n     *     pl >= 0 &&\n     *     pl < Math.min(a.length, b.length) &&\n     *     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     *     a[pl] != b[pl]\n     * }</pre>\n     * Note that a common prefix length of {@code 0} indicates that the first\n     * elements from each array mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a proper\n     * prefix if the following expression is true:\n     * <pre>{@code\n     *     a.length != b.length &&\n     *     Arrays.equals(a, 0, Math.min(a.length, b.length),\n     *                   b, 0, Math.min(a.length, b.length))\n     * }</pre>\n     *\n     * @param a the first array to be tested for a mismatch\n     * @param b the second array to be tested for a mismatch\n     * @return the index of the first mismatch between the two arrays,\n     *         otherwise {@code -1}.\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int mismatch(boolean[] a, int aFromIndex, int aToIndex, boolean[] b, int bFromIndex, int bToIndex)",
    "returnType" : "int",
    "comment" : "\n     * Finds and returns the relative index of the first mismatch between two\n     * {@code boolean} arrays over the specified ranges, otherwise return -1 if\n     * no mismatch is found.  The index will be in the range of 0 (inclusive) up\n     * to the length (inclusive) of the smaller range.\n     *\n     * <p>If the two arrays, over the specified ranges, share a common prefix\n     * then the returned relative index is the length of the common prefix and\n     * it follows that there is a mismatch between the two elements at that\n     * relative index within the respective arrays.\n     * If one array is a proper prefix of the other, over the specified ranges,\n     * then the returned relative index is the length of the smaller range and\n     * it follows that the relative index is only valid for the array with the\n     * larger range.\n     * Otherwise, there is no mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common\n     * prefix of length {@code pl} if the following expression is true:\n     * <pre>{@code\n     *     pl >= 0 &&\n     *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     *     a[aFromIndex + pl] != b[bFromIndex + pl]\n     * }</pre>\n     * Note that a common prefix length of {@code 0} indicates that the first\n     * elements from each array mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper\n     * prefix if the following expression is true:\n     * <pre>{@code\n     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n     * }</pre>\n     *\n     * @param a the first array to be tested for a mismatch\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be tested\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be tested\n     * @param b the second array to be tested for a mismatch\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be tested\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be tested\n     * @return the relative index of the first mismatch between the two arrays\n     *         over the specified ranges, otherwise {@code -1}.\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int mismatch(byte[] a, byte[] b)",
    "returnType" : "int",
    "comment" : "\n     * Finds and returns the index of the first mismatch between two {@code byte}\n     * arrays, otherwise return -1 if no mismatch is found.  The index will be\n     * in the range of 0 (inclusive) up to the length (inclusive) of the smaller\n     * array.\n     *\n     * <p>If the two arrays share a common prefix then the returned index is the\n     * length of the common prefix and it follows that there is a mismatch\n     * between the two elements at that index within the respective arrays.\n     * If one array is a proper prefix of the other then the returned index is\n     * the length of the smaller array and it follows that the index is only\n     * valid for the larger array.\n     * Otherwise, there is no mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a common\n     * prefix of length {@code pl} if the following expression is true:\n     * <pre>{@code\n     *     pl >= 0 &&\n     *     pl < Math.min(a.length, b.length) &&\n     *     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     *     a[pl] != b[pl]\n     * }</pre>\n     * Note that a common prefix length of {@code 0} indicates that the first\n     * elements from each array mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a proper\n     * prefix if the following expression is true:\n     * <pre>{@code\n     *     a.length != b.length &&\n     *     Arrays.equals(a, 0, Math.min(a.length, b.length),\n     *                   b, 0, Math.min(a.length, b.length))\n     * }</pre>\n     *\n     * @param a the first array to be tested for a mismatch\n     * @param b the second array to be tested for a mismatch\n     * @return the index of the first mismatch between the two arrays,\n     *         otherwise {@code -1}.\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int mismatch(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)",
    "returnType" : "int",
    "comment" : "\n     * Finds and returns the relative index of the first mismatch between two\n     * {@code byte} arrays over the specified ranges, otherwise return -1 if no\n     * mismatch is found.  The index will be in the range of 0 (inclusive) up to\n     * the length (inclusive) of the smaller range.\n     *\n     * <p>If the two arrays, over the specified ranges, share a common prefix\n     * then the returned relative index is the length of the common prefix and\n     * it follows that there is a mismatch between the two elements at that\n     * relative index within the respective arrays.\n     * If one array is a proper prefix of the other, over the specified ranges,\n     * then the returned relative index is the length of the smaller range and\n     * it follows that the relative index is only valid for the array with the\n     * larger range.\n     * Otherwise, there is no mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common\n     * prefix of length {@code pl} if the following expression is true:\n     * <pre>{@code\n     *     pl >= 0 &&\n     *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     *     a[aFromIndex + pl] != b[bFromIndex + pl]\n     * }</pre>\n     * Note that a common prefix length of {@code 0} indicates that the first\n     * elements from each array mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper\n     * prefix if the following expression is true:\n     * <pre>{@code\n     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n     * }</pre>\n     *\n     * @param a the first array to be tested for a mismatch\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be tested\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be tested\n     * @param b the second array to be tested for a mismatch\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be tested\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be tested\n     * @return the relative index of the first mismatch between the two arrays\n     *         over the specified ranges, otherwise {@code -1}.\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int mismatch(char[] a, char[] b)",
    "returnType" : "int",
    "comment" : "\n     * Finds and returns the index of the first mismatch between two {@code char}\n     * arrays, otherwise return -1 if no mismatch is found.  The index will be\n     * in the range of 0 (inclusive) up to the length (inclusive) of the smaller\n     * array.\n     *\n     * <p>If the two arrays share a common prefix then the returned index is the\n     * length of the common prefix and it follows that there is a mismatch\n     * between the two elements at that index within the respective arrays.\n     * If one array is a proper prefix of the other then the returned index is\n     * the length of the smaller array and it follows that the index is only\n     * valid for the larger array.\n     * Otherwise, there is no mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a common\n     * prefix of length {@code pl} if the following expression is true:\n     * <pre>{@code\n     *     pl >= 0 &&\n     *     pl < Math.min(a.length, b.length) &&\n     *     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     *     a[pl] != b[pl]\n     * }</pre>\n     * Note that a common prefix length of {@code 0} indicates that the first\n     * elements from each array mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a proper\n     * prefix if the following expression is true:\n     * <pre>{@code\n     *     a.length != b.length &&\n     *     Arrays.equals(a, 0, Math.min(a.length, b.length),\n     *                   b, 0, Math.min(a.length, b.length))\n     * }</pre>\n     *\n     * @param a the first array to be tested for a mismatch\n     * @param b the second array to be tested for a mismatch\n     * @return the index of the first mismatch between the two arrays,\n     *         otherwise {@code -1}.\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int mismatch(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex)",
    "returnType" : "int",
    "comment" : "\n     * Finds and returns the relative index of the first mismatch between two\n     * {@code char} arrays over the specified ranges, otherwise return -1 if no\n     * mismatch is found.  The index will be in the range of 0 (inclusive) up to\n     * the length (inclusive) of the smaller range.\n     *\n     * <p>If the two arrays, over the specified ranges, share a common prefix\n     * then the returned relative index is the length of the common prefix and\n     * it follows that there is a mismatch between the two elements at that\n     * relative index within the respective arrays.\n     * If one array is a proper prefix of the other, over the specified ranges,\n     * then the returned relative index is the length of the smaller range and\n     * it follows that the relative index is only valid for the array with the\n     * larger range.\n     * Otherwise, there is no mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common\n     * prefix of length {@code pl} if the following expression is true:\n     * <pre>{@code\n     *     pl >= 0 &&\n     *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     *     a[aFromIndex + pl] != b[bFromIndex + pl]\n     * }</pre>\n     * Note that a common prefix length of {@code 0} indicates that the first\n     * elements from each array mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper\n     * prefix if the following expression is true:\n     * <pre>{@code\n     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n     * }</pre>\n     *\n     * @param a the first array to be tested for a mismatch\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be tested\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be tested\n     * @param b the second array to be tested for a mismatch\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be tested\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be tested\n     * @return the relative index of the first mismatch between the two arrays\n     *         over the specified ranges, otherwise {@code -1}.\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int mismatch(short[] a, short[] b)",
    "returnType" : "int",
    "comment" : "\n     * Finds and returns the index of the first mismatch between two {@code short}\n     * arrays, otherwise return -1 if no mismatch is found.  The index will be\n     * in the range of 0 (inclusive) up to the length (inclusive) of the smaller\n     * array.\n     *\n     * <p>If the two arrays share a common prefix then the returned index is the\n     * length of the common prefix and it follows that there is a mismatch\n     * between the two elements at that index within the respective arrays.\n     * If one array is a proper prefix of the other then the returned index is\n     * the length of the smaller array and it follows that the index is only\n     * valid for the larger array.\n     * Otherwise, there is no mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a common\n     * prefix of length {@code pl} if the following expression is true:\n     * <pre>{@code\n     *     pl >= 0 &&\n     *     pl < Math.min(a.length, b.length) &&\n     *     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     *     a[pl] != b[pl]\n     * }</pre>\n     * Note that a common prefix length of {@code 0} indicates that the first\n     * elements from each array mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a proper\n     * prefix if the following expression is true:\n     * <pre>{@code\n     *     a.length != b.length &&\n     *     Arrays.equals(a, 0, Math.min(a.length, b.length),\n     *                   b, 0, Math.min(a.length, b.length))\n     * }</pre>\n     *\n     * @param a the first array to be tested for a mismatch\n     * @param b the second array to be tested for a mismatch\n     * @return the index of the first mismatch between the two arrays,\n     *         otherwise {@code -1}.\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int mismatch(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)",
    "returnType" : "int",
    "comment" : "\n     * Finds and returns the relative index of the first mismatch between two\n     * {@code short} arrays over the specified ranges, otherwise return -1 if no\n     * mismatch is found.  The index will be in the range of 0 (inclusive) up to\n     * the length (inclusive) of the smaller range.\n     *\n     * <p>If the two arrays, over the specified ranges, share a common prefix\n     * then the returned relative index is the length of the common prefix and\n     * it follows that there is a mismatch between the two elements at that\n     * relative index within the respective arrays.\n     * If one array is a proper prefix of the other, over the specified ranges,\n     * then the returned relative index is the length of the smaller range and\n     * it follows that the relative index is only valid for the array with the\n     * larger range.\n     * Otherwise, there is no mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common\n     * prefix of length {@code pl} if the following expression is true:\n     * <pre>{@code\n     *     pl >= 0 &&\n     *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     *     a[aFromIndex + pl] != b[bFromIndex + pl]\n     * }</pre>\n     * Note that a common prefix length of {@code 0} indicates that the first\n     * elements from each array mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper\n     * prefix if the following expression is true:\n     * <pre>{@code\n     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n     * }</pre>\n     *\n     * @param a the first array to be tested for a mismatch\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be tested\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be tested\n     * @param b the second array to be tested for a mismatch\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be tested\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be tested\n     * @return the relative index of the first mismatch between the two arrays\n     *         over the specified ranges, otherwise {@code -1}.\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int mismatch(int[] a, int[] b)",
    "returnType" : "int",
    "comment" : "\n     * Finds and returns the index of the first mismatch between two {@code int}\n     * arrays, otherwise return -1 if no mismatch is found.  The index will be\n     * in the range of 0 (inclusive) up to the length (inclusive) of the smaller\n     * array.\n     *\n     * <p>If the two arrays share a common prefix then the returned index is the\n     * length of the common prefix and it follows that there is a mismatch\n     * between the two elements at that index within the respective arrays.\n     * If one array is a proper prefix of the other then the returned index is\n     * the length of the smaller array and it follows that the index is only\n     * valid for the larger array.\n     * Otherwise, there is no mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a common\n     * prefix of length {@code pl} if the following expression is true:\n     * <pre>{@code\n     *     pl >= 0 &&\n     *     pl < Math.min(a.length, b.length) &&\n     *     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     *     a[pl] != b[pl]\n     * }</pre>\n     * Note that a common prefix length of {@code 0} indicates that the first\n     * elements from each array mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a proper\n     * prefix if the following expression is true:\n     * <pre>{@code\n     *     a.length != b.length &&\n     *     Arrays.equals(a, 0, Math.min(a.length, b.length),\n     *                   b, 0, Math.min(a.length, b.length))\n     * }</pre>\n     *\n     * @param a the first array to be tested for a mismatch\n     * @param b the second array to be tested for a mismatch\n     * @return the index of the first mismatch between the two arrays,\n     *         otherwise {@code -1}.\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int mismatch(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)",
    "returnType" : "int",
    "comment" : "\n     * Finds and returns the relative index of the first mismatch between two\n     * {@code int} arrays over the specified ranges, otherwise return -1 if no\n     * mismatch is found.  The index will be in the range of 0 (inclusive) up to\n     * the length (inclusive) of the smaller range.\n     *\n     * <p>If the two arrays, over the specified ranges, share a common prefix\n     * then the returned relative index is the length of the common prefix and\n     * it follows that there is a mismatch between the two elements at that\n     * relative index within the respective arrays.\n     * If one array is a proper prefix of the other, over the specified ranges,\n     * then the returned relative index is the length of the smaller range and\n     * it follows that the relative index is only valid for the array with the\n     * larger range.\n     * Otherwise, there is no mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common\n     * prefix of length {@code pl} if the following expression is true:\n     * <pre>{@code\n     *     pl >= 0 &&\n     *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     *     a[aFromIndex + pl] != b[bFromIndex + pl]\n     * }</pre>\n     * Note that a common prefix length of {@code 0} indicates that the first\n     * elements from each array mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper\n     * prefix if the following expression is true:\n     * <pre>{@code\n     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n     * }</pre>\n     *\n     * @param a the first array to be tested for a mismatch\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be tested\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be tested\n     * @param b the second array to be tested for a mismatch\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be tested\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be tested\n     * @return the relative index of the first mismatch between the two arrays\n     *         over the specified ranges, otherwise {@code -1}.\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int mismatch(long[] a, long[] b)",
    "returnType" : "int",
    "comment" : "\n     * Finds and returns the index of the first mismatch between two {@code long}\n     * arrays, otherwise return -1 if no mismatch is found.  The index will be\n     * in the range of 0 (inclusive) up to the length (inclusive) of the smaller\n     * array.\n     *\n     * <p>If the two arrays share a common prefix then the returned index is the\n     * length of the common prefix and it follows that there is a mismatch\n     * between the two elements at that index within the respective arrays.\n     * If one array is a proper prefix of the other then the returned index is\n     * the length of the smaller array and it follows that the index is only\n     * valid for the larger array.\n     * Otherwise, there is no mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a common\n     * prefix of length {@code pl} if the following expression is true:\n     * <pre>{@code\n     *     pl >= 0 &&\n     *     pl < Math.min(a.length, b.length) &&\n     *     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     *     a[pl] != b[pl]\n     * }</pre>\n     * Note that a common prefix length of {@code 0} indicates that the first\n     * elements from each array mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a proper\n     * prefix if the following expression is true:\n     * <pre>{@code\n     *     a.length != b.length &&\n     *     Arrays.equals(a, 0, Math.min(a.length, b.length),\n     *                   b, 0, Math.min(a.length, b.length))\n     * }</pre>\n     *\n     * @param a the first array to be tested for a mismatch\n     * @param b the second array to be tested for a mismatch\n     * @return the index of the first mismatch between the two arrays,\n     *         otherwise {@code -1}.\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int mismatch(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)",
    "returnType" : "int",
    "comment" : "\n     * Finds and returns the relative index of the first mismatch between two\n     * {@code long} arrays over the specified ranges, otherwise return -1 if no\n     * mismatch is found.  The index will be in the range of 0 (inclusive) up to\n     * the length (inclusive) of the smaller range.\n     *\n     * <p>If the two arrays, over the specified ranges, share a common prefix\n     * then the returned relative index is the length of the common prefix and\n     * it follows that there is a mismatch between the two elements at that\n     * relative index within the respective arrays.\n     * If one array is a proper prefix of the other, over the specified ranges,\n     * then the returned relative index is the length of the smaller range and\n     * it follows that the relative index is only valid for the array with the\n     * larger range.\n     * Otherwise, there is no mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common\n     * prefix of length {@code pl} if the following expression is true:\n     * <pre>{@code\n     *     pl >= 0 &&\n     *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     *     a[aFromIndex + pl] != b[bFromIndex + pl]\n     * }</pre>\n     * Note that a common prefix length of {@code 0} indicates that the first\n     * elements from each array mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper\n     * prefix if the following expression is true:\n     * <pre>{@code\n     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n     * }</pre>\n     *\n     * @param a the first array to be tested for a mismatch\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be tested\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be tested\n     * @param b the second array to be tested for a mismatch\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be tested\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be tested\n     * @return the relative index of the first mismatch between the two arrays\n     *         over the specified ranges, otherwise {@code -1}.\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int mismatch(float[] a, float[] b)",
    "returnType" : "int",
    "comment" : "\n     * Finds and returns the index of the first mismatch between two {@code float}\n     * arrays, otherwise return -1 if no mismatch is found.  The index will be\n     * in the range of 0 (inclusive) up to the length (inclusive) of the smaller\n     * array.\n     *\n     * <p>If the two arrays share a common prefix then the returned index is the\n     * length of the common prefix and it follows that there is a mismatch\n     * between the two elements at that index within the respective arrays.\n     * If one array is a proper prefix of the other then the returned index is\n     * the length of the smaller array and it follows that the index is only\n     * valid for the larger array.\n     * Otherwise, there is no mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a common\n     * prefix of length {@code pl} if the following expression is true:\n     * <pre>{@code\n     *     pl >= 0 &&\n     *     pl < Math.min(a.length, b.length) &&\n     *     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     *     Float.compare(a[pl], b[pl]) != 0\n     * }</pre>\n     * Note that a common prefix length of {@code 0} indicates that the first\n     * elements from each array mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a proper\n     * prefix if the following expression is true:\n     * <pre>{@code\n     *     a.length != b.length &&\n     *     Arrays.equals(a, 0, Math.min(a.length, b.length),\n     *                   b, 0, Math.min(a.length, b.length))\n     * }</pre>\n     *\n     * @param a the first array to be tested for a mismatch\n     * @param b the second array to be tested for a mismatch\n     * @return the index of the first mismatch between the two arrays,\n     *         otherwise {@code -1}.\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int mismatch(float[] a, int aFromIndex, int aToIndex, float[] b, int bFromIndex, int bToIndex)",
    "returnType" : "int",
    "comment" : "\n     * Finds and returns the relative index of the first mismatch between two\n     * {@code float} arrays over the specified ranges, otherwise return -1 if no\n     * mismatch is found.  The index will be in the range of 0 (inclusive) up to\n     * the length (inclusive) of the smaller range.\n     *\n     * <p>If the two arrays, over the specified ranges, share a common prefix\n     * then the returned relative index is the length of the common prefix and\n     * it follows that there is a mismatch between the two elements at that\n     * relative index within the respective arrays.\n     * If one array is a proper prefix of the other, over the specified ranges,\n     * then the returned relative index is the length of the smaller range and\n     * it follows that the relative index is only valid for the array with the\n     * larger range.\n     * Otherwise, there is no mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common\n     * prefix of length {@code pl} if the following expression is true:\n     * <pre>{@code\n     *     pl >= 0 &&\n     *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     *     Float.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0\n     * }</pre>\n     * Note that a common prefix length of {@code 0} indicates that the first\n     * elements from each array mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper\n     * prefix if the following expression is true:\n     * <pre>{@code\n     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n     * }</pre>\n     *\n     * @param a the first array to be tested for a mismatch\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be tested\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be tested\n     * @param b the second array to be tested for a mismatch\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be tested\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be tested\n     * @return the relative index of the first mismatch between the two arrays\n     *         over the specified ranges, otherwise {@code -1}.\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int mismatch(double[] a, double[] b)",
    "returnType" : "int",
    "comment" : "\n     * Finds and returns the index of the first mismatch between two\n     * {@code double} arrays, otherwise return -1 if no mismatch is found.  The\n     * index will be in the range of 0 (inclusive) up to the length (inclusive)\n     * of the smaller array.\n     *\n     * <p>If the two arrays share a common prefix then the returned index is the\n     * length of the common prefix and it follows that there is a mismatch\n     * between the two elements at that index within the respective arrays.\n     * If one array is a proper prefix of the other then the returned index is\n     * the length of the smaller array and it follows that the index is only\n     * valid for the larger array.\n     * Otherwise, there is no mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a common\n     * prefix of length {@code pl} if the following expression is true:\n     * <pre>{@code\n     *     pl >= 0 &&\n     *     pl < Math.min(a.length, b.length) &&\n     *     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     *     Double.compare(a[pl], b[pl]) != 0\n     * }</pre>\n     * Note that a common prefix length of {@code 0} indicates that the first\n     * elements from each array mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a proper\n     * prefix if the following expression is true:\n     * <pre>{@code\n     *     a.length != b.length &&\n     *     Arrays.equals(a, 0, Math.min(a.length, b.length),\n     *                   b, 0, Math.min(a.length, b.length))\n     * }</pre>\n     *\n     * @param a the first array to be tested for a mismatch\n     * @param b the second array to be tested for a mismatch\n     * @return the index of the first mismatch between the two arrays,\n     *         otherwise {@code -1}.\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int mismatch(double[] a, int aFromIndex, int aToIndex, double[] b, int bFromIndex, int bToIndex)",
    "returnType" : "int",
    "comment" : "\n     * Finds and returns the relative index of the first mismatch between two\n     * {@code double} arrays over the specified ranges, otherwise return -1 if\n     * no mismatch is found.  The index will be in the range of 0 (inclusive) up\n     * to the length (inclusive) of the smaller range.\n     *\n     * <p>If the two arrays, over the specified ranges, share a common prefix\n     * then the returned relative index is the length of the common prefix and\n     * it follows that there is a mismatch between the two elements at that\n     * relative index within the respective arrays.\n     * If one array is a proper prefix of the other, over the specified ranges,\n     * then the returned relative index is the length of the smaller range and\n     * it follows that the relative index is only valid for the array with the\n     * larger range.\n     * Otherwise, there is no mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common\n     * prefix of length {@code pl} if the following expression is true:\n     * <pre>{@code\n     *     pl >= 0 &&\n     *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     *     Double.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0\n     * }</pre>\n     * Note that a common prefix length of {@code 0} indicates that the first\n     * elements from each array mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper\n     * prefix if the following expression is true:\n     * <pre>{@code\n     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n     * }</pre>\n     *\n     * @param a the first array to be tested for a mismatch\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be tested\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be tested\n     * @param b the second array to be tested for a mismatch\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be tested\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be tested\n     * @return the relative index of the first mismatch between the two arrays\n     *         over the specified ranges, otherwise {@code -1}.\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int mismatch(Object[] a, Object[] b)",
    "returnType" : "int",
    "comment" : "\n     * Finds and returns the index of the first mismatch between two\n     * {@code Object} arrays, otherwise return -1 if no mismatch is found.  The\n     * index will be in the range of 0 (inclusive) up to the length (inclusive)\n     * of the smaller array.\n     *\n     * <p>If the two arrays share a common prefix then the returned index is the\n     * length of the common prefix and it follows that there is a mismatch\n     * between the two elements at that index within the respective arrays.\n     * If one array is a proper prefix of the other then the returned index is\n     * the length of the smaller array and it follows that the index is only\n     * valid for the larger array.\n     * Otherwise, there is no mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a common\n     * prefix of length {@code pl} if the following expression is true:\n     * <pre>{@code\n     *     pl >= 0 &&\n     *     pl < Math.min(a.length, b.length) &&\n     *     Arrays.equals(a, 0, pl, b, 0, pl) &&\n     *     !Objects.equals(a[pl], b[pl])\n     * }</pre>\n     * Note that a common prefix length of {@code 0} indicates that the first\n     * elements from each array mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a proper\n     * prefix if the following expression is true:\n     * <pre>{@code\n     *     a.length != b.length &&\n     *     Arrays.equals(a, 0, Math.min(a.length, b.length),\n     *                   b, 0, Math.min(a.length, b.length))\n     * }</pre>\n     *\n     * @param a the first array to be tested for a mismatch\n     * @param b the second array to be tested for a mismatch\n     * @return the index of the first mismatch between the two arrays,\n     *         otherwise {@code -1}.\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int mismatch(Object[] a, int aFromIndex, int aToIndex, Object[] b, int bFromIndex, int bToIndex)",
    "returnType" : "int",
    "comment" : "\n     * Finds and returns the relative index of the first mismatch between two\n     * {@code Object} arrays over the specified ranges, otherwise return -1 if\n     * no mismatch is found.  The index will be in the range of 0 (inclusive) up\n     * to the length (inclusive) of the smaller range.\n     *\n     * <p>If the two arrays, over the specified ranges, share a common prefix\n     * then the returned relative index is the length of the common prefix and\n     * it follows that there is a mismatch between the two elements at that\n     * relative index within the respective arrays.\n     * If one array is a proper prefix of the other, over the specified ranges,\n     * then the returned relative index is the length of the smaller range and\n     * it follows that the relative index is only valid for the array with the\n     * larger range.\n     * Otherwise, there is no mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common\n     * prefix of length {@code pl} if the following expression is true:\n     * <pre>{@code\n     *     pl >= 0 &&\n     *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &&\n     *     !Objects.equals(a[aFromIndex + pl], b[bFromIndex + pl])\n     * }</pre>\n     * Note that a common prefix length of {@code 0} indicates that the first\n     * elements from each array mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper\n     * prefix if the following expression is true:\n     * <pre>{@code\n     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))\n     * }</pre>\n     *\n     * @param a the first array to be tested for a mismatch\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be tested\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be tested\n     * @param b the second array to be tested for a mismatch\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be tested\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be tested\n     * @return the relative index of the first mismatch between the two arrays\n     *         over the specified ranges, otherwise {@code -1}.\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int mismatch(T[] a, T[] b, Comparator<? super T> cmp)",
    "returnType" : "int",
    "comment" : "\n     * Finds and returns the index of the first mismatch between two\n     * {@code Object} arrays, otherwise return -1 if no mismatch is found.\n     * The index will be in the range of 0 (inclusive) up to the length\n     * (inclusive) of the smaller array.\n     *\n     * <p>The specified comparator is used to determine if two array elements\n     * from the each array are not equal.\n     *\n     * <p>If the two arrays share a common prefix then the returned index is the\n     * length of the common prefix and it follows that there is a mismatch\n     * between the two elements at that index within the respective arrays.\n     * If one array is a proper prefix of the other then the returned index is\n     * the length of the smaller array and it follows that the index is only\n     * valid for the larger array.\n     * Otherwise, there is no mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a common\n     * prefix of length {@code pl} if the following expression is true:\n     * <pre>{@code\n     *     pl >= 0 &&\n     *     pl < Math.min(a.length, b.length) &&\n     *     Arrays.equals(a, 0, pl, b, 0, pl, cmp)\n     *     cmp.compare(a[pl], b[pl]) != 0\n     * }</pre>\n     * Note that a common prefix length of {@code 0} indicates that the first\n     * elements from each array mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b}, share a proper\n     * prefix if the following expression is true:\n     * <pre>{@code\n     *     a.length != b.length &&\n     *     Arrays.equals(a, 0, Math.min(a.length, b.length),\n     *                   b, 0, Math.min(a.length, b.length),\n     *                   cmp)\n     * }</pre>\n     *\n     * @param a the first array to be tested for a mismatch\n     * @param b the second array to be tested for a mismatch\n     * @param cmp the comparator to compare array elements\n     * @param <T> the type of array elements\n     * @return the index of the first mismatch between the two arrays,\n     *         otherwise {@code -1}.\n     * @throws NullPointerException\n     *         if either array or the comparator is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int mismatch(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator<? super T> cmp)",
    "returnType" : "int",
    "comment" : "\n     * Finds and returns the relative index of the first mismatch between two\n     * {@code Object} arrays over the specified ranges, otherwise return -1 if\n     * no mismatch is found.  The index will be in the range of 0 (inclusive) up\n     * to the length (inclusive) of the smaller range.\n     *\n     * <p>If the two arrays, over the specified ranges, share a common prefix\n     * then the returned relative index is the length of the common prefix and\n     * it follows that there is a mismatch between the two elements at that\n     * relative index within the respective arrays.\n     * If one array is a proper prefix of the other, over the specified ranges,\n     * then the returned relative index is the length of the smaller range and\n     * it follows that the relative index is only valid for the array with the\n     * larger range.\n     * Otherwise, there is no mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a common\n     * prefix of length {@code pl} if the following expression is true:\n     * <pre>{@code\n     *     pl >= 0 &&\n     *     pl < Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &&\n     *     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl, cmp) &&\n     *     cmp.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0\n     * }</pre>\n     * Note that a common prefix length of {@code 0} indicates that the first\n     * elements from each array mismatch.\n     *\n     * <p>Two non-{@code null} arrays, {@code a} and {@code b} with specified\n     * ranges [{@code aFromIndex}, {@code atoIndex}) and\n     * [{@code bFromIndex}, {@code btoIndex}) respectively, share a proper\n     * prefix if the following expression is true:\n     * <pre>{@code\n     *     (aToIndex - aFromIndex) != (bToIndex - bFromIndex) &&\n     *     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n     *                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),\n     *                   cmp)\n     * }</pre>\n     *\n     * @param a the first array to be tested for a mismatch\n     * @param aFromIndex the index (inclusive) of the first element in the\n     *                   first array to be tested\n     * @param aToIndex the index (exclusive) of the last element in the\n     *                 first array to be tested\n     * @param b the second array to be tested for a mismatch\n     * @param bFromIndex the index (inclusive) of the first element in the\n     *                   second array to be tested\n     * @param bToIndex the index (exclusive) of the last element in the\n     *                 second array to be tested\n     * @param cmp the comparator to compare array elements\n     * @param <T> the type of array elements\n     * @return the relative index of the first mismatch between the two arrays\n     *         over the specified ranges, otherwise {@code -1}.\n     * @throws IllegalArgumentException\n     *         if {@code aFromIndex > aToIndex} or\n     *         if {@code bFromIndex > bToIndex}\n     * @throws ArrayIndexOutOfBoundsException\n     *         if {@code aFromIndex < 0 or aToIndex > a.length} or\n     *         if {@code bFromIndex < 0 or bToIndex > b.length}\n     * @throws NullPointerException\n     *         if either array or the comparator is {@code null}\n     * @since 9\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public static void sort(int[] a)", "public static void sort(int[] a, int fromIndex, int toIndex)", "public static void sort(long[] a)", "public static void sort(long[] a, int fromIndex, int toIndex)", "public static void sort(short[] a)", "public static void sort(short[] a, int fromIndex, int toIndex)", "public static void sort(char[] a)", "public static void sort(char[] a, int fromIndex, int toIndex)", "public static void sort(byte[] a)", "public static void sort(byte[] a, int fromIndex, int toIndex)", "public static void sort(float[] a)", "public static void sort(float[] a, int fromIndex, int toIndex)", "public static void sort(double[] a)", "public static void sort(double[] a, int fromIndex, int toIndex)", "public static void parallelSort(byte[] a)", "public static void parallelSort(byte[] a, int fromIndex, int toIndex)", "public static void parallelSort(char[] a)", "public static void parallelSort(char[] a, int fromIndex, int toIndex)", "public static void parallelSort(short[] a)", "public static void parallelSort(short[] a, int fromIndex, int toIndex)", "public static void parallelSort(int[] a)", "public static void parallelSort(int[] a, int fromIndex, int toIndex)", "public static void parallelSort(long[] a)", "public static void parallelSort(long[] a, int fromIndex, int toIndex)", "public static void parallelSort(float[] a)", "public static void parallelSort(float[] a, int fromIndex, int toIndex)", "public static void parallelSort(double[] a)", "public static void parallelSort(double[] a, int fromIndex, int toIndex)", " static void rangeCheck(int arrayLength, int fromIndex, int toIndex)", "public static void parallelSort(T[] a)", "public static void parallelSort(T[] a, int fromIndex, int toIndex)", "public static void parallelSort(T[] a, Comparator<? super T> cmp)", "public static void parallelSort(T[] a, int fromIndex, int toIndex, Comparator<? super T> cmp)", "public static void sort(Object[] a)", "public static void sort(Object[] a, int fromIndex, int toIndex)", "private static void mergeSort(Object[] src, Object[] dest, int low, int high, int off)", "private static void swap(Object[] x, int a, int b)", "public static void sort(T[] a, Comparator<? super T> c)", "public static void sort(T[] a, int fromIndex, int toIndex, Comparator<? super T> c)", "public static void parallelPrefix(T[] array, BinaryOperator<T> op)", "public static void parallelPrefix(T[] array, int fromIndex, int toIndex, BinaryOperator<T> op)", "public static void parallelPrefix(long[] array, LongBinaryOperator op)", "public static void parallelPrefix(long[] array, int fromIndex, int toIndex, LongBinaryOperator op)", "public static void parallelPrefix(double[] array, DoubleBinaryOperator op)", "public static void parallelPrefix(double[] array, int fromIndex, int toIndex, DoubleBinaryOperator op)", "public static void parallelPrefix(int[] array, IntBinaryOperator op)", "public static void parallelPrefix(int[] array, int fromIndex, int toIndex, IntBinaryOperator op)", "public static int binarySearch(long[] a, long key)", "public static int binarySearch(long[] a, int fromIndex, int toIndex, long key)", "private static int binarySearch0(long[] a, int fromIndex, int toIndex, long key)", "public static int binarySearch(int[] a, int key)", "public static int binarySearch(int[] a, int fromIndex, int toIndex, int key)", "private static int binarySearch0(int[] a, int fromIndex, int toIndex, int key)", "public static int binarySearch(short[] a, short key)", "public static int binarySearch(short[] a, int fromIndex, int toIndex, short key)", "private static int binarySearch0(short[] a, int fromIndex, int toIndex, short key)", "public static int binarySearch(char[] a, char key)", "public static int binarySearch(char[] a, int fromIndex, int toIndex, char key)", "private static int binarySearch0(char[] a, int fromIndex, int toIndex, char key)", "public static int binarySearch(byte[] a, byte key)", "public static int binarySearch(byte[] a, int fromIndex, int toIndex, byte key)", "private static int binarySearch0(byte[] a, int fromIndex, int toIndex, byte key)", "public static int binarySearch(double[] a, double key)", "public static int binarySearch(double[] a, int fromIndex, int toIndex, double key)", "private static int binarySearch0(double[] a, int fromIndex, int toIndex, double key)", "public static int binarySearch(float[] a, float key)", "public static int binarySearch(float[] a, int fromIndex, int toIndex, float key)", "private static int binarySearch0(float[] a, int fromIndex, int toIndex, float key)", "public static int binarySearch(Object[] a, Object key)", "public static int binarySearch(Object[] a, int fromIndex, int toIndex, Object key)", "private static int binarySearch0(Object[] a, int fromIndex, int toIndex, Object key)", "public static int binarySearch(T[] a, T key, Comparator<? super T> c)", "public static int binarySearch(T[] a, int fromIndex, int toIndex, T key, Comparator<? super T> c)", "private static int binarySearch0(T[] a, int fromIndex, int toIndex, T key, Comparator<? super T> c)", "public static boolean equals(long[] a, long[] a2)", "public static boolean equals(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)", "public static boolean equals(int[] a, int[] a2)", "public static boolean equals(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)", "public static boolean equals(short[] a, short[] a2)", "public static boolean equals(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)", "public static boolean equals(char[] a, char[] a2)", "public static boolean equals(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex)", "public static boolean equals(byte[] a, byte[] a2)", "public static boolean equals(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)", "public static boolean equals(boolean[] a, boolean[] a2)", "public static boolean equals(boolean[] a, int aFromIndex, int aToIndex, boolean[] b, int bFromIndex, int bToIndex)", "public static boolean equals(double[] a, double[] a2)", "public static boolean equals(double[] a, int aFromIndex, int aToIndex, double[] b, int bFromIndex, int bToIndex)", "public static boolean equals(float[] a, float[] a2)", "public static boolean equals(float[] a, int aFromIndex, int aToIndex, float[] b, int bFromIndex, int bToIndex)", "public static boolean equals(Object[] a, Object[] a2)", "public static boolean equals(Object[] a, int aFromIndex, int aToIndex, Object[] b, int bFromIndex, int bToIndex)", "public static boolean equals(T[] a, T[] a2, Comparator<? super T> cmp)", "public static boolean equals(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator<? super T> cmp)", "public static void fill(long[] a, long val)", "public static void fill(long[] a, int fromIndex, int toIndex, long val)", "public static void fill(int[] a, int val)", "public static void fill(int[] a, int fromIndex, int toIndex, int val)", "public static void fill(short[] a, short val)", "public static void fill(short[] a, int fromIndex, int toIndex, short val)", "public static void fill(char[] a, char val)", "public static void fill(char[] a, int fromIndex, int toIndex, char val)", "public static void fill(byte[] a, byte val)", "public static void fill(byte[] a, int fromIndex, int toIndex, byte val)", "public static void fill(boolean[] a, boolean val)", "public static void fill(boolean[] a, int fromIndex, int toIndex, boolean val)", "public static void fill(double[] a, double val)", "public static void fill(double[] a, int fromIndex, int toIndex, double val)", "public static void fill(float[] a, float val)", "public static void fill(float[] a, int fromIndex, int toIndex, float val)", "public static void fill(Object[] a, Object val)", "public static void fill(Object[] a, int fromIndex, int toIndex, Object val)", "public static T[] copyOf(T[] original, int newLength)", "public static T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType)", "public static byte[] copyOf(byte[] original, int newLength)", "public static short[] copyOf(short[] original, int newLength)", "public static int[] copyOf(int[] original, int newLength)", "public static long[] copyOf(long[] original, int newLength)", "public static char[] copyOf(char[] original, int newLength)", "public static float[] copyOf(float[] original, int newLength)", "public static double[] copyOf(double[] original, int newLength)", "public static boolean[] copyOf(boolean[] original, int newLength)", "public static T[] copyOfRange(T[] original, int from, int to)", "public static T[] copyOfRange(U[] original, int from, int to, Class<? extends T[]> newType)", "public static byte[] copyOfRange(byte[] original, int from, int to)", "public static short[] copyOfRange(short[] original, int from, int to)", "public static int[] copyOfRange(int[] original, int from, int to)", "public static long[] copyOfRange(long[] original, int from, int to)", "public static char[] copyOfRange(char[] original, int from, int to)", "public static float[] copyOfRange(float[] original, int from, int to)", "public static double[] copyOfRange(double[] original, int from, int to)", "public static boolean[] copyOfRange(boolean[] original, int from, int to)", "public static List<T> asList(T... a)", "public static int hashCode(long[] a)", "public static int hashCode(int[] a)", "public static int hashCode(short[] a)", "public static int hashCode(char[] a)", "public static int hashCode(byte[] a)", "public static int hashCode(boolean[] a)", "public static int hashCode(float[] a)", "public static int hashCode(double[] a)", "public static int hashCode(Object[] a)", "public static int deepHashCode(Object[] a)", "private static int primitiveArrayHashCode(Object a, Class<?> cl)", "public static boolean deepEquals(Object[] a1, Object[] a2)", " static boolean deepEquals0(Object e1, Object e2)", "public static String toString(long[] a)", "public static String toString(int[] a)", "public static String toString(short[] a)", "public static String toString(char[] a)", "public static String toString(byte[] a)", "public static String toString(boolean[] a)", "public static String toString(float[] a)", "public static String toString(double[] a)", "public static String toString(Object[] a)", "public static String deepToString(Object[] a)", "private static void deepToString(Object[] a, StringBuilder buf, Set<Object[]> dejaVu)", "public static void setAll(T[] array, IntFunction<? extends T> generator)", "public static void parallelSetAll(T[] array, IntFunction<? extends T> generator)", "public static void setAll(int[] array, IntUnaryOperator generator)", "public static void parallelSetAll(int[] array, IntUnaryOperator generator)", "public static void setAll(long[] array, IntToLongFunction generator)", "public static void parallelSetAll(long[] array, IntToLongFunction generator)", "public static void setAll(double[] array, IntToDoubleFunction generator)", "public static void parallelSetAll(double[] array, IntToDoubleFunction generator)", "public static Spliterator<T> spliterator(T[] array)", "public static Spliterator<T> spliterator(T[] array, int startInclusive, int endExclusive)", "public static Spliterator.OfInt spliterator(int[] array)", "public static Spliterator.OfInt spliterator(int[] array, int startInclusive, int endExclusive)", "public static Spliterator.OfLong spliterator(long[] array)", "public static Spliterator.OfLong spliterator(long[] array, int startInclusive, int endExclusive)", "public static Spliterator.OfDouble spliterator(double[] array)", "public static Spliterator.OfDouble spliterator(double[] array, int startInclusive, int endExclusive)", "public static Stream<T> stream(T[] array)", "public static Stream<T> stream(T[] array, int startInclusive, int endExclusive)", "public static IntStream stream(int[] array)", "public static IntStream stream(int[] array, int startInclusive, int endExclusive)", "public static LongStream stream(long[] array)", "public static LongStream stream(long[] array, int startInclusive, int endExclusive)", "public static DoubleStream stream(double[] array)", "public static DoubleStream stream(double[] array, int startInclusive, int endExclusive)", "public static int compare(boolean[] a, boolean[] b)", "public static int compare(boolean[] a, int aFromIndex, int aToIndex, boolean[] b, int bFromIndex, int bToIndex)", "public static int compare(byte[] a, byte[] b)", "public static int compare(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)", "public static int compareUnsigned(byte[] a, byte[] b)", "public static int compareUnsigned(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)", "public static int compare(short[] a, short[] b)", "public static int compare(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)", "public static int compareUnsigned(short[] a, short[] b)", "public static int compareUnsigned(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)", "public static int compare(char[] a, char[] b)", "public static int compare(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex)", "public static int compare(int[] a, int[] b)", "public static int compare(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)", "public static int compareUnsigned(int[] a, int[] b)", "public static int compareUnsigned(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)", "public static int compare(long[] a, long[] b)", "public static int compare(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)", "public static int compareUnsigned(long[] a, long[] b)", "public static int compareUnsigned(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)", "public static int compare(float[] a, float[] b)", "public static int compare(float[] a, int aFromIndex, int aToIndex, float[] b, int bFromIndex, int bToIndex)", "public static int compare(double[] a, double[] b)", "public static int compare(double[] a, int aFromIndex, int aToIndex, double[] b, int bFromIndex, int bToIndex)", "public static int compare(T[] a, T[] b)", "public static int compare(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex)", "public static int compare(T[] a, T[] b, Comparator<? super T> cmp)", "public static int compare(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator<? super T> cmp)", "public static int mismatch(boolean[] a, boolean[] b)", "public static int mismatch(boolean[] a, int aFromIndex, int aToIndex, boolean[] b, int bFromIndex, int bToIndex)", "public static int mismatch(byte[] a, byte[] b)", "public static int mismatch(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex)", "public static int mismatch(char[] a, char[] b)", "public static int mismatch(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex)", "public static int mismatch(short[] a, short[] b)", "public static int mismatch(short[] a, int aFromIndex, int aToIndex, short[] b, int bFromIndex, int bToIndex)", "public static int mismatch(int[] a, int[] b)", "public static int mismatch(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex)", "public static int mismatch(long[] a, long[] b)", "public static int mismatch(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex)", "public static int mismatch(float[] a, float[] b)", "public static int mismatch(float[] a, int aFromIndex, int aToIndex, float[] b, int bFromIndex, int bToIndex)", "public static int mismatch(double[] a, double[] b)", "public static int mismatch(double[] a, int aFromIndex, int aToIndex, double[] b, int bFromIndex, int bToIndex)", "public static int mismatch(Object[] a, Object[] b)", "public static int mismatch(Object[] a, int aFromIndex, int aToIndex, Object[] b, int bFromIndex, int bToIndex)", "public static int mismatch(T[] a, T[] b, Comparator<? super T> cmp)", "public static int mismatch(T[] a, int aFromIndex, int aToIndex, T[] b, int bFromIndex, int bToIndex, Comparator<? super T> cmp)" ],
  "variableNames" : [ "MIN_ARRAY_SORT_GRAN", "INSERTIONSORT_THRESHOLD", "DO_NOT_CLONE_IN_ARRAYS_AS_LIST" ]
}