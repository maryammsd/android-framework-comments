{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/org/xml/sax/ContentHandler.java",
  "packageName" : "org.xml.sax",
  "className" : "ContentHandler",
  "comment" : "\n * Receive notification of the logical content of a document.\n *\n * <blockquote>\n * <em>This module, both source code and documentation, is in the\n * Public Domain, and comes with <strong>NO WARRANTY</strong>.</em>\n * See <a href='http://www.saxproject.org'>http://www.saxproject.org</a>\n * for further information.\n * </blockquote>\n *\n * <p>This is the main interface that most SAX applications\n * implement: if the application needs to be informed of basic parsing\n * events, it implements this interface and registers an instance with\n * the SAX parser using the {@link org.xml.sax.XMLReader#setContentHandler\n * setContentHandler} method.  The parser uses the instance to report\n * basic document-related events like the start and end of elements\n * and character data.</p>\n *\n * <p>The order of events in this interface is very important, and\n * mirrors the order of information in the document itself.  For\n * example, all of an element's content (character data, processing\n * instructions, and/or subelements) will appear, in order, between\n * the startElement event and the corresponding endElement event.</p>\n *\n * <p>This interface is similar to the now-deprecated SAX 1.0\n * DocumentHandler interface, but it adds support for Namespaces\n * and for reporting skipped entities (in non-validating XML\n * processors).</p>\n *\n * <p>Implementors should note that there is also a\n * <code>ContentHandler</code> class in the <code>java.net</code>\n * package; that means that it's probably a bad idea to do</p>\n *\n * <pre>import java.net.*;\n * import org.xml.sax.*;\n * </pre>\n *\n * <p>In fact, \"import ...*\" is usually a sign of sloppy programming\n * anyway, so the user should consider this a feature rather than a\n * bug.</p>\n *\n * @since SAX 2.0\n * @author David Megginson\n * @version 2.0.1+ (sax2r3pre1)\n * @see org.xml.sax.XMLReader\n * @see org.xml.sax.DTDHandler\n * @see org.xml.sax.ErrorHandler\n ",
  "links" : [ "org.xml.sax.XMLReader#setContentHandlersetContentHandler" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : "public void setDocumentLocator(Locator locator)",
    "returnType" : "void",
    "comment" : "\n     * Receive an object for locating the origin of SAX document events.\n     *\n     * <p>SAX parsers are strongly encouraged (though not absolutely\n     * required) to supply a locator: if it does so, it must supply\n     * the locator to the application by invoking this method before\n     * invoking any of the other methods in the ContentHandler\n     * interface.</p>\n     *\n     * <p>The locator allows the application to determine the end\n     * position of any document-related event, even if the parser is\n     * not reporting an error.  Typically, the application will\n     * use this information for reporting its own errors (such as\n     * character content that does not match an application's\n     * business rules).  The information returned by the locator\n     * is probably not sufficient for use with a search engine.</p>\n     *\n     * <p>Note that the locator will return correct information only\n     * during the invocation SAX event callbacks after\n     * {@link #startDocument startDocument} returns and before\n     * {@link #endDocument endDocument} is called.  The\n     * application should not attempt to use it at any other time.</p>\n     *\n     * @param locator an object that can return the location of\n     *                any SAX document event\n     * @see org.xml.sax.Locator\n     ",
    "links" : [ "#endDocument", "#startDocument" ]
  }, {
    "name" : "public void startDocument() throws SAXException",
    "returnType" : "void",
    "comment" : "\n     * Receive notification of the beginning of a document.\n     *\n     * <p>The SAX parser will invoke this method only once, before any\n     * other event callbacks (except for {@link #setDocumentLocator\n     * setDocumentLocator}).</p>\n     *\n     * @throws org.xml.sax.SAXException any SAX exception, possibly\n     *            wrapping another exception\n     * @see #endDocument\n     ",
    "links" : [ "#setDocumentLocatorsetDocumentLocator" ]
  }, {
    "name" : "public void endDocument() throws SAXException",
    "returnType" : "void",
    "comment" : "\n     * Receive notification of the end of a document.\n     *\n     * <p><strong>There is an apparent contradiction between the\n     * documentation for this method and the documentation for {@link\n     * org.xml.sax.ErrorHandler#fatalError}.  Until this ambiguity is\n     * resolved in a future major release, clients should make no\n     * assumptions about whether endDocument() will or will not be\n     * invoked when the parser has reported a fatalError() or thrown\n     * an exception.</strong></p>\n     *\n     * <p>The SAX parser will invoke this method only once, and it will\n     * be the last method invoked during the parse.  The parser shall\n     * not invoke this method until it has either abandoned parsing\n     * (because of an unrecoverable error) or reached the end of\n     * input.</p>\n     *\n     * @throws org.xml.sax.SAXException any SAX exception, possibly\n     *            wrapping another exception\n     * @see #startDocument\n     ",
    "links" : [ "org.xml.sax.ErrorHandler#fatalError" ]
  }, {
    "name" : "public void startPrefixMapping(String prefix, String uri) throws SAXException",
    "returnType" : "void",
    "comment" : "\n     * Begin the scope of a prefix-URI Namespace mapping.\n     *\n     * <p>The information from this event is not necessary for\n     * normal Namespace processing: the SAX XML reader will\n     * automatically replace prefixes for element and attribute\n     * names when the <code>http://xml.org/sax/features/namespaces</code>\n     * feature is <var>true</var> (the default).</p>\n     *\n     * <p>There are cases, however, when applications need to\n     * use prefixes in character data or in attribute values,\n     * where they cannot safely be expanded automatically; the\n     * start/endPrefixMapping event supplies the information\n     * to the application to expand prefixes in those contexts\n     * itself, if necessary.</p>\n     *\n     * <p>Note that start/endPrefixMapping events are not\n     * guaranteed to be properly nested relative to each other:\n     * all startPrefixMapping events will occur immediately before the\n     * corresponding {@link #startElement startElement} event,\n     * and all {@link #endPrefixMapping endPrefixMapping}\n     * events will occur immediately after the corresponding\n     * {@link #endElement endElement} event,\n     * but their order is not otherwise\n     * guaranteed.</p>\n     *\n     * <p>There should never be start/endPrefixMapping events for the\n     * \"xml\" prefix, since it is predeclared and immutable.</p>\n     *\n     * @param prefix the Namespace prefix being declared.\n     *    An empty string is used for the default element namespace,\n     *    which has no prefix.\n     * @param uri the Namespace URI the prefix is mapped to\n     * @throws org.xml.sax.SAXException the client may throw\n     *            an exception during processing\n     * @see #endPrefixMapping\n     * @see #startElement\n     ",
    "links" : [ "#endElement", "#startElement", "#endPrefixMapping" ]
  }, {
    "name" : "public void endPrefixMapping(String prefix) throws SAXException",
    "returnType" : "void",
    "comment" : "\n     * End the scope of a prefix-URI mapping.\n     *\n     * <p>See {@link #startPrefixMapping startPrefixMapping} for\n     * details.  These events will always occur immediately after the\n     * corresponding {@link #endElement endElement} event, but the order of\n     * {@link #endPrefixMapping endPrefixMapping} events is not otherwise\n     * guaranteed.</p>\n     *\n     * @param prefix the prefix that was being mapped.\n     *    This is the empty string when a default mapping scope ends.\n     * @throws org.xml.sax.SAXException the client may throw\n     *            an exception during processing\n     * @see #startPrefixMapping\n     * @see #endElement\n     ",
    "links" : [ "#endElement", "#startPrefixMapping", "#endPrefixMapping" ]
  }, {
    "name" : "public void startElement(String uri, String localName, String qName, Attributes atts) throws SAXException",
    "returnType" : "void",
    "comment" : "\n     * Receive notification of the beginning of an element.\n     *\n     * <p>The Parser will invoke this method at the beginning of every\n     * element in the XML document; there will be a corresponding\n     * {@link #endElement endElement} event for every startElement event\n     * (even when the element is empty). All of the element's content will be\n     * reported, in order, before the corresponding endElement\n     * event.</p>\n     *\n     * <p>This event allows up to three name components for each\n     * element:</p>\n     *\n     * <ol>\n     * <li>the Namespace URI;</li>\n     * <li>the local name; and</li>\n     * <li>the qualified (prefixed) name.</li>\n     * </ol>\n     *\n     * <p>Any or all of these may be provided, depending on the\n     * values of the <var>http://xml.org/sax/features/namespaces</var>\n     * and the <var>http://xml.org/sax/features/namespace-prefixes</var>\n     * properties:</p>\n     *\n     * <ul>\n     * <li>the Namespace URI and local name are required when\n     * the namespaces property is <var>true</var> (the default), and are\n     * optional when the namespaces property is <var>false</var> (if one is\n     * specified, both must be);</li>\n     * <li>the qualified name is required when the namespace-prefixes property\n     * is <var>true</var>, and is optional when the namespace-prefixes property\n     * is <var>false</var> (the default).</li>\n     * </ul>\n     *\n     * <p>Note that the attribute list provided will contain only\n     * attributes with explicit values (specified or defaulted):\n     * #IMPLIED attributes will be omitted.  The attribute list\n     * will contain attributes used for Namespace declarations\n     * (xmlns* attributes) only if the\n     * <code>http://xml.org/sax/features/namespace-prefixes</code>\n     * property is true (it is false by default, and support for a\n     * true value is optional).</p>\n     *\n     * <p>Like {@link #characters characters()}, attribute values may have\n     * characters that need more than one <code>char</code> value.  </p>\n     *\n     * @param uri the Namespace URI, or the empty string if the\n     *        element has no Namespace URI or if Namespace\n     *        processing is not being performed\n     * @param localName the local name (without prefix), or the\n     *        empty string if Namespace processing is not being\n     *        performed\n     * @param qName the qualified name (with prefix), or the\n     *        empty string if qualified names are not available\n     * @param atts the attributes attached to the element.  If\n     *        there are no attributes, it shall be an empty\n     *        Attributes object.  The value of this object after\n     *        startElement returns is undefined\n     * @throws org.xml.sax.SAXException any SAX exception, possibly\n     *            wrapping another exception\n     * @see #endElement\n     * @see org.xml.sax.Attributes\n     * @see org.xml.sax.helpers.AttributesImpl\n     ",
    "links" : [ "#endElement", "#characters" ]
  }, {
    "name" : "public void endElement(String uri, String localName, String qName) throws SAXException",
    "returnType" : "void",
    "comment" : "\n     * Receive notification of the end of an element.\n     *\n     * <p>The SAX parser will invoke this method at the end of every\n     * element in the XML document; there will be a corresponding\n     * {@link #startElement startElement} event for every endElement\n     * event (even when the element is empty).</p>\n     *\n     * <p>For information on the names, see startElement.</p>\n     *\n     * @param uri the Namespace URI, or the empty string if the\n     *        element has no Namespace URI or if Namespace\n     *        processing is not being performed\n     * @param localName the local name (without prefix), or the\n     *        empty string if Namespace processing is not being\n     *        performed\n     * @param qName the qualified XML name (with prefix), or the\n     *        empty string if qualified names are not available\n     * @throws org.xml.sax.SAXException any SAX exception, possibly\n     *            wrapping another exception\n     ",
    "links" : [ "#startElement" ]
  }, {
    "name" : "public void characters(char[] ch, int start, int length) throws SAXException",
    "returnType" : "void",
    "comment" : "\n     * Receive notification of character data.\n     *\n     * <p>The Parser will call this method to report each chunk of\n     * character data.  SAX parsers may return all contiguous character\n     * data in a single chunk, or they may split it into several\n     * chunks; however, all of the characters in any single event\n     * must come from the same external entity so that the Locator\n     * provides useful information.</p>\n     *\n     * <p>The application must not attempt to read from the array\n     * outside of the specified range.</p>\n     *\n     * <p>Individual characters may consist of more than one Java\n     * <code>char</code> value.  There are two important cases where this\n     * happens, because characters can't be represented in just sixteen bits.\n     * In one case, characters are represented in a <em>Surrogate Pair</em>,\n     * using two special Unicode values. Such characters are in the so-called\n     * \"Astral Planes\", with a code point above U+FFFF.  A second case involves\n     * composite characters, such as a base character combining with one or\n     * more accent characters. </p>\n     *\n     * <p> Your code should not assume that algorithms using\n     * <code>char</code>-at-a-time idioms will be working in character\n     * units; in some cases they will split characters.  This is relevant\n     * wherever XML permits arbitrary characters, such as attribute values,\n     * processing instruction data, and comments as well as in data reported\n     * from this method.  It's also generally relevant whenever Java code\n     * manipulates internationalized text; the issue isn't unique to XML.</p>\n     *\n     * <p>Note that some parsers will report whitespace in element\n     * content using the {@link #ignorableWhitespace ignorableWhitespace}\n     * method rather than this one (validating parsers <em>must</em>\n     * do so).</p>\n     *\n     * @param ch the characters from the XML document\n     * @param start the start position in the array\n     * @param length the number of characters to read from the array\n     * @throws org.xml.sax.SAXException any SAX exception, possibly\n     *            wrapping another exception\n     * @see #ignorableWhitespace\n     * @see org.xml.sax.Locator\n     ",
    "links" : [ "#ignorableWhitespace" ]
  }, {
    "name" : "public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException",
    "returnType" : "void",
    "comment" : "\n     * Receive notification of ignorable whitespace in element content.\n     *\n     * <p>Validating Parsers must use this method to report each chunk\n     * of whitespace in element content (see the W3C XML 1.0\n     * recommendation, section 2.10): non-validating parsers may also\n     * use this method if they are capable of parsing and using\n     * content models.</p>\n     *\n     * <p>SAX parsers may return all contiguous whitespace in a single\n     * chunk, or they may split it into several chunks; however, all of\n     * the characters in any single event must come from the same\n     * external entity, so that the Locator provides useful\n     * information.</p>\n     *\n     * <p>The application must not attempt to read from the array\n     * outside of the specified range.</p>\n     *\n     * @param ch the characters from the XML document\n     * @param start the start position in the array\n     * @param length the number of characters to read from the array\n     * @throws org.xml.sax.SAXException any SAX exception, possibly\n     *            wrapping another exception\n     * @see #characters\n     ",
    "links" : [ ]
  }, {
    "name" : "public void processingInstruction(String target, String data) throws SAXException",
    "returnType" : "void",
    "comment" : "\n     * Receive notification of a processing instruction.\n     *\n     * <p>The Parser will invoke this method once for each processing\n     * instruction found: note that processing instructions may occur\n     * before or after the main document element.</p>\n     *\n     * <p>A SAX parser must never report an XML declaration (XML 1.0,\n     * section 2.8) or a text declaration (XML 1.0, section 4.3.1)\n     * using this method.</p>\n     *\n     * <p>Like {@link #characters characters()}, processing instruction\n     * data may have characters that need more than one <code>char</code>\n     * value. </p>\n     *\n     * @param target the processing instruction target\n     * @param data the processing instruction data, or null if\n     *        none was supplied.  The data does not include any\n     *        whitespace separating it from the target\n     * @throws org.xml.sax.SAXException any SAX exception, possibly\n     *            wrapping another exception\n     ",
    "links" : [ "#characters" ]
  }, {
    "name" : "public void skippedEntity(String name) throws SAXException",
    "returnType" : "void",
    "comment" : "\n     * Receive notification of a skipped entity.\n     * This is not called for entity references within markup constructs\n     * such as element start tags or markup declarations.  (The XML\n     * recommendation requires reporting skipped external entities.\n     * SAX also reports internal entity expansion/non-expansion, except\n     * within markup constructs.)\n     *\n     * <p>The Parser will invoke this method each time the entity is\n     * skipped.  Non-validating processors may skip entities if they\n     * have not seen the declarations (because, for example, the\n     * entity was declared in an external DTD subset).  All processors\n     * may skip external entities, depending on the values of the\n     * <code>http://xml.org/sax/features/external-general-entities</code>\n     * and the\n     * <code>http://xml.org/sax/features/external-parameter-entities</code>\n     * properties.</p>\n     *\n     * @param name the name of the skipped entity.  If it is a\n     *        parameter entity, the name will begin with '%', and if\n     *        it is the external DTD subset, it will be the string\n     *        \"[dtd]\"\n     * @throws org.xml.sax.SAXException any SAX exception, possibly\n     *            wrapping another exception\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public void setDocumentLocator(Locator locator)", "public void startDocument() throws SAXException", "public void endDocument() throws SAXException", "public void startPrefixMapping(String prefix, String uri) throws SAXException", "public void endPrefixMapping(String prefix) throws SAXException", "public void startElement(String uri, String localName, String qName, Attributes atts) throws SAXException", "public void endElement(String uri, String localName, String qName) throws SAXException", "public void characters(char[] ch, int start, int length) throws SAXException", "public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException", "public void processingInstruction(String target, String data) throws SAXException", "public void skippedEntity(String name) throws SAXException" ],
  "variableNames" : [ ]
}