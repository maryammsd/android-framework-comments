{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/icu/text/UTF16.java",
  "packageName" : "android.icu.text",
  "className" : "UTF16",
  "comment" : "",
  "links" : [ ],
  "variables" : [ {
    "name" : "SINGLE_CHAR_BOUNDARY",
    "type" : "int",
    "comment" : "\n     * Value returned in {@link #bounds(String, int) bounds()}.\n     * These values are chosen specifically so that it actually represents the position of the\n     * character [offset16 - (value &gt;&gt; 2), offset16 + (value &amp; 3)]\n     ",
    "links" : [ "#bounds(String" ]
  }, {
    "name" : "LEAD_SURROGATE_BOUNDARY",
    "type" : "int",
    "comment" : "\n     * Value returned in {@link #bounds(String, int) bounds()}.\n     * These values are chosen specifically so that it actually represents the position of the\n     * character [offset16 - (value &gt;&gt; 2), offset16 + (value &amp; 3)]\n     ",
    "links" : [ "#bounds(String" ]
  }, {
    "name" : "TRAIL_SURROGATE_BOUNDARY",
    "type" : "int",
    "comment" : "\n     * Value returned in {@link #bounds(String, int) bounds()}.\n     * These values are chosen specifically so that it actually represents the position of the\n     * character [offset16 - (value &gt;&gt; 2), offset16 + (value &amp; 3)]\n     ",
    "links" : [ "#bounds(String" ]
  }, {
    "name" : "CODEPOINT_MIN_VALUE",
    "type" : "int",
    "comment" : "\n     * The lowest Unicode code point value.\n     ",
    "links" : [ ]
  }, {
    "name" : "CODEPOINT_MAX_VALUE",
    "type" : "int",
    "comment" : "\n     * The highest Unicode code point value (scalar value) according to the Unicode Standard.\n     ",
    "links" : [ ]
  }, {
    "name" : "SUPPLEMENTARY_MIN_VALUE",
    "type" : "int",
    "comment" : "\n     * The minimum value for Supplementary code points\n     ",
    "links" : [ ]
  }, {
    "name" : "LEAD_SURROGATE_MIN_VALUE",
    "type" : "int",
    "comment" : "\n     * Lead surrogate minimum value\n     ",
    "links" : [ ]
  }, {
    "name" : "TRAIL_SURROGATE_MIN_VALUE",
    "type" : "int",
    "comment" : "\n     * Trail surrogate minimum value\n     ",
    "links" : [ ]
  }, {
    "name" : "LEAD_SURROGATE_MAX_VALUE",
    "type" : "int",
    "comment" : "\n     * Lead surrogate maximum value\n     ",
    "links" : [ ]
  }, {
    "name" : "TRAIL_SURROGATE_MAX_VALUE",
    "type" : "int",
    "comment" : "\n     * Trail surrogate maximum value\n     ",
    "links" : [ ]
  }, {
    "name" : "SURROGATE_MIN_VALUE",
    "type" : "int",
    "comment" : "\n     * Surrogate minimum value\n     ",
    "links" : [ ]
  }, {
    "name" : "SURROGATE_MAX_VALUE",
    "type" : "int",
    "comment" : "\n     * Maximum surrogate value\n     ",
    "links" : [ ]
  }, {
    "name" : "LEAD_SURROGATE_BITMASK",
    "type" : "int",
    "comment" : "\n     * Lead surrogate bitmask\n     ",
    "links" : [ ]
  }, {
    "name" : "TRAIL_SURROGATE_BITMASK",
    "type" : "int",
    "comment" : "\n     * Trail surrogate bitmask\n     ",
    "links" : [ ]
  }, {
    "name" : "SURROGATE_BITMASK",
    "type" : "int",
    "comment" : "\n     * Surrogate bitmask\n     ",
    "links" : [ ]
  }, {
    "name" : "LEAD_SURROGATE_BITS",
    "type" : "int",
    "comment" : "\n     * Lead surrogate bits\n     ",
    "links" : [ ]
  }, {
    "name" : "TRAIL_SURROGATE_BITS",
    "type" : "int",
    "comment" : "\n     * Trail surrogate bits\n     ",
    "links" : [ ]
  }, {
    "name" : "SURROGATE_BITS",
    "type" : "int",
    "comment" : "\n     * Surrogate bits\n     ",
    "links" : [ ]
  }, {
    "name" : "LEAD_SURROGATE_SHIFT_",
    "type" : "int",
    "comment" : "\n     * Shift value for lead surrogate to form a supplementary character.\n     ",
    "links" : [ ]
  }, {
    "name" : "TRAIL_SURROGATE_MASK_",
    "type" : "int",
    "comment" : "\n     * Mask to retrieve the significant value from a trail surrogate.\n     ",
    "links" : [ ]
  }, {
    "name" : "LEAD_SURROGATE_OFFSET_",
    "type" : "int",
    "comment" : "\n     * Value that all lead surrogate starts with\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static int charAt(String source, int offset16)",
    "returnType" : "int",
    "comment" : "\n     * Extract a single UTF-32 value from a string. Used when iterating forwards or backwards (with\n     * <code>UTF16.getCharCount()</code>, as well as random access. If a validity check is\n     * required, use <code><a href=\"../lang/UCharacter.html#isLegal(char)\">\n     * UCharacter.isLegal()</a></code>\n     * on the return value. If the char retrieved is part of a surrogate pair, its supplementary\n     * character will be returned. If a complete supplementary character is not found the incomplete\n     * character will be returned\n     *\n     * @param source Array of UTF-16 chars\n     * @param offset16 UTF-16 offset to the start of the character.\n     * @return UTF-32 value for the UTF-32 value that contains the char at offset16. The boundaries\n     *         of that codepoint are the same as in <code>bounds32()</code>.\n     * @exception IndexOutOfBoundsException Thrown if offset16 is out of bounds.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static int _charAt(String source, int offset16, char single)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static int charAt(CharSequence source, int offset16)",
    "returnType" : "int",
    "comment" : "\n     * Extract a single UTF-32 value from a string. Used when iterating forwards or backwards (with\n     * <code>UTF16.getCharCount()</code>, as well as random access. If a validity check is\n     * required, use <code><a href=\"../lang/UCharacter.html#isLegal(char)\">\n     * UCharacter.isLegal()</a></code>\n     * on the return value. If the char retrieved is part of a surrogate pair, its supplementary\n     * character will be returned. If a complete supplementary character is not found the incomplete\n     * character will be returned\n     *\n     * @param source Array of UTF-16 chars\n     * @param offset16 UTF-16 offset to the start of the character.\n     * @return UTF-32 value for the UTF-32 value that contains the char at offset16. The boundaries\n     *         of that codepoint are the same as in <code>bounds32()</code>.\n     * @exception IndexOutOfBoundsException Thrown if offset16 is out of bounds.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static int _charAt(CharSequence source, int offset16, char single)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static int charAt(StringBuffer source, int offset16)",
    "returnType" : "int",
    "comment" : "\n     * Extract a single UTF-32 value from a string. Used when iterating forwards or backwards (with\n     * <code>UTF16.getCharCount()</code>, as well as random access. If a validity check is\n     * required, use <code><a href=\"../lang/UCharacter.html#isLegal(char)\">UCharacter.isLegal()\n     * </a></code>\n     * on the return value. If the char retrieved is part of a surrogate pair, its supplementary\n     * character will be returned. If a complete supplementary character is not found the incomplete\n     * character will be returned\n     *\n     * @param source UTF-16 chars string buffer\n     * @param offset16 UTF-16 offset to the start of the character.\n     * @return UTF-32 value for the UTF-32 value that contains the char at offset16. The boundaries\n     *         of that codepoint are the same as in <code>bounds32()</code>.\n     * @exception IndexOutOfBoundsException Thrown if offset16 is out of bounds.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int charAt(char[] source, int start, int limit, int offset16)",
    "returnType" : "int",
    "comment" : "\n     * Extract a single UTF-32 value from a substring. Used when iterating forwards or backwards\n     * (with <code>UTF16.getCharCount()</code>, as well as random access. If a validity check is\n     * required, use <code><a href=\"../lang/UCharacter.html#isLegal(char)\">UCharacter.isLegal()\n     * </a></code>\n     * on the return value. If the char retrieved is part of a surrogate pair, its supplementary\n     * character will be returned. If a complete supplementary character is not found the incomplete\n     * character will be returned\n     *\n     * @param source Array of UTF-16 chars\n     * @param start Offset to substring in the source array for analyzing\n     * @param limit Offset to substring in the source array for analyzing\n     * @param offset16 UTF-16 offset relative to start\n     * @return UTF-32 value for the UTF-32 value that contains the char at offset16. The boundaries\n     *         of that codepoint are the same as in <code>bounds32()</code>.\n     * @exception IndexOutOfBoundsException Thrown if offset16 is not within the range of start and limit.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int charAt(Replaceable source, int offset16)",
    "returnType" : "int",
    "comment" : "\n     * Extract a single UTF-32 value from a string. Used when iterating forwards or backwards (with\n     * <code>UTF16.getCharCount()</code>, as well as random access. If a validity check is\n     * required, use <code><a href=\"../lang/UCharacter.html#isLegal(char)\">UCharacter.isLegal()\n     * </a></code>\n     * on the return value. If the char retrieved is part of a surrogate pair, its supplementary\n     * character will be returned. If a complete supplementary character is not found the incomplete\n     * character will be returned\n     *\n     * @param source UTF-16 chars string buffer\n     * @param offset16 UTF-16 offset to the start of the character.\n     * @return UTF-32 value for the UTF-32 value that contains the char at offset16. The boundaries\n     *         of that codepoint are the same as in <code>bounds32()</code>.\n     * @exception IndexOutOfBoundsException Thrown if offset16 is out of bounds.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getCharCount(int char32)",
    "returnType" : "int",
    "comment" : "\n     * Determines how many chars this char32 requires. If a validity check is required, use <code>\n     * <a href=\"../lang/UCharacter.html#isLegal(char)\">isLegal()</a></code>\n     * on char32 before calling.\n     *\n     * @param char32 The input codepoint.\n     * @return 2 if is in supplementary space, otherwise 1.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int bounds(String source, int offset16)",
    "returnType" : "int",
    "comment" : "\n     * Returns the type of the boundaries around the char at offset16. Used for random access.\n     *\n     * @param source Text to analyse\n     * @param offset16 UTF-16 offset\n     * @return\n     *            <ul>\n     *            <li> SINGLE_CHAR_BOUNDARY : a single char; the bounds are [offset16, offset16+1]\n     *            <li> LEAD_SURROGATE_BOUNDARY : a surrogate pair starting at offset16; the bounds\n     *            are [offset16, offset16 + 2]\n     *            <li> TRAIL_SURROGATE_BOUNDARY : a surrogate pair starting at offset16 - 1; the\n     *            bounds are [offset16 - 1, offset16 + 1]\n     *            </ul>\n     *            For bit-twiddlers, the return values for these are chosen so that the boundaries\n     *            can be gotten by: [offset16 - (value &gt;&gt; 2), offset16 + (value &amp; 3)].\n     * @exception IndexOutOfBoundsException If offset16 is out of bounds.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int bounds(StringBuffer source, int offset16)",
    "returnType" : "int",
    "comment" : "\n     * Returns the type of the boundaries around the char at offset16. Used for random access.\n     *\n     * @param source String buffer to analyse\n     * @param offset16 UTF16 offset\n     * @return\n     *            <ul>\n     *            <li> SINGLE_CHAR_BOUNDARY : a single char; the bounds are [offset16, offset16 + 1]\n     *            <li> LEAD_SURROGATE_BOUNDARY : a surrogate pair starting at offset16; the bounds\n     *            are [offset16, offset16 + 2]\n     *            <li> TRAIL_SURROGATE_BOUNDARY : a surrogate pair starting at offset16 - 1; the\n     *            bounds are [offset16 - 1, offset16 + 1]\n     *            </ul>\n     *            For bit-twiddlers, the return values for these are chosen so that the boundaries\n     *            can be gotten by: [offset16 - (value &gt;&gt; 2), offset16 + (value &amp; 3)].\n     * @exception IndexOutOfBoundsException If offset16 is out of bounds.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int bounds(char[] source, int start, int limit, int offset16)",
    "returnType" : "int",
    "comment" : "\n     * Returns the type of the boundaries around the char at offset16. Used for random access. Note\n     * that the boundaries are determined with respect to the subarray, hence the char array\n     * {0xD800, 0xDC00} has the result SINGLE_CHAR_BOUNDARY for start = offset16 = 0 and limit = 1.\n     *\n     * @param source Char array to analyse\n     * @param start Offset to substring in the source array for analyzing\n     * @param limit Offset to substring in the source array for analyzing\n     * @param offset16 UTF16 offset relative to start\n     * @return\n     *            <ul>\n     *            <li> SINGLE_CHAR_BOUNDARY : a single char; the bounds are\n     *            <li> LEAD_SURROGATE_BOUNDARY : a surrogate pair starting at offset16; the bounds\n     *            are [offset16, offset16 + 2]\n     *            <li> TRAIL_SURROGATE_BOUNDARY : a surrogate pair starting at offset16 - 1; the\n     *            bounds are [offset16 - 1, offset16 + 1]\n     *            </ul>\n     *            For bit-twiddlers, the boundary values for these are chosen so that the boundaries\n     *            can be gotten by: [offset16 - (boundvalue &gt;&gt; 2), offset16 + (boundvalue &amp; 3)].\n     * @exception IndexOutOfBoundsException If offset16 is not within the range of start and limit.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isSurrogate(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines whether the code point is a surrogate.\n     *\n     * @param codePoint The input character.\n     *        (In ICU 2.1-69 the type of this parameter was <code>char</code>.)\n     * @return true If the input code point is a surrogate.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isTrailSurrogate(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines whether the code point is a trail surrogate.\n     *\n     * @param codePoint The input character.\n     *        (In ICU 2.1-69 the type of this parameter was <code>char</code>.)\n     * @return true If the input code point is a trail surrogate.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isLeadSurrogate(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines whether the code point is a lead surrogate.\n     *\n     * @param codePoint The input character.\n     *        (In ICU 2.1-69 the type of this parameter was <code>char</code>.)\n     * @return true If the input code point is a lead surrogate\n     ",
    "links" : [ ]
  }, {
    "name" : "public static char getLeadSurrogate(int char32)",
    "returnType" : "char",
    "comment" : "\n     * Returns the lead surrogate. If a validity check is required, use\n     * <code><a href=\"../lang/UCharacter.html#isLegal(char)\">isLegal()</a></code> on char32\n     * before calling.\n     *\n     * @param char32 The input character.\n     * @return lead surrogate if the getCharCount(ch) is 2; <br>\n     *         and 0 otherwise (note: 0 is not a valid lead surrogate).\n     ",
    "links" : [ ]
  }, {
    "name" : "public static char getTrailSurrogate(int char32)",
    "returnType" : "char",
    "comment" : "\n     * Returns the trail surrogate. If a validity check is required, use\n     * <code><a href=\"../lang/UCharacter.html#isLegal(char)\">isLegal()</a></code> on char32\n     * before calling.\n     *\n     * @param char32 The input character.\n     * @return the trail surrogate if the getCharCount(ch) is 2; <br>\n     *         otherwise the character itself\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String valueOf(int char32)",
    "returnType" : "String",
    "comment" : "\n     * Convenience method corresponding to String.valueOf(char). Returns a one or two char string\n     * containing the UTF-32 value in UTF16 format. If a validity check is required, use\n     * {@link android.icu.lang.UCharacter#isLegal(int)} on char32 before calling.\n     *\n     * @param char32 The input character.\n     * @return string value of char32 in UTF16 format\n     * @exception IllegalArgumentException Thrown if char32 is a invalid codepoint.\n     ",
    "links" : [ "android.icu.lang.UCharacter#isLegal(int)" ]
  }, {
    "name" : "public static String valueOf(String source, int offset16)",
    "returnType" : "String",
    "comment" : "\n     * Convenience method corresponding to String.valueOf(codepoint at offset16). Returns a one or\n     * two char string containing the UTF-32 value in UTF16 format. If offset16 indexes a surrogate\n     * character, the whole supplementary codepoint will be returned. If a validity check is\n     * required, use {@link android.icu.lang.UCharacter#isLegal(int)} on the\n     * codepoint at offset16 before calling. The result returned will be a newly created String\n     * obtained by calling source.substring(..) with the appropriate indexes.\n     *\n     * @param source The input string.\n     * @param offset16 The UTF16 index to the codepoint in source\n     * @return string value of char32 in UTF16 format\n     ",
    "links" : [ "android.icu.lang.UCharacter#isLegal(int)" ]
  }, {
    "name" : "public static String valueOf(StringBuffer source, int offset16)",
    "returnType" : "String",
    "comment" : "\n     * Convenience method corresponding to StringBuffer.valueOf(codepoint at offset16). Returns a\n     * one or two char string containing the UTF-32 value in UTF16 format. If offset16 indexes a\n     * surrogate character, the whole supplementary codepoint will be returned. If a validity check\n     * is required, use {@link android.icu.lang.UCharacter#isLegal(int)} on\n     * the codepoint at offset16 before calling. The result returned will be a newly created String\n     * obtained by calling source.substring(..) with the appropriate indexes.\n     *\n     * @param source The input string buffer.\n     * @param offset16 The UTF16 index to the codepoint in source\n     * @return string value of char32 in UTF16 format\n     ",
    "links" : [ "android.icu.lang.UCharacter#isLegal(int)" ]
  }, {
    "name" : "public static String valueOf(char[] source, int start, int limit, int offset16)",
    "returnType" : "String",
    "comment" : "\n     * Convenience method. Returns a one or two char string containing the UTF-32 value in UTF16\n     * format. If offset16 indexes a surrogate character, the whole supplementary codepoint will be\n     * returned, except when either the leading or trailing surrogate character lies out of the\n     * specified subarray. In the latter case, only the surrogate character within bounds will be\n     * returned. If a validity check is required, use\n     * {@link android.icu.lang.UCharacter#isLegal(int)} on the codepoint at\n     * offset16 before calling. The result returned will be a newly created String containing the\n     * relevant characters.\n     *\n     * @param source The input char array.\n     * @param start Start index of the subarray\n     * @param limit End index of the subarray\n     * @param offset16 The UTF16 index to the codepoint in source relative to start\n     * @return string value of char32 in UTF16 format\n     ",
    "links" : [ "android.icu.lang.UCharacter#isLegal(int)" ]
  }, {
    "name" : "public static int findOffsetFromCodePoint(String source, int offset32)",
    "returnType" : "int",
    "comment" : "\n     * Returns the UTF-16 offset that corresponds to a UTF-32 offset. Used for random access. See\n     * the {@link UTF16 class description} for notes on roundtripping.\n     *\n     * @param source The UTF-16 string\n     * @param offset32 UTF-32 offset\n     * @return UTF-16 offset\n     * @exception IndexOutOfBoundsException If offset32 is out of bounds.\n     ",
    "links" : [ "android.icu.text.UTF16" ]
  }, {
    "name" : "public static int findOffsetFromCodePoint(StringBuffer source, int offset32)",
    "returnType" : "int",
    "comment" : "\n     * Returns the UTF-16 offset that corresponds to a UTF-32 offset. Used for random access. See\n     * the {@link UTF16 class description} for notes on roundtripping.\n     *\n     * @param source The UTF-16 string buffer\n     * @param offset32 UTF-32 offset\n     * @return UTF-16 offset\n     * @exception IndexOutOfBoundsException If offset32 is out of bounds.\n     ",
    "links" : [ "android.icu.text.UTF16" ]
  }, {
    "name" : "public static int findOffsetFromCodePoint(char[] source, int start, int limit, int offset32)",
    "returnType" : "int",
    "comment" : "\n     * Returns the UTF-16 offset that corresponds to a UTF-32 offset. Used for random access. See\n     * the {@link UTF16 class description} for notes on roundtripping.\n     *\n     * @param source The UTF-16 char array whose substring is to be analysed\n     * @param start Offset of the substring to be analysed\n     * @param limit Offset of the substring to be analysed\n     * @param offset32 UTF-32 offset relative to start\n     * @return UTF-16 offset relative to start\n     * @exception IndexOutOfBoundsException If offset32 is out of bounds.\n     ",
    "links" : [ "android.icu.text.UTF16" ]
  }, {
    "name" : "public static int findCodePointOffset(String source, int offset16)",
    "returnType" : "int",
    "comment" : "\n     * Returns the UTF-32 offset corresponding to the first UTF-32 boundary at or after the given\n     * UTF-16 offset. Used for random access. See the {@link UTF16 class description} for\n     * notes on roundtripping.<br>\n     * <i>Note: If the UTF-16 offset is into the middle of a surrogate pair, then the UTF-32 offset\n     * of the <strong>lead</strong> of the pair is returned. </i>\n     * <p>\n     * To find the UTF-32 length of a string, use:\n     *\n     * <pre>\n     * len32 = countCodePoint(source, source.length());\n     * </pre>\n     *\n     * @param source Text to analyse\n     * @param offset16 UTF-16 offset &lt; source text length.\n     * @return UTF-32 offset\n     * @exception IndexOutOfBoundsException If offset16 is out of bounds.\n     ",
    "links" : [ "android.icu.text.UTF16" ]
  }, {
    "name" : "public static int findCodePointOffset(StringBuffer source, int offset16)",
    "returnType" : "int",
    "comment" : "\n     * Returns the UTF-32 offset corresponding to the first UTF-32 boundary at the given UTF-16\n     * offset. Used for random access. See the {@link UTF16 class description} for notes on\n     * roundtripping.<br>\n     * <i>Note: If the UTF-16 offset is into the middle of a surrogate pair, then the UTF-32 offset\n     * of the <strong>lead</strong> of the pair is returned. </i>\n     * <p>\n     * To find the UTF-32 length of a string, use:\n     *\n     * <pre>\n     * len32 = countCodePoint(source);\n     * </pre>\n     *\n     * @param source Text to analyse\n     * @param offset16 UTF-16 offset &lt; source text length.\n     * @return UTF-32 offset\n     * @exception IndexOutOfBoundsException If offset16 is out of bounds.\n     ",
    "links" : [ "android.icu.text.UTF16" ]
  }, {
    "name" : "public static int findCodePointOffset(char[] source, int start, int limit, int offset16)",
    "returnType" : "int",
    "comment" : "\n     * Returns the UTF-32 offset corresponding to the first UTF-32 boundary at the given UTF-16\n     * offset. Used for random access. See the {@link UTF16 class description} for notes on\n     * roundtripping.<br>\n     * <i>Note: If the UTF-16 offset is into the middle of a surrogate pair, then the UTF-32 offset\n     * of the <strong>lead</strong> of the pair is returned. </i>\n     * <p>\n     * To find the UTF-32 length of a substring, use:\n     *\n     * <pre>\n     * len32 = countCodePoint(source, start, limit);\n     * </pre>\n     *\n     * @param source Text to analyse\n     * @param start Offset of the substring\n     * @param limit Offset of the substring\n     * @param offset16 UTF-16 relative to start\n     * @return UTF-32 offset relative to start\n     * @exception IndexOutOfBoundsException If offset16 is not within the range of start and limit.\n     ",
    "links" : [ "android.icu.text.UTF16" ]
  }, {
    "name" : "public static StringBuffer append(StringBuffer target, int char32)",
    "returnType" : "StringBuffer",
    "comment" : "\n     * Append a single UTF-32 value to the end of a StringBuffer. If a validity check is required,\n     * use {@link android.icu.lang.UCharacter#isLegal(int)} on char32 before\n     * calling.\n     *\n     * @param target The buffer to append to\n     * @param char32 Value to append.\n     * @return the updated StringBuffer\n     * @exception IllegalArgumentException Thrown when char32 does not lie within the range of the Unicode codepoints\n     ",
    "links" : [ "android.icu.lang.UCharacter#isLegal(int)" ]
  }, {
    "name" : "public static StringBuffer appendCodePoint(StringBuffer target, int cp)",
    "returnType" : "StringBuffer",
    "comment" : "\n     * Cover JDK 1.5 APIs. Append the code point to the buffer and return the buffer as a\n     * convenience.\n     *\n     * @param target The buffer to append to\n     * @param cp The code point to append\n     * @return the updated StringBuffer\n     * @throws IllegalArgumentException If cp is not a valid code point\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int append(char[] target, int limit, int char32)",
    "returnType" : "int",
    "comment" : "\n     * Adds a codepoint to offset16 position of the argument char array.\n     *\n     * @param target Char array to be append with the new code point\n     * @param limit UTF16 offset which the codepoint will be appended.\n     * @param char32 Code point to be appended\n     * @return offset after char32 in the array.\n     * @exception IllegalArgumentException Thrown if there is not enough space for the append, or when char32 does not\n     *                lie within the range of the Unicode codepoints.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int countCodePoint(String source)",
    "returnType" : "int",
    "comment" : "\n     * Number of codepoints in a UTF16 String\n     *\n     * @param source UTF16 string\n     * @return number of codepoint in string\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int countCodePoint(StringBuffer source)",
    "returnType" : "int",
    "comment" : "\n     * Number of codepoints in a UTF16 String buffer\n     *\n     * @param source UTF16 string buffer\n     * @return number of codepoint in string\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int countCodePoint(char[] source, int start, int limit)",
    "returnType" : "int",
    "comment" : "\n     * Number of codepoints in a UTF16 char array substring\n     *\n     * @param source UTF16 char array\n     * @param start Offset of the substring\n     * @param limit Offset of the substring\n     * @return number of codepoint in the substring\n     * @exception IndexOutOfBoundsException If start and limit are not valid.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void setCharAt(StringBuffer target, int offset16, int char32)",
    "returnType" : "void",
    "comment" : "\n     * Set a code point into a UTF16 position. Adjusts target according if we are replacing a\n     * non-supplementary codepoint with a supplementary and vice versa.\n     *\n     * @param target Stringbuffer\n     * @param offset16 UTF16 position to insert into\n     * @param char32 Code point\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int setCharAt(char[] target, int limit, int offset16, int char32)",
    "returnType" : "int",
    "comment" : "\n     * Set a code point into a UTF16 position in a char array. Adjusts target according if we are\n     * replacing a non-supplementary codepoint with a supplementary and vice versa.\n     *\n     * @param target char array\n     * @param limit numbers of valid chars in target, different from target.length. limit counts the\n     *            number of chars in target that represents a string, not the size of array target.\n     * @param offset16 UTF16 position to insert into\n     * @param char32 code point\n     * @return new number of chars in target that represents a string\n     * @exception IndexOutOfBoundsException if offset16 is out of range\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int moveCodePointOffset(String source, int offset16, int shift32)",
    "returnType" : "int",
    "comment" : "\n     * Shifts offset16 by the argument number of codepoints\n     *\n     * @param source string\n     * @param offset16 UTF16 position to shift\n     * @param shift32 number of codepoints to shift\n     * @return new shifted offset16\n     * @exception IndexOutOfBoundsException if the new offset16 is out of bounds.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int moveCodePointOffset(StringBuffer source, int offset16, int shift32)",
    "returnType" : "int",
    "comment" : "\n     * Shifts offset16 by the argument number of codepoints\n     *\n     * @param source String buffer\n     * @param offset16 UTF16 position to shift\n     * @param shift32 Number of codepoints to shift\n     * @return new shifted offset16\n     * @exception IndexOutOfBoundsException If the new offset16 is out of bounds.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int moveCodePointOffset(char[] source, int start, int limit, int offset16, int shift32)",
    "returnType" : "int",
    "comment" : "\n     * Shifts offset16 by the argument number of codepoints within a subarray.\n     *\n     * @param source Char array\n     * @param start Position of the subarray to be performed on\n     * @param limit Position of the subarray to be performed on\n     * @param offset16 UTF16 position to shift relative to start\n     * @param shift32 Number of codepoints to shift\n     * @return new shifted offset16 relative to start\n     * @exception IndexOutOfBoundsException If the new offset16 is out of bounds with respect to the subarray or the\n     *                subarray bounds are out of range.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static StringBuffer insert(StringBuffer target, int offset16, int char32)",
    "returnType" : "StringBuffer",
    "comment" : "\n     * Inserts char32 codepoint into target at the argument offset16. If the offset16 is in the\n     * middle of a supplementary codepoint, char32 will be inserted after the supplementary\n     * codepoint. The length of target increases by one if codepoint is non-supplementary, 2\n     * otherwise.\n     * <p>\n     * The overall effect is exactly as if the argument were converted to a string by the method\n     * valueOf(char) and the characters in that string were then inserted into target at the\n     * position indicated by offset16.\n     * </p>\n     * <p>\n     * The offset argument must be greater than or equal to 0, and less than or equal to the length\n     * of source.\n     *\n     * @param target String buffer to insert to\n     * @param offset16 Offset which char32 will be inserted in\n     * @param char32 Codepoint to be inserted\n     * @return a reference to target\n     * @exception IndexOutOfBoundsException Thrown if offset16 is invalid.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int insert(char[] target, int limit, int offset16, int char32)",
    "returnType" : "int",
    "comment" : "\n     * Inserts char32 codepoint into target at the argument offset16. If the offset16 is in the\n     * middle of a supplementary codepoint, char32 will be inserted after the supplementary\n     * codepoint. Limit increases by one if codepoint is non-supplementary, 2 otherwise.\n     * <p>\n     * The overall effect is exactly as if the argument were converted to a string by the method\n     * valueOf(char) and the characters in that string were then inserted into target at the\n     * position indicated by offset16.\n     * </p>\n     * <p>\n     * The offset argument must be greater than or equal to 0, and less than or equal to the limit.\n     *\n     * @param target Char array to insert to\n     * @param limit End index of the char array, limit &lt;= target.length\n     * @param offset16 Offset which char32 will be inserted in\n     * @param char32 Codepoint to be inserted\n     * @return new limit size\n     * @exception IndexOutOfBoundsException Thrown if offset16 is invalid.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static StringBuffer delete(StringBuffer target, int offset16)",
    "returnType" : "StringBuffer",
    "comment" : "\n     * Removes the codepoint at the specified position in this target (shortening target by 1\n     * character if the codepoint is a non-supplementary, 2 otherwise).\n     *\n     * @param target String buffer to remove codepoint from\n     * @param offset16 Offset which the codepoint will be removed\n     * @return a reference to target\n     * @exception IndexOutOfBoundsException Thrown if offset16 is invalid.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int delete(char[] target, int limit, int offset16)",
    "returnType" : "int",
    "comment" : "\n     * Removes the codepoint at the specified position in this target (shortening target by 1\n     * character if the codepoint is a non-supplementary, 2 otherwise).\n     *\n     * @param target String buffer to remove codepoint from\n     * @param limit End index of the char array, limit &lt;= target.length\n     * @param offset16 Offset which the codepoint will be removed\n     * @return a new limit size\n     * @exception IndexOutOfBoundsException Thrown if offset16 is invalid.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int indexOf(String source, int char32)",
    "returnType" : "int",
    "comment" : "\n     * Returns the index within the argument UTF16 format Unicode string of the first occurrence of\n     * the argument codepoint. I.e., the smallest index <code>i</code> such that\n     * <code>UTF16.charAt(source, i) ==\n     * char32</code> is true.\n     * <p>\n     * If no such character occurs in this string, then -1 is returned.\n     * </p>\n     * <p>\n     * Examples:<br>\n     * UTF16.indexOf(\"abc\", 'a') returns 0<br>\n     * UTF16.indexOf(\"abc\\ud800\\udc00\", 0x10000) returns 3<br>\n     * UTF16.indexOf(\"abc\\ud800\\udc00\", 0xd800) returns -1<br>\n     * </p>\n     * Note this method is provided as support to jdk 1.3, which does not support supplementary\n     * characters to its fullest.\n     *\n     * @param source UTF16 format Unicode string that will be searched\n     * @param char32 Codepoint to search for\n     * @return the index of the first occurrence of the codepoint in the argument Unicode string, or\n     *         -1 if the codepoint does not occur.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int indexOf(String source, String str)",
    "returnType" : "int",
    "comment" : "\n     * Returns the index within the argument UTF16 format Unicode string of the first occurrence of\n     * the argument string str. This method is implemented based on codepoints, hence a \"lead\n     * surrogate character + trail surrogate character\" is treated as one entity.e Hence if the str\n     * starts with trail surrogate character at index 0, a source with a leading a surrogate\n     * character before str found at in source will not have a valid match. Vice versa for lead\n     * surrogates that ends str. See example below.\n     * <p>\n     * If no such string str occurs in this source, then -1 is returned.\n     * </p>\n     * <p>\n     * Examples:<br>\n     * UTF16.indexOf(\"abc\", \"ab\") returns 0<br>\n     * UTF16.indexOf(\"abc\\ud800\\udc00\", \"\\ud800\\udc00\") returns 3<br>\n     * UTF16.indexOf(\"abc\\ud800\\udc00\", \"\\ud800\") returns -1<br>\n     * </p>\n     * Note this method is provided as support to jdk 1.3, which does not support supplementary\n     * characters to its fullest.\n     *\n     * @param source UTF16 format Unicode string that will be searched\n     * @param str UTF16 format Unicode string to search for\n     * @return the index of the first occurrence of the codepoint in the argument Unicode string, or\n     *         -1 if the codepoint does not occur.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int indexOf(String source, int char32, int fromIndex)",
    "returnType" : "int",
    "comment" : "\n     * Returns the index within the argument UTF16 format Unicode string of the first occurrence of\n     * the argument codepoint. I.e., the smallest index i such that: <br>\n     * (UTF16.charAt(source, i) == char32 &amp;&amp; i &gt;= fromIndex) is true.\n     * <p>\n     * If no such character occurs in this string, then -1 is returned.\n     * </p>\n     * <p>\n     * Examples:<br>\n     * UTF16.indexOf(\"abc\", 'a', 1) returns -1<br>\n     * UTF16.indexOf(\"abc\\ud800\\udc00\", 0x10000, 1) returns 3<br>\n     * UTF16.indexOf(\"abc\\ud800\\udc00\", 0xd800, 1) returns -1<br>\n     * </p>\n     * Note this method is provided as support to jdk 1.3, which does not support supplementary\n     * characters to its fullest.\n     *\n     * @param source UTF16 format Unicode string that will be searched\n     * @param char32 Codepoint to search for\n     * @param fromIndex The index to start the search from.\n     * @return the index of the first occurrence of the codepoint in the argument Unicode string at\n     *         or after fromIndex, or -1 if the codepoint does not occur.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int indexOf(String source, String str, int fromIndex)",
    "returnType" : "int",
    "comment" : "\n     * Returns the index within the argument UTF16 format Unicode string of the first occurrence of\n     * the argument string str. This method is implemented based on codepoints, hence a \"lead\n     * surrogate character + trail surrogate character\" is treated as one entity.e Hence if the str\n     * starts with trail surrogate character at index 0, a source with a leading a surrogate\n     * character before str found at in source will not have a valid match. Vice versa for lead\n     * surrogates that ends str. See example below.\n     * <p>\n     * If no such string str occurs in this source, then -1 is returned.\n     * </p>\n     * <p>\n     * Examples:<br>\n     * UTF16.indexOf(\"abc\", \"ab\", 0) returns 0<br>\n     * UTF16.indexOf(\"abc\\ud800\\udc00\", \"\\ud800\\udc00\", 0) returns 3<br>\n     * UTF16.indexOf(\"abc\\ud800\\udc00\", \"\\ud800\\udc00\", 2) returns 3<br>\n     * UTF16.indexOf(\"abc\\ud800\\udc00\", \"\\ud800\", 0) returns -1<br>\n     * </p>\n     * Note this method is provided as support to jdk 1.3, which does not support supplementary\n     * characters to its fullest.\n     *\n     * @param source UTF16 format Unicode string that will be searched\n     * @param str UTF16 format Unicode string to search for\n     * @param fromIndex The index to start the search from.\n     * @return the index of the first occurrence of the codepoint in the argument Unicode string, or\n     *         -1 if the codepoint does not occur.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int lastIndexOf(String source, int char32)",
    "returnType" : "int",
    "comment" : "\n     * Returns the index within the argument UTF16 format Unicode string of the last occurrence of\n     * the argument codepoint. I.e., the index returned is the largest value i such that:\n     * UTF16.charAt(source, i) == char32 is true.\n     * <p>\n     * Examples:<br>\n     * UTF16.lastIndexOf(\"abc\", 'a') returns 0<br>\n     * UTF16.lastIndexOf(\"abc\\ud800\\udc00\", 0x10000) returns 3<br>\n     * UTF16.lastIndexOf(\"abc\\ud800\\udc00\", 0xd800) returns -1<br>\n     * </p>\n     * <p>\n     * source is searched backwards starting at the last character.\n     * </p>\n     * Note this method is provided as support to jdk 1.3, which does not support supplementary\n     * characters to its fullest.\n     *\n     * @param source UTF16 format Unicode string that will be searched\n     * @param char32 Codepoint to search for\n     * @return the index of the last occurrence of the codepoint in source, or -1 if the codepoint\n     *         does not occur.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int lastIndexOf(String source, String str)",
    "returnType" : "int",
    "comment" : "\n     * Returns the index within the argument UTF16 format Unicode string of the last occurrence of\n     * the argument string str. This method is implemented based on codepoints, hence a \"lead\n     * surrogate character + trail surrogate character\" is treated as one entity.e Hence if the str\n     * starts with trail surrogate character at index 0, a source with a leading a surrogate\n     * character before str found at in source will not have a valid match. Vice versa for lead\n     * surrogates that ends str. See example below.\n     * <p>\n     * Examples:<br>\n     * UTF16.lastIndexOf(\"abc\", \"a\") returns 0<br>\n     * UTF16.lastIndexOf(\"abc\\ud800\\udc00\", \"\\ud800\\udc00\") returns 3<br>\n     * UTF16.lastIndexOf(\"abc\\ud800\\udc00\", \"\\ud800\") returns -1<br>\n     * </p>\n     * <p>\n     * source is searched backwards starting at the last character.\n     * </p>\n     * Note this method is provided as support to jdk 1.3, which does not support supplementary\n     * characters to its fullest.\n     *\n     * @param source UTF16 format Unicode string that will be searched\n     * @param str UTF16 format Unicode string to search for\n     * @return the index of the last occurrence of the codepoint in source, or -1 if the codepoint\n     *         does not occur.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int lastIndexOf(String source, int char32, int fromIndex)",
    "returnType" : "int",
    "comment" : "\n     * <p>\n     * Returns the index within the argument UTF16 format Unicode string of the last occurrence of\n     * the argument codepoint, where the result is less than or equals to fromIndex.\n     * </p>\n     * <p>\n     * This method is implemented based on codepoints, hence a single surrogate character will not\n     * match a supplementary character.\n     * </p>\n     * <p>\n     * source is searched backwards starting at the last character starting at the specified index.\n     * </p>\n     * <p>\n     * Examples:<br>\n     * UTF16.lastIndexOf(\"abc\", 'c', 2) returns 2<br>\n     * UTF16.lastIndexOf(\"abc\", 'c', 1) returns -1<br>\n     * UTF16.lastIndexOf(\"abc\\ud800\\udc00\", 0x10000, 5) returns 3<br>\n     * UTF16.lastIndexOf(\"abc\\ud800\\udc00\", 0x10000, 3) returns 3<br>\n     * UTF16.lastIndexOf(\"abc\\ud800\\udc00\", 0xd800) returns -1<br>\n     * </p>\n     * Note this method is provided as support to jdk 1.3, which does not support supplementary\n     * characters to its fullest.\n     *\n     * @param source UTF16 format Unicode string that will be searched\n     * @param char32 Codepoint to search for\n     * @param fromIndex the index to start the search from. There is no restriction on the value of\n     *            fromIndex. If it is greater than or equal to the length of this string, it has the\n     *            same effect as if it were equal to one less than the length of this string: this\n     *            entire string may be searched. If it is negative, it has the same effect as if it\n     *            were -1: -1 is returned.\n     * @return the index of the last occurrence of the codepoint in source, or -1 if the codepoint\n     *         does not occur.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int lastIndexOf(String source, String str, int fromIndex)",
    "returnType" : "int",
    "comment" : "\n     * <p>\n     * Returns the index within the argument UTF16 format Unicode string of the last occurrence of\n     * the argument string str, where the result is less than or equals to fromIndex.\n     * </p>\n     * <p>\n     * This method is implemented based on codepoints, hence a \"lead surrogate character + trail\n     * surrogate character\" is treated as one entity. Hence if the str starts with trail surrogate\n     * character at index 0, a source with a leading a surrogate character before str found at in\n     * source will not have a valid match. Vice versa for lead surrogates that ends str.\n     * </p>\n     * See example below.\n     * <p>\n     * Examples:<br>\n     * UTF16.lastIndexOf(\"abc\", \"c\", 2) returns 2<br>\n     * UTF16.lastIndexOf(\"abc\", \"c\", 1) returns -1<br>\n     * UTF16.lastIndexOf(\"abc\\ud800\\udc00\", \"\\ud800\\udc00\", 5) returns 3<br>\n     * UTF16.lastIndexOf(\"abc\\ud800\\udc00\", \"\\ud800\\udc00\", 3) returns 3<br>\n     * UTF16.lastIndexOf(\"abc\\ud800\\udc00\", \"\\ud800\", 4) returns -1<br>\n     * </p>\n     * <p>\n     * source is searched backwards starting at the last character.\n     * </p>\n     * Note this method is provided as support to jdk 1.3, which does not support supplementary\n     * characters to its fullest.\n     *\n     * @param source UTF16 format Unicode string that will be searched\n     * @param str UTF16 format Unicode string to search for\n     * @param fromIndex the index to start the search from. There is no restriction on the value of\n     *            fromIndex. If it is greater than or equal to the length of this string, it has the\n     *            same effect as if it were equal to one less than the length of this string: this\n     *            entire string may be searched. If it is negative, it has the same effect as if it\n     *            were -1: -1 is returned.\n     * @return the index of the last occurrence of the codepoint in source, or -1 if the codepoint\n     *         does not occur.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String replace(String source, int oldChar32, int newChar32)",
    "returnType" : "String",
    "comment" : "\n     * Returns a new UTF16 format Unicode string resulting from replacing all occurrences of\n     * oldChar32 in source with newChar32. If the character oldChar32 does not occur in the UTF16\n     * format Unicode string source, then source will be returned. Otherwise, a new String object is\n     * created that represents a codepoint sequence identical to the codepoint sequence represented\n     * by source, except that every occurrence of oldChar32 is replaced by an occurrence of\n     * newChar32.\n     * <p>\n     * Examples: <br>\n     * UTF16.replace(\"mesquite in your cellar\", 'e', 'o');<br>\n     * returns \"mosquito in your collar\"<br>\n     * UTF16.replace(\"JonL\", 'q', 'x');<br>\n     * returns \"JonL\" (no change)<br>\n     * UTF16.replace(\"Supplementary character \\ud800\\udc00\", 0x10000, '!'); <br>\n     * returns \"Supplementary character !\"<br>\n     * UTF16.replace(\"Supplementary character \\ud800\\udc00\", 0xd800, '!'); <br>\n     * returns \"Supplementary character \\ud800\\udc00\"<br>\n     * </p>\n     * Note this method is provided as support to jdk 1.3, which does not support supplementary\n     * characters to its fullest.\n     *\n     * @param source UTF16 format Unicode string which the codepoint replacements will be based on.\n     * @param oldChar32 Non-zero old codepoint to be replaced.\n     * @param newChar32 The new codepoint to replace oldChar32\n     * @return new String derived from source by replacing every occurrence of oldChar32 with\n     *         newChar32, unless when no oldChar32 is found in source then source will be returned.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String replace(String source, String oldStr, String newStr)",
    "returnType" : "String",
    "comment" : "\n     * Returns a new UTF16 format Unicode string resulting from replacing all occurrences of oldStr\n     * in source with newStr. If the string oldStr does not occur in the UTF16 format Unicode string\n     * source, then source will be returned. Otherwise, a new String object is created that\n     * represents a codepoint sequence identical to the codepoint sequence represented by source,\n     * except that every occurrence of oldStr is replaced by an occurrence of newStr.\n     * <p>\n     * Examples: <br>\n     * UTF16.replace(\"mesquite in your cellar\", \"e\", \"o\");<br>\n     * returns \"mosquito in your collar\"<br>\n     * UTF16.replace(\"mesquite in your cellar\", \"mesquite\", \"cat\");<br>\n     * returns \"cat in your cellar\"<br>\n     * UTF16.replace(\"JonL\", \"q\", \"x\");<br>\n     * returns \"JonL\" (no change)<br>\n     * UTF16.replace(\"Supplementary character \\ud800\\udc00\", \"\\ud800\\udc00\", '!'); <br>\n     * returns \"Supplementary character !\"<br>\n     * UTF16.replace(\"Supplementary character \\ud800\\udc00\", \"\\ud800\", '!'); <br>\n     * returns \"Supplementary character \\ud800\\udc00\"<br>\n     * </p>\n     * Note this method is provided as support to jdk 1.3, which does not support supplementary\n     * characters to its fullest.\n     *\n     * @param source UTF16 format Unicode string which the replacements will be based on.\n     * @param oldStr Non-zero-length string to be replaced.\n     * @param newStr The new string to replace oldStr\n     * @return new String derived from source by replacing every occurrence of oldStr with newStr.\n     *         When no oldStr is found in source, then source will be returned.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static StringBuffer reverse(StringBuffer source)",
    "returnType" : "StringBuffer",
    "comment" : "\n     * Reverses a UTF16 format Unicode string and replaces source's content with it. This method\n     * will reverse surrogate characters correctly, instead of blindly reversing every character.\n     * <p>\n     * Examples:<br>\n     * UTF16.reverse(new StringBuffer( \"Supplementary characters \\ud800\\udc00\\ud801\\udc01\"))<br>\n     * returns \"\\ud801\\udc01\\ud800\\udc00 sretcarahc yratnemelppuS\".\n     *\n     * @param source The source StringBuffer that contains UTF16 format Unicode string to be reversed\n     * @return a modified source with reversed UTF16 format Unicode string.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean hasMoreCodePointsThan(String source, int number)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the string contains more Unicode code points than a certain number. This is more\n     * efficient than counting all code points in the entire string and comparing that number with a\n     * threshold. This function may not need to scan the string at all if the length is within a\n     * certain range, and never needs to count more than 'number + 1' code points. Logically\n     * equivalent to (countCodePoint(s) &gt; number). A Unicode code point may occupy either one or two\n     * code units.\n     *\n     * @param source The input string.\n     * @param number The number of code points in the string is compared against the 'number'\n     *            parameter.\n     * @return boolean value for whether the string contains more Unicode code points than 'number'.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean hasMoreCodePointsThan(char[] source, int start, int limit, int number)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the sub-range of char array, from argument start to limit, contains more Unicode\n     * code points than a certain number. This is more efficient than counting all code points in\n     * the entire char array range and comparing that number with a threshold. This function may not\n     * need to scan the char array at all if start and limit is within a certain range, and never\n     * needs to count more than 'number + 1' code points. Logically equivalent to\n     * (countCodePoint(source, start, limit) &gt; number). A Unicode code point may occupy either one\n     * or two code units.\n     *\n     * @param source Array of UTF-16 chars\n     * @param start Offset to substring in the source array for analyzing\n     * @param limit Offset to substring in the source array for analyzing\n     * @param number The number of code points in the string is compared against the 'number'\n     *            parameter.\n     * @return boolean value for whether the string contains more Unicode code points than 'number'.\n     * @exception IndexOutOfBoundsException Thrown when limit &lt; start\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean hasMoreCodePointsThan(StringBuffer source, int number)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the string buffer contains more Unicode code points than a certain number. This is\n     * more efficient than counting all code points in the entire string buffer and comparing that\n     * number with a threshold. This function may not need to scan the string buffer at all if the\n     * length is within a certain range, and never needs to count more than 'number + 1' code\n     * points. Logically equivalent to (countCodePoint(s) &gt; number). A Unicode code point may\n     * occupy either one or two code units.\n     *\n     * @param source The input string buffer.\n     * @param number The number of code points in the string buffer is compared against the 'number'\n     *            parameter.\n     * @return boolean value for whether the string buffer contains more Unicode code points than\n     *         'number'.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String newString(int[] codePoints, int offset, int count)",
    "returnType" : "String",
    "comment" : "\n     * Cover JDK 1.5 API. Create a String from an array of codePoints.\n     *\n     * @param codePoints The code array\n     * @param offset The start of the text in the code point array\n     * @param count The number of code points\n     * @return a String representing the code points between offset and count\n     * @throws IllegalArgumentException If an invalid code point is encountered\n     * @throws IndexOutOfBoundsException If the offset or count are out of bounds.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getSingleCodePoint(CharSequence s)",
    "returnType" : "int",
    "comment" : "\n     * Utility for getting a code point from a CharSequence that contains exactly one code point.\n     * @return the code point IF the string is non-null and consists of a single code point.\n     * otherwise returns -1.\n     * @param s to test\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int compareCodePoint(int codePoint, CharSequence s)",
    "returnType" : "int",
    "comment" : "\n     * Utility for comparing a code point to a string without having to create a new string. Returns the same results\n     * as a code point comparison of UTF16.valueOf(codePoint) and s.toString(). More specifically, if\n     * <pre>\n     * sc = new StringComparator(true,false,0);\n     * fast = UTF16.compareCodePoint(codePoint, charSequence)\n     * slower = sc.compare(UTF16.valueOf(codePoint), charSequence == null ? \"\" : charSequence.toString())\n     * </pre>\n     * then\n     * <pre>\n     * Integer.signum(fast) == Integer.signum(slower)\n     * </pre>\n     * @param codePoint to test\n     * @param s to test\n     * @return equivalent of code point comparator comparing two strings.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static String toString(int ch)",
    "returnType" : "String",
    "comment" : "\n     * <p>\n     * Converts argument code point and returns a String object representing the code point's value\n     * in UTF16 format.\n     * </p>\n     * <p>\n     * This method does not check for the validity of the codepoint, the results are not guaranteed\n     * if a invalid codepoint is passed as argument.\n     * </p>\n     * <p>\n     * The result is a string whose length is 1 for non-supplementary code points, 2 otherwise.\n     * </p>\n     *\n     * @param ch\n     *            code point\n     * @return string representation of the code point\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public static int charAt(String source, int offset16)", "private static int _charAt(String source, int offset16, char single)", "public static int charAt(CharSequence source, int offset16)", "private static int _charAt(CharSequence source, int offset16, char single)", "public static int charAt(StringBuffer source, int offset16)", "public static int charAt(char[] source, int start, int limit, int offset16)", "public static int charAt(Replaceable source, int offset16)", "public static int getCharCount(int char32)", "public static int bounds(String source, int offset16)", "public static int bounds(StringBuffer source, int offset16)", "public static int bounds(char[] source, int start, int limit, int offset16)", "public static boolean isSurrogate(int codePoint)", "public static boolean isTrailSurrogate(int codePoint)", "public static boolean isLeadSurrogate(int codePoint)", "public static char getLeadSurrogate(int char32)", "public static char getTrailSurrogate(int char32)", "public static String valueOf(int char32)", "public static String valueOf(String source, int offset16)", "public static String valueOf(StringBuffer source, int offset16)", "public static String valueOf(char[] source, int start, int limit, int offset16)", "public static int findOffsetFromCodePoint(String source, int offset32)", "public static int findOffsetFromCodePoint(StringBuffer source, int offset32)", "public static int findOffsetFromCodePoint(char[] source, int start, int limit, int offset32)", "public static int findCodePointOffset(String source, int offset16)", "public static int findCodePointOffset(StringBuffer source, int offset16)", "public static int findCodePointOffset(char[] source, int start, int limit, int offset16)", "public static StringBuffer append(StringBuffer target, int char32)", "public static StringBuffer appendCodePoint(StringBuffer target, int cp)", "public static int append(char[] target, int limit, int char32)", "public static int countCodePoint(String source)", "public static int countCodePoint(StringBuffer source)", "public static int countCodePoint(char[] source, int start, int limit)", "public static void setCharAt(StringBuffer target, int offset16, int char32)", "public static int setCharAt(char[] target, int limit, int offset16, int char32)", "public static int moveCodePointOffset(String source, int offset16, int shift32)", "public static int moveCodePointOffset(StringBuffer source, int offset16, int shift32)", "public static int moveCodePointOffset(char[] source, int start, int limit, int offset16, int shift32)", "public static StringBuffer insert(StringBuffer target, int offset16, int char32)", "public static int insert(char[] target, int limit, int offset16, int char32)", "public static StringBuffer delete(StringBuffer target, int offset16)", "public static int delete(char[] target, int limit, int offset16)", "public static int indexOf(String source, int char32)", "public static int indexOf(String source, String str)", "public static int indexOf(String source, int char32, int fromIndex)", "public static int indexOf(String source, String str, int fromIndex)", "public static int lastIndexOf(String source, int char32)", "public static int lastIndexOf(String source, String str)", "public static int lastIndexOf(String source, int char32, int fromIndex)", "public static int lastIndexOf(String source, String str, int fromIndex)", "public static String replace(String source, int oldChar32, int newChar32)", "public static String replace(String source, String oldStr, String newStr)", "public static StringBuffer reverse(StringBuffer source)", "public static boolean hasMoreCodePointsThan(String source, int number)", "public static boolean hasMoreCodePointsThan(char[] source, int start, int limit, int number)", "public static boolean hasMoreCodePointsThan(StringBuffer source, int number)", "public static String newString(int[] codePoints, int offset, int count)", "public static int getSingleCodePoint(CharSequence s)", "public static int compareCodePoint(int codePoint, CharSequence s)", "private static String toString(int ch)" ],
  "variableNames" : [ "SINGLE_CHAR_BOUNDARY", "LEAD_SURROGATE_BOUNDARY", "TRAIL_SURROGATE_BOUNDARY", "CODEPOINT_MIN_VALUE", "CODEPOINT_MAX_VALUE", "SUPPLEMENTARY_MIN_VALUE", "LEAD_SURROGATE_MIN_VALUE", "TRAIL_SURROGATE_MIN_VALUE", "LEAD_SURROGATE_MAX_VALUE", "TRAIL_SURROGATE_MAX_VALUE", "SURROGATE_MIN_VALUE", "SURROGATE_MAX_VALUE", "LEAD_SURROGATE_BITMASK", "TRAIL_SURROGATE_BITMASK", "SURROGATE_BITMASK", "LEAD_SURROGATE_BITS", "TRAIL_SURROGATE_BITS", "SURROGATE_BITS", "LEAD_SURROGATE_SHIFT_", "TRAIL_SURROGATE_MASK_", "LEAD_SURROGATE_OFFSET_" ]
}