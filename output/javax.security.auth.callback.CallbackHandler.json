{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/javax/security/auth/callback/CallbackHandler.java",
  "packageName" : "javax.security.auth.callback",
  "className" : "CallbackHandler",
  "comment" : "\n * <p> An application implements a {@code CallbackHandler} and passes\n * it to underlying security services so that they may interact with\n * the application to retrieve specific authentication data,\n * such as usernames and passwords, or to display certain information,\n * such as error and warning messages.\n *\n * <p> CallbackHandlers are implemented in an application-dependent fashion.\n * For example, implementations for an application with a graphical user\n * interface (GUI) may pop up windows to prompt for requested information\n * or to display error messages.  An implementation may also choose to obtain\n * requested information from an alternate source without asking the end user.\n *\n * <p> Underlying security services make requests for different types\n * of information by passing individual Callbacks to the\n * {@code CallbackHandler}.  The {@code CallbackHandler}\n * implementation decides how to retrieve and display information\n * depending on the Callbacks passed to it.  For example,\n * if the underlying service needs a username and password to\n * authenticate a user, it uses a {@code NameCallback} and\n * {@code PasswordCallback}.  The {@code CallbackHandler}\n * can then choose to prompt for a username and password serially,\n * or to prompt for both in a single window.\n *\n * <p> A default {@code CallbackHandler} class implementation\n * may be specified by setting the value of the\n * {@code auth.login.defaultCallbackHandler} security property.\n *\n * <p> If the security property is set to the fully qualified name of a\n * {@code CallbackHandler} implementation class,\n * then a {@code LoginContext} will load the specified\n * {@code CallbackHandler} and pass it to the underlying LoginModules.\n * The {@code LoginContext} only loads the default handler\n * if it was not provided one.\n *\n * <p> All default handler implementations must provide a public\n * zero-argument constructor.\n *\n * @see java.security.Security security properties\n ",
  "links" : [ ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " void handle(Callback[] callbacks) throws java.io.IOException, UnsupportedCallbackException",
    "returnType" : "void",
    "comment" : "\n     * <p> Retrieve or display the information requested in the\n     * provided Callbacks.\n     *\n     * <p> The {@code handle} method implementation checks the\n     * instance(s) of the {@code Callback} object(s) passed in\n     * to retrieve or display the requested information.\n     * The following example is provided to help demonstrate what an\n     * {@code handle} method implementation might look like.\n     * This example code is for guidance only.  Many details,\n     * including proper error handling, are left out for simplicity.\n     *\n     * <pre>{@code\n     * public void handle(Callback[] callbacks)\n     * throws IOException, UnsupportedCallbackException {\n     *\n     *   for (int i = 0; i < callbacks.length; i++) {\n     *      if (callbacks[i] instanceof TextOutputCallback) {\n     *\n     *          // display the message according to the specified type\n     *          TextOutputCallback toc = (TextOutputCallback)callbacks[i];\n     *          switch (toc.getMessageType()) {\n     *          case TextOutputCallback.INFORMATION:\n     *              System.out.println(toc.getMessage());\n     *              break;\n     *          case TextOutputCallback.ERROR:\n     *              System.out.println(\"ERROR: \" + toc.getMessage());\n     *              break;\n     *          case TextOutputCallback.WARNING:\n     *              System.out.println(\"WARNING: \" + toc.getMessage());\n     *              break;\n     *          default:\n     *              throw new IOException(\"Unsupported message type: \" +\n     *                                  toc.getMessageType());\n     *          }\n     *\n     *      } else if (callbacks[i] instanceof NameCallback) {\n     *\n     *          // prompt the user for a username\n     *          NameCallback nc = (NameCallback)callbacks[i];\n     *\n     *          // ignore the provided defaultName\n     *          System.err.print(nc.getPrompt());\n     *          System.err.flush();\n     *          nc.setName((new BufferedReader\n     *                  (new InputStreamReader(System.in))).readLine());\n     *\n     *      } else if (callbacks[i] instanceof PasswordCallback) {\n     *\n     *          // prompt the user for sensitive information\n     *          PasswordCallback pc = (PasswordCallback)callbacks[i];\n     *          System.err.print(pc.getPrompt());\n     *          System.err.flush();\n     *          pc.setPassword(readPassword(System.in));\n     *\n     *      } else {\n     *          throw new UnsupportedCallbackException\n     *                  (callbacks[i], \"Unrecognized Callback\");\n     *      }\n     *   }\n     * }\n     *\n     * // Reads user password from given input stream.\n     * private char[] readPassword(InputStream in) throws IOException {\n     *    // insert code to read a user password from the input stream\n     * }\n     * }</pre>\n     *\n     * @param callbacks an array of {@code Callback} objects provided\n     *          by an underlying security service which contains\n     *          the information requested to be retrieved or displayed.\n     *\n     * @exception java.io.IOException if an input or output error occurs. <p>\n     *\n     * @exception UnsupportedCallbackException if the implementation of this\n     *          method does not support one or more of the Callbacks\n     *          specified in the {@code callbacks} parameter.\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ " void handle(Callback[] callbacks) throws java.io.IOException, UnsupportedCallbackException" ],
  "variableNames" : [ ]
}