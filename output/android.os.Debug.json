{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/os/Debug.java",
  "packageName" : "android.os",
  "className" : "Debug",
  "comment" : "\n * Provides various debugging methods for Android applications, including\n * tracing and allocation counts.\n * <p><strong>Logging Trace Files</strong></p>\n * <p>Debug can create log files that give details about an application, such as\n * a call stack and start/stop times for any running methods. See <a\n * href=\"{@docRoot}studio/profile/traceview.html\">Inspect Trace Logs with\n * Traceview</a> for information about reading trace files. To start logging\n * trace files, call one of the startMethodTracing() methods. To stop tracing,\n * call {@link #stopMethodTracing()}.\n ",
  "links" : [ "#stopMethodTracing()" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TRACE_COUNT_ALLOCS",
    "type" : "int",
    "comment" : " This must match VMDebug.TRACE_COUNT_ALLOCS.",
    "links" : [ ]
  }, {
    "name" : "SHOW_FULL_DETAIL",
    "type" : "int",
    "comment" : "\n     * Flags for printLoadedClasses().  Default behavior is to only show\n     * the class name.\n     ",
    "links" : [ ]
  }, {
    "name" : "SHOW_CLASSLOADER",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SHOW_INITIALIZED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWaiting",
    "type" : "boolean",
    "comment" : " set/cleared by waitForDebugger()",
    "links" : [ ]
  }, {
    "name" : "MIN_DEBUGGER_IDLE",
    "type" : "int",
    "comment" : " msec",
    "links" : [ ]
  }, {
    "name" : "SPIN_DELAY",
    "type" : "int",
    "comment" : " msec",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_TRACE_BODY",
    "type" : "String",
    "comment" : "\n     * Default trace file path and file\n     ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_TRACE_EXTENSION",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "FRAMEWORK_FEATURES",
    "type" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SYSFS_QEMU_TRACE_STATE",
    "type" : "String",
    "comment" : "\n     * This is the pathname to the sysfs file that enables and disables\n     * tracing on the qemu emulator.\n     ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_TOTAL",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_FREE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_BUFFERS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_CACHED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_SHMEM",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_SLAB",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_SLAB_RECLAIMABLE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_SLAB_UNRECLAIMABLE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_SWAP_TOTAL",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_SWAP_FREE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_ZRAM_TOTAL",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_MAPPED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_VM_ALLOC_USED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_PAGE_TABLES",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_KERNEL_STACK",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_KRECLAIMABLE",
    "type" : "int",
    "comment" : "\n     * Note: MEMINFO_KRECLAIMABLE includes MEMINFO_SLAB_RECLAIMABLE (see KReclaimable field\n     * description in kernel documentation).\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_ACTIVE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_INACTIVE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_UNEVICTABLE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_AVAILABLE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_ACTIVE_ANON",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_INACTIVE_ANON",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_ACTIVE_FILE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_INACTIVE_FILE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_CMA_TOTAL",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_CMA_FREE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MEMINFO_COUNT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "debugProperties",
    "type" : "TypedProperties",
    "comment" : "\n     * A Map of typed debug properties.\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static void suspendAllAndSendVmStart()",
    "returnType" : "void",
    "comment" : "\n     * Wait until a debugger attaches. As soon as a debugger attaches,\n     * suspend all Java threads and send VM_START (a.k.a VM_INIT)\n     * packet.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void waitForDebugger()",
    "returnType" : "void",
    "comment" : "\n     * Wait until a debugger attaches.  As soon as the debugger attaches,\n     * this returns, so you will need to place a breakpoint after the\n     * waitForDebugger() call if you want to start tracing immediately.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean waitingForDebugger()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns \"true\" if one or more threads is waiting for a debugger\n     * to attach.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isDebuggerConnected()",
    "returnType" : "boolean",
    "comment" : "\n     * Determine if a debugger is currently attached.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String[] getVmFeatureList()",
    "returnType" : "String[]",
    "comment" : "\n     * Returns an array of strings that identify VM features.  This is\n     * used by DDMS to determine what sorts of operations the VM can\n     * perform.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String[] getFeatureList()",
    "returnType" : "String[]",
    "comment" : "\n     * Returns an array of strings that identify Framework features. This is\n     * used by DDMS to determine what sorts of operations the Framework can\n     * perform.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void changeDebugPort(int port)",
    "returnType" : "void",
    "comment" : "\n     * Change the JDWP port.\n     *\n     * @deprecated no longer needed or useful\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void startNativeTracing()",
    "returnType" : "void",
    "comment" : "\n     * Enable qemu tracing. For this to work requires running everything inside\n     * the qemu emulator; otherwise, this method will have no effect. The trace\n     * file is specified on the command line when the emulator is started. For\n     * example, the following command line <br />\n     * <code>emulator -trace foo</code><br />\n     * will start running the emulator and create a trace file named \"foo\". This\n     * method simply enables writing the trace records to the trace file.\n     *\n     * <p>\n     * The main differences between this and {@link #startMethodTracing()} are\n     * that tracing in the qemu emulator traces every cpu instruction of every\n     * process, including kernel code, so we have more complete information,\n     * including all context switches. We can also get more detailed information\n     * such as cache misses. The sequence of calls is determined by\n     * post-processing the instruction trace. The qemu tracing is also done\n     * without modifying the application or perturbing the timing of calls\n     * because no instrumentation is added to the application being traced.\n     * </p>\n     *\n     * <p>\n     * One limitation of using this method compared to using\n     * {@link #startMethodTracing()} on the real device is that the emulator\n     * does not model all of the real hardware effects such as memory and\n     * bus contention.  The emulator also has a simple cache model and cannot\n     * capture all the complexities of a real cache.\n     * </p>\n     ",
    "links" : [ "#startMethodTracing()" ]
  }, {
    "name" : "public static void stopNativeTracing()",
    "returnType" : "void",
    "comment" : "\n     * Stop qemu tracing.  See {@link #startNativeTracing()} to start tracing.\n     *\n     * <p>Tracing can be started and stopped as many times as desired.  When\n     * the qemu emulator itself is stopped then the buffered trace records\n     * are flushed and written to the trace file.  In fact, it is not necessary\n     * to call this method at all; simply killing qemu is sufficient.  But\n     * starting and stopping a trace is useful for examining a specific\n     * region of code.</p>\n     ",
    "links" : [ "#startNativeTracing()" ]
  }, {
    "name" : "public static void enableEmulatorTraceOutput()",
    "returnType" : "void",
    "comment" : "\n     * Enable \"emulator traces\", in which information about the current\n     * method is made available to the \"emulator -trace\" feature.  There\n     * is no corresponding \"disable\" call -- this is intended for use by\n     * the framework when tracing should be turned on and left that way, so\n     * that traces captured with F9/F10 will include the necessary data.\n     *\n     * This puts the VM into \"profile\" mode, which has performance\n     * consequences.\n     *\n     * To temporarily enable tracing, use {@link #startNativeTracing()}.\n     *\n     * @deprecated Please use other tracing method in this class.\n     ",
    "links" : [ "#startNativeTracing()" ]
  }, {
    "name" : "public static void startMethodTracing()",
    "returnType" : "void",
    "comment" : "\n     * Start method tracing with default log name and buffer size.\n     * <p>\n     * By default, the trace file is called \"dmtrace.trace\" and it's placed\n     * under your package-specific directory on primary shared/external storage,\n     * as returned by {@link Context#getExternalFilesDir(String)}.\n     * <p>\n     * See <a href=\"{@docRoot}studio/profile/traceview.html\">Inspect Trace Logs\n     * with Traceview</a> for information about reading trace files.\n     * <p class=\"note\">\n     * When method tracing is enabled, the VM will run more slowly than usual,\n     * so the timings from the trace files should only be considered in relative\n     * terms (e.g. was run #1 faster than run #2). The times for native methods\n     * will not change, so don't try to use this to compare the performance of\n     * interpreted and native implementations of the same method. As an\n     * alternative, consider using sampling-based method tracing via\n     * {@link #startMethodTracingSampling(String, int, int)} or \"native\" tracing\n     * in the emulator via {@link #startNativeTracing()}.\n     * </p>\n     ",
    "links" : [ "#startMethodTracingSampling(String", "#startNativeTracing()", "android.content.Context#getExternalFilesDir(String)" ]
  }, {
    "name" : "public static void startMethodTracing(String tracePath)",
    "returnType" : "void",
    "comment" : "\n     * Start method tracing, specifying the trace log file path.\n     * <p>\n     * When a relative file path is given, the trace file will be placed under\n     * your package-specific directory on primary shared/external storage, as\n     * returned by {@link Context#getExternalFilesDir(String)}.\n     * <p>\n     * See <a href=\"{@docRoot}studio/profile/traceview.html\">Inspect Trace Logs\n     * with Traceview</a> for information about reading trace files.\n     * <p class=\"note\">\n     * When method tracing is enabled, the VM will run more slowly than usual,\n     * so the timings from the trace files should only be considered in relative\n     * terms (e.g. was run #1 faster than run #2). The times for native methods\n     * will not change, so don't try to use this to compare the performance of\n     * interpreted and native implementations of the same method. As an\n     * alternative, consider using sampling-based method tracing via\n     * {@link #startMethodTracingSampling(String, int, int)} or \"native\" tracing\n     * in the emulator via {@link #startNativeTracing()}.\n     * </p>\n     *\n     * @param tracePath Path to the trace log file to create. If {@code null},\n     *            this will default to \"dmtrace.trace\". If the file already\n     *            exists, it will be truncated. If the path given does not end\n     *            in \".trace\", it will be appended for you.\n     ",
    "links" : [ "#startMethodTracingSampling(String", "#startNativeTracing()", "android.content.Context#getExternalFilesDir(String)" ]
  }, {
    "name" : "public static void startMethodTracing(String tracePath, int bufferSize)",
    "returnType" : "void",
    "comment" : "\n     * Start method tracing, specifying the trace log file name and the buffer\n     * size.\n     * <p>\n     * When a relative file path is given, the trace file will be placed under\n     * your package-specific directory on primary shared/external storage, as\n     * returned by {@link Context#getExternalFilesDir(String)}.\n     * <p>\n     * See <a href=\"{@docRoot}studio/profile/traceview.html\">Inspect Trace Logs\n     * with Traceview</a> for information about reading trace files.\n     * <p class=\"note\">\n     * When method tracing is enabled, the VM will run more slowly than usual,\n     * so the timings from the trace files should only be considered in relative\n     * terms (e.g. was run #1 faster than run #2). The times for native methods\n     * will not change, so don't try to use this to compare the performance of\n     * interpreted and native implementations of the same method. As an\n     * alternative, consider using sampling-based method tracing via\n     * {@link #startMethodTracingSampling(String, int, int)} or \"native\" tracing\n     * in the emulator via {@link #startNativeTracing()}.\n     * </p>\n     *\n     * @param tracePath Path to the trace log file to create. If {@code null},\n     *            this will default to \"dmtrace.trace\". If the file already\n     *            exists, it will be truncated. If the path given does not end\n     *            in \".trace\", it will be appended for you.\n     * @param bufferSize The maximum amount of trace data we gather. If not\n     *            given, it defaults to 8MB.\n     ",
    "links" : [ "#startMethodTracingSampling(String", "#startNativeTracing()", "android.content.Context#getExternalFilesDir(String)" ]
  }, {
    "name" : "public static void startMethodTracing(String tracePath, int bufferSize, int flags)",
    "returnType" : "void",
    "comment" : "\n     * Start method tracing, specifying the trace log file name, the buffer\n     * size, and flags.\n     * <p>\n     * When a relative file path is given, the trace file will be placed under\n     * your package-specific directory on primary shared/external storage, as\n     * returned by {@link Context#getExternalFilesDir(String)}.\n     * <p>\n     * See <a href=\"{@docRoot}studio/profile/traceview.html\">Inspect Trace Logs\n     * with Traceview</a> for information about reading trace files.\n     * <p class=\"note\">\n     * When method tracing is enabled, the VM will run more slowly than usual,\n     * so the timings from the trace files should only be considered in relative\n     * terms (e.g. was run #1 faster than run #2). The times for native methods\n     * will not change, so don't try to use this to compare the performance of\n     * interpreted and native implementations of the same method. As an\n     * alternative, consider using sampling-based method tracing via\n     * {@link #startMethodTracingSampling(String, int, int)} or \"native\" tracing\n     * in the emulator via {@link #startNativeTracing()}.\n     * </p>\n     *\n     * @param tracePath Path to the trace log file to create. If {@code null},\n     *            this will default to \"dmtrace.trace\". If the file already\n     *            exists, it will be truncated. If the path given does not end\n     *            in \".trace\", it will be appended for you.\n     * @param bufferSize The maximum amount of trace data we gather. If not\n     *            given, it defaults to 8MB.\n     * @param flags Flags to control method tracing. The only one that is\n     *            currently defined is {@link #TRACE_COUNT_ALLOCS}.\n     ",
    "links" : [ "#startMethodTracingSampling(String", "#TRACE_COUNT_ALLOCS", "#startNativeTracing()", "android.content.Context#getExternalFilesDir(String)" ]
  }, {
    "name" : "public static void startMethodTracingSampling(String tracePath, int bufferSize, int intervalUs)",
    "returnType" : "void",
    "comment" : "\n     * Start sampling-based method tracing, specifying the trace log file name,\n     * the buffer size, and the sampling interval.\n     * <p>\n     * When a relative file path is given, the trace file will be placed under\n     * your package-specific directory on primary shared/external storage, as\n     * returned by {@link Context#getExternalFilesDir(String)}.\n     * <p>\n     * See <a href=\"{@docRoot}studio/profile/traceview.html\">Inspect Trace Logs\n     * with Traceview</a> for information about reading trace files.\n     *\n     * @param tracePath Path to the trace log file to create. If {@code null},\n     *            this will default to \"dmtrace.trace\". If the file already\n     *            exists, it will be truncated. If the path given does not end\n     *            in \".trace\", it will be appended for you.\n     * @param bufferSize The maximum amount of trace data we gather. If not\n     *            given, it defaults to 8MB.\n     * @param intervalUs The amount of time between each sample in microseconds.\n     ",
    "links" : [ "android.content.Context#getExternalFilesDir(String)" ]
  }, {
    "name" : "private static String fixTracePath(String tracePath)",
    "returnType" : "String",
    "comment" : "\n     * Formats name of trace log file for method tracing.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void startMethodTracing(String traceName, FileDescriptor fd, int bufferSize, int flags, boolean streamOutput)",
    "returnType" : "void",
    "comment" : "\n     * Like startMethodTracing(String, int, int), but taking an already-opened\n     * FileDescriptor in which the trace is written.  The file name is also\n     * supplied simply for logging.  Makes a dup of the file descriptor.\n     *\n     * Not exposed in the SDK unless we are really comfortable with supporting\n     * this and find it would be useful.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void startMethodTracingDdms(int bufferSize, int flags, boolean samplingEnabled, int intervalUs)",
    "returnType" : "void",
    "comment" : "\n     * Starts method tracing without a backing file.  When stopMethodTracing\n     * is called, the result is sent directly to DDMS.  (If DDMS is not\n     * attached when tracing ends, the profiling data will be discarded.)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getMethodTracingMode()",
    "returnType" : "int",
    "comment" : "\n     * Determine whether method tracing is currently active and what type is\n     * active.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void stopMethodTracing()",
    "returnType" : "void",
    "comment" : "\n     * Stop method tracing.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static long threadCpuTimeNanos()",
    "returnType" : "long",
    "comment" : "\n     * Get an indication of thread CPU usage.  The value returned\n     * indicates the amount of time that the current thread has spent\n     * executing code or waiting for certain types of I/O.\n     *\n     * The time is expressed in nanoseconds, and is only meaningful\n     * when compared to the result from an earlier call.  Note that\n     * nanosecond resolution does not imply nanosecond accuracy.\n     *\n     * On system which don't support this operation, the call returns -1.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void startAllocCounting()",
    "returnType" : "void",
    "comment" : "\n     * Start counting the number and aggregate size of memory allocations.\n     *\n     * <p>The {@link #startAllocCounting() start} method resets the counts and enables counting.\n     * The {@link #stopAllocCounting() stop} method disables the counting so that the analysis\n     * code doesn't cause additional allocations.  The various <code>get</code> methods return\n     * the specified value. And the various <code>reset</code> methods reset the specified\n     * count.</p>\n     *\n     * <p>Counts are kept for the system as a whole (global) and for each thread.\n     * The per-thread counts for threads other than the current thread\n     * are not cleared by the \"reset\" or \"start\" calls.</p>\n     *\n     * @deprecated Accurate counting is a burden on the runtime and may be removed.\n     ",
    "links" : [ "#startAllocCounting()", "#stopAllocCounting()" ]
  }, {
    "name" : "public static void stopAllocCounting()",
    "returnType" : "void",
    "comment" : "\n     * Stop counting the number and aggregate size of memory allocations.\n     *\n     * @deprecated Accurate counting is a burden on the runtime and may be removed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getGlobalAllocCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the global count of objects allocated by the runtime between a\n     * {@link #startAllocCounting() start} and {@link #stopAllocCounting() stop}.\n     *\n     * @deprecated Accurate counting is a burden on the runtime and may be removed.\n     ",
    "links" : [ "#startAllocCounting()", "#stopAllocCounting()" ]
  }, {
    "name" : "public static void resetGlobalAllocCount()",
    "returnType" : "void",
    "comment" : "\n     * Clears the global count of objects allocated.\n     * @see #getGlobalAllocCount()\n     *\n     * @deprecated Accurate counting is a burden on the runtime and may be removed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getGlobalAllocSize()",
    "returnType" : "int",
    "comment" : "\n     * Returns the global size, in bytes, of objects allocated by the runtime between a\n     * {@link #startAllocCounting() start} and {@link #stopAllocCounting() stop}.\n     *\n     * @deprecated Accurate counting is a burden on the runtime and may be removed.\n     ",
    "links" : [ "#startAllocCounting()", "#stopAllocCounting()" ]
  }, {
    "name" : "public static void resetGlobalAllocSize()",
    "returnType" : "void",
    "comment" : "\n     * Clears the global size of objects allocated.\n     * @see #getGlobalAllocSize()\n     *\n     * @deprecated Accurate counting is a burden on the runtime and may be removed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getGlobalFreedCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the global count of objects freed by the runtime between a\n     * {@link #startAllocCounting() start} and {@link #stopAllocCounting() stop}.\n     *\n     * @deprecated Accurate counting is a burden on the runtime and may be removed.\n     ",
    "links" : [ "#startAllocCounting()", "#stopAllocCounting()" ]
  }, {
    "name" : "public static void resetGlobalFreedCount()",
    "returnType" : "void",
    "comment" : "\n     * Clears the global count of objects freed.\n     * @see #getGlobalFreedCount()\n     *\n     * @deprecated Accurate counting is a burden on the runtime and may be removed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getGlobalFreedSize()",
    "returnType" : "int",
    "comment" : "\n     * Returns the global size, in bytes, of objects freed by the runtime between a\n     * {@link #startAllocCounting() start} and {@link #stopAllocCounting() stop}.\n     *\n     * @deprecated Accurate counting is a burden on the runtime and may be removed.\n     ",
    "links" : [ "#startAllocCounting()", "#stopAllocCounting()" ]
  }, {
    "name" : "public static void resetGlobalFreedSize()",
    "returnType" : "void",
    "comment" : "\n     * Clears the global size of objects freed.\n     * @see #getGlobalFreedSize()\n     *\n     * @deprecated Accurate counting is a burden on the runtime and may be removed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getGlobalGcInvocationCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of non-concurrent GC invocations between a\n     * {@link #startAllocCounting() start} and {@link #stopAllocCounting() stop}.\n     *\n     * @deprecated Accurate counting is a burden on the runtime and may be removed.\n     ",
    "links" : [ "#startAllocCounting()", "#stopAllocCounting()" ]
  }, {
    "name" : "public static void resetGlobalGcInvocationCount()",
    "returnType" : "void",
    "comment" : "\n     * Clears the count of non-concurrent GC invocations.\n     * @see #getGlobalGcInvocationCount()\n     *\n     * @deprecated Accurate counting is a burden on the runtime and may be removed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getGlobalClassInitCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of classes successfully initialized (ie those that executed without\n     * throwing an exception) between a {@link #startAllocCounting() start} and\n     * {@link #stopAllocCounting() stop}.\n     *\n     * @deprecated Accurate counting is a burden on the runtime and may be removed.\n     ",
    "links" : [ "#startAllocCounting()", "#stopAllocCounting()" ]
  }, {
    "name" : "public static void resetGlobalClassInitCount()",
    "returnType" : "void",
    "comment" : "\n     * Clears the count of classes initialized.\n     * @see #getGlobalClassInitCount()\n     *\n     * @deprecated Accurate counting is a burden on the runtime and may be removed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getGlobalClassInitTime()",
    "returnType" : "int",
    "comment" : "\n     * Returns the time spent successfully initializing classes between a\n     * {@link #startAllocCounting() start} and {@link #stopAllocCounting() stop}.\n     *\n     * @deprecated Accurate counting is a burden on the runtime and may be removed.\n     ",
    "links" : [ "#startAllocCounting()", "#stopAllocCounting()" ]
  }, {
    "name" : "public static void resetGlobalClassInitTime()",
    "returnType" : "void",
    "comment" : "\n     * Clears the count of time spent initializing classes.\n     * @see #getGlobalClassInitTime()\n     *\n     * @deprecated Accurate counting is a burden on the runtime and may be removed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getGlobalExternalAllocCount()",
    "returnType" : "int",
    "comment" : "\n     * This method exists for compatibility and always returns 0.\n     * @deprecated This method is now obsolete.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void resetGlobalExternalAllocSize()",
    "returnType" : "void",
    "comment" : "\n     * This method exists for compatibility and has no effect.\n     * @deprecated This method is now obsolete.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void resetGlobalExternalAllocCount()",
    "returnType" : "void",
    "comment" : "\n     * This method exists for compatibility and has no effect.\n     * @deprecated This method is now obsolete.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getGlobalExternalAllocSize()",
    "returnType" : "int",
    "comment" : "\n     * This method exists for compatibility and always returns 0.\n     * @deprecated This method is now obsolete.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getGlobalExternalFreedCount()",
    "returnType" : "int",
    "comment" : "\n     * This method exists for compatibility and always returns 0.\n     * @deprecated This method is now obsolete.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void resetGlobalExternalFreedCount()",
    "returnType" : "void",
    "comment" : "\n     * This method exists for compatibility and has no effect.\n     * @deprecated This method is now obsolete.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getGlobalExternalFreedSize()",
    "returnType" : "int",
    "comment" : "\n     * This method exists for compatibility and has no effect.\n     * @deprecated This method is now obsolete.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void resetGlobalExternalFreedSize()",
    "returnType" : "void",
    "comment" : "\n     * This method exists for compatibility and has no effect.\n     * @deprecated This method is now obsolete.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getThreadAllocCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the thread-local count of objects allocated by the runtime between a\n     * {@link #startAllocCounting() start} and {@link #stopAllocCounting() stop}.\n     *\n     * @deprecated Accurate counting is a burden on the runtime and may be removed.\n     ",
    "links" : [ "#startAllocCounting()", "#stopAllocCounting()" ]
  }, {
    "name" : "public static void resetThreadAllocCount()",
    "returnType" : "void",
    "comment" : "\n     * Clears the thread-local count of objects allocated.\n     * @see #getThreadAllocCount()\n     *\n     * @deprecated Accurate counting is a burden on the runtime and may be removed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getThreadAllocSize()",
    "returnType" : "int",
    "comment" : "\n     * Returns the thread-local size of objects allocated by the runtime between a\n     * {@link #startAllocCounting() start} and {@link #stopAllocCounting() stop}.\n     * @return The allocated size in bytes.\n     *\n     * @deprecated Accurate counting is a burden on the runtime and may be removed.\n     ",
    "links" : [ "#startAllocCounting()", "#stopAllocCounting()" ]
  }, {
    "name" : "public static void resetThreadAllocSize()",
    "returnType" : "void",
    "comment" : "\n     * Clears the thread-local count of objects allocated.\n     * @see #getThreadAllocSize()\n     *\n     * @deprecated Accurate counting is a burden on the runtime and may be removed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getThreadExternalAllocCount()",
    "returnType" : "int",
    "comment" : "\n     * This method exists for compatibility and has no effect.\n     * @deprecated This method is now obsolete.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void resetThreadExternalAllocCount()",
    "returnType" : "void",
    "comment" : "\n     * This method exists for compatibility and has no effect.\n     * @deprecated This method is now obsolete.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getThreadExternalAllocSize()",
    "returnType" : "int",
    "comment" : "\n     * This method exists for compatibility and has no effect.\n     * @deprecated This method is now obsolete.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void resetThreadExternalAllocSize()",
    "returnType" : "void",
    "comment" : "\n     * This method exists for compatibility and has no effect.\n     * @deprecated This method is now obsolete.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getThreadGcInvocationCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of thread-local non-concurrent GC invocations between a\n     * {@link #startAllocCounting() start} and {@link #stopAllocCounting() stop}.\n     *\n     * @deprecated Accurate counting is a burden on the runtime and may be removed.\n     ",
    "links" : [ "#startAllocCounting()", "#stopAllocCounting()" ]
  }, {
    "name" : "public static void resetThreadGcInvocationCount()",
    "returnType" : "void",
    "comment" : "\n     * Clears the thread-local count of non-concurrent GC invocations.\n     * @see #getThreadGcInvocationCount()\n     *\n     * @deprecated Accurate counting is a burden on the runtime and may be removed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void resetAllCounts()",
    "returnType" : "void",
    "comment" : "\n     * Clears all the global and thread-local memory allocation counters.\n     * @see #startAllocCounting()\n     *\n     * @deprecated Accurate counting is a burden on the runtime and may be removed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getRuntimeStat(String statName)",
    "returnType" : "String",
    "comment" : "\n     * Returns the value of a particular runtime statistic or {@code null} if no\n     * such runtime statistic exists.\n     *\n     * <p>The following table lists the runtime statistics that the runtime supports.\n     * All statistics are approximate. Individual allocations may not be immediately reflected\n     * in the results.\n     * Note runtime statistics may be added or removed in a future API level.</p>\n     *\n     * <table>\n     *     <thead>\n     *         <tr>\n     *             <th>Runtime statistic name</th>\n     *             <th>Meaning</th>\n     *             <th>Example</th>\n     *             <th>Supported (API Levels)</th>\n     *         </tr>\n     *     </thead>\n     *     <tbody>\n     *         <tr>\n     *             <td>art.gc.gc-count</td>\n     *             <td>The number of garbage collection runs.</td>\n     *             <td>{@code 164}</td>\n     *             <td>23</td>\n     *         </tr>\n     *         <tr>\n     *             <td>art.gc.gc-time</td>\n     *             <td>The total duration of garbage collection runs in ms.</td>\n     *             <td>{@code 62364}</td>\n     *             <td>23</td>\n     *         </tr>\n     *         <tr>\n     *             <td>art.gc.bytes-allocated</td>\n     *             <td>The total number of bytes that the application allocated.</td>\n     *             <td>{@code 1463948408}</td>\n     *             <td>23</td>\n     *         </tr>\n     *         <tr>\n     *             <td>art.gc.bytes-freed</td>\n     *             <td>The total number of bytes that garbage collection reclaimed.</td>\n     *             <td>{@code 1313493084}</td>\n     *             <td>23</td>\n     *         </tr>\n     *         <tr>\n     *             <td>art.gc.blocking-gc-count</td>\n     *             <td>The number of blocking garbage collection runs.</td>\n     *             <td>{@code 2}</td>\n     *             <td>23</td>\n     *         </tr>\n     *         <tr>\n     *             <td>art.gc.blocking-gc-time</td>\n     *             <td>The total duration of blocking garbage collection runs in ms.</td>\n     *             <td>{@code 804}</td>\n     *             <td>23</td>\n     *         </tr>\n     *         <tr>\n     *             <td>art.gc.gc-count-rate-histogram</td>\n     *             <td>Every 10 seconds, the gc-count-rate is computed as the number of garbage\n     *                 collection runs that have occurred over the last 10\n     *                 seconds. art.gc.gc-count-rate-histogram is a histogram of the gc-count-rate\n     *                 samples taken since the process began. The histogram can be used to identify\n     *                 instances of high rates of garbage collection runs. For example, a histogram\n     *                 of \"0:34503,1:45350,2:11281,3:8088,4:43,5:8\" shows that most of the time\n     *                 there are between 0 and 2 garbage collection runs every 10 seconds, but there\n     *                 were 8 distinct 10-second intervals in which 5 garbage collection runs\n     *                 occurred.</td>\n     *             <td>{@code 0:34503,1:45350,2:11281,3:8088,4:43,5:8}</td>\n     *             <td>23</td>\n     *         </tr>\n     *         <tr>\n     *             <td>art.gc.blocking-gc-count-rate-histogram</td>\n     *             <td>Every 10 seconds, the blocking-gc-count-rate is computed as the number of\n     *                 blocking garbage collection runs that have occurred over the last 10\n     *                 seconds. art.gc.blocking-gc-count-rate-histogram is a histogram of the\n     *                 blocking-gc-count-rate samples taken since the process began. The histogram\n     *                 can be used to identify instances of high rates of blocking garbage\n     *                 collection runs. For example, a histogram of \"0:99269,1:1,2:1\" shows that\n     *                 most of the time there are zero blocking garbage collection runs every 10\n     *                 seconds, but there was one 10-second interval in which one blocking garbage\n     *                 collection run occurred, and there was one interval in which two blocking\n     *                 garbage collection runs occurred.</td>\n     *             <td>{@code 0:99269,1:1,2:1}</td>\n     *             <td>23</td>\n     *         </tr>\n     *     </tbody>\n     * </table>\n     *\n     * @param statName\n     *            the name of the runtime statistic to look up.\n     * @return the value of the specified runtime statistic or {@code null} if the\n     *         runtime statistic doesn't exist.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Map<String, String> getRuntimeStats()",
    "returnType" : "Map<String, String>",
    "comment" : "\n     * Returns a map of the names/values of the runtime statistics\n     * that {@link #getRuntimeStat(String)} supports.\n     *\n     * @return a map of the names/values of the supported runtime statistics.\n     ",
    "links" : [ "#getRuntimeStat(String)" ]
  }, {
    "name" : "public static native long getNativeHeapSize()",
    "returnType" : "long",
    "comment" : "\n     * Returns the size of the native heap.\n     * @return The size of the native heap in bytes.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native long getNativeHeapAllocatedSize()",
    "returnType" : "long",
    "comment" : "\n     * Returns the amount of allocated memory in the native heap.\n     * @return The allocated size in bytes.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native long getNativeHeapFreeSize()",
    "returnType" : "long",
    "comment" : "\n     * Returns the amount of free memory in the native heap.\n     * @return The freed size in bytes.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native void getMemoryInfo(MemoryInfo memoryInfo)",
    "returnType" : "void",
    "comment" : "\n     * Retrieves information about this processes memory usages. This information is broken down by\n     * how much is in use by dalvik, the native heap, and everything else.\n     *\n     * <p><b>Note:</b> this method directly retrieves memory information for the given process\n     * from low-level data available to it.  It may not be able to retrieve information about\n     * some protected allocations, such as graphics.  If you want to be sure you can see\n     * all information about allocations by the process, use\n     * {@link android.app.ActivityManager#getProcessMemoryInfo(int[])} instead.</p>\n     ",
    "links" : [ "android.app.ActivityManager#getProcessMemoryInfo(int" ]
  }, {
    "name" : "public static native boolean getMemoryInfo(int pid, MemoryInfo memoryInfo)",
    "returnType" : "boolean",
    "comment" : "\n     * Note: currently only works when the requested pid has the same UID\n     * as the caller.\n     *\n     * @return true if the meminfo was read successfully, false if not (i.e., given pid has gone).\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native long getPss()",
    "returnType" : "long",
    "comment" : "\n     * Retrieves the PSS memory used by the process as given by the\n     * smaps.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native long getPss(int pid, long[] outUssSwapPssRss, long[] outMemtrack)",
    "returnType" : "long",
    "comment" : "\n     * Retrieves the PSS memory used by the process as given by the smaps. Optionally supply a long\n     * array of up to 3 entries to also receive (up to 3 values in order): the Uss and SwapPss and\n     * Rss (only filled in as of {@link android.os.Build.VERSION_CODES#P}) of the process, and\n     * another array to also retrieve the separate memtrack sizes (up to 4 values in order): the\n     * total memtrack reported size, memtrack graphics, memtrack gl and memtrack other.\n     *\n     * @return The PSS memory usage, or 0 if failed to retrieve (i.e., given pid has gone).\n     * @hide\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#P" ]
  }, {
    "name" : "public static native long getRss()",
    "returnType" : "long",
    "comment" : "\n     * Retrieves the RSS memory used by the process as given by the status file.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native long getRss(int pid, long[] outMemtrack)",
    "returnType" : "long",
    "comment" : "\n     * Retrieves the RSS memory used by the process as given by the status file. Optionally supply a\n     * long array of up to 4 entries to retrieve the total memtrack reported size, memtrack\n     * graphics, memtrack gl, and memtrack other.\n     *\n     * @return The RSS memory usage, or 0 if retrieval failed (i.e. the PID is gone).\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native void getMemInfo(long[] outSizes)",
    "returnType" : "void",
    "comment" : "\n     * Retrieves /proc/meminfo.  outSizes is filled with fields\n     * as defined by MEMINFO_* offsets.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int setAllocationLimit(int limit)",
    "returnType" : "int",
    "comment" : "\n     * Establish an object allocation limit in the current thread.\n     * This feature was never enabled in release builds.  The\n     * allocation limits feature was removed in Honeycomb.  This\n     * method exists for compatibility and always returns -1 and has\n     * no effect.\n     *\n     * @deprecated This method is now obsolete.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int setGlobalAllocationLimit(int limit)",
    "returnType" : "int",
    "comment" : "\n     * Establish a global object allocation limit.  This feature was\n     * never enabled in release builds.  The allocation limits feature\n     * was removed in Honeycomb.  This method exists for compatibility\n     * and always returns -1 and has no effect.\n     *\n     * @deprecated This method is now obsolete.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void printLoadedClasses(int flags)",
    "returnType" : "void",
    "comment" : "\n     * Dump a list of all currently loaded class to the log file.\n     *\n     * @param flags See constants above.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getLoadedClassCount()",
    "returnType" : "int",
    "comment" : "\n     * Get the number of loaded classes.\n     * @return the number of loaded classes.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void dumpHprofData(String fileName) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Dump \"hprof\" data to the specified file.  This may cause a GC.\n     *\n     * @param fileName Full pathname of output file (e.g. \"/sdcard/dump.hprof\").\n     * @throws UnsupportedOperationException if the VM was built without\n     *         HPROF support.\n     * @throws IOException if an error occurs while opening or writing files.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void dumpHprofData(String fileName, FileDescriptor fd) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Like dumpHprofData(String), but takes an already-opened\n     * FileDescriptor to which the trace is written.  The file name is also\n     * supplied simply for logging.  Makes a dup of the file descriptor.\n     *\n     * Primarily for use by the \"am\" shell command.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void dumpHprofDataDdms()",
    "returnType" : "void",
    "comment" : "\n     * Collect \"hprof\" and send it to DDMS.  This may cause a GC.\n     *\n     * @throws UnsupportedOperationException if the VM was built without\n     *         HPROF support.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native void dumpNativeHeap(FileDescriptor fd)",
    "returnType" : "void",
    "comment" : "\n     * Writes native heap data to the specified file descriptor.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native void dumpNativeMallocInfo(FileDescriptor fd)",
    "returnType" : "void",
    "comment" : "\n     * Writes malloc info data to the specified file descriptor.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static long countInstancesOfClass(Class cls)",
    "returnType" : "long",
    "comment" : "\n      * Returns a count of the extant instances of a class.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native int getBinderSentTransactions()",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of sent transactions from this process.\n     * @return The number of sent transactions or -1 if it could not read t.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native int getBinderReceivedTransactions()",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of received transactions from the binder driver.\n     * @return The number of received transactions or -1 if it could not read the stats.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final native int getBinderLocalObjectCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of active local Binder objects that exist in the\n     * current process.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final native int getBinderProxyObjectCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of references to remote proxy Binder objects that\n     * exist in the current process.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final native int getBinderDeathObjectCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of death notification links to Binder objects that\n     * exist in the current process.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final void dumpReferenceTables()",
    "returnType" : "void",
    "comment" : "\n     * Dumps the contents of VM reference tables (e.g. JNI locals and\n     * globals) to the log file.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean fieldTypeMatches(Field field, Class<?> cl)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the type of the field matches the specified class.\n     * Handles the case where the class is, e.g., java.lang.Boolean, but\n     * the field is of the primitive \"boolean\" type.  Also handles all of\n     * the java.lang.Number subclasses.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void modifyFieldIfSet(final Field field, final TypedProperties properties, final String propertyName)",
    "returnType" : "void",
    "comment" : "\n     * Looks up the property that corresponds to the field, and sets the field's value\n     * if the types match.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void setFieldsOn(Class<?> cl)",
    "returnType" : "void",
    "comment" : "\n     * Equivalent to <code>setFieldsOn(cl, false)</code>.\n     *\n     * @see #setFieldsOn(Class, boolean)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void setFieldsOn(Class<?> cl, boolean partial)",
    "returnType" : "void",
    "comment" : "\n     * Reflectively sets static fields of a class based on internal debugging\n     * properties.  This method is a no-op if false is\n     * false.\n     * <p>\n     * <strong>NOTE TO APPLICATION DEVELOPERS</strong>: false will\n     * always be false in release builds.  This API is typically only useful\n     * for platform developers.\n     * </p>\n     * Class setup: define a class whose only fields are non-final, static\n     * primitive types (except for \"char\") or Strings.  In a static block\n     * after the field definitions/initializations, pass the class to\n     * this method, Debug.setFieldsOn(). Example:\n     * <pre>\n     * package com.example;\n     *\n     * import android.os.Debug;\n     *\n     * public class MyDebugVars {\n     *    public static String s = \"a string\";\n     *    public static String s2 = \"second string\";\n     *    public static String ns = null;\n     *    public static boolean b = false;\n     *    public static int i = 5;\n     *    @Debug.DebugProperty\n     *    public static float f = 0.1f;\n     *    @@Debug.DebugProperty\n     *    public static double d = 0.5d;\n     *\n     *    // This MUST appear AFTER all fields are defined and initialized!\n     *    static {\n     *        // Sets all the fields\n     *        Debug.setFieldsOn(MyDebugVars.class);\n     *\n     *        // Sets only the fields annotated with @Debug.DebugProperty\n     *        // Debug.setFieldsOn(MyDebugVars.class, true);\n     *    }\n     * }\n     * </pre>\n     * setFieldsOn() may override the value of any field in the class based\n     * on internal properties that are fixed at boot time.\n     * <p>\n     * These properties are only set during platform debugging, and are not\n     * meant to be used as a general-purpose properties store.\n     *\n     * {@hide}\n     *\n     * @param cl The class to (possibly) modify\n     * @param partial If false, sets all static fields, otherwise, only set\n     *        fields with the {@link android.os.Debug.DebugProperty}\n     *        annotation\n     * @throws IllegalArgumentException if any fields are final or non-static,\n     *         or if the type of the field does not match the type of\n     *         the internal debugging property value.\n     ",
    "links" : [ "android.os.Debug.DebugProperty" ]
  }, {
    "name" : "public static boolean dumpService(String name, FileDescriptor fd, String[] args)",
    "returnType" : "boolean",
    "comment" : "\n     * Get a debugging dump of a system service by name.\n     *\n     * <p>Most services require the caller to hold android.permission.DUMP.\n     *\n     * @param name of the service to dump\n     * @param fd to write dump output to (usually an output log file)\n     * @param args to pass to the service's dump method, may be null\n     * @return true if the service was dumped successfully, false if\n     *     the service could not be found or had an error while dumping\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native boolean dumpJavaBacktraceToFileTimeout(int pid, String file, int timeoutSecs)",
    "returnType" : "boolean",
    "comment" : "\n     * Append the Java stack traces of a given native process to a specified file.\n     *\n     * @param pid pid to dump.\n     * @param file path of file to append dump to.\n     * @param timeoutSecs time to wait in seconds, or 0 to wait forever.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native boolean dumpNativeBacktraceToFileTimeout(int pid, String file, int timeoutSecs)",
    "returnType" : "boolean",
    "comment" : "\n     * Append the native stack traces of a given process to a specified file.\n     *\n     * @param pid pid to dump.\n     * @param file path of file to append dump to.\n     * @param timeoutSecs time to wait in seconds, or 0 to wait forever.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native String getUnreachableMemory(int limit, boolean contents)",
    "returnType" : "String",
    "comment" : "\n     * Get description of unreachable native memory.\n     * @param limit the number of leaks to provide info on, 0 to only get a summary.\n     * @param contents true to include a hex dump of the contents of unreachable memory.\n     * @return the String containing a description of unreachable memory.\n     * @hide ",
    "links" : [ ]
  }, {
    "name" : "private static String getCaller(StackTraceElement[] callStack, int depth)",
    "returnType" : "String",
    "comment" : "\n     * Return a String describing the calling method and location at a particular stack depth.\n     * @param callStack the Thread stack\n     * @param depth the depth of stack to return information for.\n     * @return the String describing the caller at that depth.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getCallers(final int depth)",
    "returnType" : "String",
    "comment" : "\n     * Return a string consisting of methods and locations at multiple call stack levels.\n     * @param depth the number of levels to return, starting with the immediate caller.\n     * @return a string describing the call stack.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getCallers(final int start, int depth)",
    "returnType" : "String",
    "comment" : "\n     * Return a string consisting of methods and locations at multiple call stack levels.\n     * @param depth the number of levels to return, starting with the immediate caller.\n     * @return a string describing the call stack.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getCallers(final int depth, String linePrefix)",
    "returnType" : "String",
    "comment" : "\n     * Like {@link #getCallers(int)}, but each location is append to the string\n     * as a new line with <var>linePrefix</var> in front of it.\n     * @param depth the number of levels to return, starting with the immediate caller.\n     * @param linePrefix prefix to put in front of each location.\n     * @return a string describing the call stack.\n     * {@hide}\n     ",
    "links" : [ "#getCallers(int)" ]
  }, {
    "name" : "public static String getCaller()",
    "returnType" : "String",
    "comment" : "\n     * @return a String describing the immediate caller of the calling method.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void attachJvmtiAgent(@NonNull String library, @Nullable String options, @Nullable ClassLoader classLoader) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Attach a library as a jvmti agent to the current runtime, with the given classloader\n     * determining the library search path.\n     * <p>\n     * Note: agents may only be attached to debuggable apps. Otherwise, this function will\n     * throw a SecurityException.\n     *\n     * @param library the library containing the agent.\n     * @param options the options passed to the agent.\n     * @param classLoader the classloader determining the library search path.\n     *\n     * @throws IOException if the agent could not be attached.\n     * @throws SecurityException if the app is not debuggable.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native long getZramFreeKb()",
    "returnType" : "long",
    "comment" : "\n     * Return the current free ZRAM usage in kilobytes.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native long getDmabufTotalExportedKb()",
    "returnType" : "long",
    "comment" : "\n     * Return total memory size in kilobytes for exported DMA-BUFs or -1 if\n     * the DMA-BUF sysfs stats at /sys/kernel/dmabuf/buffers could not be read.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native long getDmabufHeapTotalExportedKb()",
    "returnType" : "long",
    "comment" : "\n     * Return total memory size in kilobytes for DMA-BUFs exported from the DMA-BUF\n     * heaps frameworks or -1 in the case of an error.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native long getIonHeapsSizeKb()",
    "returnType" : "long",
    "comment" : "\n     * Return memory size in kilobytes allocated for ION heaps or -1 if\n     * /sys/kernel/ion/total_heaps_kb could not be read.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native long getDmabufHeapPoolsSizeKb()",
    "returnType" : "long",
    "comment" : "\n     * Return memory size in kilobytes allocated for DMA-BUF heap pools or -1 if\n     * /sys/kernel/dma_heap/total_pools_kb could not be read.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native long getIonPoolsSizeKb()",
    "returnType" : "long",
    "comment" : "\n     * Return memory size in kilobytes allocated for ION pools or -1 if\n     * /sys/kernel/ion/total_pools_kb could not be read.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native long getGpuPrivateMemoryKb()",
    "returnType" : "long",
    "comment" : "\n     * Returns the global total GPU-private memory in kB or -1 on error.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native long getDmabufMappedSizeKb()",
    "returnType" : "long",
    "comment" : "\n     * Return DMA-BUF memory mapped by processes in kB.\n     * Notes:\n     *  * Warning: Might impact performance as it reads /proc/<pid>/maps files for each process.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native long getGpuTotalUsageKb()",
    "returnType" : "long",
    "comment" : "\n     * Return memory size in kilobytes used by GPU.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native boolean isVmapStack()",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether virtually-mapped kernel stacks are enabled (CONFIG_VMAP_STACK).\n     * Note: caller needs config_gz read sepolicy permission\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static native boolean logAllocatorStats()",
    "returnType" : "boolean",
    "comment" : "\n     * Log internal statistics about the allocator.\n     * @return true if the statistics were logged properly, false if not.\n     *\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public static void suspendAllAndSendVmStart()", "public static void waitForDebugger()", "public static boolean waitingForDebugger()", "public static boolean isDebuggerConnected()", "public static String[] getVmFeatureList()", "public static String[] getFeatureList()", "public static void changeDebugPort(int port)", "public static void startNativeTracing()", "public static void stopNativeTracing()", "public static void enableEmulatorTraceOutput()", "public static void startMethodTracing()", "public static void startMethodTracing(String tracePath)", "public static void startMethodTracing(String tracePath, int bufferSize)", "public static void startMethodTracing(String tracePath, int bufferSize, int flags)", "public static void startMethodTracingSampling(String tracePath, int bufferSize, int intervalUs)", "private static String fixTracePath(String tracePath)", "public static void startMethodTracing(String traceName, FileDescriptor fd, int bufferSize, int flags, boolean streamOutput)", "public static void startMethodTracingDdms(int bufferSize, int flags, boolean samplingEnabled, int intervalUs)", "public static int getMethodTracingMode()", "public static void stopMethodTracing()", "public static long threadCpuTimeNanos()", "public static void startAllocCounting()", "public static void stopAllocCounting()", "public static int getGlobalAllocCount()", "public static void resetGlobalAllocCount()", "public static int getGlobalAllocSize()", "public static void resetGlobalAllocSize()", "public static int getGlobalFreedCount()", "public static void resetGlobalFreedCount()", "public static int getGlobalFreedSize()", "public static void resetGlobalFreedSize()", "public static int getGlobalGcInvocationCount()", "public static void resetGlobalGcInvocationCount()", "public static int getGlobalClassInitCount()", "public static void resetGlobalClassInitCount()", "public static int getGlobalClassInitTime()", "public static void resetGlobalClassInitTime()", "public static int getGlobalExternalAllocCount()", "public static void resetGlobalExternalAllocSize()", "public static void resetGlobalExternalAllocCount()", "public static int getGlobalExternalAllocSize()", "public static int getGlobalExternalFreedCount()", "public static void resetGlobalExternalFreedCount()", "public static int getGlobalExternalFreedSize()", "public static void resetGlobalExternalFreedSize()", "public static int getThreadAllocCount()", "public static void resetThreadAllocCount()", "public static int getThreadAllocSize()", "public static void resetThreadAllocSize()", "public static int getThreadExternalAllocCount()", "public static void resetThreadExternalAllocCount()", "public static int getThreadExternalAllocSize()", "public static void resetThreadExternalAllocSize()", "public static int getThreadGcInvocationCount()", "public static void resetThreadGcInvocationCount()", "public static void resetAllCounts()", "public static String getRuntimeStat(String statName)", "public static Map<String, String> getRuntimeStats()", "public static native long getNativeHeapSize()", "public static native long getNativeHeapAllocatedSize()", "public static native long getNativeHeapFreeSize()", "public static native void getMemoryInfo(MemoryInfo memoryInfo)", "public static native boolean getMemoryInfo(int pid, MemoryInfo memoryInfo)", "public static native long getPss()", "public static native long getPss(int pid, long[] outUssSwapPssRss, long[] outMemtrack)", "public static native long getRss()", "public static native long getRss(int pid, long[] outMemtrack)", "public static native void getMemInfo(long[] outSizes)", "public static int setAllocationLimit(int limit)", "public static int setGlobalAllocationLimit(int limit)", "public static void printLoadedClasses(int flags)", "public static int getLoadedClassCount()", "public static void dumpHprofData(String fileName) throws IOException", "public static void dumpHprofData(String fileName, FileDescriptor fd) throws IOException", "public static void dumpHprofDataDdms()", "public static native void dumpNativeHeap(FileDescriptor fd)", "public static native void dumpNativeMallocInfo(FileDescriptor fd)", "public static long countInstancesOfClass(Class cls)", "public static native int getBinderSentTransactions()", "public static native int getBinderReceivedTransactions()", "public static final native int getBinderLocalObjectCount()", "public static final native int getBinderProxyObjectCount()", "public static final native int getBinderDeathObjectCount()", "public static final void dumpReferenceTables()", "private static boolean fieldTypeMatches(Field field, Class<?> cl)", "private static void modifyFieldIfSet(final Field field, final TypedProperties properties, final String propertyName)", "public static void setFieldsOn(Class<?> cl)", "public static void setFieldsOn(Class<?> cl, boolean partial)", "public static boolean dumpService(String name, FileDescriptor fd, String[] args)", "public static native boolean dumpJavaBacktraceToFileTimeout(int pid, String file, int timeoutSecs)", "public static native boolean dumpNativeBacktraceToFileTimeout(int pid, String file, int timeoutSecs)", "public static native String getUnreachableMemory(int limit, boolean contents)", "private static String getCaller(StackTraceElement[] callStack, int depth)", "public static String getCallers(final int depth)", "public static String getCallers(final int start, int depth)", "public static String getCallers(final int depth, String linePrefix)", "public static String getCaller()", "public static void attachJvmtiAgent(@NonNull String library, @Nullable String options, @Nullable ClassLoader classLoader) throws IOException", "public static native long getZramFreeKb()", "public static native long getDmabufTotalExportedKb()", "public static native long getDmabufHeapTotalExportedKb()", "public static native long getIonHeapsSizeKb()", "public static native long getDmabufHeapPoolsSizeKb()", "public static native long getIonPoolsSizeKb()", "public static native long getGpuPrivateMemoryKb()", "public static native long getDmabufMappedSizeKb()", "public static native long getGpuTotalUsageKb()", "public static native boolean isVmapStack()", "public static native boolean logAllocatorStats()" ],
  "variableNames" : [ "TAG", "TRACE_COUNT_ALLOCS", "SHOW_FULL_DETAIL", "SHOW_CLASSLOADER", "SHOW_INITIALIZED", "mWaiting", "MIN_DEBUGGER_IDLE", "SPIN_DELAY", "DEFAULT_TRACE_BODY", "DEFAULT_TRACE_EXTENSION", "FRAMEWORK_FEATURES", "SYSFS_QEMU_TRACE_STATE", "MEMINFO_TOTAL", "MEMINFO_FREE", "MEMINFO_BUFFERS", "MEMINFO_CACHED", "MEMINFO_SHMEM", "MEMINFO_SLAB", "MEMINFO_SLAB_RECLAIMABLE", "MEMINFO_SLAB_UNRECLAIMABLE", "MEMINFO_SWAP_TOTAL", "MEMINFO_SWAP_FREE", "MEMINFO_ZRAM_TOTAL", "MEMINFO_MAPPED", "MEMINFO_VM_ALLOC_USED", "MEMINFO_PAGE_TABLES", "MEMINFO_KERNEL_STACK", "MEMINFO_KRECLAIMABLE", "MEMINFO_ACTIVE", "MEMINFO_INACTIVE", "MEMINFO_UNEVICTABLE", "MEMINFO_AVAILABLE", "MEMINFO_ACTIVE_ANON", "MEMINFO_INACTIVE_ANON", "MEMINFO_ACTIVE_FILE", "MEMINFO_INACTIVE_FILE", "MEMINFO_CMA_TOTAL", "MEMINFO_CMA_FREE", "MEMINFO_COUNT", "debugProperties" ]
}