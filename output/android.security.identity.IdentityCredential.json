{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/security/identity/IdentityCredential.java",
  "packageName" : "android.security.identity",
  "className" : "IdentityCredential",
  "comment" : "\n * Class used to read data from a previously provisioned credential.\n *\n * Use {@link IdentityCredentialStore#getCredentialByName(String, int)} to get a\n * {@link IdentityCredential} instance.\n ",
  "links" : [ "android.security.identity.IdentityCredentialStore#getCredentialByName(String", "android.security.identity.IdentityCredential" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : "public abstract KeyPair createEphemeralKeyPair()",
    "returnType" : "KeyPair",
    "comment" : "\n     * Create an ephemeral key pair to use to establish a secure channel with a reader.\n     *\n     * <p>Applications should use this key-pair for the communications channel with the reader\n     * using a protocol / cipher-suite appropriate for the application. One example of such a\n     * protocol is the one used for Mobile Driving Licenses, see ISO 18013-5 section 9.2.1 \"Session\n     * encryption\".\n     *\n     * @return ephemeral key pair to use to establish a secure channel with a reader.\n     * @deprecated Use {@link PresentationSession} instead.\n     ",
    "links" : [ "android.security.identity.PresentationSession" ]
  }, {
    "name" : "public abstract void setReaderEphemeralPublicKey(@NonNull PublicKey readerEphemeralPublicKey) throws InvalidKeyException",
    "returnType" : "void",
    "comment" : "\n     * Set the ephemeral public key provided by the reader. If called, this must be called before\n     * {@link #getEntries(byte[], Map, byte[], byte[])} is called.\n     *\n     * @param readerEphemeralPublicKey The ephemeral public key provided by the reader to\n     *                                 establish a secure session.\n     * @throws InvalidKeyException if the given key is invalid.\n     * @deprecated Use {@link PresentationSession} instead.\n     ",
    "links" : [ "android.security.identity.PresentationSession", "#getEntries(byte" ]
  }, {
    "name" : "public abstract byte[] encryptMessageToReader(@NonNull byte[] messagePlaintext)",
    "returnType" : "byte[]",
    "comment" : "\n     * Encrypt a message for transmission to the reader.\n     *\n     * <p>Do not use. In this version of the API, this method produces an incorrect\n     * result. Instead, applications should implement message encryption/decryption themselves as\n     * detailed in the {@link #createEphemeralKeyPair()} method. In a future API-level, this\n     * method will be deprecated.\n     *\n     * @param messagePlaintext unencrypted message to encrypt.\n     * @return encrypted message.\n     * @deprecated Applications should use {@link PresentationSession} and\n     *             implement encryption/decryption themselves.\n     ",
    "links" : [ "android.security.identity.PresentationSession", "#createEphemeralKeyPair()" ]
  }, {
    "name" : "public abstract byte[] decryptMessageFromReader(@NonNull byte[] messageCiphertext) throws MessageDecryptionException",
    "returnType" : "byte[]",
    "comment" : "\n     * Decrypt a message received from the reader.\n     *\n     * <p>Do not use. In this version of the API, this method produces an incorrect\n     * result. Instead, applications should implement message encryption/decryption themselves as\n     * detailed in the {@link #createEphemeralKeyPair()} method. In a future API-level, this\n     * method will be deprecated.\n     *\n     * @param messageCiphertext encrypted message to decrypt.\n     * @return decrypted message.\n     * @throws MessageDecryptionException if the ciphertext couldn't be decrypted.\n     * @deprecated Applications should use {@link PresentationSession} and\n     *             implement encryption/decryption themselves.\n     ",
    "links" : [ "android.security.identity.PresentationSession", "#createEphemeralKeyPair()" ]
  }, {
    "name" : "public abstract Collection<X509Certificate> getCredentialKeyCertificateChain()",
    "returnType" : "Collection<X509Certificate>",
    "comment" : "\n     * Gets the X.509 certificate chain for the CredentialKey which identifies this\n     * credential to the issuing authority. This is the same certificate chain that\n     * was returned by {@link WritableIdentityCredential#getCredentialKeyCertificateChain(byte[])}\n     * when the credential was first created and its Android Keystore extension will\n     * contain the <code>challenge</code> data set at that time. See the documentation\n     * for that method for important information about this certificate chain.\n     *\n     * @return the certificate chain for this credential's CredentialKey.\n     ",
    "links" : [ "android.security.identity.WritableIdentityCredential#getCredentialKeyCertificateChain(byte" ]
  }, {
    "name" : "public abstract void setAllowUsingExhaustedKeys(boolean allowUsingExhaustedKeys)",
    "returnType" : "void",
    "comment" : "\n     * Sets whether to allow using an authentication key which use count has been exceeded if no\n     * other key is available. This must be called prior to calling\n     * {@link #getEntries(byte[], Map, byte[], byte[])}.\n     *\n     * By default this is set to true.\n     *\n     * @param allowUsingExhaustedKeys whether to allow using an authentication key which use count\n     *                                has been exceeded if no other key is available.\n     * @deprecated Use {@link PresentationSession} instead.\n     ",
    "links" : [ "android.security.identity.PresentationSession", "#getEntries(byte" ]
  }, {
    "name" : "public void setAllowUsingExpiredKeys(boolean allowUsingExpiredKeys)",
    "returnType" : "void",
    "comment" : "\n     * Sets whether to allow using an authentication key which has been expired if no\n     * other key is available. This must be called prior to calling\n     * {@link #getEntries(byte[], Map, byte[], byte[])}.\n     *\n     * <p>By default this is set to false.\n     *\n     * <p>This is only implemented in feature version 202101 or later. If not implemented, the call\n     * fails with {@link UnsupportedOperationException}. See\n     * {@link android.content.pm.PackageManager#FEATURE_IDENTITY_CREDENTIAL_HARDWARE} for known\n     * feature versions.\n     *\n     * @param allowUsingExpiredKeys whether to allow using an authentication key which use count\n     *                              has been exceeded if no other key is available.\n     * @deprecated Use {@link PresentationSession} instead.\n     ",
    "links" : [ "android.security.identity.PresentationSession", "android.content.pm.PackageManager#FEATURE_IDENTITY_CREDENTIAL_HARDWARE", "#getEntries(byte", "UnsupportedOperationException" ]
  }, {
    "name" : "public void setIncrementKeyUsageCount(boolean incrementKeyUsageCount)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     *\n     * Sets whether the usage count of an authentication key should be increased. This must be\n     * called prior to calling\n     * {@link #getEntries(byte[], Map, byte[], byte[])} or using a\n     * {@link android.hardware.biometrics.BiometricPrompt.CryptoObject} which references this object.\n     *\n     * <p>By default this is set to true.\n     *\n     * <p>This is only implemented in feature version 202201 or later. If not implemented, the call\n     * fails with {@link UnsupportedOperationException}. See\n     * {@link android.content.pm.PackageManager#FEATURE_IDENTITY_CREDENTIAL_HARDWARE} for known\n     * feature versions.\n     *\n     * @param incrementKeyUsageCount whether the usage count of the key should be increased.\n     * @deprecated Use {@link PresentationSession} instead.\n     ",
    "links" : [ "android.hardware.biometrics.BiometricPrompt.CryptoObject", "android.security.identity.PresentationSession", "android.content.pm.PackageManager#FEATURE_IDENTITY_CREDENTIAL_HARDWARE", "#getEntries(byte", "UnsupportedOperationException" ]
  }, {
    "name" : "public abstract long getCredstoreOperationHandle()",
    "returnType" : "long",
    "comment" : "\n     * Called by android.hardware.biometrics.CryptoObject#getOpId() to get an\n     * operation handle.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract ResultData getEntries(@Nullable byte[] requestMessage, @NonNull Map<String, Collection<String>> entriesToRequest, @Nullable byte[] sessionTranscript, @Nullable byte[] readerSignature) throws SessionTranscriptMismatchException, NoAuthenticationKeyAvailableException, InvalidReaderSignatureException, EphemeralPublicKeyNotFoundException, InvalidRequestMessageException",
    "returnType" : "ResultData",
    "comment" : "\n     * Retrieve data entries and associated data from this {@code IdentityCredential}.\n     *\n     * <p>If an access control check fails for one of the requested entries or if the entry\n     * doesn't exist, the entry is simply not returned. The application can detect this\n     * by using the {@link ResultData#getStatus(String, String)} method on each of the requested\n     * entries.\n     *\n     * <p>It is permissible to call this method multiple times using the same instance but if this\n     * is done, the {@code sessionTranscript} parameter must be identical for each call. If this is\n     * not the case, the {@link SessionTranscriptMismatchException} exception is thrown.\n     * Additionally, if this is done the same auth-key will be used.\n     *\n     * <p>The application should not make any assumptions on whether user authentication is needed.\n     * Instead, the application should request the data elements values first and then examine\n     * the returned {@link ResultData}. If {@link ResultData#STATUS_USER_AUTHENTICATION_FAILED}\n     * is returned the application should get a\n     * {@link android.hardware.biometrics.BiometricPrompt.CryptoObject} which references this\n     * object and use it with a {@link android.hardware.biometrics.BiometricPrompt}. Upon successful\n     * authentication the application may call {@link #getEntries(byte[], Map, byte[], byte[])}\n     * again.\n     *\n     * <p>If not {@code null} the {@code requestMessage} parameter must contain data for the request\n     * from the verifier. The content can be defined in the way appropriate for the credential, but\n     * there are three requirements that must be met to work with this API:\n     * <ul>\n     * <li>The content must be a CBOR-encoded structure.</li>\n     * <li>The CBOR structure must be a map.</li>\n     * <li>The map must contain a tstr key \"nameSpaces\" whose value contains a map, as described in\n     *     the example below.</li>\n     * </ul>\n     *\n     * <p>If these requirements are not met the {@link InvalidRequestMessageException} exception\n     * is thrown.\n     *\n     * <p>Here's an example of CBOR which conforms to this requirement:\n     * <pre>\n     *   ItemsRequest = {\n     *     ? \"docType\" : DocType,\n     *     \"nameSpaces\" : NameSpaces,\n     *     ? \"RequestInfo\" : {* tstr => any} ; Additional info the reader wants to provide\n     *   }\n     *\n     *   DocType = tstr\n     *\n     *   NameSpaces = {\n     *     + NameSpace => DataElements    ; Requested data elements for each NameSpace\n     *   }\n     *\n     *   NameSpace = tstr\n     *\n     *   DataElements = {\n     *     + DataElement => IntentToRetain\n     *   }\n     *\n     *   DataElement = tstr\n     *   IntentToRetain = bool\n     * </pre>\n     *\n     * <p>If mdoc session encryption is used (e.g. if {@link #createEphemeralKeyPair()} has been\n     * called) and if the {@code sessionTranscript} parameter is not {@code null}, the X and Y\n     * coordinates of the public part of the key-pair previously generated by\n     * {@link #createEphemeralKeyPair()} must appear somewhere in the bytes of the CBOR. Each of\n     * these coordinates must appear encoded with the most significant bits first and use the\n     * exact amount of bits indicated by the key size of the ephemeral keys. For example, if the\n     * ephemeral key is using the P-256 curve then the 32 bytes for the X coordinate encoded with\n     * the most significant bits first must appear somewhere in {@code sessionTranscript} and\n     * ditto for the 32 bytes for the Y coordinate.\n     *\n     * <p>If {@code readerSignature} is not {@code null} it must be the bytes of a\n     * {@code COSE_Sign1} structure as defined in RFC 8152. For the payload nil shall be used and\n     * the detached payload is the ReaderAuthenticationBytes CBOR described below.\n     * <pre>\n     *     ReaderAuthentication = [\n     *       \"ReaderAuthentication\",\n     *       SessionTranscript,\n     *       ItemsRequestBytes\n     *     ]\n     *\n     *     ItemsRequestBytes = #6.24(bstr .cbor ItemsRequest)\n     *\n     *     ReaderAuthenticationBytes = #6.24(bstr .cbor ReaderAuthentication)\n     * </pre>\n     *\n     * <p>where {@code ItemsRequestBytes} are the bytes in the {@code requestMessage} parameter.\n     *\n     * <p>The public key corresponding to the key used to make the signature, can be found in the\n     * {@code x5chain} unprotected header element of the {@code COSE_Sign1} structure (as as\n     * described in\n     * <a href=\"https://tools.ietf.org/html/draft-ietf-cose-x509-04\">draft-ietf-cose-x509-04</a>).\n     * There will be at least one certificate in said element and there may be more (and if so,\n     * each certificate must be signed by its successor).\n     *\n     * <p>Data elements protected by reader authentication are returned if, and only if, they are\n     * mentioned in {@code requestMessage}, {@code requestMessage} is signed by the top-most\n     * certificate in the reader's certificate chain, and the data element is configured\n     * with an {@link AccessControlProfile} configured with an X.509 certificate which appears\n     * in the certificate chain.\n     *\n     * <p>Note that only items referenced in {@code entriesToRequest} are returned - the\n     * {@code requestMessage} parameter is used only for enforcing reader authentication.\n     *\n     * <p>The reason for having {@code requestMessage} and {@code entriesToRequest} as separate\n     * parameters is that the former represents a request from the remote verifier device\n     * (optionally signed) and this allows the application to filter the request to not include\n     * data elements which the user has not consented to sharing.\n     *\n     * @param requestMessage         If not {@code null}, must contain CBOR data conforming to\n     *                               the schema mentioned above.\n     * @param entriesToRequest       The entries to request, organized as a map of namespace\n     *                               names with each value being a collection of data elements\n     *                               in the given namespace.\n     * @param readerSignature        A {@code COSE_Sign1} structure as described above or\n     *                               {@code null} if reader authentication is not being used.\n     * @return A {@link ResultData} object containing entry data organized by namespace and a\n     *         cryptographically authenticated representation of the same data.\n     * @throws SessionTranscriptMismatchException     Thrown when trying use multiple different\n     *                                                session transcripts.\n     * @throws NoAuthenticationKeyAvailableException  if authentication keys were never\n     *                                                provisioned, the method\n     *                                      {@link #setAvailableAuthenticationKeys(int, int, long)}\n     *                                                was called with {@code keyCount} set to 0,\n     *                                                the method\n     *                                                {@link #setAllowUsingExhaustedKeys(boolean)}\n     *                                                was called with {@code false} and all\n     *                                                available authentication keys have been\n     *                                                exhausted.\n     * @throws InvalidReaderSignatureException        if the reader signature is invalid, or it\n     *                                                doesn't contain a certificate chain, or if\n     *                                                the signature failed to validate.\n     * @throws InvalidRequestMessageException         if the requestMessage is malformed.\n     * @throws EphemeralPublicKeyNotFoundException    if the ephemeral public key was not found in\n     *                                                the session transcript.\n     * @deprecated Use {@link PresentationSession} instead.\n     ",
    "links" : [ "android.security.identity.ResultData#getStatus(String", "android.security.identity.SessionTranscriptMismatchException", "android.security.identity.PresentationSession", "android.security.identity.InvalidRequestMessageException", "#setAllowUsingExhaustedKeys(boolean)", "android.hardware.biometrics.BiometricPrompt.CryptoObject", "android.hardware.biometrics.BiometricPrompt", "android.security.identity.ResultData#STATUS_USER_AUTHENTICATION_FAILED", "android.security.identity.AccessControlProfile", "android.security.identity.ResultData", "#setAvailableAuthenticationKeys(int", "#createEphemeralKeyPair()", "#getEntries(byte" ]
  }, {
    "name" : "public abstract void setAvailableAuthenticationKeys(int keyCount, int maxUsesPerKey)",
    "returnType" : "void",
    "comment" : "\n     * Sets the number of dynamic authentication keys the {@code IdentityCredential} will maintain,\n     * and the number of times each should be used.\n     *\n     * <p>The Identity Credential system will select the least-used dynamic authentication key each\n     * time {@link #getEntries(byte[], Map, byte[], byte[])} is called. Identity Credentials\n     * for which this method has not been called behave as though it had been called wit\n     * {@code keyCount} 0 and {@code maxUsesPerKey} 1.\n     *\n     * <p>The effect of this method is like calling\n     * {@link #setAvailableAuthenticationKeys(int, int, long)} with the last parameter is set to 0.\n     *\n     * @param keyCount      The number of active, certified dynamic authentication keys the\n     *                      {@code IdentityCredential} will try to keep available. This value\n     *                      must be non-negative.\n     * @param maxUsesPerKey The maximum number of times each of the keys will be used before it's\n     *                      eligible for replacement. This value must be greater than zero.\n     * @deprecated Use {@link #setAvailableAuthenticationKeys(int, int, long)} instead.\n     ",
    "links" : [ "#setAvailableAuthenticationKeys(int", "#getEntries(byte" ]
  }, {
    "name" : "public abstract Collection<X509Certificate> getAuthKeysNeedingCertification()",
    "returnType" : "Collection<X509Certificate>",
    "comment" : "\n     * Gets a collection of dynamic authentication keys that need certification.\n     *\n     * <p>When there aren't enough certified dynamic authentication keys, either because the key\n     * count has been increased or because one or more keys have reached their usage count or\n     * it if a key is too close to its expiration date, this\n     * method will generate replacement keys and certificates and return them for issuer\n     * certification.  The issuer certificates and associated static authentication data must then\n     * be provided back to the Identity Credential using\n     * {@link #storeStaticAuthenticationData(X509Certificate, byte[])}.  The private part of\n     * each authentication key never leaves secure hardware.\n     *\n     * <p>Each X.509 certificate is signed by CredentialKey. The certificate chain for CredentialKey\n     * can be obtained using the {@link #getCredentialKeyCertificateChain()} method.\n\n     * <p>If the implementation is feature version 202101 or later,\n     * each X.509 certificate contains an X.509 extension at OID 1.3.6.1.4.1.11129.2.1.26 which\n     * contains a DER encoded OCTET STRING with the bytes of the CBOR with the following CDDL:\n     * <pre>\n     *   ProofOfBinding = [\n     *     \"ProofOfBinding\",\n     *     bstr,              // Contains SHA-256(ProofOfProvisioning)\n     *   ]\n     * </pre>\n     * <p>This CBOR enables an issuer to determine the exact state of the credential it\n     * returns issuer-signed data for.\n     *\n     * <p> See {@link android.content.pm.PackageManager#FEATURE_IDENTITY_CREDENTIAL_HARDWARE} for\n     * known feature versions.\n     *\n     * @return A collection of X.509 certificates for dynamic authentication keys that need issuer\n     * certification.\n     ",
    "links" : [ "#getCredentialKeyCertificateChain()", "android.content.pm.PackageManager#FEATURE_IDENTITY_CREDENTIAL_HARDWARE", "#storeStaticAuthenticationData(X509Certificate" ]
  }, {
    "name" : "public abstract void storeStaticAuthenticationData(@NonNull X509Certificate authenticationKey, @NonNull byte[] staticAuthData) throws UnknownAuthenticationKeyException",
    "returnType" : "void",
    "comment" : "\n     * Store authentication data associated with a dynamic authentication key.\n     *\n     * This should only be called for an authenticated key returned by\n     * {@link #getAuthKeysNeedingCertification()}.\n     *\n     * @param authenticationKey The dynamic authentication key for which certification and\n     *                          associated static\n     *                          authentication data is being provided.\n     * @param staticAuthData    Static authentication data provided by the issuer that validates\n     *                          the authenticity\n     *                          and integrity of the credential data fields.\n     * @throws UnknownAuthenticationKeyException If the given authentication key is not recognized.\n     * @deprecated Use {@link #storeStaticAuthenticationData(X509Certificate, Instant, byte[])}\n     *     instead.\n     ",
    "links" : [ "#storeStaticAuthenticationData(X509Certificate", "#getAuthKeysNeedingCertification()" ]
  }, {
    "name" : "public void storeStaticAuthenticationData(@NonNull X509Certificate authenticationKey, @NonNull Instant expirationDate, @NonNull byte[] staticAuthData) throws UnknownAuthenticationKeyException",
    "returnType" : "void",
    "comment" : "\n     * Store authentication data associated with a dynamic authentication key.\n     *\n     * This should only be called for an authenticated key returned by\n     * {@link #getAuthKeysNeedingCertification()}.\n     *\n     * @param authenticationKey The dynamic authentication key for which certification and\n     *                          associated static\n     *                          authentication data is being provided.\n     * @param expirationDate    The expiration date of the static authentication data.\n     * @param staticAuthData    Static authentication data provided by the issuer that validates\n     *                          the authenticity\n     *                          and integrity of the credential data fields.\n     * @throws UnknownAuthenticationKeyException If the given authentication key is not recognized.\n     ",
    "links" : [ "#getAuthKeysNeedingCertification()" ]
  }, {
    "name" : "public abstract int[] getAuthenticationDataUsageCount()",
    "returnType" : "int[]",
    "comment" : "\n     * Get the number of times the dynamic authentication keys have been used.\n     *\n     * @return int array of dynamic authentication key usage counts.\n     * @deprecated Use {@link #getAuthenticationKeyMetadata()} instead.\n     ",
    "links" : [ "#getAuthenticationKeyMetadata()" ]
  }, {
    "name" : "public byte[] proveOwnership(@NonNull byte[] challenge)",
    "returnType" : "byte[]",
    "comment" : "\n     * Proves ownership of a credential.\n     *\n     * <p>This method returns a COSE_Sign1 data structure signed by the CredentialKey\n     * with payload set to {@code ProofOfDeletion} as defined below.</p>\n     *\n     * <p>The returned CBOR is the following:</p>\n     * <pre>\n     *     ProofOfOwnership = [\n     *          \"ProofOfOwnership\",           ; tstr\n     *          tstr,                         ; DocType\n     *          bstr,                         ; Challenge\n     *          bool                          ; true if this is a test credential, should\n     *                                        ; always be false.\n     *      ]\n     * </pre>\n     *\n     * <p>This is only implemented in feature version 202101 or later. If not implemented, the call\n     * fails with {@link UnsupportedOperationException}. See\n     * {@link android.content.pm.PackageManager#FEATURE_IDENTITY_CREDENTIAL_HARDWARE} for known\n     * feature versions.\n     *\n     * @param challenge is a non-empty byte array whose contents should be unique, fresh and\n     *                  provided by the issuing authority. The value provided is embedded in the\n     *                  generated CBOR and enables the issuing authority to verify that the\n     *                  returned proof is fresh. Implementations are required to support\n     *                  challenges at least 32 bytes of length.\n     * @return the COSE_Sign1 data structure above\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_IDENTITY_CREDENTIAL_HARDWARE", "UnsupportedOperationException" ]
  }, {
    "name" : "public byte[] delete(@NonNull byte[] challenge)",
    "returnType" : "byte[]",
    "comment" : "\n     * Deletes a credential.\n     *\n     * <p>This method returns a COSE_Sign1 data structure signed by the CredentialKey\n     * with payload set to {@code ProofOfDeletion} as defined below.</p>\n     *\n     * <pre>\n     *     ProofOfDeletion = [\n     *          \"ProofOfDeletion\",            ; tstr\n     *          tstr,                         ; DocType\n     *          bstr,                         ; Challenge\n     *          bool                          ; true if this is a test credential, should\n     *                                        ; always be false.\n     *      ]\n     * </pre>\n     *\n     * <p>This is only implemented in feature version 202101 or later. If not implemented, the call\n     * fails with {@link UnsupportedOperationException}. See\n     * {@link android.content.pm.PackageManager#FEATURE_IDENTITY_CREDENTIAL_HARDWARE} for known\n     * feature versions.\n     *\n     * @param challenge is a non-empty byte array whose contents should be unique, fresh and\n     *                  provided by the issuing authority. The value provided is embedded in the\n     *                  generated CBOR and enables the issuing authority to verify that the\n     *                  returned proof is fresh. Implementations are required to support\n     *                  challenges at least 32 bytes of length.\n     * @return the COSE_Sign1 data structure above\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_IDENTITY_CREDENTIAL_HARDWARE", "UnsupportedOperationException" ]
  }, {
    "name" : "public byte[] update(@NonNull PersonalizationData personalizationData)",
    "returnType" : "byte[]",
    "comment" : "\n     * Updates the credential with new access control profiles and data items.\n     *\n     * <p>This method is similar to\n     * {@link WritableIdentityCredential#personalize(PersonalizationData)} except that it operates\n     * on an existing credential, see the documentation for that method for the format of the\n     * returned data.\n     *\n     * <p>If this call succeeds an side-effect is that all dynamic authentication keys for the\n     * credential are deleted. The application will need to use\n     * {@link #getAuthKeysNeedingCertification()} to generate replacement keys and return\n     * them for issuer certification.\n     *\n     * <p>This is only implemented in feature version 202101 or later. If not implemented, the call\n     * fails with {@link UnsupportedOperationException}. See\n     * {@link android.content.pm.PackageManager#FEATURE_IDENTITY_CREDENTIAL_HARDWARE} for known\n     * feature versions.\n     *\n     * @param personalizationData   The data to update, including access control profiles\n     *                              and data elements and their values, grouped into namespaces.\n     * @return A COSE_Sign1 data structure, see above.\n     ",
    "links" : [ "android.security.identity.WritableIdentityCredential#personalize(PersonalizationData)", "android.content.pm.PackageManager#FEATURE_IDENTITY_CREDENTIAL_HARDWARE", "#getAuthKeysNeedingCertification()", "UnsupportedOperationException" ]
  }, {
    "name" : "public void setAvailableAuthenticationKeys(@IntRange(from = 0) int keyCount, @IntRange(from = 1) int maxUsesPerKey, @IntRange(from = 0) long minValidTimeMillis)",
    "returnType" : "void",
    "comment" : "\n     * Sets the number of dynamic authentication keys the {@code IdentityCredential} will maintain,\n     * the number of times each should be used, and the minimum amount of time it's valid for.\n     *\n     * <p>The Identity Credential system will select the least-used dynamic authentication key each\n     * time {@link #getEntries(byte[], Map, byte[], byte[])} is called. Identity Credentials\n     * for which this method has not been called behave as though it had been called wit\n     * {@code keyCount} 0, {@code maxUsesPerKey} 1, and {@code minValidTimeMillis} 0.\n     *\n     * <p>Applications can use {@link #getAuthenticationKeyMetadata()} to get a picture of the\n     * usage andtime left of each configured authentication key. This can be used to determine\n     * how urgent it is recertify new authentication keys via the\n     * {@link #getAuthKeysNeedingCertification()} method.\n     *\n     * @param keyCount      The number of active, certified dynamic authentication keys the\n     *                      {@code IdentityCredential} will try to keep available. This value\n     *                      must be non-negative.\n     * @param maxUsesPerKey The maximum number of times each of the keys will be used before it's\n     *                      eligible for replacement. This value must be greater than zero.\n     * @param minValidTimeMillis If a key has less time left than this value it will be eliglible\n     *                           for replacement. This value must be non-negative.\n     ",
    "links" : [ "#getAuthenticationKeyMetadata()", "#getEntries(byte", "#getAuthKeysNeedingCertification()" ]
  }, {
    "name" : "public List<AuthenticationKeyMetadata> getAuthenticationKeyMetadata()",
    "returnType" : "List<AuthenticationKeyMetadata>",
    "comment" : "\n     * Get information about dynamic authentication keys.\n     *\n     * <p>The returned list may have <code>null</code> values if certification for the dynamic\n     * authentication key is pending.\n     *\n     * <p>The list is always <code>keyCount</code> elements long.\n     *\n     * @return list of authentication key metadata objects.\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public abstract KeyPair createEphemeralKeyPair()", "public abstract void setReaderEphemeralPublicKey(@NonNull PublicKey readerEphemeralPublicKey) throws InvalidKeyException", "public abstract byte[] encryptMessageToReader(@NonNull byte[] messagePlaintext)", "public abstract byte[] decryptMessageFromReader(@NonNull byte[] messageCiphertext) throws MessageDecryptionException", "public abstract Collection<X509Certificate> getCredentialKeyCertificateChain()", "public abstract void setAllowUsingExhaustedKeys(boolean allowUsingExhaustedKeys)", "public void setAllowUsingExpiredKeys(boolean allowUsingExpiredKeys)", "public void setIncrementKeyUsageCount(boolean incrementKeyUsageCount)", "public abstract long getCredstoreOperationHandle()", "public abstract ResultData getEntries(@Nullable byte[] requestMessage, @NonNull Map<String, Collection<String>> entriesToRequest, @Nullable byte[] sessionTranscript, @Nullable byte[] readerSignature) throws SessionTranscriptMismatchException, NoAuthenticationKeyAvailableException, InvalidReaderSignatureException, EphemeralPublicKeyNotFoundException, InvalidRequestMessageException", "public abstract void setAvailableAuthenticationKeys(int keyCount, int maxUsesPerKey)", "public abstract Collection<X509Certificate> getAuthKeysNeedingCertification()", "public abstract void storeStaticAuthenticationData(@NonNull X509Certificate authenticationKey, @NonNull byte[] staticAuthData) throws UnknownAuthenticationKeyException", "public void storeStaticAuthenticationData(@NonNull X509Certificate authenticationKey, @NonNull Instant expirationDate, @NonNull byte[] staticAuthData) throws UnknownAuthenticationKeyException", "public abstract int[] getAuthenticationDataUsageCount()", "public byte[] proveOwnership(@NonNull byte[] challenge)", "public byte[] delete(@NonNull byte[] challenge)", "public byte[] update(@NonNull PersonalizationData personalizationData)", "public void setAvailableAuthenticationKeys(@IntRange(from = 0) int keyCount, @IntRange(from = 1) int maxUsesPerKey, @IntRange(from = 0) long minValidTimeMillis)", "public List<AuthenticationKeyMetadata> getAuthenticationKeyMetadata()" ],
  "variableNames" : [ ]
}