{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/graphics/Paint.java",
  "packageName" : "android.graphics",
  "className" : "Paint",
  "comment" : "\n * The Paint class holds the style and color information about how to draw\n * geometries, text and bitmaps.\n ",
  "variables" : [ {
    "name" : "mNativePaint",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mNativeShader",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mNativeColorFilter",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mColor",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mColorFilter",
    "type" : "ColorFilter",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMaskFilter",
    "type" : "MaskFilter",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPathEffect",
    "type" : "PathEffect",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mShader",
    "type" : "Shader",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTypeface",
    "type" : "Typeface",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mXfermode",
    "type" : "Xfermode",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHasCompatScaling",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCompatScaling",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInvCompatScaling",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLocales",
    "type" : "LocaleList",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFontFeatureSettings",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFontVariationSettings",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mShadowLayerRadius",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mShadowLayerDx",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mShadowLayerDy",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mShadowLayerColor",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sCacheLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sMinikinLocaleListIdCache",
    "type" : "HashMap<String, Integer>",
    "comment" : "\n     * Cache for the Minikin language list ID.\n     *\n     * A map from a string representation of the LocaleList to Minikin's language list ID.\n     ",
    "links" : [ ]
  }, {
    "name" : "mBidiFlags",
    "type" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "sStyleArray",
    "type" : "Style[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sCapArray",
    "type" : "Cap[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sJoinArray",
    "type" : "Join[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sAlignArray",
    "type" : "Align[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ANTI_ALIAS_FLAG",
    "type" : "int",
    "comment" : "\n     * Paint flag that enables antialiasing when drawing.\n     *\n     * <p>Enabling this flag will cause all draw operations that support\n     * antialiasing to use it.</p>\n     *\n     * @see #Paint(int)\n     * @see #setFlags(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FILTER_BITMAP_FLAG",
    "type" : "int",
    "comment" : "\n     * Paint flag that enables bilinear sampling on scaled bitmaps.\n     *\n     * <p>If cleared, scaled bitmaps will be drawn with nearest neighbor\n     * sampling, likely resulting in artifacts. This should generally be on\n     * when drawing bitmaps, unless performance-bound (rendering to software\n     * canvas) or preferring pixelation artifacts to blurriness when scaling\n     * significantly.</p>\n     *\n     * <p>If bitmaps are scaled for device density at creation time (as\n     * resource bitmaps often are) the filtering will already have been\n     * done.</p>\n     *\n     * @see #Paint(int)\n     * @see #setFlags(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "DITHER_FLAG",
    "type" : "int",
    "comment" : "\n     * Paint flag that enables dithering when blitting.\n     *\n     * <p>Enabling this flag applies a dither to any blit operation where the\n     * target's colour space is more constrained than the source.\n     *\n     * @see #Paint(int)\n     * @see #setFlags(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "UNDERLINE_TEXT_FLAG",
    "type" : "int",
    "comment" : "\n     * Paint flag that applies an underline decoration to drawn text.\n     *\n     * @see #Paint(int)\n     * @see #setFlags(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "STRIKE_THRU_TEXT_FLAG",
    "type" : "int",
    "comment" : "\n     * Paint flag that applies a strike-through decoration to drawn text.\n     *\n     * @see #Paint(int)\n     * @see #setFlags(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "FAKE_BOLD_TEXT_FLAG",
    "type" : "int",
    "comment" : "\n     * Paint flag that applies a synthetic bolding effect to drawn text.\n     *\n     * <p>Enabling this flag will cause text draw operations to apply a\n     * simulated bold effect when drawing a {@link Typeface} that is not\n     * already bold.</p>\n     *\n     * @see #Paint(int)\n     * @see #setFlags(int)\n     ",
    "links" : [ "Typeface" ]
  }, {
    "name" : "LINEAR_TEXT_FLAG",
    "type" : "int",
    "comment" : "\n     * Paint flag that enables smooth linear scaling of text.\n     *\n     * <p>Enabling this flag does not actually scale text, but rather adjusts\n     * text draw operations to deal gracefully with smooth adjustment of scale.\n     * When this flag is enabled, font hinting is disabled to prevent shape\n     * deformation between scale factors, and glyph caching is disabled due to\n     * the large number of glyph images that will be generated.</p>\n     *\n     * <p>{@link #SUBPIXEL_TEXT_FLAG} should be used in conjunction with this\n     * flag to prevent glyph positions from snapping to whole pixel values as\n     * scale factor is adjusted.</p>\n     *\n     * @see #Paint(int)\n     * @see #setFlags(int)\n     ",
    "links" : [ "#SUBPIXEL_TEXT_FLAG" ]
  }, {
    "name" : "SUBPIXEL_TEXT_FLAG",
    "type" : "int",
    "comment" : "\n     * Paint flag that enables subpixel positioning of text.\n     *\n     * <p>Enabling this flag causes glyph advances to be computed with subpixel\n     * accuracy.</p>\n     *\n     * <p>This can be used with {@link #LINEAR_TEXT_FLAG} to prevent text from\n     * jittering during smooth scale transitions.</p>\n     *\n     * @see #Paint(int)\n     * @see #setFlags(int)\n     ",
    "links" : [ "#LINEAR_TEXT_FLAG" ]
  }, {
    "name" : "DEV_KERN_TEXT_FLAG",
    "type" : "int",
    "comment" : " Legacy Paint flag, no longer used. ",
    "links" : [ ]
  }, {
    "name" : "LCD_RENDER_TEXT_FLAG",
    "type" : "int",
    "comment" : " @hide bit mask for the flag enabling subpixel glyph rendering for text ",
    "links" : [ ]
  }, {
    "name" : "EMBEDDED_BITMAP_TEXT_FLAG",
    "type" : "int",
    "comment" : "\n     * Paint flag that enables the use of bitmap fonts when drawing text.\n     *\n     * <p>Disabling this flag will prevent text draw operations from using\n     * embedded bitmap strikes in fonts, causing fonts with both scalable\n     * outlines and bitmap strikes to draw only the scalable outlines, and\n     * fonts with only bitmap strikes to not draw at all.</p>\n     *\n     * @see #Paint(int)\n     * @see #setFlags(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "AUTO_HINTING_TEXT_FLAG",
    "type" : "int",
    "comment" : " @hide bit mask for the flag forcing freetype's autohinter on for text ",
    "links" : [ ]
  }, {
    "name" : "VERTICAL_TEXT_FLAG",
    "type" : "int",
    "comment" : " @hide bit mask for the flag enabling vertical rendering for text ",
    "links" : [ ]
  }, {
    "name" : "HIDDEN_DEFAULT_PAINT_FLAGS",
    "type" : "int",
    "comment" : " These flags are always set on a new/reset paint, even if flags 0 is passed.",
    "links" : [ ]
  }, {
    "name" : "HINTING_OFF",
    "type" : "int",
    "comment" : "\n     * Font hinter option that disables font hinting.\n     *\n     * @see #setHinting(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "HINTING_ON",
    "type" : "int",
    "comment" : "\n     * Font hinter option that enables font hinting.\n     *\n     * @see #setHinting(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "BIDI_LTR",
    "type" : "int",
    "comment" : "\n     * Bidi flag to set LTR paragraph direction.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "BIDI_RTL",
    "type" : "int",
    "comment" : "\n     * Bidi flag to set RTL paragraph direction.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "BIDI_DEFAULT_LTR",
    "type" : "int",
    "comment" : "\n     * Bidi flag to detect paragraph direction via heuristics, defaulting to\n     * LTR.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "BIDI_DEFAULT_RTL",
    "type" : "int",
    "comment" : "\n     * Bidi flag to detect paragraph direction via heuristics, defaulting to\n     * RTL.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "BIDI_FORCE_LTR",
    "type" : "int",
    "comment" : "\n     * Bidi flag to override direction to all LTR (ignore bidi).\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "BIDI_FORCE_RTL",
    "type" : "int",
    "comment" : "\n     * Bidi flag to override direction to all RTL (ignore bidi).\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "BIDI_MAX_FLAG_VALUE",
    "type" : "int",
    "comment" : "\n     * Maximum Bidi flag value.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "BIDI_FLAG_MASK",
    "type" : "int",
    "comment" : "\n     * Mask for bidi flags.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTION_LTR",
    "type" : "int",
    "comment" : "\n     * Flag for getTextRunAdvances indicating left-to-right run direction.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTION_RTL",
    "type" : "int",
    "comment" : "\n     * Flag for getTextRunAdvances indicating right-to-left run direction.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CURSOR_AFTER",
    "type" : "int",
    "comment" : "\n     * Option for getTextRunCursor.\n     *\n     * Compute the valid cursor after offset or the limit of the context, whichever is less.\n     ",
    "links" : [ ]
  }, {
    "name" : "CURSOR_AT_OR_AFTER",
    "type" : "int",
    "comment" : "\n     * Option for getTextRunCursor.\n     *\n     * Compute the valid cursor at or after the offset or the limit of the context, whichever is\n     * less.\n     ",
    "links" : [ ]
  }, {
    "name" : "CURSOR_BEFORE",
    "type" : "int",
    "comment" : "\n     * Option for getTextRunCursor.\n     *\n     * Compute the valid cursor before offset or the start of the context, whichever is greater.\n     ",
    "links" : [ ]
  }, {
    "name" : "CURSOR_AT_OR_BEFORE",
    "type" : "int",
    "comment" : "\n     * Option for getTextRunCursor.\n     *\n     * Compute the valid cursor at or before offset or the start of the context, whichever is\n     * greater.\n     ",
    "links" : [ ]
  }, {
    "name" : "CURSOR_AT",
    "type" : "int",
    "comment" : "\n     * Option for getTextRunCursor.\n     *\n     * Return offset if the cursor at offset is valid, or -1 if it isn't.\n     ",
    "links" : [ ]
  }, {
    "name" : "CURSOR_OPT_MAX_VALUE",
    "type" : "int",
    "comment" : "\n     * Maximum cursor option value.\n     ",
    "links" : [ ]
  }, {
    "name" : "START_HYPHEN_EDIT_NO_EDIT",
    "type" : "int",
    "comment" : "\n     * An integer representing the starting of the line has no modification for hyphenation.\n     ",
    "links" : [ ]
  }, {
    "name" : "START_HYPHEN_EDIT_INSERT_HYPHEN",
    "type" : "int",
    "comment" : "\n     * An integer representing the starting of the line has normal hyphen character (U+002D).\n     ",
    "links" : [ ]
  }, {
    "name" : "START_HYPHEN_EDIT_INSERT_ZWJ",
    "type" : "int",
    "comment" : "\n     * An integer representing the starting of the line has Zero-Width-Joiner (U+200D).\n     ",
    "links" : [ ]
  }, {
    "name" : "END_HYPHEN_EDIT_NO_EDIT",
    "type" : "int",
    "comment" : "\n     * An integer representing the end of the line has no modification for hyphenation.\n     ",
    "links" : [ ]
  }, {
    "name" : "END_HYPHEN_EDIT_REPLACE_WITH_HYPHEN",
    "type" : "int",
    "comment" : "\n     * An integer representing the character at the end of the line is replaced with hyphen\n     * character (U+002D).\n     ",
    "links" : [ ]
  }, {
    "name" : "END_HYPHEN_EDIT_INSERT_HYPHEN",
    "type" : "int",
    "comment" : "\n     * An integer representing the end of the line has normal hyphen character (U+002D).\n     ",
    "links" : [ ]
  }, {
    "name" : "END_HYPHEN_EDIT_INSERT_ARMENIAN_HYPHEN",
    "type" : "int",
    "comment" : "\n     * An integer representing the end of the line has Armentian hyphen (U+058A).\n     ",
    "links" : [ ]
  }, {
    "name" : "END_HYPHEN_EDIT_INSERT_MAQAF",
    "type" : "int",
    "comment" : "\n     * An integer representing the end of the line has maqaf (Hebrew hyphen, U+05BE).\n     ",
    "links" : [ ]
  }, {
    "name" : "END_HYPHEN_EDIT_INSERT_UCAS_HYPHEN",
    "type" : "int",
    "comment" : "\n     * An integer representing the end of the line has Canadian Syllabics hyphen (U+1400).\n     ",
    "links" : [ ]
  }, {
    "name" : "END_HYPHEN_EDIT_INSERT_ZWJ_AND_HYPHEN",
    "type" : "int",
    "comment" : "\n     * An integer representing the end of the line has Zero-Width-Joiner (U+200D) followed by normal\n     * hyphen character (U+002D).\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public void reset()",
    "returnType" : "void",
    "comment" : " Restores the paint to its default settings. ",
    "links" : [ ]
  }, {
    "name" : "public void set(Paint src)",
    "returnType" : "void",
    "comment" : "\n     * Copy the fields from src into this paint. This is equivalent to calling\n     * get() on all of the src fields, and calling the corresponding set()\n     * methods on this.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setClassVariablesFrom(Paint paint)",
    "returnType" : "void",
    "comment" : "\n     * Set all class variables using current values from the given\n     * {@link Paint}.\n     ",
    "links" : [ "Paint" ]
  }, {
    "name" : "public void setCompatibilityScaling(float factor)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public long getNativeInstance()",
    "returnType" : "long",
    "comment" : "\n     * Return the pointer to the native object while ensuring that any\n     * mutable objects that are attached to the paint are also up-to-date.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getBidiFlags()",
    "returnType" : "int",
    "comment" : "\n     * Return the bidi flags on the paint.\n     *\n     * @return the bidi flags on the paint\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setBidiFlags(int flags)",
    "returnType" : "void",
    "comment" : "\n     * Set the bidi flags on the paint.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getFlags()",
    "returnType" : "int",
    "comment" : "\n     * Return the paint's flags. Use the Flag enum to test flag values.\n     *\n     * @return the paint's flags (see enums ending in _Flag for bit masks)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setFlags(int flags)",
    "returnType" : "void",
    "comment" : "\n     * Set the paint's flags. Use the Flag enum to specific flag values.\n     *\n     * @param flags The new flag bits for the paint\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getHinting()",
    "returnType" : "int",
    "comment" : "\n     * Return the paint's hinting mode.  Returns either\n     * {@link #HINTING_OFF} or {@link #HINTING_ON}.\n     ",
    "links" : [ "#HINTING_OFF", "#HINTING_ON" ]
  }, {
    "name" : "public void setHinting(int mode)",
    "returnType" : "void",
    "comment" : "\n     * Set the paint's hinting mode.  May be either\n     * {@link #HINTING_OFF} or {@link #HINTING_ON}.\n     ",
    "links" : [ "#HINTING_OFF", "#HINTING_ON" ]
  }, {
    "name" : "public final boolean isAntiAlias()",
    "returnType" : "boolean",
    "comment" : "\n     * Helper for getFlags(), returning true if ANTI_ALIAS_FLAG bit is set\n     * AntiAliasing smooths out the edges of what is being drawn, but is has\n     * no impact on the interior of the shape. See setDither() and\n     * setFilterBitmap() to affect how colors are treated.\n     *\n     * @return true if the antialias bit is set in the paint's flags.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAntiAlias(boolean aa)",
    "returnType" : "void",
    "comment" : "\n     * Helper for setFlags(), setting or clearing the ANTI_ALIAS_FLAG bit\n     * AntiAliasing smooths out the edges of what is being drawn, but is has\n     * no impact on the interior of the shape. See setDither() and\n     * setFilterBitmap() to affect how colors are treated.\n     *\n     * @param aa true to set the antialias bit in the flags, false to clear it\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean isDither()",
    "returnType" : "boolean",
    "comment" : "\n     * Helper for getFlags(), returning true if DITHER_FLAG bit is set\n     * Dithering affects how colors that are higher precision than the device\n     * are down-sampled. No dithering is generally faster, but higher precision\n     * colors are just truncated down (e.g. 8888 -> 565). Dithering tries to\n     * distribute the error inherent in this process, to reduce the visual\n     * artifacts.\n     *\n     * @return true if the dithering bit is set in the paint's flags.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDither(boolean dither)",
    "returnType" : "void",
    "comment" : "\n     * Helper for setFlags(), setting or clearing the DITHER_FLAG bit\n     * Dithering affects how colors that are higher precision than the device\n     * are down-sampled. No dithering is generally faster, but higher precision\n     * colors are just truncated down (e.g. 8888 -> 565). Dithering tries to\n     * distribute the error inherent in this process, to reduce the visual\n     * artifacts.\n     *\n     * @param dither true to set the dithering bit in flags, false to clear it\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean isLinearText()",
    "returnType" : "boolean",
    "comment" : "\n     * Helper for getFlags(), returning true if LINEAR_TEXT_FLAG bit is set\n     *\n     * @return true if the lineartext bit is set in the paint's flags\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setLinearText(boolean linearText)",
    "returnType" : "void",
    "comment" : "\n     * Helper for setFlags(), setting or clearing the LINEAR_TEXT_FLAG bit\n     *\n     * @param linearText true to set the linearText bit in the paint's flags,\n     *                   false to clear it.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean isSubpixelText()",
    "returnType" : "boolean",
    "comment" : "\n     * Helper for getFlags(), returning true if SUBPIXEL_TEXT_FLAG bit is set\n     *\n     * @return true if the subpixel bit is set in the paint's flags\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSubpixelText(boolean subpixelText)",
    "returnType" : "void",
    "comment" : "\n     * Helper for setFlags(), setting or clearing the SUBPIXEL_TEXT_FLAG bit\n     *\n     * @param subpixelText true to set the subpixelText bit in the paint's\n     *                     flags, false to clear it.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean isUnderlineText()",
    "returnType" : "boolean",
    "comment" : "\n     * Helper for getFlags(), returning true if UNDERLINE_TEXT_FLAG bit is set\n     *\n     * @return true if the underlineText bit is set in the paint's flags.\n     * @see #getUnderlinePosition()\n     * @see #getUnderlineThickness()\n     * @see #setUnderlineText(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getUnderlinePosition()",
    "returnType" : "float",
    "comment" : "\n     * Returns the distance from top of the underline to the baseline in pixels.\n     *\n     * The result is positive for positions that are below the baseline.\n     * This method returns where the underline should be drawn independent of if the {@link\n     * #UNDERLINE_TEXT_FLAG} bit is set.\n     *\n     * @return the position of the underline in pixels\n     * @see #isUnderlineText()\n     * @see #getUnderlineThickness()\n     * @see #setUnderlineText(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getUnderlineThickness()",
    "returnType" : "float",
    "comment" : "\n     * Returns the thickness of the underline in pixels.\n     *\n     * @return the thickness of the underline in pixels\n     * @see #isUnderlineText()\n     * @see #getUnderlinePosition()\n     * @see #setUnderlineText(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setUnderlineText(boolean underlineText)",
    "returnType" : "void",
    "comment" : "\n     * Helper for setFlags(), setting or clearing the UNDERLINE_TEXT_FLAG bit\n     *\n     * @param underlineText true to set the underlineText bit in the paint's\n     *                      flags, false to clear it.\n     * @see #isUnderlineText()\n     * @see #getUnderlinePosition()\n     * @see #getUnderlineThickness()\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean isStrikeThruText()",
    "returnType" : "boolean",
    "comment" : "\n     * Helper for getFlags(), returning true if STRIKE_THRU_TEXT_FLAG bit is set\n     *\n     * @return true if the {@link #STRIKE_THRU_TEXT_FLAG} bit is set in the paint's flags.\n     * @see #getStrikeThruPosition()\n     * @see #getStrikeThruThickness()\n     * @see #setStrikeThruText(boolean)\n     ",
    "links" : [ "#STRIKE_THRU_TEXT_FLAG" ]
  }, {
    "name" : "public float getStrikeThruPosition()",
    "returnType" : "float",
    "comment" : "\n     * Distance from top of the strike-through line to the baseline in pixels.\n     *\n     * The result is negative for positions that are above the baseline.\n     * This method returns where the strike-through line should be drawn independent of if the\n     * {@link #STRIKE_THRU_TEXT_FLAG} bit is set.\n     *\n     * @return the position of the strike-through line in pixels\n     * @see #getStrikeThruThickness()\n     * @see #setStrikeThruText(boolean)\n     * @see #isStrikeThruText()\n     ",
    "links" : [ "#STRIKE_THRU_TEXT_FLAG" ]
  }, {
    "name" : "public float getStrikeThruThickness()",
    "returnType" : "float",
    "comment" : "\n     * Returns the thickness of the strike-through line in pixels.\n     *\n     * @return the position of the strike-through line in pixels\n     * @see #getStrikeThruPosition()\n     * @see #setStrikeThruText(boolean)\n     * @see #isStrikeThruText()\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setStrikeThruText(boolean strikeThruText)",
    "returnType" : "void",
    "comment" : "\n     * Helper for setFlags(), setting or clearing the STRIKE_THRU_TEXT_FLAG bit\n     *\n     * @param strikeThruText true to set the strikeThruText bit in the paint's\n     *                       flags, false to clear it.\n     * @see #getStrikeThruPosition()\n     * @see #getStrikeThruThickness()\n     * @see #isStrikeThruText()\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean isFakeBoldText()",
    "returnType" : "boolean",
    "comment" : "\n     * Helper for getFlags(), returning true if FAKE_BOLD_TEXT_FLAG bit is set\n     *\n     * @return true if the fakeBoldText bit is set in the paint's flags.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setFakeBoldText(boolean fakeBoldText)",
    "returnType" : "void",
    "comment" : "\n     * Helper for setFlags(), setting or clearing the FAKE_BOLD_TEXT_FLAG bit\n     *\n     * @param fakeBoldText true to set the fakeBoldText bit in the paint's\n     *                     flags, false to clear it.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean isFilterBitmap()",
    "returnType" : "boolean",
    "comment" : "\n     * Whether or not the bitmap filter is activated.\n     * Filtering affects the sampling of bitmaps when they are transformed.\n     * Filtering does not affect how the colors in the bitmap are converted into\n     * device pixels. That is dependent on dithering and xfermodes.\n     *\n     * @see #setFilterBitmap(boolean) setFilterBitmap()\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setFilterBitmap(boolean filter)",
    "returnType" : "void",
    "comment" : "\n     * Helper for setFlags(), setting or clearing the FILTER_BITMAP_FLAG bit.\n     * Filtering affects the sampling of bitmaps when they are transformed.\n     * Filtering does not affect how the colors in the bitmap are converted into\n     * device pixels. That is dependent on dithering and xfermodes.\n     *\n     * @param filter true to set the FILTER_BITMAP_FLAG bit in the paint's\n     *               flags, false to clear it.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Style getStyle()",
    "returnType" : "Style",
    "comment" : "\n     * Return the paint's style, used for controlling how primitives'\n     * geometries are interpreted (except for drawBitmap, which always assumes\n     * FILL_STYLE).\n     *\n     * @return the paint's style setting (Fill, Stroke, StrokeAndFill)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setStyle(Style style)",
    "returnType" : "void",
    "comment" : "\n     * Set the paint's style, used for controlling how primitives'\n     * geometries are interpreted (except for drawBitmap, which always assumes\n     * Fill).\n     *\n     * @param style The new style to set in the paint\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getColor()",
    "returnType" : "int",
    "comment" : "\n     * Return the paint's color in sRGB. Note that the color is a 32bit value\n     * containing alpha as well as r,g,b. This 32bit value is not premultiplied,\n     * meaning that its alpha can be any value, regardless of the values of\n     * r,g,b. See the Color class for more details.\n     *\n     * @return the paint's color (and alpha).\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getColorLong()",
    "returnType" : "long",
    "comment" : "\n     * Return the paint's color. Note that the color is a long with an encoded\n     * {@link ColorSpace} as well as alpha and r,g,b. These values are not\n     * premultiplied, meaning that alpha can be any value, regardless of the\n     * values of r,g,b. See the {@link Color} class for more details.\n     *\n     * @return the paint's color, alpha, and {@code ColorSpace} encoded as a\n     *      {@code ColorLong}\n     ",
    "links" : [ "ColorSpace", "Color" ]
  }, {
    "name" : "public void setColor(@ColorInt int color)",
    "returnType" : "void",
    "comment" : "\n     * Set the paint's color. Note that the color is an int containing alpha\n     * as well as r,g,b. This 32bit value is not premultiplied, meaning that\n     * its alpha can be any value, regardless of the values of r,g,b.\n     * See the Color class for more details.\n     *\n     * @param color The new color (including alpha) to set in the paint.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setColor(@ColorLong long color)",
    "returnType" : "void",
    "comment" : "\n     * Set the paint's color with a {@code ColorLong}. Note that the color is\n     * a long with an encoded {@link ColorSpace} as well as alpha and r,g,b.\n     * These values are not premultiplied, meaning that alpha can be any value,\n     * regardless of the values of r,g,b. See the {@link Color} class for more\n     * details.\n     *\n     * @param color The new color (including alpha and {@link ColorSpace})\n     *      to set in the paint.\n     * @throws IllegalArgumentException if the color space encoded in the\n     *      {@code ColorLong} is invalid or unknown.\n     ",
    "links" : [ "ColorSpace", "Color", "ColorSpace" ]
  }, {
    "name" : "public int getAlpha()",
    "returnType" : "int",
    "comment" : "\n     * Helper to getColor() that just returns the color's alpha value. This is\n     * the same as calling getColor() >>> 24. It always returns a value between\n     * 0 (completely transparent) and 255 (completely opaque).\n     *\n     * @return the alpha component of the paint's color.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAlpha(int a)",
    "returnType" : "void",
    "comment" : "\n     * Helper to setColor(), that only assigns the color's alpha value,\n     * leaving its r,g,b values unchanged. Results are undefined if the alpha\n     * value is outside of the range [0..255]\n     *\n     * @param a set the alpha component [0..255] of the paint's color.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setARGB(int a, int r, int g, int b)",
    "returnType" : "void",
    "comment" : "\n     * Helper to setColor(), that takes a,r,g,b and constructs the color int\n     *\n     * @param a The new alpha component (0..255) of the paint's color.\n     * @param r The new red component (0..255) of the paint's color.\n     * @param g The new green component (0..255) of the paint's color.\n     * @param b The new blue component (0..255) of the paint's color.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getStrokeWidth()",
    "returnType" : "float",
    "comment" : "\n     * Return the width for stroking.\n     * <p />\n     * A value of 0 strokes in hairline mode.\n     * Hairlines always draws a single pixel independent of the canvas's matrix.\n     *\n     * @return the paint's stroke width, used whenever the paint's style is\n     *         Stroke or StrokeAndFill.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setStrokeWidth(float width)",
    "returnType" : "void",
    "comment" : "\n     * Set the width for stroking.\n     * Pass 0 to stroke in hairline mode.\n     * Hairlines always draws a single pixel independent of the canvas's matrix.\n     *\n     * @param width set the paint's stroke width, used whenever the paint's\n     *              style is Stroke or StrokeAndFill.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getStrokeMiter()",
    "returnType" : "float",
    "comment" : "\n     * Return the paint's stroke miter value. Used to control the behavior\n     * of miter joins when the joins angle is sharp.\n     *\n     * @return the paint's miter limit, used whenever the paint's style is\n     *         Stroke or StrokeAndFill.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setStrokeMiter(float miter)",
    "returnType" : "void",
    "comment" : "\n     * Set the paint's stroke miter value. This is used to control the behavior\n     * of miter joins when the joins angle is sharp. This value must be >= 0.\n     *\n     * @param miter set the miter limit on the paint, used whenever the paint's\n     *              style is Stroke or StrokeAndFill.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Cap getStrokeCap()",
    "returnType" : "Cap",
    "comment" : "\n     * Return the paint's Cap, controlling how the start and end of stroked\n     * lines and paths are treated.\n     *\n     * @return the line cap style for the paint, used whenever the paint's\n     *         style is Stroke or StrokeAndFill.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setStrokeCap(Cap cap)",
    "returnType" : "void",
    "comment" : "\n     * Set the paint's Cap.\n     *\n     * @param cap set the paint's line cap style, used whenever the paint's\n     *            style is Stroke or StrokeAndFill.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Join getStrokeJoin()",
    "returnType" : "Join",
    "comment" : "\n     * Return the paint's stroke join type.\n     *\n     * @return the paint's Join.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setStrokeJoin(Join join)",
    "returnType" : "void",
    "comment" : "\n     * Set the paint's Join.\n     *\n     * @param join set the paint's Join, used whenever the paint's style is\n     *             Stroke or StrokeAndFill.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getFillPath(Path src, Path dst)",
    "returnType" : "boolean",
    "comment" : "\n     * Applies any/all effects (patheffect, stroking) to src, returning the\n     * result in dst. The result is that drawing src with this paint will be\n     * the same as drawing dst with a default paint (at least from the\n     * geometric perspective).\n     *\n     * @param src input path\n     * @param dst output path (may be the same as src)\n     * @return    true if the path should be filled, or false if it should be\n     *                 drawn with a hairline (width == 0)\n     ",
    "links" : [ ]
  }, {
    "name" : "public Shader getShader()",
    "returnType" : "Shader",
    "comment" : "\n     * Get the paint's shader object.\n     *\n     * @return the paint's shader (or null)\n     ",
    "links" : [ ]
  }, {
    "name" : "public Shader setShader(Shader shader)",
    "returnType" : "Shader",
    "comment" : "\n     * Set or clear the shader object.\n     * <p />\n     * Pass null to clear any previous shader.\n     * As a convenience, the parameter passed is also returned.\n     *\n     * @param shader May be null. the new shader to be installed in the paint\n     * @return       shader\n     ",
    "links" : [ ]
  }, {
    "name" : "public ColorFilter getColorFilter()",
    "returnType" : "ColorFilter",
    "comment" : "\n     * Get the paint's colorfilter (maybe be null).\n     *\n     * @return the paint's colorfilter (maybe be null)\n     ",
    "links" : [ ]
  }, {
    "name" : "public ColorFilter setColorFilter(ColorFilter filter)",
    "returnType" : "ColorFilter",
    "comment" : "\n     * Set or clear the paint's colorfilter, returning the parameter.\n     *\n     * @param filter May be null. The new filter to be installed in the paint\n     * @return       filter\n     ",
    "links" : [ ]
  }, {
    "name" : "public Xfermode getXfermode()",
    "returnType" : "Xfermode",
    "comment" : "\n     * Get the paint's transfer mode object.\n     *\n     * @return the paint's transfer mode (or null)\n     ",
    "links" : [ ]
  }, {
    "name" : "public BlendMode getBlendMode()",
    "returnType" : "BlendMode",
    "comment" : "\n     * Get the paint's blend mode object.\n     *\n     * @return the paint's blend mode (or null)\n     ",
    "links" : [ ]
  }, {
    "name" : "public Xfermode setXfermode(Xfermode xfermode)",
    "returnType" : "Xfermode",
    "comment" : "\n     * Set or clear the transfer mode object. A transfer mode defines how\n     * source pixels (generate by a drawing command) are composited with\n     * the destination pixels (content of the render target).\n     * <p />\n     * Pass null to clear any previous transfer mode.\n     * As a convenience, the parameter passed is also returned.\n     * <p />\n     * {@link PorterDuffXfermode} is the most common transfer mode.\n     *\n     * @param xfermode May be null. The xfermode to be installed in the paint\n     * @return         xfermode\n     ",
    "links" : [ "PorterDuffXfermode" ]
  }, {
    "name" : "private Xfermode installXfermode(Xfermode xfermode)",
    "returnType" : "Xfermode",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setBlendMode(@Nullable BlendMode blendmode)",
    "returnType" : "void",
    "comment" : "\n     * Set or clear the blend mode. A blend mode defines how source pixels\n     * (generated by a drawing command) are composited with the destination pixels\n     * (content of the render target).\n     * <p />\n     * Pass null to clear any previous blend mode.\n     * <p />\n     *\n     * @see BlendMode\n     *\n     * @param blendmode May be null. The blend mode to be installed in the paint\n     ",
    "links" : [ ]
  }, {
    "name" : "public PathEffect getPathEffect()",
    "returnType" : "PathEffect",
    "comment" : "\n     * Get the paint's patheffect object.\n     *\n     * @return the paint's patheffect (or null)\n     ",
    "links" : [ ]
  }, {
    "name" : "public PathEffect setPathEffect(PathEffect effect)",
    "returnType" : "PathEffect",
    "comment" : "\n     * Set or clear the patheffect object.\n     * <p />\n     * Pass null to clear any previous patheffect.\n     * As a convenience, the parameter passed is also returned.\n     *\n     * @param effect May be null. The patheffect to be installed in the paint\n     * @return       effect\n     ",
    "links" : [ ]
  }, {
    "name" : "public MaskFilter getMaskFilter()",
    "returnType" : "MaskFilter",
    "comment" : "\n     * Get the paint's maskfilter object.\n     *\n     * @return the paint's maskfilter (or null)\n     ",
    "links" : [ ]
  }, {
    "name" : "public MaskFilter setMaskFilter(MaskFilter maskfilter)",
    "returnType" : "MaskFilter",
    "comment" : "\n     * Set or clear the maskfilter object.\n     * <p />\n     * Pass null to clear any previous maskfilter.\n     * As a convenience, the parameter passed is also returned.\n     *\n     * @param maskfilter May be null. The maskfilter to be installed in the\n     *                   paint\n     * @return           maskfilter\n     ",
    "links" : [ ]
  }, {
    "name" : "public Typeface getTypeface()",
    "returnType" : "Typeface",
    "comment" : "\n     * Get the paint's typeface object.\n     * <p />\n     * The typeface object identifies which font to use when drawing or\n     * measuring text.\n     *\n     * @return the paint's typeface (or null)\n     ",
    "links" : [ ]
  }, {
    "name" : "public Typeface setTypeface(Typeface typeface)",
    "returnType" : "Typeface",
    "comment" : "\n     * Set or clear the typeface object.\n     * <p />\n     * Pass null to clear any previous typeface.\n     * As a convenience, the parameter passed is also returned.\n     *\n     * @param typeface May be null. The typeface to be installed in the paint\n     * @return         typeface\n     ",
    "links" : [ ]
  }, {
    "name" : "public Rasterizer getRasterizer()",
    "returnType" : "Rasterizer",
    "comment" : "\n     * Get the paint's rasterizer (or null).\n     * <p />\n     * The raster controls/modifies how paths/text are turned into alpha masks.\n     *\n     * @return         the paint's rasterizer (or null)\n     *\n     * @deprecated Rasterizer is not supported by either the HW or PDF backends.\n     * @removed\n     ",
    "links" : [ ]
  }, {
    "name" : "public Rasterizer setRasterizer(Rasterizer rasterizer)",
    "returnType" : "Rasterizer",
    "comment" : "\n     * Set or clear the rasterizer object.\n     * <p />\n     * Pass null to clear any previous rasterizer.\n     * As a convenience, the parameter passed is also returned.\n     *\n     * @param rasterizer May be null. The new rasterizer to be installed in\n     *                   the paint.\n     * @return           rasterizer\n     *\n     * @deprecated Rasterizer is not supported by either the HW or PDF backends.\n     * @removed\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setShadowLayer(float radius, float dx, float dy, @ColorInt int shadowColor)",
    "returnType" : "void",
    "comment" : "\n     * This draws a shadow layer below the main layer, with the specified\n     * offset and color, and blur radius. If radius is 0, then the shadow\n     * layer is removed.\n     * <p>\n     * Can be used to create a blurred shadow underneath text. Support for use\n     * with other drawing operations is constrained to the software rendering\n     * pipeline.\n     * <p>\n     * The alpha of the shadow will be the paint's alpha if the shadow color is\n     * opaque, or the alpha from the shadow color if not.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setShadowLayer(float radius, float dx, float dy, @ColorLong long shadowColor)",
    "returnType" : "void",
    "comment" : "\n     * This draws a shadow layer below the main layer, with the specified\n     * offset and color, and blur radius. If radius is 0, then the shadow\n     * layer is removed.\n     * <p>\n     * Can be used to create a blurred shadow underneath text. Support for use\n     * with other drawing operations is constrained to the software rendering\n     * pipeline.\n     * <p>\n     * The alpha of the shadow will be the paint's alpha if the shadow color is\n     * opaque, or the alpha from the shadow color if not.\n     *\n     * @throws IllegalArgumentException if the color space encoded in the\n     *      {@code ColorLong} is invalid or unknown.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void clearShadowLayer()",
    "returnType" : "void",
    "comment" : "\n     * Clear the shadow layer.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasShadowLayer()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the paint has a shadow layer attached\n     *\n     * @return true if the paint has a shadow layer attached and false otherwise\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getShadowLayerRadius()",
    "returnType" : "float",
    "comment" : "\n     * Returns the blur radius of the shadow layer.\n     * @see #setShadowLayer(float,float,float,int)\n     * @see #setShadowLayer(float,float,float,long)\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getShadowLayerDx()",
    "returnType" : "float",
    "comment" : "\n     * Returns the x offset of the shadow layer.\n     * @see #setShadowLayer(float,float,float,int)\n     * @see #setShadowLayer(float,float,float,long)\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getShadowLayerDy()",
    "returnType" : "float",
    "comment" : "\n     * Returns the y offset of the shadow layer.\n     * @see #setShadowLayer(float,float,float,int)\n     * @see #setShadowLayer(float,float,float,long)\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getShadowLayerColor()",
    "returnType" : "int",
    "comment" : "\n     * Returns the color of the shadow layer.\n     * @see #setShadowLayer(float,float,float,int)\n     * @see #setShadowLayer(float,float,float,long)\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getShadowLayerColorLong()",
    "returnType" : "long",
    "comment" : "\n     * Returns the color of the shadow layer.\n     *\n     * @return the shadow layer's color encoded as a {@link ColorLong}.\n     * @see #setShadowLayer(float,float,float,int)\n     * @see #setShadowLayer(float,float,float,long)\n     * @see Color\n     ",
    "links" : [ "ColorLong" ]
  }, {
    "name" : "public Align getTextAlign()",
    "returnType" : "Align",
    "comment" : "\n     * Return the paint's Align value for drawing text. This controls how the\n     * text is positioned relative to its origin. LEFT align means that all of\n     * the text will be drawn to the right of its origin (i.e. the origin\n     * specifieds the LEFT edge of the text) and so on.\n     *\n     * @return the paint's Align value for drawing text.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTextAlign(Align align)",
    "returnType" : "void",
    "comment" : "\n     * Set the paint's text alignment. This controls how the\n     * text is positioned relative to its origin. LEFT align means that all of\n     * the text will be drawn to the right of its origin (i.e. the origin\n     * specifieds the LEFT edge of the text) and so on.\n     *\n     * @param align set the paint's Align value for drawing text.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Locale getTextLocale()",
    "returnType" : "Locale",
    "comment" : "\n     * Get the text's primary Locale. Note that this is not all of the locale-related information\n     * Paint has. Use {@link #getTextLocales()} to get the complete list.\n     *\n     * @return the paint's primary Locale used for drawing text, never null.\n     ",
    "links" : [ "#getTextLocales" ]
  }, {
    "name" : "public LocaleList getTextLocales()",
    "returnType" : "LocaleList",
    "comment" : "\n     * Get the text locale list.\n     *\n     * @return the paint's LocaleList used for drawing text, never null or empty.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTextLocale(@NonNull Locale locale)",
    "returnType" : "void",
    "comment" : "\n     * Set the text locale list to a one-member list consisting of just the locale.\n     *\n     * See {@link #setTextLocales(LocaleList)} for how the locale list affects\n     * the way the text is drawn for some languages.\n     *\n     * @param locale the paint's locale value for drawing text, must not be null.\n     ",
    "links" : [ "#setTextLocales" ]
  }, {
    "name" : "public void setTextLocales(@NonNull @Size(min = 1) LocaleList locales)",
    "returnType" : "void",
    "comment" : "\n     * Set the text locale list.\n     *\n     * The text locale list affects how the text is drawn for some languages.\n     *\n     * For example, if the locale list contains {@link Locale#CHINESE} or {@link Locale#CHINA},\n     * then the text renderer will prefer to draw text using a Chinese font. Likewise,\n     * if the locale list contains {@link Locale#JAPANESE} or {@link Locale#JAPAN}, then the text\n     * renderer will prefer to draw text using a Japanese font. If the locale list contains both,\n     * the order those locales appear in the list is considered for deciding the font.\n     *\n     * This distinction is important because Chinese and Japanese text both use many\n     * of the same Unicode code points but their appearance is subtly different for\n     * each language.\n     *\n     * By default, the text locale list is initialized to a one-member list just containing the\n     * system locales. This assumes that the text to be rendered will most likely be in the user's\n     * preferred language.\n     *\n     * If the actual language or languages of the text is/are known, then they can be provided to\n     * the text renderer using this method. The text renderer may attempt to guess the\n     * language script based on the contents of the text to be drawn independent of\n     * the text locale here. Specifying the text locales just helps it do a better\n     * job in certain ambiguous cases.\n     *\n     * @param locales the paint's locale list for drawing text, must not be null or empty.\n     ",
    "links" : [ "Locale#CHINESE", "Locale#CHINA", "Locale#JAPANESE", "Locale#JAPAN" ]
  }, {
    "name" : "private void syncTextLocalesWithMinikin()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isElegantTextHeight()",
    "returnType" : "boolean",
    "comment" : "\n     * Get the elegant metrics flag.\n     *\n     * @return true if elegant metrics are enabled for text drawing.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setElegantTextHeight(boolean elegant)",
    "returnType" : "void",
    "comment" : "\n     * Set the paint's elegant height metrics flag. This setting selects font\n     * variants that have not been compacted to fit Latin-based vertical\n     * metrics, and also increases top and bottom bounds to provide more space.\n     *\n     * @param elegant set the paint's elegant metrics flag for drawing text.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getTextSize()",
    "returnType" : "float",
    "comment" : "\n     * Return the paint's text size.\n     *\n     * @return the paint's text size in pixel units.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTextSize(float textSize)",
    "returnType" : "void",
    "comment" : "\n     * Set the paint's text size. This value must be > 0\n     *\n     * @param textSize set the paint's text size in pixel units.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getTextScaleX()",
    "returnType" : "float",
    "comment" : "\n     * Return the paint's horizontal scale factor for text. The default value\n     * is 1.0.\n     *\n     * @return the paint's scale factor in X for drawing/measuring text\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTextScaleX(float scaleX)",
    "returnType" : "void",
    "comment" : "\n     * Set the paint's horizontal scale factor for text. The default value\n     * is 1.0. Values > 1.0 will stretch the text wider. Values < 1.0 will\n     * stretch the text narrower.\n     *\n     * @param scaleX set the paint's scale in X for drawing/measuring text.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getTextSkewX()",
    "returnType" : "float",
    "comment" : "\n     * Return the paint's horizontal skew factor for text. The default value\n     * is 0.\n     *\n     * @return         the paint's skew factor in X for drawing text.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTextSkewX(float skewX)",
    "returnType" : "void",
    "comment" : "\n     * Set the paint's horizontal skew factor for text. The default value\n     * is 0. For approximating oblique text, use values around -0.25.\n     *\n     * @param skewX set the paint's skew factor in X for drawing text.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getLetterSpacing()",
    "returnType" : "float",
    "comment" : "\n     * Return the paint's letter-spacing for text. The default value\n     * is 0.\n     *\n     * @return         the paint's letter-spacing for drawing text.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setLetterSpacing(float letterSpacing)",
    "returnType" : "void",
    "comment" : "\n     * Set the paint's letter-spacing for text. The default value\n     * is 0.  The value is in 'EM' units.  Typical values for slight\n     * expansion will be around 0.05.  Negative values tighten text.\n     *\n     * @param letterSpacing set the paint's letter-spacing for drawing text.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getWordSpacing()",
    "returnType" : "float",
    "comment" : "\n     * Return the paint's extra word-spacing for text.\n     *\n     * The default value is 0.\n     *\n     * @return the paint's extra word-spacing for drawing text in pixels.\n     * @see #setWordSpacing(float)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setWordSpacing(@Px float wordSpacing)",
    "returnType" : "void",
    "comment" : "\n     * Set the paint's extra word-spacing for text.\n     *\n     * Increases the white space width between words with the given amount of pixels.\n     * The default value is 0.\n     *\n     * @param wordSpacing set the paint's extra word-spacing for drawing text in pixels.\n     * @see #getWordSpacing()\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getFontFeatureSettings()",
    "returnType" : "String",
    "comment" : "\n     * Returns the font feature settings. The format is the same as the CSS\n     * font-feature-settings attribute:\n     * <a href=\"https://www.w3.org/TR/css-fonts-3/#font-feature-settings-prop\">\n     *     https://www.w3.org/TR/css-fonts-3/#font-feature-settings-prop</a>\n     *\n     * @return the paint's currently set font feature settings. Default is null.\n     *\n     * @see #setFontFeatureSettings(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setFontFeatureSettings(String settings)",
    "returnType" : "void",
    "comment" : "\n     * Set font feature settings.\n     *\n     * The format is the same as the CSS font-feature-settings attribute:\n     * <a href=\"https://www.w3.org/TR/css-fonts-3/#font-feature-settings-prop\">\n     *     https://www.w3.org/TR/css-fonts-3/#font-feature-settings-prop</a>\n     *\n     * @see #getFontFeatureSettings()\n     *\n     * @param settings the font feature settings string to use, may be null.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getFontVariationSettings()",
    "returnType" : "String",
    "comment" : "\n     * Returns the font variation settings.\n     *\n     * @return the paint's currently set font variation settings. Default is null.\n     *\n     * @see #setFontVariationSettings(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setFontVariationSettings(String fontVariationSettings)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets TrueType or OpenType font variation settings. The settings string is constructed from\n     * multiple pairs of axis tag and style values. The axis tag must contain four ASCII characters\n     * and must be wrapped with single quotes (U+0027) or double quotes (U+0022). Axis strings that\n     * are longer or shorter than four characters, or contain characters outside of U+0020..U+007E\n     * are invalid. If a specified axis name is not defined in the font, the settings will be\n     * ignored.\n     *\n     * Examples,\n     * <ul>\n     * <li>Set font width to 150.\n     * <pre>\n     * <code>\n     *   Paint paint = new Paint();\n     *   paint.setFontVariationSettings(\"'wdth' 150\");\n     * </code>\n     * </pre>\n     * </li>\n     *\n     * <li>Set the font slant to 20 degrees and ask for italic style.\n     * <pre>\n     * <code>\n     *   Paint paint = new Paint();\n     *   paint.setFontVariationSettings(\"'slnt' 20, 'ital' 1\");\n     * </code>\n     * </pre>\n     * </li>\n     * </ul>\n     *\n     * @param fontVariationSettings font variation settings. You can pass null or empty string as\n     *                              no variation settings.\n     *\n     * @return true if the given settings is effective to at least one font file underlying this\n     *         typeface. This function also returns true for empty settings string. Otherwise\n     *         returns false\n     *\n     * @throws IllegalArgumentException If given string is not a valid font variation settings\n     *                                  format\n     *\n     * @see #getFontVariationSettings()\n     * @see FontVariationAxis\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getStartHyphenEdit()",
    "returnType" : "int",
    "comment" : "\n     * Get the current value of start hyphen edit.\n     *\n     * The default value is 0 which is equivalent to {@link #START_HYPHEN_EDIT_NO_EDIT}.\n     *\n     * @return the current starting hyphen edit value\n     * @see #setStartHyphenEdit(int)\n     ",
    "links" : [ "#START_HYPHEN_EDIT_NO_EDIT" ]
  }, {
    "name" : "public int getEndHyphenEdit()",
    "returnType" : "int",
    "comment" : "\n     * Get the current value of end hyphen edit.\n     *\n     * The default value is 0 which is equivalent to {@link #END_HYPHEN_EDIT_NO_EDIT}.\n     *\n     * @return the current starting hyphen edit value\n     * @see #setStartHyphenEdit(int)\n     ",
    "links" : [ "#END_HYPHEN_EDIT_NO_EDIT" ]
  }, {
    "name" : "public void setStartHyphenEdit(@StartHyphenEdit int startHyphen)",
    "returnType" : "void",
    "comment" : "\n     * Set a start hyphen edit on the paint.\n     *\n     * By setting start hyphen edit, the measurement and drawing is performed with modifying\n     * hyphenation at the start of line. For example, by passing\n     * {@link #START_HYPHEN_EDIT_INSERT_HYPHEN} like as follows, HYPHEN(U+2010)\n     * character is appended at the start of line.\n     *\n     * <pre>\n     * <code>\n     *   Paint paint = new Paint();\n     *   paint.setStartHyphenEdit(Paint.START_HYPHEN_EDIT_INSERT_HYPHEN);\n     *   paint.measureText(\"abc\", 0, 3);  // Returns the width of \"-abc\"\n     *   Canvas.drawText(\"abc\", 0, 3, 0f, 0f, paint);  // Draws \"-abc\"\n     * </code>\n     * </pre>\n     *\n     * The default value is 0 which is equivalent to\n     * {@link #START_HYPHEN_EDIT_NO_EDIT}.\n     *\n     * @param startHyphen a start hyphen edit value.\n     * @see #getStartHyphenEdit()\n     ",
    "links" : [ "#START_HYPHEN_EDIT_INSERT_HYPHEN", "#START_HYPHEN_EDIT_NO_EDIT" ]
  }, {
    "name" : "public void setEndHyphenEdit(@EndHyphenEdit int endHyphen)",
    "returnType" : "void",
    "comment" : "\n     * Set a end hyphen edit on the paint.\n     *\n     * By setting end hyphen edit, the measurement and drawing is performed with modifying\n     * hyphenation at the end of line. For example, by passing\n     * {@link #END_HYPHEN_EDIT_INSERT_HYPHEN} like as follows, HYPHEN(U+2010)\n     * character is appended at the end of line.\n     *\n     * <pre>\n     * <code>\n     *   Paint paint = new Paint();\n     *   paint.setEndHyphenEdit(Paint.END_HYPHEN_EDIT_INSERT_HYPHEN);\n     *   paint.measureText(\"abc\", 0, 3);  // Returns the width of \"abc-\"\n     *   Canvas.drawText(\"abc\", 0, 3, 0f, 0f, paint);  // Draws \"abc-\"\n     * </code>\n     * </pre>\n     *\n     * The default value is 0 which is equivalent to {@link #END_HYPHEN_EDIT_NO_EDIT}.\n     *\n     * @param endHyphen a end hyphen edit value.\n     * @see #getEndHyphenEdit()\n     ",
    "links" : [ "#END_HYPHEN_EDIT_INSERT_HYPHEN", "#END_HYPHEN_EDIT_NO_EDIT" ]
  }, {
    "name" : "public float ascent()",
    "returnType" : "float",
    "comment" : "\n     * Return the distance above (negative) the baseline (ascent) based on the\n     * current typeface and text size.\n     *\n     * <p>Note that this is the ascent of the main typeface, and actual text rendered may need a\n     * larger ascent because fallback fonts may get used in rendering the text.\n     *\n     * @return the distance above (negative) the baseline (ascent) based on the\n     *         current typeface and text size.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float descent()",
    "returnType" : "float",
    "comment" : "\n     * Return the distance below (positive) the baseline (descent) based on the\n     * current typeface and text size.\n     *\n     * <p>Note that this is the descent of the main typeface, and actual text rendered may need a\n     * larger descent because fallback fonts may get used in rendering the text.\n     *\n     * @return the distance below (positive) the baseline (descent) based on\n     *         the current typeface and text size.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getFontMetrics(FontMetrics metrics)",
    "returnType" : "float",
    "comment" : "\n     * Return the font's recommended interline spacing, given the Paint's\n     * settings for typeface, textSize, etc. If metrics is not null, return the\n     * fontmetric values in it.\n     *\n     * <p>Note that these are the values for the main typeface, and actual text rendered may need a\n     * larger set of values because fallback fonts may get used in rendering the text.\n     *\n     * @param metrics If this object is not null, its fields are filled with\n     *                the appropriate values given the paint's text attributes.\n     * @return the font's recommended interline spacing.\n     ",
    "links" : [ ]
  }, {
    "name" : "public FontMetrics getFontMetrics()",
    "returnType" : "FontMetrics",
    "comment" : "\n     * Allocates a new FontMetrics object, and then calls getFontMetrics(fm)\n     * with it, returning the object.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getFontMetricsInt(FontMetricsInt fmi)",
    "returnType" : "int",
    "comment" : "\n     * Return the font's interline spacing, given the Paint's settings for\n     * typeface, textSize, etc. If metrics is not null, return the fontmetric\n     * values in it. Note: all values have been converted to integers from\n     * floats, in such a way has to make the answers useful for both spacing\n     * and clipping. If you want more control over the rounding, call\n     * getFontMetrics().\n     *\n     * <p>Note that these are the values for the main typeface, and actual text rendered may need a\n     * larger set of values because fallback fonts may get used in rendering the text.\n     *\n     * @return the font's interline spacing.\n     ",
    "links" : [ ]
  }, {
    "name" : "public FontMetricsInt getFontMetricsInt()",
    "returnType" : "FontMetricsInt",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public float getFontSpacing()",
    "returnType" : "float",
    "comment" : "\n     * Return the recommend line spacing based on the current typeface and\n     * text size.\n     *\n     * <p>Note that this is the value for the main typeface, and actual text rendered may need a\n     * larger value because fallback fonts may get used in rendering the text.\n     *\n     * @return  recommend line spacing based on the current typeface and\n     *          text size.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float measureText(char[] text, int index, int count)",
    "returnType" : "float",
    "comment" : "\n     * Return the width of the text.\n     *\n     * @param text  The text to measure. Cannot be null.\n     * @param index The index of the first character to start measuring\n     * @param count THe number of characters to measure, beginning with start\n     * @return      The width of the text\n     ",
    "links" : [ ]
  }, {
    "name" : "public float measureText(String text, int start, int end)",
    "returnType" : "float",
    "comment" : "\n     * Return the width of the text.\n     *\n     * @param text  The text to measure. Cannot be null.\n     * @param start The index of the first character to start measuring\n     * @param end   1 beyond the index of the last character to measure\n     * @return      The width of the text\n     ",
    "links" : [ ]
  }, {
    "name" : "public float measureText(String text)",
    "returnType" : "float",
    "comment" : "\n     * Return the width of the text.\n     *\n     * @param text  The text to measure. Cannot be null.\n     * @return      The width of the text\n     ",
    "links" : [ ]
  }, {
    "name" : "public float measureText(CharSequence text, int start, int end)",
    "returnType" : "float",
    "comment" : "\n     * Return the width of the text.\n     *\n     * @param text  The text to measure\n     * @param start The index of the first character to start measuring\n     * @param end   1 beyond the index of the last character to measure\n     * @return      The width of the text\n     ",
    "links" : [ ]
  }, {
    "name" : "public int breakText(char[] text, int index, int count, float maxWidth, float[] measuredWidth)",
    "returnType" : "int",
    "comment" : "\n     * Measure the text, stopping early if the measured width exceeds maxWidth.\n     * Return the number of chars that were measured, and if measuredWidth is\n     * not null, return in it the actual width measured.\n     *\n     * @param text  The text to measure. Cannot be null.\n     * @param index The offset into text to begin measuring at\n     * @param count The number of maximum number of entries to measure. If count\n     *              is negative, then the characters are measured in reverse order.\n     * @param maxWidth The maximum width to accumulate.\n     * @param measuredWidth Optional. If not null, returns the actual width\n     *                     measured.\n     * @return The number of chars that were measured. Will always be <=\n     *         abs(count).\n     ",
    "links" : [ ]
  }, {
    "name" : "public int breakText(CharSequence text, int start, int end, boolean measureForwards, float maxWidth, float[] measuredWidth)",
    "returnType" : "int",
    "comment" : "\n     * Measure the text, stopping early if the measured width exceeds maxWidth.\n     * Return the number of chars that were measured, and if measuredWidth is\n     * not null, return in it the actual width measured.\n     *\n     * @param text  The text to measure. Cannot be null.\n     * @param start The offset into text to begin measuring at\n     * @param end   The end of the text slice to measure.\n     * @param measureForwards If true, measure forwards, starting at start.\n     *                        Otherwise, measure backwards, starting with end.\n     * @param maxWidth The maximum width to accumulate.\n     * @param measuredWidth Optional. If not null, returns the actual width\n     *                     measured.\n     * @return The number of chars that were measured. Will always be <=\n     *         abs(end - start).\n     ",
    "links" : [ ]
  }, {
    "name" : "public int breakText(String text, boolean measureForwards, float maxWidth, float[] measuredWidth)",
    "returnType" : "int",
    "comment" : "\n     * Measure the text, stopping early if the measured width exceeds maxWidth.\n     * Return the number of chars that were measured, and if measuredWidth is\n     * not null, return in it the actual width measured.\n     *\n     * @param text  The text to measure. Cannot be null.\n     * @param measureForwards If true, measure forwards, starting with the\n     *                        first character in the string. Otherwise,\n     *                        measure backwards, starting with the\n     *                        last character in the string.\n     * @param maxWidth The maximum width to accumulate.\n     * @param measuredWidth Optional. If not null, returns the actual width\n     *                     measured.\n     * @return The number of chars that were measured. Will always be <=\n     *         abs(count).\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getTextWidths(char[] text, int index, int count, float[] widths)",
    "returnType" : "int",
    "comment" : "\n     * Return the advance widths for the characters in the string.\n     *\n     * @param text     The text to measure. Cannot be null.\n     * @param index    The index of the first char to to measure\n     * @param count    The number of chars starting with index to measure\n     * @param widths   array to receive the advance widths of the characters.\n     *                 Must be at least a large as count.\n     * @return         the actual number of widths returned.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getTextWidths(CharSequence text, int start, int end, float[] widths)",
    "returnType" : "int",
    "comment" : "\n     * Return the advance widths for the characters in the string.\n     *\n     * @param text     The text to measure. Cannot be null.\n     * @param start    The index of the first char to to measure\n     * @param end      The end of the text slice to measure\n     * @param widths   array to receive the advance widths of the characters.\n     *                 Must be at least a large as (end - start).\n     * @return         the actual number of widths returned.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getTextWidths(String text, int start, int end, float[] widths)",
    "returnType" : "int",
    "comment" : "\n     * Return the advance widths for the characters in the string.\n     *\n     * @param text   The text to measure. Cannot be null.\n     * @param start  The index of the first char to to measure\n     * @param end    The end of the text slice to measure\n     * @param widths array to receive the advance widths of the characters.\n     *               Must be at least a large as the text.\n     * @return       the number of code units in the specified text.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getTextWidths(String text, float[] widths)",
    "returnType" : "int",
    "comment" : "\n     * Return the advance widths for the characters in the string.\n     *\n     * @param text   The text to measure\n     * @param widths array to receive the advance widths of the characters.\n     *               Must be at least a large as the text.\n     * @return       the number of code units in the specified text.\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getTextRunAdvances(@NonNull char[] chars, @IntRange(from = 0) int index, @IntRange(from = 0) int count, @IntRange(from = 0) int contextIndex, @IntRange(from = 0) int contextCount, boolean isRtl, @Nullable float[] advances, @IntRange(from = 0) int advancesIndex)",
    "returnType" : "float",
    "comment" : "\n     * Retrieve the character advances of the text.\n     *\n     * Returns the total advance width for the characters in the run from {@code index} for\n     * {@code count} of chars, and if {@code advances} is not null, the advance assigned to each of\n     * these characters (java chars).\n     *\n     * <p>\n     * The trailing surrogate in a valid surrogate pair is assigned an advance of 0.  Thus the\n     * number of returned advances is always equal to count, not to the number of unicode codepoints\n     * represented by the run.\n     * </p>\n     *\n     * <p>\n     * In the case of conjuncts or combining marks, the total advance is assigned to the first\n     * logical character, and the following characters are assigned an advance of 0.\n     * </p>\n     *\n     * <p>\n     * This generates the sum of the advances of glyphs for characters in a reordered cluster as the\n     * width of the first logical character in the cluster, and 0 for the widths of all other\n     * characters in the cluster.  In effect, such clusters are treated like conjuncts.\n     * </p>\n     *\n     * <p>\n     * The shaping bounds limit the amount of context available outside start and end that can be\n     * used for shaping analysis.  These bounds typically reflect changes in bidi level or font\n     * metrics across which shaping does not occur.\n     * </p>\n     *\n     * @param chars the text to measure.\n     * @param index the index of the first character to measure\n     * @param count the number of characters to measure\n     * @param contextIndex the index of the first character to use for shaping context.\n     *                     Context must cover the measureing target.\n     * @param contextCount the number of character to use for shaping context.\n     *                     Context must cover the measureing target.\n     * @param isRtl whether the run is in RTL direction\n     * @param advances array to receive the advances, must have room for all advances.\n     *                 This can be null if only total advance is needed\n     * @param advancesIndex the position in advances at which to put the advance corresponding to\n     *                      the character at start\n     * @return the total advance in pixels\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getTextRunCursor(@NonNull char[] text, @IntRange(from = 0) int contextStart, @IntRange(from = 0) int contextLength, boolean isRtl, @IntRange(from = 0) int offset, @CursorOption int cursorOpt)",
    "returnType" : "int",
    "comment" : "\n     * Returns the next cursor position in the run.\n     *\n     * This avoids placing the cursor between surrogates, between characters that form conjuncts,\n     * between base characters and combining marks, or within a reordering cluster.\n     *\n     * <p>\n     * ContextStart and offset are relative to the start of text.\n     * The context is the shaping context for cursor movement, generally the bounds of the metric\n     * span enclosing the cursor in the direction of movement.\n     *\n     * <p>\n     * If cursorOpt is {@link #CURSOR_AT} and the offset is not a valid cursor position, this\n     * returns -1.  Otherwise this will never return a value before contextStart or after\n     * contextStart + contextLength.\n     *\n     * @param text the text\n     * @param contextStart the start of the context\n     * @param contextLength the length of the context\n     * @param isRtl true if the paragraph context is RTL, otherwise false\n     * @param offset the cursor position to move from\n     * @param cursorOpt how to move the cursor\n     * @return the offset of the next position, or -1\n     ",
    "links" : [ "#CURSOR_AT" ]
  }, {
    "name" : "public int getTextRunCursor(@NonNull CharSequence text, @IntRange(from = 0) int contextStart, @IntRange(from = 0) int contextEnd, boolean isRtl, @IntRange(from = 0) int offset, @CursorOption int cursorOpt)",
    "returnType" : "int",
    "comment" : "\n     * Returns the next cursor position in the run.\n     *\n     * This avoids placing the cursor between surrogates, between characters that form conjuncts,\n     * between base characters and combining marks, or within a reordering cluster.\n     *\n     * <p>\n     * ContextStart, contextEnd, and offset are relative to the start of\n     * text.  The context is the shaping context for cursor movement, generally\n     * the bounds of the metric span enclosing the cursor in the direction of\n     * movement.\n     *\n     * <p>\n     * If cursorOpt is {@link #CURSOR_AT} and the offset is not a valid cursor position, this\n     * returns -1.  Otherwise this will never return a value before contextStart or after\n     * contextEnd.\n     *\n     * @param text the text\n     * @param contextStart the start of the context\n     * @param contextEnd the end of the context\n     * @param isRtl true if the paragraph context is RTL, otherwise false\n     * @param offset the cursor position to move from\n     * @param cursorOpt how to move the cursor\n     * @return the offset of the next position, or -1\n     ",
    "links" : [ "#CURSOR_AT" ]
  }, {
    "name" : "public int getTextRunCursor(@NonNull String text, @IntRange(from = 0) int contextStart, @IntRange(from = 0) int contextEnd, boolean isRtl, @IntRange(from = 0) int offset, @CursorOption int cursorOpt)",
    "returnType" : "int",
    "comment" : "\n     * Returns the next cursor position in the run.\n     *\n     * This avoids placing the cursor between surrogates, between characters that form conjuncts,\n     * between base characters and combining marks, or within a reordering cluster.\n     *\n     * <p>\n     * ContextStart, contextEnd, and offset are relative to the start of text.  The context is the\n     * shaping context for cursor movement, generally the bounds of the metric span enclosing the\n     * cursor in the direction of movement.\n     * </p>\n     *\n     * <p>\n     * If cursorOpt is {@link #CURSOR_AT} and the offset is not a valid cursor position, this\n     * returns -1.  Otherwise this will never return a value before contextStart or after\n     * contextEnd.\n     * </p>\n     *\n     * @param text the text\n     * @param contextStart the start of the context\n     * @param contextEnd the end of the context\n     * @param isRtl true if the paragraph context is RTL, otherwise false.\n     * @param offset the cursor position to move from\n     * @param cursorOpt how to move the cursor\n     * @return the offset of the next position, or -1\n     * @hide\n     ",
    "links" : [ "#CURSOR_AT" ]
  }, {
    "name" : "public void getTextPath(char[] text, int index, int count, float x, float y, Path path)",
    "returnType" : "void",
    "comment" : "\n     * Return the path (outline) for the specified text.\n     * Note: just like Canvas.drawText, this will respect the Align setting in\n     * the paint.\n     *\n     * @param text the text to retrieve the path from\n     * @param index the index of the first character in text\n     * @param count the number of characters starting with index\n     * @param x the x coordinate of the text's origin\n     * @param y the y coordinate of the text's origin\n     * @param path the path to receive the data describing the text. Must be allocated by the caller\n     ",
    "links" : [ ]
  }, {
    "name" : "public void getTextPath(String text, int start, int end, float x, float y, Path path)",
    "returnType" : "void",
    "comment" : "\n     * Return the path (outline) for the specified text.\n     * Note: just like Canvas.drawText, this will respect the Align setting\n     * in the paint.\n     *\n     * @param text the text to retrieve the path from\n     * @param start the first character in the text\n     * @param end 1 past the last character in the text\n     * @param x the x coordinate of the text's origin\n     * @param y the y coordinate of the text's origin\n     * @param path the path to receive the data describing the text. Must be allocated by the caller\n     ",
    "links" : [ ]
  }, {
    "name" : "public void getTextBounds(String text, int start, int end, Rect bounds)",
    "returnType" : "void",
    "comment" : "\n     * Retrieve the text boundary box and store to bounds.\n     *\n     * Return in bounds (allocated by the caller) the smallest rectangle that\n     * encloses all of the characters, with an implied origin at (0,0).\n     *\n     * @param text string to measure and return its bounds\n     * @param start index of the first char in the string to measure\n     * @param end 1 past the last char in the string to measure\n     * @param bounds returns the unioned bounds of all the text. Must be allocated by the caller\n     ",
    "links" : [ ]
  }, {
    "name" : "public void getTextBounds(@NonNull CharSequence text, int start, int end, @NonNull Rect bounds)",
    "returnType" : "void",
    "comment" : "\n     * Retrieve the text boundary box and store to bounds.\n     *\n     * Return in bounds (allocated by the caller) the smallest rectangle that\n     * encloses all of the characters, with an implied origin at (0,0).\n     *\n     * Note that styles are ignored even if you pass {@link android.text.Spanned} instance.\n     * Use {@link android.text.StaticLayout} for measuring bounds of {@link android.text.Spanned}.\n     *\n     * @param text text to measure and return its bounds\n     * @param start index of the first char in the text to measure\n     * @param end 1 past the last char in the text to measure\n     * @param bounds returns the unioned bounds of all the text. Must be allocated by the caller\n     ",
    "links" : [ "android.text.Spanned", "android.text.StaticLayout", "android.text.Spanned" ]
  }, {
    "name" : "public void getTextBounds(char[] text, int index, int count, Rect bounds)",
    "returnType" : "void",
    "comment" : "\n     * Return in bounds (allocated by the caller) the smallest rectangle that\n     * encloses all of the characters, with an implied origin at (0,0).\n     *\n     * @param text  array of chars to measure and return their unioned bounds\n     * @param index index of the first char in the array to measure\n     * @param count the number of chars, beginning at index, to measure\n     * @param bounds returns the unioned bounds of all the text. Must be allocated by the caller\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasGlyph(String string)",
    "returnType" : "boolean",
    "comment" : "\n     * Determine whether the typeface set on the paint has a glyph supporting the string. The\n     * simplest case is when the string contains a single character, in which this method\n     * determines whether the font has the character. In the case of multiple characters, the\n     * method returns true if there is a single glyph representing the ligature. For example, if\n     * the input is a pair of regional indicator symbols, determine whether there is an emoji flag\n     * for the pair.\n     *\n     * <p>Finally, if the string contains a variation selector, the method only returns true if\n     * the fonts contains a glyph specific to that variation.\n     *\n     * <p>Checking is done on the entire fallback chain, not just the immediate font referenced.\n     *\n     * @param string the string to test whether there is glyph support\n     * @return true if the typeface has a glyph for the string\n     ",
    "links" : [ ]
  }, {
    "name" : "public float getRunAdvance(char[] text, int start, int end, int contextStart, int contextEnd, boolean isRtl, int offset)",
    "returnType" : "float",
    "comment" : "\n     * Measure cursor position within a run of text.\n     *\n     * <p>The run of text includes the characters from {@code start} to {@code end} in the text. In\n     * addition, the range {@code contextStart} to {@code contextEnd} is used as context for the\n     * purpose of complex text shaping, such as Arabic text potentially shaped differently based on\n     * the text next to it.\n     *\n     * <p>All text outside the range {@code contextStart..contextEnd} is ignored. The text between\n     * {@code start} and {@code end} will be laid out to be measured.\n     *\n     * <p>The returned width measurement is the advance from {@code start} to {@code offset}. It is\n     * generally a positive value, no matter the direction of the run. If {@code offset == end},\n     * the return value is simply the width of the whole run from {@code start} to {@code end}.\n     *\n     * <p>Ligatures are formed for characters in the range {@code start..end} (but not for\n     * {@code start..contextStart} or {@code end..contextEnd}). If {@code offset} points to a\n     * character in the middle of such a formed ligature, but at a grapheme cluster boundary, the\n     * return value will also reflect an advance in the middle of the ligature. See\n     * {@link #getOffsetForAdvance} for more discussion of grapheme cluster boundaries.\n     *\n     * <p>The direction of the run is explicitly specified by {@code isRtl}. Thus, this method is\n     * suitable only for runs of a single direction.\n     *\n     * <p>All indices are relative to the start of {@code text}. Further, {@code 0 <= contextStart\n     * <= start <= offset <= end <= contextEnd <= text.length} must hold on entry.\n     *\n     * @param text the text to measure. Cannot be null.\n     * @param start the index of the start of the range to measure\n     * @param end the index + 1 of the end of the range to measure\n     * @param contextStart the index of the start of the shaping context\n     * @param contextEnd the index + 1 of the end of the shaping context\n     * @param isRtl whether the run is in RTL direction\n     * @param offset index of caret position\n     * @return width measurement between start and offset\n     ",
    "links" : [ "#getOffsetForAdvance" ]
  }, {
    "name" : "public float getRunAdvance(CharSequence text, int start, int end, int contextStart, int contextEnd, boolean isRtl, int offset)",
    "returnType" : "float",
    "comment" : "\n     * @see #getRunAdvance(char[], int, int, int, int, boolean, int)\n     *\n     * @param text the text to measure. Cannot be null.\n     * @param start the index of the start of the range to measure\n     * @param end the index + 1 of the end of the range to measure\n     * @param contextStart the index of the start of the shaping context\n     * @param contextEnd the index + 1 of the end of the shaping context\n     * @param isRtl whether the run is in RTL direction\n     * @param offset index of caret position\n     * @return width measurement between start and offset\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getOffsetForAdvance(char[] text, int start, int end, int contextStart, int contextEnd, boolean isRtl, float advance)",
    "returnType" : "int",
    "comment" : "\n     * Get the character offset within the string whose position is closest to the specified\n     * horizontal position.\n     *\n     * <p>The returned value is generally the value of {@code offset} for which\n     * {@link #getRunAdvance} yields a result most closely approximating {@code advance},\n     * and which is also on a grapheme cluster boundary. As such, it is the preferred method\n     * for positioning a cursor in response to a touch or pointer event. The grapheme cluster\n     * boundaries are based on\n     * <a href=\"http://unicode.org/reports/tr29/\">Unicode Standard Annex #29</a> but with some\n     * tailoring for better user experience.\n     *\n     * <p>Note that {@code advance} is a (generally positive) width measurement relative to the start\n     * of the run. Thus, for RTL runs it the distance from the point to the right edge.\n     *\n     * <p>All indices are relative to the start of {@code text}. Further, {@code 0 <= contextStart\n     * <= start <= end <= contextEnd <= text.length} must hold on entry, and {@code start <= result\n     * <= end} will hold on return.\n     *\n     * @param text the text to measure. Cannot be null.\n     * @param start the index of the start of the range to measure\n     * @param end the index + 1 of the end of the range to measure\n     * @param contextStart the index of the start of the shaping context\n     * @param contextEnd the index + 1 of the end of the range to measure\n     * @param isRtl whether the run is in RTL direction\n     * @param advance width relative to start of run\n     * @return index of offset\n     ",
    "links" : [ "#getRunAdvance" ]
  }, {
    "name" : "public int getOffsetForAdvance(CharSequence text, int start, int end, int contextStart, int contextEnd, boolean isRtl, float advance)",
    "returnType" : "int",
    "comment" : "\n     * @see #getOffsetForAdvance(char[], int, int, int, int, boolean, float)\n     *\n     * @param text the text to measure. Cannot be null.\n     * @param start the index of the start of the range to measure\n     * @param end the index + 1 of the end of the range to measure\n     * @param contextStart the index of the start of the shaping context\n     * @param contextEnd the index + 1 of the end of the range to measure\n     * @param isRtl whether the run is in RTL direction\n     * @param advance width relative to start of run\n     * @return index of offset\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean equalsForTextMeasurement(@NonNull Paint other)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true of the passed {@link Paint} will have the same effect on text measurement\n     *\n     * @param other A {@link Paint} object.\n     * @return true if the other {@link Paint} has the same effect on text measurement.\n     ",
    "links" : [ "Paint", "Paint", "Paint" ]
  }, {
    "name" : "private static native long nGetNativeFinalizer()",
    "returnType" : "long",
    "comment" : " regular JNI",
    "links" : [ ]
  }, {
    "name" : "private static native long nInit()",
    "returnType" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native long nInitWithPaint(long paint)",
    "returnType" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native int nBreakText(long nObject, char[] text, int index, int count, float maxWidth, int bidiFlags, float[] measuredWidth)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native int nBreakText(long nObject, String text, boolean measureForwards, float maxWidth, int bidiFlags, float[] measuredWidth)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native float nGetTextAdvances(long paintPtr, char[] text, int index, int count, int contextIndex, int contextCount, int bidiFlags, float[] advances, int advancesIndex)",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native float nGetTextAdvances(long paintPtr, String text, int start, int end, int contextStart, int contextEnd, int bidiFlags, float[] advances, int advancesIndex)",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int nGetTextRunCursor(long paintPtr, char[] text, int contextStart, int contextLength, int dir, int offset, int cursorOpt)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private native int nGetTextRunCursor(long paintPtr, String text, int contextStart, int contextEnd, int dir, int offset, int cursorOpt)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nGetTextPath(long paintPtr, int bidiFlags, char[] text, int index, int count, float x, float y, long path)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nGetTextPath(long paintPtr, int bidiFlags, String text, int start, int end, float x, float y, long path)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nGetStringBounds(long nativePaint, String text, int start, int end, int bidiFlags, Rect bounds)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nGetCharArrayBounds(long nativePaint, char[] text, int index, int count, int bidiFlags, Rect bounds)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native boolean nHasGlyph(long paintPtr, int bidiFlags, String string)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native float nGetRunAdvance(long paintPtr, char[] text, int start, int end, int contextStart, int contextEnd, boolean isRtl, int offset)",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native int nGetOffsetForAdvance(long paintPtr, char[] text, int start, int end, int contextStart, int contextEnd, boolean isRtl, float advance)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native int nSetTextLocales(long paintPtr, String locales)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetFontFeatureSettings(long paintPtr, String settings)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native float nGetFontMetrics(long paintPtr, FontMetrics metrics)",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native int nGetFontMetricsInt(long paintPtr, FontMetricsInt fmi)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nReset(long paintPtr)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSet(long paintPtrDest, long paintPtrSrc)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native int nGetStyle(long paintPtr)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetStyle(long paintPtr, int style)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native int nGetStrokeCap(long paintPtr)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetStrokeCap(long paintPtr, int cap)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native int nGetStrokeJoin(long paintPtr)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetStrokeJoin(long paintPtr, int join)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native boolean nGetFillPath(long paintPtr, long src, long dst)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native long nSetShader(long paintPtr, long shader)",
    "returnType" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native long nSetColorFilter(long paintPtr, long filter)",
    "returnType" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetXfermode(long paintPtr, int xfermode)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native long nSetPathEffect(long paintPtr, long effect)",
    "returnType" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native long nSetMaskFilter(long paintPtr, long maskfilter)",
    "returnType" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetTypeface(long paintPtr, long typeface)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native int nGetTextAlign(long paintPtr)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetTextAlign(long paintPtr, int align)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetTextLocalesByMinikinLocaleListId(long paintPtr, int mMinikinLocaleListId)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetShadowLayer(long paintPtr, float radius, float dx, float dy, long colorSpaceHandle, @ColorLong long shadowColor)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native boolean nHasShadowLayer(long paintPtr)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native float nGetLetterSpacing(long paintPtr)",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetLetterSpacing(long paintPtr, float letterSpacing)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native float nGetWordSpacing(long paintPtr)",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetWordSpacing(long paintPtr, float wordSpacing)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native int nGetStartHyphenEdit(long paintPtr)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native int nGetEndHyphenEdit(long paintPtr)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetStartHyphenEdit(long paintPtr, int hyphen)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetEndHyphenEdit(long paintPtr, int hyphen)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetStrokeMiter(long paintPtr, float miter)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native float nGetStrokeMiter(long paintPtr)",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetStrokeWidth(long paintPtr, float width)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native float nGetStrokeWidth(long paintPtr)",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetAlpha(long paintPtr, int a)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetDither(long paintPtr, boolean dither)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native int nGetFlags(long paintPtr)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetFlags(long paintPtr, int flags)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native int nGetHinting(long paintPtr)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetHinting(long paintPtr, int mode)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetAntiAlias(long paintPtr, boolean aa)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetLinearText(long paintPtr, boolean linearText)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetSubpixelText(long paintPtr, boolean subpixelText)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetUnderlineText(long paintPtr, boolean underlineText)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetFakeBoldText(long paintPtr, boolean fakeBoldText)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetFilterBitmap(long paintPtr, boolean filter)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetColor(long paintPtr, long colorSpaceHandle, @ColorLong long color)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetColor(long paintPtr, @ColorInt int color)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetStrikeThruText(long paintPtr, boolean strikeThruText)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native boolean nIsElegantTextHeight(long paintPtr)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetElegantTextHeight(long paintPtr, boolean elegant)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native float nGetTextSize(long paintPtr)",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native float nGetTextScaleX(long paintPtr)",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetTextScaleX(long paintPtr, float scaleX)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native float nGetTextSkewX(long paintPtr)",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetTextSkewX(long paintPtr, float skewX)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native float nAscent(long paintPtr)",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native float nDescent(long paintPtr)",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native float nGetUnderlinePosition(long paintPtr)",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native float nGetUnderlineThickness(long paintPtr)",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native float nGetStrikeThruPosition(long paintPtr)",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native float nGetStrikeThruThickness(long paintPtr)",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nSetTextSize(long paintPtr, float textSize)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native boolean nEqualsForTextMeasurement(long leftPaintPtr, long rightPaintPtr)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  } ],
  "variableNames" : [ "mNativePaint", "mNativeShader", "mNativeColorFilter", "mColor", "mColorFilter", "mMaskFilter", "mPathEffect", "mShader", "mTypeface", "mXfermode", "mHasCompatScaling", "mCompatScaling", "mInvCompatScaling", "mLocales", "mFontFeatureSettings", "mFontVariationSettings", "mShadowLayerRadius", "mShadowLayerDx", "mShadowLayerDy", "mShadowLayerColor", "sCacheLock", "sMinikinLocaleListIdCache", "mBidiFlags", "sStyleArray", "sCapArray", "sJoinArray", "sAlignArray", "ANTI_ALIAS_FLAG", "FILTER_BITMAP_FLAG", "DITHER_FLAG", "UNDERLINE_TEXT_FLAG", "STRIKE_THRU_TEXT_FLAG", "FAKE_BOLD_TEXT_FLAG", "LINEAR_TEXT_FLAG", "SUBPIXEL_TEXT_FLAG", "DEV_KERN_TEXT_FLAG", "LCD_RENDER_TEXT_FLAG", "EMBEDDED_BITMAP_TEXT_FLAG", "AUTO_HINTING_TEXT_FLAG", "VERTICAL_TEXT_FLAG", "HIDDEN_DEFAULT_PAINT_FLAGS", "HINTING_OFF", "HINTING_ON", "BIDI_LTR", "BIDI_RTL", "BIDI_DEFAULT_LTR", "BIDI_DEFAULT_RTL", "BIDI_FORCE_LTR", "BIDI_FORCE_RTL", "BIDI_MAX_FLAG_VALUE", "BIDI_FLAG_MASK", "DIRECTION_LTR", "DIRECTION_RTL", "CURSOR_AFTER", "CURSOR_AT_OR_AFTER", "CURSOR_BEFORE", "CURSOR_AT_OR_BEFORE", "CURSOR_AT", "CURSOR_OPT_MAX_VALUE", "START_HYPHEN_EDIT_NO_EDIT", "START_HYPHEN_EDIT_INSERT_HYPHEN", "START_HYPHEN_EDIT_INSERT_ZWJ", "END_HYPHEN_EDIT_NO_EDIT", "END_HYPHEN_EDIT_REPLACE_WITH_HYPHEN", "END_HYPHEN_EDIT_INSERT_HYPHEN", "END_HYPHEN_EDIT_INSERT_ARMENIAN_HYPHEN", "END_HYPHEN_EDIT_INSERT_MAQAF", "END_HYPHEN_EDIT_INSERT_UCAS_HYPHEN", "END_HYPHEN_EDIT_INSERT_ZWJ_AND_HYPHEN" ],
  "methodNames" : [ "public void reset()", "public void set(Paint src)", "private void setClassVariablesFrom(Paint paint)", "public void setCompatibilityScaling(float factor)", "public long getNativeInstance()", "public int getBidiFlags()", "public void setBidiFlags(int flags)", "public int getFlags()", "public void setFlags(int flags)", "public int getHinting()", "public void setHinting(int mode)", "public final boolean isAntiAlias()", "public void setAntiAlias(boolean aa)", "public final boolean isDither()", "public void setDither(boolean dither)", "public final boolean isLinearText()", "public void setLinearText(boolean linearText)", "public final boolean isSubpixelText()", "public void setSubpixelText(boolean subpixelText)", "public final boolean isUnderlineText()", "public float getUnderlinePosition()", "public float getUnderlineThickness()", "public void setUnderlineText(boolean underlineText)", "public final boolean isStrikeThruText()", "public float getStrikeThruPosition()", "public float getStrikeThruThickness()", "public void setStrikeThruText(boolean strikeThruText)", "public final boolean isFakeBoldText()", "public void setFakeBoldText(boolean fakeBoldText)", "public final boolean isFilterBitmap()", "public void setFilterBitmap(boolean filter)", "public Style getStyle()", "public void setStyle(Style style)", "public int getColor()", "public long getColorLong()", "public void setColor(@ColorInt int color)", "public void setColor(@ColorLong long color)", "public int getAlpha()", "public void setAlpha(int a)", "public void setARGB(int a, int r, int g, int b)", "public float getStrokeWidth()", "public void setStrokeWidth(float width)", "public float getStrokeMiter()", "public void setStrokeMiter(float miter)", "public Cap getStrokeCap()", "public void setStrokeCap(Cap cap)", "public Join getStrokeJoin()", "public void setStrokeJoin(Join join)", "public boolean getFillPath(Path src, Path dst)", "public Shader getShader()", "public Shader setShader(Shader shader)", "public ColorFilter getColorFilter()", "public ColorFilter setColorFilter(ColorFilter filter)", "public Xfermode getXfermode()", "public BlendMode getBlendMode()", "public Xfermode setXfermode(Xfermode xfermode)", "private Xfermode installXfermode(Xfermode xfermode)", "public void setBlendMode(@Nullable BlendMode blendmode)", "public PathEffect getPathEffect()", "public PathEffect setPathEffect(PathEffect effect)", "public MaskFilter getMaskFilter()", "public MaskFilter setMaskFilter(MaskFilter maskfilter)", "public Typeface getTypeface()", "public Typeface setTypeface(Typeface typeface)", "public Rasterizer getRasterizer()", "public Rasterizer setRasterizer(Rasterizer rasterizer)", "public void setShadowLayer(float radius, float dx, float dy, @ColorInt int shadowColor)", "public void setShadowLayer(float radius, float dx, float dy, @ColorLong long shadowColor)", "public void clearShadowLayer()", "public boolean hasShadowLayer()", "public float getShadowLayerRadius()", "public float getShadowLayerDx()", "public float getShadowLayerDy()", "public int getShadowLayerColor()", "public long getShadowLayerColorLong()", "public Align getTextAlign()", "public void setTextAlign(Align align)", "public Locale getTextLocale()", "public LocaleList getTextLocales()", "public void setTextLocale(@NonNull Locale locale)", "public void setTextLocales(@NonNull @Size(min = 1) LocaleList locales)", "private void syncTextLocalesWithMinikin()", "public boolean isElegantTextHeight()", "public void setElegantTextHeight(boolean elegant)", "public float getTextSize()", "public void setTextSize(float textSize)", "public float getTextScaleX()", "public void setTextScaleX(float scaleX)", "public float getTextSkewX()", "public void setTextSkewX(float skewX)", "public float getLetterSpacing()", "public void setLetterSpacing(float letterSpacing)", "public float getWordSpacing()", "public void setWordSpacing(@Px float wordSpacing)", "public String getFontFeatureSettings()", "public void setFontFeatureSettings(String settings)", "public String getFontVariationSettings()", "public boolean setFontVariationSettings(String fontVariationSettings)", "public int getStartHyphenEdit()", "public int getEndHyphenEdit()", "public void setStartHyphenEdit(@StartHyphenEdit int startHyphen)", "public void setEndHyphenEdit(@EndHyphenEdit int endHyphen)", "public float ascent()", "public float descent()", "public float getFontMetrics(FontMetrics metrics)", "public FontMetrics getFontMetrics()", "public int getFontMetricsInt(FontMetricsInt fmi)", "public FontMetricsInt getFontMetricsInt()", "public float getFontSpacing()", "public float measureText(char[] text, int index, int count)", "public float measureText(String text, int start, int end)", "public float measureText(String text)", "public float measureText(CharSequence text, int start, int end)", "public int breakText(char[] text, int index, int count, float maxWidth, float[] measuredWidth)", "public int breakText(CharSequence text, int start, int end, boolean measureForwards, float maxWidth, float[] measuredWidth)", "public int breakText(String text, boolean measureForwards, float maxWidth, float[] measuredWidth)", "public int getTextWidths(char[] text, int index, int count, float[] widths)", "public int getTextWidths(CharSequence text, int start, int end, float[] widths)", "public int getTextWidths(String text, int start, int end, float[] widths)", "public int getTextWidths(String text, float[] widths)", "public float getTextRunAdvances(@NonNull char[] chars, @IntRange(from = 0) int index, @IntRange(from = 0) int count, @IntRange(from = 0) int contextIndex, @IntRange(from = 0) int contextCount, boolean isRtl, @Nullable float[] advances, @IntRange(from = 0) int advancesIndex)", "public int getTextRunCursor(@NonNull char[] text, @IntRange(from = 0) int contextStart, @IntRange(from = 0) int contextLength, boolean isRtl, @IntRange(from = 0) int offset, @CursorOption int cursorOpt)", "public int getTextRunCursor(@NonNull CharSequence text, @IntRange(from = 0) int contextStart, @IntRange(from = 0) int contextEnd, boolean isRtl, @IntRange(from = 0) int offset, @CursorOption int cursorOpt)", "public int getTextRunCursor(@NonNull String text, @IntRange(from = 0) int contextStart, @IntRange(from = 0) int contextEnd, boolean isRtl, @IntRange(from = 0) int offset, @CursorOption int cursorOpt)", "public void getTextPath(char[] text, int index, int count, float x, float y, Path path)", "public void getTextPath(String text, int start, int end, float x, float y, Path path)", "public void getTextBounds(String text, int start, int end, Rect bounds)", "public void getTextBounds(@NonNull CharSequence text, int start, int end, @NonNull Rect bounds)", "public void getTextBounds(char[] text, int index, int count, Rect bounds)", "public boolean hasGlyph(String string)", "public float getRunAdvance(char[] text, int start, int end, int contextStart, int contextEnd, boolean isRtl, int offset)", "public float getRunAdvance(CharSequence text, int start, int end, int contextStart, int contextEnd, boolean isRtl, int offset)", "public int getOffsetForAdvance(char[] text, int start, int end, int contextStart, int contextEnd, boolean isRtl, float advance)", "public int getOffsetForAdvance(CharSequence text, int start, int end, int contextStart, int contextEnd, boolean isRtl, float advance)", "public boolean equalsForTextMeasurement(@NonNull Paint other)", "private static native long nGetNativeFinalizer()", "private static native long nInit()", "private static native long nInitWithPaint(long paint)", "private static native int nBreakText(long nObject, char[] text, int index, int count, float maxWidth, int bidiFlags, float[] measuredWidth)", "private static native int nBreakText(long nObject, String text, boolean measureForwards, float maxWidth, int bidiFlags, float[] measuredWidth)", "private static native float nGetTextAdvances(long paintPtr, char[] text, int index, int count, int contextIndex, int contextCount, int bidiFlags, float[] advances, int advancesIndex)", "private static native float nGetTextAdvances(long paintPtr, String text, int start, int end, int contextStart, int contextEnd, int bidiFlags, float[] advances, int advancesIndex)", "private native int nGetTextRunCursor(long paintPtr, char[] text, int contextStart, int contextLength, int dir, int offset, int cursorOpt)", "private native int nGetTextRunCursor(long paintPtr, String text, int contextStart, int contextEnd, int dir, int offset, int cursorOpt)", "private static native void nGetTextPath(long paintPtr, int bidiFlags, char[] text, int index, int count, float x, float y, long path)", "private static native void nGetTextPath(long paintPtr, int bidiFlags, String text, int start, int end, float x, float y, long path)", "private static native void nGetStringBounds(long nativePaint, String text, int start, int end, int bidiFlags, Rect bounds)", "private static native void nGetCharArrayBounds(long nativePaint, char[] text, int index, int count, int bidiFlags, Rect bounds)", "private static native boolean nHasGlyph(long paintPtr, int bidiFlags, String string)", "private static native float nGetRunAdvance(long paintPtr, char[] text, int start, int end, int contextStart, int contextEnd, boolean isRtl, int offset)", "private static native int nGetOffsetForAdvance(long paintPtr, char[] text, int start, int end, int contextStart, int contextEnd, boolean isRtl, float advance)", "private static native int nSetTextLocales(long paintPtr, String locales)", "private static native void nSetFontFeatureSettings(long paintPtr, String settings)", "private static native float nGetFontMetrics(long paintPtr, FontMetrics metrics)", "private static native int nGetFontMetricsInt(long paintPtr, FontMetricsInt fmi)", "private static native void nReset(long paintPtr)", "private static native void nSet(long paintPtrDest, long paintPtrSrc)", "private static native int nGetStyle(long paintPtr)", "private static native void nSetStyle(long paintPtr, int style)", "private static native int nGetStrokeCap(long paintPtr)", "private static native void nSetStrokeCap(long paintPtr, int cap)", "private static native int nGetStrokeJoin(long paintPtr)", "private static native void nSetStrokeJoin(long paintPtr, int join)", "private static native boolean nGetFillPath(long paintPtr, long src, long dst)", "private static native long nSetShader(long paintPtr, long shader)", "private static native long nSetColorFilter(long paintPtr, long filter)", "private static native void nSetXfermode(long paintPtr, int xfermode)", "private static native long nSetPathEffect(long paintPtr, long effect)", "private static native long nSetMaskFilter(long paintPtr, long maskfilter)", "private static native void nSetTypeface(long paintPtr, long typeface)", "private static native int nGetTextAlign(long paintPtr)", "private static native void nSetTextAlign(long paintPtr, int align)", "private static native void nSetTextLocalesByMinikinLocaleListId(long paintPtr, int mMinikinLocaleListId)", "private static native void nSetShadowLayer(long paintPtr, float radius, float dx, float dy, long colorSpaceHandle, @ColorLong long shadowColor)", "private static native boolean nHasShadowLayer(long paintPtr)", "private static native float nGetLetterSpacing(long paintPtr)", "private static native void nSetLetterSpacing(long paintPtr, float letterSpacing)", "private static native float nGetWordSpacing(long paintPtr)", "private static native void nSetWordSpacing(long paintPtr, float wordSpacing)", "private static native int nGetStartHyphenEdit(long paintPtr)", "private static native int nGetEndHyphenEdit(long paintPtr)", "private static native void nSetStartHyphenEdit(long paintPtr, int hyphen)", "private static native void nSetEndHyphenEdit(long paintPtr, int hyphen)", "private static native void nSetStrokeMiter(long paintPtr, float miter)", "private static native float nGetStrokeMiter(long paintPtr)", "private static native void nSetStrokeWidth(long paintPtr, float width)", "private static native float nGetStrokeWidth(long paintPtr)", "private static native void nSetAlpha(long paintPtr, int a)", "private static native void nSetDither(long paintPtr, boolean dither)", "private static native int nGetFlags(long paintPtr)", "private static native void nSetFlags(long paintPtr, int flags)", "private static native int nGetHinting(long paintPtr)", "private static native void nSetHinting(long paintPtr, int mode)", "private static native void nSetAntiAlias(long paintPtr, boolean aa)", "private static native void nSetLinearText(long paintPtr, boolean linearText)", "private static native void nSetSubpixelText(long paintPtr, boolean subpixelText)", "private static native void nSetUnderlineText(long paintPtr, boolean underlineText)", "private static native void nSetFakeBoldText(long paintPtr, boolean fakeBoldText)", "private static native void nSetFilterBitmap(long paintPtr, boolean filter)", "private static native void nSetColor(long paintPtr, long colorSpaceHandle, @ColorLong long color)", "private static native void nSetColor(long paintPtr, @ColorInt int color)", "private static native void nSetStrikeThruText(long paintPtr, boolean strikeThruText)", "private static native boolean nIsElegantTextHeight(long paintPtr)", "private static native void nSetElegantTextHeight(long paintPtr, boolean elegant)", "private static native float nGetTextSize(long paintPtr)", "private static native float nGetTextScaleX(long paintPtr)", "private static native void nSetTextScaleX(long paintPtr, float scaleX)", "private static native float nGetTextSkewX(long paintPtr)", "private static native void nSetTextSkewX(long paintPtr, float skewX)", "private static native float nAscent(long paintPtr)", "private static native float nDescent(long paintPtr)", "private static native float nGetUnderlinePosition(long paintPtr)", "private static native float nGetUnderlineThickness(long paintPtr)", "private static native float nGetStrikeThruPosition(long paintPtr)", "private static native float nGetStrikeThruThickness(long paintPtr)", "private static native void nSetTextSize(long paintPtr, float textSize)", "private static native boolean nEqualsForTextMeasurement(long leftPaintPtr, long rightPaintPtr)" ]
}