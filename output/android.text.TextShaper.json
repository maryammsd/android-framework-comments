{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/text/TextShaper.java",
  "packageName" : "android.text",
  "className" : "TextShaper",
  "comment" : "\n * Provides text shaping for multi-styled text.\n *\n * Here is an example of animating text size and letter spacing for simple text.\n * <pre>\n * <code>\n * // In this example, shape the text once for start and end state, then animate between two shape\n * // result without re-shaping in each frame.\n * class SimpleAnimationView @JvmOverloads constructor(\n *         context: Context,\n *         attrs: AttributeSet? = null,\n *         defStyleAttr: Int = 0\n * ) : View(context, attrs, defStyleAttr) {\n *     private val textDir = TextDirectionHeuristics.LOCALE\n *     private val text = \"Hello, World.\"  // The text to be displayed\n *\n *     // Class for keeping drawing parameters.\n *     data class DrawStyle(val textSize: Float, val alpha: Int)\n *\n *     // The start and end text shaping result. This class will animate between these two.\n *     private val start = mutableListOf&lt;Pair&lt;PositionedGlyphs, DrawStyle&gt;&gt;()\n *     private val end = mutableListOf&lt;Pair&lt;PositionedGlyphs, DrawStyle&gt;&gt;()\n *\n *     init {\n *         val startPaint = TextPaint().apply {\n *             alpha = 0 // Alpha only affect text drawing but not text shaping\n *             textSize = 36f // TextSize affect both text shaping and drawing.\n *             letterSpacing = 0f // Letter spacing only affect text shaping but not drawing.\n *         }\n *\n *         val endPaint = TextPaint().apply {\n *             alpha = 255\n *             textSize =128f\n *             letterSpacing = 0.1f\n *         }\n *\n *         TextShaper.shapeText(text, 0, text.length, textDir, startPaint) { _, _, glyphs, paint ->\n *             start.add(Pair(glyphs, DrawStyle(paint.textSize, paint.alpha)))\n *         }\n *         TextShaper.shapeText(text, 0, text.length, textDir, endPaint) { _, _, glyphs, paint ->\n *             end.add(Pair(glyphs, DrawStyle(paint.textSize, paint.alpha)))\n *         }\n *     }\n *\n *     override fun onDraw(canvas: Canvas) {\n *         super.onDraw(canvas)\n *\n *         // Set the baseline to the vertical center of the view.\n *         canvas.translate(0f, height / 2f)\n *\n *         // Assume the number of PositionedGlyphs are the same. If different, you may want to\n *         // animate in a different way, e.g. cross fading.\n *         start.zip(end) { (startGlyphs, startDrawStyle), (endGlyphs, endDrawStyle) ->\n *             // Tween the style and set to paint.\n *             paint.textSize = lerp(startDrawStyle.textSize, endDrawStyle.textSize, progress)\n *             paint.alpha = lerp(startDrawStyle.alpha, endDrawStyle.alpha, progress)\n *\n *             // Assume the number of glyphs are the same. If different, you may want to animate in\n *             // a different way, e.g. cross fading.\n *             require(startGlyphs.glyphCount() == endGlyphs.glyphCount())\n *\n *             if (startGlyphs.glyphCount() == 0) return@zip\n *\n *             var curFont = startGlyphs.getFont(0)\n *             var drawStart = 0\n *             for (i in 1 until startGlyphs.glyphCount()) {\n *                 // Assume the pair of Glyph ID and font is the same. If different, you may want\n *                 // to animate in a different way, e.g. cross fading.\n *                 require(startGlyphs.getGlyphId(i) == endGlyphs.getGlyphId(i))\n *                 require(startGlyphs.getFont(i) === endGlyphs.getFont(i))\n *\n *                 val font = startGlyphs.getFont(i)\n *                 if (curFont != font) {\n *                     drawGlyphs(canvas, startGlyphs, endGlyphs, drawStart, i, curFont, paint)\n *                     curFont = font\n *                     drawStart = i\n *                 }\n *             }\n *             if (drawStart != startGlyphs.glyphCount() - 1) {\n *                 drawGlyphs(canvas, startGlyphs, endGlyphs, drawStart, startGlyphs.glyphCount(),\n *                         curFont, paint)\n *             }\n *         }\n *     }\n *\n *     // Draws Glyphs for the same font run.\n *     private fun drawGlyphs(canvas: Canvas, startGlyph: PositionedGlyphs,\n *                            endGlyph: PositionedGlyphs, start: Int, end: Int, font: Font,\n *                            paint: Paint) {\n *         var cacheIndex = 0\n *         for (i in start until end) {\n *             intArrayCache[cacheIndex] = startGlyph.getGlyphId(i)\n *             // The glyph positions are different from start to end since they are shaped\n *             // with different letter spacing. Use linear interpolation for positions\n *             // during animation.\n *             floatArrayCache[cacheIndex * 2] =\n *                     lerp(startGlyph.getGlyphX(i), endGlyph.getGlyphX(i), progress)\n *             floatArrayCache[cacheIndex * 2 + 1] =\n *                     lerp(startGlyph.getGlyphY(i), endGlyph.getGlyphY(i), progress)\n *             if (cacheIndex == CACHE_SIZE) {  // Cached int array is full. Flashing.\n *                 canvas.drawGlyphs(\n *                         intArrayCache, 0, // glyphID array and its starting offset\n *                         floatArrayCache, 0, // position array and its starting offset\n *                         cacheIndex, // glyph count\n *                         font,\n *                         paint\n *                 )\n *                 cacheIndex = 0\n *             }\n *             cacheIndex++\n *         }\n *         if (cacheIndex != 0) {\n *             canvas.drawGlyphs(\n *                     intArrayCache, 0, // glyphID array and its starting offset\n *                     floatArrayCache, 0, // position array and its starting offset\n *                     cacheIndex, // glyph count\n *                     font,\n *                     paint\n *             )\n *         }\n *     }\n *\n *     // Linear Interpolator\n *     private fun lerp(start: Float, end: Float, t: Float) = start * (1f - t) + end * t\n *     private fun lerp(start: Int, end: Int, t: Float) = (start * (1f - t) + end * t).toInt()\n *\n *     // The animation progress.\n *     var progress: Float = 0f\n *         set(value) {\n *             field = value\n *             invalidate()\n *         }\n *\n *     // working copy of paint.\n *     private val paint = Paint()\n *\n *     // Array cache for reducing allocation during drawing.\n *     private var intArrayCache = IntArray(CACHE_SIZE)\n *     private var floatArrayCache = FloatArray(CACHE_SIZE * 2)\n * }\n * </code>\n * </pre>\n * @see TextRunShaper#shapeTextRun(char[], int, int, int, int, float, float, boolean, Paint)\n * @see TextRunShaper#shapeTextRun(CharSequence, int, int, int, int, float, float, boolean, Paint)\n * @see TextShaper#shapeText(CharSequence, int, int, TextDirectionHeuristic, TextPaint,\n * GlyphsConsumer)\n ",
  "links" : [ ],
  "variables" : [ ],
  "methods" : [ {
    "name" : "public static void shapeText(@NonNull CharSequence text, @IntRange(from = 0) int start, @IntRange(from = 0) int count, @NonNull TextDirectionHeuristic dir, @NonNull TextPaint paint, @NonNull GlyphsConsumer consumer)",
    "returnType" : "void",
    "comment" : "\n     * Shape multi-styled text.\n     *\n     * In the LTR context, the shape result will go from left to right, thus you may want to draw\n     * glyphs from left most position of the canvas. In the RTL context, the shape result will go\n     * from right to left, thus you may want to draw glyphs from right most position of the canvas.\n     *\n     * @param text a styled text.\n     * @param start a start index of shaping target in the text.\n     * @param count a length of shaping target in the text.\n     * @param dir a text direction.\n     * @param paint a paint\n     * @param consumer a consumer of the shape result.\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public static void shapeText(@NonNull CharSequence text, @IntRange(from = 0) int start, @IntRange(from = 0) int count, @NonNull TextDirectionHeuristic dir, @NonNull TextPaint paint, @NonNull GlyphsConsumer consumer)" ],
  "variableNames" : [ ]
}