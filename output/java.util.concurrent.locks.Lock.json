{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/util/concurrent/locks/Lock.java",
  "packageName" : "java.util.concurrent.locks",
  "className" : "Lock",
  "comment" : "\n * {@code Lock} implementations provide more extensive locking\n * operations than can be obtained using {@code synchronized} methods\n * and statements.  They allow more flexible structuring, may have\n * quite different properties, and may support multiple associated\n * {@link Condition} objects.\n *\n * <p>A lock is a tool for controlling access to a shared resource by\n * multiple threads. Commonly, a lock provides exclusive access to a\n * shared resource: only one thread at a time can acquire the lock and\n * all access to the shared resource requires that the lock be\n * acquired first. However, some locks may allow concurrent access to\n * a shared resource, such as the read lock of a {@link ReadWriteLock}.\n *\n * <p>The use of {@code synchronized} methods or statements provides\n * access to the implicit monitor lock associated with every object, but\n * forces all lock acquisition and release to occur in a block-structured way:\n * when multiple locks are acquired they must be released in the opposite\n * order, and all locks must be released in the same lexical scope in which\n * they were acquired.\n *\n * <p>While the scoping mechanism for {@code synchronized} methods\n * and statements makes it much easier to program with monitor locks,\n * and helps avoid many common programming errors involving locks,\n * there are occasions where you need to work with locks in a more\n * flexible way. For example, some algorithms for traversing\n * concurrently accessed data structures require the use of\n * &quot;hand-over-hand&quot; or &quot;chain locking&quot;: you\n * acquire the lock of node A, then node B, then release A and acquire\n * C, then release B and acquire D and so on.  Implementations of the\n * {@code Lock} interface enable the use of such techniques by\n * allowing a lock to be acquired and released in different scopes,\n * and allowing multiple locks to be acquired and released in any\n * order.\n *\n * <p>With this increased flexibility comes additional\n * responsibility. The absence of block-structured locking removes the\n * automatic release of locks that occurs with {@code synchronized}\n * methods and statements. In most cases, the following idiom\n * should be used:\n *\n * <pre> {@code\n * Lock l = ...;\n * l.lock();\n * try {\n *   // access the resource protected by this lock\n * } finally {\n *   l.unlock();\n * }}</pre>\n *\n * When locking and unlocking occur in different scopes, care must be\n * taken to ensure that all code that is executed while the lock is\n * held is protected by try-finally or try-catch to ensure that the\n * lock is released when necessary.\n *\n * <p>{@code Lock} implementations provide additional functionality\n * over the use of {@code synchronized} methods and statements by\n * providing a non-blocking attempt to acquire a lock ({@link\n * #tryLock()}), an attempt to acquire the lock that can be\n * interrupted ({@link #lockInterruptibly}, and an attempt to acquire\n * the lock that can timeout ({@link #tryLock(long, TimeUnit)}).\n *\n * <p>A {@code Lock} class can also provide behavior and semantics\n * that is quite different from that of the implicit monitor lock,\n * such as guaranteed ordering, non-reentrant usage, or deadlock\n * detection. If an implementation provides such specialized semantics\n * then the implementation must document those semantics.\n *\n * <p>Note that {@code Lock} instances are just normal objects and can\n * themselves be used as the target in a {@code synchronized} statement.\n * Acquiring the\n * monitor lock of a {@code Lock} instance has no specified relationship\n * with invoking any of the {@link #lock} methods of that instance.\n * It is recommended that to avoid confusion you never use {@code Lock}\n * instances in this way, except within their own implementation.\n *\n * <p>Except where noted, passing a {@code null} value for any\n * parameter will result in a {@link NullPointerException} being\n * thrown.\n *\n * <h2>Memory Synchronization</h2>\n *\n * <p>All {@code Lock} implementations <em>must</em> enforce the same\n * memory synchronization semantics as provided by the built-in monitor\n * lock, as described in\n * Chapter 17 of\n * <cite>The Java Language Specification</cite>:\n * <ul>\n * <li>A successful {@code lock} operation has the same memory\n * synchronization effects as a successful <em>Lock</em> action.\n * <li>A successful {@code unlock} operation has the same\n * memory synchronization effects as a successful <em>Unlock</em> action.\n * </ul>\n *\n * Unsuccessful locking and unlocking operations, and reentrant\n * locking/unlocking operations, do not require any memory\n * synchronization effects.\n *\n * <h2>Implementation Considerations</h2>\n *\n * <p>The three forms of lock acquisition (interruptible,\n * non-interruptible, and timed) may differ in their performance\n * characteristics, ordering guarantees, or other implementation\n * qualities.  Further, the ability to interrupt the <em>ongoing</em>\n * acquisition of a lock may not be available in a given {@code Lock}\n * class.  Consequently, an implementation is not required to define\n * exactly the same guarantees or semantics for all three forms of\n * lock acquisition, nor is it required to support interruption of an\n * ongoing lock acquisition.  An implementation is required to clearly\n * document the semantics and guarantees provided by each of the\n * locking methods. It must also obey the interruption semantics as\n * defined in this interface, to the extent that interruption of lock\n * acquisition is supported: which is either totally, or only on\n * method entry.\n *\n * <p>As interruption generally implies cancellation, and checks for\n * interruption are often infrequent, an implementation can favor responding\n * to an interrupt over normal method return. This is true even if it can be\n * shown that the interrupt occurred after another action may have unblocked\n * the thread. An implementation should document this behavior.\n *\n * @see ReentrantLock\n * @see Condition\n * @see ReadWriteLock\n * @jls 17.4 Memory Model\n *\n * @since 1.5\n * @author Doug Lea\n ",
  "links" : [ "#tryLock(long", "#lock", "java.util.concurrent.locks.Condition", "#lockInterruptibly", "NullPointerException", "#tryLock()", "java.util.concurrent.locks.ReadWriteLock" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " void lock()",
    "returnType" : "void",
    "comment" : "\n     * Acquires the lock.\n     *\n     * <p>If the lock is not available then the current thread becomes\n     * disabled for thread scheduling purposes and lies dormant until the\n     * lock has been acquired.\n     *\n     * <p><b>Implementation Considerations</b>\n     *\n     * <p>A {@code Lock} implementation may be able to detect erroneous use\n     * of the lock, such as an invocation that would cause deadlock, and\n     * may throw an (unchecked) exception in such circumstances.  The\n     * circumstances and the exception type must be documented by that\n     * {@code Lock} implementation.\n     ",
    "links" : [ ]
  }, {
    "name" : " void lockInterruptibly() throws InterruptedException",
    "returnType" : "void",
    "comment" : "\n     * Acquires the lock unless the current thread is\n     * {@linkplain Thread#interrupt interrupted}.\n     *\n     * <p>Acquires the lock if it is available and returns immediately.\n     *\n     * <p>If the lock is not available then the current thread becomes\n     * disabled for thread scheduling purposes and lies dormant until\n     * one of two things happens:\n     *\n     * <ul>\n     * <li>The lock is acquired by the current thread; or\n     * <li>Some other thread {@linkplain Thread#interrupt interrupts} the\n     * current thread, and interruption of lock acquisition is supported.\n     * </ul>\n     *\n     * <p>If the current thread:\n     * <ul>\n     * <li>has its interrupted status set on entry to this method; or\n     * <li>is {@linkplain Thread#interrupt interrupted} while acquiring the\n     * lock, and interruption of lock acquisition is supported,\n     * </ul>\n     * then {@link InterruptedException} is thrown and the current thread's\n     * interrupted status is cleared.\n     *\n     * <p><b>Implementation Considerations</b>\n     *\n     * <p>The ability to interrupt a lock acquisition in some\n     * implementations may not be possible, and if possible may be an\n     * expensive operation.  The programmer should be aware that this\n     * may be the case. An implementation should document when this is\n     * the case.\n     *\n     * <p>An implementation can favor responding to an interrupt over\n     * normal method return.\n     *\n     * <p>A {@code Lock} implementation may be able to detect\n     * erroneous use of the lock, such as an invocation that would\n     * cause deadlock, and may throw an (unchecked) exception in such\n     * circumstances.  The circumstances and the exception type must\n     * be documented by that {@code Lock} implementation.\n     *\n     * @throws InterruptedException if the current thread is\n     *         interrupted while acquiring the lock (and interruption\n     *         of lock acquisition is supported)\n     ",
    "links" : [ "InterruptedException" ]
  }, {
    "name" : " boolean tryLock()",
    "returnType" : "boolean",
    "comment" : "\n     * Acquires the lock only if it is free at the time of invocation.\n     *\n     * <p>Acquires the lock if it is available and returns immediately\n     * with the value {@code true}.\n     * If the lock is not available then this method will return\n     * immediately with the value {@code false}.\n     *\n     * <p>A typical usage idiom for this method would be:\n     * <pre> {@code\n     * Lock lock = ...;\n     * if (lock.tryLock()) {\n     *   try {\n     *     // manipulate protected state\n     *   } finally {\n     *     lock.unlock();\n     *   }\n     * } else {\n     *   // perform alternative actions\n     * }}</pre>\n     *\n     * This usage ensures that the lock is unlocked if it was acquired, and\n     * doesn't try to unlock if the lock was not acquired.\n     *\n     * @return {@code true} if the lock was acquired and\n     *         {@code false} otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean tryLock(long time, TimeUnit unit) throws InterruptedException",
    "returnType" : "boolean",
    "comment" : "\n     * Acquires the lock if it is free within the given waiting time and the\n     * current thread has not been {@linkplain Thread#interrupt interrupted}.\n     *\n     * <p>If the lock is available this method returns immediately\n     * with the value {@code true}.\n     * If the lock is not available then\n     * the current thread becomes disabled for thread scheduling\n     * purposes and lies dormant until one of three things happens:\n     * <ul>\n     * <li>The lock is acquired by the current thread; or\n     * <li>Some other thread {@linkplain Thread#interrupt interrupts} the\n     * current thread, and interruption of lock acquisition is supported; or\n     * <li>The specified waiting time elapses\n     * </ul>\n     *\n     * <p>If the lock is acquired then the value {@code true} is returned.\n     *\n     * <p>If the current thread:\n     * <ul>\n     * <li>has its interrupted status set on entry to this method; or\n     * <li>is {@linkplain Thread#interrupt interrupted} while acquiring\n     * the lock, and interruption of lock acquisition is supported,\n     * </ul>\n     * then {@link InterruptedException} is thrown and the current thread's\n     * interrupted status is cleared.\n     *\n     * <p>If the specified waiting time elapses then the value {@code false}\n     * is returned.\n     * If the time is\n     * less than or equal to zero, the method will not wait at all.\n     *\n     * <p><b>Implementation Considerations</b>\n     *\n     * <p>The ability to interrupt a lock acquisition in some implementations\n     * may not be possible, and if possible may\n     * be an expensive operation.\n     * The programmer should be aware that this may be the case. An\n     * implementation should document when this is the case.\n     *\n     * <p>An implementation can favor responding to an interrupt over normal\n     * method return, or reporting a timeout.\n     *\n     * <p>A {@code Lock} implementation may be able to detect\n     * erroneous use of the lock, such as an invocation that would cause\n     * deadlock, and may throw an (unchecked) exception in such circumstances.\n     * The circumstances and the exception type must be documented by that\n     * {@code Lock} implementation.\n     *\n     * @param time the maximum time to wait for the lock\n     * @param unit the time unit of the {@code time} argument\n     * @return {@code true} if the lock was acquired and {@code false}\n     *         if the waiting time elapsed before the lock was acquired\n     *\n     * @throws InterruptedException if the current thread is interrupted\n     *         while acquiring the lock (and interruption of lock\n     *         acquisition is supported)\n     ",
    "links" : [ "InterruptedException" ]
  }, {
    "name" : " void unlock()",
    "returnType" : "void",
    "comment" : "\n     * Releases the lock.\n     *\n     * <p><b>Implementation Considerations</b>\n     *\n     * <p>A {@code Lock} implementation will usually impose\n     * restrictions on which thread can release a lock (typically only the\n     * holder of the lock can release it) and may throw\n     * an (unchecked) exception if the restriction is violated.\n     * Any restrictions and the exception\n     * type must be documented by that {@code Lock} implementation.\n     ",
    "links" : [ ]
  }, {
    "name" : " Condition newCondition()",
    "returnType" : "Condition",
    "comment" : "\n     * Returns a new {@link Condition} instance that is bound to this\n     * {@code Lock} instance.\n     *\n     * <p>Before waiting on the condition the lock must be held by the\n     * current thread.\n     * A call to {@link Condition#await()} will atomically release the lock\n     * before waiting and re-acquire the lock before the wait returns.\n     *\n     * <p><b>Implementation Considerations</b>\n     *\n     * <p>The exact operation of the {@link Condition} instance depends on\n     * the {@code Lock} implementation and must be documented by that\n     * implementation.\n     *\n     * @return A new {@link Condition} instance for this {@code Lock} instance\n     * @throws UnsupportedOperationException if this {@code Lock}\n     *         implementation does not support conditions\n     ",
    "links" : [ "java.util.concurrent.locks.Condition", "java.util.concurrent.locks.Condition#await()" ]
  } ],
  "methodNames" : [ " void lock()", " void lockInterruptibly() throws InterruptedException", " boolean tryLock()", " boolean tryLock(long time, TimeUnit unit) throws InterruptedException", " void unlock()", " Condition newCondition()" ],
  "variableNames" : [ ]
}