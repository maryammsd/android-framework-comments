{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/security/DrbgParameters.java",
  "packageName" : "java.security",
  "className" : "DrbgParameters",
  "comment" : "\n * This class specifies the parameters used by a DRBG (Deterministic\n * Random Bit Generator).\n * <p>\n * According to\n * <a href=\"http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf\">\n * NIST Special Publication 800-90A Revision 1, Recommendation for Random\n * Number Generation Using Deterministic Random Bit Generators</a> (800-90Ar1),\n * <blockquote>\n * A DRBG is based on a DRBG mechanism as specified in this Recommendation\n * and includes a source of randomness. A DRBG mechanism uses an algorithm\n * (i.e., a DRBG algorithm) that produces a sequence of bits from an initial\n * value that is determined by a seed that is determined from the output of\n * the randomness source.\"\n * </blockquote>\n * <p>\n * The 800-90Ar1 specification allows for a variety of DRBG implementation\n * choices, such as:\n * <ul>\n * <li> an entropy source,\n * <li> a DRBG mechanism (for example, Hash_DRBG),\n * <li> a DRBG algorithm (for example, SHA-256 for Hash_DRBG and AES-256\n * for CTR_DRBG. Please note that it is not the algorithm used in\n * {@link SecureRandom#getInstance}, which we will call a\n * <em>SecureRandom algorithm</em> below),\n * <li> optional features, including prediction resistance\n * and reseeding supports,\n * <li> highest security strength.\n * </ul>\n * <p>\n * These choices are set in each implementation and are not directly\n * managed by the {@code SecureRandom} API.  Check your DRBG provider's\n * documentation to find an appropriate implementation for the situation.\n * <p>\n * On the other hand, the 800-90Ar1 specification does have some configurable\n * options, such as:\n * <ul>\n * <li> required security strength,\n * <li> if prediction resistance is required,\n * <li> personalization string and additional input.\n * </ul>\n * <p>\n * A DRBG instance can be instantiated with parameters from an\n * {@link DrbgParameters.Instantiation} object and other information\n * (for example, the nonce, which is not managed by this API). This maps\n * to the {@code Instantiate_function} defined in NIST SP 800-90Ar1.\n * <p>\n * A DRBG instance can be reseeded with parameters from a\n * {@link DrbgParameters.Reseed} object. This maps to the\n * {@code Reseed_function} defined in NIST SP 800-90Ar1. Calling\n * {@link SecureRandom#reseed()} is equivalent to calling\n * {@link SecureRandom#reseed(SecureRandomParameters)} with the effective\n * instantiated prediction resistance flag (as returned by\n * {@link SecureRandom#getParameters()}) with no additional input.\n * <p>\n * A DRBG instance generates data with additional parameters from a\n * {@link DrbgParameters.NextBytes} object. This maps to the\n * {@code Generate_function} defined in NIST SP 800-90Ar1. Calling\n * {@link SecureRandom#nextBytes(byte[])} is equivalent to calling\n * {@link SecureRandom#nextBytes(byte[], SecureRandomParameters)}\n * with the effective instantiated strength and prediction resistance flag\n * (as returned by {@link SecureRandom#getParameters()}) with no\n * additional input.\n * <p>\n * A DRBG should be implemented as a subclass of {@link SecureRandomSpi}.\n * It is recommended that the implementation contain the 1-arg\n * {@linkplain SecureRandomSpi#SecureRandomSpi(SecureRandomParameters) constructor}\n * that takes a {@code DrbgParameters.Instantiation} argument. If implemented\n * this way, this implementation can be chosen by any\n * {@code SecureRandom.getInstance()} method. If it is chosen by a\n * {@code SecureRandom.getInstance()} with a {@link SecureRandomParameters}\n * parameter, the parameter is passed into this constructor. If it is chosen\n * by a {@code SecureRandom.getInstance()} without a\n * {@code SecureRandomParameters} parameter, the constructor is called with\n * a {@code null} argument and the implementation should choose its own\n * parameters. Its {@link SecureRandom#getParameters()} must always return a\n * non-null effective {@code DrbgParameters.Instantiation} object that reflects\n * how the DRBG is actually instantiated. A caller can use this information\n * to determine whether a {@code SecureRandom} object is a DRBG and what\n * features it supports. Please note that the returned value does not\n * necessarily equal to the {@code DrbgParameters.Instantiation} object passed\n * into the {@code SecureRandom.getInstance()} call. For example,\n * the requested capability can be {@link DrbgParameters.Capability#NONE}\n * but the effective value can be {@link DrbgParameters.Capability#RESEED_ONLY}\n * if the implementation supports reseeding. The implementation must implement\n * the {@link SecureRandomSpi#engineNextBytes(byte[], SecureRandomParameters)}\n * method which takes a {@code DrbgParameters.NextBytes} parameter. Unless\n * the result of {@link SecureRandom#getParameters()} has its\n * {@linkplain DrbgParameters.Instantiation#getCapability() capability} being\n * {@link Capability#NONE NONE}, it must implement\n * {@link SecureRandomSpi#engineReseed(SecureRandomParameters)} which takes\n * a {@code DrbgParameters.Reseed} parameter.\n * <p>\n * On the other hand, if a DRBG implementation does not contain a constructor\n * that has an {@code DrbgParameters.Instantiation} argument (not recommended),\n * it can only be chosen by a {@code SecureRandom.getInstance()} without\n * a {@code SecureRandomParameters} parameter, but will not be chosen if\n * a {@code getInstance} method with a {@code SecureRandomParameters} parameter\n * is called. If implemented this way, its {@link SecureRandom#getParameters()}\n * must return {@code null}, and it does not need to implement either\n * {@link SecureRandomSpi#engineNextBytes(byte[], SecureRandomParameters)}\n * or {@link SecureRandomSpi#engineReseed(SecureRandomParameters)}.\n * <p>\n * A DRBG might reseed itself automatically if the seed period is bigger\n * than the maximum seed life defined by the DRBG mechanism.\n * <p>\n * A DRBG implementation should support serialization and deserialization\n * by retaining the configuration and effective parameters, but the internal\n * state must not be serialized and the deserialized object must be\n * reinstantiated.\n * <p>\n * Examples:\n * <blockquote><pre>\n * SecureRandom drbg;\n * byte[] buffer = new byte[32];\n *\n * // Any DRBG is OK\n * drbg = SecureRandom.getInstance(\"DRBG\");\n * drbg.nextBytes(buffer);\n *\n * SecureRandomParameters params = drbg.getParameters();\n * if (params instanceof DrbgParameters.Instantiation) {\n *     DrbgParameters.Instantiation ins = (DrbgParameters.Instantiation) params;\n *     if (ins.getCapability().supportsReseeding()) {\n *         drbg.reseed();\n *     }\n * }\n *\n * // The following call requests a weak DRBG instance. It is only\n * // guaranteed to support 112 bits of security strength.\n * drbg = SecureRandom.getInstance(\"DRBG\",\n *         DrbgParameters.instantiation(112, NONE, null));\n *\n * // Both the next two calls will likely fail, because drbg could be\n * // instantiated with a smaller strength with no prediction resistance\n * // support.\n * drbg.nextBytes(buffer,\n *         DrbgParameters.nextBytes(256, false, \"more\".getBytes()));\n * drbg.nextBytes(buffer,\n *         DrbgParameters.nextBytes(112, true, \"more\".getBytes()));\n *\n * // The following call requests a strong DRBG instance, with a\n * // personalization string. If it successfully returns an instance,\n * // that instance is guaranteed to support 256 bits of security strength\n * // with prediction resistance available.\n * drbg = SecureRandom.getInstance(\"DRBG\", DrbgParameters.instantiation(\n *         256, PR_AND_RESEED, \"hello\".getBytes()));\n *\n * // Prediction resistance is not requested in this single call,\n * // but an additional input is used.\n * drbg.nextBytes(buffer,\n *         DrbgParameters.nextBytes(-1, false, \"more\".getBytes()));\n *\n * // Same for this call.\n * drbg.reseed(DrbgParameters.reseed(false, \"extra\".getBytes()));</pre>\n * </blockquote>\n *\n * @implSpec\n * By convention, a provider should name its primary DRBG implementation\n * with the <a href=\n * \"{@docRoot}/../specs/security/standard-names.html#securerandom-number-generation-algorithms\">\n * standard {@code SecureRandom} algorithm name</a> \"DRBG\".\n *\n * @implNote\n * The following notes apply to the \"DRBG\" implementation in the SUN provider\n * of the JDK reference implementation.\n * <p>\n * This implementation supports the Hash_DRBG and HMAC_DRBG mechanisms with\n * DRBG algorithm SHA-224, SHA-512/224, SHA-256, SHA-512/256, SHA-384 and\n * SHA-512, and CTR_DRBG (both using derivation function and not using\n * derivation function) with DRBG algorithm AES-128, AES-192 and AES-256.\n * <p>\n * The mechanism name and DRBG algorithm name are determined by the\n * {@linkplain Security#getProperty(String) security property}\n * {@code securerandom.drbg.config}. The default choice is Hash_DRBG\n * with SHA-256.\n * <p>\n * For each combination, the security strength can be requested from 112\n * up to the highest strength it supports. Both reseeding and prediction\n * resistance are supported.\n * <p>\n * Personalization string is supported through the\n * {@link DrbgParameters.Instantiation} class and additional input is supported\n * through the {@link DrbgParameters.NextBytes} and\n * {@link DrbgParameters.Reseed} classes.\n * <p>\n * If a DRBG is not instantiated with a {@link DrbgParameters.Instantiation}\n * object explicitly, this implementation instantiates it with a default\n * requested strength of 128 bits, no prediction resistance request, and\n * no personalization string. These default instantiation parameters can also\n * be customized with the {@code securerandom.drbg.config} security property.\n * <p>\n * This implementation reads fresh entropy from the system default entropy\n * source determined by the security property {@code securerandom.source}.\n * <p>\n * Calling {@link SecureRandom#generateSeed(int)} will directly read\n * from this system default entropy source.\n *\n * @since 9\n ",
  "links" : [ "DrbgParameters.NextBytes", "java.security.SecureRandom#reseed()", "DrbgParameters.Capability#NONE", "DrbgParameters.Instantiation", "java.security.SecureRandom#nextBytes(byte", "#NONE", "java.security.SecureRandomParameters", "java.security.SecureRandomSpi#engineNextBytes(byte", "DrbgParameters.Reseed", "java.security.SecureRandomSpi#engineReseed(SecureRandomParameters)", "java.security.SecureRandom#generateSeed(int)", "java.security.SecureRandom#getParameters()", "DrbgParameters.Capability#RESEED_ONLY", "java.security.SecureRandom#reseed(SecureRandomParameters)", "java.security.SecureRandom#getInstance", "java.security.SecureRandomSpi" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : "public static Instantiation instantiation(int strength, Capability capability, byte[] personalizationString)",
    "returnType" : "Instantiation",
    "comment" : "\n     * Generates a {@link DrbgParameters.Instantiation} object.\n     *\n     * @param strength security strength in bits, -1 for default strength\n     *                 if used in {@code getInstance}.\n     * @param capability capability\n     * @param personalizationString personalization string as a byte array,\n     *                              can be {@code null}. The content of this\n     *                              byte array will be copied.\n     * @return a new {@code Instantiation} object\n     * @throws NullPointerException if {@code capability} is {@code null}\n     * @throws IllegalArgumentException if {@code strength} is less than -1\n     ",
    "links" : [ "DrbgParameters.Instantiation" ]
  }, {
    "name" : "public static NextBytes nextBytes(int strength, boolean predictionResistance, byte[] additionalInput)",
    "returnType" : "NextBytes",
    "comment" : "\n     * Generates a {@link NextBytes} object.\n     *\n     * @param strength requested security strength in bits. If set to -1, the\n     *                 effective strength will be used.\n     * @param predictionResistance prediction resistance requested\n     * @param additionalInput additional input, can be {@code null}.\n     *                        The content of this byte array will be copied.\n     * @throws IllegalArgumentException if {@code strength} is less than -1\n     * @return a new {@code NextBytes} object\n     ",
    "links" : [ "NextBytes" ]
  }, {
    "name" : "public static Reseed reseed(boolean predictionResistance, byte[] additionalInput)",
    "returnType" : "Reseed",
    "comment" : "\n     * Generates a {@link Reseed} object.\n     *\n     * @param predictionResistance prediction resistance requested\n     * @param additionalInput additional input, can be {@code null}.\n     *                        The content of this byte array will be copied.\n     * @return a new {@code Reseed} object\n     ",
    "links" : [ "Reseed" ]
  } ],
  "methodNames" : [ "public static Instantiation instantiation(int strength, Capability capability, byte[] personalizationString)", "public static NextBytes nextBytes(int strength, boolean predictionResistance, byte[] additionalInput)", "public static Reseed reseed(boolean predictionResistance, byte[] additionalInput)" ],
  "variableNames" : [ ]
}