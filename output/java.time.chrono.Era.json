{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/time/chrono/Era.java",
  "packageName" : "java.time.chrono",
  "className" : "Era",
  "comment" : "\n * An era of the time-line.\n * <p>\n * Most calendar systems have a single epoch dividing the time-line into two eras.\n * However, some calendar systems, have multiple eras, such as one for the reign\n * of each leader.\n * In all cases, the era is conceptually the largest division of the time-line.\n * Each chronology defines the Era's that are known Eras and a\n * {@link Chronology#eras Chronology.eras} to get the valid eras.\n * <p>\n * For example, the Thai Buddhist calendar system divides time into two eras,\n * before and after a single date. By contrast, the Japanese calendar system\n * has one era for the reign of each Emperor.\n * <p>\n * Instances of {@code Era} may be compared using the {@code ==} operator.\n *\n * @implSpec\n * This interface must be implemented with care to ensure other classes operate correctly.\n * All implementations must be singletons - final, immutable and thread-safe.\n * It is recommended to use an enum whenever possible.\n *\n * @since 1.8\n ",
  "links" : [ "java.time.chrono.Chronology#eras" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " int getValue()",
    "returnType" : "int",
    "comment" : "\n     * Gets the numeric value associated with the era as defined by the chronology.\n     * Each chronology defines the predefined Eras and methods to list the Eras\n     * of the chronology.\n     * <p>\n     * All fields, including eras, have an associated numeric value.\n     * The meaning of the numeric value for era is determined by the chronology\n     * according to these principles:\n     * <ul>\n     * <li>The era in use at the epoch 1970-01-01 (ISO) has the value 1.\n     * <li>Later eras have sequentially higher values.\n     * <li>Earlier eras have sequentially lower values, which may be negative.\n     * </ul>\n     *\n     * @return the numeric era value\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean isSupported(TemporalField field)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the specified field is supported.\n     * <p>\n     * This checks if this era can be queried for the specified field.\n     * If false, then calling the {@link #range(TemporalField) range} and\n     * {@link #get(TemporalField) get} methods will throw an exception.\n     * <p>\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@code ERA} field returns true.\n     * All other {@code ChronoField} instances will return false.\n     * <p>\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param field  the field to check, null returns false\n     * @return true if the field is supported on this era, false if not\n     ",
    "links" : [ "#range(TemporalField)", "java.time.temporal.ChronoField", "#get(TemporalField)" ]
  }, {
    "name" : " ValueRange range(TemporalField field)",
    "returnType" : "ValueRange",
    "comment" : "\n     * Gets the range of valid values for the specified field.\n     * <p>\n     * The range object expresses the minimum and maximum valid values for a field.\n     * This era is used to enhance the accuracy of the returned range.\n     * If it is not possible to return the range, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * <p>\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@code ERA} field returns the range.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * <p>\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the range can be obtained is determined by the field.\n     * <p>\n     * The default implementation must return a range for {@code ERA} from\n     * zero to one, suitable for two era calendar systems such as ISO.\n     *\n     * @param field  the field to query the range for, not null\n     * @return the range of valid values for the field, not null\n     * @throws DateTimeException if the range for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     ",
    "links" : [ "java.time.temporal.ChronoField" ]
  }, {
    "name" : " int get(TemporalField field)",
    "returnType" : "int",
    "comment" : "\n     * Gets the value of the specified field from this era as an {@code int}.\n     * <p>\n     * This queries this era for the value of the specified field.\n     * The returned value will always be within the valid range of values for the field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * <p>\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@code ERA} field returns the value of the era.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * <p>\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained or\n     *         the value is outside the range of valid values for the field\n     * @throws UnsupportedTemporalTypeException if the field is not supported or\n     *         the range of values exceeds an {@code int}\n     * @throws ArithmeticException if numeric overflow occurs\n     ",
    "links" : [ "java.time.temporal.ChronoField" ]
  }, {
    "name" : " long getLong(TemporalField field)",
    "returnType" : "long",
    "comment" : "\n     * Gets the value of the specified field from this era as a {@code long}.\n     * <p>\n     * This queries this era for the value of the specified field.\n     * If it is not possible to return the value, because the field is not supported\n     * or for some other reason, an exception is thrown.\n     * <p>\n     * If the field is a {@link ChronoField} then the query is implemented here.\n     * The {@code ERA} field returns the value of the era.\n     * All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.\n     * <p>\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}\n     * passing {@code this} as the argument. Whether the value can be obtained,\n     * and what the value represents, is determined by the field.\n     *\n     * @param field  the field to get, not null\n     * @return the value for the field\n     * @throws DateTimeException if a value for the field cannot be obtained\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     ",
    "links" : [ "java.time.temporal.ChronoField" ]
  }, {
    "name" : " R query(TemporalQuery<R> query)",
    "returnType" : "R",
    "comment" : "\n     * Queries this era using the specified query.\n     * <p>\n     * This queries this era using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * <p>\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param <R> the type of the result\n     * @param query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     ",
    "links" : [ "java.time.temporal.TemporalQuery#queryFrom(TemporalAccessor)" ]
  }, {
    "name" : " Temporal adjustInto(Temporal temporal)",
    "returnType" : "Temporal",
    "comment" : "\n     * Adjusts the specified temporal object to have the same era as this object.\n     * <p>\n     * This returns a temporal object of the same observable type as the input\n     * with the era changed to be the same as this.\n     * <p>\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * passing {@link ChronoField#ERA} as the field.\n     * <p>\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisEra.adjustInto(temporal);\n     *   temporal = temporal.with(thisEra);\n     * </pre>\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param temporal  the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     ",
    "links" : [ "java.time.temporal.Temporal#with(TemporalField", "java.time.temporal.Temporal#with(TemporalAdjuster)", "java.time.temporal.ChronoField#ERA" ]
  }, {
    "name" : " String getDisplayName(TextStyle style, Locale locale)",
    "returnType" : "String",
    "comment" : "\n     * Gets the textual representation of this era.\n     * <p>\n     * This returns the textual name used to identify the era,\n     * suitable for presentation to the user.\n     * The parameters control the style of the returned text and the locale.\n     * <p>\n     * If no textual mapping is found then the {@link #getValue() numeric value} is returned.\n     *\n     * @apiNote This default implementation is suitable for most implementations.\n     *\n     * @param style  the style of the text required, not null\n     * @param locale  the locale to use, not null\n     * @return the text value of the era, not null\n     ",
    "links" : [ "#getValue()" ]
  } ],
  "methodNames" : [ " int getValue()", " boolean isSupported(TemporalField field)", " ValueRange range(TemporalField field)", " int get(TemporalField field)", " long getLong(TemporalField field)", " R query(TemporalQuery<R> query)", " Temporal adjustInto(Temporal temporal)", " String getDisplayName(TextStyle style, Locale locale)" ],
  "variableNames" : [ ]
}