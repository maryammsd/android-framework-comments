{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/os/Environment.java",
  "packageName" : "android.os",
  "className" : "Environment",
  "comment" : "\n * Provides access to environment variables.\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ENV_EXTERNAL_STORAGE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ENV_ANDROID_ROOT",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ENV_ANDROID_DATA",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ENV_ANDROID_EXPAND",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ENV_ANDROID_STORAGE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ENV_DOWNLOAD_CACHE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ENV_OEM_ROOT",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ENV_ODM_ROOT",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ENV_VENDOR_ROOT",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ENV_PRODUCT_ROOT",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ENV_SYSTEM_EXT_ROOT",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ENV_APEX_ROOT",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIR_ANDROID",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "DIR_DATA",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIR_MEDIA",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIR_OBB",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIR_FILES",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIR_CACHE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIR_USER_CE",
    "type" : "String",
    "comment" : "\n     * The folder name prefix for the user credential protected data directory. This is exposed for\n     * use in string path caching for {@link ApplicationInfo} objects, and should not be accessed\n     * directly otherwise. Prefer {@link #getDataUserCeDirectory(String, int)}.\n     * {@hide}\n     ",
    "links" : [ "#getDataUserCeDirectory(String", "android.content.pm.ApplicationInfo" ]
  }, {
    "name" : "DIR_USER_DE",
    "type" : "String",
    "comment" : "\n     * The folder name prefix for the user device protected data directory. This is exposed for use\n     * in string path caching for {@link ApplicationInfo} objects, and should not be accessed\n     * directly otherwise. Prefer {@link #getDataUserDeDirectory(String, int)}.\n     * {@hide}\n     ",
    "links" : [ "#getDataUserDeDirectory(String", "android.content.pm.ApplicationInfo" ]
  }, {
    "name" : "DIRECTORY_ANDROID",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "DIR_ANDROID_ROOT",
    "type" : "File",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIR_ANDROID_DATA_PATH",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIR_ANDROID_DATA",
    "type" : "File",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIR_ANDROID_EXPAND",
    "type" : "File",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIR_ANDROID_STORAGE",
    "type" : "File",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIR_DOWNLOAD_CACHE",
    "type" : "File",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIR_METADATA",
    "type" : "File",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIR_OEM_ROOT",
    "type" : "File",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIR_ODM_ROOT",
    "type" : "File",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIR_VENDOR_ROOT",
    "type" : "File",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIR_PRODUCT_ROOT",
    "type" : "File",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIR_SYSTEM_EXT_ROOT",
    "type" : "File",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIR_APEX_ROOT",
    "type" : "File",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_SCOPED_STORAGE",
    "type" : "long",
    "comment" : "\n     * Scoped Storage is on by default. However, it is not strictly enforced and there are multiple\n     * ways to opt out of scoped storage:\n     * <ul>\n     * <li>Target Sdk < Q</li>\n     * <li>Target Sdk = Q and has `requestLegacyExternalStorage` set in AndroidManifest.xml</li>\n     * <li>Target Sdk > Q: Upgrading from an app that was opted out of scoped storage and has\n     * `preserveLegacyExternalStorage` set in AndroidManifest.xml</li>\n     * </ul>\n     * This flag is enabled for all apps by default as Scoped Storage is enabled by default.\n     * Developers can disable this flag to opt out of Scoped Storage and have legacy storage\n     * workflow.\n     *\n     * Note: {@code FORCE_ENABLE_SCOPED_STORAGE} should also be disabled for apps to opt out of\n     * scoped storage.\n     * Note: This flag is also used in {@code com.android.providers.media.LocalCallingIdentity}.\n     * Any modifications to this flag should be reflected there as well.\n     * See https://developer.android.com/training/data-storage#scoped-storage for more information.\n     ",
    "links" : [ ]
  }, {
    "name" : "FORCE_ENABLE_SCOPED_STORAGE",
    "type" : "long",
    "comment" : "\n     * Setting this flag strictly enforces Scoped Storage regardless of:\n     * <ul>\n     * <li>The value of Target Sdk</li>\n     * <li>The value of `requestLegacyExternalStorage` in AndroidManifest.xml</li>\n     * <li>The value of `preserveLegacyExternalStorage` in AndroidManifest.xml</li>\n     * </ul>\n     *\n     * Note: {@code DEFAULT_SCOPED_STORAGE} should also be enabled for apps to be enforced into\n     * scoped storage.\n     * Note: This flag is also used in {@code com.android.providers.media.LocalCallingIdentity}.\n     * Any modifications to this flag should be reflected there as well.\n     * See https://developer.android.com/training/data-storage#scoped-storage for more information.\n     ",
    "links" : [ ]
  }, {
    "name" : "sCurrentUser",
    "type" : "UserEnvironment",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sUserRequired",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DIRECTORY_MUSIC",
    "type" : "String",
    "comment" : "\n     * Standard directory in which to place any audio files that should be\n     * in the regular list of music for the user.\n     * This may be combined with {@link #DIRECTORY_AUDIOBOOKS},\n     * {@link #DIRECTORY_PODCASTS}, {@link #DIRECTORY_NOTIFICATIONS},\n     * {@link #DIRECTORY_ALARMS}, {@link #DIRECTORY_RINGTONES}, and\n     * {@link #DIRECTORY_RECORDINGS} as a series of directories to\n     * categorize a particular audio file as more than one type.\n     ",
    "links" : [ "#DIRECTORY_PODCASTS", "#DIRECTORY_RECORDINGS", "#DIRECTORY_ALARMS", "#DIRECTORY_NOTIFICATIONS", "#DIRECTORY_AUDIOBOOKS", "#DIRECTORY_RINGTONES" ]
  }, {
    "name" : "DIRECTORY_PODCASTS",
    "type" : "String",
    "comment" : "\n     * Standard directory in which to place any audio files that should be\n     * in the list of podcasts that the user can select (not as regular\n     * music).\n     * This may be combined with {@link #DIRECTORY_MUSIC},\n     * {@link #DIRECTORY_AUDIOBOOKS}, {@link #DIRECTORY_NOTIFICATIONS},\n     * {@link #DIRECTORY_ALARMS}, {@link #DIRECTORY_RINGTONES}, and\n     * {@link #DIRECTORY_RECORDINGS} as a series of directories to\n     * categorize a particular audio file as more than one type.\n     ",
    "links" : [ "#DIRECTORY_MUSIC", "#DIRECTORY_RECORDINGS", "#DIRECTORY_ALARMS", "#DIRECTORY_NOTIFICATIONS", "#DIRECTORY_AUDIOBOOKS", "#DIRECTORY_RINGTONES" ]
  }, {
    "name" : "DIRECTORY_RINGTONES",
    "type" : "String",
    "comment" : "\n     * Standard directory in which to place any audio files that should be\n     * in the list of ringtones that the user can select (not as regular\n     * music).\n     * This may be combined with {@link #DIRECTORY_MUSIC},\n     * {@link #DIRECTORY_AUDIOBOOKS}, {@link #DIRECTORY_PODCASTS},\n     * {@link #DIRECTORY_NOTIFICATIONS}, {@link #DIRECTORY_ALARMS},\n     * and {@link #DIRECTORY_RECORDINGS} as a series of directories\n     * to categorize a particular audio file as more than one type.\n     ",
    "links" : [ "#DIRECTORY_MUSIC", "#DIRECTORY_PODCASTS", "#DIRECTORY_RECORDINGS", "#DIRECTORY_ALARMS", "#DIRECTORY_NOTIFICATIONS", "#DIRECTORY_AUDIOBOOKS" ]
  }, {
    "name" : "DIRECTORY_ALARMS",
    "type" : "String",
    "comment" : "\n     * Standard directory in which to place any audio files that should be\n     * in the list of alarms that the user can select (not as regular\n     * music).\n     * This may be combined with {@link #DIRECTORY_MUSIC},\n     * {@link #DIRECTORY_AUDIOBOOKS}, {@link #DIRECTORY_PODCASTS},\n     * {@link #DIRECTORY_NOTIFICATIONS}, {@link #DIRECTORY_RINGTONES},\n     * and {@link #DIRECTORY_RECORDINGS} as a series of directories\n     * to categorize a particular audio file as more than one type.\n     ",
    "links" : [ "#DIRECTORY_MUSIC", "#DIRECTORY_PODCASTS", "#DIRECTORY_RECORDINGS", "#DIRECTORY_NOTIFICATIONS", "#DIRECTORY_AUDIOBOOKS", "#DIRECTORY_RINGTONES" ]
  }, {
    "name" : "DIRECTORY_NOTIFICATIONS",
    "type" : "String",
    "comment" : "\n     * Standard directory in which to place any audio files that should be\n     * in the list of notifications that the user can select (not as regular\n     * music).\n     * This may be combined with {@link #DIRECTORY_MUSIC},\n     * {@link #DIRECTORY_AUDIOBOOKS}, {@link #DIRECTORY_PODCASTS},\n     * {@link #DIRECTORY_ALARMS}, {@link #DIRECTORY_RINGTONES}, and\n     * {@link #DIRECTORY_RECORDINGS} as a series of directories to\n     * categorize a particular audio file as more than one type.\n     ",
    "links" : [ "#DIRECTORY_MUSIC", "#DIRECTORY_PODCASTS", "#DIRECTORY_RECORDINGS", "#DIRECTORY_ALARMS", "#DIRECTORY_AUDIOBOOKS", "#DIRECTORY_RINGTONES" ]
  }, {
    "name" : "DIRECTORY_PICTURES",
    "type" : "String",
    "comment" : "\n     * Standard directory in which to place pictures that are available to\n     * the user.  Note that this is primarily a convention for the top-level\n     * public directory, as the media scanner will find and collect pictures\n     * in any directory.\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTORY_MOVIES",
    "type" : "String",
    "comment" : "\n     * Standard directory in which to place movies that are available to\n     * the user.  Note that this is primarily a convention for the top-level\n     * public directory, as the media scanner will find and collect movies\n     * in any directory.\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTORY_DOWNLOADS",
    "type" : "String",
    "comment" : "\n     * Standard directory in which to place files that have been downloaded by\n     * the user.  Note that this is primarily a convention for the top-level\n     * public directory, you are free to download files anywhere in your own\n     * private directories.  Also note that though the constant here is\n     * named DIRECTORY_DOWNLOADS (plural), the actual file name is non-plural for\n     * backwards compatibility reasons.\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTORY_DCIM",
    "type" : "String",
    "comment" : "\n     * The traditional location for pictures and videos when mounting the\n     * device as a camera.  Note that this is primarily a convention for the\n     * top-level public directory, as this convention makes no sense elsewhere.\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTORY_DOCUMENTS",
    "type" : "String",
    "comment" : "\n     * Standard directory in which to place documents that have been created by\n     * the user.\n     ",
    "links" : [ ]
  }, {
    "name" : "DIRECTORY_SCREENSHOTS",
    "type" : "String",
    "comment" : "\n     * Standard directory in which to place screenshots that have been taken by\n     * the user. Typically used as a secondary directory under\n     * {@link #DIRECTORY_PICTURES}.\n     ",
    "links" : [ "#DIRECTORY_PICTURES" ]
  }, {
    "name" : "DIRECTORY_AUDIOBOOKS",
    "type" : "String",
    "comment" : "\n     * Standard directory in which to place any audio files that should be\n     * in the list of audiobooks that the user can select (not as regular\n     * music).\n     * This may be combined with {@link #DIRECTORY_MUSIC},\n     * {@link #DIRECTORY_PODCASTS}, {@link #DIRECTORY_NOTIFICATIONS},\n     * {@link #DIRECTORY_ALARMS}, {@link #DIRECTORY_RINGTONES},\n     * and {@link #DIRECTORY_RECORDINGS} as a series of directories\n     * to categorize a particular audio file as more than one type.\n     ",
    "links" : [ "#DIRECTORY_MUSIC", "#DIRECTORY_PODCASTS", "#DIRECTORY_RECORDINGS", "#DIRECTORY_ALARMS", "#DIRECTORY_NOTIFICATIONS", "#DIRECTORY_RINGTONES" ]
  }, {
    "name" : "DIRECTORY_RECORDINGS",
    "type" : "String",
    "comment" : "\n     * Standard directory in which to place any audio files that should be\n     * in the list of voice recordings recorded by voice recorder apps that\n     * the user can select (not as regular music).\n     * This may be combined with {@link #DIRECTORY_MUSIC},\n     * {@link #DIRECTORY_AUDIOBOOKS}, {@link #DIRECTORY_PODCASTS},\n     * {@link #DIRECTORY_NOTIFICATIONS}, {@link #DIRECTORY_ALARMS},\n     * and {@link #DIRECTORY_RINGTONES} as a series of directories\n     * to categorize a particular audio file as more than one type.\n     ",
    "links" : [ "#DIRECTORY_MUSIC", "#DIRECTORY_PODCASTS", "#DIRECTORY_ALARMS", "#DIRECTORY_NOTIFICATIONS", "#DIRECTORY_AUDIOBOOKS", "#DIRECTORY_RINGTONES" ]
  }, {
    "name" : "STANDARD_DIRECTORIES",
    "type" : "String[]",
    "comment" : "\n     * List of standard storage directories.\n     * <p>\n     * Each of its values have its own constant:\n     * <ul>\n     *   <li>{@link #DIRECTORY_MUSIC}\n     *   <li>{@link #DIRECTORY_PODCASTS}\n     *   <li>{@link #DIRECTORY_ALARMS}\n     *   <li>{@link #DIRECTORY_RINGTONES}\n     *   <li>{@link #DIRECTORY_NOTIFICATIONS}\n     *   <li>{@link #DIRECTORY_PICTURES}\n     *   <li>{@link #DIRECTORY_MOVIES}\n     *   <li>{@link #DIRECTORY_DOWNLOADS}\n     *   <li>{@link #DIRECTORY_DCIM}\n     *   <li>{@link #DIRECTORY_DOCUMENTS}\n     *   <li>{@link #DIRECTORY_AUDIOBOOKS}\n     *   <li>{@link #DIRECTORY_RECORDINGS}\n     * </ul>\n     * @hide\n     ",
    "links" : [ "#DIRECTORY_MUSIC", "#DIRECTORY_PODCASTS", "#DIRECTORY_RECORDINGS", "#DIRECTORY_ALARMS", "#DIRECTORY_NOTIFICATIONS", "#DIRECTORY_DOCUMENTS", "#DIRECTORY_AUDIOBOOKS", "#DIRECTORY_RINGTONES", "#DIRECTORY_MOVIES", "#DIRECTORY_DCIM", "#DIRECTORY_PICTURES", "#DIRECTORY_DOWNLOADS" ]
  }, {
    "name" : "HAS_MUSIC",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "HAS_PODCASTS",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "HAS_RINGTONES",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "HAS_ALARMS",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "HAS_NOTIFICATIONS",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "HAS_PICTURES",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "HAS_MOVIES",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "HAS_DOWNLOADS",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "HAS_DCIM",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "HAS_DOCUMENTS",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "HAS_AUDIOBOOKS",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "HAS_RECORDINGS",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "HAS_ANDROID",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "HAS_OTHER",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_UNKNOWN",
    "type" : "String",
    "comment" : "\n     * Unknown storage state, such as when a path isn't backed by known storage\n     * media.\n     *\n     * @see #getExternalStorageState(File)\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_REMOVED",
    "type" : "String",
    "comment" : "\n     * Storage state if the media is not present.\n     *\n     * @see #getExternalStorageState(File)\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_UNMOUNTED",
    "type" : "String",
    "comment" : "\n     * Storage state if the media is present but not mounted.\n     *\n     * @see #getExternalStorageState(File)\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_CHECKING",
    "type" : "String",
    "comment" : "\n     * Storage state if the media is present and being disk-checked.\n     *\n     * @see #getExternalStorageState(File)\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_NOFS",
    "type" : "String",
    "comment" : "\n     * Storage state if the media is present but is blank or is using an\n     * unsupported filesystem.\n     *\n     * @see #getExternalStorageState(File)\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_MOUNTED",
    "type" : "String",
    "comment" : "\n     * Storage state if the media is present and mounted at its mount point with\n     * read/write access.\n     *\n     * @see #getExternalStorageState(File)\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_MOUNTED_READ_ONLY",
    "type" : "String",
    "comment" : "\n     * Storage state if the media is present and mounted at its mount point with\n     * read-only access.\n     *\n     * @see #getExternalStorageState(File)\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_SHARED",
    "type" : "String",
    "comment" : "\n     * Storage state if the media is present not mounted, and shared via USB\n     * mass storage.\n     *\n     * @see #getExternalStorageState(File)\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_BAD_REMOVAL",
    "type" : "String",
    "comment" : "\n     * Storage state if the media was removed before it was unmounted.\n     *\n     * @see #getExternalStorageState(File)\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_UNMOUNTABLE",
    "type" : "String",
    "comment" : "\n     * Storage state if the media is present but cannot be mounted. Typically\n     * this happens if the file system on the media is corrupted.\n     *\n     * @see #getExternalStorageState(File)\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_EJECTING",
    "type" : "String",
    "comment" : "\n     * Storage state if the media is in the process of being ejected.\n     *\n     * @see #getExternalStorageState(File)\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static void initForCurrentUser()",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static File getRootDirectory()",
    "returnType" : "File",
    "comment" : "\n     * Return root of the \"system\" partition holding the core Android OS.\n     * Always present and mounted read-only.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File getStorageDirectory()",
    "returnType" : "File",
    "comment" : "\n     * Return root directory where all external storage devices will be mounted.\n     * For example, {@link #getExternalStorageDirectory()} will appear under\n     * this location.\n     ",
    "links" : [ "#getExternalStorageDirectory()" ]
  }, {
    "name" : "public static File getOemDirectory()",
    "returnType" : "File",
    "comment" : "\n     * Return root directory of the \"oem\" partition holding OEM customizations,\n     * if any. If present, the partition is mounted read-only.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File getOdmDirectory()",
    "returnType" : "File",
    "comment" : "\n     * Return root directory of the \"odm\" partition holding ODM customizations,\n     * if any. If present, the partition is mounted read-only.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File getVendorDirectory()",
    "returnType" : "File",
    "comment" : "\n     * Return root directory of the \"vendor\" partition that holds vendor-provided\n     * software that should persist across simple reflashing of the \"system\" partition.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File getProductDirectory()",
    "returnType" : "File",
    "comment" : "\n     * Return root directory of the \"product\" partition holding product-specific\n     * customizations if any. If present, the partition is mounted read-only.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File getProductServicesDirectory()",
    "returnType" : "File",
    "comment" : "\n     * Return root directory of the \"product_services\" partition holding middleware\n     * services if any. If present, the partition is mounted read-only.\n     *\n     * @deprecated This directory is not guaranteed to exist.\n     *             Its name is changed to \"system_ext\" because the partition's purpose is changed.\n     *             {@link #getSystemExtDirectory()}\n     * @hide\n     ",
    "links" : [ "#getSystemExtDirectory()" ]
  }, {
    "name" : "public static File getSystemExtDirectory()",
    "returnType" : "File",
    "comment" : "\n     * Return root directory of the \"system_ext\" partition holding system partition's extension\n     * If present, the partition is mounted read-only.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File getApexDirectory()",
    "returnType" : "File",
    "comment" : "\n     * Return root directory of the apex mount point, where all the apex modules are made available\n     * to the rest of the system.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File getUserSystemDirectory(int userId)",
    "returnType" : "File",
    "comment" : "\n     * Return the system directory for a user. This is for use by system\n     * services to store files relating to the user. This directory will be\n     * automatically deleted when the user is removed.\n     *\n     * @deprecated This directory is valid and still exists, but but callers\n     *             should <em>strongly</em> consider switching to using either\n     *             {@link #getDataSystemCeDirectory(int)} or\n     *             {@link #getDataSystemDeDirectory(int)}, both of which support\n     *             fast user wipe.\n     * @hide\n     ",
    "links" : [ "#getDataSystemDeDirectory(int)", "#getDataSystemCeDirectory(int)" ]
  }, {
    "name" : "public static File getUserConfigDirectory(int userId)",
    "returnType" : "File",
    "comment" : "\n     * Returns the config directory for a user. This is for use by system\n     * services to store files relating to the user which should be readable by\n     * any app running as that user.\n     *\n     * @deprecated This directory is valid and still exists, but callers should\n     *             <em>strongly</em> consider switching to\n     *             {@link #getDataMiscCeDirectory(int)} which is protected with\n     *             user credentials or {@link #getDataMiscDeDirectory(int)}\n     *             which supports fast user wipe.\n     * @hide\n     ",
    "links" : [ "#getDataMiscDeDirectory(int)", "#getDataMiscCeDirectory(int)" ]
  }, {
    "name" : "public static File getDataDirectory()",
    "returnType" : "File",
    "comment" : "\n     * Return the user data directory.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getDataDirectoryPath()",
    "returnType" : "String",
    "comment" : "\n     * @see #getDataDirectory()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataDirectory(String volumeUuid)",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static String getDataDirectoryPath(String volumeUuid)",
    "returnType" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static File getExpandDirectory()",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataSystemDirectory()",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataSystemDeDirectory()",
    "returnType" : "File",
    "comment" : "\n     * Returns the base directory for per-user system directory, device encrypted.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataSystemCeDirectory()",
    "returnType" : "File",
    "comment" : "\n     * Returns the base directory for per-user system directory, credential encrypted.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataSystemCeDirectory(int userId)",
    "returnType" : "File",
    "comment" : "\n     * Return the \"credential encrypted\" system directory for a user. This is\n     * for use by system services to store files relating to the user. This\n     * directory supports fast user wipe, and will be automatically deleted when\n     * the user is removed.\n     * <p>\n     * Data stored under this path is \"credential encrypted\", which uses an\n     * encryption key that is entangled with user credentials, such as a PIN or\n     * password. The contents will only be available once the user has been\n     * unlocked, as reported by {@code SystemService.onUnlockUser()}.\n     * <p>\n     * New code should <em>strongly</em> prefer storing sensitive data in these\n     * credential encrypted areas.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataSystemDeDirectory(int userId)",
    "returnType" : "File",
    "comment" : "\n     * Return the \"device encrypted\" system directory for a user. This is for\n     * use by system services to store files relating to the user. This\n     * directory supports fast user wipe, and will be automatically deleted when\n     * the user is removed.\n     * <p>\n     * Data stored under this path is \"device encrypted\", which uses an\n     * encryption key that is tied to the physical device. The contents will\n     * only be available once the device has finished a {@code dm-verity}\n     * protected boot.\n     * <p>\n     * New code should <em>strongly</em> avoid storing sensitive data in these\n     * device encrypted areas.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataMiscDirectory()",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataMiscCeDirectory()",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataMiscCeDirectory(int userId)",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "private static File getDataMiscCeDirectory(String volumeUuid, int userId)",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataMiscCeSharedSdkSandboxDirectory(String volumeUuid, int userId, String packageName)",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataMiscDeDirectory(int userId)",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "private static File getDataMiscDeDirectory(String volumeUuid, int userId)",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataMiscDeSharedSdkSandboxDirectory(String volumeUuid, int userId, String packageName)",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "private static File getDataProfilesDeDirectory(int userId)",
    "returnType" : "File",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static File getDataVendorCeDirectory(int userId)",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataVendorDeDirectory(int userId)",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataRefProfilesDePackageDirectory(String packageName)",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataProfilesDePackageDirectory(int userId, String packageName)",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataAppDirectory(String volumeUuid)",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataStagingDirectory(String volumeUuid)",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataUserCeDirectory(String volumeUuid)",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataUserCeDirectory(String volumeUuid, int userId)",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataUserCePackageDirectory(@Nullable String volumeUuid, int userId, @NonNull String packageName)",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataCePackageDirectoryForUser(@NonNull UUID storageUuid, @NonNull UserHandle user, @NonNull String packageName)",
    "returnType" : "File",
    "comment" : "\n     * Retrieve the credential encrypted data directory for a specific package of a specific user.\n     * This is equivalent to {@link ApplicationInfo#credentialProtectedDataDir}, exposed because\n     * fetching a full {@link ApplicationInfo} instance may be expensive if all the caller needs\n     * is this directory.\n     *\n     * @param storageUuid The storage volume for this directory, usually retrieved from a\n     * {@link StorageManager} API or {@link ApplicationInfo#storageUuid}.\n     * @param user The user this directory is for.\n     * @param packageName The app this directory is for.\n     *\n     * @see ApplicationInfo#credentialProtectedDataDir\n     * @return A file to the directory.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.pm.ApplicationInfo#storageUuid", "android.os.storage.StorageManager", "android.content.pm.ApplicationInfo#credentialProtectedDataDir", "android.content.pm.ApplicationInfo" ]
  }, {
    "name" : "public static File getDataUserDeDirectory(String volumeUuid)",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataUserDeDirectory(String volumeUuid, int userId)",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataUserDePackageDirectory(@Nullable String volumeUuid, int userId, @NonNull String packageName)",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataDePackageDirectoryForUser(@NonNull UUID storageUuid, @NonNull UserHandle user, @NonNull String packageName)",
    "returnType" : "File",
    "comment" : "\n     * Retrieve the device encrypted data directory for a specific package of a specific user. This\n     * is equivalent to {@link ApplicationInfo#deviceProtectedDataDir}, exposed because fetching a\n     * full {@link ApplicationInfo} instance may be expensive if all the caller needs is this\n     * directory.\n     *\n     * @param storageUuid The storage volume for this directory, usually retrieved from a\n     * {@link StorageManager} API or {@link ApplicationInfo#storageUuid}.\n     * @param user The user this directory is for.\n     * @param packageName The app this directory is for.\n     *\n     * @see ApplicationInfo#deviceProtectedDataDir\n     * @return A file to the directory.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.pm.ApplicationInfo#storageUuid", "android.os.storage.StorageManager", "android.content.pm.ApplicationInfo#deviceProtectedDataDir", "android.content.pm.ApplicationInfo" ]
  }, {
    "name" : "public static File getDataPreloadsDirectory()",
    "returnType" : "File",
    "comment" : "\n     * Return preloads directory.\n     * <p>This directory may contain pre-loaded content such as\n     * {@link #getDataPreloadsDemoDirectory() demo videos} and\n     * {@link #getDataPreloadsAppsDirectory() APK files} .\n     * {@hide}\n     ",
    "links" : [ "#getDataPreloadsAppsDirectory()", "#getDataPreloadsDemoDirectory()" ]
  }, {
    "name" : "public static File getDataPreloadsDemoDirectory()",
    "returnType" : "File",
    "comment" : "\n     * @see #getDataPreloadsDirectory()\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataPreloadsAppsDirectory()",
    "returnType" : "File",
    "comment" : "\n     * @see #getDataPreloadsDirectory()\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataPreloadsMediaDirectory()",
    "returnType" : "File",
    "comment" : "\n     * @see #getDataPreloadsDirectory()\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataPreloadsFileCacheDirectory(String packageName)",
    "returnType" : "File",
    "comment" : "\n     * Returns location of preloaded cache directory for package name\n     * @see #getDataPreloadsDirectory()\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File getDataPreloadsFileCacheDirectory()",
    "returnType" : "File",
    "comment" : "\n     * Returns location of preloaded cache directory.\n     * @see #getDataPreloadsDirectory()\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File getPackageCacheDirectory()",
    "returnType" : "File",
    "comment" : "\n     * Returns location of packages cache directory.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Collection<File> getInternalMediaDirectories()",
    "returnType" : "Collection<File>",
    "comment" : "\n     * Return locations where media files (such as ringtones, notification\n     * sounds, or alarm sounds) may be located on internal storage. These are\n     * typically indexed under {@link MediaStore#VOLUME_INTERNAL}.\n     *\n     * @hide\n     ",
    "links" : [ "android.provider.MediaStore#VOLUME_INTERNAL" ]
  }, {
    "name" : "private static void addCanonicalFile(List<File> list, File file)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static File getExternalStorageDirectory()",
    "returnType" : "File",
    "comment" : "\n     * Return the primary shared/external storage directory. This directory may\n     * not currently be accessible if it has been mounted by the user on their\n     * computer, has been removed from the device, or some other problem has\n     * happened. You can determine its current state with\n     * {@link #getExternalStorageState()}.\n     * <p>\n     * <em>Note: don't be confused by the word \"external\" here. This directory\n     * can better be thought as media/shared storage. It is a filesystem that\n     * can hold a relatively large amount of data and that is shared across all\n     * applications (does not enforce permissions). Traditionally this is an SD\n     * card, but it may also be implemented as built-in storage in a device that\n     * is distinct from the protected internal storage and can be mounted as a\n     * filesystem on a computer.</em>\n     * <p>\n     * On devices with multiple users (as described by {@link UserManager}),\n     * each user has their own isolated shared storage. Applications only have\n     * access to the shared storage for the user they're running as.\n     * <p>\n     * In devices with multiple shared/external storage directories, this\n     * directory represents the primary storage that the user will interact\n     * with. Access to secondary storage is available through\n     * {@link Context#getExternalFilesDirs(String)},\n     * {@link Context#getExternalCacheDirs()}, and\n     * {@link Context#getExternalMediaDirs()}.\n     * <p>\n     * Applications should not directly use this top-level directory, in order\n     * to avoid polluting the user's root namespace. Any files that are private\n     * to the application should be placed in a directory returned by\n     * {@link android.content.Context#getExternalFilesDir\n     * Context.getExternalFilesDir}, which the system will take care of deleting\n     * if the application is uninstalled. Other shared files should be placed in\n     * one of the directories returned by\n     * {@link #getExternalStoragePublicDirectory}.\n     * <p>\n     * Writing to this path requires the\n     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} permission,\n     * and starting in {@link android.os.Build.VERSION_CODES#KITKAT}, read\n     * access requires the\n     * {@link android.Manifest.permission#READ_EXTERNAL_STORAGE} permission,\n     * which is automatically granted if you hold the write permission.\n     * <p>\n     * Starting in {@link android.os.Build.VERSION_CODES#KITKAT}, if your\n     * application only needs to store internal data, consider using\n     * {@link Context#getExternalFilesDir(String)},\n     * {@link Context#getExternalCacheDir()}, or\n     * {@link Context#getExternalMediaDirs()}, which require no permissions to\n     * read or write.\n     * <p>\n     * This path may change between platform versions, so applications should\n     * only persist relative paths.\n     * <p>\n     * Here is an example of typical code to monitor the state of external\n     * storage:\n     * <p>\n     * {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java\n     * monitor_storage}\n     * <p>\n     * Note that alternatives such as {@link Context#getExternalFilesDir(String)} or\n     * {@link MediaStore} offer better performance.\n     *\n     * @see #getExternalStorageState()\n     * @see #isExternalStorageRemovable()\n     ",
    "links" : [ "android.os.UserManager", "android.content.Context#getExternalCacheDir()", "android.content.Context#getExternalCacheDirs()", "android.content.Context#getExternalMediaDirs()", "android.content.Context#getExternalFilesDir(String)", "android.os.Build.VERSION_CODES#KITKAT", "android.Manifest.permission#WRITE_EXTERNAL_STORAGE", "#getExternalStoragePublicDirectory", "android.content.Context#getExternalFilesDirContext.getExternalFilesDir", "android.Manifest.permission#READ_EXTERNAL_STORAGE", "android.provider.MediaStore", "android.content.Context#getExternalFilesDirs(String)", "#getExternalStorageState()" ]
  }, {
    "name" : "public static File getLegacyExternalStorageDirectory()",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static File getLegacyExternalStorageObbDirectory()",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isStandardDirectory(String dir)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int classifyExternalStorageDirectory(File dir)",
    "returnType" : "int",
    "comment" : "\n     * Classify the content types present on the given external storage device.\n     * <p>\n     * This is typically useful for deciding if an inserted SD card is empty, or\n     * if it contains content like photos that should be preserved.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean hasInterestingFiles(File dir)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean isInterestingFile(File file)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static File getExternalStoragePublicDirectory(String type)",
    "returnType" : "File",
    "comment" : "\n     * Get a top-level shared/external storage directory for placing files of a\n     * particular type. This is where the user will typically place and manage\n     * their own files, so you should be careful about what you put here to\n     * ensure you don't erase their files or get in the way of their own\n     * organization.\n     * <p>\n     * On devices with multiple users (as described by {@link UserManager}),\n     * each user has their own isolated shared storage. Applications only have\n     * access to the shared storage for the user they're running as.\n     * </p>\n     * <p>\n     * Here is an example of typical code to manipulate a picture on the public\n     * shared storage:\n     * </p>\n     * {@sample development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java\n     * public_picture}\n     * <p>\n     * Note that alternatives such as {@link Context#getExternalFilesDir(String)} or\n     * {@link MediaStore} offer better performance.\n     *\n     * @param type The type of storage directory to return. Should be one of\n     *            {@link #DIRECTORY_MUSIC}, {@link #DIRECTORY_PODCASTS},\n     *            {@link #DIRECTORY_RINGTONES}, {@link #DIRECTORY_ALARMS},\n     *            {@link #DIRECTORY_NOTIFICATIONS}, {@link #DIRECTORY_PICTURES},\n     *            {@link #DIRECTORY_MOVIES}, {@link #DIRECTORY_DOWNLOADS},\n     *            {@link #DIRECTORY_DCIM}, or {@link #DIRECTORY_DOCUMENTS}. May not be null.\n     * @return Returns the File path for the directory. Note that this directory\n     *         may not yet exist, so you must make sure it exists before using\n     *         it such as with {@link File#mkdirs File.mkdirs()}.\n     ",
    "links" : [ "android.os.UserManager", "#DIRECTORY_MUSIC", "java.io.File#mkdirs", "#DIRECTORY_PODCASTS", "#DIRECTORY_ALARMS", "#DIRECTORY_RINGTONES", "android.content.Context#getExternalFilesDir(String)", "#DIRECTORY_DCIM", "#DIRECTORY_PICTURES", "#DIRECTORY_DOWNLOADS", "#DIRECTORY_NOTIFICATIONS", "#DIRECTORY_DOCUMENTS", "android.provider.MediaStore", "#DIRECTORY_MOVIES" ]
  }, {
    "name" : "public static File[] buildExternalStorageAndroidDataDirs()",
    "returnType" : "File[]",
    "comment" : "\n     * Returns the path for android-specific data on the SD card.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File[] buildExternalStorageAndroidObbDirs()",
    "returnType" : "File[]",
    "comment" : "\n     * Returns the path for android-specific OBB data on the SD card.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File[] buildExternalStorageAppDataDirs(String packageName)",
    "returnType" : "File[]",
    "comment" : "\n     * Generates the raw path to an application's data\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File[] buildExternalStorageAppMediaDirs(String packageName)",
    "returnType" : "File[]",
    "comment" : "\n     * Generates the raw path to an application's media\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File[] buildExternalStorageAppObbDirs(String packageName)",
    "returnType" : "File[]",
    "comment" : "\n     * Generates the raw path to an application's OBB files\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File[] buildExternalStorageAppFilesDirs(String packageName)",
    "returnType" : "File[]",
    "comment" : "\n     * Generates the path to an application's files.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File[] buildExternalStorageAppCacheDirs(String packageName)",
    "returnType" : "File[]",
    "comment" : "\n     * Generates the path to an application's cache.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File[] buildExternalStoragePublicDirs(@NonNull String dirType)",
    "returnType" : "File[]",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static File getDownloadCacheDirectory()",
    "returnType" : "File",
    "comment" : "\n     * Return the download/cache content directory.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File getMetadataDirectory()",
    "returnType" : "File",
    "comment" : "\n     * Return the metadata directory.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getExternalStorageState()",
    "returnType" : "String",
    "comment" : "\n     * Returns the current state of the primary shared/external storage media.\n     *\n     * @see #getExternalStorageDirectory()\n     * @return one of {@link #MEDIA_UNKNOWN}, {@link #MEDIA_REMOVED},\n     *         {@link #MEDIA_UNMOUNTED}, {@link #MEDIA_CHECKING},\n     *         {@link #MEDIA_NOFS}, {@link #MEDIA_MOUNTED},\n     *         {@link #MEDIA_MOUNTED_READ_ONLY}, {@link #MEDIA_SHARED},\n     *         {@link #MEDIA_BAD_REMOVAL}, or {@link #MEDIA_UNMOUNTABLE}.\n     ",
    "links" : [ "#MEDIA_CHECKING", "#MEDIA_UNKNOWN", "#MEDIA_NOFS", "#MEDIA_UNMOUNTABLE", "#MEDIA_UNMOUNTED", "#MEDIA_MOUNTED", "#MEDIA_SHARED", "#MEDIA_MOUNTED_READ_ONLY", "#MEDIA_BAD_REMOVAL", "#MEDIA_REMOVED" ]
  }, {
    "name" : "public static String getStorageState(File path)",
    "returnType" : "String",
    "comment" : "\n     * @deprecated use {@link #getExternalStorageState(File)}\n     ",
    "links" : [ "#getExternalStorageState(File)" ]
  }, {
    "name" : "public static String getExternalStorageState(File path)",
    "returnType" : "String",
    "comment" : "\n     * Returns the current state of the shared/external storage media at the\n     * given path.\n     *\n     * @return one of {@link #MEDIA_UNKNOWN}, {@link #MEDIA_REMOVED},\n     *         {@link #MEDIA_UNMOUNTED}, {@link #MEDIA_CHECKING},\n     *         {@link #MEDIA_NOFS}, {@link #MEDIA_MOUNTED},\n     *         {@link #MEDIA_MOUNTED_READ_ONLY}, {@link #MEDIA_SHARED},\n     *         {@link #MEDIA_BAD_REMOVAL}, or {@link #MEDIA_UNMOUNTABLE}.\n     ",
    "links" : [ "#MEDIA_CHECKING", "#MEDIA_UNKNOWN", "#MEDIA_NOFS", "#MEDIA_UNMOUNTABLE", "#MEDIA_UNMOUNTED", "#MEDIA_MOUNTED", "#MEDIA_SHARED", "#MEDIA_MOUNTED_READ_ONLY", "#MEDIA_BAD_REMOVAL", "#MEDIA_REMOVED" ]
  }, {
    "name" : "public static boolean isExternalStorageRemovable()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the primary shared/external storage media is physically\n     * removable.\n     *\n     * @return true if the storage device can be removed (such as an SD card),\n     *         or false if the storage device is built in and cannot be\n     *         physically removed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isExternalStorageRemovable(@NonNull File path)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the shared/external storage media at the given path is\n     * physically removable.\n     *\n     * @return true if the storage device can be removed (such as an SD card),\n     *         or false if the storage device is built in and cannot be\n     *         physically removed.\n     * @throws IllegalArgumentException if the path is not a valid storage\n     *             device.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isExternalStorageEmulated()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the primary shared/external storage media is emulated.\n     * <p>\n     * The contents of emulated storage devices are backed by a private user\n     * data partition, which means there is little benefit to apps storing data\n     * here instead of the private directories returned by\n     * {@link Context#getFilesDir()}, etc.\n     * <p>\n     * This returns true when emulated storage is backed by either internal\n     * storage or an adopted storage device.\n     *\n     * @see DevicePolicyManager#setStorageEncryption(android.content.ComponentName,\n     *      boolean)\n     ",
    "links" : [ "android.content.Context#getFilesDir()" ]
  }, {
    "name" : "public static boolean isExternalStorageEmulated(@NonNull File path)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the shared/external storage media at the given path is\n     * emulated.\n     * <p>\n     * The contents of emulated storage devices are backed by a private user\n     * data partition, which means there is little benefit to apps storing data\n     * here instead of the private directories returned by\n     * {@link Context#getFilesDir()}, etc.\n     * <p>\n     * This returns true when emulated storage is backed by either internal\n     * storage or an adopted storage device.\n     *\n     * @throws IllegalArgumentException if the path is not a valid storage\n     *             device.\n     ",
    "links" : [ "android.content.Context#getFilesDir()" ]
  }, {
    "name" : "public static boolean isExternalStorageLegacy()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the shared/external storage media is a\n     * legacy view that includes files not owned by the app.\n     * <p>\n     * This value may be different from the value requested by\n     * {@code requestLegacyExternalStorage} in the app's manifest, since an app\n     * may inherit its legacy state based on when it was first installed, target sdk and other\n     * factors.\n     * <p>\n     * Non-legacy apps can continue to discover and read media belonging to\n     * other apps via {@link android.provider.MediaStore}.\n     ",
    "links" : [ "android.provider.MediaStore" ]
  }, {
    "name" : "public static boolean isExternalStorageLegacy(@NonNull File path)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the shared/external storage media is a\n     * legacy view that includes files not owned by the app.\n     * <p>\n     * This value may be different from the value requested by\n     * {@code requestLegacyExternalStorage} in the app's manifest, since an app\n     * may inherit its legacy state based on when it was first installed, target sdk and other\n     * factors.\n     * <p>\n     * Non-legacy apps can continue to discover and read media belonging to\n     * other apps via {@link android.provider.MediaStore}.\n     *\n     * @throws IllegalArgumentException if the path is not a valid storage\n     * device.\n     ",
    "links" : [ "android.provider.MediaStore" ]
  }, {
    "name" : "private static boolean isScopedStorageEnforced(boolean defaultScopedStorage, boolean forceEnableScopedStorage)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean isScopedStorageDisabled(boolean defaultScopedStorage, boolean forceEnableScopedStorage)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean isExternalStorageManager()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the calling app has All Files Access on the primary shared/external storage\n     * media.\n     * <p>Declaring the permission {@link android.Manifest.permission#MANAGE_EXTERNAL_STORAGE} isn't\n     * enough to gain the access.\n     * <p>To request access, use\n     * {@link android.provider.Settings#ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION}.\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_EXTERNAL_STORAGE", "android.provider.Settings#ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION" ]
  }, {
    "name" : "public static boolean isExternalStorageManager(@NonNull File path)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the calling app has All Files Access at the given {@code path}\n     * <p>Declaring the permission {@link android.Manifest.permission#MANAGE_EXTERNAL_STORAGE} isn't\n     * enough to gain the access.\n     * <p>To request access, use\n     * {@link android.provider.Settings#ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION}.\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_EXTERNAL_STORAGE", "android.provider.Settings#ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION" ]
  }, {
    "name" : " static File getDirectory(String variableName, String defaultPath)",
    "returnType" : "File",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static String getDirectoryPath(@NonNull String variableName, @NonNull String defaultPath)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static void setUserRequired(boolean userRequired)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "private static void throwIfUserRequired()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static File[] buildPaths(File[] base, String... segments)",
    "returnType" : "File[]",
    "comment" : "\n     * Append path segments to each given base path, returning result.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File buildPath(File base, String... segments)",
    "returnType" : "File",
    "comment" : "\n     * Append path segments to given base path, returning result.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static File maybeTranslateEmulatedPathToInternal(File path)",
    "returnType" : "File",
    "comment" : "\n     * If the given path exists on emulated external storage, return the\n     * translated backing path hosted on internal storage. This bypasses any\n     * emulation later, improving performance. This is <em>only</em> suitable\n     * for read-only access.\n     * <p>\n     * Returns original path if given path doesn't meet these criteria. Callers\n     * must hold {@link android.Manifest.permission#WRITE_MEDIA_STORAGE}\n     * permission.\n     *\n     * @deprecated disabled now that FUSE has been replaced by sdcardfs\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#WRITE_MEDIA_STORAGE" ]
  } ],
  "methodNames" : [ "public static void initForCurrentUser()", "public static File getRootDirectory()", "public static File getStorageDirectory()", "public static File getOemDirectory()", "public static File getOdmDirectory()", "public static File getVendorDirectory()", "public static File getProductDirectory()", "public static File getProductServicesDirectory()", "public static File getSystemExtDirectory()", "public static File getApexDirectory()", "public static File getUserSystemDirectory(int userId)", "public static File getUserConfigDirectory(int userId)", "public static File getDataDirectory()", "public static String getDataDirectoryPath()", "public static File getDataDirectory(String volumeUuid)", "public static String getDataDirectoryPath(String volumeUuid)", "public static File getExpandDirectory()", "public static File getDataSystemDirectory()", "public static File getDataSystemDeDirectory()", "public static File getDataSystemCeDirectory()", "public static File getDataSystemCeDirectory(int userId)", "public static File getDataSystemDeDirectory(int userId)", "public static File getDataMiscDirectory()", "public static File getDataMiscCeDirectory()", "public static File getDataMiscCeDirectory(int userId)", "private static File getDataMiscCeDirectory(String volumeUuid, int userId)", "public static File getDataMiscCeSharedSdkSandboxDirectory(String volumeUuid, int userId, String packageName)", "public static File getDataMiscDeDirectory(int userId)", "private static File getDataMiscDeDirectory(String volumeUuid, int userId)", "public static File getDataMiscDeSharedSdkSandboxDirectory(String volumeUuid, int userId, String packageName)", "private static File getDataProfilesDeDirectory(int userId)", "public static File getDataVendorCeDirectory(int userId)", "public static File getDataVendorDeDirectory(int userId)", "public static File getDataRefProfilesDePackageDirectory(String packageName)", "public static File getDataProfilesDePackageDirectory(int userId, String packageName)", "public static File getDataAppDirectory(String volumeUuid)", "public static File getDataStagingDirectory(String volumeUuid)", "public static File getDataUserCeDirectory(String volumeUuid)", "public static File getDataUserCeDirectory(String volumeUuid, int userId)", "public static File getDataUserCePackageDirectory(@Nullable String volumeUuid, int userId, @NonNull String packageName)", "public static File getDataCePackageDirectoryForUser(@NonNull UUID storageUuid, @NonNull UserHandle user, @NonNull String packageName)", "public static File getDataUserDeDirectory(String volumeUuid)", "public static File getDataUserDeDirectory(String volumeUuid, int userId)", "public static File getDataUserDePackageDirectory(@Nullable String volumeUuid, int userId, @NonNull String packageName)", "public static File getDataDePackageDirectoryForUser(@NonNull UUID storageUuid, @NonNull UserHandle user, @NonNull String packageName)", "public static File getDataPreloadsDirectory()", "public static File getDataPreloadsDemoDirectory()", "public static File getDataPreloadsAppsDirectory()", "public static File getDataPreloadsMediaDirectory()", "public static File getDataPreloadsFileCacheDirectory(String packageName)", "public static File getDataPreloadsFileCacheDirectory()", "public static File getPackageCacheDirectory()", "public static Collection<File> getInternalMediaDirectories()", "private static void addCanonicalFile(List<File> list, File file)", "public static File getExternalStorageDirectory()", "public static File getLegacyExternalStorageDirectory()", "public static File getLegacyExternalStorageObbDirectory()", "public static boolean isStandardDirectory(String dir)", "public static int classifyExternalStorageDirectory(File dir)", "private static boolean hasInterestingFiles(File dir)", "private static boolean isInterestingFile(File file)", "public static File getExternalStoragePublicDirectory(String type)", "public static File[] buildExternalStorageAndroidDataDirs()", "public static File[] buildExternalStorageAndroidObbDirs()", "public static File[] buildExternalStorageAppDataDirs(String packageName)", "public static File[] buildExternalStorageAppMediaDirs(String packageName)", "public static File[] buildExternalStorageAppObbDirs(String packageName)", "public static File[] buildExternalStorageAppFilesDirs(String packageName)", "public static File[] buildExternalStorageAppCacheDirs(String packageName)", "public static File[] buildExternalStoragePublicDirs(@NonNull String dirType)", "public static File getDownloadCacheDirectory()", "public static File getMetadataDirectory()", "public static String getExternalStorageState()", "public static String getStorageState(File path)", "public static String getExternalStorageState(File path)", "public static boolean isExternalStorageRemovable()", "public static boolean isExternalStorageRemovable(@NonNull File path)", "public static boolean isExternalStorageEmulated()", "public static boolean isExternalStorageEmulated(@NonNull File path)", "public static boolean isExternalStorageLegacy()", "public static boolean isExternalStorageLegacy(@NonNull File path)", "private static boolean isScopedStorageEnforced(boolean defaultScopedStorage, boolean forceEnableScopedStorage)", "private static boolean isScopedStorageDisabled(boolean defaultScopedStorage, boolean forceEnableScopedStorage)", "public static boolean isExternalStorageManager()", "public static boolean isExternalStorageManager(@NonNull File path)", " static File getDirectory(String variableName, String defaultPath)", " static String getDirectoryPath(@NonNull String variableName, @NonNull String defaultPath)", "public static void setUserRequired(boolean userRequired)", "private static void throwIfUserRequired()", "public static File[] buildPaths(File[] base, String... segments)", "public static File buildPath(File base, String... segments)", "public static File maybeTranslateEmulatedPathToInternal(File path)" ],
  "variableNames" : [ "TAG", "ENV_EXTERNAL_STORAGE", "ENV_ANDROID_ROOT", "ENV_ANDROID_DATA", "ENV_ANDROID_EXPAND", "ENV_ANDROID_STORAGE", "ENV_DOWNLOAD_CACHE", "ENV_OEM_ROOT", "ENV_ODM_ROOT", "ENV_VENDOR_ROOT", "ENV_PRODUCT_ROOT", "ENV_SYSTEM_EXT_ROOT", "ENV_APEX_ROOT", "DIR_ANDROID", "DIR_DATA", "DIR_MEDIA", "DIR_OBB", "DIR_FILES", "DIR_CACHE", "DIR_USER_CE", "DIR_USER_DE", "DIRECTORY_ANDROID", "DIR_ANDROID_ROOT", "DIR_ANDROID_DATA_PATH", "DIR_ANDROID_DATA", "DIR_ANDROID_EXPAND", "DIR_ANDROID_STORAGE", "DIR_DOWNLOAD_CACHE", "DIR_METADATA", "DIR_OEM_ROOT", "DIR_ODM_ROOT", "DIR_VENDOR_ROOT", "DIR_PRODUCT_ROOT", "DIR_SYSTEM_EXT_ROOT", "DIR_APEX_ROOT", "DEFAULT_SCOPED_STORAGE", "FORCE_ENABLE_SCOPED_STORAGE", "sCurrentUser", "sUserRequired", "DIRECTORY_MUSIC", "DIRECTORY_PODCASTS", "DIRECTORY_RINGTONES", "DIRECTORY_ALARMS", "DIRECTORY_NOTIFICATIONS", "DIRECTORY_PICTURES", "DIRECTORY_MOVIES", "DIRECTORY_DOWNLOADS", "DIRECTORY_DCIM", "DIRECTORY_DOCUMENTS", "DIRECTORY_SCREENSHOTS", "DIRECTORY_AUDIOBOOKS", "DIRECTORY_RECORDINGS", "STANDARD_DIRECTORIES", "HAS_MUSIC", "HAS_PODCASTS", "HAS_RINGTONES", "HAS_ALARMS", "HAS_NOTIFICATIONS", "HAS_PICTURES", "HAS_MOVIES", "HAS_DOWNLOADS", "HAS_DCIM", "HAS_DOCUMENTS", "HAS_AUDIOBOOKS", "HAS_RECORDINGS", "HAS_ANDROID", "HAS_OTHER", "MEDIA_UNKNOWN", "MEDIA_REMOVED", "MEDIA_UNMOUNTED", "MEDIA_CHECKING", "MEDIA_NOFS", "MEDIA_MOUNTED", "MEDIA_MOUNTED_READ_ONLY", "MEDIA_SHARED", "MEDIA_BAD_REMOVAL", "MEDIA_UNMOUNTABLE", "MEDIA_EJECTING" ]
}