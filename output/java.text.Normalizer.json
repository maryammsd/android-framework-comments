{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/text/Normalizer.java",
  "packageName" : "java.text",
  "className" : "Normalizer",
  "comment" : "\n * This class provides the method {@code normalize} which transforms Unicode\n * text into an equivalent composed or decomposed form, allowing for easier\n * sorting and searching of text.\n * The {@code normalize} method supports the standard normalization forms\n * described in\n * <a href=\"https://www.unicode.org/reports/tr15/\">\n * Unicode Standard Annex #15 &mdash; Unicode Normalization Forms</a>.\n * <p>\n * Characters with accents or other adornments can be encoded in\n * several different ways in Unicode.  For example, take the character A-acute.\n * In Unicode, this can be encoded as a single character (the \"composed\" form):\n *\n * <pre>\n *      U+00C1    LATIN CAPITAL LETTER A WITH ACUTE</pre>\n *\n * or as two separate characters (the \"decomposed\" form):\n *\n * <pre>\n *      U+0041    LATIN CAPITAL LETTER A\n *      U+0301    COMBINING ACUTE ACCENT</pre>\n *\n * To a user of your program, however, both of these sequences should be\n * treated as the same \"user-level\" character \"A with acute accent\".  When you\n * are searching or comparing text, you must ensure that these two sequences are\n * treated as equivalent.  In addition, you must handle characters with more than\n * one accent. Sometimes the order of a character's combining accents is\n * significant, while in other cases accent sequences in different orders are\n * really equivalent.\n * <p>\n * Similarly, the string \"ffi\" can be encoded as three separate letters:\n *\n * <pre>\n *      U+0066    LATIN SMALL LETTER F\n *      U+0066    LATIN SMALL LETTER F\n *      U+0069    LATIN SMALL LETTER I</pre>\n *\n * or as the single character\n *\n * <pre>\n *      U+FB03    LATIN SMALL LIGATURE FFI</pre>\n *\n * The ffi ligature is not a distinct semantic character, and strictly speaking\n * it shouldn't be in Unicode at all, but it was included for compatibility\n * with existing character sets that already provided it.  The Unicode standard\n * identifies such characters by giving them \"compatibility\" decompositions\n * into the corresponding semantic characters.  When sorting and searching, you\n * will often want to use these mappings.\n * <p>\n * The {@code normalize} method helps solve these problems by transforming\n * text into the canonical composed and decomposed forms as shown in the first\n * example above. In addition, you can have it perform compatibility\n * decompositions so that you can treat compatibility characters the same as\n * their equivalents.\n * Finally, the {@code normalize} method rearranges accents into the\n * proper canonical order, so that you do not have to worry about accent\n * rearrangement on your own.\n * <p>\n * The W3C generally recommends to exchange texts in NFC.\n * Note also that most legacy character encodings use only precomposed forms and\n * often do not encode any combining marks by themselves. For conversion to such\n * character encodings the Unicode text needs to be normalized to NFC.\n * For more usage examples, see the Unicode Standard Annex.\n *\n * @since 1.6\n ",
  "links" : [ ],
  "variables" : [ ],
  "methods" : [ {
    "name" : "public static String normalize(CharSequence src, Form form)",
    "returnType" : "String",
    "comment" : "\n     * Normalize a sequence of char values.\n     * The sequence will be normalized according to the specified normalization\n     * form.\n     * @param src        The sequence of char values to normalize.\n     * @param form       The normalization form; one of\n     *                   {@link java.text.Normalizer.Form#NFC},\n     *                   {@link java.text.Normalizer.Form#NFD},\n     *                   {@link java.text.Normalizer.Form#NFKC},\n     *                   {@link java.text.Normalizer.Form#NFKD}\n     * @return The normalized String\n     * @throws NullPointerException If {@code src} or {@code form}\n     * is null.\n     ",
    "links" : [ "java.text.Normalizer.Form#NFC", "java.text.Normalizer.Form#NFD", "java.text.Normalizer.Form#NFKC", "java.text.Normalizer.Form#NFKD" ]
  }, {
    "name" : "public static boolean isNormalized(CharSequence src, Form form)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the given sequence of char values is normalized.\n     * @param src        The sequence of char values to be checked.\n     * @param form       The normalization form; one of\n     *                   {@link java.text.Normalizer.Form#NFC},\n     *                   {@link java.text.Normalizer.Form#NFD},\n     *                   {@link java.text.Normalizer.Form#NFKC},\n     *                   {@link java.text.Normalizer.Form#NFKD}\n     * @return true if the sequence of char values is normalized;\n     * false otherwise.\n     * @throws NullPointerException If {@code src} or {@code form}\n     * is null.\n     ",
    "links" : [ "java.text.Normalizer.Form#NFC", "java.text.Normalizer.Form#NFD", "java.text.Normalizer.Form#NFKC", "java.text.Normalizer.Form#NFKD" ]
  } ],
  "methodNames" : [ "public static String normalize(CharSequence src, Form form)", "public static boolean isNormalized(CharSequence src, Form form)" ],
  "variableNames" : [ ]
}