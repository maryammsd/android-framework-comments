{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/hardware/SensorManager.java",
  "packageName" : "android.hardware",
  "className" : "SensorManager",
  "comment" : "\n * <p>\n * SensorManager lets you access the device's {@link android.hardware.Sensor\n * sensors}.\n * </p>\n * <p>\n * Always make sure to disable sensors you don't need, especially when your\n * activity is paused. Failing to do so can drain the battery in just a few\n * hours. Note that the system will <i>not</i> disable sensors automatically when\n * the screen turns off.\n * </p>\n * <p class=\"note\">\n * Note: Don't use this mechanism with a Trigger Sensor, have a look\n * at {@link TriggerEventListener}. {@link Sensor#TYPE_SIGNIFICANT_MOTION}\n * is an example of a trigger sensor.\n * </p>\n * <p>\n * In order to access sensor data at high sampling rates (i.e. greater than 200 Hz\n * for {@link SensorEventListener} and greater than {@link SensorDirectChannel#RATE_NORMAL}\n * for {@link SensorDirectChannel}), apps must declare\n * the {@link android.Manifest.permission#HIGH_SAMPLING_RATE_SENSORS} permission\n * in their AndroidManifest.xml file.\n * </p>\n * <pre class=\"prettyprint\">\n * public class SensorActivity extends Activity implements SensorEventListener {\n *     private final SensorManager mSensorManager;\n *     private final Sensor mAccelerometer;\n *\n *     public SensorActivity() {\n *         mSensorManager = (SensorManager)getSystemService(SENSOR_SERVICE);\n *         mAccelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);\n *     }\n *\n *     protected void onResume() {\n *         super.onResume();\n *         mSensorManager.registerListener(this, mAccelerometer, SensorManager.SENSOR_DELAY_NORMAL);\n *     }\n *\n *     protected void onPause() {\n *         super.onPause();\n *         mSensorManager.unregisterListener(this);\n *     }\n *\n *     public void onAccuracyChanged(Sensor sensor, int accuracy) {\n *     }\n *\n *     public void onSensorChanged(SensorEvent event) {\n *     }\n * }\n * </pre>\n *\n * @see SensorEventListener\n * @see SensorEvent\n * @see Sensor\n *\n ",
  "links" : [ "android.hardware.SensorDirectChannel#RATE_NORMAL", "android.Manifest.permission#HIGH_SAMPLING_RATE_SENSORS", "android.hardware.SensorDirectChannel", "android.hardware.TriggerEventListener", "android.hardware.SensorEventListener", "android.hardware.Sensorsensors", "android.hardware.Sensor#TYPE_SIGNIFICANT_MOTION" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "sTempMatrix",
    "type" : "float[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSensorListByType",
    "type" : "SparseArray<List<Sensor>>",
    "comment" : " Cached lists of sensors by type.  Guarded by mSensorListByType.",
    "links" : [ ]
  }, {
    "name" : "mLegacySensorManager",
    "type" : "LegacySensorManager",
    "comment" : " Legacy sensor manager implementation.  Guarded by mSensorListByType during initialization.",
    "links" : [ ]
  }, {
    "name" : "SENSOR_ORIENTATION",
    "type" : "int",
    "comment" : "\n     * A constant describing an orientation sensor. See\n     * {@link android.hardware.SensorListener SensorListener} for more details.\n     *\n     * @deprecated use {@link android.hardware.Sensor Sensor} instead.\n     ",
    "links" : [ "android.hardware.SensorListener", "android.hardware.Sensor" ]
  }, {
    "name" : "SENSOR_ACCELEROMETER",
    "type" : "int",
    "comment" : "\n     * A constant describing an accelerometer. See\n     * {@link android.hardware.SensorListener SensorListener} for more details.\n     *\n     * @deprecated use {@link android.hardware.Sensor Sensor} instead.\n     ",
    "links" : [ "android.hardware.SensorListener", "android.hardware.Sensor" ]
  }, {
    "name" : "SENSOR_TEMPERATURE",
    "type" : "int",
    "comment" : "\n     * A constant describing a temperature sensor See\n     * {@link android.hardware.SensorListener SensorListener} for more details.\n     *\n     * @deprecated use {@link android.hardware.Sensor Sensor} instead.\n     ",
    "links" : [ "android.hardware.SensorListener", "android.hardware.Sensor" ]
  }, {
    "name" : "SENSOR_MAGNETIC_FIELD",
    "type" : "int",
    "comment" : "\n     * A constant describing a magnetic sensor See\n     * {@link android.hardware.SensorListener SensorListener} for more details.\n     *\n     * @deprecated use {@link android.hardware.Sensor Sensor} instead.\n     ",
    "links" : [ "android.hardware.SensorListener", "android.hardware.Sensor" ]
  }, {
    "name" : "SENSOR_LIGHT",
    "type" : "int",
    "comment" : "\n     * A constant describing an ambient light sensor See\n     * {@link android.hardware.SensorListener SensorListener} for more details.\n     *\n     * @deprecated use {@link android.hardware.Sensor Sensor} instead.\n     ",
    "links" : [ "android.hardware.SensorListener", "android.hardware.Sensor" ]
  }, {
    "name" : "SENSOR_PROXIMITY",
    "type" : "int",
    "comment" : "\n     * A constant describing a proximity sensor See\n     * {@link android.hardware.SensorListener SensorListener} for more details.\n     *\n     * @deprecated use {@link android.hardware.Sensor Sensor} instead.\n     ",
    "links" : [ "android.hardware.SensorListener", "android.hardware.Sensor" ]
  }, {
    "name" : "SENSOR_TRICORDER",
    "type" : "int",
    "comment" : "\n     * A constant describing a Tricorder See\n     * {@link android.hardware.SensorListener SensorListener} for more details.\n     *\n     * @deprecated use {@link android.hardware.Sensor Sensor} instead.\n     ",
    "links" : [ "android.hardware.SensorListener", "android.hardware.Sensor" ]
  }, {
    "name" : "SENSOR_ORIENTATION_RAW",
    "type" : "int",
    "comment" : "\n     * A constant describing an orientation sensor. See\n     * {@link android.hardware.SensorListener SensorListener} for more details.\n     *\n     * @deprecated use {@link android.hardware.Sensor Sensor} instead.\n     ",
    "links" : [ "android.hardware.SensorListener", "android.hardware.Sensor" ]
  }, {
    "name" : "SENSOR_ALL",
    "type" : "int",
    "comment" : "\n     * A constant that includes all sensors\n     *\n     * @deprecated use {@link android.hardware.Sensor Sensor} instead.\n     ",
    "links" : [ "android.hardware.Sensor" ]
  }, {
    "name" : "SENSOR_MIN",
    "type" : "int",
    "comment" : "\n     * Smallest sensor ID\n     *\n     * @deprecated use {@link android.hardware.Sensor Sensor} instead.\n     ",
    "links" : [ "android.hardware.Sensor" ]
  }, {
    "name" : "SENSOR_MAX",
    "type" : "int",
    "comment" : "\n     * Largest sensor ID\n     *\n     * @deprecated use {@link android.hardware.Sensor Sensor} instead.\n     ",
    "links" : [ "android.hardware.Sensor" ]
  }, {
    "name" : "DATA_X",
    "type" : "int",
    "comment" : "\n     * Index of the X value in the array returned by\n     * {@link android.hardware.SensorListener#onSensorChanged}\n     *\n     * @deprecated use {@link android.hardware.Sensor Sensor} instead.\n     ",
    "links" : [ "android.hardware.SensorListener#onSensorChanged", "android.hardware.Sensor" ]
  }, {
    "name" : "DATA_Y",
    "type" : "int",
    "comment" : "\n     * Index of the Y value in the array returned by\n     * {@link android.hardware.SensorListener#onSensorChanged}\n     *\n     * @deprecated use {@link android.hardware.Sensor Sensor} instead.\n     ",
    "links" : [ "android.hardware.SensorListener#onSensorChanged", "android.hardware.Sensor" ]
  }, {
    "name" : "DATA_Z",
    "type" : "int",
    "comment" : "\n     * Index of the Z value in the array returned by\n     * {@link android.hardware.SensorListener#onSensorChanged}\n     *\n     * @deprecated use {@link android.hardware.Sensor Sensor} instead.\n     ",
    "links" : [ "android.hardware.SensorListener#onSensorChanged", "android.hardware.Sensor" ]
  }, {
    "name" : "RAW_DATA_INDEX",
    "type" : "int",
    "comment" : "\n     * Offset to the untransformed values in the array returned by\n     * {@link android.hardware.SensorListener#onSensorChanged}\n     *\n     * @deprecated use {@link android.hardware.Sensor Sensor} instead.\n     ",
    "links" : [ "android.hardware.SensorListener#onSensorChanged", "android.hardware.Sensor" ]
  }, {
    "name" : "RAW_DATA_X",
    "type" : "int",
    "comment" : "\n     * Index of the untransformed X value in the array returned by\n     * {@link android.hardware.SensorListener#onSensorChanged}\n     *\n     * @deprecated use {@link android.hardware.Sensor Sensor} instead.\n     ",
    "links" : [ "android.hardware.SensorListener#onSensorChanged", "android.hardware.Sensor" ]
  }, {
    "name" : "RAW_DATA_Y",
    "type" : "int",
    "comment" : "\n     * Index of the untransformed Y value in the array returned by\n     * {@link android.hardware.SensorListener#onSensorChanged}\n     *\n     * @deprecated use {@link android.hardware.Sensor Sensor} instead.\n     ",
    "links" : [ "android.hardware.SensorListener#onSensorChanged", "android.hardware.Sensor" ]
  }, {
    "name" : "RAW_DATA_Z",
    "type" : "int",
    "comment" : "\n     * Index of the untransformed Z value in the array returned by\n     * {@link android.hardware.SensorListener#onSensorChanged}\n     *\n     * @deprecated use {@link android.hardware.Sensor Sensor} instead.\n     ",
    "links" : [ "android.hardware.SensorListener#onSensorChanged", "android.hardware.Sensor" ]
  }, {
    "name" : "STANDARD_GRAVITY",
    "type" : "float",
    "comment" : " Standard gravity (g) on Earth. This value is equivalent to 1G ",
    "links" : [ ]
  }, {
    "name" : "GRAVITY_SUN",
    "type" : "float",
    "comment" : " Sun's gravity in SI units (m/s^2) ",
    "links" : [ ]
  }, {
    "name" : "GRAVITY_MERCURY",
    "type" : "float",
    "comment" : " Mercury's gravity in SI units (m/s^2) ",
    "links" : [ ]
  }, {
    "name" : "GRAVITY_VENUS",
    "type" : "float",
    "comment" : " Venus' gravity in SI units (m/s^2) ",
    "links" : [ ]
  }, {
    "name" : "GRAVITY_EARTH",
    "type" : "float",
    "comment" : " Earth's gravity in SI units (m/s^2) ",
    "links" : [ ]
  }, {
    "name" : "GRAVITY_MOON",
    "type" : "float",
    "comment" : " The Moon's gravity in SI units (m/s^2) ",
    "links" : [ ]
  }, {
    "name" : "GRAVITY_MARS",
    "type" : "float",
    "comment" : " Mars' gravity in SI units (m/s^2) ",
    "links" : [ ]
  }, {
    "name" : "GRAVITY_JUPITER",
    "type" : "float",
    "comment" : " Jupiter's gravity in SI units (m/s^2) ",
    "links" : [ ]
  }, {
    "name" : "GRAVITY_SATURN",
    "type" : "float",
    "comment" : " Saturn's gravity in SI units (m/s^2) ",
    "links" : [ ]
  }, {
    "name" : "GRAVITY_URANUS",
    "type" : "float",
    "comment" : " Uranus' gravity in SI units (m/s^2) ",
    "links" : [ ]
  }, {
    "name" : "GRAVITY_NEPTUNE",
    "type" : "float",
    "comment" : " Neptune's gravity in SI units (m/s^2) ",
    "links" : [ ]
  }, {
    "name" : "GRAVITY_PLUTO",
    "type" : "float",
    "comment" : " Pluto's gravity in SI units (m/s^2) ",
    "links" : [ ]
  }, {
    "name" : "GRAVITY_DEATH_STAR_I",
    "type" : "float",
    "comment" : " Gravity (estimate) on the first Death Star in Empire units (m/s^2) ",
    "links" : [ ]
  }, {
    "name" : "GRAVITY_THE_ISLAND",
    "type" : "float",
    "comment" : " Gravity on the island ",
    "links" : [ ]
  }, {
    "name" : "MAGNETIC_FIELD_EARTH_MAX",
    "type" : "float",
    "comment" : " Maximum magnetic field on Earth's surface ",
    "links" : [ ]
  }, {
    "name" : "MAGNETIC_FIELD_EARTH_MIN",
    "type" : "float",
    "comment" : " Minimum magnetic field on Earth's surface ",
    "links" : [ ]
  }, {
    "name" : "PRESSURE_STANDARD_ATMOSPHERE",
    "type" : "float",
    "comment" : " Standard atmosphere, or average sea-level pressure in hPa (millibar) ",
    "links" : [ ]
  }, {
    "name" : "LIGHT_SUNLIGHT_MAX",
    "type" : "float",
    "comment" : " Maximum luminance of sunlight in lux ",
    "links" : [ ]
  }, {
    "name" : "LIGHT_SUNLIGHT",
    "type" : "float",
    "comment" : " luminance of sunlight in lux ",
    "links" : [ ]
  }, {
    "name" : "LIGHT_SHADE",
    "type" : "float",
    "comment" : " luminance in shade in lux ",
    "links" : [ ]
  }, {
    "name" : "LIGHT_OVERCAST",
    "type" : "float",
    "comment" : " luminance under an overcast sky in lux ",
    "links" : [ ]
  }, {
    "name" : "LIGHT_SUNRISE",
    "type" : "float",
    "comment" : " luminance at sunrise in lux ",
    "links" : [ ]
  }, {
    "name" : "LIGHT_CLOUDY",
    "type" : "float",
    "comment" : " luminance under a cloudy sky in lux ",
    "links" : [ ]
  }, {
    "name" : "LIGHT_FULLMOON",
    "type" : "float",
    "comment" : " luminance at night with full moon in lux ",
    "links" : [ ]
  }, {
    "name" : "LIGHT_NO_MOON",
    "type" : "float",
    "comment" : " luminance at night with no moon in lux",
    "links" : [ ]
  }, {
    "name" : "SENSOR_DELAY_FASTEST",
    "type" : "int",
    "comment" : " get sensor data as fast as possible ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_DELAY_GAME",
    "type" : "int",
    "comment" : " rate suitable for games ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_DELAY_UI",
    "type" : "int",
    "comment" : " rate suitable for the user interface  ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_DELAY_NORMAL",
    "type" : "int",
    "comment" : " rate (default) suitable for screen orientation changes ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_STATUS_NO_CONTACT",
    "type" : "int",
    "comment" : "\n      * The values returned by this sensor cannot be trusted because the sensor\n      * had no contact with what it was measuring (for example, the heart rate\n      * monitor is not in contact with the user).\n      ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_STATUS_UNRELIABLE",
    "type" : "int",
    "comment" : "\n     * The values returned by this sensor cannot be trusted, calibration is\n     * needed or the environment doesn't allow readings\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_STATUS_ACCURACY_LOW",
    "type" : "int",
    "comment" : "\n     * This sensor is reporting data with low accuracy, calibration with the\n     * environment is needed\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_STATUS_ACCURACY_MEDIUM",
    "type" : "int",
    "comment" : "\n     * This sensor is reporting data with an average level of accuracy,\n     * calibration with the environment may improve the readings\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_STATUS_ACCURACY_HIGH",
    "type" : "int",
    "comment" : " This sensor is reporting data with maximum accuracy ",
    "links" : [ ]
  }, {
    "name" : "AXIS_X",
    "type" : "int",
    "comment" : " see {@link #remapCoordinateSystem} ",
    "links" : [ "#remapCoordinateSystem" ]
  }, {
    "name" : "AXIS_Y",
    "type" : "int",
    "comment" : " see {@link #remapCoordinateSystem} ",
    "links" : [ "#remapCoordinateSystem" ]
  }, {
    "name" : "AXIS_Z",
    "type" : "int",
    "comment" : " see {@link #remapCoordinateSystem} ",
    "links" : [ "#remapCoordinateSystem" ]
  }, {
    "name" : "AXIS_MINUS_X",
    "type" : "int",
    "comment" : " see {@link #remapCoordinateSystem} ",
    "links" : [ "#remapCoordinateSystem" ]
  }, {
    "name" : "AXIS_MINUS_Y",
    "type" : "int",
    "comment" : " see {@link #remapCoordinateSystem} ",
    "links" : [ "#remapCoordinateSystem" ]
  }, {
    "name" : "AXIS_MINUS_Z",
    "type" : "int",
    "comment" : " see {@link #remapCoordinateSystem} ",
    "links" : [ "#remapCoordinateSystem" ]
  }, {
    "name" : "DATA_INJECTION",
    "type" : "int",
    "comment" : "\n     * This mode is only used for testing purposes. Not all HALs support this mode. In this mode,\n     * the HAL ignores the sensor data provided by physical sensors and accepts the data that is\n     * injected from the SensorService as if it were the real sensor data. This mode is primarily\n     * used for testing various algorithms like vendor provided SensorFusion, Step Counter and\n     * Step Detector etc. Typically, in this mode, there is a client app which injects\n     * sensor data into the HAL. Normal apps can register and unregister for any sensor\n     * that supports injection. Registering to sensors that do not support injection will\n     * give an error.\n     * This is the default data injection mode.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REPLAY_DATA_INJECTION",
    "type" : "int",
    "comment" : "\n     * Mostly equivalent to DATA_INJECTION with the difference being that the injected data is\n     * delivered to all requesting apps rather than just the package allowed to inject data.\n     * This mode is only allowed to be used on development builds.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "HAL_BYPASS_REPLAY_DATA_INJECTION",
    "type" : "int",
    "comment" : "\n     * Like REPLAY_DATA_INJECTION but injected data is not sent into the HAL. It is stored in a\n     * buffer in the platform and played back to all requesting apps.\n     * This is useful for playing back sensor data to test platform components without\n     * relying on the HAL to support data injection.\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "protected abstract List<Sensor> getFullSensorList()",
    "returnType" : "List<Sensor>",
    "comment" : "\n     * Gets the full list of sensors that are available.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected abstract List<Sensor> getFullDynamicSensorList()",
    "returnType" : "List<Sensor>",
    "comment" : "\n     * Gets the full list of dynamic sensors that are available.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getSensors()",
    "returnType" : "int",
    "comment" : "\n     * @return available sensors.\n     * @deprecated This method is deprecated, use\n     *             {@link SensorManager#getSensorList(int)} instead\n     ",
    "links" : [ "android.hardware.SensorManager#getSensorList(int)" ]
  }, {
    "name" : "public List<Sensor> getSensorList(int type)",
    "returnType" : "List<Sensor>",
    "comment" : "\n     * Use this method to get the list of available sensors of a certain type.\n     * Make multiple calls to get sensors of different types or use\n     * {@link android.hardware.Sensor#TYPE_ALL Sensor.TYPE_ALL} to get all the\n     * sensors. Note that the {@link android.hardware.Sensor#getName()} is\n     * expected to yield a value that is unique across any sensors that return\n     * the same value for {@link android.hardware.Sensor#getType()}.\n     *\n     * <p class=\"note\">\n     * NOTE: Both wake-up and non wake-up sensors matching the given type are\n     * returned. Check {@link Sensor#isWakeUpSensor()} to know the wake-up properties\n     * of the returned {@link Sensor}.\n     * </p>\n     *\n     * @param type\n     *        of sensors requested\n     *\n     * @return a list of sensors matching the asked type.\n     *\n     * @see #getDefaultSensor(int)\n     * @see Sensor\n     ",
    "links" : [ "android.hardware.Sensor#getName()", "android.hardware.Sensor#TYPE_ALL", "android.hardware.Sensor#isWakeUpSensor()", "android.hardware.Sensor", "android.hardware.Sensor#getType()" ]
  }, {
    "name" : "public Sensor getSensorByHandle(int sensorHandle)",
    "returnType" : "Sensor",
    "comment" : "\n     * Returns the {@link Sensor} object identified by the given sensor handle.\n     *\n     * The raw sensor handle integer is an implementation detail and as such this method should only\n     * be used by internal system components.\n     *\n     * @param sensorHandle The integer handle uniquely identifying the sensor.\n     * @return A Sensor object identified by the given {@code sensorHandle}, if such a sensor\n     * exists, {@code null} otherwise.\n     *\n     * @hide\n     ",
    "links" : [ "android.hardware.Sensor" ]
  }, {
    "name" : "public List<Sensor> getDynamicSensorList(int type)",
    "returnType" : "List<Sensor>",
    "comment" : "\n     * Use this method to get a list of available dynamic sensors of a certain type.\n     * Make multiple calls to get sensors of different types or use\n     * {@link android.hardware.Sensor#TYPE_ALL Sensor.TYPE_ALL} to get all dynamic sensors.\n     *\n     * <p class=\"note\">\n     * NOTE: Both wake-up and non wake-up sensors matching the given type are\n     * returned. Check {@link Sensor#isWakeUpSensor()} to know the wake-up properties\n     * of the returned {@link Sensor}.\n     * </p>\n     *\n     * @param type of sensors requested\n     *\n     * @return a list of dynamic sensors matching the requested type.\n     *\n     * @see Sensor\n     ",
    "links" : [ "android.hardware.Sensor#TYPE_ALL", "android.hardware.Sensor#isWakeUpSensor()", "android.hardware.Sensor" ]
  }, {
    "name" : "public Sensor getDefaultSensor(int type)",
    "returnType" : "Sensor",
    "comment" : "\n     * Use this method to get the default sensor for a given type. Note that the\n     * returned sensor could be a composite sensor, and its data could be\n     * averaged or filtered. If you need to access the raw sensors use\n     * {@link SensorManager#getSensorList(int) getSensorList}.\n     *\n     * @param type\n     *         of sensors requested\n     *\n     * @return the default sensor matching the requested type if one exists and the application\n     *         has the necessary permissions, or null otherwise.\n     *\n     * @see #getSensorList(int)\n     * @see Sensor\n     ",
    "links" : [ "android.hardware.SensorManager#getSensorList(int)" ]
  }, {
    "name" : "public Sensor getDefaultSensor(int type, boolean wakeUp)",
    "returnType" : "Sensor",
    "comment" : "\n     * Return a Sensor with the given type and wakeUp properties. If multiple sensors of this\n     * type exist, any one of them may be returned.\n     * <p>\n     * For example,\n     * <ul>\n     *     <li>getDefaultSensor({@link Sensor#TYPE_ACCELEROMETER}, true) returns a wake-up\n     *     accelerometer sensor if it exists. </li>\n     *     <li>getDefaultSensor({@link Sensor#TYPE_PROXIMITY}, false) returns a non wake-up\n     *     proximity sensor if it exists. </li>\n     *     <li>getDefaultSensor({@link Sensor#TYPE_PROXIMITY}, true) returns a wake-up proximity\n     *     sensor which is the same as the Sensor returned by {@link #getDefaultSensor(int)}. </li>\n     * </ul>\n     * </p>\n     * <p class=\"note\">\n     * Note: Sensors like {@link Sensor#TYPE_PROXIMITY} and {@link Sensor#TYPE_SIGNIFICANT_MOTION}\n     * are declared as wake-up sensors by default.\n     * </p>\n     * @param type\n     *        type of sensor requested\n     * @param wakeUp\n     *        flag to indicate whether the Sensor is a wake-up or non wake-up sensor.\n     * @return the default sensor matching the requested type and wakeUp properties if one exists\n     *         and the application has the necessary permissions, or null otherwise.\n     * @see Sensor#isWakeUpSensor()\n     ",
    "links" : [ "#getDefaultSensor(int)", "android.hardware.Sensor#TYPE_ACCELEROMETER", "android.hardware.Sensor#TYPE_PROXIMITY", "android.hardware.Sensor#TYPE_SIGNIFICANT_MOTION" ]
  }, {
    "name" : "public boolean registerListener(SensorListener listener, int sensors)",
    "returnType" : "boolean",
    "comment" : "\n     * Registers a listener for given sensors.\n     *\n     * @deprecated This method is deprecated, use\n     *             {@link SensorManager#registerListener(SensorEventListener, Sensor, int)}\n     *             instead.\n     *\n     * @param listener\n     *        sensor listener object\n     *\n     * @param sensors\n     *        a bit masks of the sensors to register to\n     *\n     * @return <code>true</code> if the sensor is supported and successfully\n     *         enabled\n     ",
    "links" : [ "android.hardware.SensorManager#registerListener(SensorEventListener" ]
  }, {
    "name" : "public boolean registerListener(SensorListener listener, int sensors, int rate)",
    "returnType" : "boolean",
    "comment" : "\n     * Registers a SensorListener for given sensors.\n     *\n     * @deprecated This method is deprecated, use\n     *             {@link SensorManager#registerListener(SensorEventListener, Sensor, int)}\n     *             instead.\n     *\n     * @param listener\n     *        sensor listener object\n     *\n     * @param sensors\n     *        a bit masks of the sensors to register to\n     *\n     * @param rate\n     *        rate of events. This is only a hint to the system. events may be\n     *        received faster or slower than the specified rate. Usually events\n     *        are received faster. The value must be one of\n     *        {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},\n     *        {@link #SENSOR_DELAY_GAME}, or {@link #SENSOR_DELAY_FASTEST}.\n     *\n     * @return <code>true</code> if the sensor is supported and successfully\n     *         enabled\n     ",
    "links" : [ "#SENSOR_DELAY_NORMAL", "#SENSOR_DELAY_FASTEST", "#SENSOR_DELAY_UI", "android.hardware.SensorManager#registerListener(SensorEventListener", "#SENSOR_DELAY_GAME" ]
  }, {
    "name" : "public void unregisterListener(SensorListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters a listener for all sensors.\n     *\n     * @deprecated This method is deprecated, use\n     *             {@link SensorManager#unregisterListener(SensorEventListener)}\n     *             instead.\n     *\n     * @param listener\n     *        a SensorListener object\n     ",
    "links" : [ "android.hardware.SensorManager#unregisterListener(SensorEventListener)" ]
  }, {
    "name" : "public void unregisterListener(SensorListener listener, int sensors)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters a listener for the sensors with which it is registered.\n     *\n     * @deprecated This method is deprecated, use\n     *             {@link SensorManager#unregisterListener(SensorEventListener, Sensor)}\n     *             instead.\n     *\n     * @param listener\n     *        a SensorListener object\n     *\n     * @param sensors\n     *        a bit masks of the sensors to unregister from\n     ",
    "links" : [ "android.hardware.SensorManager#unregisterListener(SensorEventListener" ]
  }, {
    "name" : "public void unregisterListener(SensorEventListener listener, Sensor sensor)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters a listener for the sensors with which it is registered.\n     *\n     * <p class=\"note\">\n     * Note: Don't use this method with a one shot trigger sensor such as\n     * {@link Sensor#TYPE_SIGNIFICANT_MOTION}.\n     * Use {@link #cancelTriggerSensor(TriggerEventListener, Sensor)} instead.\n     * </p>\n     *\n     * @param listener\n     *        a SensorEventListener object\n     *\n     * @param sensor\n     *        the sensor to unregister from\n     *\n     * @see #unregisterListener(SensorEventListener)\n     * @see #registerListener(SensorEventListener, Sensor, int)\n     ",
    "links" : [ "android.hardware.Sensor#TYPE_SIGNIFICANT_MOTION", "#cancelTriggerSensor(TriggerEventListener" ]
  }, {
    "name" : "public void unregisterListener(SensorEventListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters a listener for all sensors.\n     *\n     * @param listener\n     *        a SensorListener object\n     *\n     * @see #unregisterListener(SensorEventListener, Sensor)\n     * @see #registerListener(SensorEventListener, Sensor, int)\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "protected abstract void unregisterListenerImpl(SensorEventListener listener, Sensor sensor)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean registerListener(SensorEventListener listener, Sensor sensor, int samplingPeriodUs)",
    "returnType" : "boolean",
    "comment" : "\n     * Registers a {@link android.hardware.SensorEventListener SensorEventListener} for the given\n     * sensor at the given sampling frequency.\n     * <p>\n     * The events will be delivered to the provided {@code SensorEventListener} as soon as they are\n     * available. To reduce the power consumption, applications can use\n     * {@link #registerListener(SensorEventListener, Sensor, int, int)} instead and specify a\n     * positive non-zero maximum reporting latency.\n     * </p>\n     * <p>\n     * In the case of non-wake-up sensors, the events are only delivered while the Application\n     * Processor (AP) is not in suspend mode. See {@link Sensor#isWakeUpSensor()} for more details.\n     * To ensure delivery of events from non-wake-up sensors even when the screen is OFF, the\n     * application registering to the sensor must hold a partial wake-lock to keep the AP awake,\n     * otherwise some events might be lost while the AP is asleep. Note that although events might\n     * be lost while the AP is asleep, the sensor will still consume power if it is not explicitly\n     * deactivated by the application. Applications must unregister their {@code\n     * SensorEventListener}s in their activity's {@code onPause()} method to avoid consuming power\n     * while the device is inactive.  See {@link #registerListener(SensorEventListener, Sensor, int,\n     * int)} for more details on hardware FIFO (queueing) capabilities and when some sensor events\n     * might be lost.\n     * </p>\n     * <p>\n     * In the case of wake-up sensors, each event generated by the sensor will cause the AP to\n     * wake-up, ensuring that each event can be delivered. Because of this, registering to a wake-up\n     * sensor has very significant power implications. Call {@link Sensor#isWakeUpSensor()} to check\n     * whether a sensor is a wake-up sensor. See\n     * {@link #registerListener(SensorEventListener, Sensor, int, int)} for information on how to\n     * reduce the power impact of registering to wake-up sensors.\n     * </p>\n     * <p class=\"note\">\n     * Note: Don't use this method with one-shot trigger sensors such as\n     * {@link Sensor#TYPE_SIGNIFICANT_MOTION}. Use\n     * {@link #requestTriggerSensor(TriggerEventListener, Sensor)} instead. Use\n     * {@link Sensor#getReportingMode()} to obtain the reporting mode of a given sensor.\n     * </p>\n     *\n     * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object.\n     * @param sensor The {@link android.hardware.Sensor Sensor} to register to.\n     * @param samplingPeriodUs The rate {@link android.hardware.SensorEvent sensor events} are\n     *            delivered at. This is only a hint to the system. Events may be received faster or\n     *            slower than the specified rate. Usually events are received faster. The value must\n     *            be one of {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},\n     *            {@link #SENSOR_DELAY_GAME}, or {@link #SENSOR_DELAY_FASTEST} or, the desired delay\n     *            between events in microseconds. Specifying the delay in microseconds only works\n     *            from Android 2.3 (API level 9) onwards. For earlier releases, you must use one of\n     *            the {@code SENSOR_DELAY_*} constants.\n     * @return <code>true</code> if the sensor is supported and successfully enabled.\n     * @see #registerListener(SensorEventListener, Sensor, int, Handler)\n     * @see #unregisterListener(SensorEventListener)\n     * @see #unregisterListener(SensorEventListener, Sensor)\n     ",
    "links" : [ "android.hardware.Sensor#isWakeUpSensor()", "android.hardware.Sensor#getReportingMode()", "android.hardware.SensorEvent", "#SENSOR_DELAY_NORMAL", "#SENSOR_DELAY_FASTEST", "#registerListener(SensorEventListener", "#SENSOR_DELAY_UI", "android.hardware.SensorEventListener", "#requestTriggerSensor(TriggerEventListener", "#SENSOR_DELAY_GAME", "android.hardware.Sensor", "android.hardware.Sensor#TYPE_SIGNIFICANT_MOTION" ]
  }, {
    "name" : "public boolean registerListener(SensorEventListener listener, Sensor sensor, int samplingPeriodUs, int maxReportLatencyUs)",
    "returnType" : "boolean",
    "comment" : "\n     * Registers a {@link android.hardware.SensorEventListener SensorEventListener} for the given\n     * sensor at the given sampling frequency and the given maximum reporting latency.\n     * <p>\n     * This function is similar to {@link #registerListener(SensorEventListener, Sensor, int)} but\n     * it allows events to stay temporarily in the hardware FIFO (queue) before being delivered. The\n     * events can be stored in the hardware FIFO up to {@code maxReportLatencyUs} microseconds. Once\n     * one of the events in the FIFO needs to be reported, all of the events in the FIFO are\n     * reported sequentially. This means that some events will be reported before the maximum\n     * reporting latency has elapsed.\n     * </p><p>\n     * When {@code maxReportLatencyUs} is 0, the call is equivalent to a call to\n     * {@link #registerListener(SensorEventListener, Sensor, int)}, as it requires the events to be\n     * delivered as soon as possible.\n     * </p><p>\n     * When {@code sensor.maxFifoEventCount()} is 0, the sensor does not use a FIFO, so the call\n     * will also be equivalent to {@link #registerListener(SensorEventListener, Sensor, int)}.\n     * </p><p>\n     * Setting {@code maxReportLatencyUs} to a positive value allows to reduce the number of\n     * interrupts the AP (Application Processor) receives, hence reducing power consumption, as the\n     * AP can switch to a lower power state while the sensor is capturing the data. This is\n     * especially important when registering to wake-up sensors, for which each interrupt causes the\n     * AP to wake up if it was in suspend mode. See {@link Sensor#isWakeUpSensor()} for more\n     * information on wake-up sensors.\n     * </p>\n     * <p class=\"note\">\n     * </p>\n     * Note: Don't use this method with one-shot trigger sensors such as\n     * {@link Sensor#TYPE_SIGNIFICANT_MOTION}. Use\n     * {@link #requestTriggerSensor(TriggerEventListener, Sensor)} instead. </p>\n     *\n     * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object\n     *            that will receive the sensor events. If the application is interested in receiving\n     *            flush complete notifications, it should register with\n     *            {@link android.hardware.SensorEventListener SensorEventListener2} instead.\n     * @param sensor The {@link android.hardware.Sensor Sensor} to register to.\n     * @param samplingPeriodUs The desired delay between two consecutive events in microseconds.\n     *            This is only a hint to the system. Events may be received faster or slower than\n     *            the specified rate. Usually events are received faster. Can be one of\n     *            {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},\n     *            {@link #SENSOR_DELAY_GAME}, {@link #SENSOR_DELAY_FASTEST} or the delay in\n     *            microseconds.\n     * @param maxReportLatencyUs Maximum time in microseconds that events can be delayed before\n     *            being reported to the application. A large value allows reducing the power\n     *            consumption associated with the sensor. If maxReportLatencyUs is set to zero,\n     *            events are delivered as soon as they are available, which is equivalent to calling\n     *            {@link #registerListener(SensorEventListener, Sensor, int)}.\n     * @return <code>true</code> if the sensor is supported and successfully enabled.\n     * @see #registerListener(SensorEventListener, Sensor, int)\n     * @see #unregisterListener(SensorEventListener)\n     * @see #flush(SensorEventListener)\n     ",
    "links" : [ "android.hardware.Sensor#isWakeUpSensor()", "#SENSOR_DELAY_NORMAL", "#SENSOR_DELAY_FASTEST", "#registerListener(SensorEventListener", "#SENSOR_DELAY_UI", "android.hardware.SensorEventListener", "#requestTriggerSensor(TriggerEventListener", "#SENSOR_DELAY_GAME", "android.hardware.Sensor", "android.hardware.Sensor#TYPE_SIGNIFICANT_MOTION" ]
  }, {
    "name" : "public boolean registerListener(SensorEventListener listener, Sensor sensor, int samplingPeriodUs, Handler handler)",
    "returnType" : "boolean",
    "comment" : "\n     * Registers a {@link android.hardware.SensorEventListener SensorEventListener} for the given\n     * sensor. Events are delivered in continuous mode as soon as they are available. To reduce the\n     * power consumption, applications can use\n     * {@link #registerListener(SensorEventListener, Sensor, int, int)} instead and specify a\n     * positive non-zero maximum reporting latency.\n     * <p class=\"note\">\n     * </p>\n     * Note: Don't use this method with a one shot trigger sensor such as\n     * {@link Sensor#TYPE_SIGNIFICANT_MOTION}. Use\n     * {@link #requestTriggerSensor(TriggerEventListener, Sensor)} instead. </p>\n     *\n     * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object.\n     * @param sensor The {@link android.hardware.Sensor Sensor} to register to.\n     * @param samplingPeriodUs The rate {@link android.hardware.SensorEvent sensor events} are\n     *            delivered at. This is only a hint to the system. Events may be received faster or\n     *            slower than the specified rate. Usually events are received faster. The value must\n     *            be one of {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},\n     *            {@link #SENSOR_DELAY_GAME}, or {@link #SENSOR_DELAY_FASTEST} or, the desired\n     *            delay between events in microseconds. Specifying the delay in microseconds only\n     *            works from Android 2.3 (API level 9) onwards. For earlier releases, you must use\n     *            one of the {@code SENSOR_DELAY_*} constants.\n     * @param handler The {@link android.os.Handler Handler} the {@link android.hardware.SensorEvent\n     *            sensor events} will be delivered to.\n     * @return <code>true</code> if the sensor is supported and successfully enabled.\n     * @see #registerListener(SensorEventListener, Sensor, int)\n     * @see #unregisterListener(SensorEventListener)\n     * @see #unregisterListener(SensorEventListener, Sensor)\n     ",
    "links" : [ "android.hardware.SensorEvent", "android.hardware.SensorEventsensor", "#SENSOR_DELAY_NORMAL", "#SENSOR_DELAY_FASTEST", "android.os.Handler", "#registerListener(SensorEventListener", "#SENSOR_DELAY_UI", "android.hardware.SensorEventListener", "#requestTriggerSensor(TriggerEventListener", "#SENSOR_DELAY_GAME", "android.hardware.Sensor", "android.hardware.Sensor#TYPE_SIGNIFICANT_MOTION" ]
  }, {
    "name" : "public boolean registerListener(SensorEventListener listener, Sensor sensor, int samplingPeriodUs, int maxReportLatencyUs, Handler handler)",
    "returnType" : "boolean",
    "comment" : "\n     * Registers a {@link android.hardware.SensorEventListener SensorEventListener} for the given\n     * sensor at the given sampling frequency and the given maximum reporting latency.\n     *\n     * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object\n     *            that will receive the sensor events. If the application is interested in receiving\n     *            flush complete notifications, it should register with\n     *            {@link android.hardware.SensorEventListener SensorEventListener2} instead.\n     * @param sensor The {@link android.hardware.Sensor Sensor} to register to.\n     * @param samplingPeriodUs The desired delay between two consecutive events in microseconds.\n     *            This is only a hint to the system. Events may be received faster or slower than\n     *            the specified rate. Usually events are received faster. Can be one of\n     *            {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},\n     *            {@link #SENSOR_DELAY_GAME}, {@link #SENSOR_DELAY_FASTEST} or the delay in\n     *            microseconds.\n     * @param maxReportLatencyUs Maximum time in microseconds that events can be delayed before\n     *            being reported to the application. A large value allows reducing the power\n     *            consumption associated with the sensor. If maxReportLatencyUs is set to zero,\n     *            events are delivered as soon as they are available, which is equivalent to calling\n     *            {@link #registerListener(SensorEventListener, Sensor, int)}.\n     * @param handler The {@link android.os.Handler Handler} the {@link android.hardware.SensorEvent\n     *            sensor events} will be delivered to.\n     * @return <code>true</code> if the sensor is supported and successfully enabled.\n     * @see #registerListener(SensorEventListener, Sensor, int, int)\n     ",
    "links" : [ "android.hardware.SensorEventsensor", "#SENSOR_DELAY_NORMAL", "#SENSOR_DELAY_FASTEST", "android.os.Handler", "#SENSOR_DELAY_UI", "#registerListener(SensorEventListener", "android.hardware.SensorEventListener", "#SENSOR_DELAY_GAME", "android.hardware.Sensor" ]
  }, {
    "name" : "protected abstract boolean registerListenerImpl(SensorEventListener listener, Sensor sensor, int delayUs, Handler handler, int maxReportLatencyUs, int reservedFlags)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean flush(SensorEventListener listener)",
    "returnType" : "boolean",
    "comment" : "\n     * Flushes the FIFO of all the sensors registered for this listener. If there are events\n     * in the FIFO of the sensor, they are returned as if the maxReportLatency of the FIFO has\n     * expired. Events are returned in the usual way through the SensorEventListener.\n     * This call doesn't affect the maxReportLatency for this sensor. This call is asynchronous and\n     * returns immediately.\n     * {@link android.hardware.SensorEventListener2#onFlushCompleted onFlushCompleted} is called\n     * after all the events in the batch at the time of calling this method have been delivered\n     * successfully. If the hardware doesn't support flush, it still returns true and a trivial\n     * flush complete event is sent after the current event for all the clients registered for this\n     * sensor.\n     *\n     * @param listener A {@link android.hardware.SensorEventListener SensorEventListener} object\n     *        which was previously used in a registerListener call.\n     * @return <code>true</code> if the flush is initiated successfully on all the sensors\n     *         registered for this listener, false if no sensor is previously registered for this\n     *         listener or flush on one of the sensors fails.\n     * @see #registerListener(SensorEventListener, Sensor, int, int)\n     * @throws IllegalArgumentException when listener is null.\n     ",
    "links" : [ "android.hardware.SensorEventListener", "android.hardware.SensorEventListener2#onFlushCompleted" ]
  }, {
    "name" : "protected abstract boolean flushImpl(SensorEventListener listener)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public SensorDirectChannel createDirectChannel(MemoryFile mem)",
    "returnType" : "SensorDirectChannel",
    "comment" : "\n     * Create a sensor direct channel backed by shared memory wrapped in MemoryFile object.\n     *\n     * The resulting channel can be used for delivering sensor events to native code, other\n     * processes, GPU/DSP or other co-processors without CPU intervention. This is the recommended\n     * for high performance sensor applications that use high sensor rates (e.g. greater than 200Hz)\n     * and cares about sensor event latency.\n     *\n     * Use the returned {@link android.hardware.SensorDirectChannel} object to configure direct\n     * report of sensor events. After use, call {@link android.hardware.SensorDirectChannel#close()}\n     * to free up resource in sensor system associated with the direct channel.\n     *\n     * @param mem A {@link android.os.MemoryFile} shared memory object.\n     * @return A {@link android.hardware.SensorDirectChannel} object.\n     * @throws NullPointerException when mem is null.\n     * @throws UncheckedIOException if not able to create channel.\n     * @see SensorDirectChannel#close()\n     ",
    "links" : [ "android.hardware.SensorDirectChannel", "android.os.MemoryFile", "android.hardware.SensorDirectChannel#close()" ]
  }, {
    "name" : "public SensorDirectChannel createDirectChannel(HardwareBuffer mem)",
    "returnType" : "SensorDirectChannel",
    "comment" : "\n     * Create a sensor direct channel backed by shared memory wrapped in HardwareBuffer object.\n     *\n     * The resulting channel can be used for delivering sensor events to native code, other\n     * processes, GPU/DSP or other co-processors without CPU intervention. This is the recommended\n     * for high performance sensor applications that use high sensor rates (e.g. greater than 200Hz)\n     * and cares about sensor event latency.\n     *\n     * Use the returned {@link android.hardware.SensorDirectChannel} object to configure direct\n     * report of sensor events. After use, call {@link android.hardware.SensorDirectChannel#close()}\n     * to free up resource in sensor system associated with the direct channel.\n     *\n     * @param mem A {@link android.hardware.HardwareBuffer} shared memory object.\n     * @return A {@link android.hardware.SensorDirectChannel} object.\n     * @throws NullPointerException when mem is null.\n     * @throws UncheckedIOException if not able to create channel.\n     * @see SensorDirectChannel#close()\n     ",
    "links" : [ "android.hardware.SensorDirectChannel", "android.hardware.HardwareBuffer", "android.hardware.SensorDirectChannel#close()" ]
  }, {
    "name" : "protected abstract SensorDirectChannel createDirectChannelImpl(MemoryFile memoryFile, HardwareBuffer hardwareBuffer)",
    "returnType" : "SensorDirectChannel",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : " void destroyDirectChannel(SensorDirectChannel channel)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "protected abstract void destroyDirectChannelImpl(SensorDirectChannel channel)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "protected abstract int configureDirectChannelImpl(SensorDirectChannel channel, Sensor s, int rate)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void registerDynamicSensorCallback(DynamicSensorCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Add a {@link android.hardware.SensorManager.DynamicSensorCallback\n     * DynamicSensorCallback} to receive dynamic sensor connection callbacks. Repeat\n     * registration with the already registered callback object will have no additional effect.\n     *\n     * @param callback An object that implements the\n     *        {@link android.hardware.SensorManager.DynamicSensorCallback\n     *        DynamicSensorCallback}\n     *        interface for receiving callbacks.\n     * @see #registerDynamicSensorCallback(DynamicSensorCallback, Handler)\n     *\n     * @throws IllegalArgumentException when callback is null.\n     ",
    "links" : [ "android.hardware.SensorManager.DynamicSensorCallbackDynamicSensorCallback" ]
  }, {
    "name" : "public void registerDynamicSensorCallback(DynamicSensorCallback callback, Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Add a {@link android.hardware.SensorManager.DynamicSensorCallback\n     * DynamicSensorCallback} to receive dynamic sensor connection callbacks. Repeat\n     * registration with the already registered callback object will have no additional effect.\n     *\n     * @param callback An object that implements the\n     *        {@link android.hardware.SensorManager.DynamicSensorCallback\n     *        DynamicSensorCallback} interface for receiving callbacks.\n     * @param handler The {@link android.os.Handler Handler} the {@link\n     *        android.hardware.SensorManager.DynamicSensorCallback\n     *        sensor connection events} will be delivered to.\n     *\n     * @throws IllegalArgumentException when callback is null.\n     ",
    "links" : [ "android.hardware.SensorManager.DynamicSensorCallbackDynamicSensorCallback", "android.os.Handler", "android.hardware.SensorManager.DynamicSensorCallbacksensor" ]
  }, {
    "name" : "public void unregisterDynamicSensorCallback(DynamicSensorCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Remove a {@link android.hardware.SensorManager.DynamicSensorCallback\n     * DynamicSensorCallback} to stop sending dynamic sensor connection events to that\n     * callback.\n     *\n     * @param callback An object that implements the\n     *        {@link android.hardware.SensorManager.DynamicSensorCallback\n     *        DynamicSensorCallback}\n     *        interface for receiving callbacks.\n     ",
    "links" : [ "android.hardware.SensorManager.DynamicSensorCallbackDynamicSensorCallback" ]
  }, {
    "name" : "public boolean isDynamicSensorDiscoverySupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Tell if dynamic sensor discovery feature is supported by system.\n     *\n     * @return <code>true</code> if dynamic sensor discovery is supported, <code>false</code>\n     * otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected abstract void registerDynamicSensorCallbackImpl(DynamicSensorCallback callback, Handler handler)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "protected abstract void unregisterDynamicSensorCallbackImpl(DynamicSensorCallback callback)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static boolean getRotationMatrix(float[] R, float[] I, float[] gravity, float[] geomagnetic)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static float getInclination(float[] I)",
    "returnType" : "float",
    "comment" : "\n     * Computes the geomagnetic inclination angle in radians from the\n     * inclination matrix <b>I</b> returned by {@link #getRotationMatrix}.\n     *\n     * @param I\n     *        inclination matrix see {@link #getRotationMatrix}.\n     *\n     * @return The geomagnetic inclination angle in radians.\n     *\n     * @see #getRotationMatrix(float[], float[], float[], float[])\n     * @see #getOrientation(float[], float[])\n     * @see GeomagneticField\n     *\n     ",
    "links" : [ "#getRotationMatrix" ]
  }, {
    "name" : "public static boolean remapCoordinateSystem(float[] inR, int X, int Y, float[] outR)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean remapCoordinateSystemImpl(float[] inR, int X, int Y, float[] outR)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static float[] getOrientation(float[] R, float[] values)",
    "returnType" : "float[]",
    "comment" : "\n     * Computes the device's orientation based on the rotation matrix.\n     * <p>\n     * When it returns, the array values are as follows:\n     * <ul>\n     * <li>values[0]: <i>Azimuth</i>, angle of rotation about the -z axis.\n     *                This value represents the angle between the device's y\n     *                axis and the magnetic north pole. When facing north, this\n     *                angle is 0, when facing south, this angle is &pi;.\n     *                Likewise, when facing east, this angle is &pi;/2, and\n     *                when facing west, this angle is -&pi;/2. The range of\n     *                values is -&pi; to &pi;.</li>\n     * <li>values[1]: <i>Pitch</i>, angle of rotation about the x axis.\n     *                This value represents the angle between a plane parallel\n     *                to the device's screen and a plane parallel to the ground.\n     *                Assuming that the bottom edge of the device faces the\n     *                user and that the screen is face-up, tilting the top edge\n     *                of the device toward the ground creates a positive pitch\n     *                angle. The range of values is -&pi;/2 to &pi;/2.</li>\n     * <li>values[2]: <i>Roll</i>, angle of rotation about the y axis. This\n     *                value represents the angle between a plane perpendicular\n     *                to the device's screen and a plane perpendicular to the\n     *                ground. Assuming that the bottom edge of the device faces\n     *                the user and that the screen is face-up, tilting the left\n     *                edge of the device toward the ground creates a positive\n     *                roll angle. The range of values is -&pi; to &pi;.</li>\n     * </ul>\n     * <p>\n     * Applying these three rotations in the azimuth, pitch, roll order\n     * transforms an identity matrix to the rotation matrix passed into this\n     * method. Also, note that all three orientation angles are expressed in\n     * <b>radians</b>.\n     *\n     * @param R\n     *        rotation matrix see {@link #getRotationMatrix}.\n     *\n     * @param values\n     *        an array of 3 floats to hold the result.\n     *\n     * @return The array values passed as argument.\n     *\n     * @see #getRotationMatrix(float[], float[], float[], float[])\n     * @see GeomagneticField\n     ",
    "links" : [ "#getRotationMatrix" ]
  }, {
    "name" : "public static float getAltitude(float p0, float p)",
    "returnType" : "float",
    "comment" : "\n     * Computes the Altitude in meters from the atmospheric pressure and the\n     * pressure at sea level.\n     * <p>\n     * Typically the atmospheric pressure is read from a\n     * {@link Sensor#TYPE_PRESSURE} sensor. The pressure at sea level must be\n     * known, usually it can be retrieved from airport databases in the\n     * vicinity. If unknown, you can use {@link #PRESSURE_STANDARD_ATMOSPHERE}\n     * as an approximation, but absolute altitudes won't be accurate.\n     * </p>\n     * <p>\n     * To calculate altitude differences, you must calculate the difference\n     * between the altitudes at both points. If you don't know the altitude\n     * as sea level, you can use {@link #PRESSURE_STANDARD_ATMOSPHERE} instead,\n     * which will give good results considering the range of pressure typically\n     * involved.\n     * </p>\n     * <p>\n     * <code><ul>\n     *  float altitude_difference =\n     *      getAltitude(SensorManager.PRESSURE_STANDARD_ATMOSPHERE, pressure_at_point2)\n     *      - getAltitude(SensorManager.PRESSURE_STANDARD_ATMOSPHERE, pressure_at_point1);\n     * </ul></code>\n     * </p>\n     *\n     * @param p0 pressure at sea level\n     * @param p atmospheric pressure\n     * @return Altitude in meters\n     ",
    "links" : [ "android.hardware.Sensor#TYPE_PRESSURE", "#PRESSURE_STANDARD_ATMOSPHERE" ]
  }, {
    "name" : "public static void getAngleChange(float[] angleChange, float[] R, float[] prevR)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static void getRotationMatrixFromVector(float[] R, float[] rotationVector)",
    "returnType" : "void",
    "comment" : " Helper function to convert a rotation vector to a rotation matrix.\n     *  Given a rotation vector (presumably from a ROTATION_VECTOR sensor), returns a\n     *  9  or 16 element rotation matrix in the array R.  R must have length 9 or 16.\n     *  If R.length == 9, the following matrix is returned:\n     * <pre>\n     *   /  R[ 0]   R[ 1]   R[ 2]   \\\n     *   |  R[ 3]   R[ 4]   R[ 5]   |\n     *   \\  R[ 6]   R[ 7]   R[ 8]   /\n     *</pre>\n     * If R.length == 16, the following matrix is returned:\n     * <pre>\n     *   /  R[ 0]   R[ 1]   R[ 2]   0  \\\n     *   |  R[ 4]   R[ 5]   R[ 6]   0  |\n     *   |  R[ 8]   R[ 9]   R[10]   0  |\n     *   \\  0       0       0       1  /\n     *</pre>\n     *  @param rotationVector the rotation vector to convert\n     *  @param R an array of floats in which to store the rotation matrix\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void getQuaternionFromVector(float[] Q, float[] rv)",
    "returnType" : "void",
    "comment" : " Helper function to convert a rotation vector to a normalized quaternion.\n     *  Given a rotation vector (presumably from a ROTATION_VECTOR sensor), returns a normalized\n     *  quaternion in the array Q.  The quaternion is stored as [w, x, y, z]\n     *  @param rv the rotation vector to convert\n     *  @param Q an array of floats in which to store the computed quaternion\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean requestTriggerSensor(TriggerEventListener listener, Sensor sensor)",
    "returnType" : "boolean",
    "comment" : "\n     * Requests receiving trigger events for a trigger sensor.\n     *\n     * <p>\n     * When the sensor detects a trigger event condition, such as significant motion in\n     * the case of the {@link Sensor#TYPE_SIGNIFICANT_MOTION}, the provided trigger listener\n     * will be invoked once and then its request to receive trigger events will be canceled.\n     * To continue receiving trigger events, the application must request to receive trigger\n     * events again.\n     * </p>\n     *\n     * @param listener The listener on which the\n     *        {@link TriggerEventListener#onTrigger(TriggerEvent)} will be delivered.\n     * @param sensor The sensor to be enabled.\n     *\n     * @return true if the sensor was successfully enabled.\n     *\n     * @throws IllegalArgumentException when sensor is null or not a trigger sensor.\n     ",
    "links" : [ "android.hardware.TriggerEventListener#onTrigger(TriggerEvent)", "android.hardware.Sensor#TYPE_SIGNIFICANT_MOTION" ]
  }, {
    "name" : "protected abstract boolean requestTriggerSensorImpl(TriggerEventListener listener, Sensor sensor)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean cancelTriggerSensor(TriggerEventListener listener, Sensor sensor)",
    "returnType" : "boolean",
    "comment" : "\n     * Cancels receiving trigger events for a trigger sensor.\n     *\n     * <p>\n     * Note that a Trigger sensor will be auto disabled if\n     * {@link TriggerEventListener#onTrigger(TriggerEvent)} has triggered.\n     * This method is provided in case the user wants to explicitly cancel the request\n     * to receive trigger events.\n     * </p>\n     *\n     * @param listener The listener on which the\n     *        {@link TriggerEventListener#onTrigger(TriggerEvent)}\n     *        is delivered.It should be the same as the one used\n     *        in {@link #requestTriggerSensor(TriggerEventListener, Sensor)}\n     * @param sensor The sensor for which the trigger request should be canceled.\n     *        If null, it cancels receiving trigger for all sensors associated\n     *        with the listener.\n     *\n     * @return true if successfully canceled.\n     *\n     * @throws IllegalArgumentException when sensor is a trigger sensor.\n     ",
    "links" : [ "android.hardware.TriggerEventListener#onTrigger(TriggerEvent)", "#requestTriggerSensor(TriggerEventListener" ]
  }, {
    "name" : "protected abstract boolean cancelTriggerSensorImpl(TriggerEventListener listener, Sensor sensor, boolean disable)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean initDataInjection(boolean enable)",
    "returnType" : "boolean",
    "comment" : "\n     * For testing purposes only. Not for third party applications.\n     *\n     * Initialize data injection mode and create a client for data injection. SensorService should\n     * already be operating in DATA_INJECTION mode for this call succeed. To set SensorService into\n     * DATA_INJECTION mode \"adb shell dumpsys sensorservice data_injection\" needs to be called\n     * through adb. Typically this is done using a host side test.  This mode is expected to be used\n     * only for testing purposes. If the HAL is set to data injection mode, it will ignore the input\n     * from physical sensors and read sensor data that is injected from the test application. This\n     * mode is used for testing vendor implementations for various algorithms like Rotation Vector,\n     * Significant Motion, Step Counter etc. Not all HALs support DATA_INJECTION. This method will\n     * fail in those cases. Once this method succeeds, the test can call\n     * {@link injectSensorData(Sensor, float[], int, long)} to inject sensor data into the HAL.\n     *\n     * @param enable True to initialize a client in DATA_INJECTION mode.\n     *               False to clean up the native resources.\n     *\n     * @return true if the HAL supports data injection and false\n     *         otherwise.\n     * @hide\n     ",
    "links" : [ "injectSensorData(Sensor" ]
  }, {
    "name" : "public boolean initDataInjection(boolean enable, @DataInjectionMode int mode)",
    "returnType" : "boolean",
    "comment" : "\n     * For testing purposes only. Not for third party applications.\n     *\n     * Initialize data injection mode and create a client for data injection. SensorService should\n     * already be operating in one of DATA_INJECTION, REPLAY_DATA_INJECTION or\n     * HAL_BYPASS_REPLAY_DATA_INJECTION modes for this call succeed. To set SensorService in\n     * a Data Injection mode, use one of:\n     *\n     * <ul>\n     *      <li>adb shell dumpsys sensorservice data_injection</li>\n     *      <li>adb shell dumpsys sensorservice replay_data_injection package_name</li>\n     *      <li>adb shell dumpsys sensorservice hal_bypass_replay_data_injection package_name</li>\n     * </ul>\n     *\n     * Typically this is done using a host side test.  This mode is expected to be used\n     * only for testing purposes. See {@link DataInjectionMode} for details of each data injection\n     * mode. Once this method succeeds, the test can call\n     * {@link #injectSensorData(Sensor, float[], int, long)} to inject sensor data into the HAL.\n     * To put SensorService back into normal mode, use \"adb shell dumpsys sensorservice enable\"\n     *\n     * @param enable True to initialize a client in a data injection mode.\n     *               False to clean up the native resources.\n     *\n     * @param mode One of DATA_INJECTION, REPLAY_DATA_INJECTION or HAL_BYPASS_DATA_INJECTION.\n     *             See {@link DataInjectionMode} for details.\n     *\n     * @return true if the HAL supports data injection and false\n     *         otherwise.\n     * @hide\n     ",
    "links" : [ "DataInjectionMode", "#injectSensorData(Sensor" ]
  }, {
    "name" : "protected abstract boolean initDataInjectionImpl(boolean enable, @DataInjectionMode int mode)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean injectSensorData(Sensor sensor, float[] values, int accuracy, long timestamp)",
    "returnType" : "boolean",
    "comment" : "\n     * For testing purposes only. Not for third party applications.\n     *\n     * This method is used to inject raw sensor data into the HAL.  Call {@link\n     * initDataInjection(boolean)} before this method to set the HAL in data injection mode. This\n     * method should be called only if a previous call to initDataInjection has been successful and\n     * the HAL and SensorService are already operating in data injection mode.\n     *\n     * @param sensor The sensor to inject.\n     * @param values Sensor values to inject. The length of this\n     *               array must be exactly equal to the number of\n     *               values reported by the sensor type.\n     * @param accuracy Accuracy of the sensor.\n     * @param timestamp Sensor timestamp associated with the event.\n     *\n     * @return boolean True if the data injection succeeds, false\n     *         otherwise.\n     * @throws IllegalArgumentException when the sensor is null,\n     *         data injection is not supported by the sensor, values\n     *         are null, incorrect number of values for the sensor,\n     *         sensor accuracy is incorrect or timestamps are\n     *         invalid.\n     * @hide\n     ",
    "links" : [ "initDataInjection(boolean)" ]
  }, {
    "name" : "protected abstract boolean injectSensorDataImpl(Sensor sensor, float[] values, int accuracy, long timestamp)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private LegacySensorManager getLegacySensorManager()",
    "returnType" : "LegacySensorManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static int getDelay(int rate)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean setOperationParameter(SensorAdditionalInfo parameter)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "protected abstract boolean setOperationParameterImpl(SensorAdditionalInfo parameter)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  } ],
  "methodNames" : [ "protected abstract List<Sensor> getFullSensorList()", "protected abstract List<Sensor> getFullDynamicSensorList()", "public int getSensors()", "public List<Sensor> getSensorList(int type)", "public Sensor getSensorByHandle(int sensorHandle)", "public List<Sensor> getDynamicSensorList(int type)", "public Sensor getDefaultSensor(int type)", "public Sensor getDefaultSensor(int type, boolean wakeUp)", "public boolean registerListener(SensorListener listener, int sensors)", "public boolean registerListener(SensorListener listener, int sensors, int rate)", "public void unregisterListener(SensorListener listener)", "public void unregisterListener(SensorListener listener, int sensors)", "public void unregisterListener(SensorEventListener listener, Sensor sensor)", "public void unregisterListener(SensorEventListener listener)", "protected abstract void unregisterListenerImpl(SensorEventListener listener, Sensor sensor)", "public boolean registerListener(SensorEventListener listener, Sensor sensor, int samplingPeriodUs)", "public boolean registerListener(SensorEventListener listener, Sensor sensor, int samplingPeriodUs, int maxReportLatencyUs)", "public boolean registerListener(SensorEventListener listener, Sensor sensor, int samplingPeriodUs, Handler handler)", "public boolean registerListener(SensorEventListener listener, Sensor sensor, int samplingPeriodUs, int maxReportLatencyUs, Handler handler)", "protected abstract boolean registerListenerImpl(SensorEventListener listener, Sensor sensor, int delayUs, Handler handler, int maxReportLatencyUs, int reservedFlags)", "public boolean flush(SensorEventListener listener)", "protected abstract boolean flushImpl(SensorEventListener listener)", "public SensorDirectChannel createDirectChannel(MemoryFile mem)", "public SensorDirectChannel createDirectChannel(HardwareBuffer mem)", "protected abstract SensorDirectChannel createDirectChannelImpl(MemoryFile memoryFile, HardwareBuffer hardwareBuffer)", " void destroyDirectChannel(SensorDirectChannel channel)", "protected abstract void destroyDirectChannelImpl(SensorDirectChannel channel)", "protected abstract int configureDirectChannelImpl(SensorDirectChannel channel, Sensor s, int rate)", "public void registerDynamicSensorCallback(DynamicSensorCallback callback)", "public void registerDynamicSensorCallback(DynamicSensorCallback callback, Handler handler)", "public void unregisterDynamicSensorCallback(DynamicSensorCallback callback)", "public boolean isDynamicSensorDiscoverySupported()", "protected abstract void registerDynamicSensorCallbackImpl(DynamicSensorCallback callback, Handler handler)", "protected abstract void unregisterDynamicSensorCallbackImpl(DynamicSensorCallback callback)", "public static boolean getRotationMatrix(float[] R, float[] I, float[] gravity, float[] geomagnetic)", "public static float getInclination(float[] I)", "public static boolean remapCoordinateSystem(float[] inR, int X, int Y, float[] outR)", "private static boolean remapCoordinateSystemImpl(float[] inR, int X, int Y, float[] outR)", "public static float[] getOrientation(float[] R, float[] values)", "public static float getAltitude(float p0, float p)", "public static void getAngleChange(float[] angleChange, float[] R, float[] prevR)", "public static void getRotationMatrixFromVector(float[] R, float[] rotationVector)", "public static void getQuaternionFromVector(float[] Q, float[] rv)", "public boolean requestTriggerSensor(TriggerEventListener listener, Sensor sensor)", "protected abstract boolean requestTriggerSensorImpl(TriggerEventListener listener, Sensor sensor)", "public boolean cancelTriggerSensor(TriggerEventListener listener, Sensor sensor)", "protected abstract boolean cancelTriggerSensorImpl(TriggerEventListener listener, Sensor sensor, boolean disable)", "public boolean initDataInjection(boolean enable)", "public boolean initDataInjection(boolean enable, @DataInjectionMode int mode)", "protected abstract boolean initDataInjectionImpl(boolean enable, @DataInjectionMode int mode)", "public boolean injectSensorData(Sensor sensor, float[] values, int accuracy, long timestamp)", "protected abstract boolean injectSensorDataImpl(Sensor sensor, float[] values, int accuracy, long timestamp)", "private LegacySensorManager getLegacySensorManager()", "private static int getDelay(int rate)", "public boolean setOperationParameter(SensorAdditionalInfo parameter)", "protected abstract boolean setOperationParameterImpl(SensorAdditionalInfo parameter)" ],
  "variableNames" : [ "TAG", "sTempMatrix", "mSensorListByType", "mLegacySensorManager", "SENSOR_ORIENTATION", "SENSOR_ACCELEROMETER", "SENSOR_TEMPERATURE", "SENSOR_MAGNETIC_FIELD", "SENSOR_LIGHT", "SENSOR_PROXIMITY", "SENSOR_TRICORDER", "SENSOR_ORIENTATION_RAW", "SENSOR_ALL", "SENSOR_MIN", "SENSOR_MAX", "DATA_X", "DATA_Y", "DATA_Z", "RAW_DATA_INDEX", "RAW_DATA_X", "RAW_DATA_Y", "RAW_DATA_Z", "STANDARD_GRAVITY", "GRAVITY_SUN", "GRAVITY_MERCURY", "GRAVITY_VENUS", "GRAVITY_EARTH", "GRAVITY_MOON", "GRAVITY_MARS", "GRAVITY_JUPITER", "GRAVITY_SATURN", "GRAVITY_URANUS", "GRAVITY_NEPTUNE", "GRAVITY_PLUTO", "GRAVITY_DEATH_STAR_I", "GRAVITY_THE_ISLAND", "MAGNETIC_FIELD_EARTH_MAX", "MAGNETIC_FIELD_EARTH_MIN", "PRESSURE_STANDARD_ATMOSPHERE", "LIGHT_SUNLIGHT_MAX", "LIGHT_SUNLIGHT", "LIGHT_SHADE", "LIGHT_OVERCAST", "LIGHT_SUNRISE", "LIGHT_CLOUDY", "LIGHT_FULLMOON", "LIGHT_NO_MOON", "SENSOR_DELAY_FASTEST", "SENSOR_DELAY_GAME", "SENSOR_DELAY_UI", "SENSOR_DELAY_NORMAL", "SENSOR_STATUS_NO_CONTACT", "SENSOR_STATUS_UNRELIABLE", "SENSOR_STATUS_ACCURACY_LOW", "SENSOR_STATUS_ACCURACY_MEDIUM", "SENSOR_STATUS_ACCURACY_HIGH", "AXIS_X", "AXIS_Y", "AXIS_Z", "AXIS_MINUS_X", "AXIS_MINUS_Y", "AXIS_MINUS_Z", "DATA_INJECTION", "REPLAY_DATA_INJECTION", "HAL_BYPASS_REPLAY_DATA_INJECTION" ]
}