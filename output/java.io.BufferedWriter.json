{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/io/BufferedWriter.java",
  "packageName" : "java.io",
  "className" : "BufferedWriter",
  "comment" : "",
  "links" : [ ],
  "variables" : [ {
    "name" : "out",
    "type" : "Writer",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "cb",
    "type" : "char[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "nChars",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "nextChar",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "defaultCharBufferSize",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private void ensureOpen() throws IOException",
    "returnType" : "void",
    "comment" : " Checks to make sure that the stream has not been closed ",
    "links" : [ ]
  }, {
    "name" : " void flushBuffer() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Flushes the output buffer to the underlying character stream, without\n     * flushing the stream itself.  This method is non-private only so that it\n     * may be invoked by PrintStream.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void write(int c) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes a single character.\n     *\n     * @exception  IOException  If an I/O error occurs\n     ",
    "links" : [ ]
  }, {
    "name" : "private int min(int a, int b)",
    "returnType" : "int",
    "comment" : "\n     * Our own little min method, to avoid loading java.lang.Math if we've run\n     * out of file descriptors and we're trying to print a stack trace.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void write(char[] cbuf, int off, int len) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes a portion of an array of characters.\n     *\n     * <p> Ordinarily this method stores characters from the given array into\n     * this stream's buffer, flushing the buffer to the underlying stream as\n     * needed.  If the requested length is at least as large as the buffer,\n     * however, then this method will flush the buffer and write the characters\n     * directly to the underlying stream.  Thus redundant\n     * {@code BufferedWriter}s will not copy data unnecessarily.\n     *\n     * @param  cbuf  A character array\n     * @param  off   Offset from which to start reading characters\n     * @param  len   Number of characters to write\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code off} is negative, or {@code len} is negative,\n     *          or {@code off + len} is negative or greater than the length\n     *          of the given array\n     *\n     * @throws  IOException  If an I/O error occurs\n     ",
    "links" : [ ]
  }, {
    "name" : "public void write(String s, int off, int len) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes a portion of a String.\n     *\n     * @implSpec\n     * While the specification of this method in the\n     * {@linkplain java.io.Writer#write(java.lang.String,int,int) superclass}\n     * recommends that an {@link IndexOutOfBoundsException} be thrown\n     * if {@code len} is negative or {@code off + len} is negative,\n     * the implementation in this class does not throw such an exception in\n     * these cases but instead simply writes no characters.\n     *\n     * @param  s     String to be written\n     * @param  off   Offset from which to start reading characters\n     * @param  len   Number of characters to be written\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code off} is negative,\n     *          or {@code off + len} is greater than the length\n     *          of the given string\n     *\n     * @throws  IOException  If an I/O error occurs\n     ",
    "links" : [ "IndexOutOfBoundsException" ]
  }, {
    "name" : "public void newLine() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Writes a line separator.  The line separator string is defined by the\n     * system property {@code line.separator}, and is not necessarily a single\n     * newline ('\\n') character.\n     *\n     * @exception  IOException  If an I/O error occurs\n     ",
    "links" : [ ]
  }, {
    "name" : "public void flush() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Flushes the stream.\n     *\n     * @exception  IOException  If an I/O error occurs\n     ",
    "links" : [ ]
  }, {
    "name" : "public void close() throws IOException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ "private void ensureOpen() throws IOException", " void flushBuffer() throws IOException", "public void write(int c) throws IOException", "private int min(int a, int b)", "public void write(char[] cbuf, int off, int len) throws IOException", "public void write(String s, int off, int len) throws IOException", "public void newLine() throws IOException", "public void flush() throws IOException", "public void close() throws IOException" ],
  "variableNames" : [ "out", "cb", "nChars", "nextChar", "defaultCharBufferSize" ]
}