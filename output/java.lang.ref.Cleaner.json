{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/lang/ref/Cleaner.java",
  "packageName" : "java.lang.ref",
  "className" : "Cleaner",
  "comment" : "\n * {@code Cleaner} manages a set of object references and corresponding cleaning actions.\n * <p>\n * Cleaning actions are {@link #register(Object object, Runnable action) registered}\n * to run after the cleaner is notified that the object has become\n * phantom reachable.\n * The cleaner uses {@link PhantomReference} and {@link ReferenceQueue} to be\n * notified when the <a href=\"package-summary.html#reachability\">reachability</a>\n * changes.\n * <p>\n * Each cleaner operates independently, managing the pending cleaning actions\n * and handling threading and termination when the cleaner is no longer in use.\n * Registering an object reference and corresponding cleaning action returns\n * a {@link Cleanable Cleanable}. The most efficient use is to explicitly invoke\n * the {@link Cleanable#clean clean} method when the object is closed or\n * no longer needed.\n * The cleaning action is a {@link Runnable} to be invoked at most once when\n * the object has become phantom reachable unless it has already been explicitly cleaned.\n * Note that the cleaning action must not refer to the object being registered.\n * If so, the object will not become phantom reachable and the cleaning action\n * will not be invoked automatically.\n * <p>\n * The execution of the cleaning action is performed\n * by a thread associated with the cleaner.\n * The thread runs until all registered cleaning actions have\n * completed and the cleaner itself is reclaimed by the garbage collector.\n * <p>\n * The behavior of cleaners during {@link System#exit(int) System.exit}\n * is implementation specific. No guarantees are made relating\n * to whether cleaning actions are invoked or not.\n * <p>\n * Unless otherwise noted, passing a {@code null} argument to a constructor or\n * method in this class will cause a\n * {@link java.lang.NullPointerException NullPointerException} to be thrown.\n *\n * @apiNote\n * The cleaning action is invoked only after the associated object becomes\n * phantom reachable, so it is important that the object implementing the\n * cleaning action does not hold references to the object.\n * In this example, a static class encapsulates the cleaning state and action.\n * An \"inner\" class, anonymous or not,  must not be used because it implicitly\n * contains a reference to the outer instance, preventing it from becoming\n * phantom reachable.\n * The choice of a new cleaner or sharing an existing cleaner is determined\n * by the use case.\n * <p>\n * If the CleaningExample is used in a try-finally block then the\n * {@code close} method calls the cleaning action.\n * If the {@code close} method is not called, the cleaning action is called\n * by the Cleaner when the CleaningExample instance has become phantom reachable.\n * <pre>{@code\n * public class CleaningExample implements AutoCloseable {\n *        // Use the shared android.system.SystemCleaner instance on Android.\n *        private static final Cleaner cleaner = SystemCleaner.cleaner();\n *\n *        static class State implements Runnable {\n *\n *            State(...) {\n *                // initialize State needed for cleaning action\n *            }\n *\n *            public void run() {\n *                // cleanup action accessing State, executed at most once\n *            }\n *        }\n *\n *        private final State;\n *        private final Cleaner.Cleanable cleanable\n *\n *        public CleaningExample() {\n *            this.state = new State(...);\n *            this.cleanable = cleaner.register(this, state);\n *        }\n *\n *        public void close() {\n *            cleanable.clean();\n *        }\n *    }\n * }</pre>\n * The cleaning action could be a lambda but all too easily will capture\n * the object reference, by referring to fields of the object being cleaned,\n * preventing the object from becoming phantom reachable.\n * Using a static nested class, as above, will avoid accidentally retaining the\n * object reference.\n * <p>\n * <a id=\"compatible-cleaners\"></a>\n * Cleaning actions should be prepared to be invoked concurrently with\n * other cleaning actions.\n * Typically the cleaning actions should be very quick to execute\n * and not block. If the cleaning action blocks, it may delay processing\n * other cleaning actions registered to the same cleaner.\n * All cleaning actions registered to a cleaner should be mutually compatible.\n * @since 9\n ",
  "links" : [ "java.lang.ref.PhantomReference", "#register(Object", "Runnable", "#clean", "Cleanable", "#exit(int)", "java.lang.ref.ReferenceQueue", "java.lang.NullPointerException" ],
  "variables" : [ {
    "name" : "impl",
    "type" : "CleanerImpl",
    "comment" : "\n     * The Cleaner implementation.\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static Cleaner create()",
    "returnType" : "Cleaner",
    "comment" : "\n     * Returns a new {@code Cleaner}.\n     * <p>\n     * The cleaner creates a {@link Thread#setDaemon(boolean) daemon thread}\n     * to process the phantom reachable objects and to invoke cleaning actions.\n     * The {@linkplain java.lang.Thread#getContextClassLoader context class loader}\n     * of the thread is set to the\n     * {@link ClassLoader#getSystemClassLoader() system class loader}.\n     * The thread has no permissions, enforced only if a\n     * {@link java.lang.System#setSecurityManager(SecurityManager) SecurityManager is set}.\n     * <p>\n     * All exceptions thrown by the cleaning actions in this thread are ignored.\n     * <p>\n     * The cleaner terminates when it is phantom reachable and all of the\n     * registered cleaning actions are complete.\n     *\n     * @return a new {@code Cleaner}\n     *\n     * @throws  SecurityException  if the current thread is not allowed to\n     *               create or start the thread.\n     ",
    "links" : [ "java.lang.System#setSecurityManager(SecurityManager)", "#setDaemon(boolean)", "#getSystemClassLoader()" ]
  }, {
    "name" : "public static Cleaner create(ThreadFactory threadFactory)",
    "returnType" : "Cleaner",
    "comment" : "\n     * Returns a new {@code Cleaner} using a {@code Thread} from the {@code ThreadFactory}.\n     * <p>\n     * A thread from the thread factory's {@link ThreadFactory#newThread(Runnable) newThread}\n     * method is set to be a {@link Thread#setDaemon(boolean) daemon thread}\n     * and started to process phantom reachable objects and invoke cleaning actions.\n     * On each call the {@link ThreadFactory#newThread(Runnable) thread factory}\n     * must provide a Thread that is suitable for performing the cleaning actions.\n     * <p>\n     * The cleaner terminates when it is phantom reachable and all of the\n     * registered cleaning actions are complete.\n     *\n     * @param threadFactory a {@code ThreadFactory} to return a new {@code Thread}\n     *                      to process cleaning actions\n     * @return a new {@code Cleaner}\n     *\n     * @throws  IllegalThreadStateException  if the thread from the thread\n     *               factory was {@link Thread.State#NEW not a new thread}.\n     * @throws  SecurityException  if the current thread is not allowed to\n     *               create or start the thread.\n     ",
    "links" : [ "#setDaemon(boolean)", "java.util.concurrent.ThreadFactory#newThread(Runnable)", "Thread.State#NEW" ]
  }, {
    "name" : "public static Cleaner createSystemCleaner()",
    "returnType" : "Cleaner",
    "comment" : "\n     * Returns a new {@code Cleaner} associated with the finalizer thread.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Cleanable register(Object obj, Runnable action)",
    "returnType" : "Cleanable",
    "comment" : "\n     * Registers an object and a cleaning action to run when the object\n     * becomes phantom reachable.\n     * Refer to the <a href=\"#compatible-cleaners\">API Note</a> above for\n     * cautions about the behavior of cleaning actions.\n     *\n     * @param obj   the object to monitor\n     * @param action a {@code Runnable} to invoke when the object becomes phantom reachable\n     * @return a {@code Cleanable} instance\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public static Cleaner create()", "public static Cleaner create(ThreadFactory threadFactory)", "public static Cleaner createSystemCleaner()", "public Cleanable register(Object obj, Runnable action)" ],
  "variableNames" : [ "impl" ]
}