{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/hardware/camera2/CaptureResult.java",
  "packageName" : "android.hardware.camera2",
  "className" : "CaptureResult",
  "comment" : "\n * <p>The subset of the results of a single image capture from the image sensor.</p>\n *\n * <p>Contains a subset of the final configuration for the capture hardware (sensor, lens,\n * flash), the processing pipeline, the control algorithms, and the output\n * buffers.</p>\n *\n * <p>CaptureResults are produced by a {@link CameraDevice} after processing a\n * {@link CaptureRequest}. All properties listed for capture requests can also\n * be queried on the capture result, to determine the final values used for\n * capture. The result also includes additional metadata about the state of the\n * camera device during the capture.</p>\n *\n * <p>Not all properties returned by {@link CameraCharacteristics#getAvailableCaptureResultKeys()}\n * are necessarily available. Some results are {@link CaptureResult partial} and will\n * not have every key set. Only {@link TotalCaptureResult total} results are guaranteed to have\n * every key available that was enabled by the request.</p>\n *\n * <p>{@link CaptureResult} objects are immutable.</p>\n *\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "VERBOSE",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mResults",
    "type" : "CameraMetadataNative",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRequest",
    "type" : "CaptureRequest",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSequenceId",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFrameNumber",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "COLOR_CORRECTION_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>The mode control selects how the image data is converted from the\n     * sensor's native color into linear sRGB color.</p>\n     * <p>When auto-white balance (AWB) is enabled with {@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode}, this\n     * control is overridden by the AWB routine. When AWB is disabled, the\n     * application controls how the color mapping is performed.</p>\n     * <p>We define the expected processing pipeline below. For consistency\n     * across devices, this is always the case with TRANSFORM_MATRIX.</p>\n     * <p>When either FAST or HIGH_QUALITY is used, the camera device may\n     * do additional processing but {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} and\n     * {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform} will still be provided by the\n     * camera device (in the results) and be roughly correct.</p>\n     * <p>Switching to TRANSFORM_MATRIX and using the data provided from\n     * FAST or HIGH_QUALITY will yield a picture with the same white point\n     * as what was produced by the camera device in the earlier frame.</p>\n     * <p>The expected processing pipeline is as follows:</p>\n     * <p><img alt=\"White balance processing pipeline\" src=\"/reference/images/camera2/metadata/android.colorCorrection.mode/processing_pipeline.png\" /></p>\n     * <p>The white balance is encoded by two values, a 4-channel white-balance\n     * gain vector (applied in the Bayer domain), and a 3x3 color transform\n     * matrix (applied after demosaic).</p>\n     * <p>The 4-channel white-balance gains are defined as:</p>\n     * <pre><code>{@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} = [ R G_even G_odd B ]\n     * </code></pre>\n     * <p>where <code>G_even</code> is the gain for green pixels on even rows of the\n     * output, and <code>G_odd</code> is the gain for green pixels on the odd rows.\n     * These may be identical for a given camera device implementation; if\n     * the camera device does not support a separate gain for even/odd green\n     * channels, it will use the <code>G_even</code> value, and write <code>G_odd</code> equal to\n     * <code>G_even</code> in the output result metadata.</p>\n     * <p>The matrices for color transforms are defined as a 9-entry vector:</p>\n     * <pre><code>{@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform} = [ I0 I1 I2 I3 I4 I5 I6 I7 I8 ]\n     * </code></pre>\n     * <p>which define a transform from input sensor colors, <code>P_in = [ r g b ]</code>,\n     * to output linear sRGB, <code>P_out = [ r' g' b' ]</code>,</p>\n     * <p>with colors as follows:</p>\n     * <pre><code>r' = I0r + I1g + I2b\n     * g' = I3r + I4g + I5b\n     * b' = I6r + I7g + I8b\n     * </code></pre>\n     * <p>Both the input and output value ranges must match. Overflow/underflow\n     * values are clipped to fit within the range.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #COLOR_CORRECTION_MODE_TRANSFORM_MATRIX TRANSFORM_MATRIX}</li>\n     *   <li>{@link #COLOR_CORRECTION_MODE_FAST FAST}</li>\n     *   <li>{@link #COLOR_CORRECTION_MODE_HIGH_QUALITY HIGH_QUALITY}</li>\n     * </ul></p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#COLOR_CORRECTION_GAINS\n     * @see CaptureRequest#COLOR_CORRECTION_TRANSFORM\n     * @see CaptureRequest#CONTROL_AWB_MODE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see #COLOR_CORRECTION_MODE_TRANSFORM_MATRIX\n     * @see #COLOR_CORRECTION_MODE_FAST\n     * @see #COLOR_CORRECTION_MODE_HIGH_QUALITY\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "#COLOR_CORRECTION_MODE_FAST", "#COLOR_CORRECTION_MODE_TRANSFORM_MATRIX", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "android.hardware.camera2.CaptureRequest#CONTROL_AWB_MODE", "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_GAINS", "#COLOR_CORRECTION_MODE_HIGH_QUALITY", "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_TRANSFORM" ]
  }, {
    "name" : "COLOR_CORRECTION_TRANSFORM",
    "type" : "Key<android.hardware.camera2.params.ColorSpaceTransform>",
    "comment" : "\n     * <p>A color transform matrix to use to transform\n     * from sensor RGB color space to output linear sRGB color space.</p>\n     * <p>This matrix is either set by the camera device when the request\n     * {@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode} is not TRANSFORM_MATRIX, or\n     * directly by the application in the request when the\n     * {@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode} is TRANSFORM_MATRIX.</p>\n     * <p>In the latter case, the camera device may round the matrix to account\n     * for precision issues; the final rounded matrix should be reported back\n     * in this matrix result metadata. The transform should keep the magnitude\n     * of the output color values within <code>[0, 1.0]</code> (assuming input color\n     * values is within the normalized range <code>[0, 1.0]</code>), or clipping may occur.</p>\n     * <p>The valid range of each matrix element varies on different devices, but\n     * values within [-1.5, 3.0] are guaranteed not to be clipped.</p>\n     * <p><b>Units</b>: Unitless scale factors</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#COLOR_CORRECTION_MODE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_MODE", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL" ]
  }, {
    "name" : "COLOR_CORRECTION_GAINS",
    "type" : "Key<android.hardware.camera2.params.RggbChannelVector>",
    "comment" : "\n     * <p>Gains applying to Bayer raw color channels for\n     * white-balance.</p>\n     * <p>These per-channel gains are either set by the camera device\n     * when the request {@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode} is not\n     * TRANSFORM_MATRIX, or directly by the application in the\n     * request when the {@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode} is\n     * TRANSFORM_MATRIX.</p>\n     * <p>The gains in the result metadata are the gains actually\n     * applied by the camera device to the current frame.</p>\n     * <p>The valid range of gains varies on different devices, but gains\n     * between [1.0, 3.0] are guaranteed not to be clipped. Even if a given\n     * device allows gains below 1.0, this is usually not recommended because\n     * this can create color artifacts.</p>\n     * <p><b>Units</b>: Unitless gain factors</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#COLOR_CORRECTION_MODE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_MODE", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL" ]
  }, {
    "name" : "COLOR_CORRECTION_ABERRATION_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Mode of operation for the chromatic aberration correction algorithm.</p>\n     * <p>Chromatic (color) aberration is caused by the fact that different wavelengths of light\n     * can not focus on the same point after exiting from the lens. This metadata defines\n     * the high level control of chromatic aberration correction algorithm, which aims to\n     * minimize the chromatic artifacts that may occur along the object boundaries in an\n     * image.</p>\n     * <p>FAST/HIGH_QUALITY both mean that camera device determined aberration\n     * correction will be applied. HIGH_QUALITY mode indicates that the camera device will\n     * use the highest-quality aberration correction algorithms, even if it slows down\n     * capture rate. FAST means the camera device will not slow down capture rate when\n     * applying aberration correction.</p>\n     * <p>LEGACY devices will always be in FAST mode.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #COLOR_CORRECTION_ABERRATION_MODE_OFF OFF}</li>\n     *   <li>{@link #COLOR_CORRECTION_ABERRATION_MODE_FAST FAST}</li>\n     *   <li>{@link #COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY HIGH_QUALITY}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES android.colorCorrection.availableAberrationModes}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CameraCharacteristics#COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES\n     * @see #COLOR_CORRECTION_ABERRATION_MODE_OFF\n     * @see #COLOR_CORRECTION_ABERRATION_MODE_FAST\n     * @see #COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY\n     ",
    "links" : [ "#COLOR_CORRECTION_ABERRATION_MODE_OFF", "#COLOR_CORRECTION_ABERRATION_MODE_FAST", "#COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY", "android.hardware.camera2.CameraCharacteristics#COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES" ]
  }, {
    "name" : "CONTROL_AE_ANTIBANDING_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>The desired setting for the camera device's auto-exposure\n     * algorithm's antibanding compensation.</p>\n     * <p>Some kinds of lighting fixtures, such as some fluorescent\n     * lights, flicker at the rate of the power supply frequency\n     * (60Hz or 50Hz, depending on country). While this is\n     * typically not noticeable to a person, it can be visible to\n     * a camera device. If a camera sets its exposure time to the\n     * wrong value, the flicker may become visible in the\n     * viewfinder as flicker or in a final captured image, as a\n     * set of variable-brightness bands across the image.</p>\n     * <p>Therefore, the auto-exposure routines of camera devices\n     * include antibanding routines that ensure that the chosen\n     * exposure value will not cause such banding. The choice of\n     * exposure time depends on the rate of flicker, which the\n     * camera device can detect automatically, or the expected\n     * rate can be selected by the application using this\n     * control.</p>\n     * <p>A given camera device may not support all of the possible\n     * options for the antibanding mode. The\n     * {@link CameraCharacteristics#CONTROL_AE_AVAILABLE_ANTIBANDING_MODES android.control.aeAvailableAntibandingModes} key contains\n     * the available modes for a given camera device.</p>\n     * <p>AUTO mode is the default if it is available on given\n     * camera device. When AUTO mode is not available, the\n     * default will be either 50HZ or 60HZ, and both 50HZ\n     * and 60HZ will be available.</p>\n     * <p>If manual exposure control is enabled (by setting\n     * {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} or {@link CaptureRequest#CONTROL_MODE android.control.mode} to OFF),\n     * then this setting has no effect, and the application must\n     * ensure it selects exposure times that do not cause banding\n     * issues. The {@link CaptureResult#STATISTICS_SCENE_FLICKER android.statistics.sceneFlicker} key can assist\n     * the application in this.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_AE_ANTIBANDING_MODE_OFF OFF}</li>\n     *   <li>{@link #CONTROL_AE_ANTIBANDING_MODE_50HZ 50HZ}</li>\n     *   <li>{@link #CONTROL_AE_ANTIBANDING_MODE_60HZ 60HZ}</li>\n     *   <li>{@link #CONTROL_AE_ANTIBANDING_MODE_AUTO AUTO}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br></p>\n     * <p>{@link CameraCharacteristics#CONTROL_AE_AVAILABLE_ANTIBANDING_MODES android.control.aeAvailableAntibandingModes}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CameraCharacteristics#CONTROL_AE_AVAILABLE_ANTIBANDING_MODES\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CaptureRequest#CONTROL_MODE\n     * @see CaptureResult#STATISTICS_SCENE_FLICKER\n     * @see #CONTROL_AE_ANTIBANDING_MODE_OFF\n     * @see #CONTROL_AE_ANTIBANDING_MODE_50HZ\n     * @see #CONTROL_AE_ANTIBANDING_MODE_60HZ\n     * @see #CONTROL_AE_ANTIBANDING_MODE_AUTO\n     ",
    "links" : [ "android.hardware.camera2.CaptureResult#STATISTICS_SCENE_FLICKER", "#CONTROL_AE_ANTIBANDING_MODE_50HZ", "#CONTROL_AE_ANTIBANDING_MODE_AUTO", "android.hardware.camera2.CaptureRequest#CONTROL_AE_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_MODE", "#CONTROL_AE_ANTIBANDING_MODE_60HZ", "#CONTROL_AE_ANTIBANDING_MODE_OFF", "android.hardware.camera2.CameraCharacteristics#CONTROL_AE_AVAILABLE_ANTIBANDING_MODES" ]
  }, {
    "name" : "CONTROL_AE_EXPOSURE_COMPENSATION",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Adjustment to auto-exposure (AE) target image\n     * brightness.</p>\n     * <p>The adjustment is measured as a count of steps, with the\n     * step size defined by {@link CameraCharacteristics#CONTROL_AE_COMPENSATION_STEP android.control.aeCompensationStep} and the\n     * allowed range by {@link CameraCharacteristics#CONTROL_AE_COMPENSATION_RANGE android.control.aeCompensationRange}.</p>\n     * <p>For example, if the exposure value (EV) step is 0.333, '6'\n     * will mean an exposure compensation of +2 EV; -3 will mean an\n     * exposure compensation of -1 EV. One EV represents a doubling\n     * of image brightness. Note that this control will only be\n     * effective if {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} <code>!=</code> OFF. This control\n     * will take effect even when {@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} <code>== true</code>.</p>\n     * <p>In the event of exposure compensation value being changed, camera device\n     * may take several frames to reach the newly requested exposure target.\n     * During that time, {@link CaptureResult#CONTROL_AE_STATE android.control.aeState} field will be in the SEARCHING\n     * state. Once the new exposure target is reached, {@link CaptureResult#CONTROL_AE_STATE android.control.aeState} will\n     * change from SEARCHING to either CONVERGED, LOCKED (if AE lock is enabled), or\n     * FLASH_REQUIRED (if the scene is too dark for still capture).</p>\n     * <p><b>Units</b>: Compensation steps</p>\n     * <p><b>Range of valid values:</b><br>\n     * {@link CameraCharacteristics#CONTROL_AE_COMPENSATION_RANGE android.control.aeCompensationRange}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CameraCharacteristics#CONTROL_AE_COMPENSATION_RANGE\n     * @see CameraCharacteristics#CONTROL_AE_COMPENSATION_STEP\n     * @see CaptureRequest#CONTROL_AE_LOCK\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CaptureResult#CONTROL_AE_STATE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#CONTROL_AE_MODE", "android.hardware.camera2.CaptureResult#CONTROL_AE_STATE", "android.hardware.camera2.CameraCharacteristics#CONTROL_AE_COMPENSATION_STEP", "android.hardware.camera2.CaptureRequest#CONTROL_AE_LOCK", "android.hardware.camera2.CameraCharacteristics#CONTROL_AE_COMPENSATION_RANGE" ]
  }, {
    "name" : "CONTROL_AE_LOCK",
    "type" : "Key<Boolean>",
    "comment" : "\n     * <p>Whether auto-exposure (AE) is currently locked to its latest\n     * calculated values.</p>\n     * <p>When set to <code>true</code> (ON), the AE algorithm is locked to its latest parameters,\n     * and will not change exposure settings until the lock is set to <code>false</code> (OFF).</p>\n     * <p>Note that even when AE is locked, the flash may be fired if\n     * the {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} is ON_AUTO_FLASH /\n     * ON_ALWAYS_FLASH / ON_AUTO_FLASH_REDEYE.</p>\n     * <p>When {@link CaptureRequest#CONTROL_AE_EXPOSURE_COMPENSATION android.control.aeExposureCompensation} is changed, even if the AE lock\n     * is ON, the camera device will still adjust its exposure value.</p>\n     * <p>If AE precapture is triggered (see {@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger})\n     * when AE is already locked, the camera device will not change the exposure time\n     * ({@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime}) and sensitivity ({@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity})\n     * parameters. The flash may be fired if the {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode}\n     * is ON_AUTO_FLASH/ON_AUTO_FLASH_REDEYE and the scene is too dark. If the\n     * {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} is ON_ALWAYS_FLASH, the scene may become overexposed.\n     * Similarly, AE precapture trigger CANCEL has no effect when AE is already locked.</p>\n     * <p>When an AE precapture sequence is triggered, AE unlock will not be able to unlock\n     * the AE if AE is locked by the camera device internally during precapture metering\n     * sequence In other words, submitting requests with AE unlock has no effect for an\n     * ongoing precapture metering sequence. Otherwise, the precapture metering sequence\n     * will never succeed in a sequence of preview requests where AE lock is always set\n     * to <code>false</code>.</p>\n     * <p>Since the camera device has a pipeline of in-flight requests, the settings that\n     * get locked do not necessarily correspond to the settings that were present in the\n     * latest capture result received from the camera device, since additional captures\n     * and AE updates may have occurred even before the result was sent out. If an\n     * application is switching between automatic and manual control and wishes to eliminate\n     * any flicker during the switch, the following procedure is recommended:</p>\n     * <ol>\n     * <li>Starting in auto-AE mode:</li>\n     * <li>Lock AE</li>\n     * <li>Wait for the first result to be output that has the AE locked</li>\n     * <li>Copy exposure settings from that result into a request, set the request to manual AE</li>\n     * <li>Submit the capture request, proceed to run manual AE as desired.</li>\n     * </ol>\n     * <p>See {@link CaptureResult#CONTROL_AE_STATE android.control.aeState} for AE lock related state transition details.</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_EXPOSURE_COMPENSATION\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER\n     * @see CaptureResult#CONTROL_AE_STATE\n     * @see CaptureRequest#SENSOR_EXPOSURE_TIME\n     * @see CaptureRequest#SENSOR_SENSITIVITY\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#SENSOR_SENSITIVITY", "android.hardware.camera2.CaptureRequest#CONTROL_AE_MODE", "android.hardware.camera2.CaptureResult#CONTROL_AE_STATE", "android.hardware.camera2.CaptureRequest#CONTROL_AE_EXPOSURE_COMPENSATION", "android.hardware.camera2.CaptureRequest#SENSOR_EXPOSURE_TIME", "android.hardware.camera2.CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER" ]
  }, {
    "name" : "CONTROL_AE_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>The desired mode for the camera device's\n     * auto-exposure routine.</p>\n     * <p>This control is only effective if {@link CaptureRequest#CONTROL_MODE android.control.mode} is\n     * AUTO.</p>\n     * <p>When set to any of the ON modes, the camera device's\n     * auto-exposure routine is enabled, overriding the\n     * application's selected exposure time, sensor sensitivity,\n     * and frame duration ({@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime},\n     * {@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}, and\n     * {@link CaptureRequest#SENSOR_FRAME_DURATION android.sensor.frameDuration}). If one of the FLASH modes\n     * is selected, the camera device's flash unit controls are\n     * also overridden.</p>\n     * <p>The FLASH modes are only available if the camera device\n     * has a flash unit ({@link CameraCharacteristics#FLASH_INFO_AVAILABLE android.flash.info.available} is <code>true</code>).</p>\n     * <p>If flash TORCH mode is desired, this field must be set to\n     * ON or OFF, and {@link CaptureRequest#FLASH_MODE android.flash.mode} set to TORCH.</p>\n     * <p>When set to any of the ON modes, the values chosen by the\n     * camera device auto-exposure routine for the overridden\n     * fields for a given capture will be available in its\n     * CaptureResult.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_AE_MODE_OFF OFF}</li>\n     *   <li>{@link #CONTROL_AE_MODE_ON ON}</li>\n     *   <li>{@link #CONTROL_AE_MODE_ON_AUTO_FLASH ON_AUTO_FLASH}</li>\n     *   <li>{@link #CONTROL_AE_MODE_ON_ALWAYS_FLASH ON_ALWAYS_FLASH}</li>\n     *   <li>{@link #CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE ON_AUTO_FLASH_REDEYE}</li>\n     *   <li>{@link #CONTROL_AE_MODE_ON_EXTERNAL_FLASH ON_EXTERNAL_FLASH}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#CONTROL_AE_AVAILABLE_MODES android.control.aeAvailableModes}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CameraCharacteristics#CONTROL_AE_AVAILABLE_MODES\n     * @see CaptureRequest#CONTROL_MODE\n     * @see CameraCharacteristics#FLASH_INFO_AVAILABLE\n     * @see CaptureRequest#FLASH_MODE\n     * @see CaptureRequest#SENSOR_EXPOSURE_TIME\n     * @see CaptureRequest#SENSOR_FRAME_DURATION\n     * @see CaptureRequest#SENSOR_SENSITIVITY\n     * @see #CONTROL_AE_MODE_OFF\n     * @see #CONTROL_AE_MODE_ON\n     * @see #CONTROL_AE_MODE_ON_AUTO_FLASH\n     * @see #CONTROL_AE_MODE_ON_ALWAYS_FLASH\n     * @see #CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE\n     * @see #CONTROL_AE_MODE_ON_EXTERNAL_FLASH\n     ",
    "links" : [ "#CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE", "#CONTROL_AE_MODE_ON_EXTERNAL_FLASH", "android.hardware.camera2.CameraCharacteristics#FLASH_INFO_AVAILABLE", "android.hardware.camera2.CaptureRequest#FLASH_MODE", "#CONTROL_AE_MODE_ON_AUTO_FLASH", "android.hardware.camera2.CaptureRequest#SENSOR_SENSITIVITY", "android.hardware.camera2.CaptureRequest#SENSOR_FRAME_DURATION", "android.hardware.camera2.CaptureRequest#CONTROL_MODE", "#CONTROL_AE_MODE_OFF", "#CONTROL_AE_MODE_ON", "android.hardware.camera2.CameraCharacteristics#CONTROL_AE_AVAILABLE_MODES", "android.hardware.camera2.CaptureRequest#SENSOR_EXPOSURE_TIME", "#CONTROL_AE_MODE_ON_ALWAYS_FLASH" ]
  }, {
    "name" : "CONTROL_AE_REGIONS",
    "type" : "Key<android.hardware.camera2.params.MeteringRectangle[]>",
    "comment" : "\n     * <p>List of metering areas to use for auto-exposure adjustment.</p>\n     * <p>Not available if {@link CameraCharacteristics#CONTROL_MAX_REGIONS_AE android.control.maxRegionsAe} is 0.\n     * Otherwise will always be present.</p>\n     * <p>The maximum number of regions supported by the device is determined by the value\n     * of {@link CameraCharacteristics#CONTROL_MAX_REGIONS_AE android.control.maxRegionsAe}.</p>\n     * <p>For devices not supporting {@link CaptureRequest#DISTORTION_CORRECTION_MODE android.distortionCorrection.mode} control, the coordinate\n     * system always follows that of {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, with (0,0) being\n     * the top-left pixel in the active pixel array, and\n     * ({@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.width - 1,\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.height - 1) being the bottom-right pixel in the\n     * active pixel array.</p>\n     * <p>For devices supporting {@link CaptureRequest#DISTORTION_CORRECTION_MODE android.distortionCorrection.mode} control, the coordinate\n     * system depends on the mode being set.\n     * When the distortion correction mode is OFF, the coordinate system follows\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}, with\n     * <code>(0, 0)</code> being the top-left pixel of the pre-correction active array, and\n     * ({@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}.width - 1,\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}.height - 1) being the bottom-right\n     * pixel in the pre-correction active pixel array.\n     * When the distortion correction mode is not OFF, the coordinate system follows\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, with\n     * <code>(0, 0)</code> being the top-left pixel of the active array, and\n     * ({@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.width - 1,\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.height - 1) being the bottom-right pixel in the\n     * active pixel array.</p>\n     * <p>The weight must be within <code>[0, 1000]</code>, and represents a weight\n     * for every pixel in the area. This means that a large metering area\n     * with the same weight as a smaller area will have more effect in\n     * the metering result. Metering areas can partially overlap and the\n     * camera device will add the weights in the overlap region.</p>\n     * <p>The weights are relative to weights of other exposure metering regions, so if only one\n     * region is used, all non-zero weights will have the same effect. A region with 0\n     * weight is ignored.</p>\n     * <p>If all regions have 0 weight, then no specific metering area needs to be used by the\n     * camera device.</p>\n     * <p>If the metering region is outside the used {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} returned in\n     * capture result metadata, the camera device will ignore the sections outside the crop\n     * region and output only the intersection rectangle as the metering region in the result\n     * metadata.  If the region is entirely outside the crop region, it will be ignored and\n     * not reported in the result metadata.</p>\n     * <p>Starting from API level 30, the coordinate system of activeArraySize or\n     * preCorrectionActiveArraySize is used to represent post-zoomRatio field of view, not\n     * pre-zoom field of view. This means that the same aeRegions values at different\n     * {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} represent different parts of the scene. The aeRegions\n     * coordinates are relative to the activeArray/preCorrectionActiveArray representing the\n     * zoomed field of view. If {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} is set to 1.0 (default), the same\n     * aeRegions at different {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} still represent the same parts of the\n     * scene as they do before. See {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} for details. Whether to use\n     * activeArraySize or preCorrectionActiveArraySize still depends on distortion correction\n     * mode.</p>\n     * <p><b>Units</b>: Pixel coordinates within {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize} or\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize} depending on\n     * distortion correction capability and mode</p>\n     * <p><b>Range of valid values:</b><br>\n     * Coordinates must be between <code>[(0,0), (width, height))</code> of\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize} or {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}\n     * depending on distortion correction capability and mode</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CameraCharacteristics#CONTROL_MAX_REGIONS_AE\n     * @see CaptureRequest#CONTROL_ZOOM_RATIO\n     * @see CaptureRequest#DISTORTION_CORRECTION_MODE\n     * @see CaptureRequest#SCALER_CROP_REGION\n     * @see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE\n     * @see CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#CONTROL_MAX_REGIONS_AE", "android.hardware.camera2.CaptureRequest#DISTORTION_CORRECTION_MODE", "android.hardware.camera2.CaptureRequest#SCALER_CROP_REGION", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE", "android.hardware.camera2.CaptureRequest#CONTROL_ZOOM_RATIO" ]
  }, {
    "name" : "CONTROL_AE_TARGET_FPS_RANGE",
    "type" : "Key<android.util.Range<Integer>>",
    "comment" : "\n     * <p>Range over which the auto-exposure routine can\n     * adjust the capture frame rate to maintain good\n     * exposure.</p>\n     * <p>Only constrains auto-exposure (AE) algorithm, not\n     * manual control of {@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime} and\n     * {@link CaptureRequest#SENSOR_FRAME_DURATION android.sensor.frameDuration}.</p>\n     * <p><b>Units</b>: Frames per second (FPS)</p>\n     * <p><b>Range of valid values:</b><br>\n     * Any of the entries in {@link CameraCharacteristics#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES android.control.aeAvailableTargetFpsRanges}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CameraCharacteristics#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES\n     * @see CaptureRequest#SENSOR_EXPOSURE_TIME\n     * @see CaptureRequest#SENSOR_FRAME_DURATION\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#SENSOR_FRAME_DURATION", "android.hardware.camera2.CameraCharacteristics#CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES", "android.hardware.camera2.CaptureRequest#SENSOR_EXPOSURE_TIME" ]
  }, {
    "name" : "CONTROL_AE_PRECAPTURE_TRIGGER",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Whether the camera device will trigger a precapture\n     * metering sequence when it processes this request.</p>\n     * <p>This entry is normally set to IDLE, or is not\n     * included at all in the request settings. When included and\n     * set to START, the camera device will trigger the auto-exposure (AE)\n     * precapture metering sequence.</p>\n     * <p>When set to CANCEL, the camera device will cancel any active\n     * precapture metering trigger, and return to its initial AE state.\n     * If a precapture metering sequence is already completed, and the camera\n     * device has implicitly locked the AE for subsequent still capture, the\n     * CANCEL trigger will unlock the AE and return to its initial AE state.</p>\n     * <p>The precapture sequence should be triggered before starting a\n     * high-quality still capture for final metering decisions to\n     * be made, and for firing pre-capture flash pulses to estimate\n     * scene brightness and required final capture flash power, when\n     * the flash is enabled.</p>\n     * <p>Normally, this entry should be set to START for only a\n     * single request, and the application should wait until the\n     * sequence completes before starting a new one.</p>\n     * <p>When a precapture metering sequence is finished, the camera device\n     * may lock the auto-exposure routine internally to be able to accurately expose the\n     * subsequent still capture image (<code>{@link CaptureRequest#CONTROL_CAPTURE_INTENT android.control.captureIntent} == STILL_CAPTURE</code>).\n     * For this case, the AE may not resume normal scan if no subsequent still capture is\n     * submitted. To ensure that the AE routine restarts normal scan, the application should\n     * submit a request with <code>{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} == true</code>, followed by a request\n     * with <code>{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} == false</code>, if the application decides not to submit a\n     * still capture request after the precapture sequence completes. Alternatively, for\n     * API level 23 or newer devices, the CANCEL can be used to unlock the camera device\n     * internally locked AE if the application doesn't submit a still capture request after\n     * the AE precapture trigger. Note that, the CANCEL was added in API level 23, and must not\n     * be used in devices that have earlier API levels.</p>\n     * <p>The exact effect of auto-exposure (AE) precapture trigger\n     * depends on the current AE mode and state; see\n     * {@link CaptureResult#CONTROL_AE_STATE android.control.aeState} for AE precapture state transition\n     * details.</p>\n     * <p>On LEGACY-level devices, the precapture trigger is not supported;\n     * capturing a high-resolution JPEG image will automatically trigger a\n     * precapture sequence before the high-resolution capture, including\n     * potentially firing a pre-capture flash.</p>\n     * <p>Using the precapture trigger and the auto-focus trigger {@link CaptureRequest#CONTROL_AF_TRIGGER android.control.afTrigger}\n     * simultaneously is allowed. However, since these triggers often require cooperation between\n     * the auto-focus and auto-exposure routines (for example, the may need to be enabled for a\n     * focus sweep), the camera device may delay acting on a later trigger until the previous\n     * trigger has been fully handled. This may lead to longer intervals between the trigger and\n     * changes to {@link CaptureResult#CONTROL_AE_STATE android.control.aeState} indicating the start of the precapture sequence, for\n     * example.</p>\n     * <p>If both the precapture and the auto-focus trigger are activated on the same request, then\n     * the camera device will complete them in the optimal order for that device.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_AE_PRECAPTURE_TRIGGER_IDLE IDLE}</li>\n     *   <li>{@link #CONTROL_AE_PRECAPTURE_TRIGGER_START START}</li>\n     *   <li>{@link #CONTROL_AE_PRECAPTURE_TRIGGER_CANCEL CANCEL}</li>\n     * </ul></p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Limited capability</b> -\n     * Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_LOCK\n     * @see CaptureResult#CONTROL_AE_STATE\n     * @see CaptureRequest#CONTROL_AF_TRIGGER\n     * @see CaptureRequest#CONTROL_CAPTURE_INTENT\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see #CONTROL_AE_PRECAPTURE_TRIGGER_IDLE\n     * @see #CONTROL_AE_PRECAPTURE_TRIGGER_START\n     * @see #CONTROL_AE_PRECAPTURE_TRIGGER_CANCEL\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "#CONTROL_AE_PRECAPTURE_TRIGGER_START", "android.hardware.camera2.CaptureResult#CONTROL_AE_STATE", "android.hardware.camera2.CaptureRequest#CONTROL_AE_LOCK", "#CONTROL_AE_PRECAPTURE_TRIGGER_CANCEL", "android.hardware.camera2.CaptureRequest#CONTROL_AF_TRIGGER", "#CONTROL_AE_PRECAPTURE_TRIGGER_IDLE", "android.hardware.camera2.CaptureRequest#CONTROL_CAPTURE_INTENT", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED" ]
  }, {
    "name" : "CONTROL_AE_STATE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Current state of the auto-exposure (AE) algorithm.</p>\n     * <p>Switching between or enabling AE modes ({@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode}) always\n     * resets the AE state to INACTIVE. Similarly, switching between {@link CaptureRequest#CONTROL_MODE android.control.mode},\n     * or {@link CaptureRequest#CONTROL_SCENE_MODE android.control.sceneMode} if <code>{@link CaptureRequest#CONTROL_MODE android.control.mode} == USE_SCENE_MODE</code> resets all\n     * the algorithm states to INACTIVE.</p>\n     * <p>The camera device can do several state transitions between two results, if it is\n     * allowed by the state transition table. For example: INACTIVE may never actually be\n     * seen in a result.</p>\n     * <p>The state in the result is the state for this image (in sync with this image): if\n     * AE state becomes CONVERGED, then the image data associated with this result should\n     * be good to use.</p>\n     * <p>Below are state transition tables for different AE modes.</p>\n     * <table>\n     * <thead>\n     * <tr>\n     * <th align=\"center\">State</th>\n     * <th align=\"center\">Transition Cause</th>\n     * <th align=\"center\">New State</th>\n     * <th align=\"center\">Notes</th>\n     * </tr>\n     * </thead>\n     * <tbody>\n     * <tr>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\"></td>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">Camera device auto exposure algorithm is disabled</td>\n     * </tr>\n     * </tbody>\n     * </table>\n     * <p>When {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} is AE_MODE_ON*:</p>\n     * <table>\n     * <thead>\n     * <tr>\n     * <th align=\"center\">State</th>\n     * <th align=\"center\">Transition Cause</th>\n     * <th align=\"center\">New State</th>\n     * <th align=\"center\">Notes</th>\n     * </tr>\n     * </thead>\n     * <tbody>\n     * <tr>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">Camera device initiates AE scan</td>\n     * <td align=\"center\">SEARCHING</td>\n     * <td align=\"center\">Values changing</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} is ON</td>\n     * <td align=\"center\">LOCKED</td>\n     * <td align=\"center\">Values locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">SEARCHING</td>\n     * <td align=\"center\">Camera device finishes AE scan</td>\n     * <td align=\"center\">CONVERGED</td>\n     * <td align=\"center\">Good values, not changing</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">SEARCHING</td>\n     * <td align=\"center\">Camera device finishes AE scan</td>\n     * <td align=\"center\">FLASH_REQUIRED</td>\n     * <td align=\"center\">Converged but too dark w/o flash</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">SEARCHING</td>\n     * <td align=\"center\">{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} is ON</td>\n     * <td align=\"center\">LOCKED</td>\n     * <td align=\"center\">Values locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">CONVERGED</td>\n     * <td align=\"center\">Camera device initiates AE scan</td>\n     * <td align=\"center\">SEARCHING</td>\n     * <td align=\"center\">Values changing</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">CONVERGED</td>\n     * <td align=\"center\">{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} is ON</td>\n     * <td align=\"center\">LOCKED</td>\n     * <td align=\"center\">Values locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">FLASH_REQUIRED</td>\n     * <td align=\"center\">Camera device initiates AE scan</td>\n     * <td align=\"center\">SEARCHING</td>\n     * <td align=\"center\">Values changing</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">FLASH_REQUIRED</td>\n     * <td align=\"center\">{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} is ON</td>\n     * <td align=\"center\">LOCKED</td>\n     * <td align=\"center\">Values locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">LOCKED</td>\n     * <td align=\"center\">{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} is OFF</td>\n     * <td align=\"center\">SEARCHING</td>\n     * <td align=\"center\">Values not good after unlock</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">LOCKED</td>\n     * <td align=\"center\">{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} is OFF</td>\n     * <td align=\"center\">CONVERGED</td>\n     * <td align=\"center\">Values good after unlock</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">LOCKED</td>\n     * <td align=\"center\">{@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} is OFF</td>\n     * <td align=\"center\">FLASH_REQUIRED</td>\n     * <td align=\"center\">Exposure good, but too dark</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">PRECAPTURE</td>\n     * <td align=\"center\">Sequence done. {@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} is OFF</td>\n     * <td align=\"center\">CONVERGED</td>\n     * <td align=\"center\">Ready for high-quality capture</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">PRECAPTURE</td>\n     * <td align=\"center\">Sequence done. {@link CaptureRequest#CONTROL_AE_LOCK android.control.aeLock} is ON</td>\n     * <td align=\"center\">LOCKED</td>\n     * <td align=\"center\">Ready for high-quality capture</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">LOCKED</td>\n     * <td align=\"center\">aeLock is ON and aePrecaptureTrigger is START</td>\n     * <td align=\"center\">LOCKED</td>\n     * <td align=\"center\">Precapture trigger is ignored when AE is already locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">LOCKED</td>\n     * <td align=\"center\">aeLock is ON and aePrecaptureTrigger is CANCEL</td>\n     * <td align=\"center\">LOCKED</td>\n     * <td align=\"center\">Precapture trigger is ignored when AE is already locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">Any state (excluding LOCKED)</td>\n     * <td align=\"center\">{@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger} is START</td>\n     * <td align=\"center\">PRECAPTURE</td>\n     * <td align=\"center\">Start AE precapture metering sequence</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">Any state (excluding LOCKED)</td>\n     * <td align=\"center\">{@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger} is CANCEL</td>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">Currently active precapture metering sequence is canceled</td>\n     * </tr>\n     * </tbody>\n     * </table>\n     * <p>If the camera device supports AE external flash mode (ON_EXTERNAL_FLASH is included in\n     * {@link CameraCharacteristics#CONTROL_AE_AVAILABLE_MODES android.control.aeAvailableModes}), {@link CaptureResult#CONTROL_AE_STATE android.control.aeState} must be FLASH_REQUIRED after\n     * the camera device finishes AE scan and it's too dark without flash.</p>\n     * <p>For the above table, the camera device may skip reporting any state changes that happen\n     * without application intervention (i.e. mode switch, trigger, locking). Any state that\n     * can be skipped in that manner is called a transient state.</p>\n     * <p>For example, for above AE modes (AE_MODE_ON*), in addition to the state transitions\n     * listed in above table, it is also legal for the camera device to skip one or more\n     * transient states between two results. See below table for examples:</p>\n     * <table>\n     * <thead>\n     * <tr>\n     * <th align=\"center\">State</th>\n     * <th align=\"center\">Transition Cause</th>\n     * <th align=\"center\">New State</th>\n     * <th align=\"center\">Notes</th>\n     * </tr>\n     * </thead>\n     * <tbody>\n     * <tr>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">Camera device finished AE scan</td>\n     * <td align=\"center\">CONVERGED</td>\n     * <td align=\"center\">Values are already good, transient states are skipped by camera device.</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">Any state (excluding LOCKED)</td>\n     * <td align=\"center\">{@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger} is START, sequence done</td>\n     * <td align=\"center\">FLASH_REQUIRED</td>\n     * <td align=\"center\">Converged but too dark w/o flash after a precapture sequence, transient states are skipped by camera device.</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">Any state (excluding LOCKED)</td>\n     * <td align=\"center\">{@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger} is START, sequence done</td>\n     * <td align=\"center\">CONVERGED</td>\n     * <td align=\"center\">Converged after a precapture sequence, transient states are skipped by camera device.</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">Any state (excluding LOCKED)</td>\n     * <td align=\"center\">{@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger} is CANCEL, converged</td>\n     * <td align=\"center\">FLASH_REQUIRED</td>\n     * <td align=\"center\">Converged but too dark w/o flash after a precapture sequence is canceled, transient states are skipped by camera device.</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">Any state (excluding LOCKED)</td>\n     * <td align=\"center\">{@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger} is CANCEL, converged</td>\n     * <td align=\"center\">CONVERGED</td>\n     * <td align=\"center\">Converged after a precapture sequenceis canceled, transient states are skipped by camera device.</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">CONVERGED</td>\n     * <td align=\"center\">Camera device finished AE scan</td>\n     * <td align=\"center\">FLASH_REQUIRED</td>\n     * <td align=\"center\">Converged but too dark w/o flash after a new scan, transient states are skipped by camera device.</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">FLASH_REQUIRED</td>\n     * <td align=\"center\">Camera device finished AE scan</td>\n     * <td align=\"center\">CONVERGED</td>\n     * <td align=\"center\">Converged after a new scan, transient states are skipped by camera device.</td>\n     * </tr>\n     * </tbody>\n     * </table>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_AE_STATE_INACTIVE INACTIVE}</li>\n     *   <li>{@link #CONTROL_AE_STATE_SEARCHING SEARCHING}</li>\n     *   <li>{@link #CONTROL_AE_STATE_CONVERGED CONVERGED}</li>\n     *   <li>{@link #CONTROL_AE_STATE_LOCKED LOCKED}</li>\n     *   <li>{@link #CONTROL_AE_STATE_FLASH_REQUIRED FLASH_REQUIRED}</li>\n     *   <li>{@link #CONTROL_AE_STATE_PRECAPTURE PRECAPTURE}</li>\n     * </ul></p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Limited capability</b> -\n     * Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CameraCharacteristics#CONTROL_AE_AVAILABLE_MODES\n     * @see CaptureRequest#CONTROL_AE_LOCK\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER\n     * @see CaptureResult#CONTROL_AE_STATE\n     * @see CaptureRequest#CONTROL_MODE\n     * @see CaptureRequest#CONTROL_SCENE_MODE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see #CONTROL_AE_STATE_INACTIVE\n     * @see #CONTROL_AE_STATE_SEARCHING\n     * @see #CONTROL_AE_STATE_CONVERGED\n     * @see #CONTROL_AE_STATE_LOCKED\n     * @see #CONTROL_AE_STATE_FLASH_REQUIRED\n     * @see #CONTROL_AE_STATE_PRECAPTURE\n     ",
    "links" : [ "#CONTROL_AE_STATE_SEARCHING", "android.hardware.camera2.CaptureRequest#CONTROL_AE_LOCK", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED", "android.hardware.camera2.CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER", "#CONTROL_AE_STATE_PRECAPTURE", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CaptureRequest#CONTROL_AE_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_MODE", "android.hardware.camera2.CaptureResult#CONTROL_AE_STATE", "#CONTROL_AE_STATE_FLASH_REQUIRED", "#CONTROL_AE_STATE_LOCKED", "android.hardware.camera2.CaptureRequest#CONTROL_SCENE_MODE", "#CONTROL_AE_STATE_INACTIVE", "android.hardware.camera2.CameraCharacteristics#CONTROL_AE_AVAILABLE_MODES", "#CONTROL_AE_STATE_CONVERGED" ]
  }, {
    "name" : "CONTROL_AF_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Whether auto-focus (AF) is currently enabled, and what\n     * mode it is set to.</p>\n     * <p>Only effective if {@link CaptureRequest#CONTROL_MODE android.control.mode} = AUTO and the lens is not fixed focus\n     * (i.e. <code>{@link CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE android.lens.info.minimumFocusDistance} &gt; 0</code>). Also note that\n     * when {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} is OFF, the behavior of AF is device\n     * dependent. It is recommended to lock AF by using {@link CaptureRequest#CONTROL_AF_TRIGGER android.control.afTrigger} before\n     * setting {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} to OFF, or set AF mode to OFF when AE is OFF.</p>\n     * <p>If the lens is controlled by the camera device auto-focus algorithm,\n     * the camera device will report the current AF status in {@link CaptureResult#CONTROL_AF_STATE android.control.afState}\n     * in result metadata.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_AF_MODE_OFF OFF}</li>\n     *   <li>{@link #CONTROL_AF_MODE_AUTO AUTO}</li>\n     *   <li>{@link #CONTROL_AF_MODE_MACRO MACRO}</li>\n     *   <li>{@link #CONTROL_AF_MODE_CONTINUOUS_VIDEO CONTINUOUS_VIDEO}</li>\n     *   <li>{@link #CONTROL_AF_MODE_CONTINUOUS_PICTURE CONTINUOUS_PICTURE}</li>\n     *   <li>{@link #CONTROL_AF_MODE_EDOF EDOF}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#CONTROL_AF_AVAILABLE_MODES android.control.afAvailableModes}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CameraCharacteristics#CONTROL_AF_AVAILABLE_MODES\n     * @see CaptureResult#CONTROL_AF_STATE\n     * @see CaptureRequest#CONTROL_AF_TRIGGER\n     * @see CaptureRequest#CONTROL_MODE\n     * @see CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE\n     * @see #CONTROL_AF_MODE_OFF\n     * @see #CONTROL_AF_MODE_AUTO\n     * @see #CONTROL_AF_MODE_MACRO\n     * @see #CONTROL_AF_MODE_CONTINUOUS_VIDEO\n     * @see #CONTROL_AF_MODE_CONTINUOUS_PICTURE\n     * @see #CONTROL_AF_MODE_EDOF\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE", "#CONTROL_AF_MODE_CONTINUOUS_PICTURE", "android.hardware.camera2.CaptureRequest#CONTROL_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_AE_MODE", "#CONTROL_AF_MODE_OFF", "#CONTROL_AF_MODE_AUTO", "#CONTROL_AF_MODE_CONTINUOUS_VIDEO", "android.hardware.camera2.CameraCharacteristics#CONTROL_AF_AVAILABLE_MODES", "android.hardware.camera2.CaptureResult#CONTROL_AF_STATE", "#CONTROL_AF_MODE_EDOF", "android.hardware.camera2.CaptureRequest#CONTROL_AF_TRIGGER", "#CONTROL_AF_MODE_MACRO" ]
  }, {
    "name" : "CONTROL_AF_REGIONS",
    "type" : "Key<android.hardware.camera2.params.MeteringRectangle[]>",
    "comment" : "\n     * <p>List of metering areas to use for auto-focus.</p>\n     * <p>Not available if {@link CameraCharacteristics#CONTROL_MAX_REGIONS_AF android.control.maxRegionsAf} is 0.\n     * Otherwise will always be present.</p>\n     * <p>The maximum number of focus areas supported by the device is determined by the value\n     * of {@link CameraCharacteristics#CONTROL_MAX_REGIONS_AF android.control.maxRegionsAf}.</p>\n     * <p>For devices not supporting {@link CaptureRequest#DISTORTION_CORRECTION_MODE android.distortionCorrection.mode} control, the coordinate\n     * system always follows that of {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, with (0,0) being\n     * the top-left pixel in the active pixel array, and\n     * ({@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.width - 1,\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.height - 1) being the bottom-right pixel in the\n     * active pixel array.</p>\n     * <p>For devices supporting {@link CaptureRequest#DISTORTION_CORRECTION_MODE android.distortionCorrection.mode} control, the coordinate\n     * system depends on the mode being set.\n     * When the distortion correction mode is OFF, the coordinate system follows\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}, with\n     * <code>(0, 0)</code> being the top-left pixel of the pre-correction active array, and\n     * ({@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}.width - 1,\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}.height - 1) being the bottom-right\n     * pixel in the pre-correction active pixel array.\n     * When the distortion correction mode is not OFF, the coordinate system follows\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, with\n     * <code>(0, 0)</code> being the top-left pixel of the active array, and\n     * ({@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.width - 1,\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.height - 1) being the bottom-right pixel in the\n     * active pixel array.</p>\n     * <p>The weight must be within <code>[0, 1000]</code>, and represents a weight\n     * for every pixel in the area. This means that a large metering area\n     * with the same weight as a smaller area will have more effect in\n     * the metering result. Metering areas can partially overlap and the\n     * camera device will add the weights in the overlap region.</p>\n     * <p>The weights are relative to weights of other metering regions, so if only one region\n     * is used, all non-zero weights will have the same effect. A region with 0 weight is\n     * ignored.</p>\n     * <p>If all regions have 0 weight, then no specific metering area needs to be used by the\n     * camera device. The capture result will either be a zero weight region as well, or\n     * the region selected by the camera device as the focus area of interest.</p>\n     * <p>If the metering region is outside the used {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} returned in\n     * capture result metadata, the camera device will ignore the sections outside the crop\n     * region and output only the intersection rectangle as the metering region in the result\n     * metadata. If the region is entirely outside the crop region, it will be ignored and\n     * not reported in the result metadata.</p>\n     * <p>Starting from API level 30, the coordinate system of activeArraySize or\n     * preCorrectionActiveArraySize is used to represent post-zoomRatio field of view, not\n     * pre-zoom field of view. This means that the same afRegions values at different\n     * {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} represent different parts of the scene. The afRegions\n     * coordinates are relative to the activeArray/preCorrectionActiveArray representing the\n     * zoomed field of view. If {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} is set to 1.0 (default), the same\n     * afRegions at different {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} still represent the same parts of the\n     * scene as they do before. See {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} for details. Whether to use\n     * activeArraySize or preCorrectionActiveArraySize still depends on distortion correction\n     * mode.</p>\n     * <p><b>Units</b>: Pixel coordinates within {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize} or\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize} depending on\n     * distortion correction capability and mode</p>\n     * <p><b>Range of valid values:</b><br>\n     * Coordinates must be between <code>[(0,0), (width, height))</code> of\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize} or {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}\n     * depending on distortion correction capability and mode</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CameraCharacteristics#CONTROL_MAX_REGIONS_AF\n     * @see CaptureRequest#CONTROL_ZOOM_RATIO\n     * @see CaptureRequest#DISTORTION_CORRECTION_MODE\n     * @see CaptureRequest#SCALER_CROP_REGION\n     * @see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE\n     * @see CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#CONTROL_MAX_REGIONS_AF", "android.hardware.camera2.CaptureRequest#DISTORTION_CORRECTION_MODE", "android.hardware.camera2.CaptureRequest#SCALER_CROP_REGION", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE", "android.hardware.camera2.CaptureRequest#CONTROL_ZOOM_RATIO" ]
  }, {
    "name" : "CONTROL_AF_TRIGGER",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Whether the camera device will trigger autofocus for this request.</p>\n     * <p>This entry is normally set to IDLE, or is not\n     * included at all in the request settings.</p>\n     * <p>When included and set to START, the camera device will trigger the\n     * autofocus algorithm. If autofocus is disabled, this trigger has no effect.</p>\n     * <p>When set to CANCEL, the camera device will cancel any active trigger,\n     * and return to its initial AF state.</p>\n     * <p>Generally, applications should set this entry to START or CANCEL for only a\n     * single capture, and then return it to IDLE (or not set at all). Specifying\n     * START for multiple captures in a row means restarting the AF operation over\n     * and over again.</p>\n     * <p>See {@link CaptureResult#CONTROL_AF_STATE android.control.afState} for what the trigger means for each AF mode.</p>\n     * <p>Using the autofocus trigger and the precapture trigger {@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger}\n     * simultaneously is allowed. However, since these triggers often require cooperation between\n     * the auto-focus and auto-exposure routines (for example, the may need to be enabled for a\n     * focus sweep), the camera device may delay acting on a later trigger until the previous\n     * trigger has been fully handled. This may lead to longer intervals between the trigger and\n     * changes to {@link CaptureResult#CONTROL_AF_STATE android.control.afState}, for example.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_AF_TRIGGER_IDLE IDLE}</li>\n     *   <li>{@link #CONTROL_AF_TRIGGER_START START}</li>\n     *   <li>{@link #CONTROL_AF_TRIGGER_CANCEL CANCEL}</li>\n     * </ul></p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER\n     * @see CaptureResult#CONTROL_AF_STATE\n     * @see #CONTROL_AF_TRIGGER_IDLE\n     * @see #CONTROL_AF_TRIGGER_START\n     * @see #CONTROL_AF_TRIGGER_CANCEL\n     ",
    "links" : [ "#CONTROL_AF_TRIGGER_IDLE", "#CONTROL_AF_TRIGGER_START", "android.hardware.camera2.CaptureResult#CONTROL_AF_STATE", "#CONTROL_AF_TRIGGER_CANCEL", "android.hardware.camera2.CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER" ]
  }, {
    "name" : "CONTROL_AF_STATE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Current state of auto-focus (AF) algorithm.</p>\n     * <p>Switching between or enabling AF modes ({@link CaptureRequest#CONTROL_AF_MODE android.control.afMode}) always\n     * resets the AF state to INACTIVE. Similarly, switching between {@link CaptureRequest#CONTROL_MODE android.control.mode},\n     * or {@link CaptureRequest#CONTROL_SCENE_MODE android.control.sceneMode} if <code>{@link CaptureRequest#CONTROL_MODE android.control.mode} == USE_SCENE_MODE</code> resets all\n     * the algorithm states to INACTIVE.</p>\n     * <p>The camera device can do several state transitions between two results, if it is\n     * allowed by the state transition table. For example: INACTIVE may never actually be\n     * seen in a result.</p>\n     * <p>The state in the result is the state for this image (in sync with this image): if\n     * AF state becomes FOCUSED, then the image data associated with this result should\n     * be sharp.</p>\n     * <p>Below are state transition tables for different AF modes.</p>\n     * <p>When {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode} is AF_MODE_OFF or AF_MODE_EDOF:</p>\n     * <table>\n     * <thead>\n     * <tr>\n     * <th align=\"center\">State</th>\n     * <th align=\"center\">Transition Cause</th>\n     * <th align=\"center\">New State</th>\n     * <th align=\"center\">Notes</th>\n     * </tr>\n     * </thead>\n     * <tbody>\n     * <tr>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\"></td>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">Never changes</td>\n     * </tr>\n     * </tbody>\n     * </table>\n     * <p>When {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode} is AF_MODE_AUTO or AF_MODE_MACRO:</p>\n     * <table>\n     * <thead>\n     * <tr>\n     * <th align=\"center\">State</th>\n     * <th align=\"center\">Transition Cause</th>\n     * <th align=\"center\">New State</th>\n     * <th align=\"center\">Notes</th>\n     * </tr>\n     * </thead>\n     * <tbody>\n     * <tr>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">AF_TRIGGER</td>\n     * <td align=\"center\">ACTIVE_SCAN</td>\n     * <td align=\"center\">Start AF sweep, Lens now moving</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">ACTIVE_SCAN</td>\n     * <td align=\"center\">AF sweep done</td>\n     * <td align=\"center\">FOCUSED_LOCKED</td>\n     * <td align=\"center\">Focused, Lens now locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">ACTIVE_SCAN</td>\n     * <td align=\"center\">AF sweep done</td>\n     * <td align=\"center\">NOT_FOCUSED_LOCKED</td>\n     * <td align=\"center\">Not focused, Lens now locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">ACTIVE_SCAN</td>\n     * <td align=\"center\">AF_CANCEL</td>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">Cancel/reset AF, Lens now locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">FOCUSED_LOCKED</td>\n     * <td align=\"center\">AF_CANCEL</td>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">Cancel/reset AF</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">FOCUSED_LOCKED</td>\n     * <td align=\"center\">AF_TRIGGER</td>\n     * <td align=\"center\">ACTIVE_SCAN</td>\n     * <td align=\"center\">Start new sweep, Lens now moving</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">NOT_FOCUSED_LOCKED</td>\n     * <td align=\"center\">AF_CANCEL</td>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">Cancel/reset AF</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">NOT_FOCUSED_LOCKED</td>\n     * <td align=\"center\">AF_TRIGGER</td>\n     * <td align=\"center\">ACTIVE_SCAN</td>\n     * <td align=\"center\">Start new sweep, Lens now moving</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">Any state</td>\n     * <td align=\"center\">Mode change</td>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\"></td>\n     * </tr>\n     * </tbody>\n     * </table>\n     * <p>For the above table, the camera device may skip reporting any state changes that happen\n     * without application intervention (i.e. mode switch, trigger, locking). Any state that\n     * can be skipped in that manner is called a transient state.</p>\n     * <p>For example, for these AF modes (AF_MODE_AUTO and AF_MODE_MACRO), in addition to the\n     * state transitions listed in above table, it is also legal for the camera device to skip\n     * one or more transient states between two results. See below table for examples:</p>\n     * <table>\n     * <thead>\n     * <tr>\n     * <th align=\"center\">State</th>\n     * <th align=\"center\">Transition Cause</th>\n     * <th align=\"center\">New State</th>\n     * <th align=\"center\">Notes</th>\n     * </tr>\n     * </thead>\n     * <tbody>\n     * <tr>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">AF_TRIGGER</td>\n     * <td align=\"center\">FOCUSED_LOCKED</td>\n     * <td align=\"center\">Focus is already good or good after a scan, lens is now locked.</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">AF_TRIGGER</td>\n     * <td align=\"center\">NOT_FOCUSED_LOCKED</td>\n     * <td align=\"center\">Focus failed after a scan, lens is now locked.</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">FOCUSED_LOCKED</td>\n     * <td align=\"center\">AF_TRIGGER</td>\n     * <td align=\"center\">FOCUSED_LOCKED</td>\n     * <td align=\"center\">Focus is already good or good after a scan, lens is now locked.</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">NOT_FOCUSED_LOCKED</td>\n     * <td align=\"center\">AF_TRIGGER</td>\n     * <td align=\"center\">FOCUSED_LOCKED</td>\n     * <td align=\"center\">Focus is good after a scan, lens is not locked.</td>\n     * </tr>\n     * </tbody>\n     * </table>\n     * <p>When {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode} is AF_MODE_CONTINUOUS_VIDEO:</p>\n     * <table>\n     * <thead>\n     * <tr>\n     * <th align=\"center\">State</th>\n     * <th align=\"center\">Transition Cause</th>\n     * <th align=\"center\">New State</th>\n     * <th align=\"center\">Notes</th>\n     * </tr>\n     * </thead>\n     * <tbody>\n     * <tr>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">Camera device initiates new scan</td>\n     * <td align=\"center\">PASSIVE_SCAN</td>\n     * <td align=\"center\">Start AF scan, Lens now moving</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">AF_TRIGGER</td>\n     * <td align=\"center\">NOT_FOCUSED_LOCKED</td>\n     * <td align=\"center\">AF state query, Lens now locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">PASSIVE_SCAN</td>\n     * <td align=\"center\">Camera device completes current scan</td>\n     * <td align=\"center\">PASSIVE_FOCUSED</td>\n     * <td align=\"center\">End AF scan, Lens now locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">PASSIVE_SCAN</td>\n     * <td align=\"center\">Camera device fails current scan</td>\n     * <td align=\"center\">PASSIVE_UNFOCUSED</td>\n     * <td align=\"center\">End AF scan, Lens now locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">PASSIVE_SCAN</td>\n     * <td align=\"center\">AF_TRIGGER</td>\n     * <td align=\"center\">FOCUSED_LOCKED</td>\n     * <td align=\"center\">Immediate transition, if focus is good. Lens now locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">PASSIVE_SCAN</td>\n     * <td align=\"center\">AF_TRIGGER</td>\n     * <td align=\"center\">NOT_FOCUSED_LOCKED</td>\n     * <td align=\"center\">Immediate transition, if focus is bad. Lens now locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">PASSIVE_SCAN</td>\n     * <td align=\"center\">AF_CANCEL</td>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">Reset lens position, Lens now locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">PASSIVE_FOCUSED</td>\n     * <td align=\"center\">Camera device initiates new scan</td>\n     * <td align=\"center\">PASSIVE_SCAN</td>\n     * <td align=\"center\">Start AF scan, Lens now moving</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">PASSIVE_UNFOCUSED</td>\n     * <td align=\"center\">Camera device initiates new scan</td>\n     * <td align=\"center\">PASSIVE_SCAN</td>\n     * <td align=\"center\">Start AF scan, Lens now moving</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">PASSIVE_FOCUSED</td>\n     * <td align=\"center\">AF_TRIGGER</td>\n     * <td align=\"center\">FOCUSED_LOCKED</td>\n     * <td align=\"center\">Immediate transition, lens now locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">PASSIVE_UNFOCUSED</td>\n     * <td align=\"center\">AF_TRIGGER</td>\n     * <td align=\"center\">NOT_FOCUSED_LOCKED</td>\n     * <td align=\"center\">Immediate transition, lens now locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">FOCUSED_LOCKED</td>\n     * <td align=\"center\">AF_TRIGGER</td>\n     * <td align=\"center\">FOCUSED_LOCKED</td>\n     * <td align=\"center\">No effect</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">FOCUSED_LOCKED</td>\n     * <td align=\"center\">AF_CANCEL</td>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">Restart AF scan</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">NOT_FOCUSED_LOCKED</td>\n     * <td align=\"center\">AF_TRIGGER</td>\n     * <td align=\"center\">NOT_FOCUSED_LOCKED</td>\n     * <td align=\"center\">No effect</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">NOT_FOCUSED_LOCKED</td>\n     * <td align=\"center\">AF_CANCEL</td>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">Restart AF scan</td>\n     * </tr>\n     * </tbody>\n     * </table>\n     * <p>When {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode} is AF_MODE_CONTINUOUS_PICTURE:</p>\n     * <table>\n     * <thead>\n     * <tr>\n     * <th align=\"center\">State</th>\n     * <th align=\"center\">Transition Cause</th>\n     * <th align=\"center\">New State</th>\n     * <th align=\"center\">Notes</th>\n     * </tr>\n     * </thead>\n     * <tbody>\n     * <tr>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">Camera device initiates new scan</td>\n     * <td align=\"center\">PASSIVE_SCAN</td>\n     * <td align=\"center\">Start AF scan, Lens now moving</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">AF_TRIGGER</td>\n     * <td align=\"center\">NOT_FOCUSED_LOCKED</td>\n     * <td align=\"center\">AF state query, Lens now locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">PASSIVE_SCAN</td>\n     * <td align=\"center\">Camera device completes current scan</td>\n     * <td align=\"center\">PASSIVE_FOCUSED</td>\n     * <td align=\"center\">End AF scan, Lens now locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">PASSIVE_SCAN</td>\n     * <td align=\"center\">Camera device fails current scan</td>\n     * <td align=\"center\">PASSIVE_UNFOCUSED</td>\n     * <td align=\"center\">End AF scan, Lens now locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">PASSIVE_SCAN</td>\n     * <td align=\"center\">AF_TRIGGER</td>\n     * <td align=\"center\">FOCUSED_LOCKED</td>\n     * <td align=\"center\">Eventual transition once the focus is good. Lens now locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">PASSIVE_SCAN</td>\n     * <td align=\"center\">AF_TRIGGER</td>\n     * <td align=\"center\">NOT_FOCUSED_LOCKED</td>\n     * <td align=\"center\">Eventual transition if cannot find focus. Lens now locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">PASSIVE_SCAN</td>\n     * <td align=\"center\">AF_CANCEL</td>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">Reset lens position, Lens now locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">PASSIVE_FOCUSED</td>\n     * <td align=\"center\">Camera device initiates new scan</td>\n     * <td align=\"center\">PASSIVE_SCAN</td>\n     * <td align=\"center\">Start AF scan, Lens now moving</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">PASSIVE_UNFOCUSED</td>\n     * <td align=\"center\">Camera device initiates new scan</td>\n     * <td align=\"center\">PASSIVE_SCAN</td>\n     * <td align=\"center\">Start AF scan, Lens now moving</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">PASSIVE_FOCUSED</td>\n     * <td align=\"center\">AF_TRIGGER</td>\n     * <td align=\"center\">FOCUSED_LOCKED</td>\n     * <td align=\"center\">Immediate trans. Lens now locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">PASSIVE_UNFOCUSED</td>\n     * <td align=\"center\">AF_TRIGGER</td>\n     * <td align=\"center\">NOT_FOCUSED_LOCKED</td>\n     * <td align=\"center\">Immediate trans. Lens now locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">FOCUSED_LOCKED</td>\n     * <td align=\"center\">AF_TRIGGER</td>\n     * <td align=\"center\">FOCUSED_LOCKED</td>\n     * <td align=\"center\">No effect</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">FOCUSED_LOCKED</td>\n     * <td align=\"center\">AF_CANCEL</td>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">Restart AF scan</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">NOT_FOCUSED_LOCKED</td>\n     * <td align=\"center\">AF_TRIGGER</td>\n     * <td align=\"center\">NOT_FOCUSED_LOCKED</td>\n     * <td align=\"center\">No effect</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">NOT_FOCUSED_LOCKED</td>\n     * <td align=\"center\">AF_CANCEL</td>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">Restart AF scan</td>\n     * </tr>\n     * </tbody>\n     * </table>\n     * <p>When switch between AF_MODE_CONTINUOUS_* (CAF modes) and AF_MODE_AUTO/AF_MODE_MACRO\n     * (AUTO modes), the initial INACTIVE or PASSIVE_SCAN states may be skipped by the\n     * camera device. When a trigger is included in a mode switch request, the trigger\n     * will be evaluated in the context of the new mode in the request.\n     * See below table for examples:</p>\n     * <table>\n     * <thead>\n     * <tr>\n     * <th align=\"center\">State</th>\n     * <th align=\"center\">Transition Cause</th>\n     * <th align=\"center\">New State</th>\n     * <th align=\"center\">Notes</th>\n     * </tr>\n     * </thead>\n     * <tbody>\n     * <tr>\n     * <td align=\"center\">any state</td>\n     * <td align=\"center\">CAF--&gt;AUTO mode switch</td>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">Mode switch without trigger, initial state must be INACTIVE</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">any state</td>\n     * <td align=\"center\">CAF--&gt;AUTO mode switch with AF_TRIGGER</td>\n     * <td align=\"center\">trigger-reachable states from INACTIVE</td>\n     * <td align=\"center\">Mode switch with trigger, INACTIVE is skipped</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">any state</td>\n     * <td align=\"center\">AUTO--&gt;CAF mode switch</td>\n     * <td align=\"center\">passively reachable states from INACTIVE</td>\n     * <td align=\"center\">Mode switch without trigger, passive transient state is skipped</td>\n     * </tr>\n     * </tbody>\n     * </table>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_AF_STATE_INACTIVE INACTIVE}</li>\n     *   <li>{@link #CONTROL_AF_STATE_PASSIVE_SCAN PASSIVE_SCAN}</li>\n     *   <li>{@link #CONTROL_AF_STATE_PASSIVE_FOCUSED PASSIVE_FOCUSED}</li>\n     *   <li>{@link #CONTROL_AF_STATE_ACTIVE_SCAN ACTIVE_SCAN}</li>\n     *   <li>{@link #CONTROL_AF_STATE_FOCUSED_LOCKED FOCUSED_LOCKED}</li>\n     *   <li>{@link #CONTROL_AF_STATE_NOT_FOCUSED_LOCKED NOT_FOCUSED_LOCKED}</li>\n     *   <li>{@link #CONTROL_AF_STATE_PASSIVE_UNFOCUSED PASSIVE_UNFOCUSED}</li>\n     * </ul></p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_AF_MODE\n     * @see CaptureRequest#CONTROL_MODE\n     * @see CaptureRequest#CONTROL_SCENE_MODE\n     * @see #CONTROL_AF_STATE_INACTIVE\n     * @see #CONTROL_AF_STATE_PASSIVE_SCAN\n     * @see #CONTROL_AF_STATE_PASSIVE_FOCUSED\n     * @see #CONTROL_AF_STATE_ACTIVE_SCAN\n     * @see #CONTROL_AF_STATE_FOCUSED_LOCKED\n     * @see #CONTROL_AF_STATE_NOT_FOCUSED_LOCKED\n     * @see #CONTROL_AF_STATE_PASSIVE_UNFOCUSED\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#CONTROL_MODE", "#CONTROL_AF_STATE_ACTIVE_SCAN", "android.hardware.camera2.CaptureRequest#CONTROL_AF_MODE", "#CONTROL_AF_STATE_PASSIVE_FOCUSED", "#CONTROL_AF_STATE_NOT_FOCUSED_LOCKED", "#CONTROL_AF_STATE_INACTIVE", "#CONTROL_AF_STATE_PASSIVE_UNFOCUSED", "#CONTROL_AF_STATE_PASSIVE_SCAN", "#CONTROL_AF_STATE_FOCUSED_LOCKED", "android.hardware.camera2.CaptureRequest#CONTROL_SCENE_MODE" ]
  }, {
    "name" : "CONTROL_AWB_LOCK",
    "type" : "Key<Boolean>",
    "comment" : "\n     * <p>Whether auto-white balance (AWB) is currently locked to its\n     * latest calculated values.</p>\n     * <p>When set to <code>true</code> (ON), the AWB algorithm is locked to its latest parameters,\n     * and will not change color balance settings until the lock is set to <code>false</code> (OFF).</p>\n     * <p>Since the camera device has a pipeline of in-flight requests, the settings that\n     * get locked do not necessarily correspond to the settings that were present in the\n     * latest capture result received from the camera device, since additional captures\n     * and AWB updates may have occurred even before the result was sent out. If an\n     * application is switching between automatic and manual control and wishes to eliminate\n     * any flicker during the switch, the following procedure is recommended:</p>\n     * <ol>\n     * <li>Starting in auto-AWB mode:</li>\n     * <li>Lock AWB</li>\n     * <li>Wait for the first result to be output that has the AWB locked</li>\n     * <li>Copy AWB settings from that result into a request, set the request to manual AWB</li>\n     * <li>Submit the capture request, proceed to run manual AWB as desired.</li>\n     * </ol>\n     * <p>Note that AWB lock is only meaningful when\n     * {@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode} is in the AUTO mode; in other modes,\n     * AWB is already fixed to a specific setting.</p>\n     * <p>Some LEGACY devices may not support ON; the value is then overridden to OFF.</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_AWB_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#CONTROL_AWB_MODE" ]
  }, {
    "name" : "CONTROL_AWB_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Whether auto-white balance (AWB) is currently setting the color\n     * transform fields, and what its illumination target\n     * is.</p>\n     * <p>This control is only effective if {@link CaptureRequest#CONTROL_MODE android.control.mode} is AUTO.</p>\n     * <p>When set to the ON mode, the camera device's auto-white balance\n     * routine is enabled, overriding the application's selected\n     * {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}, {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} and\n     * {@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode}. Note that when {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode}\n     * is OFF, the behavior of AWB is device dependent. It is recommened to\n     * also set AWB mode to OFF or lock AWB by using {@link CaptureRequest#CONTROL_AWB_LOCK android.control.awbLock} before\n     * setting AE mode to OFF.</p>\n     * <p>When set to the OFF mode, the camera device's auto-white balance\n     * routine is disabled. The application manually controls the white\n     * balance by {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform}, {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains}\n     * and {@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode}.</p>\n     * <p>When set to any other modes, the camera device's auto-white\n     * balance routine is disabled. The camera device uses each\n     * particular illumination target for white balance\n     * adjustment. The application's values for\n     * {@link CaptureRequest#COLOR_CORRECTION_TRANSFORM android.colorCorrection.transform},\n     * {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} and\n     * {@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode} are ignored.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_AWB_MODE_OFF OFF}</li>\n     *   <li>{@link #CONTROL_AWB_MODE_AUTO AUTO}</li>\n     *   <li>{@link #CONTROL_AWB_MODE_INCANDESCENT INCANDESCENT}</li>\n     *   <li>{@link #CONTROL_AWB_MODE_FLUORESCENT FLUORESCENT}</li>\n     *   <li>{@link #CONTROL_AWB_MODE_WARM_FLUORESCENT WARM_FLUORESCENT}</li>\n     *   <li>{@link #CONTROL_AWB_MODE_DAYLIGHT DAYLIGHT}</li>\n     *   <li>{@link #CONTROL_AWB_MODE_CLOUDY_DAYLIGHT CLOUDY_DAYLIGHT}</li>\n     *   <li>{@link #CONTROL_AWB_MODE_TWILIGHT TWILIGHT}</li>\n     *   <li>{@link #CONTROL_AWB_MODE_SHADE SHADE}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#CONTROL_AWB_AVAILABLE_MODES android.control.awbAvailableModes}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#COLOR_CORRECTION_GAINS\n     * @see CaptureRequest#COLOR_CORRECTION_MODE\n     * @see CaptureRequest#COLOR_CORRECTION_TRANSFORM\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CameraCharacteristics#CONTROL_AWB_AVAILABLE_MODES\n     * @see CaptureRequest#CONTROL_AWB_LOCK\n     * @see CaptureRequest#CONTROL_MODE\n     * @see #CONTROL_AWB_MODE_OFF\n     * @see #CONTROL_AWB_MODE_AUTO\n     * @see #CONTROL_AWB_MODE_INCANDESCENT\n     * @see #CONTROL_AWB_MODE_FLUORESCENT\n     * @see #CONTROL_AWB_MODE_WARM_FLUORESCENT\n     * @see #CONTROL_AWB_MODE_DAYLIGHT\n     * @see #CONTROL_AWB_MODE_CLOUDY_DAYLIGHT\n     * @see #CONTROL_AWB_MODE_TWILIGHT\n     * @see #CONTROL_AWB_MODE_SHADE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_MODE", "#CONTROL_AWB_MODE_AUTO", "android.hardware.camera2.CaptureRequest#CONTROL_AWB_LOCK", "#CONTROL_AWB_MODE_TWILIGHT", "#CONTROL_AWB_MODE_WARM_FLUORESCENT", "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_TRANSFORM", "#CONTROL_AWB_MODE_DAYLIGHT", "#CONTROL_AWB_MODE_FLUORESCENT", "#CONTROL_AWB_MODE_SHADE", "android.hardware.camera2.CaptureRequest#CONTROL_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_AE_MODE", "#CONTROL_AWB_MODE_OFF", "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_GAINS", "#CONTROL_AWB_MODE_INCANDESCENT", "#CONTROL_AWB_MODE_CLOUDY_DAYLIGHT", "android.hardware.camera2.CameraCharacteristics#CONTROL_AWB_AVAILABLE_MODES" ]
  }, {
    "name" : "CONTROL_AWB_REGIONS",
    "type" : "Key<android.hardware.camera2.params.MeteringRectangle[]>",
    "comment" : "\n     * <p>List of metering areas to use for auto-white-balance illuminant\n     * estimation.</p>\n     * <p>Not available if {@link CameraCharacteristics#CONTROL_MAX_REGIONS_AWB android.control.maxRegionsAwb} is 0.\n     * Otherwise will always be present.</p>\n     * <p>The maximum number of regions supported by the device is determined by the value\n     * of {@link CameraCharacteristics#CONTROL_MAX_REGIONS_AWB android.control.maxRegionsAwb}.</p>\n     * <p>For devices not supporting {@link CaptureRequest#DISTORTION_CORRECTION_MODE android.distortionCorrection.mode} control, the coordinate\n     * system always follows that of {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, with (0,0) being\n     * the top-left pixel in the active pixel array, and\n     * ({@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.width - 1,\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.height - 1) being the bottom-right pixel in the\n     * active pixel array.</p>\n     * <p>For devices supporting {@link CaptureRequest#DISTORTION_CORRECTION_MODE android.distortionCorrection.mode} control, the coordinate\n     * system depends on the mode being set.\n     * When the distortion correction mode is OFF, the coordinate system follows\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}, with\n     * <code>(0, 0)</code> being the top-left pixel of the pre-correction active array, and\n     * ({@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}.width - 1,\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}.height - 1) being the bottom-right\n     * pixel in the pre-correction active pixel array.\n     * When the distortion correction mode is not OFF, the coordinate system follows\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, with\n     * <code>(0, 0)</code> being the top-left pixel of the active array, and\n     * ({@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.width - 1,\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.height - 1) being the bottom-right pixel in the\n     * active pixel array.</p>\n     * <p>The weight must range from 0 to 1000, and represents a weight\n     * for every pixel in the area. This means that a large metering area\n     * with the same weight as a smaller area will have more effect in\n     * the metering result. Metering areas can partially overlap and the\n     * camera device will add the weights in the overlap region.</p>\n     * <p>The weights are relative to weights of other white balance metering regions, so if\n     * only one region is used, all non-zero weights will have the same effect. A region with\n     * 0 weight is ignored.</p>\n     * <p>If all regions have 0 weight, then no specific metering area needs to be used by the\n     * camera device.</p>\n     * <p>If the metering region is outside the used {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} returned in\n     * capture result metadata, the camera device will ignore the sections outside the crop\n     * region and output only the intersection rectangle as the metering region in the result\n     * metadata.  If the region is entirely outside the crop region, it will be ignored and\n     * not reported in the result metadata.</p>\n     * <p>Starting from API level 30, the coordinate system of activeArraySize or\n     * preCorrectionActiveArraySize is used to represent post-zoomRatio field of view, not\n     * pre-zoom field of view. This means that the same awbRegions values at different\n     * {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} represent different parts of the scene. The awbRegions\n     * coordinates are relative to the activeArray/preCorrectionActiveArray representing the\n     * zoomed field of view. If {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} is set to 1.0 (default), the same\n     * awbRegions at different {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} still represent the same parts of\n     * the scene as they do before. See {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} for details. Whether to use\n     * activeArraySize or preCorrectionActiveArraySize still depends on distortion correction\n     * mode.</p>\n     * <p><b>Units</b>: Pixel coordinates within {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize} or\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize} depending on\n     * distortion correction capability and mode</p>\n     * <p><b>Range of valid values:</b><br>\n     * Coordinates must be between <code>[(0,0), (width, height))</code> of\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize} or {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}\n     * depending on distortion correction capability and mode</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CameraCharacteristics#CONTROL_MAX_REGIONS_AWB\n     * @see CaptureRequest#CONTROL_ZOOM_RATIO\n     * @see CaptureRequest#DISTORTION_CORRECTION_MODE\n     * @see CaptureRequest#SCALER_CROP_REGION\n     * @see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE\n     * @see CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#DISTORTION_CORRECTION_MODE", "android.hardware.camera2.CaptureRequest#SCALER_CROP_REGION", "android.hardware.camera2.CameraCharacteristics#CONTROL_MAX_REGIONS_AWB", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE", "android.hardware.camera2.CaptureRequest#CONTROL_ZOOM_RATIO" ]
  }, {
    "name" : "CONTROL_CAPTURE_INTENT",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Information to the camera device 3A (auto-exposure,\n     * auto-focus, auto-white balance) routines about the purpose\n     * of this capture, to help the camera device to decide optimal 3A\n     * strategy.</p>\n     * <p>This control (except for MANUAL) is only effective if\n     * <code>{@link CaptureRequest#CONTROL_MODE android.control.mode} != OFF</code> and any 3A routine is active.</p>\n     * <p>All intents are supported by all devices, except that:\n     *   * ZERO_SHUTTER_LAG will be supported if {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} contains\n     * PRIVATE_REPROCESSING or YUV_REPROCESSING.\n     *   * MANUAL will be supported if {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} contains\n     * MANUAL_SENSOR.\n     *   * MOTION_TRACKING will be supported if {@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} contains\n     * MOTION_TRACKING.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_CAPTURE_INTENT_CUSTOM CUSTOM}</li>\n     *   <li>{@link #CONTROL_CAPTURE_INTENT_PREVIEW PREVIEW}</li>\n     *   <li>{@link #CONTROL_CAPTURE_INTENT_STILL_CAPTURE STILL_CAPTURE}</li>\n     *   <li>{@link #CONTROL_CAPTURE_INTENT_VIDEO_RECORD VIDEO_RECORD}</li>\n     *   <li>{@link #CONTROL_CAPTURE_INTENT_VIDEO_SNAPSHOT VIDEO_SNAPSHOT}</li>\n     *   <li>{@link #CONTROL_CAPTURE_INTENT_ZERO_SHUTTER_LAG ZERO_SHUTTER_LAG}</li>\n     *   <li>{@link #CONTROL_CAPTURE_INTENT_MANUAL MANUAL}</li>\n     *   <li>{@link #CONTROL_CAPTURE_INTENT_MOTION_TRACKING MOTION_TRACKING}</li>\n     * </ul></p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_MODE\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     * @see #CONTROL_CAPTURE_INTENT_CUSTOM\n     * @see #CONTROL_CAPTURE_INTENT_PREVIEW\n     * @see #CONTROL_CAPTURE_INTENT_STILL_CAPTURE\n     * @see #CONTROL_CAPTURE_INTENT_VIDEO_RECORD\n     * @see #CONTROL_CAPTURE_INTENT_VIDEO_SNAPSHOT\n     * @see #CONTROL_CAPTURE_INTENT_ZERO_SHUTTER_LAG\n     * @see #CONTROL_CAPTURE_INTENT_MANUAL\n     * @see #CONTROL_CAPTURE_INTENT_MOTION_TRACKING\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES", "#CONTROL_CAPTURE_INTENT_VIDEO_RECORD", "#CONTROL_CAPTURE_INTENT_PREVIEW", "android.hardware.camera2.CaptureRequest#CONTROL_MODE", "#CONTROL_CAPTURE_INTENT_STILL_CAPTURE", "#CONTROL_CAPTURE_INTENT_VIDEO_SNAPSHOT", "#CONTROL_CAPTURE_INTENT_CUSTOM", "#CONTROL_CAPTURE_INTENT_MANUAL", "#CONTROL_CAPTURE_INTENT_MOTION_TRACKING", "#CONTROL_CAPTURE_INTENT_ZERO_SHUTTER_LAG" ]
  }, {
    "name" : "CONTROL_AWB_STATE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Current state of auto-white balance (AWB) algorithm.</p>\n     * <p>Switching between or enabling AWB modes ({@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode}) always\n     * resets the AWB state to INACTIVE. Similarly, switching between {@link CaptureRequest#CONTROL_MODE android.control.mode},\n     * or {@link CaptureRequest#CONTROL_SCENE_MODE android.control.sceneMode} if <code>{@link CaptureRequest#CONTROL_MODE android.control.mode} == USE_SCENE_MODE</code> resets all\n     * the algorithm states to INACTIVE.</p>\n     * <p>The camera device can do several state transitions between two results, if it is\n     * allowed by the state transition table. So INACTIVE may never actually be seen in\n     * a result.</p>\n     * <p>The state in the result is the state for this image (in sync with this image): if\n     * AWB state becomes CONVERGED, then the image data associated with this result should\n     * be good to use.</p>\n     * <p>Below are state transition tables for different AWB modes.</p>\n     * <p>When <code>{@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode} != AWB_MODE_AUTO</code>:</p>\n     * <table>\n     * <thead>\n     * <tr>\n     * <th align=\"center\">State</th>\n     * <th align=\"center\">Transition Cause</th>\n     * <th align=\"center\">New State</th>\n     * <th align=\"center\">Notes</th>\n     * </tr>\n     * </thead>\n     * <tbody>\n     * <tr>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\"></td>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">Camera device auto white balance algorithm is disabled</td>\n     * </tr>\n     * </tbody>\n     * </table>\n     * <p>When {@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode} is AWB_MODE_AUTO:</p>\n     * <table>\n     * <thead>\n     * <tr>\n     * <th align=\"center\">State</th>\n     * <th align=\"center\">Transition Cause</th>\n     * <th align=\"center\">New State</th>\n     * <th align=\"center\">Notes</th>\n     * </tr>\n     * </thead>\n     * <tbody>\n     * <tr>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">Camera device initiates AWB scan</td>\n     * <td align=\"center\">SEARCHING</td>\n     * <td align=\"center\">Values changing</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">{@link CaptureRequest#CONTROL_AWB_LOCK android.control.awbLock} is ON</td>\n     * <td align=\"center\">LOCKED</td>\n     * <td align=\"center\">Values locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">SEARCHING</td>\n     * <td align=\"center\">Camera device finishes AWB scan</td>\n     * <td align=\"center\">CONVERGED</td>\n     * <td align=\"center\">Good values, not changing</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">SEARCHING</td>\n     * <td align=\"center\">{@link CaptureRequest#CONTROL_AWB_LOCK android.control.awbLock} is ON</td>\n     * <td align=\"center\">LOCKED</td>\n     * <td align=\"center\">Values locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">CONVERGED</td>\n     * <td align=\"center\">Camera device initiates AWB scan</td>\n     * <td align=\"center\">SEARCHING</td>\n     * <td align=\"center\">Values changing</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">CONVERGED</td>\n     * <td align=\"center\">{@link CaptureRequest#CONTROL_AWB_LOCK android.control.awbLock} is ON</td>\n     * <td align=\"center\">LOCKED</td>\n     * <td align=\"center\">Values locked</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">LOCKED</td>\n     * <td align=\"center\">{@link CaptureRequest#CONTROL_AWB_LOCK android.control.awbLock} is OFF</td>\n     * <td align=\"center\">SEARCHING</td>\n     * <td align=\"center\">Values not good after unlock</td>\n     * </tr>\n     * </tbody>\n     * </table>\n     * <p>For the above table, the camera device may skip reporting any state changes that happen\n     * without application intervention (i.e. mode switch, trigger, locking). Any state that\n     * can be skipped in that manner is called a transient state.</p>\n     * <p>For example, for this AWB mode (AWB_MODE_AUTO), in addition to the state transitions\n     * listed in above table, it is also legal for the camera device to skip one or more\n     * transient states between two results. See below table for examples:</p>\n     * <table>\n     * <thead>\n     * <tr>\n     * <th align=\"center\">State</th>\n     * <th align=\"center\">Transition Cause</th>\n     * <th align=\"center\">New State</th>\n     * <th align=\"center\">Notes</th>\n     * </tr>\n     * </thead>\n     * <tbody>\n     * <tr>\n     * <td align=\"center\">INACTIVE</td>\n     * <td align=\"center\">Camera device finished AWB scan</td>\n     * <td align=\"center\">CONVERGED</td>\n     * <td align=\"center\">Values are already good, transient states are skipped by camera device.</td>\n     * </tr>\n     * <tr>\n     * <td align=\"center\">LOCKED</td>\n     * <td align=\"center\">{@link CaptureRequest#CONTROL_AWB_LOCK android.control.awbLock} is OFF</td>\n     * <td align=\"center\">CONVERGED</td>\n     * <td align=\"center\">Values good after unlock, transient states are skipped by camera device.</td>\n     * </tr>\n     * </tbody>\n     * </table>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_AWB_STATE_INACTIVE INACTIVE}</li>\n     *   <li>{@link #CONTROL_AWB_STATE_SEARCHING SEARCHING}</li>\n     *   <li>{@link #CONTROL_AWB_STATE_CONVERGED CONVERGED}</li>\n     *   <li>{@link #CONTROL_AWB_STATE_LOCKED LOCKED}</li>\n     * </ul></p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Limited capability</b> -\n     * Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#CONTROL_AWB_LOCK\n     * @see CaptureRequest#CONTROL_AWB_MODE\n     * @see CaptureRequest#CONTROL_MODE\n     * @see CaptureRequest#CONTROL_SCENE_MODE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see #CONTROL_AWB_STATE_INACTIVE\n     * @see #CONTROL_AWB_STATE_SEARCHING\n     * @see #CONTROL_AWB_STATE_CONVERGED\n     * @see #CONTROL_AWB_STATE_LOCKED\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CaptureRequest#CONTROL_MODE", "#CONTROL_AWB_STATE_LOCKED", "#CONTROL_AWB_STATE_INACTIVE", "android.hardware.camera2.CaptureRequest#CONTROL_AWB_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_AWB_LOCK", "#CONTROL_AWB_STATE_CONVERGED", "android.hardware.camera2.CaptureRequest#CONTROL_SCENE_MODE", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED", "#CONTROL_AWB_STATE_SEARCHING" ]
  }, {
    "name" : "CONTROL_EFFECT_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>A special color effect to apply.</p>\n     * <p>When this mode is set, a color effect will be applied\n     * to images produced by the camera device. The interpretation\n     * and implementation of these color effects is left to the\n     * implementor of the camera device, and should not be\n     * depended on to be consistent (or present) across all\n     * devices.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_EFFECT_MODE_OFF OFF}</li>\n     *   <li>{@link #CONTROL_EFFECT_MODE_MONO MONO}</li>\n     *   <li>{@link #CONTROL_EFFECT_MODE_NEGATIVE NEGATIVE}</li>\n     *   <li>{@link #CONTROL_EFFECT_MODE_SOLARIZE SOLARIZE}</li>\n     *   <li>{@link #CONTROL_EFFECT_MODE_SEPIA SEPIA}</li>\n     *   <li>{@link #CONTROL_EFFECT_MODE_POSTERIZE POSTERIZE}</li>\n     *   <li>{@link #CONTROL_EFFECT_MODE_WHITEBOARD WHITEBOARD}</li>\n     *   <li>{@link #CONTROL_EFFECT_MODE_BLACKBOARD BLACKBOARD}</li>\n     *   <li>{@link #CONTROL_EFFECT_MODE_AQUA AQUA}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#CONTROL_AVAILABLE_EFFECTS android.control.availableEffects}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CameraCharacteristics#CONTROL_AVAILABLE_EFFECTS\n     * @see #CONTROL_EFFECT_MODE_OFF\n     * @see #CONTROL_EFFECT_MODE_MONO\n     * @see #CONTROL_EFFECT_MODE_NEGATIVE\n     * @see #CONTROL_EFFECT_MODE_SOLARIZE\n     * @see #CONTROL_EFFECT_MODE_SEPIA\n     * @see #CONTROL_EFFECT_MODE_POSTERIZE\n     * @see #CONTROL_EFFECT_MODE_WHITEBOARD\n     * @see #CONTROL_EFFECT_MODE_BLACKBOARD\n     * @see #CONTROL_EFFECT_MODE_AQUA\n     ",
    "links" : [ "#CONTROL_EFFECT_MODE_SEPIA", "#CONTROL_EFFECT_MODE_BLACKBOARD", "#CONTROL_EFFECT_MODE_NEGATIVE", "android.hardware.camera2.CameraCharacteristics#CONTROL_AVAILABLE_EFFECTS", "#CONTROL_EFFECT_MODE_WHITEBOARD", "#CONTROL_EFFECT_MODE_AQUA", "#CONTROL_EFFECT_MODE_POSTERIZE", "#CONTROL_EFFECT_MODE_MONO", "#CONTROL_EFFECT_MODE_SOLARIZE", "#CONTROL_EFFECT_MODE_OFF" ]
  }, {
    "name" : "CONTROL_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Overall mode of 3A (auto-exposure, auto-white-balance, auto-focus) control\n     * routines.</p>\n     * <p>This is a top-level 3A control switch. When set to OFF, all 3A control\n     * by the camera device is disabled. The application must set the fields for\n     * capture parameters itself.</p>\n     * <p>When set to AUTO, the individual algorithm controls in\n     * android.control.* are in effect, such as {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode}.</p>\n     * <p>When set to USE_SCENE_MODE or USE_EXTENDED_SCENE_MODE, the individual controls in\n     * android.control.* are mostly disabled, and the camera device\n     * implements one of the scene mode or extended scene mode settings (such as ACTION,\n     * SUNSET, PARTY, or BOKEH) as it wishes. The camera device scene mode\n     * 3A settings are provided by {@link android.hardware.camera2.CaptureResult capture results}.</p>\n     * <p>When set to OFF_KEEP_STATE, it is similar to OFF mode, the only difference\n     * is that this frame will not be used by camera device background 3A statistics\n     * update, as if this frame is never captured. This mode can be used in the scenario\n     * where the application doesn't want a 3A manual control capture to affect\n     * the subsequent auto 3A capture results.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_MODE_OFF OFF}</li>\n     *   <li>{@link #CONTROL_MODE_AUTO AUTO}</li>\n     *   <li>{@link #CONTROL_MODE_USE_SCENE_MODE USE_SCENE_MODE}</li>\n     *   <li>{@link #CONTROL_MODE_OFF_KEEP_STATE OFF_KEEP_STATE}</li>\n     *   <li>{@link #CONTROL_MODE_USE_EXTENDED_SCENE_MODE USE_EXTENDED_SCENE_MODE}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#CONTROL_AVAILABLE_MODES android.control.availableModes}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_AF_MODE\n     * @see CameraCharacteristics#CONTROL_AVAILABLE_MODES\n     * @see #CONTROL_MODE_OFF\n     * @see #CONTROL_MODE_AUTO\n     * @see #CONTROL_MODE_USE_SCENE_MODE\n     * @see #CONTROL_MODE_OFF_KEEP_STATE\n     * @see #CONTROL_MODE_USE_EXTENDED_SCENE_MODE\n     ",
    "links" : [ "#CONTROL_MODE_USE_EXTENDED_SCENE_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_AF_MODE", "android.hardware.camera2.CaptureResult", "#CONTROL_MODE_OFF_KEEP_STATE", "#CONTROL_MODE_USE_SCENE_MODE", "#CONTROL_MODE_OFF", "#CONTROL_MODE_AUTO", "android.hardware.camera2.CameraCharacteristics#CONTROL_AVAILABLE_MODES" ]
  }, {
    "name" : "CONTROL_SCENE_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Control for which scene mode is currently active.</p>\n     * <p>Scene modes are custom camera modes optimized for a certain set of conditions and\n     * capture settings.</p>\n     * <p>This is the mode that that is active when\n     * <code>{@link CaptureRequest#CONTROL_MODE android.control.mode} == USE_SCENE_MODE</code>. Aside from FACE_PRIORITY, these modes will\n     * disable {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode}, {@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode}, and {@link CaptureRequest#CONTROL_AF_MODE android.control.afMode}\n     * while in use.</p>\n     * <p>The interpretation and implementation of these scene modes is left\n     * to the implementor of the camera device. Their behavior will not be\n     * consistent across all devices, and any given device may only implement\n     * a subset of these modes.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_SCENE_MODE_DISABLED DISABLED}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_FACE_PRIORITY FACE_PRIORITY}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_ACTION ACTION}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_PORTRAIT PORTRAIT}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_LANDSCAPE LANDSCAPE}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_NIGHT NIGHT}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_NIGHT_PORTRAIT NIGHT_PORTRAIT}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_THEATRE THEATRE}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_BEACH BEACH}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_SNOW SNOW}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_SUNSET SUNSET}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_STEADYPHOTO STEADYPHOTO}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_FIREWORKS FIREWORKS}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_SPORTS SPORTS}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_PARTY PARTY}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_CANDLELIGHT CANDLELIGHT}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_BARCODE BARCODE}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_HIGH_SPEED_VIDEO HIGH_SPEED_VIDEO}</li>\n     *   <li>{@link #CONTROL_SCENE_MODE_HDR HDR}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#CONTROL_AVAILABLE_SCENE_MODES android.control.availableSceneModes}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CaptureRequest#CONTROL_AF_MODE\n     * @see CameraCharacteristics#CONTROL_AVAILABLE_SCENE_MODES\n     * @see CaptureRequest#CONTROL_AWB_MODE\n     * @see CaptureRequest#CONTROL_MODE\n     * @see #CONTROL_SCENE_MODE_DISABLED\n     * @see #CONTROL_SCENE_MODE_FACE_PRIORITY\n     * @see #CONTROL_SCENE_MODE_ACTION\n     * @see #CONTROL_SCENE_MODE_PORTRAIT\n     * @see #CONTROL_SCENE_MODE_LANDSCAPE\n     * @see #CONTROL_SCENE_MODE_NIGHT\n     * @see #CONTROL_SCENE_MODE_NIGHT_PORTRAIT\n     * @see #CONTROL_SCENE_MODE_THEATRE\n     * @see #CONTROL_SCENE_MODE_BEACH\n     * @see #CONTROL_SCENE_MODE_SNOW\n     * @see #CONTROL_SCENE_MODE_SUNSET\n     * @see #CONTROL_SCENE_MODE_STEADYPHOTO\n     * @see #CONTROL_SCENE_MODE_FIREWORKS\n     * @see #CONTROL_SCENE_MODE_SPORTS\n     * @see #CONTROL_SCENE_MODE_PARTY\n     * @see #CONTROL_SCENE_MODE_CANDLELIGHT\n     * @see #CONTROL_SCENE_MODE_BARCODE\n     * @see #CONTROL_SCENE_MODE_HIGH_SPEED_VIDEO\n     * @see #CONTROL_SCENE_MODE_HDR\n     ",
    "links" : [ "#CONTROL_SCENE_MODE_SPORTS", "android.hardware.camera2.CaptureRequest#CONTROL_AF_MODE", "#CONTROL_SCENE_MODE_DISABLED", "#CONTROL_SCENE_MODE_LANDSCAPE", "#CONTROL_SCENE_MODE_FIREWORKS", "#CONTROL_SCENE_MODE_PARTY", "android.hardware.camera2.CameraCharacteristics#CONTROL_AVAILABLE_SCENE_MODES", "#CONTROL_SCENE_MODE_PORTRAIT", "#CONTROL_SCENE_MODE_THEATRE", "#CONTROL_SCENE_MODE_CANDLELIGHT", "#CONTROL_SCENE_MODE_ACTION", "#CONTROL_SCENE_MODE_FACE_PRIORITY", "android.hardware.camera2.CaptureRequest#CONTROL_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_AE_MODE", "#CONTROL_SCENE_MODE_BARCODE", "#CONTROL_SCENE_MODE_SNOW", "#CONTROL_SCENE_MODE_STEADYPHOTO", "android.hardware.camera2.CaptureRequest#CONTROL_AWB_MODE", "#CONTROL_SCENE_MODE_NIGHT_PORTRAIT", "#CONTROL_SCENE_MODE_SUNSET", "#CONTROL_SCENE_MODE_HDR", "#CONTROL_SCENE_MODE_NIGHT", "#CONTROL_SCENE_MODE_BEACH", "#CONTROL_SCENE_MODE_HIGH_SPEED_VIDEO" ]
  }, {
    "name" : "CONTROL_VIDEO_STABILIZATION_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Whether video stabilization is\n     * active.</p>\n     * <p>Video stabilization automatically warps images from\n     * the camera in order to stabilize motion between consecutive frames.</p>\n     * <p>If enabled, video stabilization can modify the\n     * {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} to keep the video stream stabilized.</p>\n     * <p>Switching between different video stabilization modes may take several\n     * frames to initialize, the camera device will report the current mode\n     * in capture result metadata. For example, When \"ON\" mode is requested,\n     * the video stabilization modes in the first several capture results may\n     * still be \"OFF\", and it will become \"ON\" when the initialization is\n     * done.</p>\n     * <p>In addition, not all recording sizes or frame rates may be supported for\n     * stabilization by a device that reports stabilization support. It is guaranteed\n     * that an output targeting a MediaRecorder or MediaCodec will be stabilized if\n     * the recording resolution is less than or equal to 1920 x 1080 (width less than\n     * or equal to 1920, height less than or equal to 1080), and the recording\n     * frame rate is less than or equal to 30fps.  At other sizes, the CaptureResult\n     * {@link CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE android.control.videoStabilizationMode} field will return\n     * OFF if the recording output is not stabilized, or if there are no output\n     * Surface types that can be stabilized.</p>\n     * <p>If a camera device supports both this mode and OIS\n     * ({@link CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE android.lens.opticalStabilizationMode}), turning both modes on may\n     * produce undesirable interaction, so it is recommended not to enable\n     * both at the same time.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_VIDEO_STABILIZATION_MODE_OFF OFF}</li>\n     *   <li>{@link #CONTROL_VIDEO_STABILIZATION_MODE_ON ON}</li>\n     * </ul></p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE\n     * @see CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE\n     * @see CaptureRequest#SCALER_CROP_REGION\n     * @see #CONTROL_VIDEO_STABILIZATION_MODE_OFF\n     * @see #CONTROL_VIDEO_STABILIZATION_MODE_ON\n     ",
    "links" : [ "#CONTROL_VIDEO_STABILIZATION_MODE_ON", "android.hardware.camera2.CaptureRequest#LENS_OPTICAL_STABILIZATION_MODE", "#CONTROL_VIDEO_STABILIZATION_MODE_OFF", "android.hardware.camera2.CaptureRequest#SCALER_CROP_REGION", "android.hardware.camera2.CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE" ]
  }, {
    "name" : "CONTROL_POST_RAW_SENSITIVITY_BOOST",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>The amount of additional sensitivity boost applied to output images\n     * after RAW sensor data is captured.</p>\n     * <p>Some camera devices support additional digital sensitivity boosting in the\n     * camera processing pipeline after sensor RAW image is captured.\n     * Such a boost will be applied to YUV/JPEG format output images but will not\n     * have effect on RAW output formats like RAW_SENSOR, RAW10, RAW12 or RAW_OPAQUE.</p>\n     * <p>This key will be <code>null</code> for devices that do not support any RAW format\n     * outputs. For devices that do support RAW format outputs, this key will always\n     * present, and if a device does not support post RAW sensitivity boost, it will\n     * list <code>100</code> in this key.</p>\n     * <p>If the camera device cannot apply the exact boost requested, it will reduce the\n     * boost to the nearest supported value.\n     * The final boost value used will be available in the output capture result.</p>\n     * <p>For devices that support post RAW sensitivity boost, the YUV/JPEG output images\n     * of such device will have the total sensitivity of\n     * <code>{@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity} * {@link CaptureRequest#CONTROL_POST_RAW_SENSITIVITY_BOOST android.control.postRawSensitivityBoost} / 100</code>\n     * The sensitivity of RAW format images will always be <code>{@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}</code></p>\n     * <p>This control is only effective if {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} or {@link CaptureRequest#CONTROL_MODE android.control.mode} is set to\n     * OFF; otherwise the auto-exposure algorithm will override this value.</p>\n     * <p><b>Units</b>: ISO arithmetic units, the same as {@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}</p>\n     * <p><b>Range of valid values:</b><br>\n     * {@link CameraCharacteristics#CONTROL_POST_RAW_SENSITIVITY_BOOST_RANGE android.control.postRawSensitivityBoostRange}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CaptureRequest#CONTROL_MODE\n     * @see CaptureRequest#CONTROL_POST_RAW_SENSITIVITY_BOOST\n     * @see CameraCharacteristics#CONTROL_POST_RAW_SENSITIVITY_BOOST_RANGE\n     * @see CaptureRequest#SENSOR_SENSITIVITY\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#SENSOR_SENSITIVITY", "android.hardware.camera2.CameraCharacteristics#CONTROL_POST_RAW_SENSITIVITY_BOOST_RANGE", "android.hardware.camera2.CaptureRequest#CONTROL_AE_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_POST_RAW_SENSITIVITY_BOOST" ]
  }, {
    "name" : "CONTROL_ENABLE_ZSL",
    "type" : "Key<Boolean>",
    "comment" : "\n     * <p>Allow camera device to enable zero-shutter-lag mode for requests with\n     * {@link CaptureRequest#CONTROL_CAPTURE_INTENT android.control.captureIntent} == STILL_CAPTURE.</p>\n     * <p>If enableZsl is <code>true</code>, the camera device may enable zero-shutter-lag mode for requests with\n     * STILL_CAPTURE capture intent. The camera device may use images captured in the past to\n     * produce output images for a zero-shutter-lag request. The result metadata including the\n     * {@link CaptureResult#SENSOR_TIMESTAMP android.sensor.timestamp} reflects the source frames used to produce output images.\n     * Therefore, the contents of the output images and the result metadata may be out of order\n     * compared to previous regular requests. enableZsl does not affect requests with other\n     * capture intents.</p>\n     * <p>For example, when requests are submitted in the following order:\n     *   Request A: enableZsl is ON, {@link CaptureRequest#CONTROL_CAPTURE_INTENT android.control.captureIntent} is PREVIEW\n     *   Request B: enableZsl is ON, {@link CaptureRequest#CONTROL_CAPTURE_INTENT android.control.captureIntent} is STILL_CAPTURE</p>\n     * <p>The output images for request B may have contents captured before the output images for\n     * request A, and the result metadata for request B may be older than the result metadata for\n     * request A.</p>\n     * <p>Note that when enableZsl is <code>true</code>, it is not guaranteed to get output images captured in\n     * the past for requests with STILL_CAPTURE capture intent.</p>\n     * <p>For applications targeting SDK versions O and newer, the value of enableZsl in\n     * TEMPLATE_STILL_CAPTURE template may be <code>true</code>. The value in other templates is always\n     * <code>false</code> if present.</p>\n     * <p>For applications targeting SDK versions older than O, the value of enableZsl in all\n     * capture templates is always <code>false</code> if present.</p>\n     * <p>For application-operated ZSL, use CAMERA3_TEMPLATE_ZERO_SHUTTER_LAG template.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_CAPTURE_INTENT\n     * @see CaptureResult#SENSOR_TIMESTAMP\n     ",
    "links" : [ "android.hardware.camera2.CaptureResult#SENSOR_TIMESTAMP", "android.hardware.camera2.CaptureRequest#CONTROL_CAPTURE_INTENT" ]
  }, {
    "name" : "CONTROL_AF_SCENE_CHANGE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Whether a significant scene change is detected within the currently-set AF\n     * region(s).</p>\n     * <p>When the camera focus routine detects a change in the scene it is looking at,\n     * such as a large shift in camera viewpoint, significant motion in the scene, or a\n     * significant illumination change, this value will be set to DETECTED for a single capture\n     * result. Otherwise the value will be NOT_DETECTED. The threshold for detection is similar\n     * to what would trigger a new passive focus scan to begin in CONTINUOUS autofocus modes.</p>\n     * <p>This key will be available if the camera device advertises this key via {@link android.hardware.camera2.CameraCharacteristics#getAvailableCaptureResultKeys }.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_AF_SCENE_CHANGE_NOT_DETECTED NOT_DETECTED}</li>\n     *   <li>{@link #CONTROL_AF_SCENE_CHANGE_DETECTED DETECTED}</li>\n     * </ul></p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * @see #CONTROL_AF_SCENE_CHANGE_NOT_DETECTED\n     * @see #CONTROL_AF_SCENE_CHANGE_DETECTED\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#getAvailableCaptureResultKeys", "#CONTROL_AF_SCENE_CHANGE_NOT_DETECTED", "#CONTROL_AF_SCENE_CHANGE_DETECTED" ]
  }, {
    "name" : "CONTROL_EXTENDED_SCENE_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Whether extended scene mode is enabled for a particular capture request.</p>\n     * <p>With bokeh mode, the camera device may blur out the parts of scene that are not in\n     * focus, creating a bokeh (or shallow depth of field) effect for people or objects.</p>\n     * <p>When set to BOKEH_STILL_CAPTURE mode with STILL_CAPTURE capture intent, due to the extra\n     * processing needed for high quality bokeh effect, the stall may be longer than when\n     * capture intent is not STILL_CAPTURE.</p>\n     * <p>When set to BOKEH_STILL_CAPTURE mode with PREVIEW capture intent,</p>\n     * <ul>\n     * <li>If the camera device has BURST_CAPTURE capability, the frame rate requirement of\n     * BURST_CAPTURE must still be met.</li>\n     * <li>All streams not larger than the maximum streaming dimension for BOKEH_STILL_CAPTURE mode\n     * (queried via {@link android.hardware.camera2.CameraCharacteristics#CONTROL_AVAILABLE_EXTENDED_SCENE_MODE_CAPABILITIES })\n     * will have preview bokeh effect applied.</li>\n     * </ul>\n     * <p>When set to BOKEH_CONTINUOUS mode, configured streams dimension should not exceed this mode's\n     * maximum streaming dimension in order to have bokeh effect applied. Bokeh effect may not\n     * be available for streams larger than the maximum streaming dimension.</p>\n     * <p>Switching between different extended scene modes may involve reconfiguration of the camera\n     * pipeline, resulting in long latency. The application should check this key against the\n     * available session keys queried via\n     * {@link android.hardware.camera2.CameraCharacteristics#getAvailableSessionKeys }.</p>\n     * <p>For a logical multi-camera, bokeh may be implemented by stereo vision from sub-cameras\n     * with different field of view. As a result, when bokeh mode is enabled, the camera device\n     * may override {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} or {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio}, and the field of\n     * view may be smaller than when bokeh mode is off.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #CONTROL_EXTENDED_SCENE_MODE_DISABLED DISABLED}</li>\n     *   <li>{@link #CONTROL_EXTENDED_SCENE_MODE_BOKEH_STILL_CAPTURE BOKEH_STILL_CAPTURE}</li>\n     *   <li>{@link #CONTROL_EXTENDED_SCENE_MODE_BOKEH_CONTINUOUS BOKEH_CONTINUOUS}</li>\n     * </ul></p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_ZOOM_RATIO\n     * @see CaptureRequest#SCALER_CROP_REGION\n     * @see #CONTROL_EXTENDED_SCENE_MODE_DISABLED\n     * @see #CONTROL_EXTENDED_SCENE_MODE_BOKEH_STILL_CAPTURE\n     * @see #CONTROL_EXTENDED_SCENE_MODE_BOKEH_CONTINUOUS\n     ",
    "links" : [ "#CONTROL_EXTENDED_SCENE_MODE_DISABLED", "#CONTROL_EXTENDED_SCENE_MODE_BOKEH_CONTINUOUS", "android.hardware.camera2.CameraCharacteristics#CONTROL_AVAILABLE_EXTENDED_SCENE_MODE_CAPABILITIES", "android.hardware.camera2.CaptureRequest#SCALER_CROP_REGION", "#CONTROL_EXTENDED_SCENE_MODE_BOKEH_STILL_CAPTURE", "android.hardware.camera2.CaptureRequest#CONTROL_ZOOM_RATIO", "android.hardware.camera2.CameraCharacteristics#getAvailableSessionKeys" ]
  }, {
    "name" : "CONTROL_ZOOM_RATIO",
    "type" : "Key<Float>",
    "comment" : "\n     * <p>The desired zoom ratio</p>\n     * <p>Instead of using {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} with dual purposes of crop and zoom, the\n     * application can now choose to use this tag to specify the desired zoom level. The\n     * {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} can still be used to specify the horizontal or vertical\n     * crop to achieve aspect ratios different than the native camera sensor.</p>\n     * <p>By using this control, the application gains a simpler way to control zoom, which can\n     * be a combination of optical and digital zoom. For example, a multi-camera system may\n     * contain more than one lens with different focal lengths, and the user can use optical\n     * zoom by switching between lenses. Using zoomRatio has benefits in the scenarios below:</p>\n     * <ul>\n     * <li>Zooming in from a wide-angle lens to a telephoto lens: A floating-point ratio provides\n     *   better precision compared to an integer value of {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion}.</li>\n     * <li>Zooming out from a wide lens to an ultrawide lens: zoomRatio supports zoom-out whereas\n     *   {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} doesn't.</li>\n     * </ul>\n     * <p>To illustrate, here are several scenarios of different zoom ratios, crop regions,\n     * and output streams, for a hypothetical camera device with an active array of size\n     * <code>(2000,1500)</code>.</p>\n     * <ul>\n     * <li>Camera Configuration:<ul>\n     * <li>Active array size: <code>2000x1500</code> (3 MP, 4:3 aspect ratio)</li>\n     * <li>Output stream #1: <code>640x480</code> (VGA, 4:3 aspect ratio)</li>\n     * <li>Output stream #2: <code>1280x720</code> (720p, 16:9 aspect ratio)</li>\n     * </ul>\n     * </li>\n     * <li>Case #1: 4:3 crop region with 2.0x zoom ratio<ul>\n     * <li>Zoomed field of view: 1/4 of original field of view</li>\n     * <li>Crop region: <code>Rect(0, 0, 2000, 1500) // (left, top, right, bottom)</code> (post zoom)</li>\n     * </ul>\n     * </li>\n     * <li><img alt=\"4:3 aspect ratio crop diagram\" src=\"/reference/images/camera2/metadata/android.control.zoomRatio/zoom-ratio-2-crop-43.png\" /><ul>\n     * <li><code>640x480</code> stream source area: <code>(0, 0, 2000, 1500)</code> (equal to crop region)</li>\n     * <li><code>1280x720</code> stream source area: <code>(0, 187, 2000, 1312)</code> (letterboxed)</li>\n     * </ul>\n     * </li>\n     * <li>Case #2: 16:9 crop region with 2.0x zoom.<ul>\n     * <li>Zoomed field of view: 1/4 of original field of view</li>\n     * <li>Crop region: <code>Rect(0, 187, 2000, 1312)</code></li>\n     * <li><img alt=\"16:9 aspect ratio crop diagram\" src=\"/reference/images/camera2/metadata/android.control.zoomRatio/zoom-ratio-2-crop-169.png\" /></li>\n     * <li><code>640x480</code> stream source area: <code>(250, 187, 1750, 1312)</code> (pillarboxed)</li>\n     * <li><code>1280x720</code> stream source area: <code>(0, 187, 2000, 1312)</code> (equal to crop region)</li>\n     * </ul>\n     * </li>\n     * <li>Case #3: 1:1 crop region with 0.5x zoom out to ultrawide lens.<ul>\n     * <li>Zoomed field of view: 4x of original field of view (switched from wide lens to ultrawide lens)</li>\n     * <li>Crop region: <code>Rect(250, 0, 1750, 1500)</code></li>\n     * <li><img alt=\"1:1 aspect ratio crop diagram\" src=\"/reference/images/camera2/metadata/android.control.zoomRatio/zoom-ratio-0.5-crop-11.png\" /></li>\n     * <li><code>640x480</code> stream source area: <code>(250, 187, 1750, 1312)</code> (letterboxed)</li>\n     * <li><code>1280x720</code> stream source area: <code>(250, 328, 1750, 1172)</code> (letterboxed)</li>\n     * </ul>\n     * </li>\n     * </ul>\n     * <p>As seen from the graphs above, the coordinate system of cropRegion now changes to the\n     * effective after-zoom field-of-view, and is represented by the rectangle of (0, 0,\n     * activeArrayWith, activeArrayHeight). The same applies to AE/AWB/AF regions, and faces.\n     * This coordinate system change isn't applicable to RAW capture and its related\n     * metadata such as intrinsicCalibration and lensShadingMap.</p>\n     * <p>Using the same hypothetical example above, and assuming output stream #1 (640x480) is\n     * the viewfinder stream, the application can achieve 2.0x zoom in one of two ways:</p>\n     * <ul>\n     * <li>zoomRatio = 2.0, scaler.cropRegion = (0, 0, 2000, 1500)</li>\n     * <li>zoomRatio = 1.0 (default), scaler.cropRegion = (500, 375, 1500, 1125)</li>\n     * </ul>\n     * <p>If the application intends to set aeRegions to be top-left quarter of the viewfinder\n     * field-of-view, the {@link CaptureRequest#CONTROL_AE_REGIONS android.control.aeRegions} should be set to (0, 0, 1000, 750) with\n     * zoomRatio set to 2.0. Alternatively, the application can set aeRegions to the equivalent\n     * region of (500, 375, 1000, 750) for zoomRatio of 1.0. If the application doesn't\n     * explicitly set {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio}, its value defaults to 1.0.</p>\n     * <p>One limitation of controlling zoom using zoomRatio is that the {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion}\n     * must only be used for letterboxing or pillarboxing of the sensor active array, and no\n     * FREEFORM cropping can be used with {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} other than 1.0.</p>\n     * <p><b>Range of valid values:</b><br>\n     * {@link CameraCharacteristics#CONTROL_ZOOM_RATIO_RANGE android.control.zoomRatioRange}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Limited capability</b> -\n     * Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_REGIONS\n     * @see CaptureRequest#CONTROL_ZOOM_RATIO\n     * @see CameraCharacteristics#CONTROL_ZOOM_RATIO_RANGE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CaptureRequest#SCALER_CROP_REGION\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CaptureRequest#SCALER_CROP_REGION", "android.hardware.camera2.CaptureRequest#CONTROL_AE_REGIONS", "android.hardware.camera2.CaptureRequest#CONTROL_ZOOM_RATIO", "android.hardware.camera2.CameraCharacteristics#CONTROL_ZOOM_RATIO_RANGE", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED" ]
  }, {
    "name" : "EDGE_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Operation mode for edge\n     * enhancement.</p>\n     * <p>Edge enhancement improves sharpness and details in the captured image. OFF means\n     * no enhancement will be applied by the camera device.</p>\n     * <p>FAST/HIGH_QUALITY both mean camera device determined enhancement\n     * will be applied. HIGH_QUALITY mode indicates that the\n     * camera device will use the highest-quality enhancement algorithms,\n     * even if it slows down capture rate. FAST means the camera device will\n     * not slow down capture rate when applying edge enhancement. FAST may be the same as OFF if\n     * edge enhancement will slow down capture rate. Every output stream will have a similar\n     * amount of enhancement applied.</p>\n     * <p>ZERO_SHUTTER_LAG is meant to be used by applications that maintain a continuous circular\n     * buffer of high-resolution images during preview and reprocess image(s) from that buffer\n     * into a final capture when triggered by the user. In this mode, the camera device applies\n     * edge enhancement to low-resolution streams (below maximum recording resolution) to\n     * maximize preview quality, but does not apply edge enhancement to high-resolution streams,\n     * since those will be reprocessed later if necessary.</p>\n     * <p>For YUV_REPROCESSING, these FAST/HIGH_QUALITY modes both mean that the camera\n     * device will apply FAST/HIGH_QUALITY YUV-domain edge enhancement, respectively.\n     * The camera device may adjust its internal edge enhancement parameters for best\n     * image quality based on the {@link CaptureRequest#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR android.reprocess.effectiveExposureFactor}, if it is set.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #EDGE_MODE_OFF OFF}</li>\n     *   <li>{@link #EDGE_MODE_FAST FAST}</li>\n     *   <li>{@link #EDGE_MODE_HIGH_QUALITY HIGH_QUALITY}</li>\n     *   <li>{@link #EDGE_MODE_ZERO_SHUTTER_LAG ZERO_SHUTTER_LAG}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#EDGE_AVAILABLE_EDGE_MODES android.edge.availableEdgeModes}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CameraCharacteristics#EDGE_AVAILABLE_EDGE_MODES\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CaptureRequest#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR\n     * @see #EDGE_MODE_OFF\n     * @see #EDGE_MODE_FAST\n     * @see #EDGE_MODE_HIGH_QUALITY\n     * @see #EDGE_MODE_ZERO_SHUTTER_LAG\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "#EDGE_MODE_OFF", "#EDGE_MODE_HIGH_QUALITY", "#EDGE_MODE_ZERO_SHUTTER_LAG", "#EDGE_MODE_FAST", "android.hardware.camera2.CameraCharacteristics#EDGE_AVAILABLE_EDGE_MODES", "android.hardware.camera2.CaptureRequest#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR" ]
  }, {
    "name" : "FLASH_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>The desired mode for for the camera device's flash control.</p>\n     * <p>This control is only effective when flash unit is available\n     * (<code>{@link CameraCharacteristics#FLASH_INFO_AVAILABLE android.flash.info.available} == true</code>).</p>\n     * <p>When this control is used, the {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} must be set to ON or OFF.\n     * Otherwise, the camera device auto-exposure related flash control (ON_AUTO_FLASH,\n     * ON_ALWAYS_FLASH, or ON_AUTO_FLASH_REDEYE) will override this control.</p>\n     * <p>When set to OFF, the camera device will not fire flash for this capture.</p>\n     * <p>When set to SINGLE, the camera device will fire flash regardless of the camera\n     * device's auto-exposure routine's result. When used in still capture case, this\n     * control should be used along with auto-exposure (AE) precapture metering sequence\n     * ({@link CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER android.control.aePrecaptureTrigger}), otherwise, the image may be incorrectly exposed.</p>\n     * <p>When set to TORCH, the flash will be on continuously. This mode can be used\n     * for use cases such as preview, auto-focus assist, still capture, or video recording.</p>\n     * <p>The flash status will be reported by {@link CaptureResult#FLASH_STATE android.flash.state} in the capture result metadata.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #FLASH_MODE_OFF OFF}</li>\n     *   <li>{@link #FLASH_MODE_SINGLE SINGLE}</li>\n     *   <li>{@link #FLASH_MODE_TORCH TORCH}</li>\n     * </ul></p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER\n     * @see CameraCharacteristics#FLASH_INFO_AVAILABLE\n     * @see CaptureResult#FLASH_STATE\n     * @see #FLASH_MODE_OFF\n     * @see #FLASH_MODE_SINGLE\n     * @see #FLASH_MODE_TORCH\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#CONTROL_AE_MODE", "#FLASH_MODE_OFF", "#FLASH_MODE_SINGLE", "#FLASH_MODE_TORCH", "android.hardware.camera2.CameraCharacteristics#FLASH_INFO_AVAILABLE", "android.hardware.camera2.CaptureResult#FLASH_STATE", "android.hardware.camera2.CaptureRequest#CONTROL_AE_PRECAPTURE_TRIGGER" ]
  }, {
    "name" : "FLASH_STATE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Current state of the flash\n     * unit.</p>\n     * <p>When the camera device doesn't have flash unit\n     * (i.e. <code>{@link CameraCharacteristics#FLASH_INFO_AVAILABLE android.flash.info.available} == false</code>), this state will always be UNAVAILABLE.\n     * Other states indicate the current flash status.</p>\n     * <p>In certain conditions, this will be available on LEGACY devices:</p>\n     * <ul>\n     * <li>Flash-less cameras always return UNAVAILABLE.</li>\n     * <li>Using {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} <code>==</code> ON_ALWAYS_FLASH\n     *    will always return FIRED.</li>\n     * <li>Using {@link CaptureRequest#FLASH_MODE android.flash.mode} <code>==</code> TORCH\n     *    will always return FIRED.</li>\n     * </ul>\n     * <p>In all other conditions the state will not be available on\n     * LEGACY devices (i.e. it will be <code>null</code>).</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #FLASH_STATE_UNAVAILABLE UNAVAILABLE}</li>\n     *   <li>{@link #FLASH_STATE_CHARGING CHARGING}</li>\n     *   <li>{@link #FLASH_STATE_READY READY}</li>\n     *   <li>{@link #FLASH_STATE_FIRED FIRED}</li>\n     *   <li>{@link #FLASH_STATE_PARTIAL PARTIAL}</li>\n     * </ul></p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Limited capability</b> -\n     * Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CameraCharacteristics#FLASH_INFO_AVAILABLE\n     * @see CaptureRequest#FLASH_MODE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see #FLASH_STATE_UNAVAILABLE\n     * @see #FLASH_STATE_CHARGING\n     * @see #FLASH_STATE_READY\n     * @see #FLASH_STATE_FIRED\n     * @see #FLASH_STATE_PARTIAL\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CaptureRequest#CONTROL_AE_MODE", "#FLASH_STATE_READY", "#FLASH_STATE_UNAVAILABLE", "android.hardware.camera2.CameraCharacteristics#FLASH_INFO_AVAILABLE", "#FLASH_STATE_CHARGING", "android.hardware.camera2.CaptureRequest#FLASH_MODE", "#FLASH_STATE_FIRED", "#FLASH_STATE_PARTIAL", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED" ]
  }, {
    "name" : "HOT_PIXEL_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Operational mode for hot pixel correction.</p>\n     * <p>Hotpixel correction interpolates out, or otherwise removes, pixels\n     * that do not accurately measure the incoming light (i.e. pixels that\n     * are stuck at an arbitrary value or are oversensitive).</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #HOT_PIXEL_MODE_OFF OFF}</li>\n     *   <li>{@link #HOT_PIXEL_MODE_FAST FAST}</li>\n     *   <li>{@link #HOT_PIXEL_MODE_HIGH_QUALITY HIGH_QUALITY}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES android.hotPixel.availableHotPixelModes}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CameraCharacteristics#HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES\n     * @see #HOT_PIXEL_MODE_OFF\n     * @see #HOT_PIXEL_MODE_FAST\n     * @see #HOT_PIXEL_MODE_HIGH_QUALITY\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES", "#HOT_PIXEL_MODE_OFF", "#HOT_PIXEL_MODE_HIGH_QUALITY", "#HOT_PIXEL_MODE_FAST" ]
  }, {
    "name" : "JPEG_GPS_LOCATION",
    "type" : "Key<android.location.Location>",
    "comment" : "\n     * <p>A location object to use when generating image GPS metadata.</p>\n     * <p>Setting a location object in a request will include the GPS coordinates of the location\n     * into any JPEG images captured based on the request. These coordinates can then be\n     * viewed by anyone who receives the JPEG image.</p>\n     * <p>This tag is also used for HEIC image capture.</p>\n     * <p>This key is available on all devices.</p>\n     ",
    "links" : [ ]
  }, {
    "name" : "JPEG_GPS_COORDINATES",
    "type" : "Key<double[]>",
    "comment" : "\n     * <p>GPS coordinates to include in output JPEG\n     * EXIF.</p>\n     * <p>This tag is also used for HEIC image capture.</p>\n     * <p><b>Range of valid values:</b><br>\n     * (-180 - 180], [-90,90], [-inf, inf]</p>\n     * <p>This key is available on all devices.</p>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "JPEG_GPS_PROCESSING_METHOD",
    "type" : "Key<String>",
    "comment" : "\n     * <p>32 characters describing GPS algorithm to\n     * include in EXIF.</p>\n     * <p>This tag is also used for HEIC image capture.</p>\n     * <p>This key is available on all devices.</p>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "JPEG_GPS_TIMESTAMP",
    "type" : "Key<Long>",
    "comment" : "\n     * <p>Time GPS fix was made to include in\n     * EXIF.</p>\n     * <p>This tag is also used for HEIC image capture.</p>\n     * <p><b>Units</b>: UTC in seconds since January 1, 1970</p>\n     * <p>This key is available on all devices.</p>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "JPEG_ORIENTATION",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>The orientation for a JPEG image.</p>\n     * <p>The clockwise rotation angle in degrees, relative to the orientation\n     * to the camera, that the JPEG picture needs to be rotated by, to be viewed\n     * upright.</p>\n     * <p>Camera devices may either encode this value into the JPEG EXIF header, or\n     * rotate the image data to match this orientation. When the image data is rotated,\n     * the thumbnail data will also be rotated.</p>\n     * <p>Note that this orientation is relative to the orientation of the camera sensor, given\n     * by {@link CameraCharacteristics#SENSOR_ORIENTATION android.sensor.orientation}.</p>\n     * <p>To translate from the device orientation given by the Android sensor APIs for camera\n     * sensors which are not EXTERNAL, the following sample code may be used:</p>\n     * <pre><code>private int getJpegOrientation(CameraCharacteristics c, int deviceOrientation) {\n     *     if (deviceOrientation == android.view.OrientationEventListener.ORIENTATION_UNKNOWN) return 0;\n     *     int sensorOrientation = c.get(CameraCharacteristics.SENSOR_ORIENTATION);\n     *\n     *     // Round device orientation to a multiple of 90\n     *     deviceOrientation = (deviceOrientation + 45) / 90 * 90;\n     *\n     *     // Reverse device orientation for front-facing cameras\n     *     boolean facingFront = c.get(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_FRONT;\n     *     if (facingFront) deviceOrientation = -deviceOrientation;\n     *\n     *     // Calculate desired JPEG orientation relative to camera orientation to make\n     *     // the image upright relative to the device orientation\n     *     int jpegOrientation = (sensorOrientation + deviceOrientation + 360) % 360;\n     *\n     *     return jpegOrientation;\n     * }\n     * </code></pre>\n     * <p>For EXTERNAL cameras the sensor orientation will always be set to 0 and the facing will\n     * also be set to EXTERNAL. The above code is not relevant in such case.</p>\n     * <p>This tag is also used to describe the orientation of the HEIC image capture, in which\n     * case the rotation is reflected by\n     * {@link android.media.ExifInterface#TAG_ORIENTATION EXIF orientation flag}, and not by\n     * rotating the image data itself.</p>\n     * <p><b>Units</b>: Degrees in multiples of 90</p>\n     * <p><b>Range of valid values:</b><br>\n     * 0, 90, 180, 270</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CameraCharacteristics#SENSOR_ORIENTATION\n     ",
    "links" : [ "android.media.ExifInterface#TAG_ORIENTATION", "android.hardware.camera2.CameraCharacteristics#SENSOR_ORIENTATION" ]
  }, {
    "name" : "JPEG_QUALITY",
    "type" : "Key<Byte>",
    "comment" : "\n     * <p>Compression quality of the final JPEG\n     * image.</p>\n     * <p>85-95 is typical usage range. This tag is also used to describe the quality\n     * of the HEIC image capture.</p>\n     * <p><b>Range of valid values:</b><br>\n     * 1-100; larger is higher quality</p>\n     * <p>This key is available on all devices.</p>\n     ",
    "links" : [ ]
  }, {
    "name" : "JPEG_THUMBNAIL_QUALITY",
    "type" : "Key<Byte>",
    "comment" : "\n     * <p>Compression quality of JPEG\n     * thumbnail.</p>\n     * <p>This tag is also used to describe the quality of the HEIC image capture.</p>\n     * <p><b>Range of valid values:</b><br>\n     * 1-100; larger is higher quality</p>\n     * <p>This key is available on all devices.</p>\n     ",
    "links" : [ ]
  }, {
    "name" : "JPEG_THUMBNAIL_SIZE",
    "type" : "Key<android.util.Size>",
    "comment" : "\n     * <p>Resolution of embedded JPEG thumbnail.</p>\n     * <p>When set to (0, 0) value, the JPEG EXIF will not contain thumbnail,\n     * but the captured JPEG will still be a valid image.</p>\n     * <p>For best results, when issuing a request for a JPEG image, the thumbnail size selected\n     * should have the same aspect ratio as the main JPEG output.</p>\n     * <p>If the thumbnail image aspect ratio differs from the JPEG primary image aspect\n     * ratio, the camera device creates the thumbnail by cropping it from the primary image.\n     * For example, if the primary image has 4:3 aspect ratio, the thumbnail image has\n     * 16:9 aspect ratio, the primary image will be cropped vertically (letterbox) to\n     * generate the thumbnail image. The thumbnail image will always have a smaller Field\n     * Of View (FOV) than the primary image when aspect ratios differ.</p>\n     * <p>When an {@link CaptureRequest#JPEG_ORIENTATION android.jpeg.orientation} of non-zero degree is requested,\n     * the camera device will handle thumbnail rotation in one of the following ways:</p>\n     * <ul>\n     * <li>Set the {@link android.media.ExifInterface#TAG_ORIENTATION EXIF orientation flag}\n     *   and keep jpeg and thumbnail image data unrotated.</li>\n     * <li>Rotate the jpeg and thumbnail image data and not set\n     *   {@link android.media.ExifInterface#TAG_ORIENTATION EXIF orientation flag}. In this\n     *   case, LIMITED or FULL hardware level devices will report rotated thumnail size in\n     *   capture result, so the width and height will be interchanged if 90 or 270 degree\n     *   orientation is requested. LEGACY device will always report unrotated thumbnail\n     *   size.</li>\n     * </ul>\n     * <p>The tag is also used as thumbnail size for HEIC image format capture, in which case the\n     * the thumbnail rotation is reflected by\n     * {@link android.media.ExifInterface#TAG_ORIENTATION EXIF orientation flag}, and not by\n     * rotating the thumbnail data itself.</p>\n     * <p><b>Range of valid values:</b><br>\n     * {@link CameraCharacteristics#JPEG_AVAILABLE_THUMBNAIL_SIZES android.jpeg.availableThumbnailSizes}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CameraCharacteristics#JPEG_AVAILABLE_THUMBNAIL_SIZES\n     * @see CaptureRequest#JPEG_ORIENTATION\n     ",
    "links" : [ "android.media.ExifInterface#TAG_ORIENTATION", "android.hardware.camera2.CaptureRequest#JPEG_ORIENTATION", "android.hardware.camera2.CameraCharacteristics#JPEG_AVAILABLE_THUMBNAIL_SIZES" ]
  }, {
    "name" : "LENS_APERTURE",
    "type" : "Key<Float>",
    "comment" : "\n     * <p>The desired lens aperture size, as a ratio of lens focal length to the\n     * effective aperture diameter.</p>\n     * <p>Setting this value is only supported on the camera devices that have a variable\n     * aperture lens.</p>\n     * <p>When this is supported and {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} is OFF,\n     * this can be set along with {@link CaptureRequest#SENSOR_EXPOSURE_TIME android.sensor.exposureTime},\n     * {@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}, and {@link CaptureRequest#SENSOR_FRAME_DURATION android.sensor.frameDuration}\n     * to achieve manual exposure control.</p>\n     * <p>The requested aperture value may take several frames to reach the\n     * requested value; the camera device will report the current (intermediate)\n     * aperture size in capture result metadata while the aperture is changing.\n     * While the aperture is still changing, {@link CaptureResult#LENS_STATE android.lens.state} will be set to MOVING.</p>\n     * <p>When this is supported and {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} is one of\n     * the ON modes, this will be overridden by the camera device\n     * auto-exposure algorithm, the overridden values are then provided\n     * back to the user in the corresponding result.</p>\n     * <p><b>Units</b>: The f-number (f/N)</p>\n     * <p><b>Range of valid values:</b><br>\n     * {@link CameraCharacteristics#LENS_INFO_AVAILABLE_APERTURES android.lens.info.availableApertures}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#LENS_INFO_AVAILABLE_APERTURES\n     * @see CaptureResult#LENS_STATE\n     * @see CaptureRequest#SENSOR_EXPOSURE_TIME\n     * @see CaptureRequest#SENSOR_FRAME_DURATION\n     * @see CaptureRequest#SENSOR_SENSITIVITY\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#SENSOR_SENSITIVITY", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CaptureRequest#SENSOR_FRAME_DURATION", "android.hardware.camera2.CaptureResult#LENS_STATE", "android.hardware.camera2.CameraCharacteristics#LENS_INFO_AVAILABLE_APERTURES", "android.hardware.camera2.CaptureRequest#CONTROL_AE_MODE", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "android.hardware.camera2.CaptureRequest#SENSOR_EXPOSURE_TIME" ]
  }, {
    "name" : "LENS_FILTER_DENSITY",
    "type" : "Key<Float>",
    "comment" : "\n     * <p>The desired setting for the lens neutral density filter(s).</p>\n     * <p>This control will not be supported on most camera devices.</p>\n     * <p>Lens filters are typically used to lower the amount of light the\n     * sensor is exposed to (measured in steps of EV). As used here, an EV\n     * step is the standard logarithmic representation, which are\n     * non-negative, and inversely proportional to the amount of light\n     * hitting the sensor.  For example, setting this to 0 would result\n     * in no reduction of the incoming light, and setting this to 2 would\n     * mean that the filter is set to reduce incoming light by two stops\n     * (allowing 1/4 of the prior amount of light to the sensor).</p>\n     * <p>It may take several frames before the lens filter density changes\n     * to the requested value. While the filter density is still changing,\n     * {@link CaptureResult#LENS_STATE android.lens.state} will be set to MOVING.</p>\n     * <p><b>Units</b>: Exposure Value (EV)</p>\n     * <p><b>Range of valid values:</b><br>\n     * {@link CameraCharacteristics#LENS_INFO_AVAILABLE_FILTER_DENSITIES android.lens.info.availableFilterDensities}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#LENS_INFO_AVAILABLE_FILTER_DENSITIES\n     * @see CaptureResult#LENS_STATE\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CaptureResult#LENS_STATE", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "android.hardware.camera2.CameraCharacteristics#LENS_INFO_AVAILABLE_FILTER_DENSITIES" ]
  }, {
    "name" : "LENS_FOCAL_LENGTH",
    "type" : "Key<Float>",
    "comment" : "\n     * <p>The desired lens focal length; used for optical zoom.</p>\n     * <p>This setting controls the physical focal length of the camera\n     * device's lens. Changing the focal length changes the field of\n     * view of the camera device, and is usually used for optical zoom.</p>\n     * <p>Like {@link CaptureRequest#LENS_FOCUS_DISTANCE android.lens.focusDistance} and {@link CaptureRequest#LENS_APERTURE android.lens.aperture}, this\n     * setting won't be applied instantaneously, and it may take several\n     * frames before the lens can change to the requested focal length.\n     * While the focal length is still changing, {@link CaptureResult#LENS_STATE android.lens.state} will\n     * be set to MOVING.</p>\n     * <p>Optical zoom via this control will not be supported on most devices. Starting from API\n     * level 30, the camera device may combine optical and digital zoom through the\n     * {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} control.</p>\n     * <p><b>Units</b>: Millimeters</p>\n     * <p><b>Range of valid values:</b><br>\n     * {@link CameraCharacteristics#LENS_INFO_AVAILABLE_FOCAL_LENGTHS android.lens.info.availableFocalLengths}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_ZOOM_RATIO\n     * @see CaptureRequest#LENS_APERTURE\n     * @see CaptureRequest#LENS_FOCUS_DISTANCE\n     * @see CameraCharacteristics#LENS_INFO_AVAILABLE_FOCAL_LENGTHS\n     * @see CaptureResult#LENS_STATE\n     ",
    "links" : [ "android.hardware.camera2.CaptureResult#LENS_STATE", "android.hardware.camera2.CaptureRequest#LENS_APERTURE", "android.hardware.camera2.CameraCharacteristics#LENS_INFO_AVAILABLE_FOCAL_LENGTHS", "android.hardware.camera2.CaptureRequest#LENS_FOCUS_DISTANCE", "android.hardware.camera2.CaptureRequest#CONTROL_ZOOM_RATIO" ]
  }, {
    "name" : "LENS_FOCUS_DISTANCE",
    "type" : "Key<Float>",
    "comment" : "\n     * <p>Desired distance to plane of sharpest focus,\n     * measured from frontmost surface of the lens.</p>\n     * <p>Should be zero for fixed-focus cameras</p>\n     * <p><b>Units</b>: See {@link CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION android.lens.info.focusDistanceCalibration} for details</p>\n     * <p><b>Range of valid values:</b><br>\n     * &gt;= 0</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "android.hardware.camera2.CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION" ]
  }, {
    "name" : "LENS_FOCUS_RANGE",
    "type" : "Key<android.util.Pair<Float, Float>>",
    "comment" : "\n     * <p>The range of scene distances that are in\n     * sharp focus (depth of field).</p>\n     * <p>If variable focus not supported, can still report\n     * fixed depth of field range</p>\n     * <p><b>Units</b>: A pair of focus distances in diopters: (near,\n     * far); see {@link CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION android.lens.info.focusDistanceCalibration} for details.</p>\n     * <p><b>Range of valid values:</b><br>\n     * &gt;=0</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Limited capability</b> -\n     * Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CameraCharacteristics#LENS_INFO_FOCUS_DISTANCE_CALIBRATION", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED" ]
  }, {
    "name" : "LENS_OPTICAL_STABILIZATION_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Sets whether the camera device uses optical image stabilization (OIS)\n     * when capturing images.</p>\n     * <p>OIS is used to compensate for motion blur due to small\n     * movements of the camera during capture. Unlike digital image\n     * stabilization ({@link CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE android.control.videoStabilizationMode}), OIS\n     * makes use of mechanical elements to stabilize the camera\n     * sensor, and thus allows for longer exposure times before\n     * camera shake becomes apparent.</p>\n     * <p>Switching between different optical stabilization modes may take several\n     * frames to initialize, the camera device will report the current mode in\n     * capture result metadata. For example, When \"ON\" mode is requested, the\n     * optical stabilization modes in the first several capture results may still\n     * be \"OFF\", and it will become \"ON\" when the initialization is done.</p>\n     * <p>If a camera device supports both OIS and digital image stabilization\n     * ({@link CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE android.control.videoStabilizationMode}), turning both modes on may produce undesirable\n     * interaction, so it is recommended not to enable both at the same time.</p>\n     * <p>Not all devices will support OIS; see\n     * {@link CameraCharacteristics#LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION android.lens.info.availableOpticalStabilization} for\n     * available controls.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #LENS_OPTICAL_STABILIZATION_MODE_OFF OFF}</li>\n     *   <li>{@link #LENS_OPTICAL_STABILIZATION_MODE_ON ON}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION android.lens.info.availableOpticalStabilization}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Limited capability</b> -\n     * Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION\n     * @see #LENS_OPTICAL_STABILIZATION_MODE_OFF\n     * @see #LENS_OPTICAL_STABILIZATION_MODE_ON\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CameraCharacteristics#LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION", "#LENS_OPTICAL_STABILIZATION_MODE_ON", "#LENS_OPTICAL_STABILIZATION_MODE_OFF", "android.hardware.camera2.CaptureRequest#CONTROL_VIDEO_STABILIZATION_MODE", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED" ]
  }, {
    "name" : "LENS_STATE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Current lens status.</p>\n     * <p>For lens parameters {@link CaptureRequest#LENS_FOCAL_LENGTH android.lens.focalLength}, {@link CaptureRequest#LENS_FOCUS_DISTANCE android.lens.focusDistance},\n     * {@link CaptureRequest#LENS_FILTER_DENSITY android.lens.filterDensity} and {@link CaptureRequest#LENS_APERTURE android.lens.aperture}, when changes are requested,\n     * they may take several frames to reach the requested values. This state indicates\n     * the current status of the lens parameters.</p>\n     * <p>When the state is STATIONARY, the lens parameters are not changing. This could be\n     * either because the parameters are all fixed, or because the lens has had enough\n     * time to reach the most recently-requested values.\n     * If all these lens parameters are not changable for a camera device, as listed below:</p>\n     * <ul>\n     * <li>Fixed focus (<code>{@link CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE android.lens.info.minimumFocusDistance} == 0</code>), which means\n     * {@link CaptureRequest#LENS_FOCUS_DISTANCE android.lens.focusDistance} parameter will always be 0.</li>\n     * <li>Fixed focal length ({@link CameraCharacteristics#LENS_INFO_AVAILABLE_FOCAL_LENGTHS android.lens.info.availableFocalLengths} contains single value),\n     * which means the optical zoom is not supported.</li>\n     * <li>No ND filter ({@link CameraCharacteristics#LENS_INFO_AVAILABLE_FILTER_DENSITIES android.lens.info.availableFilterDensities} contains only 0).</li>\n     * <li>Fixed aperture ({@link CameraCharacteristics#LENS_INFO_AVAILABLE_APERTURES android.lens.info.availableApertures} contains single value).</li>\n     * </ul>\n     * <p>Then this state will always be STATIONARY.</p>\n     * <p>When the state is MOVING, it indicates that at least one of the lens parameters\n     * is changing.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #LENS_STATE_STATIONARY STATIONARY}</li>\n     *   <li>{@link #LENS_STATE_MOVING MOVING}</li>\n     * </ul></p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Limited capability</b> -\n     * Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CaptureRequest#LENS_APERTURE\n     * @see CaptureRequest#LENS_FILTER_DENSITY\n     * @see CaptureRequest#LENS_FOCAL_LENGTH\n     * @see CaptureRequest#LENS_FOCUS_DISTANCE\n     * @see CameraCharacteristics#LENS_INFO_AVAILABLE_APERTURES\n     * @see CameraCharacteristics#LENS_INFO_AVAILABLE_FILTER_DENSITIES\n     * @see CameraCharacteristics#LENS_INFO_AVAILABLE_FOCAL_LENGTHS\n     * @see CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE\n     * @see #LENS_STATE_STATIONARY\n     * @see #LENS_STATE_MOVING\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CameraCharacteristics#LENS_INFO_MINIMUM_FOCUS_DISTANCE", "android.hardware.camera2.CameraCharacteristics#LENS_INFO_AVAILABLE_APERTURES", "#LENS_STATE_STATIONARY", "android.hardware.camera2.CaptureRequest#LENS_APERTURE", "android.hardware.camera2.CaptureRequest#LENS_FOCAL_LENGTH", "android.hardware.camera2.CameraCharacteristics#LENS_INFO_AVAILABLE_FOCAL_LENGTHS", "android.hardware.camera2.CaptureRequest#LENS_FILTER_DENSITY", "android.hardware.camera2.CameraCharacteristics#LENS_INFO_AVAILABLE_FILTER_DENSITIES", "android.hardware.camera2.CaptureRequest#LENS_FOCUS_DISTANCE", "#LENS_STATE_MOVING", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED" ]
  }, {
    "name" : "LENS_POSE_ROTATION",
    "type" : "Key<float[]>",
    "comment" : "\n     * <p>The orientation of the camera relative to the sensor\n     * coordinate system.</p>\n     * <p>The four coefficients that describe the quaternion\n     * rotation from the Android sensor coordinate system to a\n     * camera-aligned coordinate system where the X-axis is\n     * aligned with the long side of the image sensor, the Y-axis\n     * is aligned with the short side of the image sensor, and\n     * the Z-axis is aligned with the optical axis of the sensor.</p>\n     * <p>To convert from the quaternion coefficients <code>(x,y,z,w)</code>\n     * to the axis of rotation <code>(a_x, a_y, a_z)</code> and rotation\n     * amount <code>theta</code>, the following formulas can be used:</p>\n     * <pre><code> theta = 2 * acos(w)\n     * a_x = x / sin(theta/2)\n     * a_y = y / sin(theta/2)\n     * a_z = z / sin(theta/2)\n     * </code></pre>\n     * <p>To create a 3x3 rotation matrix that applies the rotation\n     * defined by this quaternion, the following matrix can be\n     * used:</p>\n     * <pre><code>R = [ 1 - 2y^2 - 2z^2,       2xy - 2zw,       2xz + 2yw,\n     *            2xy + 2zw, 1 - 2x^2 - 2z^2,       2yz - 2xw,\n     *            2xz - 2yw,       2yz + 2xw, 1 - 2x^2 - 2y^2 ]\n     * </code></pre>\n     * <p>This matrix can then be used to apply the rotation to a\n     *  column vector point with</p>\n     * <p><code>p' = Rp</code></p>\n     * <p>where <code>p</code> is in the device sensor coordinate system, and\n     *  <code>p'</code> is in the camera-oriented coordinate system.</p>\n     * <p>If {@link CameraCharacteristics#LENS_POSE_REFERENCE android.lens.poseReference} is UNDEFINED, the quaternion rotation cannot\n     *  be accurately represented by the camera device, and will be represented by\n     *  default values matching its default facing.</p>\n     * <p><b>Units</b>:\n     * Quaternion coefficients</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Permission {@link android.Manifest.permission#CAMERA } is needed to access this property</b></p>\n     *\n     * @see CameraCharacteristics#LENS_POSE_REFERENCE\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#LENS_POSE_REFERENCE", "android.Manifest.permission#CAMERA" ]
  }, {
    "name" : "LENS_POSE_TRANSLATION",
    "type" : "Key<float[]>",
    "comment" : "\n     * <p>Position of the camera optical center.</p>\n     * <p>The position of the camera device's lens optical center,\n     * as a three-dimensional vector <code>(x,y,z)</code>.</p>\n     * <p>Prior to Android P, or when {@link CameraCharacteristics#LENS_POSE_REFERENCE android.lens.poseReference} is PRIMARY_CAMERA, this position\n     * is relative to the optical center of the largest camera device facing in the same\n     * direction as this camera, in the {@link android.hardware.SensorEvent Android sensor\n     * coordinate axes}. Note that only the axis definitions are shared with the sensor\n     * coordinate system, but not the origin.</p>\n     * <p>If this device is the largest or only camera device with a given facing, then this\n     * position will be <code>(0, 0, 0)</code>; a camera device with a lens optical center located 3 cm\n     * from the main sensor along the +X axis (to the right from the user's perspective) will\n     * report <code>(0.03, 0, 0)</code>.  Note that this means that, for many computer vision\n     * applications, the position needs to be negated to convert it to a translation from the\n     * camera to the origin.</p>\n     * <p>To transform a pixel coordinates between two cameras facing the same direction, first\n     * the source camera {@link CameraCharacteristics#LENS_DISTORTION android.lens.distortion} must be corrected for.  Then the source\n     * camera {@link CameraCharacteristics#LENS_INTRINSIC_CALIBRATION android.lens.intrinsicCalibration} needs to be applied, followed by the\n     * {@link CameraCharacteristics#LENS_POSE_ROTATION android.lens.poseRotation} of the source camera, the translation of the source camera\n     * relative to the destination camera, the {@link CameraCharacteristics#LENS_POSE_ROTATION android.lens.poseRotation} of the destination\n     * camera, and finally the inverse of {@link CameraCharacteristics#LENS_INTRINSIC_CALIBRATION android.lens.intrinsicCalibration} of the destination\n     * camera. This obtains a radial-distortion-free coordinate in the destination camera pixel\n     * coordinates.</p>\n     * <p>To compare this against a real image from the destination camera, the destination camera\n     * image then needs to be corrected for radial distortion before comparison or sampling.</p>\n     * <p>When {@link CameraCharacteristics#LENS_POSE_REFERENCE android.lens.poseReference} is GYROSCOPE, then this position is relative to\n     * the center of the primary gyroscope on the device. The axis definitions are the same as\n     * with PRIMARY_CAMERA.</p>\n     * <p>When {@link CameraCharacteristics#LENS_POSE_REFERENCE android.lens.poseReference} is UNDEFINED, this position cannot be accurately\n     * represented by the camera device, and will be represented as <code>(0, 0, 0)</code>.</p>\n     * <p><b>Units</b>: Meters</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Permission {@link android.Manifest.permission#CAMERA } is needed to access this property</b></p>\n     *\n     * @see CameraCharacteristics#LENS_DISTORTION\n     * @see CameraCharacteristics#LENS_INTRINSIC_CALIBRATION\n     * @see CameraCharacteristics#LENS_POSE_REFERENCE\n     * @see CameraCharacteristics#LENS_POSE_ROTATION\n     ",
    "links" : [ "android.hardware.SensorEvent", "android.hardware.camera2.CameraCharacteristics#LENS_DISTORTION", "android.hardware.camera2.CameraCharacteristics#LENS_POSE_REFERENCE", "android.hardware.camera2.CameraCharacteristics#LENS_INTRINSIC_CALIBRATION", "android.hardware.camera2.CameraCharacteristics#LENS_POSE_ROTATION", "android.Manifest.permission#CAMERA" ]
  }, {
    "name" : "LENS_INTRINSIC_CALIBRATION",
    "type" : "Key<float[]>",
    "comment" : "\n     * <p>The parameters for this camera device's intrinsic\n     * calibration.</p>\n     * <p>The five calibration parameters that describe the\n     * transform from camera-centric 3D coordinates to sensor\n     * pixel coordinates:</p>\n     * <pre><code>[f_x, f_y, c_x, c_y, s]\n     * </code></pre>\n     * <p>Where <code>f_x</code> and <code>f_y</code> are the horizontal and vertical\n     * focal lengths, <code>[c_x, c_y]</code> is the position of the optical\n     * axis, and <code>s</code> is a skew parameter for the sensor plane not\n     * being aligned with the lens plane.</p>\n     * <p>These are typically used within a transformation matrix K:</p>\n     * <pre><code>K = [ f_x,   s, c_x,\n     *        0, f_y, c_y,\n     *        0    0,   1 ]\n     * </code></pre>\n     * <p>which can then be combined with the camera pose rotation\n     * <code>R</code> and translation <code>t</code> ({@link CameraCharacteristics#LENS_POSE_ROTATION android.lens.poseRotation} and\n     * {@link CameraCharacteristics#LENS_POSE_TRANSLATION android.lens.poseTranslation}, respectively) to calculate the\n     * complete transform from world coordinates to pixel\n     * coordinates:</p>\n     * <pre><code>P = [ K 0   * [ R -Rt\n     *      0 1 ]      0 1 ]\n     * </code></pre>\n     * <p>(Note the negation of poseTranslation when mapping from camera\n     * to world coordinates, and multiplication by the rotation).</p>\n     * <p>With <code>p_w</code> being a point in the world coordinate system\n     * and <code>p_s</code> being a point in the camera active pixel array\n     * coordinate system, and with the mapping including the\n     * homogeneous division by z:</p>\n     * <pre><code> p_h = (x_h, y_h, z_h) = P p_w\n     * p_s = p_h / z_h\n     * </code></pre>\n     * <p>so <code>[x_s, y_s]</code> is the pixel coordinates of the world\n     * point, <code>z_s = 1</code>, and <code>w_s</code> is a measurement of disparity\n     * (depth) in pixel coordinates.</p>\n     * <p>Note that the coordinate system for this transform is the\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize} system,\n     * where <code>(0,0)</code> is the top-left of the\n     * preCorrectionActiveArraySize rectangle. Once the pose and\n     * intrinsic calibration transforms have been applied to a\n     * world point, then the {@link CameraCharacteristics#LENS_DISTORTION android.lens.distortion}\n     * transform needs to be applied, and the result adjusted to\n     * be in the {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize} coordinate\n     * system (where <code>(0, 0)</code> is the top-left of the\n     * activeArraySize rectangle), to determine the final pixel\n     * coordinate of the world point for processed (non-RAW)\n     * output buffers.</p>\n     * <p>For camera devices, the center of pixel <code>(x,y)</code> is located at\n     * coordinate <code>(x + 0.5, y + 0.5)</code>.  So on a device with a\n     * precorrection active array of size <code>(10,10)</code>, the valid pixel\n     * indices go from <code>(0,0)-(9,9)</code>, and an perfectly-built camera would\n     * have an optical center at the exact center of the pixel grid, at\n     * coordinates <code>(5.0, 5.0)</code>, which is the top-left corner of pixel\n     * <code>(5,5)</code>.</p>\n     * <p><b>Units</b>:\n     * Pixels in the\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}\n     * coordinate system.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Permission {@link android.Manifest.permission#CAMERA } is needed to access this property</b></p>\n     *\n     * @see CameraCharacteristics#LENS_DISTORTION\n     * @see CameraCharacteristics#LENS_POSE_ROTATION\n     * @see CameraCharacteristics#LENS_POSE_TRANSLATION\n     * @see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE\n     * @see CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#LENS_DISTORTION", "android.hardware.camera2.CameraCharacteristics#LENS_POSE_ROTATION", "android.Manifest.permission#CAMERA", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "android.hardware.camera2.CameraCharacteristics#LENS_POSE_TRANSLATION" ]
  }, {
    "name" : "LENS_RADIAL_DISTORTION",
    "type" : "Key<float[]>",
    "comment" : "\n     * <p>The correction coefficients to correct for this camera device's\n     * radial and tangential lens distortion.</p>\n     * <p>Four radial distortion coefficients <code>[kappa_0, kappa_1, kappa_2,\n     * kappa_3]</code> and two tangential distortion coefficients\n     * <code>[kappa_4, kappa_5]</code> that can be used to correct the\n     * lens's geometric distortion with the mapping equations:</p>\n     * <pre><code> x_c = x_i * ( kappa_0 + kappa_1 * r^2 + kappa_2 * r^4 + kappa_3 * r^6 ) +\n     *        kappa_4 * (2 * x_i * y_i) + kappa_5 * ( r^2 + 2 * x_i^2 )\n     *  y_c = y_i * ( kappa_0 + kappa_1 * r^2 + kappa_2 * r^4 + kappa_3 * r^6 ) +\n     *        kappa_5 * (2 * x_i * y_i) + kappa_4 * ( r^2 + 2 * y_i^2 )\n     * </code></pre>\n     * <p>Here, <code>[x_c, y_c]</code> are the coordinates to sample in the\n     * input image that correspond to the pixel values in the\n     * corrected image at the coordinate <code>[x_i, y_i]</code>:</p>\n     * <pre><code> correctedImage(x_i, y_i) = sample_at(x_c, y_c, inputImage)\n     * </code></pre>\n     * <p>The pixel coordinates are defined in a normalized\n     * coordinate system related to the\n     * {@link CameraCharacteristics#LENS_INTRINSIC_CALIBRATION android.lens.intrinsicCalibration} calibration fields.\n     * Both <code>[x_i, y_i]</code> and <code>[x_c, y_c]</code> have <code>(0,0)</code> at the\n     * lens optical center <code>[c_x, c_y]</code>. The maximum magnitudes\n     * of both x and y coordinates are normalized to be 1 at the\n     * edge further from the optical center, so the range\n     * for both dimensions is <code>-1 &lt;= x &lt;= 1</code>.</p>\n     * <p>Finally, <code>r</code> represents the radial distance from the\n     * optical center, <code>r^2 = x_i^2 + y_i^2</code>, and its magnitude\n     * is therefore no larger than <code>|r| &lt;= sqrt(2)</code>.</p>\n     * <p>The distortion model used is the Brown-Conrady model.</p>\n     * <p><b>Units</b>:\n     * Unitless coefficients.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Permission {@link android.Manifest.permission#CAMERA } is needed to access this property</b></p>\n     *\n     * @see CameraCharacteristics#LENS_INTRINSIC_CALIBRATION\n     * @deprecated\n     * <p>This field was inconsistently defined in terms of its\n     * normalization. Use {@link CameraCharacteristics#LENS_DISTORTION android.lens.distortion} instead.</p>\n     *\n     * @see CameraCharacteristics#LENS_DISTORTION\n\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#LENS_DISTORTION", "android.hardware.camera2.CameraCharacteristics#LENS_INTRINSIC_CALIBRATION", "android.Manifest.permission#CAMERA" ]
  }, {
    "name" : "LENS_DISTORTION",
    "type" : "Key<float[]>",
    "comment" : "\n     * <p>The correction coefficients to correct for this camera device's\n     * radial and tangential lens distortion.</p>\n     * <p>Replaces the deprecated {@link CameraCharacteristics#LENS_RADIAL_DISTORTION android.lens.radialDistortion} field, which was\n     * inconsistently defined.</p>\n     * <p>Three radial distortion coefficients <code>[kappa_1, kappa_2,\n     * kappa_3]</code> and two tangential distortion coefficients\n     * <code>[kappa_4, kappa_5]</code> that can be used to correct the\n     * lens's geometric distortion with the mapping equations:</p>\n     * <pre><code> x_c = x_i * ( 1 + kappa_1 * r^2 + kappa_2 * r^4 + kappa_3 * r^6 ) +\n     *        kappa_4 * (2 * x_i * y_i) + kappa_5 * ( r^2 + 2 * x_i^2 )\n     *  y_c = y_i * ( 1 + kappa_1 * r^2 + kappa_2 * r^4 + kappa_3 * r^6 ) +\n     *        kappa_5 * (2 * x_i * y_i) + kappa_4 * ( r^2 + 2 * y_i^2 )\n     * </code></pre>\n     * <p>Here, <code>[x_c, y_c]</code> are the coordinates to sample in the\n     * input image that correspond to the pixel values in the\n     * corrected image at the coordinate <code>[x_i, y_i]</code>:</p>\n     * <pre><code> correctedImage(x_i, y_i) = sample_at(x_c, y_c, inputImage)\n     * </code></pre>\n     * <p>The pixel coordinates are defined in a coordinate system\n     * related to the {@link CameraCharacteristics#LENS_INTRINSIC_CALIBRATION android.lens.intrinsicCalibration}\n     * calibration fields; see that entry for details of the mapping stages.\n     * Both <code>[x_i, y_i]</code> and <code>[x_c, y_c]</code>\n     * have <code>(0,0)</code> at the lens optical center <code>[c_x, c_y]</code>, and\n     * the range of the coordinates depends on the focal length\n     * terms of the intrinsic calibration.</p>\n     * <p>Finally, <code>r</code> represents the radial distance from the\n     * optical center, <code>r^2 = x_i^2 + y_i^2</code>.</p>\n     * <p>The distortion model used is the Brown-Conrady model.</p>\n     * <p><b>Units</b>:\n     * Unitless coefficients.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Permission {@link android.Manifest.permission#CAMERA } is needed to access this property</b></p>\n     *\n     * @see CameraCharacteristics#LENS_INTRINSIC_CALIBRATION\n     * @see CameraCharacteristics#LENS_RADIAL_DISTORTION\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#LENS_RADIAL_DISTORTION", "android.hardware.camera2.CameraCharacteristics#LENS_INTRINSIC_CALIBRATION", "android.Manifest.permission#CAMERA" ]
  }, {
    "name" : "NOISE_REDUCTION_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Mode of operation for the noise reduction algorithm.</p>\n     * <p>The noise reduction algorithm attempts to improve image quality by removing\n     * excessive noise added by the capture process, especially in dark conditions.</p>\n     * <p>OFF means no noise reduction will be applied by the camera device, for both raw and\n     * YUV domain.</p>\n     * <p>MINIMAL means that only sensor raw domain basic noise reduction is enabled ,to remove\n     * demosaicing or other processing artifacts. For YUV_REPROCESSING, MINIMAL is same as OFF.\n     * This mode is optional, may not be support by all devices. The application should check\n     * {@link CameraCharacteristics#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES android.noiseReduction.availableNoiseReductionModes} before using it.</p>\n     * <p>FAST/HIGH_QUALITY both mean camera device determined noise filtering\n     * will be applied. HIGH_QUALITY mode indicates that the camera device\n     * will use the highest-quality noise filtering algorithms,\n     * even if it slows down capture rate. FAST means the camera device will not\n     * slow down capture rate when applying noise filtering. FAST may be the same as MINIMAL if\n     * MINIMAL is listed, or the same as OFF if any noise filtering will slow down capture rate.\n     * Every output stream will have a similar amount of enhancement applied.</p>\n     * <p>ZERO_SHUTTER_LAG is meant to be used by applications that maintain a continuous circular\n     * buffer of high-resolution images during preview and reprocess image(s) from that buffer\n     * into a final capture when triggered by the user. In this mode, the camera device applies\n     * noise reduction to low-resolution streams (below maximum recording resolution) to maximize\n     * preview quality, but does not apply noise reduction to high-resolution streams, since\n     * those will be reprocessed later if necessary.</p>\n     * <p>For YUV_REPROCESSING, these FAST/HIGH_QUALITY modes both mean that the camera device\n     * will apply FAST/HIGH_QUALITY YUV domain noise reduction, respectively. The camera device\n     * may adjust the noise reduction parameters for best image quality based on the\n     * {@link CaptureRequest#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR android.reprocess.effectiveExposureFactor} if it is set.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #NOISE_REDUCTION_MODE_OFF OFF}</li>\n     *   <li>{@link #NOISE_REDUCTION_MODE_FAST FAST}</li>\n     *   <li>{@link #NOISE_REDUCTION_MODE_HIGH_QUALITY HIGH_QUALITY}</li>\n     *   <li>{@link #NOISE_REDUCTION_MODE_MINIMAL MINIMAL}</li>\n     *   <li>{@link #NOISE_REDUCTION_MODE_ZERO_SHUTTER_LAG ZERO_SHUTTER_LAG}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES android.noiseReduction.availableNoiseReductionModes}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES\n     * @see CaptureRequest#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR\n     * @see #NOISE_REDUCTION_MODE_OFF\n     * @see #NOISE_REDUCTION_MODE_FAST\n     * @see #NOISE_REDUCTION_MODE_HIGH_QUALITY\n     * @see #NOISE_REDUCTION_MODE_MINIMAL\n     * @see #NOISE_REDUCTION_MODE_ZERO_SHUTTER_LAG\n     ",
    "links" : [ "#NOISE_REDUCTION_MODE_HIGH_QUALITY", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "#NOISE_REDUCTION_MODE_OFF", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "android.hardware.camera2.CameraCharacteristics#NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES", "#NOISE_REDUCTION_MODE_MINIMAL", "#NOISE_REDUCTION_MODE_ZERO_SHUTTER_LAG", "#NOISE_REDUCTION_MODE_FAST", "android.hardware.camera2.CaptureRequest#REPROCESS_EFFECTIVE_EXPOSURE_FACTOR" ]
  }, {
    "name" : "QUIRKS_PARTIAL_RESULT",
    "type" : "Key<Boolean>",
    "comment" : "\n     * <p>Whether a result given to the framework is the\n     * final one for the capture, or only a partial that contains a\n     * subset of the full set of dynamic metadata\n     * values.</p>\n     * <p>The entries in the result metadata buffers for a\n     * single capture may not overlap, except for this entry. The\n     * FINAL buffers must retain FIFO ordering relative to the\n     * requests that generate them, so the FINAL buffer for frame 3 must\n     * always be sent to the framework after the FINAL buffer for frame 2, and\n     * before the FINAL buffer for frame 4. PARTIAL buffers may be returned\n     * in any order relative to other frames, but all PARTIAL buffers for a given\n     * capture must arrive before the FINAL buffer for that capture. This entry may\n     * only be used by the camera device if quirks.usePartialResult is set to 1.</p>\n     * <p><b>Range of valid values:</b><br>\n     * Optional. Default value is FINAL.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * @deprecated\n     * <p>Not used in HALv3 or newer</p>\n\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_FRAME_COUNT",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>A frame counter set by the framework. This value monotonically\n     * increases with every new result (that is, each new result has a unique\n     * frameCount value).</p>\n     * <p>Reset on release()</p>\n     * <p><b>Units</b>: count of frames</p>\n     * <p><b>Range of valid values:</b><br>\n     * &gt; 0</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * @deprecated\n     * <p>Not used in HALv3 or newer</p>\n\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_ID",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>An application-specified ID for the current\n     * request. Must be maintained unchanged in output\n     * frame</p>\n     * <p><b>Units</b>: arbitrary integer assigned by application</p>\n     * <p><b>Range of valid values:</b><br>\n     * Any int</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REQUEST_PIPELINE_DEPTH",
    "type" : "Key<Byte>",
    "comment" : "\n     * <p>Specifies the number of pipeline stages the frame went\n     * through from when it was exposed to when the final completed result\n     * was available to the framework.</p>\n     * <p>Depending on what settings are used in the request, and\n     * what streams are configured, the data may undergo less processing,\n     * and some pipeline stages skipped.</p>\n     * <p>See {@link CameraCharacteristics#REQUEST_PIPELINE_MAX_DEPTH android.request.pipelineMaxDepth} for more details.</p>\n     * <p><b>Range of valid values:</b><br>\n     * &lt;= {@link CameraCharacteristics#REQUEST_PIPELINE_MAX_DEPTH android.request.pipelineMaxDepth}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CameraCharacteristics#REQUEST_PIPELINE_MAX_DEPTH\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#REQUEST_PIPELINE_MAX_DEPTH" ]
  }, {
    "name" : "SCALER_CROP_REGION",
    "type" : "Key<android.graphics.Rect>",
    "comment" : "\n     * <p>The desired region of the sensor to read out for this capture.</p>\n     * <p>This control can be used to implement digital zoom.</p>\n     * <p>For devices not supporting {@link CaptureRequest#DISTORTION_CORRECTION_MODE android.distortionCorrection.mode} control, the coordinate\n     * system always follows that of {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, with <code>(0, 0)</code> being\n     * the top-left pixel of the active array.</p>\n     * <p>For devices supporting {@link CaptureRequest#DISTORTION_CORRECTION_MODE android.distortionCorrection.mode} control, the coordinate system\n     * depends on the mode being set.  When the distortion correction mode is OFF, the\n     * coordinate system follows {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}, with <code>(0,\n     * 0)</code> being the top-left pixel of the pre-correction active array.  When the distortion\n     * correction mode is not OFF, the coordinate system follows\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, with <code>(0, 0)</code> being the top-left pixel of the\n     * active array.</p>\n     * <p>Output streams use this rectangle to produce their output, cropping to a smaller region\n     * if necessary to maintain the stream's aspect ratio, then scaling the sensor input to\n     * match the output's configured resolution.</p>\n     * <p>The crop region is applied after the RAW to other color space (e.g. YUV)\n     * conversion. Since raw streams (e.g. RAW16) don't have the conversion stage, they are not\n     * croppable. The crop region will be ignored by raw streams.</p>\n     * <p>For non-raw streams, any additional per-stream cropping will be done to maximize the\n     * final pixel area of the stream.</p>\n     * <p>For example, if the crop region is set to a 4:3 aspect ratio, then 4:3 streams will use\n     * the exact crop region. 16:9 streams will further crop vertically (letterbox).</p>\n     * <p>Conversely, if the crop region is set to a 16:9, then 4:3 outputs will crop horizontally\n     * (pillarbox), and 16:9 streams will match exactly. These additional crops will be\n     * centered within the crop region.</p>\n     * <p>To illustrate, here are several scenarios of different crop regions and output streams,\n     * for a hypothetical camera device with an active array of size <code>(2000,1500)</code>.  Note that\n     * several of these examples use non-centered crop regions for ease of illustration; such\n     * regions are only supported on devices with FREEFORM capability\n     * ({@link CameraCharacteristics#SCALER_CROPPING_TYPE android.scaler.croppingType} <code>== FREEFORM</code>), but this does not affect the way the crop\n     * rules work otherwise.</p>\n     * <ul>\n     * <li>Camera Configuration:<ul>\n     * <li>Active array size: <code>2000x1500</code> (3 MP, 4:3 aspect ratio)</li>\n     * <li>Output stream #1: <code>640x480</code> (VGA, 4:3 aspect ratio)</li>\n     * <li>Output stream #2: <code>1280x720</code> (720p, 16:9 aspect ratio)</li>\n     * </ul>\n     * </li>\n     * <li>Case #1: 4:3 crop region with 2x digital zoom<ul>\n     * <li>Crop region: <code>Rect(500, 375, 1500, 1125) // (left, top, right, bottom)</code></li>\n     * <li><img alt=\"4:3 aspect ratio crop diagram\" src=\"/reference/images/camera2/metadata/android.scaler.cropRegion/crop-region-43-ratio.png\" /></li>\n     * <li><code>640x480</code> stream source area: <code>(500, 375, 1500, 1125)</code> (equal to crop region)</li>\n     * <li><code>1280x720</code> stream source area: <code>(500, 469, 1500, 1031)</code> (letterboxed)</li>\n     * </ul>\n     * </li>\n     * <li>Case #2: 16:9 crop region with ~1.5x digital zoom.<ul>\n     * <li>Crop region: <code>Rect(500, 375, 1833, 1125)</code></li>\n     * <li><img alt=\"16:9 aspect ratio crop diagram\" src=\"/reference/images/camera2/metadata/android.scaler.cropRegion/crop-region-169-ratio.png\" /></li>\n     * <li><code>640x480</code> stream source area: <code>(666, 375, 1666, 1125)</code> (pillarboxed)</li>\n     * <li><code>1280x720</code> stream source area: <code>(500, 375, 1833, 1125)</code> (equal to crop region)</li>\n     * </ul>\n     * </li>\n     * <li>Case #3: 1:1 crop region with ~2.6x digital zoom.<ul>\n     * <li>Crop region: <code>Rect(500, 375, 1250, 1125)</code></li>\n     * <li><img alt=\"1:1 aspect ratio crop diagram\" src=\"/reference/images/camera2/metadata/android.scaler.cropRegion/crop-region-11-ratio.png\" /></li>\n     * <li><code>640x480</code> stream source area: <code>(500, 469, 1250, 1031)</code> (letterboxed)</li>\n     * <li><code>1280x720</code> stream source area: <code>(500, 543, 1250, 957)</code> (letterboxed)</li>\n     * </ul>\n     * </li>\n     * <li>Case #4: Replace <code>640x480</code> stream with <code>1024x1024</code> stream, with 4:3 crop region:<ul>\n     * <li>Crop region: <code>Rect(500, 375, 1500, 1125)</code></li>\n     * <li><img alt=\"Square output, 4:3 aspect ratio crop diagram\" src=\"/reference/images/camera2/metadata/android.scaler.cropRegion/crop-region-43-square-ratio.png\" /></li>\n     * <li><code>1024x1024</code> stream source area: <code>(625, 375, 1375, 1125)</code> (pillarboxed)</li>\n     * <li><code>1280x720</code> stream source area: <code>(500, 469, 1500, 1031)</code> (letterboxed)</li>\n     * <li>Note that in this case, neither of the two outputs is a subset of the other, with\n     *   each containing image data the other doesn't have.</li>\n     * </ul>\n     * </li>\n     * </ul>\n     * <p>If the coordinate system is {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, the width and height\n     * of the crop region cannot be set to be smaller than\n     * <code>floor( activeArraySize.width / {@link CameraCharacteristics#SCALER_AVAILABLE_MAX_DIGITAL_ZOOM android.scaler.availableMaxDigitalZoom} )</code> and\n     * <code>floor( activeArraySize.height / {@link CameraCharacteristics#SCALER_AVAILABLE_MAX_DIGITAL_ZOOM android.scaler.availableMaxDigitalZoom} )</code>, respectively.</p>\n     * <p>If the coordinate system is {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}, the width\n     * and height of the crop region cannot be set to be smaller than\n     * <code>floor( preCorrectionActiveArraySize.width / {@link CameraCharacteristics#SCALER_AVAILABLE_MAX_DIGITAL_ZOOM android.scaler.availableMaxDigitalZoom} )</code>\n     * and\n     * <code>floor( preCorrectionActiveArraySize.height / {@link CameraCharacteristics#SCALER_AVAILABLE_MAX_DIGITAL_ZOOM android.scaler.availableMaxDigitalZoom} )</code>,\n     * respectively.</p>\n     * <p>The camera device may adjust the crop region to account for rounding and other hardware\n     * requirements; the final crop region used will be included in the output capture result.</p>\n     * <p>Starting from API level 30, it's strongly recommended to use {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio}\n     * to take advantage of better support for zoom with logical multi-camera. The benefits\n     * include better precision with optical-digital zoom combination, and ability to do\n     * zoom-out from 1.0x. When using {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} for zoom, the crop region in\n     * the capture request must be either letterboxing or pillarboxing (but not both). The\n     * coordinate system is post-zoom, meaning that the activeArraySize or\n     * preCorrectionActiveArraySize covers the camera device's field of view \"after\" zoom.  See\n     * {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} for details.</p>\n     * <p><b>Units</b>: Pixel coordinates relative to\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize} or\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize} depending on distortion correction\n     * capability and mode</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_ZOOM_RATIO\n     * @see CaptureRequest#DISTORTION_CORRECTION_MODE\n     * @see CameraCharacteristics#SCALER_AVAILABLE_MAX_DIGITAL_ZOOM\n     * @see CameraCharacteristics#SCALER_CROPPING_TYPE\n     * @see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE\n     * @see CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#DISTORTION_CORRECTION_MODE", "android.hardware.camera2.CameraCharacteristics#SCALER_AVAILABLE_MAX_DIGITAL_ZOOM", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE", "android.hardware.camera2.CameraCharacteristics#SCALER_CROPPING_TYPE", "android.hardware.camera2.CaptureRequest#CONTROL_ZOOM_RATIO" ]
  }, {
    "name" : "SCALER_ROTATE_AND_CROP",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Whether a rotation-and-crop operation is applied to processed\n     * outputs from the camera.</p>\n     * <p>This control is primarily intended to help camera applications with no support for\n     * multi-window modes to work correctly on devices where multi-window scenarios are\n     * unavoidable, such as foldables or other devices with variable display geometry or more\n     * free-form window placement (such as laptops, which often place portrait-orientation apps\n     * in landscape with pillarboxing).</p>\n     * <p>If supported, the default value is <code>ROTATE_AND_CROP_AUTO</code>, which allows the camera API\n     * to enable backwards-compatibility support for applications that do not support resizing\n     * / multi-window modes, when the device is in fact in a multi-window mode (such as inset\n     * portrait on laptops, or on a foldable device in some fold states).  In addition,\n     * <code>ROTATE_AND_CROP_NONE</code> and <code>ROTATE_AND_CROP_90</code> will always be available if this control\n     * is supported by the device.  If not supported, devices API level 30 or higher will always\n     * list only <code>ROTATE_AND_CROP_NONE</code>.</p>\n     * <p>When <code>CROP_AUTO</code> is in use, and the camera API activates backward-compatibility mode,\n     * several metadata fields will also be parsed differently to ensure that coordinates are\n     * correctly handled for features like drawing face detection boxes or passing in\n     * tap-to-focus coordinates.  The camera API will convert positions in the active array\n     * coordinate system to/from the cropped-and-rotated coordinate system to make the\n     * operation transparent for applications.  The following controls are affected:</p>\n     * <ul>\n     * <li>{@link CaptureRequest#CONTROL_AE_REGIONS android.control.aeRegions}</li>\n     * <li>{@link CaptureRequest#CONTROL_AF_REGIONS android.control.afRegions}</li>\n     * <li>{@link CaptureRequest#CONTROL_AWB_REGIONS android.control.awbRegions}</li>\n     * <li>{@link CaptureResult#STATISTICS_FACES android.statistics.faces}</li>\n     * </ul>\n     * <p>Capture results will contain the actual value selected by the API;\n     * <code>ROTATE_AND_CROP_AUTO</code> will never be seen in a capture result.</p>\n     * <p>Applications can also select their preferred cropping mode, either to opt out of the\n     * backwards-compatibility treatment, or to use the cropping feature themselves as needed.\n     * In this case, no coordinate translation will be done automatically, and all controls\n     * will continue to use the normal active array coordinates.</p>\n     * <p>Cropping and rotating is done after the application of digital zoom (via either\n     * {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion} or {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio}), but before each individual\n     * output is further cropped and scaled. It only affects processed outputs such as\n     * YUV, PRIVATE, and JPEG.  It has no effect on RAW outputs.</p>\n     * <p>When <code>CROP_90</code> or <code>CROP_270</code> are selected, there is a significant loss to the field of\n     * view. For example, with a 4:3 aspect ratio output of 1600x1200, <code>CROP_90</code> will still\n     * produce 1600x1200 output, but these buffers are cropped from a vertical 3:4 slice at the\n     * center of the 4:3 area, then rotated to be 4:3, and then upscaled to 1600x1200.  Only\n     * 56.25% of the original FOV is still visible.  In general, for an aspect ratio of <code>w:h</code>,\n     * the crop and rotate operation leaves <code>(h/w)^2</code> of the field of view visible. For 16:9,\n     * this is ~31.6%.</p>\n     * <p>As a visual example, the figure below shows the effect of <code>ROTATE_AND_CROP_90</code> on the\n     * outputs for the following parameters:</p>\n     * <ul>\n     * <li>Sensor active array: <code>2000x1500</code></li>\n     * <li>Crop region: top-left: <code>(500, 375)</code>, size: <code>(1000, 750)</code> (4:3 aspect ratio)</li>\n     * <li>Output streams: YUV <code>640x480</code> and YUV <code>1280x720</code></li>\n     * <li><code>ROTATE_AND_CROP_90</code></li>\n     * </ul>\n     * <p><img alt=\"Effect of ROTATE_AND_CROP_90\" src=\"/reference/images/camera2/metadata/android.scaler.rotateAndCrop/crop-region-rotate-90-43-ratio.png\" /></p>\n     * <p>With these settings, the regions of the active array covered by the output streams are:</p>\n     * <ul>\n     * <li>640x480 stream crop: top-left: <code>(219, 375)</code>, size: <code>(562, 750)</code></li>\n     * <li>1280x720 stream crop: top-left: <code>(289, 375)</code>, size: <code>(422, 750)</code></li>\n     * </ul>\n     * <p>Since the buffers are rotated, the buffers as seen by the application are:</p>\n     * <ul>\n     * <li>640x480 stream: top-left: <code>(781, 375)</code> on active array, size: <code>(640, 480)</code>, downscaled 1.17x from sensor pixels</li>\n     * <li>1280x720 stream: top-left: <code>(711, 375)</code> on active array, size: <code>(1280, 720)</code>, upscaled 1.71x from sensor pixels</li>\n     * </ul>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #SCALER_ROTATE_AND_CROP_NONE NONE}</li>\n     *   <li>{@link #SCALER_ROTATE_AND_CROP_90 90}</li>\n     *   <li>{@link #SCALER_ROTATE_AND_CROP_180 180}</li>\n     *   <li>{@link #SCALER_ROTATE_AND_CROP_270 270}</li>\n     *   <li>{@link #SCALER_ROTATE_AND_CROP_AUTO AUTO}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * android.scaler.availableRotateAndCropModes</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_REGIONS\n     * @see CaptureRequest#CONTROL_AF_REGIONS\n     * @see CaptureRequest#CONTROL_AWB_REGIONS\n     * @see CaptureRequest#CONTROL_ZOOM_RATIO\n     * @see CaptureRequest#SCALER_CROP_REGION\n     * @see CaptureResult#STATISTICS_FACES\n     * @see #SCALER_ROTATE_AND_CROP_NONE\n     * @see #SCALER_ROTATE_AND_CROP_90\n     * @see #SCALER_ROTATE_AND_CROP_180\n     * @see #SCALER_ROTATE_AND_CROP_270\n     * @see #SCALER_ROTATE_AND_CROP_AUTO\n     * @hide\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#CONTROL_AWB_REGIONS", "android.hardware.camera2.CaptureRequest#SCALER_CROP_REGION", "#SCALER_ROTATE_AND_CROP_90", "#SCALER_ROTATE_AND_CROP_180", "#SCALER_ROTATE_AND_CROP_AUTO", "#SCALER_ROTATE_AND_CROP_NONE", "android.hardware.camera2.CaptureRequest#CONTROL_AE_REGIONS", "android.hardware.camera2.CaptureResult#STATISTICS_FACES", "android.hardware.camera2.CaptureRequest#CONTROL_ZOOM_RATIO", "android.hardware.camera2.CaptureRequest#CONTROL_AF_REGIONS", "#SCALER_ROTATE_AND_CROP_270" ]
  }, {
    "name" : "SENSOR_EXPOSURE_TIME",
    "type" : "Key<Long>",
    "comment" : "\n     * <p>Duration each pixel is exposed to\n     * light.</p>\n     * <p>If the sensor can't expose this exact duration, it will shorten the\n     * duration exposed to the nearest possible value (rather than expose longer).\n     * The final exposure time used will be available in the output capture result.</p>\n     * <p>This control is only effective if {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} or {@link CaptureRequest#CONTROL_MODE android.control.mode} is set to\n     * OFF; otherwise the auto-exposure algorithm will override this value.</p>\n     * <p><b>Units</b>: Nanoseconds</p>\n     * <p><b>Range of valid values:</b><br>\n     * {@link CameraCharacteristics#SENSOR_INFO_EXPOSURE_TIME_RANGE android.sensor.info.exposureTimeRange}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CaptureRequest#CONTROL_MODE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#SENSOR_INFO_EXPOSURE_TIME_RANGE\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CaptureRequest#CONTROL_AE_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_MODE", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_EXPOSURE_TIME_RANGE" ]
  }, {
    "name" : "SENSOR_FRAME_DURATION",
    "type" : "Key<Long>",
    "comment" : "\n     * <p>Duration from start of frame exposure to\n     * start of next frame exposure.</p>\n     * <p>The maximum frame rate that can be supported by a camera subsystem is\n     * a function of many factors:</p>\n     * <ul>\n     * <li>Requested resolutions of output image streams</li>\n     * <li>Availability of binning / skipping modes on the imager</li>\n     * <li>The bandwidth of the imager interface</li>\n     * <li>The bandwidth of the various ISP processing blocks</li>\n     * </ul>\n     * <p>Since these factors can vary greatly between different ISPs and\n     * sensors, the camera abstraction tries to represent the bandwidth\n     * restrictions with as simple a model as possible.</p>\n     * <p>The model presented has the following characteristics:</p>\n     * <ul>\n     * <li>The image sensor is always configured to output the smallest\n     * resolution possible given the application's requested output stream\n     * sizes.  The smallest resolution is defined as being at least as large\n     * as the largest requested output stream size; the camera pipeline must\n     * never digitally upsample sensor data when the crop region covers the\n     * whole sensor. In general, this means that if only small output stream\n     * resolutions are configured, the sensor can provide a higher frame\n     * rate.</li>\n     * <li>Since any request may use any or all the currently configured\n     * output streams, the sensor and ISP must be configured to support\n     * scaling a single capture to all the streams at the same time.  This\n     * means the camera pipeline must be ready to produce the largest\n     * requested output size without any delay.  Therefore, the overall\n     * frame rate of a given configured stream set is governed only by the\n     * largest requested stream resolution.</li>\n     * <li>Using more than one output stream in a request does not affect the\n     * frame duration.</li>\n     * <li>Certain format-streams may need to do additional background processing\n     * before data is consumed/produced by that stream. These processors\n     * can run concurrently to the rest of the camera pipeline, but\n     * cannot process more than 1 capture at a time.</li>\n     * </ul>\n     * <p>The necessary information for the application, given the model above, is provided via\n     * {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputMinFrameDuration }.\n     * These are used to determine the maximum frame rate / minimum frame duration that is\n     * possible for a given stream configuration.</p>\n     * <p>Specifically, the application can use the following rules to\n     * determine the minimum frame duration it can request from the camera\n     * device:</p>\n     * <ol>\n     * <li>Let the set of currently configured input/output streams be called <code>S</code>.</li>\n     * <li>Find the minimum frame durations for each stream in <code>S</code>, by looking it up in {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputMinFrameDuration }\n     * (with its respective size/format). Let this set of frame durations be called <code>F</code>.</li>\n     * <li>For any given request <code>R</code>, the minimum frame duration allowed for <code>R</code> is the maximum\n     * out of all values in <code>F</code>. Let the streams used in <code>R</code> be called <code>S_r</code>.</li>\n     * </ol>\n     * <p>If none of the streams in <code>S_r</code> have a stall time (listed in {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputStallDuration }\n     * using its respective size/format), then the frame duration in <code>F</code> determines the steady\n     * state frame rate that the application will get if it uses <code>R</code> as a repeating request. Let\n     * this special kind of request be called <code>Rsimple</code>.</p>\n     * <p>A repeating request <code>Rsimple</code> can be <em>occasionally</em> interleaved by a single capture of a\n     * new request <code>Rstall</code> (which has at least one in-use stream with a non-0 stall time) and if\n     * <code>Rstall</code> has the same minimum frame duration this will not cause a frame rate loss if all\n     * buffers from the previous <code>Rstall</code> have already been delivered.</p>\n     * <p>For more details about stalling, see {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputStallDuration }.</p>\n     * <p>This control is only effective if {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} or {@link CaptureRequest#CONTROL_MODE android.control.mode} is set to\n     * OFF; otherwise the auto-exposure algorithm will override this value.</p>\n     * <p><b>Units</b>: Nanoseconds</p>\n     * <p><b>Range of valid values:</b><br>\n     * See {@link CameraCharacteristics#SENSOR_INFO_MAX_FRAME_DURATION android.sensor.info.maxFrameDuration}, {@link android.hardware.camera2.params.StreamConfigurationMap }.\n     * The duration is capped to <code>max(duration, exposureTime + overhead)</code>.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CaptureRequest#CONTROL_MODE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#SENSOR_INFO_MAX_FRAME_DURATION\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CaptureRequest#CONTROL_AE_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_MODE", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_MAX_FRAME_DURATION", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "android.hardware.camera2.params.StreamConfigurationMap", "android.hardware.camera2.params.StreamConfigurationMap#getOutputMinFrameDuration", "android.hardware.camera2.params.StreamConfigurationMap#getOutputStallDuration" ]
  }, {
    "name" : "SENSOR_SENSITIVITY",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>The amount of gain applied to sensor data\n     * before processing.</p>\n     * <p>The sensitivity is the standard ISO sensitivity value,\n     * as defined in ISO 12232:2006.</p>\n     * <p>The sensitivity must be within {@link CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE android.sensor.info.sensitivityRange}, and\n     * if if it less than {@link CameraCharacteristics#SENSOR_MAX_ANALOG_SENSITIVITY android.sensor.maxAnalogSensitivity}, the camera device\n     * is guaranteed to use only analog amplification for applying the gain.</p>\n     * <p>If the camera device cannot apply the exact sensitivity\n     * requested, it will reduce the gain to the nearest supported\n     * value. The final sensitivity used will be available in the\n     * output capture result.</p>\n     * <p>This control is only effective if {@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} or {@link CaptureRequest#CONTROL_MODE android.control.mode} is set to\n     * OFF; otherwise the auto-exposure algorithm will override this value.</p>\n     * <p>Note that for devices supporting postRawSensitivityBoost, the total sensitivity applied\n     * to the final processed image is the combination of {@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity} and\n     * {@link CaptureRequest#CONTROL_POST_RAW_SENSITIVITY_BOOST android.control.postRawSensitivityBoost}. In case the application uses the sensor\n     * sensitivity from last capture result of an auto request for a manual request, in order\n     * to achieve the same brightness in the output image, the application should also\n     * set postRawSensitivityBoost.</p>\n     * <p><b>Units</b>: ISO arithmetic units</p>\n     * <p><b>Range of valid values:</b><br>\n     * {@link CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE android.sensor.info.sensitivityRange}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CaptureRequest#CONTROL_MODE\n     * @see CaptureRequest#CONTROL_POST_RAW_SENSITIVITY_BOOST\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE\n     * @see CameraCharacteristics#SENSOR_MAX_ANALOG_SENSITIVITY\n     * @see CaptureRequest#SENSOR_SENSITIVITY\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#SENSOR_SENSITIVITY", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CameraCharacteristics#SENSOR_MAX_ANALOG_SENSITIVITY", "android.hardware.camera2.CaptureRequest#CONTROL_AE_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_MODE", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_SENSITIVITY_RANGE", "android.hardware.camera2.CaptureRequest#CONTROL_POST_RAW_SENSITIVITY_BOOST" ]
  }, {
    "name" : "SENSOR_TIMESTAMP",
    "type" : "Key<Long>",
    "comment" : "\n     * <p>Time at start of exposure of first\n     * row of the image sensor active array, in nanoseconds.</p>\n     * <p>The timestamps are also included in all image\n     * buffers produced for the same capture, and will be identical\n     * on all the outputs.</p>\n     * <p>When {@link CameraCharacteristics#SENSOR_INFO_TIMESTAMP_SOURCE android.sensor.info.timestampSource} <code>==</code> UNKNOWN,\n     * the timestamps measure time since an unspecified starting point,\n     * and are monotonically increasing. They can be compared with the\n     * timestamps for other captures from the same camera device, but are\n     * not guaranteed to be comparable to any other time source.</p>\n     * <p>When {@link CameraCharacteristics#SENSOR_INFO_TIMESTAMP_SOURCE android.sensor.info.timestampSource} <code>==</code> REALTIME, the\n     * timestamps measure time in the same timebase as {@link android.os.SystemClock#elapsedRealtimeNanos }, and they can\n     * be compared to other timestamps from other subsystems that\n     * are using that base.</p>\n     * <p>For reprocessing, the timestamp will match the start of exposure of\n     * the input image, i.e. {@link CaptureResult#SENSOR_TIMESTAMP the\n     * timestamp} in the TotalCaptureResult that was used to create the\n     * reprocess capture request.</p>\n     * <p><b>Units</b>: Nanoseconds</p>\n     * <p><b>Range of valid values:</b><br>\n     * &gt; 0</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CameraCharacteristics#SENSOR_INFO_TIMESTAMP_SOURCE\n     ",
    "links" : [ "android.os.SystemClock#elapsedRealtimeNanos", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_TIMESTAMP_SOURCE", "android.hardware.camera2.CaptureResult#SENSOR_TIMESTAMP" ]
  }, {
    "name" : "SENSOR_NEUTRAL_COLOR_POINT",
    "type" : "Key<Rational[]>",
    "comment" : "\n     * <p>The estimated camera neutral color in the native sensor colorspace at\n     * the time of capture.</p>\n     * <p>This value gives the neutral color point encoded as an RGB value in the\n     * native sensor color space.  The neutral color point indicates the\n     * currently estimated white point of the scene illumination.  It can be\n     * used to interpolate between the provided color transforms when\n     * processing raw sensor data.</p>\n     * <p>The order of the values is R, G, B; where R is in the lowest index.</p>\n     * <p>Starting from Android Q, this key will not be present for a MONOCHROME camera, even if\n     * the camera device has RAW capability.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_NOISE_PROFILE",
    "type" : "Key<android.util.Pair<Double, Double>[]>",
    "comment" : "\n     * <p>Noise model coefficients for each CFA mosaic channel.</p>\n     * <p>This key contains two noise model coefficients for each CFA channel\n     * corresponding to the sensor amplification (S) and sensor readout\n     * noise (O).  These are given as pairs of coefficients for each channel\n     * in the same order as channels listed for the CFA layout key\n     * (see {@link CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT android.sensor.info.colorFilterArrangement}).  This is\n     * represented as an array of Pair&lt;Double, Double&gt;, where\n     * the first member of the Pair at index n is the S coefficient and the\n     * second member is the O coefficient for the nth color channel in the CFA.</p>\n     * <p>These coefficients are used in a two parameter noise model to describe\n     * the amount of noise present in the image for each CFA channel.  The\n     * noise model used here is:</p>\n     * <p>N(x) = sqrt(Sx + O)</p>\n     * <p>Where x represents the recorded signal of a CFA channel normalized to\n     * the range [0, 1], and S and O are the noise model coeffiecients for\n     * that channel.</p>\n     * <p>A more detailed description of the noise model can be found in the\n     * Adobe DNG specification for the NoiseProfile tag.</p>\n     * <p>For a MONOCHROME camera, there is only one color channel. So the noise model coefficients\n     * will only contain one S and one O.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT" ]
  }, {
    "name" : "SENSOR_GREEN_SPLIT",
    "type" : "Key<Float>",
    "comment" : "\n     * <p>The worst-case divergence between Bayer green channels.</p>\n     * <p>This value is an estimate of the worst case split between the\n     * Bayer green channels in the red and blue rows in the sensor color\n     * filter array.</p>\n     * <p>The green split is calculated as follows:</p>\n     * <ol>\n     * <li>A 5x5 pixel (or larger) window W within the active sensor array is\n     * chosen. The term 'pixel' here is taken to mean a group of 4 Bayer\n     * mosaic channels (R, Gr, Gb, B).  The location and size of the window\n     * chosen is implementation defined, and should be chosen to provide a\n     * green split estimate that is both representative of the entire image\n     * for this camera sensor, and can be calculated quickly.</li>\n     * <li>The arithmetic mean of the green channels from the red\n     * rows (mean_Gr) within W is computed.</li>\n     * <li>The arithmetic mean of the green channels from the blue\n     * rows (mean_Gb) within W is computed.</li>\n     * <li>The maximum ratio R of the two means is computed as follows:\n     * <code>R = max((mean_Gr + 1)/(mean_Gb + 1), (mean_Gb + 1)/(mean_Gr + 1))</code></li>\n     * </ol>\n     * <p>The ratio R is the green split divergence reported for this property,\n     * which represents how much the green channels differ in the mosaic\n     * pattern.  This value is typically used to determine the treatment of\n     * the green mosaic channels when demosaicing.</p>\n     * <p>The green split value can be roughly interpreted as follows:</p>\n     * <ul>\n     * <li>R &lt; 1.03 is a negligible split (&lt;3% divergence).</li>\n     * <li>1.20 &lt;= R &gt;= 1.03 will require some software\n     * correction to avoid demosaic errors (3-20% divergence).</li>\n     * <li>R &gt; 1.20 will require strong software correction to produce\n     * a usuable image (&gt;20% divergence).</li>\n     * </ul>\n     * <p>Starting from Android Q, this key will not be present for a MONOCHROME camera, even if\n     * the camera device has RAW capability.</p>\n     * <p><b>Range of valid values:</b><br></p>\n     * <p>&gt;= 0</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     ",
    "links" : [ ]
  }, {
    "name" : "SENSOR_TEST_PATTERN_DATA",
    "type" : "Key<int[]>",
    "comment" : "\n     * <p>A pixel <code>[R, G_even, G_odd, B]</code> that supplies the test pattern\n     * when {@link CaptureRequest#SENSOR_TEST_PATTERN_MODE android.sensor.testPatternMode} is SOLID_COLOR.</p>\n     * <p>Each color channel is treated as an unsigned 32-bit integer.\n     * The camera device then uses the most significant X bits\n     * that correspond to how many bits are in its Bayer raw sensor\n     * output.</p>\n     * <p>For example, a sensor with RAW10 Bayer output would use the\n     * 10 most significant bits from each color channel.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CaptureRequest#SENSOR_TEST_PATTERN_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#SENSOR_TEST_PATTERN_MODE" ]
  }, {
    "name" : "SENSOR_TEST_PATTERN_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>When enabled, the sensor sends a test pattern instead of\n     * doing a real exposure from the camera.</p>\n     * <p>When a test pattern is enabled, all manual sensor controls specified\n     * by android.sensor.* will be ignored. All other controls should\n     * work as normal.</p>\n     * <p>For example, if manual flash is enabled, flash firing should still\n     * occur (and that the test pattern remain unmodified, since the flash\n     * would not actually affect it).</p>\n     * <p>Defaults to OFF.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #SENSOR_TEST_PATTERN_MODE_OFF OFF}</li>\n     *   <li>{@link #SENSOR_TEST_PATTERN_MODE_SOLID_COLOR SOLID_COLOR}</li>\n     *   <li>{@link #SENSOR_TEST_PATTERN_MODE_COLOR_BARS COLOR_BARS}</li>\n     *   <li>{@link #SENSOR_TEST_PATTERN_MODE_COLOR_BARS_FADE_TO_GRAY COLOR_BARS_FADE_TO_GRAY}</li>\n     *   <li>{@link #SENSOR_TEST_PATTERN_MODE_PN9 PN9}</li>\n     *   <li>{@link #SENSOR_TEST_PATTERN_MODE_CUSTOM1 CUSTOM1}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#SENSOR_AVAILABLE_TEST_PATTERN_MODES android.sensor.availableTestPatternModes}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CameraCharacteristics#SENSOR_AVAILABLE_TEST_PATTERN_MODES\n     * @see #SENSOR_TEST_PATTERN_MODE_OFF\n     * @see #SENSOR_TEST_PATTERN_MODE_SOLID_COLOR\n     * @see #SENSOR_TEST_PATTERN_MODE_COLOR_BARS\n     * @see #SENSOR_TEST_PATTERN_MODE_COLOR_BARS_FADE_TO_GRAY\n     * @see #SENSOR_TEST_PATTERN_MODE_PN9\n     * @see #SENSOR_TEST_PATTERN_MODE_CUSTOM1\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#SENSOR_AVAILABLE_TEST_PATTERN_MODES", "#SENSOR_TEST_PATTERN_MODE_OFF", "#SENSOR_TEST_PATTERN_MODE_COLOR_BARS_FADE_TO_GRAY", "#SENSOR_TEST_PATTERN_MODE_PN9", "#SENSOR_TEST_PATTERN_MODE_CUSTOM1", "#SENSOR_TEST_PATTERN_MODE_SOLID_COLOR", "#SENSOR_TEST_PATTERN_MODE_COLOR_BARS" ]
  }, {
    "name" : "SENSOR_ROLLING_SHUTTER_SKEW",
    "type" : "Key<Long>",
    "comment" : "\n     * <p>Duration between the start of exposure for the first row of the image sensor,\n     * and the start of exposure for one past the last row of the image sensor.</p>\n     * <p>This is the exposure time skew between the first and <code>(last+1)</code> row exposure start times. The\n     * first row and the last row are the first and last rows inside of the\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.</p>\n     * <p>For typical camera sensors that use rolling shutters, this is also equivalent to the frame\n     * readout time.</p>\n     * <p>If the image sensor is operating in a binned or cropped mode due to the current output\n     * target resolutions, it's possible this skew is reported to be larger than the exposure\n     * time, for example, since it is based on the full array even if a partial array is read\n     * out. Be sure to scale the number to cover the section of the sensor actually being used\n     * for the outputs you care about. So if your output covers N rows of the active array of\n     * height H, scale this value by N/H to get the total skew for that viewport.</p>\n     * <p><em>Note:</em> Prior to Android 11, this field was described as measuring duration from\n     * first to last row of the image sensor, which is not equal to the frame readout time for a\n     * rolling shutter sensor. Implementations generally reported the latter value, so to resolve\n     * the inconsistency, the description has been updated to range from (first, last+1) row\n     * exposure start, instead.</p>\n     * <p><b>Units</b>: Nanoseconds</p>\n     * <p><b>Range of valid values:</b><br>\n     * &gt;= 0 and &lt;\n     * {@link android.hardware.camera2.params.StreamConfigurationMap#getOutputMinFrameDuration }.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Limited capability</b> -\n     * Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.params.StreamConfigurationMap#getOutputMinFrameDuration", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED" ]
  }, {
    "name" : "SENSOR_DYNAMIC_BLACK_LEVEL",
    "type" : "Key<float[]>",
    "comment" : "\n     * <p>A per-frame dynamic black level offset for each of the color filter\n     * arrangement (CFA) mosaic channels.</p>\n     * <p>Camera sensor black levels may vary dramatically for different\n     * capture settings (e.g. {@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}). The fixed black\n     * level reported by {@link CameraCharacteristics#SENSOR_BLACK_LEVEL_PATTERN android.sensor.blackLevelPattern} may be too\n     * inaccurate to represent the actual value on a per-frame basis. The\n     * camera device internal pipeline relies on reliable black level values\n     * to process the raw images appropriately. To get the best image\n     * quality, the camera device may choose to estimate the per frame black\n     * level values either based on optically shielded black regions\n     * ({@link CameraCharacteristics#SENSOR_OPTICAL_BLACK_REGIONS android.sensor.opticalBlackRegions}) or its internal model.</p>\n     * <p>This key reports the camera device estimated per-frame zero light\n     * value for each of the CFA mosaic channels in the camera sensor. The\n     * {@link CameraCharacteristics#SENSOR_BLACK_LEVEL_PATTERN android.sensor.blackLevelPattern} may only represent a coarse\n     * approximation of the actual black level values. This value is the\n     * black level used in camera device internal image processing pipeline\n     * and generally more accurate than the fixed black level values.\n     * However, since they are estimated values by the camera device, they\n     * may not be as accurate as the black level values calculated from the\n     * optical black pixels reported by {@link CameraCharacteristics#SENSOR_OPTICAL_BLACK_REGIONS android.sensor.opticalBlackRegions}.</p>\n     * <p>The values are given in the same order as channels listed for the CFA\n     * layout key (see {@link CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT android.sensor.info.colorFilterArrangement}), i.e. the\n     * nth value given corresponds to the black level offset for the nth\n     * color channel listed in the CFA.</p>\n     * <p>For a MONOCHROME camera, all of the 2x2 channels must have the same values.</p>\n     * <p>This key will be available if {@link CameraCharacteristics#SENSOR_OPTICAL_BLACK_REGIONS android.sensor.opticalBlackRegions} is available or the\n     * camera device advertises this key via {@link android.hardware.camera2.CameraCharacteristics#getAvailableCaptureResultKeys }.</p>\n     * <p><b>Range of valid values:</b><br>\n     * &gt;= 0 for each.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CameraCharacteristics#SENSOR_BLACK_LEVEL_PATTERN\n     * @see CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT\n     * @see CameraCharacteristics#SENSOR_OPTICAL_BLACK_REGIONS\n     * @see CaptureRequest#SENSOR_SENSITIVITY\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#SENSOR_SENSITIVITY", "android.hardware.camera2.CameraCharacteristics#getAvailableCaptureResultKeys", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT", "android.hardware.camera2.CameraCharacteristics#SENSOR_OPTICAL_BLACK_REGIONS", "android.hardware.camera2.CameraCharacteristics#SENSOR_BLACK_LEVEL_PATTERN" ]
  }, {
    "name" : "SENSOR_DYNAMIC_WHITE_LEVEL",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Maximum raw value output by sensor for this frame.</p>\n     * <p>Since the {@link CameraCharacteristics#SENSOR_BLACK_LEVEL_PATTERN android.sensor.blackLevelPattern} may change for different\n     * capture settings (e.g., {@link CaptureRequest#SENSOR_SENSITIVITY android.sensor.sensitivity}), the white\n     * level will change accordingly. This key is similar to\n     * {@link CameraCharacteristics#SENSOR_INFO_WHITE_LEVEL android.sensor.info.whiteLevel}, but specifies the camera device\n     * estimated white level for each frame.</p>\n     * <p>This key will be available if {@link CameraCharacteristics#SENSOR_OPTICAL_BLACK_REGIONS android.sensor.opticalBlackRegions} is\n     * available or the camera device advertises this key via\n     * {@link android.hardware.camera2.CameraCharacteristics#getAvailableCaptureRequestKeys }.</p>\n     * <p><b>Range of valid values:</b><br>\n     * &gt;= 0</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CameraCharacteristics#SENSOR_BLACK_LEVEL_PATTERN\n     * @see CameraCharacteristics#SENSOR_INFO_WHITE_LEVEL\n     * @see CameraCharacteristics#SENSOR_OPTICAL_BLACK_REGIONS\n     * @see CaptureRequest#SENSOR_SENSITIVITY\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#SENSOR_SENSITIVITY", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_WHITE_LEVEL", "android.hardware.camera2.CameraCharacteristics#getAvailableCaptureRequestKeys", "android.hardware.camera2.CameraCharacteristics#SENSOR_OPTICAL_BLACK_REGIONS", "android.hardware.camera2.CameraCharacteristics#SENSOR_BLACK_LEVEL_PATTERN" ]
  }, {
    "name" : "SHADING_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Quality of lens shading correction applied\n     * to the image data.</p>\n     * <p>When set to OFF mode, no lens shading correction will be applied by the\n     * camera device, and an identity lens shading map data will be provided\n     * if <code>{@link CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE android.statistics.lensShadingMapMode} == ON</code>. For example, for lens\n     * shading map with size of <code>[ 4, 3 ]</code>,\n     * the output {@link CaptureResult#STATISTICS_LENS_SHADING_CORRECTION_MAP android.statistics.lensShadingCorrectionMap} for this case will be an identity\n     * map shown below:</p>\n     * <pre><code>[ 1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,\n     *  1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,\n     *  1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,\n     *  1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,\n     *  1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0,\n     *  1.0, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0 ]\n     * </code></pre>\n     * <p>When set to other modes, lens shading correction will be applied by the camera\n     * device. Applications can request lens shading map data by setting\n     * {@link CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE android.statistics.lensShadingMapMode} to ON, and then the camera device will provide lens\n     * shading map data in {@link CaptureResult#STATISTICS_LENS_SHADING_CORRECTION_MAP android.statistics.lensShadingCorrectionMap}; the returned shading map\n     * data will be the one applied by the camera device for this capture request.</p>\n     * <p>The shading map data may depend on the auto-exposure (AE) and AWB statistics, therefore\n     * the reliability of the map data may be affected by the AE and AWB algorithms. When AE and\n     * AWB are in AUTO modes({@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} <code>!=</code> OFF and {@link CaptureRequest#CONTROL_AWB_MODE android.control.awbMode} <code>!=</code>\n     * OFF), to get best results, it is recommended that the applications wait for the AE and AWB\n     * to be converged before using the returned shading map data.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #SHADING_MODE_OFF OFF}</li>\n     *   <li>{@link #SHADING_MODE_FAST FAST}</li>\n     *   <li>{@link #SHADING_MODE_HIGH_QUALITY HIGH_QUALITY}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#SHADING_AVAILABLE_MODES android.shading.availableModes}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CaptureRequest#CONTROL_AWB_MODE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#SHADING_AVAILABLE_MODES\n     * @see CaptureResult#STATISTICS_LENS_SHADING_CORRECTION_MAP\n     * @see CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE\n     * @see #SHADING_MODE_OFF\n     * @see #SHADING_MODE_FAST\n     * @see #SHADING_MODE_HIGH_QUALITY\n     ",
    "links" : [ "#SHADING_MODE_OFF", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CaptureRequest#CONTROL_AE_MODE", "android.hardware.camera2.CameraCharacteristics#SHADING_AVAILABLE_MODES", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "android.hardware.camera2.CaptureResult#STATISTICS_LENS_SHADING_CORRECTION_MAP", "android.hardware.camera2.CaptureRequest#CONTROL_AWB_MODE", "#SHADING_MODE_HIGH_QUALITY", "android.hardware.camera2.CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE", "#SHADING_MODE_FAST" ]
  }, {
    "name" : "STATISTICS_FACE_DETECT_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Operating mode for the face detector\n     * unit.</p>\n     * <p>Whether face detection is enabled, and whether it\n     * should output just the basic fields or the full set of\n     * fields.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #STATISTICS_FACE_DETECT_MODE_OFF OFF}</li>\n     *   <li>{@link #STATISTICS_FACE_DETECT_MODE_SIMPLE SIMPLE}</li>\n     *   <li>{@link #STATISTICS_FACE_DETECT_MODE_FULL FULL}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES android.statistics.info.availableFaceDetectModes}</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CameraCharacteristics#STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES\n     * @see #STATISTICS_FACE_DETECT_MODE_OFF\n     * @see #STATISTICS_FACE_DETECT_MODE_SIMPLE\n     * @see #STATISTICS_FACE_DETECT_MODE_FULL\n     ",
    "links" : [ "#STATISTICS_FACE_DETECT_MODE_FULL", "#STATISTICS_FACE_DETECT_MODE_OFF", "#STATISTICS_FACE_DETECT_MODE_SIMPLE", "android.hardware.camera2.CameraCharacteristics#STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES" ]
  }, {
    "name" : "STATISTICS_FACE_IDS",
    "type" : "Key<int[]>",
    "comment" : "\n     * <p>List of unique IDs for detected faces.</p>\n     * <p>Each detected face is given a unique ID that is valid for as long as the face is visible\n     * to the camera device.  A face that leaves the field of view and later returns may be\n     * assigned a new ID.</p>\n     * <p>Only available if {@link CaptureRequest#STATISTICS_FACE_DETECT_MODE android.statistics.faceDetectMode} == FULL\n     * This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#STATISTICS_FACE_DETECT_MODE\n     * @hide\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#STATISTICS_FACE_DETECT_MODE" ]
  }, {
    "name" : "STATISTICS_FACE_LANDMARKS",
    "type" : "Key<int[]>",
    "comment" : "\n     * <p>List of landmarks for detected\n     * faces.</p>\n     * <p>For devices not supporting {@link CaptureRequest#DISTORTION_CORRECTION_MODE android.distortionCorrection.mode} control, the coordinate\n     * system always follows that of {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, with <code>(0, 0)</code> being\n     * the top-left pixel of the active array.</p>\n     * <p>For devices supporting {@link CaptureRequest#DISTORTION_CORRECTION_MODE android.distortionCorrection.mode} control, the coordinate\n     * system depends on the mode being set.\n     * When the distortion correction mode is OFF, the coordinate system follows\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}, with\n     * <code>(0, 0)</code> being the top-left pixel of the pre-correction active array.\n     * When the distortion correction mode is not OFF, the coordinate system follows\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, with\n     * <code>(0, 0)</code> being the top-left pixel of the active array.</p>\n     * <p>Only available if {@link CaptureRequest#STATISTICS_FACE_DETECT_MODE android.statistics.faceDetectMode} == FULL.</p>\n     * <p>Starting from API level 30, the coordinate system of activeArraySize or\n     * preCorrectionActiveArraySize is used to represent post-zoomRatio field of view, not\n     * pre-zoomRatio field of view. This means that if the relative position of faces and\n     * the camera device doesn't change, when zooming in by increasing\n     * {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio}, the face landmarks move farther away from the center of the\n     * activeArray or preCorrectionActiveArray. If {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} is set to 1.0\n     * (default), the face landmarks coordinates won't change as {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion}\n     * changes. See {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} for details. Whether to use activeArraySize or\n     * preCorrectionActiveArraySize still depends on distortion correction mode.</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_ZOOM_RATIO\n     * @see CaptureRequest#DISTORTION_CORRECTION_MODE\n     * @see CaptureRequest#SCALER_CROP_REGION\n     * @see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE\n     * @see CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE\n     * @see CaptureRequest#STATISTICS_FACE_DETECT_MODE\n     * @hide\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#STATISTICS_FACE_DETECT_MODE", "android.hardware.camera2.CaptureRequest#DISTORTION_CORRECTION_MODE", "android.hardware.camera2.CaptureRequest#SCALER_CROP_REGION", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE", "android.hardware.camera2.CaptureRequest#CONTROL_ZOOM_RATIO" ]
  }, {
    "name" : "STATISTICS_FACE_RECTANGLES",
    "type" : "Key<android.graphics.Rect[]>",
    "comment" : "\n     * <p>List of the bounding rectangles for detected\n     * faces.</p>\n     * <p>For devices not supporting {@link CaptureRequest#DISTORTION_CORRECTION_MODE android.distortionCorrection.mode} control, the coordinate\n     * system always follows that of {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, with <code>(0, 0)</code> being\n     * the top-left pixel of the active array.</p>\n     * <p>For devices supporting {@link CaptureRequest#DISTORTION_CORRECTION_MODE android.distortionCorrection.mode} control, the coordinate\n     * system depends on the mode being set.\n     * When the distortion correction mode is OFF, the coordinate system follows\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}, with\n     * <code>(0, 0)</code> being the top-left pixel of the pre-correction active array.\n     * When the distortion correction mode is not OFF, the coordinate system follows\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}, with\n     * <code>(0, 0)</code> being the top-left pixel of the active array.</p>\n     * <p>Only available if {@link CaptureRequest#STATISTICS_FACE_DETECT_MODE android.statistics.faceDetectMode} != OFF.</p>\n     * <p>Starting from API level 30, the coordinate system of activeArraySize or\n     * preCorrectionActiveArraySize is used to represent post-zoomRatio field of view, not\n     * pre-zoomRatio field of view. This means that if the relative position of faces and\n     * the camera device doesn't change, when zooming in by increasing\n     * {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio}, the face rectangles grow larger and move farther away from\n     * the center of the activeArray or preCorrectionActiveArray. If {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio}\n     * is set to 1.0 (default), the face rectangles won't change as {@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion}\n     * changes. See {@link CaptureRequest#CONTROL_ZOOM_RATIO android.control.zoomRatio} for details. Whether to use activeArraySize or\n     * preCorrectionActiveArraySize still depends on distortion correction mode.</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_ZOOM_RATIO\n     * @see CaptureRequest#DISTORTION_CORRECTION_MODE\n     * @see CaptureRequest#SCALER_CROP_REGION\n     * @see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE\n     * @see CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE\n     * @see CaptureRequest#STATISTICS_FACE_DETECT_MODE\n     * @hide\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#STATISTICS_FACE_DETECT_MODE", "android.hardware.camera2.CaptureRequest#DISTORTION_CORRECTION_MODE", "android.hardware.camera2.CaptureRequest#SCALER_CROP_REGION", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE", "android.hardware.camera2.CaptureRequest#CONTROL_ZOOM_RATIO" ]
  }, {
    "name" : "STATISTICS_FACE_SCORES",
    "type" : "Key<byte[]>",
    "comment" : "\n     * <p>List of the face confidence scores for\n     * detected faces</p>\n     * <p>Only available if {@link CaptureRequest#STATISTICS_FACE_DETECT_MODE android.statistics.faceDetectMode} != OFF.</p>\n     * <p><b>Range of valid values:</b><br>\n     * 1-100</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#STATISTICS_FACE_DETECT_MODE\n     * @hide\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#STATISTICS_FACE_DETECT_MODE" ]
  }, {
    "name" : "STATISTICS_FACES",
    "type" : "Key<android.hardware.camera2.params.Face[]>",
    "comment" : "\n     * <p>List of the faces detected through camera face detection\n     * in this capture.</p>\n     * <p>Only available if {@link CaptureRequest#STATISTICS_FACE_DETECT_MODE android.statistics.faceDetectMode} <code>!=</code> OFF.</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CaptureRequest#STATISTICS_FACE_DETECT_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#STATISTICS_FACE_DETECT_MODE" ]
  }, {
    "name" : "STATISTICS_LENS_SHADING_CORRECTION_MAP",
    "type" : "Key<android.hardware.camera2.params.LensShadingMap>",
    "comment" : "\n     * <p>The shading map is a low-resolution floating-point map\n     * that lists the coefficients used to correct for vignetting, for each\n     * Bayer color channel.</p>\n     * <p>The map provided here is the same map that is used by the camera device to\n     * correct both color shading and vignetting for output non-RAW images.</p>\n     * <p>When there is no lens shading correction applied to RAW\n     * output images ({@link CameraCharacteristics#SENSOR_INFO_LENS_SHADING_APPLIED android.sensor.info.lensShadingApplied} <code>==</code>\n     * false), this map is the complete lens shading correction\n     * map; when there is some lens shading correction applied to\n     * the RAW output image ({@link CameraCharacteristics#SENSOR_INFO_LENS_SHADING_APPLIED android.sensor.info.lensShadingApplied}<code>==</code> true), this map reports the remaining lens shading\n     * correction map that needs to be applied to get shading\n     * corrected images that match the camera device's output for\n     * non-RAW formats.</p>\n     * <p>For a complete shading correction map, the least shaded\n     * section of the image will have a gain factor of 1; all\n     * other sections will have gains above 1.</p>\n     * <p>When {@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode} = TRANSFORM_MATRIX, the map\n     * will take into account the colorCorrection settings.</p>\n     * <p>The shading map is for the entire active pixel array, and is not\n     * affected by the crop region specified in the request. Each shading map\n     * entry is the value of the shading compensation map over a specific\n     * pixel on the sensor.  Specifically, with a (N x M) resolution shading\n     * map, and an active pixel array size (W x H), shading map entry\n     * (x,y) ϵ (0 ... N-1, 0 ... M-1) is the value of the shading map at\n     * pixel ( ((W-1)/(N-1)) * x, ((H-1)/(M-1)) * y) for the four color channels.\n     * The map is assumed to be bilinearly interpolated between the sample points.</p>\n     * <p>The channel order is [R, Geven, Godd, B], where Geven is the green\n     * channel for the even rows of a Bayer pattern, and Godd is the odd rows.\n     * The shading map is stored in a fully interleaved format.</p>\n     * <p>The shading map will generally have on the order of 30-40 rows and columns,\n     * and will be smaller than 64x64.</p>\n     * <p>As an example, given a very small map defined as:</p>\n     * <pre><code>width,height = [ 4, 3 ]\n     * values =\n     * [ 1.3, 1.2, 1.15, 1.2,  1.2, 1.2, 1.15, 1.2,\n     *     1.1, 1.2, 1.2, 1.2,  1.3, 1.2, 1.3, 1.3,\n     *   1.2, 1.2, 1.25, 1.1,  1.1, 1.1, 1.1, 1.0,\n     *     1.0, 1.0, 1.0, 1.0,  1.2, 1.3, 1.25, 1.2,\n     *   1.3, 1.2, 1.2, 1.3,   1.2, 1.15, 1.1, 1.2,\n     *     1.2, 1.1, 1.0, 1.2,  1.3, 1.15, 1.2, 1.3 ]\n     * </code></pre>\n     * <p>The low-resolution scaling map images for each channel are\n     * (displayed using nearest-neighbor interpolation):</p>\n     * <p><img alt=\"Red lens shading map\" src=\"/reference/images/camera2/metadata/android.statistics.lensShadingMap/red_shading.png\" />\n     * <img alt=\"Green (even rows) lens shading map\" src=\"/reference/images/camera2/metadata/android.statistics.lensShadingMap/green_e_shading.png\" />\n     * <img alt=\"Green (odd rows) lens shading map\" src=\"/reference/images/camera2/metadata/android.statistics.lensShadingMap/green_o_shading.png\" />\n     * <img alt=\"Blue lens shading map\" src=\"/reference/images/camera2/metadata/android.statistics.lensShadingMap/blue_shading.png\" /></p>\n     * <p>As a visualization only, inverting the full-color map to recover an\n     * image of a gray wall (using bicubic interpolation for visual quality) as captured by the sensor gives:</p>\n     * <p><img alt=\"Image of a uniform white wall (inverse shading map)\" src=\"/reference/images/camera2/metadata/android.statistics.lensShadingMap/inv_shading.png\" /></p>\n     * <p>For a MONOCHROME camera, all of the 2x2 channels must have the same values. An example\n     * shading map for such a camera is defined as:</p>\n     * <pre><code>android.lens.info.shadingMapSize = [ 4, 3 ]\n     * android.statistics.lensShadingMap =\n     * [ 1.3, 1.3, 1.3, 1.3,  1.2, 1.2, 1.2, 1.2,\n     *     1.1, 1.1, 1.1, 1.1,  1.3, 1.3, 1.3, 1.3,\n     *   1.2, 1.2, 1.2, 1.2,  1.1, 1.1, 1.1, 1.1,\n     *     1.0, 1.0, 1.0, 1.0,  1.2, 1.2, 1.2, 1.2,\n     *   1.3, 1.3, 1.3, 1.3,   1.2, 1.2, 1.2, 1.2,\n     *     1.2, 1.2, 1.2, 1.2,  1.3, 1.3, 1.3, 1.3 ]\n     * </code></pre>\n     * <p><b>Range of valid values:</b><br>\n     * Each gain factor is &gt;= 1</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#COLOR_CORRECTION_MODE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#SENSOR_INFO_LENS_SHADING_APPLIED\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_MODE", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_LENS_SHADING_APPLIED", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL" ]
  }, {
    "name" : "STATISTICS_LENS_SHADING_MAP",
    "type" : "Key<float[]>",
    "comment" : "\n     * <p>The shading map is a low-resolution floating-point map\n     * that lists the coefficients used to correct for vignetting and color shading,\n     * for each Bayer color channel of RAW image data.</p>\n     * <p>The map provided here is the same map that is used by the camera device to\n     * correct both color shading and vignetting for output non-RAW images.</p>\n     * <p>When there is no lens shading correction applied to RAW\n     * output images ({@link CameraCharacteristics#SENSOR_INFO_LENS_SHADING_APPLIED android.sensor.info.lensShadingApplied} <code>==</code>\n     * false), this map is the complete lens shading correction\n     * map; when there is some lens shading correction applied to\n     * the RAW output image ({@link CameraCharacteristics#SENSOR_INFO_LENS_SHADING_APPLIED android.sensor.info.lensShadingApplied}<code>==</code> true), this map reports the remaining lens shading\n     * correction map that needs to be applied to get shading\n     * corrected images that match the camera device's output for\n     * non-RAW formats.</p>\n     * <p>For a complete shading correction map, the least shaded\n     * section of the image will have a gain factor of 1; all\n     * other sections will have gains above 1.</p>\n     * <p>When {@link CaptureRequest#COLOR_CORRECTION_MODE android.colorCorrection.mode} = TRANSFORM_MATRIX, the map\n     * will take into account the colorCorrection settings.</p>\n     * <p>The shading map is for the entire active pixel array, and is not\n     * affected by the crop region specified in the request. Each shading map\n     * entry is the value of the shading compensation map over a specific\n     * pixel on the sensor.  Specifically, with a (N x M) resolution shading\n     * map, and an active pixel array size (W x H), shading map entry\n     * (x,y) ϵ (0 ... N-1, 0 ... M-1) is the value of the shading map at\n     * pixel ( ((W-1)/(N-1)) * x, ((H-1)/(M-1)) * y) for the four color channels.\n     * The map is assumed to be bilinearly interpolated between the sample points.</p>\n     * <p>For a Bayer camera, the channel order is [R, Geven, Godd, B], where Geven is\n     * the green channel for the even rows of a Bayer pattern, and Godd is the odd rows.\n     * The shading map is stored in a fully interleaved format, and its size\n     * is provided in the camera static metadata by android.lens.info.shadingMapSize.</p>\n     * <p>The shading map will generally have on the order of 30-40 rows and columns,\n     * and will be smaller than 64x64.</p>\n     * <p>As an example, given a very small map for a Bayer camera defined as:</p>\n     * <pre><code>android.lens.info.shadingMapSize = [ 4, 3 ]\n     * android.statistics.lensShadingMap =\n     * [ 1.3, 1.2, 1.15, 1.2,  1.2, 1.2, 1.15, 1.2,\n     *     1.1, 1.2, 1.2, 1.2,  1.3, 1.2, 1.3, 1.3,\n     *   1.2, 1.2, 1.25, 1.1,  1.1, 1.1, 1.1, 1.0,\n     *     1.0, 1.0, 1.0, 1.0,  1.2, 1.3, 1.25, 1.2,\n     *   1.3, 1.2, 1.2, 1.3,   1.2, 1.15, 1.1, 1.2,\n     *     1.2, 1.1, 1.0, 1.2,  1.3, 1.15, 1.2, 1.3 ]\n     * </code></pre>\n     * <p>The low-resolution scaling map images for each channel are\n     * (displayed using nearest-neighbor interpolation):</p>\n     * <p><img alt=\"Red lens shading map\" src=\"/reference/images/camera2/metadata/android.statistics.lensShadingMap/red_shading.png\" />\n     * <img alt=\"Green (even rows) lens shading map\" src=\"/reference/images/camera2/metadata/android.statistics.lensShadingMap/green_e_shading.png\" />\n     * <img alt=\"Green (odd rows) lens shading map\" src=\"/reference/images/camera2/metadata/android.statistics.lensShadingMap/green_o_shading.png\" />\n     * <img alt=\"Blue lens shading map\" src=\"/reference/images/camera2/metadata/android.statistics.lensShadingMap/blue_shading.png\" /></p>\n     * <p>As a visualization only, inverting the full-color map to recover an\n     * image of a gray wall (using bicubic interpolation for visual quality)\n     * as captured by the sensor gives:</p>\n     * <p><img alt=\"Image of a uniform white wall (inverse shading map)\" src=\"/reference/images/camera2/metadata/android.statistics.lensShadingMap/inv_shading.png\" /></p>\n     * <p>For a MONOCHROME camera, all of the 2x2 channels must have the same values. An example\n     * shading map for such a camera is defined as:</p>\n     * <pre><code>android.lens.info.shadingMapSize = [ 4, 3 ]\n     * android.statistics.lensShadingMap =\n     * [ 1.3, 1.3, 1.3, 1.3,  1.2, 1.2, 1.2, 1.2,\n     *     1.1, 1.1, 1.1, 1.1,  1.3, 1.3, 1.3, 1.3,\n     *   1.2, 1.2, 1.2, 1.2,  1.1, 1.1, 1.1, 1.1,\n     *     1.0, 1.0, 1.0, 1.0,  1.2, 1.2, 1.2, 1.2,\n     *   1.3, 1.3, 1.3, 1.3,   1.2, 1.2, 1.2, 1.2,\n     *     1.2, 1.2, 1.2, 1.2,  1.3, 1.3, 1.3, 1.3 ]\n     * </code></pre>\n     * <p>Note that the RAW image data might be subject to lens shading\n     * correction not reported on this map. Query\n     * {@link CameraCharacteristics#SENSOR_INFO_LENS_SHADING_APPLIED android.sensor.info.lensShadingApplied} to see if RAW image data has subject\n     * to lens shading correction. If {@link CameraCharacteristics#SENSOR_INFO_LENS_SHADING_APPLIED android.sensor.info.lensShadingApplied}\n     * is TRUE, the RAW image data is subject to partial or full lens shading\n     * correction. In the case full lens shading correction is applied to RAW\n     * images, the gain factor map reported in this key will contain all 1.0 gains.\n     * In other words, the map reported in this key is the remaining lens shading\n     * that needs to be applied on the RAW image to get images without lens shading\n     * artifacts. See {@link CameraCharacteristics#REQUEST_MAX_NUM_OUTPUT_RAW android.request.maxNumOutputRaw} for a list of RAW image\n     * formats.</p>\n     * <p><b>Range of valid values:</b><br>\n     * Each gain factor is &gt;= 1</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#COLOR_CORRECTION_MODE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#REQUEST_MAX_NUM_OUTPUT_RAW\n     * @see CameraCharacteristics#SENSOR_INFO_LENS_SHADING_APPLIED\n     * @hide\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_MODE", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_LENS_SHADING_APPLIED", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "android.hardware.camera2.CameraCharacteristics#REQUEST_MAX_NUM_OUTPUT_RAW" ]
  }, {
    "name" : "STATISTICS_PREDICTED_COLOR_GAINS",
    "type" : "Key<float[]>",
    "comment" : "\n     * <p>The best-fit color channel gains calculated\n     * by the camera device's statistics units for the current output frame.</p>\n     * <p>This may be different than the gains used for this frame,\n     * since statistics processing on data from a new frame\n     * typically completes after the transform has already been\n     * applied to that frame.</p>\n     * <p>The 4 channel gains are defined in Bayer domain,\n     * see {@link CaptureRequest#COLOR_CORRECTION_GAINS android.colorCorrection.gains} for details.</p>\n     * <p>This value should always be calculated by the auto-white balance (AWB) block,\n     * regardless of the android.control.* current values.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CaptureRequest#COLOR_CORRECTION_GAINS\n     * @deprecated\n     * <p>Never fully implemented or specified; do not use</p>\n\n     * @hide\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#COLOR_CORRECTION_GAINS" ]
  }, {
    "name" : "STATISTICS_PREDICTED_COLOR_TRANSFORM",
    "type" : "Key<Rational[]>",
    "comment" : "\n     * <p>The best-fit color transform matrix estimate\n     * calculated by the camera device's statistics units for the current\n     * output frame.</p>\n     * <p>The camera device will provide the estimate from its\n     * statistics unit on the white balance transforms to use\n     * for the next frame. These are the values the camera device believes\n     * are the best fit for the current output frame. This may\n     * be different than the transform used for this frame, since\n     * statistics processing on data from a new frame typically\n     * completes after the transform has already been applied to\n     * that frame.</p>\n     * <p>These estimates must be provided for all frames, even if\n     * capture settings and color transforms are set by the application.</p>\n     * <p>This value should always be calculated by the auto-white balance (AWB) block,\n     * regardless of the android.control.* current values.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * @deprecated\n     * <p>Never fully implemented or specified; do not use</p>\n\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "STATISTICS_SCENE_FLICKER",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>The camera device estimated scene illumination lighting\n     * frequency.</p>\n     * <p>Many light sources, such as most fluorescent lights, flicker at a rate\n     * that depends on the local utility power standards. This flicker must be\n     * accounted for by auto-exposure routines to avoid artifacts in captured images.\n     * The camera device uses this entry to tell the application what the scene\n     * illuminant frequency is.</p>\n     * <p>When manual exposure control is enabled\n     * (<code>{@link CaptureRequest#CONTROL_AE_MODE android.control.aeMode} == OFF</code> or <code>{@link CaptureRequest#CONTROL_MODE android.control.mode} ==\n     * OFF</code>), the {@link CaptureRequest#CONTROL_AE_ANTIBANDING_MODE android.control.aeAntibandingMode} doesn't perform\n     * antibanding, and the application can ensure it selects\n     * exposure times that do not cause banding issues by looking\n     * into this metadata field. See\n     * {@link CaptureRequest#CONTROL_AE_ANTIBANDING_MODE android.control.aeAntibandingMode} for more details.</p>\n     * <p>Reports NONE if there doesn't appear to be flickering illumination.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #STATISTICS_SCENE_FLICKER_NONE NONE}</li>\n     *   <li>{@link #STATISTICS_SCENE_FLICKER_50HZ 50HZ}</li>\n     *   <li>{@link #STATISTICS_SCENE_FLICKER_60HZ 60HZ}</li>\n     * </ul></p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_ANTIBANDING_MODE\n     * @see CaptureRequest#CONTROL_AE_MODE\n     * @see CaptureRequest#CONTROL_MODE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see #STATISTICS_SCENE_FLICKER_NONE\n     * @see #STATISTICS_SCENE_FLICKER_50HZ\n     * @see #STATISTICS_SCENE_FLICKER_60HZ\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CaptureRequest#CONTROL_AE_MODE", "android.hardware.camera2.CaptureRequest#CONTROL_MODE", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "#STATISTICS_SCENE_FLICKER_50HZ", "#STATISTICS_SCENE_FLICKER_NONE", "#STATISTICS_SCENE_FLICKER_60HZ", "android.hardware.camera2.CaptureRequest#CONTROL_AE_ANTIBANDING_MODE" ]
  }, {
    "name" : "STATISTICS_HOT_PIXEL_MAP_MODE",
    "type" : "Key<Boolean>",
    "comment" : "\n     * <p>Operating mode for hot pixel map generation.</p>\n     * <p>If set to <code>true</code>, a hot pixel map is returned in {@link CaptureResult#STATISTICS_HOT_PIXEL_MAP android.statistics.hotPixelMap}.\n     * If set to <code>false</code>, no hot pixel map will be returned.</p>\n     * <p><b>Range of valid values:</b><br>\n     * {@link CameraCharacteristics#STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES android.statistics.info.availableHotPixelMapModes}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CaptureResult#STATISTICS_HOT_PIXEL_MAP\n     * @see CameraCharacteristics#STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES", "android.hardware.camera2.CaptureResult#STATISTICS_HOT_PIXEL_MAP" ]
  }, {
    "name" : "STATISTICS_HOT_PIXEL_MAP",
    "type" : "Key<android.graphics.Point[]>",
    "comment" : "\n     * <p>List of <code>(x, y)</code> coordinates of hot/defective pixels on the sensor.</p>\n     * <p>A coordinate <code>(x, y)</code> must lie between <code>(0, 0)</code>, and\n     * <code>(width - 1, height - 1)</code> (inclusive), which are the top-left and\n     * bottom-right of the pixel array, respectively. The width and\n     * height dimensions are given in {@link CameraCharacteristics#SENSOR_INFO_PIXEL_ARRAY_SIZE android.sensor.info.pixelArraySize}.\n     * This may include hot pixels that lie outside of the active array\n     * bounds given by {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.</p>\n     * <p><b>Range of valid values:</b><br></p>\n     * <p>n &lt;= number of pixels on the sensor.\n     * The <code>(x, y)</code> coordinates must be bounded by\n     * {@link CameraCharacteristics#SENSOR_INFO_PIXEL_ARRAY_SIZE android.sensor.info.pixelArraySize}.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE\n     * @see CameraCharacteristics#SENSOR_INFO_PIXEL_ARRAY_SIZE\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_PIXEL_ARRAY_SIZE", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE" ]
  }, {
    "name" : "STATISTICS_LENS_SHADING_MAP_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Whether the camera device will output the lens\n     * shading map in output result metadata.</p>\n     * <p>When set to ON,\n     * android.statistics.lensShadingMap will be provided in\n     * the output result metadata.</p>\n     * <p>ON is always supported on devices with the RAW capability.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #STATISTICS_LENS_SHADING_MAP_MODE_OFF OFF}</li>\n     *   <li>{@link #STATISTICS_LENS_SHADING_MAP_MODE_ON ON}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES android.statistics.info.availableLensShadingMapModes}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES\n     * @see #STATISTICS_LENS_SHADING_MAP_MODE_OFF\n     * @see #STATISTICS_LENS_SHADING_MAP_MODE_ON\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "#STATISTICS_LENS_SHADING_MAP_MODE_OFF", "#STATISTICS_LENS_SHADING_MAP_MODE_ON", "android.hardware.camera2.CameraCharacteristics#STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES" ]
  }, {
    "name" : "STATISTICS_OIS_DATA_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>A control for selecting whether optical stabilization (OIS) position\n     * information is included in output result metadata.</p>\n     * <p>Since optical image stabilization generally involves motion much faster than the duration\n     * of individualq image exposure, multiple OIS samples can be included for a single capture\n     * result. For example, if the OIS reporting operates at 200 Hz, a typical camera operating\n     * at 30fps may have 6-7 OIS samples per capture result. This information can be combined\n     * with the rolling shutter skew to account for lens motion during image exposure in\n     * post-processing algorithms.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #STATISTICS_OIS_DATA_MODE_OFF OFF}</li>\n     *   <li>{@link #STATISTICS_OIS_DATA_MODE_ON ON}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#STATISTICS_INFO_AVAILABLE_OIS_DATA_MODES android.statistics.info.availableOisDataModes}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CameraCharacteristics#STATISTICS_INFO_AVAILABLE_OIS_DATA_MODES\n     * @see #STATISTICS_OIS_DATA_MODE_OFF\n     * @see #STATISTICS_OIS_DATA_MODE_ON\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#STATISTICS_INFO_AVAILABLE_OIS_DATA_MODES", "#STATISTICS_OIS_DATA_MODE_OFF", "#STATISTICS_OIS_DATA_MODE_ON" ]
  }, {
    "name" : "STATISTICS_OIS_TIMESTAMPS",
    "type" : "Key<long[]>",
    "comment" : "\n     * <p>An array of timestamps of OIS samples, in nanoseconds.</p>\n     * <p>The array contains the timestamps of OIS samples. The timestamps are in the same\n     * timebase as and comparable to {@link CaptureResult#SENSOR_TIMESTAMP android.sensor.timestamp}.</p>\n     * <p><b>Units</b>: nanoseconds</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CaptureResult#SENSOR_TIMESTAMP\n     * @hide\n     ",
    "links" : [ "android.hardware.camera2.CaptureResult#SENSOR_TIMESTAMP" ]
  }, {
    "name" : "STATISTICS_OIS_X_SHIFTS",
    "type" : "Key<float[]>",
    "comment" : "\n     * <p>An array of shifts of OIS samples, in x direction.</p>\n     * <p>The array contains the amount of shifts in x direction, in pixels, based on OIS samples.\n     * A positive value is a shift from left to right in the pre-correction active array\n     * coordinate system. For example, if the optical center is (1000, 500) in pre-correction\n     * active array coordinates, a shift of (3, 0) puts the new optical center at (1003, 500).</p>\n     * <p>The number of shifts must match the number of timestamps in\n     * android.statistics.oisTimestamps.</p>\n     * <p>The OIS samples are not affected by whether lens distortion correction is enabled (on\n     * supporting devices). They are always reported in pre-correction active array coordinates,\n     * since the scaling of OIS shifts would depend on the specific spot on the sensor the shift\n     * is needed.</p>\n     * <p><b>Units</b>: Pixels in active array.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "STATISTICS_OIS_Y_SHIFTS",
    "type" : "Key<float[]>",
    "comment" : "\n     * <p>An array of shifts of OIS samples, in y direction.</p>\n     * <p>The array contains the amount of shifts in y direction, in pixels, based on OIS samples.\n     * A positive value is a shift from top to bottom in pre-correction active array coordinate\n     * system. For example, if the optical center is (1000, 500) in active array coordinates, a\n     * shift of (0, 5) puts the new optical center at (1000, 505).</p>\n     * <p>The number of shifts must match the number of timestamps in\n     * android.statistics.oisTimestamps.</p>\n     * <p>The OIS samples are not affected by whether lens distortion correction is enabled (on\n     * supporting devices). They are always reported in pre-correction active array coordinates,\n     * since the scaling of OIS shifts would depend on the specific spot on the sensor the shift\n     * is needed.</p>\n     * <p><b>Units</b>: Pixels in active array.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "STATISTICS_OIS_SAMPLES",
    "type" : "Key<android.hardware.camera2.params.OisSample[]>",
    "comment" : "\n     * <p>An array of optical stabilization (OIS) position samples.</p>\n     * <p>Each OIS sample contains the timestamp and the amount of shifts in x and y direction,\n     * in pixels, of the OIS sample.</p>\n     * <p>A positive value for a shift in x direction is a shift from left to right in the\n     * pre-correction active array coordinate system. For example, if the optical center is\n     * (1000, 500) in pre-correction active array coordinates, a shift of (3, 0) puts the new\n     * optical center at (1003, 500).</p>\n     * <p>A positive value for a shift in y direction is a shift from top to bottom in\n     * pre-correction active array coordinate system. For example, if the optical center is\n     * (1000, 500) in active array coordinates, a shift of (0, 5) puts the new optical center at\n     * (1000, 505).</p>\n     * <p>The OIS samples are not affected by whether lens distortion correction is enabled (on\n     * supporting devices). They are always reported in pre-correction active array coordinates,\n     * since the scaling of OIS shifts would depend on the specific spot on the sensor the shift\n     * is needed.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     ",
    "links" : [ ]
  }, {
    "name" : "TONEMAP_CURVE_BLUE",
    "type" : "Key<float[]>",
    "comment" : "\n     * <p>Tonemapping / contrast / gamma curve for the blue\n     * channel, to use when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} is\n     * CONTRAST_CURVE.</p>\n     * <p>See android.tonemap.curveRed for more details.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CaptureRequest#TONEMAP_MODE\n     * @hide\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "android.hardware.camera2.CaptureRequest#TONEMAP_MODE" ]
  }, {
    "name" : "TONEMAP_CURVE_GREEN",
    "type" : "Key<float[]>",
    "comment" : "\n     * <p>Tonemapping / contrast / gamma curve for the green\n     * channel, to use when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} is\n     * CONTRAST_CURVE.</p>\n     * <p>See android.tonemap.curveRed for more details.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CaptureRequest#TONEMAP_MODE\n     * @hide\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "android.hardware.camera2.CaptureRequest#TONEMAP_MODE" ]
  }, {
    "name" : "TONEMAP_CURVE_RED",
    "type" : "Key<float[]>",
    "comment" : "\n     * <p>Tonemapping / contrast / gamma curve for the red\n     * channel, to use when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} is\n     * CONTRAST_CURVE.</p>\n     * <p>Each channel's curve is defined by an array of control points:</p>\n     * <pre><code>android.tonemap.curveRed =\n     *   [ P0in, P0out, P1in, P1out, P2in, P2out, P3in, P3out, ..., PNin, PNout ]\n     * 2 &lt;= N &lt;= {@link CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS android.tonemap.maxCurvePoints}</code></pre>\n     * <p>These are sorted in order of increasing <code>Pin</code>; it is\n     * required that input values 0.0 and 1.0 are included in the list to\n     * define a complete mapping. For input values between control points,\n     * the camera device must linearly interpolate between the control\n     * points.</p>\n     * <p>Each curve can have an independent number of points, and the number\n     * of points can be less than max (that is, the request doesn't have to\n     * always provide a curve with number of points equivalent to\n     * {@link CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS android.tonemap.maxCurvePoints}).</p>\n     * <p>For devices with MONOCHROME capability, all three channels must have the same set of\n     * control points.</p>\n     * <p>A few examples, and their corresponding graphical mappings; these\n     * only specify the red channel and the precision is limited to 4\n     * digits, for conciseness.</p>\n     * <p>Linear mapping:</p>\n     * <pre><code>android.tonemap.curveRed = [ 0, 0, 1.0, 1.0 ]\n     * </code></pre>\n     * <p><img alt=\"Linear mapping curve\" src=\"/reference/images/camera2/metadata/android.tonemap.curveRed/linear_tonemap.png\" /></p>\n     * <p>Invert mapping:</p>\n     * <pre><code>android.tonemap.curveRed = [ 0, 1.0, 1.0, 0 ]\n     * </code></pre>\n     * <p><img alt=\"Inverting mapping curve\" src=\"/reference/images/camera2/metadata/android.tonemap.curveRed/inverse_tonemap.png\" /></p>\n     * <p>Gamma 1/2.2 mapping, with 16 control points:</p>\n     * <pre><code>android.tonemap.curveRed = [\n     *   0.0000, 0.0000, 0.0667, 0.2920, 0.1333, 0.4002, 0.2000, 0.4812,\n     *   0.2667, 0.5484, 0.3333, 0.6069, 0.4000, 0.6594, 0.4667, 0.7072,\n     *   0.5333, 0.7515, 0.6000, 0.7928, 0.6667, 0.8317, 0.7333, 0.8685,\n     *   0.8000, 0.9035, 0.8667, 0.9370, 0.9333, 0.9691, 1.0000, 1.0000 ]\n     * </code></pre>\n     * <p><img alt=\"Gamma = 1/2.2 tonemapping curve\" src=\"/reference/images/camera2/metadata/android.tonemap.curveRed/gamma_tonemap.png\" /></p>\n     * <p>Standard sRGB gamma mapping, per IEC 61966-2-1:1999, with 16 control points:</p>\n     * <pre><code>android.tonemap.curveRed = [\n     *   0.0000, 0.0000, 0.0667, 0.2864, 0.1333, 0.4007, 0.2000, 0.4845,\n     *   0.2667, 0.5532, 0.3333, 0.6125, 0.4000, 0.6652, 0.4667, 0.7130,\n     *   0.5333, 0.7569, 0.6000, 0.7977, 0.6667, 0.8360, 0.7333, 0.8721,\n     *   0.8000, 0.9063, 0.8667, 0.9389, 0.9333, 0.9701, 1.0000, 1.0000 ]\n     * </code></pre>\n     * <p><img alt=\"sRGB tonemapping curve\" src=\"/reference/images/camera2/metadata/android.tonemap.curveRed/srgb_tonemap.png\" /></p>\n     * <p><b>Range of valid values:</b><br>\n     * 0-1 on both input and output coordinates, normalized\n     * as a floating-point value such that 0 == black and 1 == white.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS\n     * @see CaptureRequest#TONEMAP_MODE\n     * @hide\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "android.hardware.camera2.CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS", "android.hardware.camera2.CaptureRequest#TONEMAP_MODE" ]
  }, {
    "name" : "TONEMAP_CURVE",
    "type" : "Key<android.hardware.camera2.params.TonemapCurve>",
    "comment" : "\n     * <p>Tonemapping / contrast / gamma curve to use when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode}\n     * is CONTRAST_CURVE.</p>\n     * <p>The tonemapCurve consist of three curves for each of red, green, and blue\n     * channels respectively. The following example uses the red channel as an\n     * example. The same logic applies to green and blue channel.\n     * Each channel's curve is defined by an array of control points:</p>\n     * <pre><code>curveRed =\n     *   [ P0(in, out), P1(in, out), P2(in, out), P3(in, out), ..., PN(in, out) ]\n     * 2 &lt;= N &lt;= {@link CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS android.tonemap.maxCurvePoints}</code></pre>\n     * <p>These are sorted in order of increasing <code>Pin</code>; it is always\n     * guaranteed that input values 0.0 and 1.0 are included in the list to\n     * define a complete mapping. For input values between control points,\n     * the camera device must linearly interpolate between the control\n     * points.</p>\n     * <p>Each curve can have an independent number of points, and the number\n     * of points can be less than max (that is, the request doesn't have to\n     * always provide a curve with number of points equivalent to\n     * {@link CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS android.tonemap.maxCurvePoints}).</p>\n     * <p>For devices with MONOCHROME capability, all three channels must have the same set of\n     * control points.</p>\n     * <p>A few examples, and their corresponding graphical mappings; these\n     * only specify the red channel and the precision is limited to 4\n     * digits, for conciseness.</p>\n     * <p>Linear mapping:</p>\n     * <pre><code>curveRed = [ (0, 0), (1.0, 1.0) ]\n     * </code></pre>\n     * <p><img alt=\"Linear mapping curve\" src=\"/reference/images/camera2/metadata/android.tonemap.curveRed/linear_tonemap.png\" /></p>\n     * <p>Invert mapping:</p>\n     * <pre><code>curveRed = [ (0, 1.0), (1.0, 0) ]\n     * </code></pre>\n     * <p><img alt=\"Inverting mapping curve\" src=\"/reference/images/camera2/metadata/android.tonemap.curveRed/inverse_tonemap.png\" /></p>\n     * <p>Gamma 1/2.2 mapping, with 16 control points:</p>\n     * <pre><code>curveRed = [\n     *   (0.0000, 0.0000), (0.0667, 0.2920), (0.1333, 0.4002), (0.2000, 0.4812),\n     *   (0.2667, 0.5484), (0.3333, 0.6069), (0.4000, 0.6594), (0.4667, 0.7072),\n     *   (0.5333, 0.7515), (0.6000, 0.7928), (0.6667, 0.8317), (0.7333, 0.8685),\n     *   (0.8000, 0.9035), (0.8667, 0.9370), (0.9333, 0.9691), (1.0000, 1.0000) ]\n     * </code></pre>\n     * <p><img alt=\"Gamma = 1/2.2 tonemapping curve\" src=\"/reference/images/camera2/metadata/android.tonemap.curveRed/gamma_tonemap.png\" /></p>\n     * <p>Standard sRGB gamma mapping, per IEC 61966-2-1:1999, with 16 control points:</p>\n     * <pre><code>curveRed = [\n     *   (0.0000, 0.0000), (0.0667, 0.2864), (0.1333, 0.4007), (0.2000, 0.4845),\n     *   (0.2667, 0.5532), (0.3333, 0.6125), (0.4000, 0.6652), (0.4667, 0.7130),\n     *   (0.5333, 0.7569), (0.6000, 0.7977), (0.6667, 0.8360), (0.7333, 0.8721),\n     *   (0.8000, 0.9063), (0.8667, 0.9389), (0.9333, 0.9701), (1.0000, 1.0000) ]\n     * </code></pre>\n     * <p><img alt=\"sRGB tonemapping curve\" src=\"/reference/images/camera2/metadata/android.tonemap.curveRed/srgb_tonemap.png\" /></p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS\n     * @see CaptureRequest#TONEMAP_MODE\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "android.hardware.camera2.CameraCharacteristics#TONEMAP_MAX_CURVE_POINTS", "android.hardware.camera2.CaptureRequest#TONEMAP_MODE" ]
  }, {
    "name" : "TONEMAP_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>High-level global contrast/gamma/tonemapping control.</p>\n     * <p>When switching to an application-defined contrast curve by setting\n     * {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} to CONTRAST_CURVE, the curve is defined\n     * per-channel with a set of <code>(in, out)</code> points that specify the\n     * mapping from input high-bit-depth pixel value to the output\n     * low-bit-depth value.  Since the actual pixel ranges of both input\n     * and output may change depending on the camera pipeline, the values\n     * are specified by normalized floating-point numbers.</p>\n     * <p>More-complex color mapping operations such as 3D color look-up\n     * tables, selective chroma enhancement, or other non-linear color\n     * transforms will be disabled when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} is\n     * CONTRAST_CURVE.</p>\n     * <p>When using either FAST or HIGH_QUALITY, the camera device will\n     * emit its own tonemap curve in {@link CaptureRequest#TONEMAP_CURVE android.tonemap.curve}.\n     * These values are always available, and as close as possible to the\n     * actually used nonlinear/nonglobal transforms.</p>\n     * <p>If a request is sent with CONTRAST_CURVE with the camera device's\n     * provided curve in FAST or HIGH_QUALITY, the image's tonemap will be\n     * roughly the same.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #TONEMAP_MODE_CONTRAST_CURVE CONTRAST_CURVE}</li>\n     *   <li>{@link #TONEMAP_MODE_FAST FAST}</li>\n     *   <li>{@link #TONEMAP_MODE_HIGH_QUALITY HIGH_QUALITY}</li>\n     *   <li>{@link #TONEMAP_MODE_GAMMA_VALUE GAMMA_VALUE}</li>\n     *   <li>{@link #TONEMAP_MODE_PRESET_CURVE PRESET_CURVE}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#TONEMAP_AVAILABLE_TONE_MAP_MODES android.tonemap.availableToneMapModes}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CameraCharacteristics#TONEMAP_AVAILABLE_TONE_MAP_MODES\n     * @see CaptureRequest#TONEMAP_CURVE\n     * @see CaptureRequest#TONEMAP_MODE\n     * @see #TONEMAP_MODE_CONTRAST_CURVE\n     * @see #TONEMAP_MODE_FAST\n     * @see #TONEMAP_MODE_HIGH_QUALITY\n     * @see #TONEMAP_MODE_GAMMA_VALUE\n     * @see #TONEMAP_MODE_PRESET_CURVE\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CaptureRequest#TONEMAP_CURVE", "#TONEMAP_MODE_FAST", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "#TONEMAP_MODE_GAMMA_VALUE", "android.hardware.camera2.CameraCharacteristics#TONEMAP_AVAILABLE_TONE_MAP_MODES", "#TONEMAP_MODE_HIGH_QUALITY", "#TONEMAP_MODE_PRESET_CURVE", "android.hardware.camera2.CaptureRequest#TONEMAP_MODE", "#TONEMAP_MODE_CONTRAST_CURVE" ]
  }, {
    "name" : "TONEMAP_GAMMA",
    "type" : "Key<Float>",
    "comment" : "\n     * <p>Tonemapping curve to use when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} is\n     * GAMMA_VALUE</p>\n     * <p>The tonemap curve will be defined the following formula:\n     * * OUT = pow(IN, 1.0 / gamma)\n     * where IN and OUT is the input pixel value scaled to range [0.0, 1.0],\n     * pow is the power function and gamma is the gamma value specified by this\n     * key.</p>\n     * <p>The same curve will be applied to all color channels. The camera device\n     * may clip the input gamma value to its supported range. The actual applied\n     * value will be returned in capture result.</p>\n     * <p>The valid range of gamma value varies on different devices, but values\n     * within [1.0, 5.0] are guaranteed not to be clipped.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CaptureRequest#TONEMAP_MODE\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#TONEMAP_MODE" ]
  }, {
    "name" : "TONEMAP_PRESET_CURVE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Tonemapping curve to use when {@link CaptureRequest#TONEMAP_MODE android.tonemap.mode} is\n     * PRESET_CURVE</p>\n     * <p>The tonemap curve will be defined by specified standard.</p>\n     * <p>sRGB (approximated by 16 control points):</p>\n     * <p><img alt=\"sRGB tonemapping curve\" src=\"/reference/images/camera2/metadata/android.tonemap.curveRed/srgb_tonemap.png\" /></p>\n     * <p>Rec. 709 (approximated by 16 control points):</p>\n     * <p><img alt=\"Rec. 709 tonemapping curve\" src=\"/reference/images/camera2/metadata/android.tonemap.curveRed/rec709_tonemap.png\" /></p>\n     * <p>Note that above figures show a 16 control points approximation of preset\n     * curves. Camera devices may apply a different approximation to the curve.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #TONEMAP_PRESET_CURVE_SRGB SRGB}</li>\n     *   <li>{@link #TONEMAP_PRESET_CURVE_REC709 REC709}</li>\n     * </ul></p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CaptureRequest#TONEMAP_MODE\n     * @see #TONEMAP_PRESET_CURVE_SRGB\n     * @see #TONEMAP_PRESET_CURVE_REC709\n     ",
    "links" : [ "#TONEMAP_PRESET_CURVE_REC709", "#TONEMAP_PRESET_CURVE_SRGB", "android.hardware.camera2.CaptureRequest#TONEMAP_MODE" ]
  }, {
    "name" : "LED_TRANSMIT",
    "type" : "Key<Boolean>",
    "comment" : "\n     * <p>This LED is nominally used to indicate to the user\n     * that the camera is powered on and may be streaming images back to the\n     * Application Processor. In certain rare circumstances, the OS may\n     * disable this when video is processed locally and not transmitted to\n     * any untrusted applications.</p>\n     * <p>In particular, the LED <em>must</em> always be on when the data could be\n     * transmitted off the device. The LED <em>should</em> always be on whenever\n     * data is stored locally on the device.</p>\n     * <p>The LED <em>may</em> be off if a trusted application is using the data that\n     * doesn't violate the above rules.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "BLACK_LEVEL_LOCK",
    "type" : "Key<Boolean>",
    "comment" : "\n     * <p>Whether black-level compensation is locked\n     * to its current values, or is free to vary.</p>\n     * <p>Whether the black level offset was locked for this frame.  Should be\n     * ON if {@link CaptureRequest#BLACK_LEVEL_LOCK android.blackLevel.lock} was ON in the capture request, unless\n     * a change in other capture settings forced the camera device to\n     * perform a black level reset.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Full capability</b> -\n     * Present on all camera devices that report being {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL HARDWARE_LEVEL_FULL} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#BLACK_LEVEL_LOCK\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_FULL", "android.hardware.camera2.CaptureRequest#BLACK_LEVEL_LOCK" ]
  }, {
    "name" : "SYNC_FRAME_NUMBER",
    "type" : "Key<Long>",
    "comment" : "\n     * <p>The frame number corresponding to the last request\n     * with which the output result (metadata + buffers) has been fully\n     * synchronized.</p>\n     * <p>When a request is submitted to the camera device, there is usually a\n     * delay of several frames before the controls get applied. A camera\n     * device may either choose to account for this delay by implementing a\n     * pipeline and carefully submit well-timed atomic control updates, or\n     * it may start streaming control changes that span over several frame\n     * boundaries.</p>\n     * <p>In the latter case, whenever a request's settings change relative to\n     * the previous submitted request, the full set of changes may take\n     * multiple frame durations to fully take effect. Some settings may\n     * take effect sooner (in less frame durations) than others.</p>\n     * <p>While a set of control changes are being propagated, this value\n     * will be CONVERGING.</p>\n     * <p>Once it is fully known that a set of control changes have been\n     * finished propagating, and the resulting updated control settings\n     * have been read back by the camera device, this value will be set\n     * to a non-negative frame number (corresponding to the request to\n     * which the results have synchronized to).</p>\n     * <p>Older camera device implementations may not have a way to detect\n     * when all camera controls have been applied, and will always set this\n     * value to UNKNOWN.</p>\n     * <p>FULL capability devices will always have this value set to the\n     * frame number of the request corresponding to this result.</p>\n     * <p><em>Further details</em>:</p>\n     * <ul>\n     * <li>Whenever a request differs from the last request, any future\n     * results not yet returned may have this value set to CONVERGING (this\n     * could include any in-progress captures not yet returned by the camera\n     * device, for more details see pipeline considerations below).</li>\n     * <li>Submitting a series of multiple requests that differ from the\n     * previous request (e.g. r1, r2, r3 s.t. r1 != r2 != r3)\n     * moves the new synchronization frame to the last non-repeating\n     * request (using the smallest frame number from the contiguous list of\n     * repeating requests).</li>\n     * <li>Submitting the same request repeatedly will not change this value\n     * to CONVERGING, if it was already a non-negative value.</li>\n     * <li>When this value changes to non-negative, that means that all of the\n     * metadata controls from the request have been applied, all of the\n     * metadata controls from the camera device have been read to the\n     * updated values (into the result), and all of the graphics buffers\n     * corresponding to this result are also synchronized to the request.</li>\n     * </ul>\n     * <p><em>Pipeline considerations</em>:</p>\n     * <p>Submitting a request with updated controls relative to the previously\n     * submitted requests may also invalidate the synchronization state\n     * of all the results corresponding to currently in-flight requests.</p>\n     * <p>In other words, results for this current request and up to\n     * {@link CameraCharacteristics#REQUEST_PIPELINE_MAX_DEPTH android.request.pipelineMaxDepth} prior requests may have their\n     * android.sync.frameNumber change to CONVERGING.</p>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #SYNC_FRAME_NUMBER_CONVERGING CONVERGING}</li>\n     *   <li>{@link #SYNC_FRAME_NUMBER_UNKNOWN UNKNOWN}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * Either a non-negative value corresponding to a\n     * <code>frame_number</code>, or one of the two enums (CONVERGING / UNKNOWN).</p>\n     * <p>This key is available on all devices.</p>\n     *\n     * @see CameraCharacteristics#REQUEST_PIPELINE_MAX_DEPTH\n     * @see #SYNC_FRAME_NUMBER_CONVERGING\n     * @see #SYNC_FRAME_NUMBER_UNKNOWN\n     * @hide\n     ",
    "links" : [ "#SYNC_FRAME_NUMBER_CONVERGING", "android.hardware.camera2.CameraCharacteristics#REQUEST_PIPELINE_MAX_DEPTH", "#SYNC_FRAME_NUMBER_UNKNOWN" ]
  }, {
    "name" : "REPROCESS_EFFECTIVE_EXPOSURE_FACTOR",
    "type" : "Key<Float>",
    "comment" : "\n     * <p>The amount of exposure time increase factor applied to the original output\n     * frame by the application processing before sending for reprocessing.</p>\n     * <p>This is optional, and will be supported if the camera device supports YUV_REPROCESSING\n     * capability ({@link CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES android.request.availableCapabilities} contains YUV_REPROCESSING).</p>\n     * <p>For some YUV reprocessing use cases, the application may choose to filter the original\n     * output frames to effectively reduce the noise to the same level as a frame that was\n     * captured with longer exposure time. To be more specific, assuming the original captured\n     * images were captured with a sensitivity of S and an exposure time of T, the model in\n     * the camera device is that the amount of noise in the image would be approximately what\n     * would be expected if the original capture parameters had been a sensitivity of\n     * S/effectiveExposureFactor and an exposure time of T*effectiveExposureFactor, rather\n     * than S and T respectively. If the captured images were processed by the application\n     * before being sent for reprocessing, then the application may have used image processing\n     * algorithms and/or multi-frame image fusion to reduce the noise in the\n     * application-processed images (input images). By using the effectiveExposureFactor\n     * control, the application can communicate to the camera device the actual noise level\n     * improvement in the application-processed image. With this information, the camera\n     * device can select appropriate noise reduction and edge enhancement parameters to avoid\n     * excessive noise reduction ({@link CaptureRequest#NOISE_REDUCTION_MODE android.noiseReduction.mode}) and insufficient edge\n     * enhancement ({@link CaptureRequest#EDGE_MODE android.edge.mode}) being applied to the reprocessed frames.</p>\n     * <p>For example, for multi-frame image fusion use case, the application may fuse\n     * multiple output frames together to a final frame for reprocessing. When N image are\n     * fused into 1 image for reprocessing, the exposure time increase factor could be up to\n     * square root of N (based on a simple photon shot noise model). The camera device will\n     * adjust the reprocessing noise reduction and edge enhancement parameters accordingly to\n     * produce the best quality images.</p>\n     * <p>This is relative factor, 1.0 indicates the application hasn't processed the input\n     * buffer in a way that affects its effective exposure time.</p>\n     * <p>This control is only effective for YUV reprocessing capture request. For noise\n     * reduction reprocessing, it is only effective when <code>{@link CaptureRequest#NOISE_REDUCTION_MODE android.noiseReduction.mode} != OFF</code>.\n     * Similarly, for edge enhancement reprocessing, it is only effective when\n     * <code>{@link CaptureRequest#EDGE_MODE android.edge.mode} != OFF</code>.</p>\n     * <p><b>Units</b>: Relative exposure time increase factor.</p>\n     * <p><b>Range of valid values:</b><br>\n     * &gt;= 1.0</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     * <p><b>Limited capability</b> -\n     * Present on all camera devices that report being at least {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED HARDWARE_LEVEL_LIMITED} devices in the\n     * {@link CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL android.info.supportedHardwareLevel} key</p>\n     *\n     * @see CaptureRequest#EDGE_MODE\n     * @see CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL\n     * @see CaptureRequest#NOISE_REDUCTION_MODE\n     * @see CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL", "android.hardware.camera2.CaptureRequest#NOISE_REDUCTION_MODE", "android.hardware.camera2.CaptureRequest#EDGE_MODE", "android.hardware.camera2.CameraCharacteristics#INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED" ]
  }, {
    "name" : "LOGICAL_MULTI_CAMERA_ACTIVE_PHYSICAL_ID",
    "type" : "Key<String>",
    "comment" : "\n     * <p>String containing the ID of the underlying active physical camera.</p>\n     * <p>The ID of the active physical camera that's backing the logical camera. All camera\n     * streams and metadata that are not physical camera specific will be originating from this\n     * physical camera.</p>\n     * <p>For a logical camera made up of physical cameras where each camera's lenses have\n     * different characteristics, the camera device may choose to switch between the physical\n     * cameras when application changes FOCAL_LENGTH or SCALER_CROP_REGION.\n     * At the time of lens switch, this result metadata reflects the new active physical camera\n     * ID.</p>\n     * <p>This key will be available if the camera device advertises this key via {@link android.hardware.camera2.CameraCharacteristics#getAvailableCaptureResultKeys }.\n     * When available, this must be one of valid physical IDs backing this logical multi-camera.\n     * If this key is not available for a logical multi-camera, the camera device implementation\n     * may still switch between different active physical cameras based on use case, but the\n     * current active physical camera information won't be available to the application.</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     ",
    "links" : [ "android.hardware.camera2.CameraCharacteristics#getAvailableCaptureResultKeys" ]
  }, {
    "name" : "DISTORTION_CORRECTION_MODE",
    "type" : "Key<Integer>",
    "comment" : "\n     * <p>Mode of operation for the lens distortion correction block.</p>\n     * <p>The lens distortion correction block attempts to improve image quality by fixing\n     * radial, tangential, or other geometric aberrations in the camera device's optics.  If\n     * available, the {@link CameraCharacteristics#LENS_DISTORTION android.lens.distortion} field documents the lens's distortion parameters.</p>\n     * <p>OFF means no distortion correction is done.</p>\n     * <p>FAST/HIGH_QUALITY both mean camera device determined distortion correction will be\n     * applied. HIGH_QUALITY mode indicates that the camera device will use the highest-quality\n     * correction algorithms, even if it slows down capture rate. FAST means the camera device\n     * will not slow down capture rate when applying correction. FAST may be the same as OFF if\n     * any correction at all would slow down capture rate.  Every output stream will have a\n     * similar amount of enhancement applied.</p>\n     * <p>The correction only applies to processed outputs such as YUV, Y8, JPEG, or DEPTH16; it is\n     * not applied to any RAW output.</p>\n     * <p>This control will be on by default on devices that support this control. Applications\n     * disabling distortion correction need to pay extra attention with the coordinate system of\n     * metering regions, crop region, and face rectangles. When distortion correction is OFF,\n     * metadata coordinates follow the coordinate system of\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE android.sensor.info.preCorrectionActiveArraySize}. When distortion is not OFF, metadata\n     * coordinates follow the coordinate system of {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE android.sensor.info.activeArraySize}.  The\n     * camera device will map these metadata fields to match the corrected image produced by the\n     * camera device, for both capture requests and results.  However, this mapping is not very\n     * precise, since rectangles do not generally map to rectangles when corrected.  Only linear\n     * scaling between the active array and precorrection active array coordinates is\n     * performed. Applications that require precise correction of metadata need to undo that\n     * linear scaling, and apply a more complete correction that takes into the account the app's\n     * own requirements.</p>\n     * <p>The full list of metadata that is affected in this way by distortion correction is:</p>\n     * <ul>\n     * <li>{@link CaptureRequest#CONTROL_AF_REGIONS android.control.afRegions}</li>\n     * <li>{@link CaptureRequest#CONTROL_AE_REGIONS android.control.aeRegions}</li>\n     * <li>{@link CaptureRequest#CONTROL_AWB_REGIONS android.control.awbRegions}</li>\n     * <li>{@link CaptureRequest#SCALER_CROP_REGION android.scaler.cropRegion}</li>\n     * <li>{@link CaptureResult#STATISTICS_FACES android.statistics.faces}</li>\n     * </ul>\n     * <p><b>Possible values:</b>\n     * <ul>\n     *   <li>{@link #DISTORTION_CORRECTION_MODE_OFF OFF}</li>\n     *   <li>{@link #DISTORTION_CORRECTION_MODE_FAST FAST}</li>\n     *   <li>{@link #DISTORTION_CORRECTION_MODE_HIGH_QUALITY HIGH_QUALITY}</li>\n     * </ul></p>\n     * <p><b>Available values for this device:</b><br>\n     * {@link CameraCharacteristics#DISTORTION_CORRECTION_AVAILABLE_MODES android.distortionCorrection.availableModes}</p>\n     * <p><b>Optional</b> - The value for this key may be {@code null} on some devices.</p>\n     *\n     * @see CaptureRequest#CONTROL_AE_REGIONS\n     * @see CaptureRequest#CONTROL_AF_REGIONS\n     * @see CaptureRequest#CONTROL_AWB_REGIONS\n     * @see CameraCharacteristics#DISTORTION_CORRECTION_AVAILABLE_MODES\n     * @see CameraCharacteristics#LENS_DISTORTION\n     * @see CaptureRequest#SCALER_CROP_REGION\n     * @see CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE\n     * @see CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE\n     * @see CaptureResult#STATISTICS_FACES\n     * @see #DISTORTION_CORRECTION_MODE_OFF\n     * @see #DISTORTION_CORRECTION_MODE_FAST\n     * @see #DISTORTION_CORRECTION_MODE_HIGH_QUALITY\n     ",
    "links" : [ "android.hardware.camera2.CaptureRequest#CONTROL_AWB_REGIONS", "android.hardware.camera2.CameraCharacteristics#DISTORTION_CORRECTION_AVAILABLE_MODES", "android.hardware.camera2.CameraCharacteristics#LENS_DISTORTION", "android.hardware.camera2.CaptureRequest#SCALER_CROP_REGION", "#DISTORTION_CORRECTION_MODE_OFF", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE", "android.hardware.camera2.CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE", "android.hardware.camera2.CaptureRequest#CONTROL_AE_REGIONS", "#DISTORTION_CORRECTION_MODE_FAST", "#DISTORTION_CORRECTION_MODE_HIGH_QUALITY", "android.hardware.camera2.CaptureResult#STATISTICS_FACES", "android.hardware.camera2.CaptureRequest#CONTROL_AF_REGIONS" ]
  } ],
  "methods" : [ {
    "name" : "public CameraMetadataNative getNativeCopy()",
    "returnType" : "CameraMetadataNative",
    "comment" : "\n     * Returns a copy of the underlying {@link CameraMetadataNative}.\n     * @hide\n     ",
    "links" : [ "android.hardware.camera2.impl.CameraMetadataNative" ]
  }, {
    "name" : "public T get(Key<T> key)",
    "returnType" : "T",
    "comment" : "\n     * Get a capture result field value.\n     *\n     * <p>The field definitions can be found in {@link CaptureResult}.</p>\n     *\n     * <p>Querying the value for the same key more than once will return a value\n     * which is equal to the previous queried value.</p>\n     *\n     * @throws IllegalArgumentException if the key was not valid\n     *\n     * @param key The result field to read.\n     * @return The value of that key, or {@code null} if the field is not set.\n     ",
    "links" : [ "android.hardware.camera2.CaptureResult" ]
  }, {
    "name" : "protected T getProtected(Key<?> key)",
    "returnType" : "T",
    "comment" : "\n     * {@inheritDoc}\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected Class<Key<?>> getKeyClass()",
    "returnType" : "Class<Key<?>>",
    "comment" : "\n     * {@inheritDoc}\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void dumpToLog()",
    "returnType" : "void",
    "comment" : "\n     * Dumps the native metadata contents to logcat.\n     *\n     * <p>Visibility for testing/debugging only. The results will not\n     * include any synthesized keys, as they are invisible to the native layer.</p>\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<Key<?>> getKeys()",
    "returnType" : "List<Key<?>>",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "public CaptureRequest getRequest()",
    "returnType" : "CaptureRequest",
    "comment" : "\n     * Get the request associated with this result.\n     *\n     * <p>Whenever a request has been fully or partially captured, with\n     * {@link CameraCaptureSession.CaptureCallback#onCaptureCompleted} or\n     * {@link CameraCaptureSession.CaptureCallback#onCaptureProgressed}, the {@code result}'s\n     * {@code getRequest()} will return that {@code request}.\n     * </p>\n     *\n     * <p>For example,\n     * <code><pre>cameraDevice.capture(someRequest, new CaptureCallback() {\n     *     {@literal @}Override\n     *     void onCaptureCompleted(CaptureRequest myRequest, CaptureResult myResult) {\n     *         assert(myResult.getRequest.equals(myRequest) == true);\n     *     }\n     * }, null);\n     * </code></pre>\n     * </p>\n     *\n     * @return The request associated with this result. Never {@code null}.\n     ",
    "links" : [ "CameraCaptureSession.CaptureCallback#onCaptureCompleted", "CameraCaptureSession.CaptureCallback#onCaptureProgressed" ]
  }, {
    "name" : "public long getFrameNumber()",
    "returnType" : "long",
    "comment" : "\n     * Get the frame number associated with this result.\n     *\n     * <p>Whenever a request has been processed, regardless of failure or success,\n     * it gets a unique frame number assigned to its future result/failure.</p>\n     *\n     * <p>For the same type of request (capturing from the camera device or reprocessing), this\n     * value monotonically increments, starting with 0, for every new result or failure and the\n     * scope is the lifetime of the {@link CameraDevice}. Between different types of requests,\n     * the frame number may not monotonically increment. For example, the frame number of a newer\n     * reprocess result may be smaller than the frame number of an older result of capturing new\n     * images from the camera device, but the frame number of a newer reprocess result will never be\n     * smaller than the frame number of an older reprocess result.</p>\n     *\n     * @return The frame number\n     *\n     * @see CameraDevice#createCaptureRequest\n     * @see CameraDevice#createReprocessCaptureRequest\n     ",
    "links" : [ "android.hardware.camera2.CameraDevice" ]
  }, {
    "name" : "public int getSequenceId()",
    "returnType" : "int",
    "comment" : "\n     * The sequence ID for this failure that was returned by the\n     * {@link CameraCaptureSession#capture} family of functions.\n     *\n     * <p>The sequence ID is a unique monotonically increasing value starting from 0,\n     * incremented every time a new group of requests is submitted to the CameraDevice.</p>\n     *\n     * @return int The ID for the sequence of requests that this capture result is a part of\n     *\n     * @see CameraCaptureSession.CaptureCallback#onCaptureSequenceCompleted\n     * @see CameraCaptureSession.CaptureCallback#onCaptureSequenceAborted\n     ",
    "links" : [ "android.hardware.camera2.CameraCaptureSession#capture" ]
  } ],
  "variableNames" : [ "TAG", "VERBOSE", "mResults", "mRequest", "mSequenceId", "mFrameNumber", "COLOR_CORRECTION_MODE", "COLOR_CORRECTION_TRANSFORM", "COLOR_CORRECTION_GAINS", "COLOR_CORRECTION_ABERRATION_MODE", "CONTROL_AE_ANTIBANDING_MODE", "CONTROL_AE_EXPOSURE_COMPENSATION", "CONTROL_AE_LOCK", "CONTROL_AE_MODE", "CONTROL_AE_REGIONS", "CONTROL_AE_TARGET_FPS_RANGE", "CONTROL_AE_PRECAPTURE_TRIGGER", "CONTROL_AE_STATE", "CONTROL_AF_MODE", "CONTROL_AF_REGIONS", "CONTROL_AF_TRIGGER", "CONTROL_AF_STATE", "CONTROL_AWB_LOCK", "CONTROL_AWB_MODE", "CONTROL_AWB_REGIONS", "CONTROL_CAPTURE_INTENT", "CONTROL_AWB_STATE", "CONTROL_EFFECT_MODE", "CONTROL_MODE", "CONTROL_SCENE_MODE", "CONTROL_VIDEO_STABILIZATION_MODE", "CONTROL_POST_RAW_SENSITIVITY_BOOST", "CONTROL_ENABLE_ZSL", "CONTROL_AF_SCENE_CHANGE", "CONTROL_EXTENDED_SCENE_MODE", "CONTROL_ZOOM_RATIO", "EDGE_MODE", "FLASH_MODE", "FLASH_STATE", "HOT_PIXEL_MODE", "JPEG_GPS_LOCATION", "JPEG_GPS_COORDINATES", "JPEG_GPS_PROCESSING_METHOD", "JPEG_GPS_TIMESTAMP", "JPEG_ORIENTATION", "JPEG_QUALITY", "JPEG_THUMBNAIL_QUALITY", "JPEG_THUMBNAIL_SIZE", "LENS_APERTURE", "LENS_FILTER_DENSITY", "LENS_FOCAL_LENGTH", "LENS_FOCUS_DISTANCE", "LENS_FOCUS_RANGE", "LENS_OPTICAL_STABILIZATION_MODE", "LENS_STATE", "LENS_POSE_ROTATION", "LENS_POSE_TRANSLATION", "LENS_INTRINSIC_CALIBRATION", "LENS_RADIAL_DISTORTION", "LENS_DISTORTION", "NOISE_REDUCTION_MODE", "QUIRKS_PARTIAL_RESULT", "REQUEST_FRAME_COUNT", "REQUEST_ID", "REQUEST_PIPELINE_DEPTH", "SCALER_CROP_REGION", "SCALER_ROTATE_AND_CROP", "SENSOR_EXPOSURE_TIME", "SENSOR_FRAME_DURATION", "SENSOR_SENSITIVITY", "SENSOR_TIMESTAMP", "SENSOR_NEUTRAL_COLOR_POINT", "SENSOR_NOISE_PROFILE", "SENSOR_GREEN_SPLIT", "SENSOR_TEST_PATTERN_DATA", "SENSOR_TEST_PATTERN_MODE", "SENSOR_ROLLING_SHUTTER_SKEW", "SENSOR_DYNAMIC_BLACK_LEVEL", "SENSOR_DYNAMIC_WHITE_LEVEL", "SHADING_MODE", "STATISTICS_FACE_DETECT_MODE", "STATISTICS_FACE_IDS", "STATISTICS_FACE_LANDMARKS", "STATISTICS_FACE_RECTANGLES", "STATISTICS_FACE_SCORES", "STATISTICS_FACES", "STATISTICS_LENS_SHADING_CORRECTION_MAP", "STATISTICS_LENS_SHADING_MAP", "STATISTICS_PREDICTED_COLOR_GAINS", "STATISTICS_PREDICTED_COLOR_TRANSFORM", "STATISTICS_SCENE_FLICKER", "STATISTICS_HOT_PIXEL_MAP_MODE", "STATISTICS_HOT_PIXEL_MAP", "STATISTICS_LENS_SHADING_MAP_MODE", "STATISTICS_OIS_DATA_MODE", "STATISTICS_OIS_TIMESTAMPS", "STATISTICS_OIS_X_SHIFTS", "STATISTICS_OIS_Y_SHIFTS", "STATISTICS_OIS_SAMPLES", "TONEMAP_CURVE_BLUE", "TONEMAP_CURVE_GREEN", "TONEMAP_CURVE_RED", "TONEMAP_CURVE", "TONEMAP_MODE", "TONEMAP_GAMMA", "TONEMAP_PRESET_CURVE", "LED_TRANSMIT", "BLACK_LEVEL_LOCK", "SYNC_FRAME_NUMBER", "REPROCESS_EFFECTIVE_EXPOSURE_FACTOR", "LOGICAL_MULTI_CAMERA_ACTIVE_PHYSICAL_ID", "DISTORTION_CORRECTION_MODE" ],
  "methodNames" : [ "public CameraMetadataNative getNativeCopy()", "public T get(Key<T> key)", "protected T getProtected(Key<?> key)", "protected Class<Key<?>> getKeyClass()", "public void dumpToLog()", "public List<Key<?>> getKeys()", "public CaptureRequest getRequest()", "public long getFrameNumber()", "public int getSequenceId()" ]
}