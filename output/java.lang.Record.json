{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/lang/Record.java",
  "packageName" : "java.lang",
  "className" : "Record",
  "comment" : "\n * This is the common base class of all Java language record classes.\n *\n * <p>More information about records, including descriptions of the\n * implicitly declared methods synthesized by the compiler, can be\n * found in section 8.10 of\n * <cite>The Java Language Specification</cite>.\n *\n * <p>A <em>record class</em> is a shallowly immutable, transparent carrier for\n * a fixed set of values, called the <em>record components</em>.  The Java\n * language provides concise syntax for declaring record classes, whereby the\n * record components are declared in the record header.  The list of record\n * components declared in the record header form the <em>record descriptor</em>.\n *\n * <p>A record class has the following mandated members: a <em>canonical\n * constructor</em>, which must provide at least as much access as the record\n * class and whose descriptor is the same as the record descriptor;\n * a private final field corresponding to each component, whose name and\n * type are the same as that of the component; a public accessor method\n * corresponding to each component, whose name and return type are the same as\n * that of the component.  If not explicitly declared in the body of the record,\n * implicit implementations for these members are provided.\n *\n * <p>The implicit declaration of the canonical constructor has the same accessibility\n * as the record class and initializes the component fields from the corresponding\n * constructor arguments.  The implicit declaration of the accessor methods returns\n * the value of the corresponding component field.  The implicit declaration of the\n * {@link Object#equals(Object)}, {@link Object#hashCode()}, and {@link Object#toString()}\n * methods are derived from all of the component fields.\n *\n * <p>The primary reasons to provide an explicit declaration for the\n * canonical constructor or accessor methods are to validate constructor\n * arguments, perform defensive copies on mutable components, or normalize groups\n * of components (such as reducing a rational number to lowest terms.)\n *\n * <p>For all record classes, the following invariant must hold: if a record R's\n * components are {@code c1, c2, ... cn}, then if a record instance is copied\n * as follows:\n * <pre>\n *     R copy = new R(r.c1(), r.c2(), ..., r.cn());\n * </pre>\n * then it must be the case that {@code r.equals(copy)}.\n *\n * @apiNote\n * A record class that {@code implements} {@link java.io.Serializable} is said\n * to be a <i>serializable record</i>. Serializable records are serialized and\n * deserialized differently than ordinary serializable objects. During\n * deserialization the record's canonical constructor is invoked to construct\n * the record object. Certain serialization-related methods, such as readObject\n * and writeObject, are ignored for serializable records. More information about\n * serializable records can be found in the\n * <a href=\"{@docRoot}/../specs/serialization/serial-arch.html#serialization-of-records\">\n * <cite>Java Object Serialization Specification,</cite> Section 1.13,\n * \"Serialization of Records\"</a>.\n *\n * @apiNote\n * A record class structure can be obtained at runtime via reflection.\n * See {@link Class#isRecord()} and {@link Class#getRecordComponents()} for more details.\n *\n * @jls 8.10 Record Types\n * @since 16\n ",
  "links" : [ "java.lang.Object#hashCode()", "java.lang.Object#equals(Object)", "java.lang.Class#getRecordComponents()", "java.lang.Object#toString()", "java.io.Serializable", "java.lang.Class#isRecord()" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : "public abstract boolean equals(Object obj)",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates whether some other object is \"equal to\" this one.  In addition\n     * to the general contract of {@link Object#equals(Object) Object.equals},\n     * record classes must further obey the invariant that when\n     * a record instance is \"copied\" by passing the result of the record component\n     * accessor methods to the canonical constructor, as follows:\n     * <pre>\n     *     R copy = new R(r.c1(), r.c2(), ..., r.cn());\n     * </pre>\n     * then it must be the case that {@code r.equals(copy)}.\n     *\n     * @implSpec\n     * The implicitly provided implementation returns {@code true} if\n     * and only if the argument is an instance of the same record class\n     * as this record, and each component of this record is equal to\n     * the corresponding component of the argument; otherwise, {@code\n     * false} is returned. Equality of a component {@code c} is\n     * determined as follows:\n     * <ul>\n     *\n     * <li> If the component is of a reference type, the component is\n     * considered equal if and only if {@link\n     * java.util.Objects#equals(Object,Object)\n     * Objects.equals(this.c, r.c} would return {@code true}.\n     *\n     * <li> If the component is of a primitive type, using the\n     * corresponding primitive wrapper class {@code PW} (the\n     * corresponding wrapper class for {@code int} is {@code\n     * java.lang.Integer}, and so on), the component is considered\n     * equal if and only if {@code\n     * PW.compare(this.c, r.c)} would return {@code 0}.\n     *\n     * </ul>\n     *\n     * Apart from the semantics described above, the precise algorithm\n     * used in the implicitly provided implementation is unspecified\n     * and is subject to change. The implementation may or may not use\n     * calls to the particular methods listed, and may or may not\n     * perform comparisons in the order of component declaration.\n     *\n     * @see java.util.Objects#equals(Object,Object)\n     *\n     * @param   obj   the reference object with which to compare.\n     * @return  {@code true} if this record is equal to the\n     *          argument; {@code false} otherwise.\n     ",
    "links" : [ "java.util.Objects#equals(Object", "java.lang.Object#equals(Object)" ]
  }, {
    "name" : "public abstract int hashCode()",
    "returnType" : "int",
    "comment" : "\n     * Returns a hash code value for the record.\n     * Obeys the general contract of {@link Object#hashCode Object.hashCode}.\n     * For records, hashing behavior is constrained by the refined contract\n     * of {@link Record#equals Record.equals}, so that any two records\n     * created from the same components must have the same hash code.\n     *\n     * @implSpec\n     * The implicitly provided implementation returns a hash code value derived\n     * by combining appropriate hashes from each component.\n     * The precise algorithm used in the implicitly provided implementation\n     * is unspecified and is subject to change within the above limits.\n     * The resulting integer need not remain consistent from one\n     * execution of an application to another execution of the same\n     * application, even if the hashes of the component values were to\n     * remain consistent in this way.  Also, a component of primitive\n     * type may contribute its bits to the hash code differently than\n     * the {@code hashCode} of its primitive wrapper class.\n     *\n     * @see     Object#hashCode()\n     *\n     * @return  a hash code value for this record.\n     ",
    "links" : [ "java.lang.Object#hashCode", "java.lang.Record#equals" ]
  }, {
    "name" : "public abstract String toString()",
    "returnType" : "String",
    "comment" : "\n     * Returns a string representation of the record.\n     * In accordance with the general contract of {@link Object#toString()},\n     * the {@code toString} method returns a string that\n     * \"textually represents\" this record. The result should\n     * be a concise but informative representation that is easy for a\n     * person to read.\n     * <p>\n     * In addition to this general contract, record classes must further\n     * participate in the invariant that any two records which are\n     * {@linkplain Record#equals(Object) equal} must produce equal\n     * strings.  This invariant is necessarily relaxed in the rare\n     * case where corresponding equal component values might fail\n     * to produce equal strings for themselves.\n     *\n     * @implSpec\n     * The implicitly provided implementation returns a string which\n     * contains the name of the record class, the names of components\n     * of the record, and string representations of component values,\n     * so as to fulfill the contract of this method.\n     * The precise format produced by this implicitly provided implementation\n     * is subject to change, so the present syntax should not be parsed\n     * by applications to recover record component values.\n     *\n     * @see     Object#toString()\n     *\n     * @return  a string representation of the object.\n     ",
    "links" : [ "java.lang.Object#toString()" ]
  } ],
  "methodNames" : [ "public abstract boolean equals(Object obj)", "public abstract int hashCode()", "public abstract String toString()" ],
  "variableNames" : [ ]
}