{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/lang/Runtime.java",
  "packageName" : "java.lang",
  "className" : "Runtime",
  "comment" : "",
  "links" : [ ],
  "variables" : [ {
    "name" : "currentRuntime",
    "type" : "Runtime",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "shutdownHooks",
    "type" : "List<Thread>",
    "comment" : "\n     * Holds the list of threads to run when the VM terminates\n     ",
    "links" : [ ]
  }, {
    "name" : "finalizeOnExit",
    "type" : "boolean",
    "comment" : "\n     * Reflects whether finalization should be run for all objects\n     * when the VM terminates.\n     ",
    "links" : [ ]
  }, {
    "name" : "shuttingDown",
    "type" : "boolean",
    "comment" : "\n     * Reflects whether we are already shutting down the VM.\n     ",
    "links" : [ ]
  }, {
    "name" : "mLibPaths",
    "type" : "String[]",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private static native void nativeExit(int code)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static Runtime getRuntime()",
    "returnType" : "Runtime",
    "comment" : "\n     * Returns the runtime object associated with the current Java application.\n     * Most of the methods of class {@code Runtime} are instance\n     * methods and must be invoked with respect to the current runtime object.\n     *\n     * @return  the {@code Runtime} object associated with the current\n     *          Java application.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void exit(int status)",
    "returnType" : "void",
    "comment" : "\n     * Terminates the currently running Java virtual machine by initiating its\n     * shutdown sequence.  This method never returns normally.  The argument\n     * serves as a status code; by convention, a nonzero status code indicates\n     * abnormal termination.\n     *\n     * <p> All registered {@linkplain #addShutdownHook shutdown hooks}, if any,\n     * are started in some unspecified order and allowed to run concurrently\n     * until they finish.  Once this is done the virtual machine\n     * {@linkplain #halt halts}.\n     *\n     * <p> If this method is invoked after all shutdown hooks have already\n     * been run and the status is nonzero then this method halts the\n     * virtual machine with the given status code. Otherwise, this method\n     * blocks indefinitely.\n     *\n     * <p> The {@link System#exit(int) System.exit} method is the\n     * conventional and convenient means of invoking this method.\n     *\n     * @param  status\n     *         Termination status.  By convention, a nonzero status code\n     *         indicates abnormal termination.\n     *\n     * @throws SecurityException\n     *         If a security manager is present and its\n     *         {@link SecurityManager#checkExit checkExit} method does not permit\n     *         exiting with the specified status\n     *\n     * @see java.lang.SecurityException\n     * @see java.lang.SecurityManager#checkExit(int)\n     * @see #addShutdownHook\n     * @see #removeShutdownHook\n     * @see #halt(int)\n     ",
    "links" : [ "java.lang.System#exit(int)", "java.lang.SecurityManager#checkExit" ]
  }, {
    "name" : "public void addShutdownHook(Thread hook)",
    "returnType" : "void",
    "comment" : "\n     * Registers a new virtual-machine shutdown hook.\n     *\n     * <p> The Java virtual machine <i>shuts down</i> in response to two kinds\n     * of events:\n     *\n     *   <ul>\n     *\n     *   <li> The program <i>exits</i> normally, when the last non-daemon\n     *   thread exits or when the {@link #exit exit} (equivalently,\n     *   {@link System#exit(int) System.exit}) method is invoked, or\n     *\n     *   <li> The virtual machine is <i>terminated</i> in response to a\n     *   user interrupt, such as typing {@code ^C}, or a system-wide event,\n     *   such as user logoff or system shutdown.\n     *\n     *   </ul>\n     *\n     * <p> A <i>shutdown hook</i> is simply an initialized but unstarted\n     * thread.  When the virtual machine begins its shutdown sequence it will\n     * start all registered shutdown hooks in some unspecified order and let\n     * them run concurrently.  When all the hooks have finished it will then\n     * halt. Note that daemon threads will continue to run during the shutdown\n     * sequence, as will non-daemon threads if shutdown was initiated by\n     * invoking the {@link #exit exit} method.\n     *\n     * <p> Once the shutdown sequence has begun it can be stopped only by\n     * invoking the {@link #halt halt} method, which forcibly\n     * terminates the virtual machine.\n     *\n     * <p> Once the shutdown sequence has begun it is impossible to register a\n     * new shutdown hook or de-register a previously-registered hook.\n     * Attempting either of these operations will cause an\n     * {@link IllegalStateException} to be thrown.\n     *\n     * <p> Shutdown hooks run at a delicate time in the life cycle of a virtual\n     * machine and should therefore be coded defensively.  They should, in\n     * particular, be written to be thread-safe and to avoid deadlocks insofar\n     * as possible.  They should also not rely blindly upon services that may\n     * have registered their own shutdown hooks and therefore may themselves in\n     * the process of shutting down.  Attempts to use other thread-based\n     * services such as the AWT event-dispatch thread, for example, may lead to\n     * deadlocks.\n     *\n     * <p> Shutdown hooks should also finish their work quickly.  When a\n     * program invokes {@link #exit exit} the expectation is\n     * that the virtual machine will promptly shut down and exit.  When the\n     * virtual machine is terminated due to user logoff or system shutdown the\n     * underlying operating system may only allow a fixed amount of time in\n     * which to shut down and exit.  It is therefore inadvisable to attempt any\n     * user interaction or to perform a long-running computation in a shutdown\n     * hook.\n     *\n     * <p> Uncaught exceptions are handled in shutdown hooks just as in any\n     * other thread, by invoking the\n     * {@link ThreadGroup#uncaughtException uncaughtException} method of the\n     * thread's {@link ThreadGroup} object. The default implementation of this\n     * method prints the exception's stack trace to {@link System#err} and\n     * terminates the thread; it does not cause the virtual machine to exit or\n     * halt.\n     *\n     * <p> In rare circumstances the virtual machine may <i>abort</i>, that is,\n     * stop running without shutting down cleanly.  This occurs when the\n     * virtual machine is terminated externally, for example with the\n     * {@code SIGKILL} signal on Unix or the {@code TerminateProcess} call on\n     * Microsoft Windows.  The virtual machine may also abort if a native\n     * method goes awry by, for example, corrupting internal data structures or\n     * attempting to access nonexistent memory.  If the virtual machine aborts\n     * then no guarantee can be made about whether or not any shutdown hooks\n     * will be run.\n     *\n     * @param   hook\n     *          An initialized but unstarted {@link Thread} object\n     *\n     * @throws  IllegalArgumentException\n     *          If the specified hook has already been registered,\n     *          or if it can be determined that the hook is already running or\n     *          has already been run\n     *\n     * @throws  IllegalStateException\n     *          If the virtual machine is already in the process\n     *          of shutting down\n     *\n     * @throws  SecurityException\n     *          If a security manager is present and it denies\n     *          {@link RuntimePermission}(\"shutdownHooks\")\n     *\n     * @see #removeShutdownHook\n     * @see #halt(int)\n     * @see #exit(int)\n     * @since 1.3\n     ",
    "links" : [ "java.lang.IllegalStateException", "java.lang.ThreadGroup#uncaughtException", "java.lang.Thread", "#halt", "java.lang.RuntimePermission", "java.lang.System#exit(int)", "java.lang.ThreadGroup", "#exit", "java.lang.System#err" ]
  }, {
    "name" : "public boolean removeShutdownHook(Thread hook)",
    "returnType" : "boolean",
    "comment" : "\n     * De-registers a previously-registered virtual-machine shutdown hook.\n     *\n     * @param hook the hook to remove\n     * @return {@code true} if the specified hook had previously been\n     * registered and was successfully de-registered, {@code false}\n     * otherwise.\n     *\n     * @throws  IllegalStateException\n     *          If the virtual machine is already in the process of shutting\n     *          down\n     *\n     * @throws  SecurityException\n     *          If a security manager is present and it denies\n     *          {@link RuntimePermission}(\"shutdownHooks\")\n     *\n     * @see #addShutdownHook\n     * @see #exit(int)\n     * @since 1.3\n     ",
    "links" : [ "java.lang.RuntimePermission" ]
  }, {
    "name" : "public void halt(int status)",
    "returnType" : "void",
    "comment" : "\n     * Forcibly terminates the currently running Java virtual machine.  This\n     * method never returns normally.\n     *\n     * <p> This method should be used with extreme caution.  Unlike the\n     * {@link #exit exit} method, this method does not cause shutdown\n     * hooks to be started.  If the shutdown sequence has already been\n     * initiated then this method does not wait for any running\n     * shutdown hooks to finish their work.\n     *\n     * @param  status\n     *         Termination status. By convention, a nonzero status code\n     *         indicates abnormal termination. If the {@link Runtime#exit exit}\n     *         (equivalently, {@link System#exit(int) System.exit}) method\n     *         has already been invoked then this status code\n     *         will override the status code passed to that method.\n     *\n     * @throws SecurityException\n     *         If a security manager is present and its\n     *         {@link SecurityManager#checkExit checkExit} method\n     *         does not permit an exit with the specified status\n     *\n     * @see #exit\n     * @see #addShutdownHook\n     * @see #removeShutdownHook\n     * @since 1.3\n     ",
    "links" : [ "dalvik.system.VMRuntime#exit", "java.lang.System#exit(int)", "#exit", "java.lang.SecurityManager#checkExit" ]
  }, {
    "name" : "public static void runFinalizersOnExit(boolean value)",
    "returnType" : "void",
    "comment" : "\n     * Enable or disable finalization on exit; doing so specifies that the\n     * finalizers of all objects that have finalizers that have not yet been\n     * automatically invoked are to be run before the Java runtime exits.\n     * By default, finalization on exit is disabled.\n     *\n     * <p>If there is a security manager,\n     * its <code>checkExit</code> method is first called\n     * with 0 as its argument to ensure the exit is allowed.\n     * This could result in a SecurityException.\n     *\n     * @param value true to enable finalization on exit, false to disable\n     * @deprecated  This method is inherently unsafe.  It may result in\n     *      finalizers being called on live objects while other threads are\n     *      concurrently manipulating those objects, resulting in erratic\n     *      behavior or deadlock.\n     *\n     * @throws  SecurityException\n     *        if a security manager exists and its <code>checkExit</code>\n     *        method doesn't allow the exit.\n     *\n     * @see     java.lang.Runtime#exit(int)\n     * @see     java.lang.Runtime#gc()\n     * @see     java.lang.SecurityManager#checkExit(int)\n     * @since   JDK1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "public Process exec(String command) throws IOException",
    "returnType" : "Process",
    "comment" : "\n     * Executes the specified string command in a separate process.\n     *\n     * <p>This is a convenience method.  An invocation of the form\n     * {@code exec(command)}\n     * behaves in exactly the same way as the invocation\n     * {@link #exec(String, String[], File) exec}{@code (command, null, null)}.\n     *\n     * @param   command   a specified system command.\n     *\n     * @return  A new {@link Process} object for managing the subprocess\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its\n     *          {@link SecurityManager#checkExec checkExec}\n     *          method doesn't allow creation of the subprocess\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  NullPointerException\n     *          If {@code command} is {@code null}\n     *\n     * @throws  IllegalArgumentException\n     *          If {@code command} is empty\n     *\n     * @see     #exec(String[], String[], File)\n     * @see     ProcessBuilder\n     ",
    "links" : [ "java.lang.Process", "#exec(String", "java.lang.SecurityManager#checkExec" ]
  }, {
    "name" : "public Process exec(String command, String[] envp) throws IOException",
    "returnType" : "Process",
    "comment" : "\n     * Executes the specified string command in a separate process with the\n     * specified environment.\n     *\n     * <p>This is a convenience method.  An invocation of the form\n     * {@code exec(command, envp)}\n     * behaves in exactly the same way as the invocation\n     * {@link #exec(String, String[], File) exec}{@code (command, envp, null)}.\n     *\n     * @param   command   a specified system command.\n     *\n     * @param   envp      array of strings, each element of which\n     *                    has environment variable settings in the format\n     *                    <i>name</i>=<i>value</i>, or\n     *                    {@code null} if the subprocess should inherit\n     *                    the environment of the current process.\n     *\n     * @return  A new {@link Process} object for managing the subprocess\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its\n     *          {@link SecurityManager#checkExec checkExec}\n     *          method doesn't allow creation of the subprocess\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  NullPointerException\n     *          If {@code command} is {@code null},\n     *          or one of the elements of {@code envp} is {@code null}\n     *\n     * @throws  IllegalArgumentException\n     *          If {@code command} is empty\n     *\n     * @see     #exec(String[], String[], File)\n     * @see     ProcessBuilder\n     ",
    "links" : [ "java.lang.Process", "#exec(String", "java.lang.SecurityManager#checkExec" ]
  }, {
    "name" : "public Process exec(String command, String[] envp, File dir) throws IOException",
    "returnType" : "Process",
    "comment" : "\n     * Executes the specified string command in a separate process with the\n     * specified environment and working directory.\n     *\n     * <p>This is a convenience method.  An invocation of the form\n     * {@code exec(command, envp, dir)}\n     * behaves in exactly the same way as the invocation\n     * {@link #exec(String[], String[], File) exec}{@code (cmdarray, envp, dir)},\n     * where {@code cmdarray} is an array of all the tokens in\n     * {@code command}.\n     *\n     * <p>More precisely, the {@code command} string is broken\n     * into tokens using a {@link StringTokenizer} created by the call\n     * {@code new {@link StringTokenizer}(command)} with no\n     * further modification of the character categories.  The tokens\n     * produced by the tokenizer are then placed in the new string\n     * array {@code cmdarray}, in the same order.\n     *\n     * @param   command   a specified system command.\n     *\n     * @param   envp      array of strings, each element of which\n     *                    has environment variable settings in the format\n     *                    <i>name</i>=<i>value</i>, or\n     *                    {@code null} if the subprocess should inherit\n     *                    the environment of the current process.\n     *\n     * @param   dir       the working directory of the subprocess, or\n     *                    {@code null} if the subprocess should inherit\n     *                    the working directory of the current process.\n     *\n     * @return  A new {@link Process} object for managing the subprocess\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its\n     *          {@link SecurityManager#checkExec checkExec}\n     *          method doesn't allow creation of the subprocess\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  NullPointerException\n     *          If {@code command} is {@code null},\n     *          or one of the elements of {@code envp} is {@code null}\n     *\n     * @throws  IllegalArgumentException\n     *          If {@code command} is empty\n     *\n     * @see     ProcessBuilder\n     * @since 1.3\n     ",
    "links" : [ "java.lang.Process", "java.util.StringTokenizer", "#exec(String", "java.lang.SecurityManager#checkExec" ]
  }, {
    "name" : "public Process exec(String[] cmdarray) throws IOException",
    "returnType" : "Process",
    "comment" : "\n     * Executes the specified command and arguments in a separate process.\n     *\n     * <p>This is a convenience method.  An invocation of the form\n     * {@code exec(cmdarray)}\n     * behaves in exactly the same way as the invocation\n     * {@link #exec(String[], String[], File) exec}{@code (cmdarray, null, null)}.\n     *\n     * @param   cmdarray  array containing the command to call and\n     *                    its arguments.\n     *\n     * @return  A new {@link Process} object for managing the subprocess\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its\n     *          {@link SecurityManager#checkExec checkExec}\n     *          method doesn't allow creation of the subprocess\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  NullPointerException\n     *          If {@code cmdarray} is {@code null},\n     *          or one of the elements of {@code cmdarray} is {@code null}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code cmdarray} is an empty array\n     *          (has length {@code 0})\n     *\n     * @see     ProcessBuilder\n     ",
    "links" : [ "java.lang.Process", "#exec(String", "java.lang.SecurityManager#checkExec" ]
  }, {
    "name" : "public Process exec(String[] cmdarray, String[] envp) throws IOException",
    "returnType" : "Process",
    "comment" : "\n     * Executes the specified command and arguments in a separate process\n     * with the specified environment.\n     *\n     * <p>This is a convenience method.  An invocation of the form\n     * {@code exec(cmdarray, envp)}\n     * behaves in exactly the same way as the invocation\n     * {@link #exec(String[], String[], File) exec}{@code (cmdarray, envp, null)}.\n     *\n     * @param   cmdarray  array containing the command to call and\n     *                    its arguments.\n     *\n     * @param   envp      array of strings, each element of which\n     *                    has environment variable settings in the format\n     *                    <i>name</i>=<i>value</i>, or\n     *                    {@code null} if the subprocess should inherit\n     *                    the environment of the current process.\n     *\n     * @return  A new {@link Process} object for managing the subprocess\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its\n     *          {@link SecurityManager#checkExec checkExec}\n     *          method doesn't allow creation of the subprocess\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  NullPointerException\n     *          If {@code cmdarray} is {@code null},\n     *          or one of the elements of {@code cmdarray} is {@code null},\n     *          or one of the elements of {@code envp} is {@code null}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code cmdarray} is an empty array\n     *          (has length {@code 0})\n     *\n     * @see     ProcessBuilder\n     ",
    "links" : [ "java.lang.Process", "#exec(String", "java.lang.SecurityManager#checkExec" ]
  }, {
    "name" : "public Process exec(String[] cmdarray, String[] envp, File dir) throws IOException",
    "returnType" : "Process",
    "comment" : "\n     * Executes the specified command and arguments in a separate process with\n     * the specified environment and working directory.\n     *\n     * <p>Given an array of strings {@code cmdarray}, representing the\n     * tokens of a command line, and an array of strings {@code envp},\n     * representing \"environment\" variable settings, this method creates\n     * a new process in which to execute the specified command.\n     *\n     * <p>This method checks that {@code cmdarray} is a valid operating\n     * system command.  Which commands are valid is system-dependent,\n     * but at the very least the command must be a non-empty list of\n     * non-null strings.\n     *\n     * <p>If {@code envp} is {@code null}, the subprocess inherits the\n     * environment settings of the current process.\n     *\n     * <p>A minimal set of system dependent environment variables may\n     * be required to start a process on some operating systems.\n     * As a result, the subprocess may inherit additional environment variable\n     * settings beyond those in the specified environment.\n     *\n     * <p>{@link ProcessBuilder#start()} is now the preferred way to\n     * start a process with a modified environment.\n     *\n     * <p>The working directory of the new subprocess is specified by {@code dir}.\n     * If {@code dir} is {@code null}, the subprocess inherits the\n     * current working directory of the current process.\n     *\n     * <p>If a security manager exists, its\n     * {@link SecurityManager#checkExec checkExec}\n     * method is invoked with the first component of the array\n     * {@code cmdarray} as its argument. This may result in a\n     * {@link SecurityException} being thrown.\n     *\n     * <p>Starting an operating system process is highly system-dependent.\n     * Among the many things that can go wrong are:\n     * <ul>\n     * <li>The operating system program file was not found.\n     * <li>Access to the program file was denied.\n     * <li>The working directory does not exist.\n     * </ul>\n     *\n     * <p>In such cases an exception will be thrown.  The exact nature\n     * of the exception is system-dependent, but it will always be a\n     * subclass of {@link IOException}.\n     *\n     * <p>If the operating system does not support the creation of\n     * processes, an {@link UnsupportedOperationException} will be thrown.\n     *\n     *\n     * @param   cmdarray  array containing the command to call and\n     *                    its arguments.\n     *\n     * @param   envp      array of strings, each element of which\n     *                    has environment variable settings in the format\n     *                    <i>name</i>=<i>value</i>, or\n     *                    {@code null} if the subprocess should inherit\n     *                    the environment of the current process.\n     *\n     * @param   dir       the working directory of the subprocess, or\n     *                    {@code null} if the subprocess should inherit\n     *                    the working directory of the current process.\n     *\n     * @return  A new {@link Process} object for managing the subprocess\n     *\n     * @throws  SecurityException\n     *          If a security manager exists and its\n     *          {@link SecurityManager#checkExec checkExec}\n     *          method doesn't allow creation of the subprocess\n     *\n     * @throws  UnsupportedOperationException\n     *          If the operating system does not support the creation of processes.\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  NullPointerException\n     *          If {@code cmdarray} is {@code null},\n     *          or one of the elements of {@code cmdarray} is {@code null},\n     *          or one of the elements of {@code envp} is {@code null}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code cmdarray} is an empty array\n     *          (has length {@code 0})\n     *\n     * @see     ProcessBuilder\n     * @since 1.3\n     ",
    "links" : [ "java.lang.UnsupportedOperationException", "java.lang.Process", "java.lang.ProcessBuilder#start()", "java.lang.SecurityException", "IOException", "java.lang.SecurityManager#checkExec" ]
  }, {
    "name" : "public int availableProcessors()",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of processors available to the Java virtual machine.\n     *\n     * <p> This value may change during a particular invocation of the virtual\n     * machine.  Applications that are sensitive to the number of available\n     * processors should therefore occasionally poll this property and adjust\n     * their resource usage appropriately. </p>\n     *\n     * @return  the maximum number of processors available to the virtual\n     *          machine; never smaller than one\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "public native long freeMemory()",
    "returnType" : "long",
    "comment" : "\n     * Returns the amount of free memory in the Java Virtual Machine.\n     * Calling the\n     * {@code gc} method may result in increasing the value returned\n     * by {@code freeMemory.}\n     *\n     * @return  an approximation to the total amount of memory currently\n     *          available for future allocated objects, measured in bytes.\n     ",
    "links" : [ ]
  }, {
    "name" : "public native long totalMemory()",
    "returnType" : "long",
    "comment" : "\n     * Returns the total amount of memory in the Java virtual machine.\n     * The value returned by this method may vary over time, depending on\n     * the host environment.\n     * <p>\n     * Note that the amount of memory required to hold an object of any\n     * given type may be implementation-dependent.\n     *\n     * @return  the total amount of memory currently available for current\n     *          and future objects, measured in bytes.\n     ",
    "links" : [ ]
  }, {
    "name" : "public native long maxMemory()",
    "returnType" : "long",
    "comment" : "\n     * Returns the maximum amount of memory that the Java virtual machine\n     * will attempt to use.  If there is no inherent limit then the value\n     * {@link java.lang.Long#MAX_VALUE} will be returned.\n     *\n     * @return  the maximum amount of memory that the virtual machine will\n     *          attempt to use, measured in bytes\n     * @since 1.4\n     ",
    "links" : [ "java.lang.Long#MAX_VALUE" ]
  }, {
    "name" : "public void gc()",
    "returnType" : "void",
    "comment" : " public native void gc();",
    "links" : [ ]
  }, {
    "name" : "private native void nativeGc()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void runFinalization()",
    "returnType" : "void",
    "comment" : "\n     * Runs the finalization methods of any objects pending finalization.\n     * Calling this method suggests that the Java virtual machine expend\n     * effort toward running the {@code finalize} methods of objects\n     * that have been found to be discarded but whose {@code finalize}\n     * methods have not yet been run. When control returns from the\n     * method call, the virtual machine has made a best effort to\n     * complete all outstanding finalizations.\n     * <p>\n     * The virtual machine performs the finalization process\n     * automatically as needed, in a separate thread, if the\n     * {@code runFinalization} method is not invoked explicitly.\n     * <p>\n     * The method {@link System#runFinalization()} is the conventional\n     * and convenient means of invoking this method.\n     *\n     * @see     java.lang.Object#finalize()\n     ",
    "links" : [ "java.lang.System#runFinalization()" ]
  }, {
    "name" : "public void traceInstructions(boolean on)",
    "returnType" : "void",
    "comment" : "\n     * Not implemented, does nothing.\n     *\n     * @deprecated\n     * This method was intended to control instruction tracing.\n     * It has been superseded by ART-specific tracing mechanisms.\n     *\n     * @param on ignored\n     ",
    "links" : [ ]
  }, {
    "name" : "public void traceMethodCalls(boolean on)",
    "returnType" : "void",
    "comment" : "\n     * Not implemented, does nothing.\n     * <p>\n     * Calling this method on Android Lollipop or later (API level >= 21)\n     * with {@code true} argument will cause it to throw an\n     * {@code UnsupportedOperationException}.\n     *\n     * @deprecated\n     * This method was intended to control method call tracing.\n     * It has been superseded by ART-specific tracing mechanisms.\n     *\n     * @param on ignored\n     ",
    "links" : [ ]
  }, {
    "name" : "public void load(String filename)",
    "returnType" : "void",
    "comment" : "\n     * Loads the native library specified by the filename argument.  The filename\n     * argument must be an absolute path name.\n     * (for example\n     * {@code Runtime.getRuntime().load(\"/home/avh/lib/libX11.so\");}).\n     *\n     * If the filename argument, when stripped of any platform-specific library\n     * prefix, path, and file extension, indicates a library whose name is,\n     * for example, L, and a native library called L is statically linked\n     * with the VM, then the JNI_OnLoad_L function exported by the library\n     * is invoked rather than attempting to load a dynamic library.\n     * A filename matching the argument does not have to exist in the file\n     * system.\n     * See the <a href=\"{@docRoot}/../specs/jni/index.html\"> JNI Specification</a>\n     * for more details.\n     *\n     * Otherwise, the filename argument is mapped to a native library image in\n     * an implementation-dependent manner.\n     * <p>\n     * First, if there is a security manager, its {@code checkLink}\n     * method is called with the {@code filename} as its argument.\n     * This may result in a security exception.\n     * <p>\n     * This is similar to the method {@link #loadLibrary(String)}, but it\n     * accepts a general file name as an argument rather than just a library\n     * name, allowing any file of native code to be loaded.\n     * <p>\n     * The method {@link System#load(String)} is the conventional and\n     * convenient means of invoking this method.\n     *\n     * @param      filename   the file to load.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn't allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError  if either the filename is not an\n     *             absolute path name, the native library is not statically\n     *             linked with the VM, or the library cannot be mapped to\n     *             a native library image by the host system.\n     * @throws     NullPointerException if {@code filename} is\n     *             {@code null}\n     * @see        java.lang.Runtime#getRuntime()\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     ",
    "links" : [ "java.lang.System#load(String)", "#loadLibrary(String)" ]
  }, {
    "name" : "private void checkTargetSdkVersionForLoad(String methodName)",
    "returnType" : "void",
    "comment" : " Check target sdk, if it's higher than N, we throw an UnsupportedOperationException ",
    "links" : [ ]
  }, {
    "name" : " void load(String absolutePath, ClassLoader loader)",
    "returnType" : "void",
    "comment" : " Fixes b/25859957 regression. Depending on private methods is bad, mkay.",
    "links" : [ ]
  }, {
    "name" : " synchronized void load0(Class<?> fromClass, String filename)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void loadLibrary(String libname)",
    "returnType" : "void",
    "comment" : "\n     * Loads the native library specified by the {@code libname}\n     * argument.  The {@code libname} argument must not contain any platform\n     * specific prefix, file extension or path. If a native library\n     * called {@code libname} is statically linked with the VM, then the\n     * JNI_OnLoad_{@code libname} function exported by the library is invoked.\n     * See the <a href=\"{@docRoot}/../specs/jni/index.html\"> JNI Specification</a>\n     * for more details.\n     *\n     * Otherwise, the libname argument is loaded from a system library\n     * location and mapped to a native library image in an implementation-\n     * dependent manner.\n     * <p>\n     * First, if there is a security manager, its {@code checkLink}\n     * method is called with the {@code libname} as its argument.\n     * This may result in a security exception.\n     * <p>\n     * The method {@link System#loadLibrary(String)} is the conventional\n     * and convenient means of invoking this method. If native\n     * methods are to be used in the implementation of a class, a standard\n     * strategy is to put the native code in a library file (call it\n     * {@code LibFile}) and then to put a static initializer:\n     * <blockquote><pre>\n     * static { System.loadLibrary(\"LibFile\"); }\n     * </pre></blockquote>\n     * within the class declaration. When the class is loaded and\n     * initialized, the necessary native code implementation for the native\n     * methods will then be loaded as well.\n     * <p>\n     * If this method is called more than once with the same library\n     * name, the second and subsequent calls are ignored.\n     *\n     * @param      libname   the name of the library.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn't allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError if either the libname argument\n     *             contains a file path, the native library is not statically\n     *             linked with the VM,  or the library cannot be mapped to a\n     *             native library image by the host system.\n     * @throws     NullPointerException if {@code libname} is\n     *             {@code null}\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     ",
    "links" : [ "java.lang.System#loadLibrary(String)" ]
  }, {
    "name" : " void loadLibrary0(Class<?> fromClass, String libname)",
    "returnType" : "void",
    "comment" : "\n    synchronized void loadLibrary0(Class<?> fromClass, String libname) {\n        SecurityManager security = System.getSecurityManager();\n        if (security != null) {\n            security.checkLink(libname);\n        }\n        if (libname.indexOf((int)File.separatorChar) != -1) {\n            throw new UnsatisfiedLinkError(\n    \"Directory separator should not appear in library name: \" + libname);\n        }\n        ClassLoader.loadLibrary(fromClass, libname, false);\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : "public void loadLibrary(String libname, ClassLoader classLoader)",
    "returnType" : "void",
    "comment" : "\n     * Temporarily preserved for backward compatibility. Applications call this\n     * method using reflection.\n     *\n     * **** THIS METHOD WILL BE REMOVED IN A FUTURE ANDROID VERSION ****\n     *\n     * http://b/26217329\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " void loadLibrary0(ClassLoader loader, String libname)",
    "returnType" : "void",
    "comment" : " This overload exists for @UnsupportedAppUsage",
    "links" : [ ]
  }, {
    "name" : "private synchronized void loadLibrary0(ClassLoader loader, Class<?> callerClass, String libname)",
    "returnType" : "void",
    "comment" : "\n     * Loads the shared library {@code libname} in the context of {@code loader} and\n     * {@code callerClass}.\n     *\n     * @param      loader the class loader that initiated the loading. Used by the\n     *             underlying linker to determine linker namespace. A {@code null}\n     *             value represents the boot class loader.\n     * @param      callerClass the class that initiated the loading. When not\n     *             {@code null}, it is also used to determine the linker\n     *             namespace from the class's dex file location (which is in an\n     *             apk or dex jar).\n     * @param      libname the name of the library.\n     ",
    "links" : [ ]
  }, {
    "name" : "private String[] getLibPaths()",
    "returnType" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static String[] initLibPaths()",
    "returnType" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static String nativeLoad(String filename, ClassLoader loader)",
    "returnType" : "String",
    "comment" : " This method is used through reflection from /art/test/150-loadlibrary.",
    "links" : [ ]
  }, {
    "name" : "private static native String nativeLoad(String filename, ClassLoader loader, Class<?> caller)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public InputStream getLocalizedInputStream(InputStream in)",
    "returnType" : "InputStream",
    "comment" : "\n     * Creates a localized version of an input stream. This method takes\n     * an <code>InputStream</code> and returns an <code>InputStream</code>\n     * equivalent to the argument in all respects except that it is\n     * localized: as characters in the local character set are read from\n     * the stream, they are automatically converted from the local\n     * character set to Unicode.\n     * <p>\n     * If the argument is already a localized stream, it may be returned\n     * as the result.\n     *\n     * @param      in InputStream to localize\n     * @return     a localized input stream\n     * @see        java.io.InputStream\n     * @see        java.io.BufferedReader#BufferedReader(java.io.Reader)\n     * @see        java.io.InputStreamReader#InputStreamReader(java.io.InputStream)\n     * @removed As of JDK&nbsp;1.1, the preferred way to translate a byte\n     * stream in the local encoding into a character stream in Unicode is via\n     * the <code>InputStreamReader</code> and <code>BufferedReader</code>\n     * classes.\n     ",
    "links" : [ ]
  }, {
    "name" : "public OutputStream getLocalizedOutputStream(OutputStream out)",
    "returnType" : "OutputStream",
    "comment" : "\n     * Creates a localized version of an output stream. This method\n     * takes an <code>OutputStream</code> and returns an\n     * <code>OutputStream</code> equivalent to the argument in all respects\n     * except that it is localized: as Unicode characters are written to\n     * the stream, they are automatically converted to the local\n     * character set.\n     * <p>\n     * If the argument is already a localized stream, it may be returned\n     * as the result.\n     *\n     * @removed As of JDK&nbsp;1.1, the preferred way to translate a\n     * Unicode character stream into a byte stream in the local encoding is via\n     * the <code>OutputStreamWriter</code>, <code>BufferedWriter</code>, and\n     * <code>PrintWriter</code> classes.\n     *\n     * @param      out OutputStream to localize\n     * @return     a localized output stream\n     * @see        java.io.OutputStream\n     * @see        java.io.BufferedWriter#BufferedWriter(java.io.Writer)\n     * @see        java.io.OutputStreamWriter#OutputStreamWriter(java.io.OutputStream)\n     * @see        java.io.PrintWriter#PrintWriter(java.io.OutputStream)\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "private static native void nativeExit(int code)", "public static Runtime getRuntime()", "public void exit(int status)", "public void addShutdownHook(Thread hook)", "public boolean removeShutdownHook(Thread hook)", "public void halt(int status)", "public static void runFinalizersOnExit(boolean value)", "public Process exec(String command) throws IOException", "public Process exec(String command, String[] envp) throws IOException", "public Process exec(String command, String[] envp, File dir) throws IOException", "public Process exec(String[] cmdarray) throws IOException", "public Process exec(String[] cmdarray, String[] envp) throws IOException", "public Process exec(String[] cmdarray, String[] envp, File dir) throws IOException", "public int availableProcessors()", "public native long freeMemory()", "public native long totalMemory()", "public native long maxMemory()", "public void gc()", "private native void nativeGc()", "public void runFinalization()", "public void traceInstructions(boolean on)", "public void traceMethodCalls(boolean on)", "public void load(String filename)", "private void checkTargetSdkVersionForLoad(String methodName)", " void load(String absolutePath, ClassLoader loader)", " synchronized void load0(Class<?> fromClass, String filename)", "public void loadLibrary(String libname)", " void loadLibrary0(Class<?> fromClass, String libname)", "public void loadLibrary(String libname, ClassLoader classLoader)", " void loadLibrary0(ClassLoader loader, String libname)", "private synchronized void loadLibrary0(ClassLoader loader, Class<?> callerClass, String libname)", "private String[] getLibPaths()", "private static String[] initLibPaths()", "private static String nativeLoad(String filename, ClassLoader loader)", "private static native String nativeLoad(String filename, ClassLoader loader, Class<?> caller)", "public InputStream getLocalizedInputStream(InputStream in)", "public OutputStream getLocalizedOutputStream(OutputStream out)" ],
  "variableNames" : [ "currentRuntime", "shutdownHooks", "finalizeOnExit", "shuttingDown", "mLibPaths" ]
}