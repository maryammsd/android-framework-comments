{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/content/pm/PackageInstaller.java",
  "packageName" : "android.content.pm",
  "className" : "SessionParams",
  "comment" : "\n     * Parameters for creating a new {@link PackageInstaller.Session}.\n     ",
  "links" : [ "PackageInstaller.Session" ],
  "variables" : [ {
    "name" : "MODE_INVALID",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "MODE_FULL_INSTALL",
    "type" : "int",
    "comment" : "\n         * Mode for an install session whose staged APKs should fully replace any\n         * existing APKs for the target app.\n         ",
    "links" : [ ]
  }, {
    "name" : "MODE_INHERIT_EXISTING",
    "type" : "int",
    "comment" : "\n         * Mode for an install session that should inherit any existing APKs for the\n         * target app, unless they have been explicitly overridden (based on split\n         * name) by the session. For example, this can be used to add one or more\n         * split APKs to an existing installation.\n         * <p>\n         * If there are no existing APKs for the target app, this behaves like\n         * {@link #MODE_FULL_INSTALL}.\n         ",
    "links" : [ "#MODE_FULL_INSTALL" ]
  }, {
    "name" : "RESTRICTED_PERMISSIONS_ALL",
    "type" : "Set<String>",
    "comment" : "\n         * Special constant to refer to all restricted permissions.\n         ",
    "links" : [ ]
  }, {
    "name" : "UID_UNKNOWN",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "MAX_PACKAGE_NAME_LENGTH",
    "type" : "int",
    "comment" : "\n         * This value is derived from the maximum file name length. No package above this limit\n         * can ever be successfully installed on the device.\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "USER_ACTION_UNSPECIFIED",
    "type" : "int",
    "comment" : "\n         * This value is passed by the installer to {@link SessionParams#setRequireUserAction(int)}\n         * to indicate that user action is unspecified for this install.\n         * {@code requireUserAction} also defaults to this value unless modified by\n         * {@link SessionParams#setRequireUserAction(int)}\n         ",
    "links" : [ "#setRequireUserAction(int)" ]
  }, {
    "name" : "USER_ACTION_REQUIRED",
    "type" : "int",
    "comment" : "\n         * This value is passed by the installer to {@link SessionParams#setRequireUserAction(int)}\n         * to indicate that user action is required for this install.\n         ",
    "links" : [ "#setRequireUserAction(int)" ]
  }, {
    "name" : "USER_ACTION_NOT_REQUIRED",
    "type" : "int",
    "comment" : "\n         * This value is passed by the installer to {@link SessionParams#setRequireUserAction(int)}\n         * to indicate that user action is not required for this install.\n         ",
    "links" : [ "#setRequireUserAction(int)" ]
  }, {
    "name" : "PERMISSION_STATE_DEFAULT",
    "type" : "int",
    "comment" : "\n         * Value is passed by the installer to {@link #setPermissionState(String, int)} to set\n         * the state of a permission. This indicates no preference by the installer, relying on\n         * the device's default policy to set the grant state of the permission.\n         ",
    "links" : [ "#setPermissionState(String" ]
  }, {
    "name" : "PERMISSION_STATE_GRANTED",
    "type" : "int",
    "comment" : "\n         * Value is passed by the installer to {@link #setPermissionState(String, int)} to set\n         * the state of a permission. This indicates the installers wants to automatically grant\n         * the permission to the package being installed. The user and other actors in the system\n         * may still be able to deny the permission after installation.\n         ",
    "links" : [ "#setPermissionState(String" ]
  }, {
    "name" : "PERMISSION_STATE_DENIED",
    "type" : "int",
    "comment" : "\n         * Value is passed by the installer to {@link #setPermissionState(String, int)} to set\n         * the state of a permission. This indicates the installers wants to deny the permission\n         * by default to the package being installed. The user and other actors in the system may\n         * still be able to grant the permission after installation.\n         ",
    "links" : [ "#setPermissionState(String" ]
  }, {
    "name" : "mode",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "installFlags",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "installLocation",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "installReason",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "installScenario",
    "type" : "int",
    "comment" : "\n         * {@hide}\n         *\n         * This flag indicates which installation scenario best describes this session.  The system\n         * may use this value when making decisions about how to handle the installation, such as\n         * prioritizing system health or user experience.\n         ",
    "links" : [ ]
  }, {
    "name" : "sizeBytes",
    "type" : "long",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "appPackageName",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "appIcon",
    "type" : "Bitmap",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "appLabel",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "appIconLastModified",
    "type" : "long",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "originatingUri",
    "type" : "Uri",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "originatingUid",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "referrerUri",
    "type" : "Uri",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "abiOverride",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "volumeUuid",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "whitelistedRestrictedPermissions",
    "type" : "List<String>",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "autoRevokePermissionsMode",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "installerPackageName",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "isMultiPackage",
    "type" : "boolean",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "packageSource",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "isStaged",
    "type" : "boolean",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "requiredInstalledVersionCode",
    "type" : "long",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "dataLoaderParams",
    "type" : "DataLoaderParams",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "rollbackDataPolicy",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "rollbackLifetimeMillis",
    "type" : "long",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "rollbackImpactLevel",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "forceQueryableOverride",
    "type" : "boolean",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "requireUserAction",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "applicationEnabledSettingPersistent",
    "type" : "boolean",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "developmentInstallFlags",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "unarchiveId",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "mPermissionStates",
    "type" : "ArrayMap<String, Integer>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CREATOR",
    "type" : "Parcelable.Creator<SessionParams>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public SessionParams copy()",
    "returnType" : "SessionParams",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public boolean areHiddenOptionsSet()",
    "returnType" : "boolean",
    "comment" : "\n         * Check if there are hidden options set.\n         *\n         * <p>Hidden options are those options that cannot be verified via public or system-api\n         * methods on {@link SessionInfo}.\n         *\n         * @return {@code true} if any hidden option is set.\n         *\n         * @hide\n         ",
    "links" : [ "SessionInfo" ]
  }, {
    "name" : "public void setInstallLocation(int installLocation)",
    "returnType" : "void",
    "comment" : "\n         * Provide value of {@link PackageInfo#installLocation}, which may be used\n         * to determine where the app will be staged. Defaults to\n         * {@link PackageInfo#INSTALL_LOCATION_INTERNAL_ONLY}.\n         ",
    "links" : [ "android.content.pm.PackageInfo#installLocation", "android.content.pm.PackageInfo#INSTALL_LOCATION_INTERNAL_ONLY" ]
  }, {
    "name" : "public void setSize(long sizeBytes)",
    "returnType" : "void",
    "comment" : "\n         * Optionally indicate the total size (in bytes) of all APKs that will be\n         * delivered in this session. The system may use this to ensure enough disk\n         * space exists before proceeding, or to estimate container size for\n         * installations living on external storage.\n         *\n         * @see PackageInfo#INSTALL_LOCATION_AUTO\n         * @see PackageInfo#INSTALL_LOCATION_PREFER_EXTERNAL\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setAppPackageName(@Nullable String appPackageName)",
    "returnType" : "void",
    "comment" : "\n         * Optionally set the package name of the app being installed. It's strongly\n         * recommended that you provide this value when known, so that observers can\n         * communicate installing apps to users.\n         * <p>\n         * If the APKs staged in the session aren't consistent with this package\n         * name, the install will fail. Regardless of this value, all APKs in the\n         * app must have the same package name.\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setAppIcon(@Nullable Bitmap appIcon)",
    "returnType" : "void",
    "comment" : "\n         * Optionally set an icon representing the app being installed. This should\n         * be roughly {@link ActivityManager#getLauncherLargeIconSize()} in both\n         * dimensions.\n         ",
    "links" : [ "android.app.ActivityManager#getLauncherLargeIconSize()" ]
  }, {
    "name" : "public void setAppLabel(@Nullable CharSequence appLabel)",
    "returnType" : "void",
    "comment" : "\n         * Optionally set a label representing the app being installed.\n         *\n         * This value will be trimmed to the first 1000 characters.\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setOriginatingUri(@Nullable Uri originatingUri)",
    "returnType" : "void",
    "comment" : "\n         * Optionally set the URI where this package was downloaded from. This is\n         * informational and may be used as a signal for anti-malware purposes.\n         *\n         * @see Intent#EXTRA_ORIGINATING_URI\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setOriginatingUid(int originatingUid)",
    "returnType" : "void",
    "comment" : "\n         * Sets the UID that initiated the package installation. This is informational\n         * and may be used as a signal for anti-malware purposes.\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setReferrerUri(@Nullable Uri referrerUri)",
    "returnType" : "void",
    "comment" : "\n         * Optionally set the URI that referred you to install this package. This is\n         * informational and may be used as a signal for anti-malware purposes.\n         *\n         * @see Intent#EXTRA_REFERRER\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setGrantedRuntimePermissions(String[] permissions)",
    "returnType" : "void",
    "comment" : "\n         * Sets which runtime permissions to be granted to the package at installation.\n         *\n         * @param permissions The permissions to grant or null to grant all runtime\n         *     permissions.\n         *\n         * @deprecated Prefer {@link #setPermissionState(String, int)} instead starting in\n         * {@link Build.VERSION_CODES#UPSIDE_DOWN_CAKE}.\n         * @hide\n         ",
    "links" : [ "Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "#setPermissionState(String" ]
  }, {
    "name" : "public SessionParams setPermissionState(@NonNull String permissionName, @PermissionState int state)",
    "returnType" : "SessionParams",
    "comment" : "\n         * Sets the state of permissions for the package at installation.\n         * <p/>\n         * Granting any runtime permissions require the\n         * {@code android.Manifest.permission#INSTALL_GRANT_RUNTIME_PERMISSIONS}\n         * permission to be held by the caller. Revoking runtime\n         * permissions is not allowed, even during app update sessions.\n         * <p/>\n         * Holders without the permission are allowed to change the following special permissions:\n         * <p/>\n         * On platform {@link Build.VERSION_CODES#UPSIDE_DOWN_CAKE UPSIDE_DOWN_CAKE}:\n         * <ul>\n         *     <li>{@link Manifest.permission#USE_FULL_SCREEN_INTENT}</li>\n         * </ul>\n         * Install time permissions, which cannot be revoked by the user, cannot be changed by the\n         * installer.\n         * <p/>\n         * See <a href=\"https://developer.android.com/guide/topics/permissions/overview\">\n         * Permissions on Android</a> for more information.\n         *\n         * @param permissionName The permission to change state for.\n         * @param state          Either {@link #PERMISSION_STATE_DEFAULT},\n         *                       {@link #PERMISSION_STATE_GRANTED},\n         *                       or {@link #PERMISSION_STATE_DENIED} to set the permission to.\n         *\n         * @return This object for easier chaining.\n         ",
    "links" : [ "Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "#PERMISSION_STATE_DENIED", "Manifest.permission#USE_FULL_SCREEN_INTENT", "#PERMISSION_STATE_GRANTED", "#PERMISSION_STATE_DEFAULT" ]
  }, {
    "name" : "public void setPermissionStates(Collection<String> grantPermissions, Collection<String> denyPermissions)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void setPackageSource(@PackageSourceType int packageSource)",
    "returnType" : "void",
    "comment" : "\n         * Optionally indicate the package source of the app being installed. This is\n         * informational and may be used as a signal by the system.\n         *\n         * An installer should specify {@link #PACKAGE_SOURCE_OTHER} if no other package source\n         * constant adequately reflects the source for this session.\n         *\n         * The default value is {@link #PACKAGE_SOURCE_UNSPECIFIED}.\n         ",
    "links" : [ "#PACKAGE_SOURCE_UNSPECIFIED", "#PACKAGE_SOURCE_OTHER" ]
  }, {
    "name" : "public void setWhitelistedRestrictedPermissions(@Nullable Set<String> permissions)",
    "returnType" : "void",
    "comment" : "\n         * Sets which restricted permissions to be allowlisted for the app. Allowlisting\n         * is not granting the permissions, rather it allows the app to hold permissions\n         * which are otherwise restricted. Allowlisting a non restricted permission has\n         * no effect.\n         *\n         * <p> Permissions can be hard restricted which means that the app cannot hold\n         * them or soft restricted where the app can hold the permission but in a weaker\n         * form. Whether a permission is {@link PermissionInfo#FLAG_HARD_RESTRICTED hard\n         * restricted} or {@link PermissionInfo#FLAG_SOFT_RESTRICTED soft restricted}\n         * depends on the permission declaration. Allowlisting a hard restricted permission\n         * allows the app to hold that permission and allowlisting a soft restricted\n         * permission allows the app to hold the permission in its full, unrestricted form.\n         *\n         * <p> Permissions can also be immutably restricted which means that the allowlist\n         * state of the permission can be determined only at install time and cannot be\n         * changed on updated or at a later point via the package manager APIs.\n         *\n         * <p>Initially, all restricted permissions are allowlisted but you can change\n         * which ones are allowlisted by calling this method or the corresponding ones\n         * on the {@link PackageManager}. Only soft or hard restricted permissions on the current\n         * Android version are supported and any invalid entries will be removed.\n         *\n         * @see PackageManager#addWhitelistedRestrictedPermission(String, String, int)\n         * @see PackageManager#removeWhitelistedRestrictedPermission(String, String, int)\n         ",
    "links" : [ "android.content.pm.PackageManager", "android.content.pm.PermissionInfo#FLAG_SOFT_RESTRICTED", "android.content.pm.PermissionInfo#FLAG_HARD_RESTRICTED" ]
  }, {
    "name" : "public void setAutoRevokePermissionsMode(boolean shouldAutoRevoke)",
    "returnType" : "void",
    "comment" : "\n         * Sets whether permissions should be auto-revoked if this package is unused for an\n         * extended periodd of time.\n         *\n         * It's disabled by default but generally the installer should enable it for most packages,\n         * excluding only those where doing so might cause breakage that cannot be easily addressed\n         * by simply re-requesting the permission(s).\n         *\n         * If user explicitly enabled or disabled it via settings, this call is ignored.\n         *\n         * @param shouldAutoRevoke whether permissions should be auto-revoked.\n         *\n         * @deprecated No longer used\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setEnableRollback(boolean enable)",
    "returnType" : "void",
    "comment" : "\n         * Request that rollbacks be enabled or disabled for the given upgrade with rollback data\n         * policy set to RESTORE.\n         *\n         * <p>If the parent session is staged or has rollback enabled, all children sessions\n         * must have the same properties.\n         *\n         * @param enable set to {@code true} to enable, {@code false} to disable\n         * @see SessionParams#setEnableRollback(boolean, int)\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setEnableRollback(boolean enable, @PackageManager.RollbackDataPolicy int dataPolicy)",
    "returnType" : "void",
    "comment" : "\n         * Request that rollbacks be enabled or disabled for the given upgrade.\n         *\n         * <p>If the parent session is staged or has rollback enabled, all children sessions\n         * must have the same properties.\n         *\n         * <p> For a multi-package install, this method must be called on each child session to\n         * specify rollback data policies explicitly. Note each child session is allowed to have\n         * different policies.\n         *\n         * @param enable set to {@code true} to enable, {@code false} to disable\n         * @param dataPolicy the rollback data policy for this session\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setRollbackLifetimeMillis(@DurationMillisLong long lifetimeMillis)",
    "returnType" : "void",
    "comment" : "\n         * If rollback enabled for this session (via {@link #setEnableRollback}, set period\n         * after which rollback files will be deleted due to expiration\n         * {@link RollbackManagerServiceImpl#deleteRollback}.\n         *\n         * <p>For multi-package installs, this value must be set on the parent session.\n         * Child session rollback lifetime will be ignored.\n         *\n         * @param lifetimeMillis period after which rollback expires\n         * @throws IllegalArgumentException if lifetimeMillis is negative or rollback is not\n         * enabled via setEnableRollback.\n         * @hide\n         ",
    "links" : [ "#setEnableRollback", "#deleteRollback" ]
  }, {
    "name" : "public void setRollbackImpactLevel(@PackageManager.RollbackImpactLevel int impactLevel)",
    "returnType" : "void",
    "comment" : "\n         * rollbackImpactLevel is a measure of impact a rollback has on the user. This can take one\n         * of 3 values:\n         * <ul>\n         *     <li>{@link PackageManager#ROLLBACK_USER_IMPACT_LOW} (default)</li>\n         *     <li>{@link PackageManager#ROLLBACK_USER_IMPACT_HIGH} (1)</li>\n         *     <li>{@link PackageManager#ROLLBACK_USER_IMPACT_ONLY_MANUAL} (2)</li>\n         * </ul>\n         *\n         * @hide\n         ",
    "links" : [ "android.content.pm.PackageManager#ROLLBACK_USER_IMPACT_LOW", "android.content.pm.PackageManager#ROLLBACK_USER_IMPACT_HIGH", "android.content.pm.PackageManager#ROLLBACK_USER_IMPACT_ONLY_MANUAL" ]
  }, {
    "name" : "public void setAllowDowngrade(boolean allowDowngrade)",
    "returnType" : "void",
    "comment" : "\n         * @deprecated use {@link #setRequestDowngrade(boolean)}.\n         * {@hide}\n         ",
    "links" : [ "#setRequestDowngrade(boolean)" ]
  }, {
    "name" : "public void setRequestDowngrade(boolean requestDowngrade)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void setRequiredInstalledVersionCode(long versionCode)",
    "returnType" : "void",
    "comment" : "\n         * Require the given version of the package be installed.\n         * The install will only be allowed if the existing version code of\n         * the package installed on the device matches the given version code.\n         * Use {@link * PackageManager#VERSION_CODE_HIGHEST} to allow\n         * installation regardless of the currently installed package version.\n         *\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setInstallFlagsForcePermissionPrompt()",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void setDontKillApp(boolean dontKillApp)",
    "returnType" : "void",
    "comment" : "\n         * Requests that the system not kill any of the package's running\n         * processes as part of a {@link SessionParams#MODE_INHERIT_EXISTING}\n         * session in which splits being added. By default, all installs will\n         * result in the package's running processes being killed before the\n         * install completes.\n         *\n         * @param dontKillApp set to {@code true} to request that the processes\n         *                    belonging to the package not be killed as part of\n         *                    this install.\n         ",
    "links" : [ "#MODE_INHERIT_EXISTING" ]
  }, {
    "name" : "public void setInstallAsInstantApp(boolean isInstantApp)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void setInstallAsVirtualPreload()",
    "returnType" : "void",
    "comment" : "\n         * Sets the install as a virtual preload. Will only have effect when called\n         * by the verifier.\n         * {@hide}\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setInstallReason(@InstallReason int installReason)",
    "returnType" : "void",
    "comment" : "\n         * Set the reason for installing this package.\n         * <p>\n         * The install reason should be a pre-defined integer. The behavior is\n         * undefined if other values are used.\n         *\n         * @see PackageManager#INSTALL_REASON_UNKNOWN\n         * @see PackageManager#INSTALL_REASON_POLICY\n         * @see PackageManager#INSTALL_REASON_DEVICE_RESTORE\n         * @see PackageManager#INSTALL_REASON_DEVICE_SETUP\n         * @see PackageManager#INSTALL_REASON_USER\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setAllocateAggressive(boolean allocateAggressive)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void setInstallFlagAllowTest()",
    "returnType" : "void",
    "comment" : "\n         * @hide\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setInstallerPackageName(@Nullable String installerPackageName)",
    "returnType" : "void",
    "comment" : "\n         * Set the installer package for the app.\n         *\n         * By default this is the app that created the {@link PackageInstaller} object.\n         *\n         * Note: Only applications with {@link android.Manifest.permission#INSTALL_PACKAGES}\n         * permission are allowed to set an installer that is not the caller's own installer\n         * package name, otherwise it will cause a {@link SecurityException} when creating the\n         * install session.\n         *\n         * @param installerPackageName The name of the installer package, its length must be less\n         *                            than {@code 255}, otherwise it will be invalid.\n         ",
    "links" : [ "android.content.pm.PackageInstaller", "android.Manifest.permission#INSTALL_PACKAGES", "SecurityException" ]
  }, {
    "name" : "public void setMultiPackage()",
    "returnType" : "void",
    "comment" : "\n         * Set this session to be the parent of a multi-package install.\n         *\n         * A multi-package install session contains no APKs and only references other install\n         * sessions via ID. When a multi-package session is committed, all of its children\n         * are committed to the system in an atomic manner. If any children fail to install,\n         * all of them do, including the multi-package session.\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setStaged()",
    "returnType" : "void",
    "comment" : "\n         * Set this session to be staged to be installed at reboot.\n         *\n         * Staged sessions are scheduled to be installed at next reboot. Staged sessions can also be\n         * multi-package. In that case, if any of the children sessions fail to install at reboot,\n         * all the other children sessions are aborted as well.\n         *\n         * <p>If the parent session is staged or has rollback enabled, all children sessions\n         * must have the same properties.\n         *\n         * {@hide}\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setInstallAsApex()",
    "returnType" : "void",
    "comment" : "\n         * Set this session to be installing an APEX package.\n         *\n         * {@hide}\n         ",
    "links" : [ ]
  }, {
    "name" : "public boolean getEnableRollback()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void setDataLoaderParams(@NonNull DataLoaderParams dataLoaderParams)",
    "returnType" : "void",
    "comment" : "\n         * Set the data loader params for the session.\n         * This also switches installation into data loading mode and disallow direct writes into\n         * staging folder.\n         *\n         * @see android.service.dataloader.DataLoaderService.DataLoader\n         *\n         * {@hide}\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setForceQueryable()",
    "returnType" : "void",
    "comment" : "\n         *\n         * {@hide}\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setRequireUserAction(@SessionParams.UserActionRequirement int requireUserAction)",
    "returnType" : "void",
    "comment" : "\n         * Optionally indicate whether user action should be required when the session is\n         * committed.\n         * <p>\n         * Defaults to {@link #USER_ACTION_UNSPECIFIED} unless otherwise set. When unspecified for\n         * installers using the\n         * {@link android.Manifest.permission#REQUEST_INSTALL_PACKAGES REQUEST_INSTALL_PACKAGES}\n         * permission will behave as if set to {@link #USER_ACTION_REQUIRED}, and\n         * {@link #USER_ACTION_NOT_REQUIRED} otherwise. When {@code requireUserAction} is set to\n         * {@link #USER_ACTION_REQUIRED}, installers will receive a\n         * {@link #STATUS_PENDING_USER_ACTION} callback once the session is committed, indicating\n         * that user action is required for the install to proceed.\n         * <p>\n         * For installers that have been granted the\n         * {@link android.Manifest.permission#REQUEST_INSTALL_PACKAGES REQUEST_INSTALL_PACKAGES}\n         * permission, user action will not be required when all of the following conditions are\n         * met:\n         *\n         * <ul>\n         *     <li>{@code requireUserAction} is set to {@link #USER_ACTION_NOT_REQUIRED}.</li>\n         *     <li>The app being installed targets:\n         *          <ul>\n         *              <li>{@link android.os.Build.VERSION_CODES#Q API 29} or higher on\n         *              Android S  ({@link android.os.Build.VERSION_CODES#S API 31})</li>\n         *              <li>{@link android.os.Build.VERSION_CODES#R API 30} or higher on\n         *              Android T ({@link android.os.Build.VERSION_CODES#TIRAMISU API 33})</li>\n         *              <li>{@link android.os.Build.VERSION_CODES#S API 31} or higher <b>after</b>\n         *              Android T ({@link android.os.Build.VERSION_CODES#TIRAMISU API 33})</li>\n         *          </ul>\n         *     </li>\n         *     <li>The installer is:\n         *         <ul>\n         *             <li>The {@link InstallSourceInfo#getUpdateOwnerPackageName() update owner}\n         *             of an existing version of the app (in other words, this install session is\n         *             an app update) if the update ownership enforcement is enabled.</li>\n         *             <li>The\n         *             {@link InstallSourceInfo#getInstallingPackageName() installer of record}\n         *             of an existing version of the app (in other words, this install\n         *             session is an app update) if the update ownership enforcement isn't\n         *             enabled.</li>\n         *             <li>Updating itself.</li>\n         *         </ul>\n         *     </li>\n         *     <li>The installer declares the\n         *     {@link android.Manifest.permission#UPDATE_PACKAGES_WITHOUT_USER_ACTION\n         *     UPDATE_PACKAGES_WITHOUT_USER_ACTION} permission.</li>\n         * </ul>\n         * <p>\n         * Note: The target API level requirement will advance in future Android versions.\n         * Session owners should always be prepared to handle {@link #STATUS_PENDING_USER_ACTION}.\n         *\n         * @param requireUserAction whether user action should be required.\n         ",
    "links" : [ "#USER_ACTION_REQUIRED", "#USER_ACTION_NOT_REQUIRED", "android.os.Build.VERSION_CODES#TIRAMISU", "#STATUS_PENDING_USER_ACTION", "android.os.Build.VERSION_CODES#R", "android.os.Build.VERSION_CODES#Q", "android.os.Build.VERSION_CODES#S", "android.content.pm.InstallSourceInfo#getInstallingPackageName()", "android.Manifest.permission#REQUEST_INSTALL_PACKAGES", "android.Manifest.permission#UPDATE_PACKAGES_WITHOUT_USER_ACTIONUPDATE_PACKAGES_WITHOUT_USER_ACTION", "android.content.pm.InstallSourceInfo#getUpdateOwnerPackageName()", "#USER_ACTION_UNSPECIFIED" ]
  }, {
    "name" : "public void setInstallScenario(@InstallScenario int installScenario)",
    "returnType" : "void",
    "comment" : "\n         * Sets the install scenario for this session, which describes the expected user journey.\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setApplicationEnabledSettingPersistent()",
    "returnType" : "void",
    "comment" : "\n         * Request to keep the original application enabled setting. This will prevent the\n         * application from being enabled if it was previously in a disabled state.\n         ",
    "links" : [ ]
  }, {
    "name" : "public void setRequestUpdateOwnership(boolean enable)",
    "returnType" : "void",
    "comment" : "\n         * Optionally indicate whether the package being installed needs the update ownership\n         * enforcement. Once the update ownership enforcement is enabled, the other installers\n         * will need the user action to update the package even if the installers have been\n         * granted the {@link android.Manifest.permission#INSTALL_PACKAGES INSTALL_PACKAGES}\n         * permission. Default to {@code false}.\n         *\n         * The update ownership enforcement can only be enabled on initial installation. Set\n         * this to {@code true} on package update is a no-op.\n         *\n         * Note: To enable the update ownership enforcement, the installer must have the\n         * {@link android.Manifest.permission#ENFORCE_UPDATE_OWNERSHIP ENFORCE_UPDATE_OWNERSHIP}\n         * permission.\n         ",
    "links" : [ "android.Manifest.permission#INSTALL_PACKAGES", "android.Manifest.permission#ENFORCE_UPDATE_OWNERSHIP" ]
  }, {
    "name" : "public void setUnarchiveId(int unarchiveId)",
    "returnType" : "void",
    "comment" : "\n         * Used to set the unarchive ID received as part of an\n         * {@link Intent#ACTION_UNARCHIVE_PACKAGE}.\n         *\n         * <p> The ID should be retrieved from the unarchive intent and passed into the\n         * session that's being created to unarchive the app in question. Used to link the unarchive\n         * intent and the install session to disambiguate.\n         ",
    "links" : [ "android.app.PendingIntent#ACTION_UNARCHIVE_PACKAGE" ]
  }, {
    "name" : "public ArrayMap<String, Integer> getPermissionStates()",
    "returnType" : "ArrayMap<String, Integer>",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public String[] getLegacyGrantedRuntimePermissions()",
    "returnType" : "String[]",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void dump(IndentingPrintWriter pw)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public int describeContents()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void writeToParcel(Parcel dest, int flags)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ "public SessionParams copy()", "public boolean areHiddenOptionsSet()", "public void setInstallLocation(int installLocation)", "public void setSize(long sizeBytes)", "public void setAppPackageName(@Nullable String appPackageName)", "public void setAppIcon(@Nullable Bitmap appIcon)", "public void setAppLabel(@Nullable CharSequence appLabel)", "public void setOriginatingUri(@Nullable Uri originatingUri)", "public void setOriginatingUid(int originatingUid)", "public void setReferrerUri(@Nullable Uri referrerUri)", "public void setGrantedRuntimePermissions(String[] permissions)", "public SessionParams setPermissionState(@NonNull String permissionName, @PermissionState int state)", "public void setPermissionStates(Collection<String> grantPermissions, Collection<String> denyPermissions)", "public void setPackageSource(@PackageSourceType int packageSource)", "public void setWhitelistedRestrictedPermissions(@Nullable Set<String> permissions)", "public void setAutoRevokePermissionsMode(boolean shouldAutoRevoke)", "public void setEnableRollback(boolean enable)", "public void setEnableRollback(boolean enable, @PackageManager.RollbackDataPolicy int dataPolicy)", "public void setRollbackLifetimeMillis(@DurationMillisLong long lifetimeMillis)", "public void setRollbackImpactLevel(@PackageManager.RollbackImpactLevel int impactLevel)", "public void setAllowDowngrade(boolean allowDowngrade)", "public void setRequestDowngrade(boolean requestDowngrade)", "public void setRequiredInstalledVersionCode(long versionCode)", "public void setInstallFlagsForcePermissionPrompt()", "public void setDontKillApp(boolean dontKillApp)", "public void setInstallAsInstantApp(boolean isInstantApp)", "public void setInstallAsVirtualPreload()", "public void setInstallReason(@InstallReason int installReason)", "public void setAllocateAggressive(boolean allocateAggressive)", "public void setInstallFlagAllowTest()", "public void setInstallerPackageName(@Nullable String installerPackageName)", "public void setMultiPackage()", "public void setStaged()", "public void setInstallAsApex()", "public boolean getEnableRollback()", "public void setDataLoaderParams(@NonNull DataLoaderParams dataLoaderParams)", "public void setForceQueryable()", "public void setRequireUserAction(@SessionParams.UserActionRequirement int requireUserAction)", "public void setInstallScenario(@InstallScenario int installScenario)", "public void setApplicationEnabledSettingPersistent()", "public void setRequestUpdateOwnership(boolean enable)", "public void setUnarchiveId(int unarchiveId)", "public ArrayMap<String, Integer> getPermissionStates()", "public String[] getLegacyGrantedRuntimePermissions()", "public void dump(IndentingPrintWriter pw)", "public int describeContents()", "public void writeToParcel(Parcel dest, int flags)" ],
  "variableNames" : [ "MODE_INVALID", "MODE_FULL_INSTALL", "MODE_INHERIT_EXISTING", "RESTRICTED_PERMISSIONS_ALL", "UID_UNKNOWN", "MAX_PACKAGE_NAME_LENGTH", "USER_ACTION_UNSPECIFIED", "USER_ACTION_REQUIRED", "USER_ACTION_NOT_REQUIRED", "PERMISSION_STATE_DEFAULT", "PERMISSION_STATE_GRANTED", "PERMISSION_STATE_DENIED", "mode", "installFlags", "installLocation", "installReason", "installScenario", "sizeBytes", "appPackageName", "appIcon", "appLabel", "appIconLastModified", "originatingUri", "originatingUid", "referrerUri", "abiOverride", "volumeUuid", "whitelistedRestrictedPermissions", "autoRevokePermissionsMode", "installerPackageName", "isMultiPackage", "packageSource", "isStaged", "requiredInstalledVersionCode", "dataLoaderParams", "rollbackDataPolicy", "rollbackLifetimeMillis", "rollbackImpactLevel", "forceQueryableOverride", "requireUserAction", "applicationEnabledSettingPersistent", "developmentInstallFlags", "unarchiveId", "mPermissionStates", "CREATOR" ]
}