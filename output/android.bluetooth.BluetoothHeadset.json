{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/bluetooth/BluetoothHeadset.java",
  "packageName" : "android.bluetooth",
  "className" : "BluetoothHeadset",
  "comment" : "\n * Public API for controlling the Bluetooth Headset Service. This includes both\n * Bluetooth Headset and Handsfree (v1.5) profiles.\n *\n * <p>BluetoothHeadset is a proxy object for controlling the Bluetooth Headset\n * Service via IPC.\n *\n * <p> Use {@link BluetoothAdapter#getProfileProxy} to get\n * the BluetoothHeadset proxy object. Use\n * {@link BluetoothAdapter#closeProfileProxy} to close the service connection.\n *\n * <p> Android only supports one connected Bluetooth Headset at a time.\n * Each method is protected with its appropriate permission.\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DBG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "VDBG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_CONNECTION_STATE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Intent used to broadcast the change in connection state of the Headset\n     * profile.\n     *\n     * <p>This intent will have 3 extras:\n     * <ul>\n     * <li> {@link #EXTRA_STATE} - The current state of the profile. </li>\n     * <li> {@link #EXTRA_PREVIOUS_STATE}- The previous state of the profile. </li>\n     * <li> {@link BluetoothDevice#EXTRA_DEVICE} - The remote device. </li>\n     * </ul>\n     * <p>{@link #EXTRA_STATE} or {@link #EXTRA_PREVIOUS_STATE} can be any of\n     * {@link #STATE_DISCONNECTED}, {@link #STATE_CONNECTING},\n     * {@link #STATE_CONNECTED}, {@link #STATE_DISCONNECTING}.\n     *\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission to\n     * receive.\n     ",
    "links" : [ "#STATE_DISCONNECTED", "#STATE_DISCONNECTING", "#EXTRA_STATE", "android.bluetooth.BluetoothDevice#EXTRA_DEVICE", "#STATE_CONNECTING", "#STATE_CONNECTED", "#EXTRA_PREVIOUS_STATE", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "ACTION_AUDIO_STATE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Intent used to broadcast the change in the Audio Connection state of the\n     * A2DP profile.\n     *\n     * <p>This intent will have 3 extras:\n     * <ul>\n     * <li> {@link #EXTRA_STATE} - The current state of the profile. </li>\n     * <li> {@link #EXTRA_PREVIOUS_STATE}- The previous state of the profile. </li>\n     * <li> {@link BluetoothDevice#EXTRA_DEVICE} - The remote device. </li>\n     * </ul>\n     * <p>{@link #EXTRA_STATE} or {@link #EXTRA_PREVIOUS_STATE} can be any of\n     * {@link #STATE_AUDIO_CONNECTED}, {@link #STATE_AUDIO_DISCONNECTED},\n     *\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission\n     * to receive.\n     ",
    "links" : [ "#EXTRA_STATE", "android.bluetooth.BluetoothDevice#EXTRA_DEVICE", "#STATE_AUDIO_CONNECTED", "#EXTRA_PREVIOUS_STATE", "#STATE_AUDIO_DISCONNECTED", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "ACTION_ACTIVE_DEVICE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Intent used to broadcast the selection of a connected device as active.\n     *\n     * <p>This intent will have one extra:\n     * <ul>\n     * <li> {@link BluetoothDevice#EXTRA_DEVICE} - The remote device. It can\n     * be null if no device is active. </li>\n     * </ul>\n     *\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission to\n     * receive.\n     *\n     * @hide\n     ",
    "links" : [ "android.bluetooth.BluetoothDevice#EXTRA_DEVICE", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "ACTION_VENDOR_SPECIFIC_HEADSET_EVENT",
    "type" : "String",
    "comment" : "\n     * Intent used to broadcast that the headset has posted a\n     * vendor-specific event.\n     *\n     * <p>This intent will have 4 extras and 1 category.\n     * <ul>\n     * <li> {@link BluetoothDevice#EXTRA_DEVICE} - The remote Bluetooth Device\n     * </li>\n     * <li> {@link #EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD} - The vendor\n     * specific command </li>\n     * <li> {@link #EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE} - The AT\n     * command type which can be one of  {@link #AT_CMD_TYPE_READ},\n     * {@link #AT_CMD_TYPE_TEST}, or {@link #AT_CMD_TYPE_SET},\n     * {@link #AT_CMD_TYPE_BASIC},{@link #AT_CMD_TYPE_ACTION}. </li>\n     * <li> {@link #EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_ARGS} - Command\n     * arguments. </li>\n     * </ul>\n     *\n     * <p> The category is the Company ID of the vendor defining the\n     * vendor-specific command. {@link BluetoothAssignedNumbers}\n     *\n     * For example, for Plantronics specific events\n     * Category will be {@link #VENDOR_SPECIFIC_HEADSET_EVENT_COMPANY_ID_CATEGORY}.55\n     *\n     * <p> For example, an AT+XEVENT=foo,3 will get translated into\n     * <ul>\n     * <li> EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD = +XEVENT </li>\n     * <li> EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE = AT_CMD_TYPE_SET </li>\n     * <li> EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_ARGS = foo, 3 </li>\n     * </ul>\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission\n     * to receive.\n     ",
    "links" : [ "#AT_CMD_TYPE_TEST", "#EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE", "android.bluetooth.BluetoothAssignedNumbers", "android.bluetooth.BluetoothDevice#EXTRA_DEVICE", "#AT_CMD_TYPE_ACTION", "#AT_CMD_TYPE_READ", "#EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_ARGS", "#VENDOR_SPECIFIC_HEADSET_EVENT_COMPANY_ID_CATEGORY", "#AT_CMD_TYPE_BASIC", "#EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD", "#AT_CMD_TYPE_SET", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD",
    "type" : "String",
    "comment" : "\n     * A String extra field in {@link #ACTION_VENDOR_SPECIFIC_HEADSET_EVENT}\n     * intents that contains the name of the vendor-specific command.\n     ",
    "links" : [ "#ACTION_VENDOR_SPECIFIC_HEADSET_EVENT" ]
  }, {
    "name" : "EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE",
    "type" : "String",
    "comment" : "\n     * An int extra field in {@link #ACTION_VENDOR_SPECIFIC_HEADSET_EVENT}\n     * intents that contains the AT command type of the vendor-specific command.\n     ",
    "links" : [ "#ACTION_VENDOR_SPECIFIC_HEADSET_EVENT" ]
  }, {
    "name" : "AT_CMD_TYPE_READ",
    "type" : "int",
    "comment" : "\n     * AT command type READ used with\n     * {@link #EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE}\n     * For example, AT+VGM?. There are no arguments for this command type.\n     ",
    "links" : [ "#EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE" ]
  }, {
    "name" : "AT_CMD_TYPE_TEST",
    "type" : "int",
    "comment" : "\n     * AT command type TEST used with\n     * {@link #EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE}\n     * For example, AT+VGM=?. There are no arguments for this command type.\n     ",
    "links" : [ "#EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE" ]
  }, {
    "name" : "AT_CMD_TYPE_SET",
    "type" : "int",
    "comment" : "\n     * AT command type SET used with\n     * {@link #EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE}\n     * For example, AT+VGM=<args>.\n     ",
    "links" : [ "#EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE" ]
  }, {
    "name" : "AT_CMD_TYPE_BASIC",
    "type" : "int",
    "comment" : "\n     * AT command type BASIC used with\n     * {@link #EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE}\n     * For example, ATD. Single character commands and everything following the\n     * character are arguments.\n     ",
    "links" : [ "#EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE" ]
  }, {
    "name" : "AT_CMD_TYPE_ACTION",
    "type" : "int",
    "comment" : "\n     * AT command type ACTION used with\n     * {@link #EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE}\n     * For example, AT+CHUP. There are no arguments for action commands.\n     ",
    "links" : [ "#EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE" ]
  }, {
    "name" : "EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_ARGS",
    "type" : "String",
    "comment" : "\n     * A Parcelable String array extra field in\n     * {@link #ACTION_VENDOR_SPECIFIC_HEADSET_EVENT} intents that contains\n     * the arguments to the vendor-specific command.\n     ",
    "links" : [ "#ACTION_VENDOR_SPECIFIC_HEADSET_EVENT" ]
  }, {
    "name" : "VENDOR_SPECIFIC_HEADSET_EVENT_COMPANY_ID_CATEGORY",
    "type" : "String",
    "comment" : "\n     * The intent category to be used with {@link #ACTION_VENDOR_SPECIFIC_HEADSET_EVENT}\n     * for the companyId\n     ",
    "links" : [ "#ACTION_VENDOR_SPECIFIC_HEADSET_EVENT" ]
  }, {
    "name" : "VENDOR_RESULT_CODE_COMMAND_ANDROID",
    "type" : "String",
    "comment" : "\n     * A vendor-specific command for unsolicited result code.\n     ",
    "links" : [ ]
  }, {
    "name" : "VENDOR_SPECIFIC_HEADSET_EVENT_XAPL",
    "type" : "String",
    "comment" : "\n     * A vendor-specific AT command\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "VENDOR_SPECIFIC_HEADSET_EVENT_IPHONEACCEV",
    "type" : "String",
    "comment" : "\n     * A vendor-specific AT command\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "VENDOR_SPECIFIC_HEADSET_EVENT_IPHONEACCEV_BATTERY_LEVEL",
    "type" : "int",
    "comment" : "\n     * Battery level indicator associated with\n     * {@link #VENDOR_SPECIFIC_HEADSET_EVENT_IPHONEACCEV}\n     *\n     * @hide\n     ",
    "links" : [ "#VENDOR_SPECIFIC_HEADSET_EVENT_IPHONEACCEV" ]
  }, {
    "name" : "VENDOR_SPECIFIC_HEADSET_EVENT_XEVENT",
    "type" : "String",
    "comment" : "\n     * A vendor-specific AT command\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "VENDOR_SPECIFIC_HEADSET_EVENT_XEVENT_BATTERY_LEVEL",
    "type" : "String",
    "comment" : "\n     * Battery level indicator associated with {@link #VENDOR_SPECIFIC_HEADSET_EVENT_XEVENT}\n     *\n     * @hide\n     ",
    "links" : [ "#VENDOR_SPECIFIC_HEADSET_EVENT_XEVENT" ]
  }, {
    "name" : "STATE_AUDIO_DISCONNECTED",
    "type" : "int",
    "comment" : "\n     * Headset state when SCO audio is not connected.\n     * This state can be one of\n     * {@link #EXTRA_STATE} or {@link #EXTRA_PREVIOUS_STATE} of\n     * {@link #ACTION_AUDIO_STATE_CHANGED} intent.\n     ",
    "links" : [ "#EXTRA_STATE", "#ACTION_AUDIO_STATE_CHANGED", "#EXTRA_PREVIOUS_STATE" ]
  }, {
    "name" : "STATE_AUDIO_CONNECTING",
    "type" : "int",
    "comment" : "\n     * Headset state when SCO audio is connecting.\n     * This state can be one of\n     * {@link #EXTRA_STATE} or {@link #EXTRA_PREVIOUS_STATE} of\n     * {@link #ACTION_AUDIO_STATE_CHANGED} intent.\n     ",
    "links" : [ "#EXTRA_STATE", "#ACTION_AUDIO_STATE_CHANGED", "#EXTRA_PREVIOUS_STATE" ]
  }, {
    "name" : "STATE_AUDIO_CONNECTED",
    "type" : "int",
    "comment" : "\n     * Headset state when SCO audio is connected.\n     * This state can be one of\n     * {@link #EXTRA_STATE} or {@link #EXTRA_PREVIOUS_STATE} of\n     * {@link #ACTION_AUDIO_STATE_CHANGED} intent.\n     ",
    "links" : [ "#EXTRA_STATE", "#ACTION_AUDIO_STATE_CHANGED", "#EXTRA_PREVIOUS_STATE" ]
  }, {
    "name" : "ACTION_HF_INDICATORS_VALUE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Intent used to broadcast the headset's indicator status\n     *\n     * <p>This intent will have 3 extras:\n     * <ul>\n     * <li> {@link #EXTRA_HF_INDICATORS_IND_ID} - The Assigned number of headset Indicator which\n     * is supported by the headset ( as indicated by AT+BIND command in the SLC\n     * sequence) or whose value is changed (indicated by AT+BIEV command) </li>\n     * <li> {@link #EXTRA_HF_INDICATORS_IND_VALUE} - Updated value of headset indicator. </li>\n     * <li> {@link BluetoothDevice#EXTRA_DEVICE} - Remote device. </li>\n     * </ul>\n     * <p>{@link #EXTRA_HF_INDICATORS_IND_ID} is defined by Bluetooth SIG and each of the indicators\n     * are given an assigned number. Below shows the assigned number of Indicator added so far\n     * - Enhanced Safety - 1, Valid Values: 0 - Disabled, 1 - Enabled\n     * - Battery Level - 2, Valid Values: 0~100 - Remaining level of Battery\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission to receive.\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_HF_INDICATORS_IND_VALUE", "android.bluetooth.BluetoothDevice#EXTRA_DEVICE", "#EXTRA_HF_INDICATORS_IND_ID", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "EXTRA_HF_INDICATORS_IND_ID",
    "type" : "String",
    "comment" : "\n     * A int extra field in {@link #ACTION_HF_INDICATORS_VALUE_CHANGED}\n     * intents that contains the assigned number of the headset indicator as defined by\n     * Bluetooth SIG that is being sent. Value range is 0-65535 as defined in HFP 1.7\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_HF_INDICATORS_VALUE_CHANGED" ]
  }, {
    "name" : "EXTRA_HF_INDICATORS_IND_VALUE",
    "type" : "String",
    "comment" : "\n     * A int extra field in {@link #ACTION_HF_INDICATORS_VALUE_CHANGED}\n     * intents that contains the value of the Headset indicator that is being sent.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_HF_INDICATORS_VALUE_CHANGED" ]
  }, {
    "name" : "MESSAGE_HEADSET_SERVICE_CONNECTED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MESSAGE_HEADSET_SERVICE_DISCONNECTED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mServiceListener",
    "type" : "ServiceListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mService",
    "type" : "IBluetoothHeadset",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAdapter",
    "type" : "BluetoothAdapter",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBluetoothStateChangeCallback",
    "type" : "IBluetoothStateChangeCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mConnection",
    "type" : "IBluetoothProfileServiceConnection",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHandler",
    "type" : "Handler",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private boolean doBind()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void doUnbind()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void close()",
    "returnType" : "void",
    "comment" : "\n     * Close the connection to the backing service.\n     * Other public functions of BluetoothHeadset will return default error\n     * results once close() has been called. Multiple invocations of close()\n     * are ok.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean connect(BluetoothDevice device)",
    "returnType" : "boolean",
    "comment" : "\n     * Initiate connection to a profile of the remote bluetooth device.\n     *\n     * <p> Currently, the system supports only 1 connection to the\n     * headset/handsfree profile. The API will automatically disconnect connected\n     * devices before connecting.\n     *\n     * <p> This API returns false in scenarios like the profile on the\n     * device is already connected or Bluetooth is not turned on.\n     * When this API returns true, it is guaranteed that\n     * connection state intent for the profile will be broadcasted with\n     * the state. Users can get the connection state of the profile\n     * from this intent.\n     *\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}\n     * permission.\n     *\n     * @param device Remote Bluetooth Device\n     * @return false on immediate error, true otherwise\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#BLUETOOTH_ADMIN" ]
  }, {
    "name" : "public boolean disconnect(BluetoothDevice device)",
    "returnType" : "boolean",
    "comment" : "\n     * Initiate disconnection from a profile\n     *\n     * <p> This API will return false in scenarios like the profile on the\n     * Bluetooth device is not in connected state etc. When this API returns,\n     * true, it is guaranteed that the connection state change\n     * intent will be broadcasted with the state. Users can get the\n     * disconnection state of the profile from this intent.\n     *\n     * <p> If the disconnection is initiated by a remote device, the state\n     * will transition from {@link #STATE_CONNECTED} to\n     * {@link #STATE_DISCONNECTED}. If the disconnect is initiated by the\n     * host (local) device the state will transition from\n     * {@link #STATE_CONNECTED} to state {@link #STATE_DISCONNECTING} to\n     * state {@link #STATE_DISCONNECTED}. The transition to\n     * {@link #STATE_DISCONNECTING} can be used to distinguish between the\n     * two scenarios.\n     *\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}\n     * permission.\n     *\n     * @param device Remote Bluetooth Device\n     * @return false on immediate error, true otherwise\n     * @hide\n     ",
    "links" : [ "#STATE_DISCONNECTED", "#STATE_DISCONNECTING", "#STATE_CONNECTED", "android.Manifest.permission#BLUETOOTH_ADMIN" ]
  }, {
    "name" : "public List<BluetoothDevice> getConnectedDevices()",
    "returnType" : "List<BluetoothDevice>",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states)",
    "returnType" : "List<BluetoothDevice>",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getConnectionState(BluetoothDevice device)",
    "returnType" : "int",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setPriority(BluetoothDevice device, int priority)",
    "returnType" : "boolean",
    "comment" : "\n     * Set priority of the profile\n     *\n     * <p> The device should already be paired.\n     * Priority can be one of {@link BluetoothProfile#PRIORITY_ON} or\n     * {@link BluetoothProfile#PRIORITY_OFF}\n     *\n     * @param device Paired bluetooth device\n     * @param priority\n     * @return true if priority is set, false on error\n     * @hide\n     * @deprecated Replaced with {@link #setConnectionPolicy(BluetoothDevice, int)}\n     ",
    "links" : [ "android.bluetooth.BluetoothProfile#PRIORITY_OFF", "android.bluetooth.BluetoothProfile#PRIORITY_ON", "#setConnectionPolicy(BluetoothDevice" ]
  }, {
    "name" : "public boolean setConnectionPolicy(@NonNull BluetoothDevice device, @ConnectionPolicy int connectionPolicy)",
    "returnType" : "boolean",
    "comment" : "\n     * Set connection policy of the profile\n     *\n     * <p> The device should already be paired.\n     * Connection policy can be one of {@link #CONNECTION_POLICY_ALLOWED},\n     * {@link #CONNECTION_POLICY_FORBIDDEN}, {@link #CONNECTION_POLICY_UNKNOWN}\n     *\n     * @param device Paired bluetooth device\n     * @param connectionPolicy is the connection policy to set to for this profile\n     * @return true if connectionPolicy is set, false on error\n     * @hide\n     ",
    "links" : [ "#CONNECTION_POLICY_FORBIDDEN", "#CONNECTION_POLICY_ALLOWED", "#CONNECTION_POLICY_UNKNOWN" ]
  }, {
    "name" : "public int getPriority(BluetoothDevice device)",
    "returnType" : "int",
    "comment" : "\n     * Get the priority of the profile.\n     *\n     * <p> The priority can be any of:\n     * {@link #PRIORITY_AUTO_CONNECT}, {@link #PRIORITY_OFF},\n     * {@link #PRIORITY_ON}, {@link #PRIORITY_UNDEFINED}\n     *\n     * @param device Bluetooth device\n     * @return priority of the device\n     * @hide\n     ",
    "links" : [ "#PRIORITY_AUTO_CONNECT", "#PRIORITY_ON", "#PRIORITY_OFF", "#PRIORITY_UNDEFINED" ]
  }, {
    "name" : "public int getConnectionPolicy(@NonNull BluetoothDevice device)",
    "returnType" : "int",
    "comment" : "\n     * Get the connection policy of the profile.\n     *\n     * <p> The connection policy can be any of:\n     * {@link #CONNECTION_POLICY_ALLOWED}, {@link #CONNECTION_POLICY_FORBIDDEN},\n     * {@link #CONNECTION_POLICY_UNKNOWN}\n     *\n     * @param device Bluetooth device\n     * @return connection policy of the device\n     * @hide\n     ",
    "links" : [ "#CONNECTION_POLICY_FORBIDDEN", "#CONNECTION_POLICY_ALLOWED", "#CONNECTION_POLICY_UNKNOWN" ]
  }, {
    "name" : "public boolean startVoiceRecognition(BluetoothDevice device)",
    "returnType" : "boolean",
    "comment" : "\n     * Start Bluetooth voice recognition. This methods sends the voice\n     * recognition AT command to the headset and establishes the\n     * audio connection.\n     *\n     * <p> Users can listen to {@link #ACTION_AUDIO_STATE_CHANGED}.\n     * If this function returns true, this intent will be broadcasted with\n     * {@link #EXTRA_STATE} set to {@link #STATE_AUDIO_CONNECTING}.\n     *\n     * <p> {@link #EXTRA_STATE} will transition from\n     * {@link #STATE_AUDIO_CONNECTING} to {@link #STATE_AUDIO_CONNECTED} when\n     * audio connection is established and to {@link #STATE_AUDIO_DISCONNECTED}\n     * in case of failure to establish the audio connection.\n     *\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.\n     *\n     * @param device Bluetooth headset\n     * @return false if there is no headset connected, or the connected headset doesn't support\n     * voice recognition, or voice recognition is already started, or audio channel is occupied,\n     * or on error, true otherwise\n     ",
    "links" : [ "#ACTION_AUDIO_STATE_CHANGED", "#EXTRA_STATE", "#STATE_AUDIO_CONNECTED", "#STATE_AUDIO_CONNECTING", "#STATE_AUDIO_DISCONNECTED", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "public boolean stopVoiceRecognition(BluetoothDevice device)",
    "returnType" : "boolean",
    "comment" : "\n     * Stop Bluetooth Voice Recognition mode, and shut down the\n     * Bluetooth audio path.\n     *\n     * <p> Users can listen to {@link #ACTION_AUDIO_STATE_CHANGED}.\n     * If this function returns true, this intent will be broadcasted with\n     * {@link #EXTRA_STATE} set to {@link #STATE_AUDIO_DISCONNECTED}.\n     *\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.\n     *\n     * @param device Bluetooth headset\n     * @return false if there is no headset connected, or voice recognition has not started,\n     * or voice recognition has ended on this headset, or on error, true otherwise\n     ",
    "links" : [ "#ACTION_AUDIO_STATE_CHANGED", "#EXTRA_STATE", "#STATE_AUDIO_DISCONNECTED", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "public boolean isAudioConnected(BluetoothDevice device)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if Bluetooth SCO audio is connected.\n     *\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.\n     *\n     * @param device Bluetooth headset\n     * @return true if SCO is connected, false otherwise or on error\n     ",
    "links" : [ "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "public static boolean isBluetoothVoiceDialingEnabled(Context context)",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates if current platform supports voice dialing over bluetooth SCO.\n     *\n     * @return true if voice dialing over bluetooth is supported, false otherwise.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getAudioState(BluetoothDevice device)",
    "returnType" : "int",
    "comment" : "\n     * Get the current audio state of the Headset.\n     * Note: This is an internal function and shouldn't be exposed\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAudioRouteAllowed(boolean allowed)",
    "returnType" : "void",
    "comment" : "\n     * Sets whether audio routing is allowed. When set to {@code false}, the AG will not route any\n     * audio to the HF unless explicitly told to.\n     * This method should be used in cases where the SCO channel is shared between multiple profiles\n     * and must be delegated by a source knowledgeable\n     * Note: This is an internal function and shouldn't be exposed\n     *\n     * @param allowed {@code true} if the profile can reroute audio, {@code false} otherwise.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getAudioRouteAllowed()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether audio routing is allowed. see {@link #setAudioRouteAllowed(boolean)}.\n     * Note: This is an internal function and shouldn't be exposed\n     *\n     * @hide\n     ",
    "links" : [ "#setAudioRouteAllowed(boolean)" ]
  }, {
    "name" : "public void setForceScoAudio(boolean forced)",
    "returnType" : "void",
    "comment" : "\n     * Force SCO audio to be opened regardless any other restrictions\n     *\n     * @param forced Whether or not SCO audio connection should be forced: True to force SCO audio\n     * False to use SCO audio in normal manner\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAudioOn()",
    "returnType" : "boolean",
    "comment" : "\n     * Check if at least one headset's SCO audio is connected or connecting\n     *\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.\n     *\n     * @return true if at least one device's SCO audio is connected or connecting, false otherwise\n     * or on error\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "public boolean connectAudio()",
    "returnType" : "boolean",
    "comment" : "\n     * Initiates a connection of headset audio to the current active device\n     *\n     * <p> Users can listen to {@link #ACTION_AUDIO_STATE_CHANGED}.\n     * If this function returns true, this intent will be broadcasted with\n     * {@link #EXTRA_STATE} set to {@link #STATE_AUDIO_CONNECTING}.\n     *\n     * <p> {@link #EXTRA_STATE} will transition from\n     * {@link #STATE_AUDIO_CONNECTING} to {@link #STATE_AUDIO_CONNECTED} when\n     * audio connection is established and to {@link #STATE_AUDIO_DISCONNECTED}\n     * in case of failure to establish the audio connection.\n     *\n     * Note that this intent will not be sent if {@link BluetoothHeadset#isAudioOn()} is true\n     * before calling this method\n     *\n     * @return false if there was some error such as there is no active headset\n     * @hide\n     ",
    "links" : [ "#ACTION_AUDIO_STATE_CHANGED", "#EXTRA_STATE", "#STATE_AUDIO_CONNECTED", "#STATE_AUDIO_CONNECTING", "android.bluetooth.BluetoothHeadset#isAudioOn()", "#STATE_AUDIO_DISCONNECTED" ]
  }, {
    "name" : "public boolean disconnectAudio()",
    "returnType" : "boolean",
    "comment" : "\n     * Initiates a disconnection of HFP SCO audio.\n     * Tear down voice recognition or virtual voice call if any.\n     *\n     * <p> Users can listen to {@link #ACTION_AUDIO_STATE_CHANGED}.\n     * If this function returns true, this intent will be broadcasted with\n     * {@link #EXTRA_STATE} set to {@link #STATE_AUDIO_DISCONNECTED}.\n     *\n     * @return false if audio is not connected, or on error, true otherwise\n     * @hide\n     ",
    "links" : [ "#ACTION_AUDIO_STATE_CHANGED", "#EXTRA_STATE", "#STATE_AUDIO_DISCONNECTED" ]
  }, {
    "name" : "public boolean startScoUsingVirtualVoiceCall()",
    "returnType" : "boolean",
    "comment" : "\n     * Initiates a SCO channel connection as a virtual voice call to the current active device\n     * Active handsfree device will be notified of incoming call and connected call.\n     *\n     * <p> Users can listen to {@link #ACTION_AUDIO_STATE_CHANGED}.\n     * If this function returns true, this intent will be broadcasted with\n     * {@link #EXTRA_STATE} set to {@link #STATE_AUDIO_CONNECTING}.\n     *\n     * <p> {@link #EXTRA_STATE} will transition from\n     * {@link #STATE_AUDIO_CONNECTING} to {@link #STATE_AUDIO_CONNECTED} when\n     * audio connection is established and to {@link #STATE_AUDIO_DISCONNECTED}\n     * in case of failure to establish the audio connection.\n     *\n     * @return true if successful, false if one of the following case applies\n     *  - SCO audio is not idle (connecting or connected)\n     *  - virtual call has already started\n     *  - there is no active device\n     *  - a Telecom managed call is going on\n     *  - binder is dead or Bluetooth is disabled or other error\n     * @hide\n     ",
    "links" : [ "#ACTION_AUDIO_STATE_CHANGED", "#EXTRA_STATE", "#STATE_AUDIO_CONNECTED", "#STATE_AUDIO_CONNECTING", "#STATE_AUDIO_DISCONNECTED" ]
  }, {
    "name" : "public boolean stopScoUsingVirtualVoiceCall()",
    "returnType" : "boolean",
    "comment" : "\n     * Terminates an ongoing SCO connection and the associated virtual call.\n     *\n     * <p> Users can listen to {@link #ACTION_AUDIO_STATE_CHANGED}.\n     * If this function returns true, this intent will be broadcasted with\n     * {@link #EXTRA_STATE} set to {@link #STATE_AUDIO_DISCONNECTED}.\n     *\n     * @return true if successful, false if one of the following case applies\n     *  - virtual voice call is not started or has ended\n     *  - binder is dead or Bluetooth is disabled or other error\n     * @hide\n     ",
    "links" : [ "#ACTION_AUDIO_STATE_CHANGED", "#EXTRA_STATE", "#STATE_AUDIO_DISCONNECTED" ]
  }, {
    "name" : "public void phoneStateChanged(int numActive, int numHeld, int callState, String number, int type, String name)",
    "returnType" : "void",
    "comment" : "\n     * Notify Headset of phone state change.\n     * This is a backdoor for phone app to call BluetoothHeadset since\n     * there is currently not a good way to get precise call state change outside\n     * of phone app.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void clccResponse(int index, int direction, int status, int mode, boolean mpty, String number, int type)",
    "returnType" : "void",
    "comment" : "\n     * Send Headset of CLCC response\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean sendVendorSpecificResultCode(BluetoothDevice device, String command, String arg)",
    "returnType" : "boolean",
    "comment" : "\n     * Sends a vendor-specific unsolicited result code to the headset.\n     *\n     * <p>The actual string to be sent is <code>command + \": \" + arg</code>. For example, if {@code\n     * command} is {@link #VENDOR_RESULT_CODE_COMMAND_ANDROID} and {@code arg} is {@code \"0\"}, the\n     * string <code>\"+ANDROID: 0\"</code> will be sent.\n     *\n     * <p>Currently only {@link #VENDOR_RESULT_CODE_COMMAND_ANDROID} is allowed as {@code command}.\n     *\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.\n     *\n     * @param device Bluetooth headset.\n     * @param command A vendor-specific command.\n     * @param arg The argument that will be attached to the command.\n     * @return {@code false} if there is no headset connected, or if the command is not an allowed\n     * vendor-specific unsolicited result code, or on error. {@code true} otherwise.\n     * @throws IllegalArgumentException if {@code command} is {@code null}.\n     ",
    "links" : [ "#VENDOR_RESULT_CODE_COMMAND_ANDROID", "android.Manifest.permission#BLUETOOTH" ]
  }, {
    "name" : "public boolean setActiveDevice(@Nullable BluetoothDevice device)",
    "returnType" : "boolean",
    "comment" : "\n     * Select a connected device as active.\n     *\n     * The active device selection is per profile. An active device's\n     * purpose is profile-specific. For example, in HFP and HSP profiles,\n     * it is the device used for phone call audio. If a remote device is not\n     * connected, it cannot be selected as active.\n     *\n     * <p> This API returns false in scenarios like the profile on the\n     * device is not connected or Bluetooth is not turned on.\n     * When this API returns true, it is guaranteed that the\n     * {@link #ACTION_ACTIVE_DEVICE_CHANGED} intent will be broadcasted\n     * with the active device.\n     *\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}\n     * permission.\n     *\n     * @param device Remote Bluetooth Device, could be null if phone call audio should not be\n     * streamed to a headset\n     * @return false on immediate error, true otherwise\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#BLUETOOTH_ADMIN", "#ACTION_ACTIVE_DEVICE_CHANGED" ]
  }, {
    "name" : "public BluetoothDevice getActiveDevice()",
    "returnType" : "BluetoothDevice",
    "comment" : "\n     * Get the connected device that is active.\n     *\n     * @return the connected device that is active or null if no device\n     * is active.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isInbandRingingEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Check if in-band ringing is currently enabled. In-band ringing could be disabled during an\n     * active connection.\n     *\n     * @return true if in-band ringing is enabled, false if in-band ringing is disabled\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isInbandRingingSupported(Context context)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if in-band ringing is supported for this platform.\n     *\n     * @return true if in-band ringing is supported, false if in-band ringing is not supported\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isEnabled()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean isDisabled()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean isValidDevice(BluetoothDevice device)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void log(String msg)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "DBG", "VDBG", "ACTION_CONNECTION_STATE_CHANGED", "ACTION_AUDIO_STATE_CHANGED", "ACTION_ACTIVE_DEVICE_CHANGED", "ACTION_VENDOR_SPECIFIC_HEADSET_EVENT", "EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD", "EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE", "AT_CMD_TYPE_READ", "AT_CMD_TYPE_TEST", "AT_CMD_TYPE_SET", "AT_CMD_TYPE_BASIC", "AT_CMD_TYPE_ACTION", "EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_ARGS", "VENDOR_SPECIFIC_HEADSET_EVENT_COMPANY_ID_CATEGORY", "VENDOR_RESULT_CODE_COMMAND_ANDROID", "VENDOR_SPECIFIC_HEADSET_EVENT_XAPL", "VENDOR_SPECIFIC_HEADSET_EVENT_IPHONEACCEV", "VENDOR_SPECIFIC_HEADSET_EVENT_IPHONEACCEV_BATTERY_LEVEL", "VENDOR_SPECIFIC_HEADSET_EVENT_XEVENT", "VENDOR_SPECIFIC_HEADSET_EVENT_XEVENT_BATTERY_LEVEL", "STATE_AUDIO_DISCONNECTED", "STATE_AUDIO_CONNECTING", "STATE_AUDIO_CONNECTED", "ACTION_HF_INDICATORS_VALUE_CHANGED", "EXTRA_HF_INDICATORS_IND_ID", "EXTRA_HF_INDICATORS_IND_VALUE", "MESSAGE_HEADSET_SERVICE_CONNECTED", "MESSAGE_HEADSET_SERVICE_DISCONNECTED", "mContext", "mServiceListener", "mService", "mAdapter", "mBluetoothStateChangeCallback", "mConnection", "mHandler" ],
  "methodNames" : [ "private boolean doBind()", "private void doUnbind()", " void close()", "public boolean connect(BluetoothDevice device)", "public boolean disconnect(BluetoothDevice device)", "public List<BluetoothDevice> getConnectedDevices()", "public List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states)", "public int getConnectionState(BluetoothDevice device)", "public boolean setPriority(BluetoothDevice device, int priority)", "public boolean setConnectionPolicy(@NonNull BluetoothDevice device, @ConnectionPolicy int connectionPolicy)", "public int getPriority(BluetoothDevice device)", "public int getConnectionPolicy(@NonNull BluetoothDevice device)", "public boolean startVoiceRecognition(BluetoothDevice device)", "public boolean stopVoiceRecognition(BluetoothDevice device)", "public boolean isAudioConnected(BluetoothDevice device)", "public static boolean isBluetoothVoiceDialingEnabled(Context context)", "public int getAudioState(BluetoothDevice device)", "public void setAudioRouteAllowed(boolean allowed)", "public boolean getAudioRouteAllowed()", "public void setForceScoAudio(boolean forced)", "public boolean isAudioOn()", "public boolean connectAudio()", "public boolean disconnectAudio()", "public boolean startScoUsingVirtualVoiceCall()", "public boolean stopScoUsingVirtualVoiceCall()", "public void phoneStateChanged(int numActive, int numHeld, int callState, String number, int type, String name)", "public void clccResponse(int index, int direction, int status, int mode, boolean mpty, String number, int type)", "public boolean sendVendorSpecificResultCode(BluetoothDevice device, String command, String arg)", "public boolean setActiveDevice(@Nullable BluetoothDevice device)", "public BluetoothDevice getActiveDevice()", "public boolean isInbandRingingEnabled()", "public static boolean isInbandRingingSupported(Context context)", "private boolean isEnabled()", "private boolean isDisabled()", "private static boolean isValidDevice(BluetoothDevice device)", "private static void log(String msg)" ]
}