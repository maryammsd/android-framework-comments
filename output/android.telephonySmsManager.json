{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/telephony/SmsManager.java",
  "packageName" : "android.telephony",
  "className" : "SmsManager",
  "comment" : "\n * Manages SMS operations such as sending data, text, and pdu SMS messages.\n * Get this object by calling the static method {@link #getDefault()}. To create an instance of\n * {@link SmsManager} associated with a specific subscription ID, call\n * {@link #getSmsManagerForSubscriptionId(int)}. This is typically used for devices that support\n * multiple active subscriptions at once.\n *\n * <p>For information about how to behave as the default SMS app on Android 4.4 (API level 19)\n * and higher, see {@link android.provider.Telephony}.\n *\n * @see SubscriptionManager#getActiveSubscriptionInfoList()\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sInstance",
    "type" : "SmsManager",
    "comment" : " Singleton object constructed during class initialization. ",
    "links" : [ ]
  }, {
    "name" : "sLockObject",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SMS_RECORD_LENGTH",
    "type" : "int",
    "comment" : " SMS record length from TS 51.011 10.5.3\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CDMA_SMS_RECORD_LENGTH",
    "type" : "int",
    "comment" : " SMS record length from C.S0023 3.4.27\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "sSubInstances",
    "type" : "Map<Integer, SmsManager>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSubId",
    "type" : "int",
    "comment" : " A concrete subscription id, or the pseudo DEFAULT_SUBSCRIPTION_ID ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_APPEND_TRANSACTION_ID",
    "type" : "String",
    "comment" : "\n     * Whether to append transaction id to MMS WAP Push M-Notification.ind's content location URI\n     * when constructing the download URL of a new MMS (boolean type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_MMS_ENABLED",
    "type" : "String",
    "comment" : "\n     * Whether MMS is enabled for the current carrier (boolean type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_GROUP_MMS_ENABLED",
    "type" : "String",
    "comment" : "\n     * Whether group MMS is enabled for the current carrier (boolean type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_NOTIFY_WAP_MMSC_ENABLED",
    "type" : "String",
    "comment" : "\n     * If this is enabled, M-NotifyResp.ind should be sent to the WAP Push content location instead\n     * of the default MMSC (boolean type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_ALIAS_ENABLED",
    "type" : "String",
    "comment" : "\n     * Whether alias is enabled (boolean type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_ALLOW_ATTACH_AUDIO",
    "type" : "String",
    "comment" : "\n     * Whether audio is allowed to be attached for MMS messages (boolean type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_MULTIPART_SMS_ENABLED",
    "type" : "String",
    "comment" : "\n     * Whether multipart SMS is enabled (boolean type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_SMS_DELIVERY_REPORT_ENABLED",
    "type" : "String",
    "comment" : "\n     * Whether SMS delivery report is enabled (boolean type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_SUPPORT_MMS_CONTENT_DISPOSITION",
    "type" : "String",
    "comment" : "\n     * Whether content-disposition field should be expected in an MMS PDU (boolean type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_SEND_MULTIPART_SMS_AS_SEPARATE_MESSAGES",
    "type" : "String",
    "comment" : "\n     * Whether multipart SMS should be sent as separate messages\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_MMS_READ_REPORT_ENABLED",
    "type" : "String",
    "comment" : "\n     * Whether MMS read report is enabled (boolean type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_MMS_DELIVERY_REPORT_ENABLED",
    "type" : "String",
    "comment" : "\n     * Whether MMS delivery report is enabled (boolean type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_MAX_MESSAGE_SIZE",
    "type" : "String",
    "comment" : "\n     * Max MMS message size in bytes (int type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_MAX_IMAGE_WIDTH",
    "type" : "String",
    "comment" : "\n     * Max MMS image width (int type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_MAX_IMAGE_HEIGHT",
    "type" : "String",
    "comment" : "\n     * Max MMS image height (int type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_RECIPIENT_LIMIT",
    "type" : "String",
    "comment" : "\n     * Limit of recipients of MMS messages (int type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_ALIAS_MIN_CHARS",
    "type" : "String",
    "comment" : "\n     * Min alias character count (int type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_ALIAS_MAX_CHARS",
    "type" : "String",
    "comment" : "\n     * Max alias character count (int type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_SMS_TO_MMS_TEXT_THRESHOLD",
    "type" : "String",
    "comment" : "\n     * When the number of parts of a multipart SMS reaches this threshold, it should be converted\n     * into an MMS (int type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_SMS_TO_MMS_TEXT_LENGTH_THRESHOLD",
    "type" : "String",
    "comment" : "\n     * Some carriers require SMS to be converted into MMS when text length reaches this threshold\n     * (int type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_MESSAGE_TEXT_MAX_SIZE",
    "type" : "String",
    "comment" : "\n     * Max message text size (int type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_SUBJECT_MAX_LENGTH",
    "type" : "String",
    "comment" : "\n     * Max message subject length (int type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_HTTP_SOCKET_TIMEOUT",
    "type" : "String",
    "comment" : "\n     * MMS HTTP socket timeout in milliseconds (int type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_UA_PROF_TAG_NAME",
    "type" : "String",
    "comment" : "\n     * The name of the UA Prof URL HTTP header for MMS HTTP request (String type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_USER_AGENT",
    "type" : "String",
    "comment" : "\n     * The User-Agent header value for MMS HTTP request (String type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_UA_PROF_URL",
    "type" : "String",
    "comment" : "\n     * The UA Profile URL header value for MMS HTTP request (String type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_HTTP_PARAMS",
    "type" : "String",
    "comment" : "\n     * A list of HTTP headers to add to MMS HTTP request, separated by \"|\" (String type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_EMAIL_GATEWAY_NUMBER",
    "type" : "String",
    "comment" : "\n     * Email gateway number (String type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_NAI_SUFFIX",
    "type" : "String",
    "comment" : "\n     * The suffix to append to the NAI header value for MMS HTTP request (String type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_SHOW_CELL_BROADCAST_APP_LINKS",
    "type" : "String",
    "comment" : "\n     * If true, show the cell broadcast (amber alert) in the SMS settings. Some carriers don't want\n     * this shown. (Boolean type)\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_SUPPORT_HTTP_CHARSET_HEADER",
    "type" : "String",
    "comment" : "\n     * Whether the carrier MMSC supports charset field in Content-Type header. If this is false,\n     * then we don't add \"charset\" to \"Content-Type\"\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_CONFIG_CLOSE_CONNECTION",
    "type" : "String",
    "comment" : "\n     * If true, add \"Connection: close\" header to MMS HTTP requests so the connection\n     * is immediately closed (disabling keep-alive). (Boolean type)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SMS_MESSAGE_PRIORITY_NOT_SPECIFIED",
    "type" : "int",
    "comment" : "\n     * 3gpp2 SMS priority is not specified\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SMS_MESSAGE_PERIOD_NOT_SPECIFIED",
    "type" : "int",
    "comment" : "\n     * 3gpp SMS period is not specified\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PREMIUM_SMS_CONSENT_UNKNOWN",
    "type" : "int",
    "comment" : " Premium SMS Consent for the package is unknown. This indicates that the user\n     *  has not set a permission for this package, because this package has never tried\n     *  to send a premium SMS.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PREMIUM_SMS_CONSENT_ASK_USER",
    "type" : "int",
    "comment" : " Default premium SMS Consent (ask user for each premium SMS sent).\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PREMIUM_SMS_CONSENT_NEVER_ALLOW",
    "type" : "int",
    "comment" : " Premium SMS Consent when the owner has denied the app from sending premium SMS.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PREMIUM_SMS_CONSENT_ALWAYS_ALLOW",
    "type" : "int",
    "comment" : " Premium SMS Consent when the owner has allowed the app to send premium SMS.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "GET_TARGET_SDK_VERSION_CODE_CHANGE",
    "type" : "long",
    "comment" : "\n     * To check the SDK version for SmsManager.sendResolverResult method.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_ON_ICC_FREE",
    "type" : "int",
    "comment" : " Free space (TS 51.011 10.5.3 / 3GPP2 C.S0023 3.4.27). ",
    "links" : [ ]
  }, {
    "name" : "STATUS_ON_ICC_READ",
    "type" : "int",
    "comment" : " Received and read (TS 51.011 10.5.3 / 3GPP2 C.S0023 3.4.27). ",
    "links" : [ ]
  }, {
    "name" : "STATUS_ON_ICC_UNREAD",
    "type" : "int",
    "comment" : " Received and unread (TS 51.011 10.5.3 / 3GPP2 C.S0023 3.4.27). ",
    "links" : [ ]
  }, {
    "name" : "STATUS_ON_ICC_SENT",
    "type" : "int",
    "comment" : " Stored and sent (TS 51.011 10.5.3 / 3GPP2 C.S0023 3.4.27). ",
    "links" : [ ]
  }, {
    "name" : "STATUS_ON_ICC_UNSENT",
    "type" : "int",
    "comment" : " Stored and unsent (TS 51.011 10.5.3 / 3GPP2 C.S0023 3.4.27). ",
    "links" : [ ]
  }, {
    "name" : "RESULT_ERROR_NONE",
    "type" : "int",
    "comment" : "\n     * No error.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_ERROR_GENERIC_FAILURE",
    "type" : "int",
    "comment" : " Generic failure cause ",
    "links" : [ ]
  }, {
    "name" : "RESULT_ERROR_RADIO_OFF",
    "type" : "int",
    "comment" : " Failed because radio was explicitly turned off ",
    "links" : [ ]
  }, {
    "name" : "RESULT_ERROR_NULL_PDU",
    "type" : "int",
    "comment" : " Failed because no pdu provided ",
    "links" : [ ]
  }, {
    "name" : "RESULT_ERROR_NO_SERVICE",
    "type" : "int",
    "comment" : " Failed because service is currently unavailable ",
    "links" : [ ]
  }, {
    "name" : "RESULT_ERROR_LIMIT_EXCEEDED",
    "type" : "int",
    "comment" : " Failed because we reached the sending queue limit. ",
    "links" : [ ]
  }, {
    "name" : "RESULT_ERROR_FDN_CHECK_FAILURE",
    "type" : "int",
    "comment" : "\n     * Failed because FDN is enabled.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_ERROR_SHORT_CODE_NOT_ALLOWED",
    "type" : "int",
    "comment" : " Failed because user denied the sending of this short code. ",
    "links" : [ ]
  }, {
    "name" : "RESULT_ERROR_SHORT_CODE_NEVER_ALLOWED",
    "type" : "int",
    "comment" : " Failed because the user has denied this app ever send premium short codes. ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RADIO_NOT_AVAILABLE",
    "type" : "int",
    "comment" : "\n     * Failed because the radio was not available\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_NETWORK_REJECT",
    "type" : "int",
    "comment" : "\n     * Failed because of network rejection\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_INVALID_ARGUMENTS",
    "type" : "int",
    "comment" : "\n     * Failed because of invalid arguments\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_INVALID_STATE",
    "type" : "int",
    "comment" : "\n     * Failed because of an invalid state\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_NO_MEMORY",
    "type" : "int",
    "comment" : "\n     * Failed because there is no memory\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_INVALID_SMS_FORMAT",
    "type" : "int",
    "comment" : "\n     * Failed because the sms format is not valid\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_SYSTEM_ERROR",
    "type" : "int",
    "comment" : "\n     * Failed because of a system error\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_MODEM_ERROR",
    "type" : "int",
    "comment" : "\n     * Failed because of a modem error\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_NETWORK_ERROR",
    "type" : "int",
    "comment" : "\n     * Failed because of a network error\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_ENCODING_ERROR",
    "type" : "int",
    "comment" : "\n     * Failed because of an encoding error\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_INVALID_SMSC_ADDRESS",
    "type" : "int",
    "comment" : "\n     * Failed because of an invalid smsc address\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_OPERATION_NOT_ALLOWED",
    "type" : "int",
    "comment" : "\n     * Failed because the operation is not allowed\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_INTERNAL_ERROR",
    "type" : "int",
    "comment" : "\n     * Failed because of an internal error\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_NO_RESOURCES",
    "type" : "int",
    "comment" : "\n     * Failed because there are no resources\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_CANCELLED",
    "type" : "int",
    "comment" : "\n     * Failed because the operation was cancelled\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_REQUEST_NOT_SUPPORTED",
    "type" : "int",
    "comment" : "\n     * Failed because the request is not supported\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_NO_BLUETOOTH_SERVICE",
    "type" : "int",
    "comment" : "\n     * Failed sending via bluetooth because the bluetooth service is not available\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_INVALID_BLUETOOTH_ADDRESS",
    "type" : "int",
    "comment" : "\n     * Failed sending via bluetooth because the bluetooth device address is invalid\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_BLUETOOTH_DISCONNECTED",
    "type" : "int",
    "comment" : "\n     * Failed sending via bluetooth because bluetooth disconnected\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_UNEXPECTED_EVENT_STOP_SENDING",
    "type" : "int",
    "comment" : "\n     * Failed sending because the user denied or canceled the dialog displayed for a premium\n     * shortcode sms or rate-limited sms.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_SMS_BLOCKED_DURING_EMERGENCY",
    "type" : "int",
    "comment" : "\n     * Failed sending during an emergency call\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_SMS_SEND_RETRY_FAILED",
    "type" : "int",
    "comment" : "\n     * Failed to send an sms retry\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_REMOTE_EXCEPTION",
    "type" : "int",
    "comment" : "\n     * Set by BroadcastReceiver to indicate a remote exception while handling a message.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_NO_DEFAULT_SMS_APP",
    "type" : "int",
    "comment" : "\n     * Set by BroadcastReceiver to indicate there's no default sms app.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RIL_RADIO_NOT_AVAILABLE",
    "type" : "int",
    "comment" : "\n     * The radio did not start or is resetting.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RIL_SMS_SEND_FAIL_RETRY",
    "type" : "int",
    "comment" : "\n     * The radio failed to send the sms and needs to retry.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RIL_NETWORK_REJECT",
    "type" : "int",
    "comment" : "\n     * The sms request was rejected by the network.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RIL_INVALID_STATE",
    "type" : "int",
    "comment" : "\n     * The radio returned an unexpected request for the current state.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RIL_INVALID_ARGUMENTS",
    "type" : "int",
    "comment" : "\n     * The radio received invalid arguments in the request.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RIL_NO_MEMORY",
    "type" : "int",
    "comment" : "\n     * The radio didn't have sufficient memory to process the request.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RIL_REQUEST_RATE_LIMITED",
    "type" : "int",
    "comment" : "\n     * The radio denied the operation due to overly-frequent requests.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RIL_INVALID_SMS_FORMAT",
    "type" : "int",
    "comment" : "\n     * The radio returned an error indicating invalid sms format.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RIL_SYSTEM_ERR",
    "type" : "int",
    "comment" : "\n     * The radio encountered a platform or system error.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RIL_ENCODING_ERR",
    "type" : "int",
    "comment" : "\n     * The SMS message was not encoded properly.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RIL_INVALID_SMSC_ADDRESS",
    "type" : "int",
    "comment" : "\n     * The specified SMSC address was invalid.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RIL_MODEM_ERR",
    "type" : "int",
    "comment" : "\n     * The vendor RIL received an unexpected or incorrect response.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RIL_NETWORK_ERR",
    "type" : "int",
    "comment" : "\n     * The radio received an error from the network.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RIL_INTERNAL_ERR",
    "type" : "int",
    "comment" : "\n     * The modem encountered an unexpected error scenario while handling the request.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RIL_REQUEST_NOT_SUPPORTED",
    "type" : "int",
    "comment" : "\n     * The request was not supported by the radio.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RIL_INVALID_MODEM_STATE",
    "type" : "int",
    "comment" : "\n     * The radio cannot process the request in the current modem state.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RIL_NETWORK_NOT_READY",
    "type" : "int",
    "comment" : "\n     * The network is not ready to perform the request.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RIL_OPERATION_NOT_ALLOWED",
    "type" : "int",
    "comment" : "\n     * The radio reports the request is not allowed.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RIL_NO_RESOURCES",
    "type" : "int",
    "comment" : "\n     * There are insufficient resources to process the request.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RIL_CANCELLED",
    "type" : "int",
    "comment" : "\n     * The request has been cancelled.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RIL_SIM_ABSENT",
    "type" : "int",
    "comment" : "\n     * The radio failed to set the location where the CDMA subscription\n     * can be retrieved because the SIM or RUIM is absent.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RECEIVE_DISPATCH_FAILURE",
    "type" : "int",
    "comment" : "\n     * SMS receive dispatch failure.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RECEIVE_INJECTED_NULL_PDU",
    "type" : "int",
    "comment" : "\n     * SMS receive injected null PDU.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RECEIVE_RUNTIME_EXCEPTION",
    "type" : "int",
    "comment" : "\n     * SMS receive encountered runtime exception.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RECEIVE_NULL_MESSAGE_FROM_RIL",
    "type" : "int",
    "comment" : "\n     * SMS received null message from the radio interface layer.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RECEIVE_WHILE_ENCRYPTED",
    "type" : "int",
    "comment" : "\n     * SMS short code received while the phone is in encrypted state.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RECEIVE_SQL_EXCEPTION",
    "type" : "int",
    "comment" : "\n     * SMS receive encountered an SQL exception.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_RECEIVE_URI_EXCEPTION",
    "type" : "int",
    "comment" : "\n     * SMS receive an exception parsing a uri.\n     ",
    "links" : [ ]
  }, {
    "name" : "MMS_ERROR_UNSPECIFIED",
    "type" : "int",
    "comment" : " MMS send/download failure result codes",
    "links" : [ ]
  }, {
    "name" : "MMS_ERROR_INVALID_APN",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MMS_ERROR_UNABLE_CONNECT_MMS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MMS_ERROR_HTTP_FAILURE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MMS_ERROR_IO_ERROR",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MMS_ERROR_RETRY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MMS_ERROR_CONFIGURATION_ERROR",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MMS_ERROR_NO_DATA_NETWORK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EXTRA_MMS_DATA",
    "type" : "String",
    "comment" : " Intent extra name for MMS sending result data in byte array type ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_MMS_HTTP_STATUS",
    "type" : "String",
    "comment" : " Intent extra name for HTTP status code for MMS HTTP failure in integer type ",
    "links" : [ ]
  }, {
    "name" : "REGEX_PREFIX_DELIMITER",
    "type" : "String",
    "comment" : "\n     * @see #createAppSpecificSmsTokenWithPackageInfo(String, PendingIntent).\n     * The prefixes is a list of prefix {@code String} separated by this delimiter.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_STATUS_SUCCESS",
    "type" : "int",
    "comment" : "\n     * @see #createAppSpecificSmsTokenWithPackageInfo(String, PendingIntent).\n     * The success status to be added into the intent to be sent to the calling package.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RESULT_STATUS_TIMEOUT",
    "type" : "int",
    "comment" : "\n     * @see #createAppSpecificSmsTokenWithPackageInfo(String, PendingIntent).\n     * The timeout status to be added into the intent to be sent to the calling package.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_SMS_MESSAGE",
    "type" : "String",
    "comment" : "\n     * @see #createAppSpecificSmsTokenWithPackageInfo(String, PendingIntent).\n     * Intent extra key of the retrieved SMS message as a {@code String}.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_STATUS",
    "type" : "String",
    "comment" : "\n     * @see #createAppSpecificSmsTokenWithPackageInfo(String, PendingIntent).\n     * Intent extra key of SMS retriever status, which indicates whether the request for the\n     * coming SMS message is SUCCESS or TIMEOUT\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_SIM_SUBSCRIPTION_ID",
    "type" : "String",
    "comment" : "\n     * @see #createAppSpecificSmsTokenWithPackageInfo(String, PendingIntent).\n     * [Optional] Intent extra key of the retrieved Sim card subscription Id if any. {@code int}\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SMS_CATEGORY_NOT_SHORT_CODE",
    "type" : "int",
    "comment" : "\n     * Return value from {@link #checkSmsShortCodeDestination(String, String)} ()} for regular\n     * phone numbers.\n     * @hide\n     ",
    "links" : [ "#checkSmsShortCodeDestination" ]
  }, {
    "name" : "SMS_CATEGORY_FREE_SHORT_CODE",
    "type" : "int",
    "comment" : "\n     * Return value from {@link #checkSmsShortCodeDestination(String, String)} ()} for free\n     * (no cost) short codes.\n     * @hide\n     ",
    "links" : [ "#checkSmsShortCodeDestination" ]
  }, {
    "name" : "SMS_CATEGORY_STANDARD_SHORT_CODE",
    "type" : "int",
    "comment" : "\n     * Return value from {@link #checkSmsShortCodeDestination(String, String)} ()} for\n     * standard rate (non-premium)\n     * short codes.\n     * @hide\n     ",
    "links" : [ "#checkSmsShortCodeDestination" ]
  }, {
    "name" : "SMS_CATEGORY_POSSIBLE_PREMIUM_SHORT_CODE",
    "type" : "int",
    "comment" : "\n     * Return value from {@link #checkSmsShortCodeDestination(String, String)} ()} for possible\n     * premium short codes.\n     * @hide\n     ",
    "links" : [ "#checkSmsShortCodeDestination" ]
  }, {
    "name" : "SMS_CATEGORY_PREMIUM_SHORT_CODE",
    "type" : "int",
    "comment" : "\n     * Return value from {@link #checkSmsShortCodeDestination(String, String)} ()} for\n     * premium short codes.\n     * @hide\n     ",
    "links" : [ "#checkSmsShortCodeDestination" ]
  } ],
  "methods" : [ {
    "name" : "public void sendTextMessage(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent)",
    "returnType" : "void",
    "comment" : "\n     * Send a text based SMS.\n     *\n     * <p class=\"note\"><strong>Note:</strong> Using this method requires that your app has the\n     * {@link android.Manifest.permission#SEND_SMS} permission.</p>\n     *\n     * <p class=\"note\"><strong>Note:</strong> Beginning with Android 4.4 (API level 19), if\n     * <em>and only if</em> an app is not selected as the default SMS app, the system automatically\n     * writes messages sent using this method to the SMS Provider (the default SMS app is always\n     * responsible for writing its sent messages to the SMS Provider). For information about\n     * how to behave as the default SMS app, see {@link android.provider.Telephony}.</p>\n     *\n     * <p class=\"note\"><strong>Note:</strong> If {@link #getDefault()} is used to instantiate this\n     * manager on a multi-SIM device, this operation may fail sending the SMS message because no\n     * suitable default subscription could be found. In this case, if {@code sentIntent} is\n     * non-null, then the {@link PendingIntent} will be sent with an error code\n     * {@code RESULT_ERROR_GENERIC_FAILURE} and an extra string {@code \"noDefault\"} containing the\n     * boolean value {@code true}. See {@link #getDefault()} for more information on the conditions\n     * where this operation may fail.\n     * </p>\n     *\n     *\n     * @param destinationAddress the address to send the message to\n     * @param scAddress is the service center address or null to use\n     *  the current default SMSC\n     * @param text the body of the message to send\n     * @param sentIntent if not NULL this <code>PendingIntent</code> is\n     *  broadcast when the message is successfully sent, or failed.\n     *  The result code will be <code>Activity.RESULT_OK</code> for success,\n     *  or one of these errors:<br>\n     *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>\n     *  <code>RESULT_ERROR_RADIO_OFF</code><br>\n     *  <code>RESULT_ERROR_NULL_PDU</code><br>\n     *  <code>RESULT_ERROR_NO_SERVICE</code><br>\n     *  <code>RESULT_ERROR_NO_SERVICE</code><br>\n     *  <code>RESULT_ERROR_LIMIT_EXCEEDED</code><br>\n     *  <code>RESULT_ERROR_FDN_CHECK_FAILURE</code><br>\n     *  <code>RESULT_ERROR_SHORT_CODE_NOT_ALLOWED</code><br>\n     *  <code>RESULT_ERROR_SHORT_CODE_NEVER_ALLOWED</code><br>\n     *  <code>RESULT_RADIO_NOT_AVAILABLE</code><br>\n     *  <code>RESULT_NETWORK_REJECT</code><br>\n     *  <code>RESULT_INVALID_ARGUMENTS</code><br>\n     *  <code>RESULT_INVALID_STATE</code><br>\n     *  <code>RESULT_NO_MEMORY</code><br>\n     *  <code>RESULT_INVALID_SMS_FORMAT</code><br>\n     *  <code>RESULT_SYSTEM_ERROR</code><br>\n     *  <code>RESULT_MODEM_ERROR</code><br>\n     *  <code>RESULT_NETWORK_ERROR</code><br>\n     *  <code>RESULT_ENCODING_ERROR</code><br>\n     *  <code>RESULT_INVALID_SMSC_ADDRESS</code><br>\n     *  <code>RESULT_OPERATION_NOT_ALLOWED</code><br>\n     *  <code>RESULT_INTERNAL_ERROR</code><br>\n     *  <code>RESULT_NO_RESOURCES</code><br>\n     *  <code>RESULT_CANCELLED</code><br>\n     *  <code>RESULT_REQUEST_NOT_SUPPORTED</code><br>\n     *  <code>RESULT_NO_BLUETOOTH_SERVICE</code><br>\n     *  <code>RESULT_INVALID_BLUETOOTH_ADDRESS</code><br>\n     *  <code>RESULT_BLUETOOTH_DISCONNECTED</code><br>\n     *  <code>RESULT_UNEXPECTED_EVENT_STOP_SENDING</code><br>\n     *  <code>RESULT_SMS_BLOCKED_DURING_EMERGENCY</code><br>\n     *  <code>RESULT_SMS_SEND_RETRY_FAILED</code><br>\n     *  <code>RESULT_REMOTE_EXCEPTION</code><br>\n     *  <code>RESULT_NO_DEFAULT_SMS_APP</code><br>\n     *  <code>RESULT_RIL_RADIO_NOT_AVAILABLE</code><br>\n     *  <code>RESULT_RIL_SMS_SEND_FAIL_RETRY</code><br>\n     *  <code>RESULT_RIL_NETWORK_REJECT</code><br>\n     *  <code>RESULT_RIL_INVALID_STATE</code><br>\n     *  <code>RESULT_RIL_INVALID_ARGUMENTS</code><br>\n     *  <code>RESULT_RIL_NO_MEMORY</code><br>\n     *  <code>RESULT_RIL_REQUEST_RATE_LIMITED</code><br>\n     *  <code>RESULT_RIL_INVALID_SMS_FORMAT</code><br>\n     *  <code>RESULT_RIL_SYSTEM_ERR</code><br>\n     *  <code>RESULT_RIL_ENCODING_ERR</code><br>\n     *  <code>RESULT_RIL_INVALID_SMSC_ADDRESS</code><br>\n     *  <code>RESULT_RIL_MODEM_ERR</code><br>\n     *  <code>RESULT_RIL_NETWORK_ERR</code><br>\n     *  <code>RESULT_RIL_INTERNAL_ERR</code><br>\n     *  <code>RESULT_RIL_REQUEST_NOT_SUPPORTED</code><br>\n     *  <code>RESULT_RIL_INVALID_MODEM_STATE</code><br>\n     *  <code>RESULT_RIL_NETWORK_NOT_READY</code><br>\n     *  <code>RESULT_RIL_OPERATION_NOT_ALLOWED</code><br>\n     *  <code>RESULT_RIL_NO_RESOURCES</code><br>\n     *  <code>RESULT_RIL_CANCELLED</code><br>\n     *  <code>RESULT_RIL_SIM_ABSENT</code><br>\n     *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> or any of the RESULT_RIL errors,\n     *  the sentIntent may include the extra \"errorCode\" containing a radio technology specific\n     *  value, generally only useful for troubleshooting.<br>\n     *  The per-application based SMS control checks sentIntent. If sentIntent\n     *  is NULL the caller will be checked against all unknown applications,\n     *  which cause smaller number of SMS to be sent in checking period.\n     * @param deliveryIntent if not NULL this <code>PendingIntent</code> is\n     *  broadcast when the message is delivered to the recipient.  The\n     *  raw pdu of the status report is in the extended data (\"pdu\").\n     *\n     * @throws IllegalArgumentException if destinationAddress or text are empty\n     ",
    "links" : [ "android.Manifest.permission#SEND_SMS", "android.provider.Telephony", "#getDefault", "PendingIntent", "#getDefault" ]
  }, {
    "name" : "public void sendTextMessage(@NonNull String destinationAddress, @Nullable String scAddress, @NonNull String text, @Nullable PendingIntent sentIntent, @Nullable PendingIntent deliveryIntent, long messageId)",
    "returnType" : "void",
    "comment" : "\n     * Send a text based SMS. Same as {@link #sendTextMessage( String destinationAddress,\n     * String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent)}, but\n     * adds an optional messageId.\n     * @param messageId An id that uniquely identifies the message requested to be sent.\n     * Used for logging and diagnostics purposes. The id may be 0.\n     *\n     * @throws IllegalArgumentException if destinationAddress or text are empty\n     *\n     ",
    "links" : [ "#sendTextMessage" ]
  }, {
    "name" : "public void sendTextMessage(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, int priority, boolean expectMore, int validityPeriod)",
    "returnType" : "void",
    "comment" : "\n     * Send a text based SMS with messaging options.\n     *\n     * <p class=\"note\"><strong>Note:</strong> If {@link #getDefault()} is used to instantiate this\n     * manager on a multi-SIM device, this operation may fail sending the SMS message because no\n     * suitable default subscription could be found. In this case, if {@code sentIntent} is\n     * non-null, then the {@link PendingIntent} will be sent with an error code\n     * {@code RESULT_ERROR_GENERIC_FAILURE} and an extra string {@code \"noDefault\"} containing the\n     * boolean value {@code true}. See {@link #getDefault()} for more information on the conditions\n     * where this operation may fail.\n     * </p>\n     *\n     * @param destinationAddress the address to send the message to\n     * @param scAddress is the service center address or null to use\n     *  the current default SMSC\n     * @param text the body of the message to send\n     * @param sentIntent if not NULL this <code>PendingIntent</code> is\n     *  broadcast when the message is successfully sent, or failed.\n     *  The result code will be <code>Activity.RESULT_OK</code> for success,\n     *  or one of these errors:<br>\n     *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>\n     *  <code>RESULT_ERROR_RADIO_OFF</code><br>\n     *  <code>RESULT_ERROR_NULL_PDU</code><br>\n     *  <code>RESULT_ERROR_NO_SERVICE</code><br>\n     *  <code>RESULT_ERROR_NO_SERVICE</code><br>\n     *  <code>RESULT_ERROR_LIMIT_EXCEEDED</code><br>\n     *  <code>RESULT_ERROR_FDN_CHECK_FAILURE</code><br>\n     *  <code>RESULT_ERROR_SHORT_CODE_NOT_ALLOWED</code><br>\n     *  <code>RESULT_ERROR_SHORT_CODE_NEVER_ALLOWED</code><br>\n     *  <code>RESULT_RADIO_NOT_AVAILABLE</code><br>\n     *  <code>RESULT_NETWORK_REJECT</code><br>\n     *  <code>RESULT_INVALID_ARGUMENTS</code><br>\n     *  <code>RESULT_INVALID_STATE</code><br>\n     *  <code>RESULT_NO_MEMORY</code><br>\n     *  <code>RESULT_INVALID_SMS_FORMAT</code><br>\n     *  <code>RESULT_SYSTEM_ERROR</code><br>\n     *  <code>RESULT_MODEM_ERROR</code><br>\n     *  <code>RESULT_NETWORK_ERROR</code><br>\n     *  <code>RESULT_ENCODING_ERROR</code><br>\n     *  <code>RESULT_INVALID_SMSC_ADDRESS</code><br>\n     *  <code>RESULT_OPERATION_NOT_ALLOWED</code><br>\n     *  <code>RESULT_INTERNAL_ERROR</code><br>\n     *  <code>RESULT_NO_RESOURCES</code><br>\n     *  <code>RESULT_CANCELLED</code><br>\n     *  <code>RESULT_REQUEST_NOT_SUPPORTED</code><br>\n     *  <code>RESULT_NO_BLUETOOTH_SERVICE</code><br>\n     *  <code>RESULT_INVALID_BLUETOOTH_ADDRESS</code><br>\n     *  <code>RESULT_BLUETOOTH_DISCONNECTED</code><br>\n     *  <code>RESULT_UNEXPECTED_EVENT_STOP_SENDING</code><br>\n     *  <code>RESULT_SMS_BLOCKED_DURING_EMERGENCY</code><br>\n     *  <code>RESULT_SMS_SEND_RETRY_FAILED</code><br>\n     *  <code>RESULT_REMOTE_EXCEPTION</code><br>\n     *  <code>RESULT_NO_DEFAULT_SMS_APP</code><br>\n     *  <code>RESULT_RIL_RADIO_NOT_AVAILABLE</code><br>\n     *  <code>RESULT_RIL_SMS_SEND_FAIL_RETRY</code><br>\n     *  <code>RESULT_RIL_NETWORK_REJECT</code><br>\n     *  <code>RESULT_RIL_INVALID_STATE</code><br>\n     *  <code>RESULT_RIL_INVALID_ARGUMENTS</code><br>\n     *  <code>RESULT_RIL_NO_MEMORY</code><br>\n     *  <code>RESULT_RIL_REQUEST_RATE_LIMITED</code><br>\n     *  <code>RESULT_RIL_INVALID_SMS_FORMAT</code><br>\n     *  <code>RESULT_RIL_SYSTEM_ERR</code><br>\n     *  <code>RESULT_RIL_ENCODING_ERR</code><br>\n     *  <code>RESULT_RIL_INVALID_SMSC_ADDRESS</code><br>\n     *  <code>RESULT_RIL_MODEM_ERR</code><br>\n     *  <code>RESULT_RIL_NETWORK_ERR</code><br>\n     *  <code>RESULT_RIL_INTERNAL_ERR</code><br>\n     *  <code>RESULT_RIL_REQUEST_NOT_SUPPORTED</code><br>\n     *  <code>RESULT_RIL_INVALID_MODEM_STATE</code><br>\n     *  <code>RESULT_RIL_NETWORK_NOT_READY</code><br>\n     *  <code>RESULT_RIL_OPERATION_NOT_ALLOWED</code><br>\n     *  <code>RESULT_RIL_NO_RESOURCES</code><br>\n     *  <code>RESULT_RIL_CANCELLED</code><br>\n     *  <code>RESULT_RIL_SIM_ABSENT</code><br>\n     *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> or any of the RESULT_RIL errors,\n     *  the sentIntent may include the extra \"errorCode\" containing a radio technology specific\n     *  value, generally only useful for troubleshooting.<br>\n     *  The per-application based SMS control checks sentIntent. If sentIntent\n     *  is NULL the caller will be checked against all unknown applications,\n     *  which cause smaller number of SMS to be sent in checking period.\n     * @param deliveryIntent if not NULL this <code>PendingIntent</code> is\n     *  broadcast when the message is delivered to the recipient.  The\n     *  raw pdu of the status report is in the extended data (\"pdu\").\n     * @param priority Priority level of the message\n     *  Refer specification See 3GPP2 C.S0015-B, v2.0, table 4.5.9-1\n     *  ---------------------------------\n     *  PRIORITY      | Level of Priority\n     *  ---------------------------------\n     *      '00'      |     Normal\n     *      '01'      |     Interactive\n     *      '10'      |     Urgent\n     *      '11'      |     Emergency\n     *  ----------------------------------\n     *  Any Other values included Negative considered as Invalid Priority Indicator of the message.\n     * @param expectMore is a boolean to indicate the sending messages through same link or not.\n     * @param validityPeriod Validity Period of the message in mins.\n     *  Refer specification 3GPP TS 23.040 V6.8.1 section 9.2.3.12.1.\n     *  Validity Period(Minimum) -> 5 mins\n     *  Validity Period(Maximum) -> 635040 mins(i.e.63 weeks).\n     *  Any Other values included Negative considered as Invalid Validity Period of the message.\n     *\n     * @throws IllegalArgumentException if destinationAddress or text are empty\n     * {@hide}\n     ",
    "links" : [ "#getDefault", "PendingIntent", "#getDefault" ]
  }, {
    "name" : "private void sendTextMessageInternal(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessage, String packageName, String attributionTag, long messageId)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void sendTextMessageWithoutPersisting(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent)",
    "returnType" : "void",
    "comment" : "\n     * Send a text based SMS without writing it into the SMS Provider.\n     *\n     * <p>\n     * The message will be sent directly over the network and will not be visible in SMS\n     * applications. Intended for internal carrier use only.\n     * </p>\n     *\n     * <p>Requires Permission: Both {@link android.Manifest.permission#SEND_SMS} and\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE}, or that the calling app has carrier\n     * privileges (see {@link TelephonyManager#hasCarrierPrivileges}), or that the calling app is\n     * the default IMS app (see\n     * {@link CarrierConfigManager#KEY_CONFIG_IMS_PACKAGE_OVERRIDE_STRING}).\n     * </p>\n     *\n     * <p class=\"note\"><strong>Note:</strong> This method is intended for internal use by carrier\n     * applications or the Telephony framework and will never trigger an SMS disambiguation\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\n     * default subscription is defined, the subscription ID associated with this message will be\n     * INVALID, which will result in the SMS being sent on the subscription associated with logical\n     * slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the SMS is sent on the\n     * correct subscription.\n     * </p>\n     *\n     * @see #sendTextMessage(String, String, String, PendingIntent, PendingIntent)\n     ",
    "links" : [ "android.Manifest.permission#SEND_SMS", "android.Manifest.permission#MODIFY_PHONE_STATE", "TelephonyManager#hasCarrierPrivileges", "CarrierConfigManager#KEY_CONFIG_IMS_PACKAGE_OVERRIDE_STRING", "SmsManager", "#getDefault", "#getSmsManagerForSubscriptionId" ]
  }, {
    "name" : "private void sendTextMessageInternal(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessage, int priority, boolean expectMore, int validityPeriod)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void sendTextMessageWithoutPersisting(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, int priority, boolean expectMore, int validityPeriod)",
    "returnType" : "void",
    "comment" : "\n     * Send a text based SMS without writing it into the SMS Provider.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE} or the calling app has carrier\n     * privileges.\n     * </p>\n     *\n     * <p class=\"note\"><strong>Note:</strong> This method is intended for internal use by carrier\n     * applications or the Telephony framework and will never trigger an SMS disambiguation\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\n     * default subscription is defined, the subscription ID associated with this message will be\n     * INVALID, which will result in the SMS being sent on the subscription associated with logical\n     * slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the SMS is sent on the\n     * correct subscription.\n     * </p>\n     *\n     * @see #sendTextMessage(String, String, String, PendingIntent,\n     * PendingIntent, int, boolean, int)\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MODIFY_PHONE_STATE", "SmsManager", "#getDefault", "#getSmsManagerForSubscriptionId" ]
  }, {
    "name" : "public void injectSmsPdu(byte[] pdu, @SmsMessage.Format String format, PendingIntent receivedIntent)",
    "returnType" : "void",
    "comment" : "\n     *\n     * Inject an SMS PDU into the android application framework.\n     *\n     * <p>Requires permission: {@link android.Manifest.permission#MODIFY_PHONE_STATE} or carrier\n     * privileges per {@link android.telephony.TelephonyManager#hasCarrierPrivileges}.\n     *\n     * <p class=\"note\"><strong>Note:</strong> This method is intended for internal use by carrier\n     * applications or the Telephony framework and will never trigger an SMS disambiguation\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\n     * default subscription is defined, the subscription ID associated with this message will be\n     * INVALID, which will result in the SMS being injected on the subscription associated with\n     * logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the SMS is\n     * delivered to the correct subscription.\n     * </p>\n     *\n     * @param pdu is the byte array of pdu to be injected into android application framework\n     * @param format is the format of SMS pdu ({@link SmsMessage#FORMAT_3GPP} or\n     *  {@link SmsMessage#FORMAT_3GPP2})\n     * @param receivedIntent if not NULL this <code>PendingIntent</code> is\n     *  broadcast when the message is successfully received by the\n     *  android application framework, or failed. This intent is broadcasted at\n     *  the same time an SMS received from radio is acknowledged back.\n     *  The result code will be {@link android.provider.Telephony.Sms.Intents#RESULT_SMS_HANDLED}\n     *  for success, or {@link android.provider.Telephony.Sms.Intents#RESULT_SMS_GENERIC_ERROR} or\n     *  {@link #RESULT_REMOTE_EXCEPTION} for error.\n     *\n     * @throws IllegalArgumentException if the format is invalid.\n     ",
    "links" : [ "android.Manifest.permission#MODIFY_PHONE_STATE", "android.telephony.TelephonyManager#hasCarrierPrivileges", "SmsManager", "#getDefault", "#getSmsManagerForSubscriptionId", "SmsMessage#FORMAT_3GPP", "SmsMessage#FORMAT_3GPP2", "android.provider.Telephony.Sms.Intents#RESULT_SMS_HANDLED", "android.provider.Telephony.Sms.Intents#RESULT_SMS_GENERIC_ERROR", "#RESULT_REMOTE_EXCEPTION" ]
  }, {
    "name" : "public ArrayList<String> divideMessage(String text)",
    "returnType" : "ArrayList<String>",
    "comment" : "\n     * Divide a message text into several fragments, none bigger than the maximum SMS message size.\n     *\n     * @param text the original message. Must not be null.\n     * @return an <code>ArrayList</code> of strings that, in order, comprise the original message.\n     * @throws IllegalArgumentException if text is null.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void sendMultipartTextMessage(String destinationAddress, String scAddress, ArrayList<String> parts, ArrayList<PendingIntent> sentIntents, ArrayList<PendingIntent> deliveryIntents)",
    "returnType" : "void",
    "comment" : "\n     * Send a multi-part text based SMS.  The callee should have already\n     * divided the message into correctly sized parts by calling\n     * <code>divideMessage</code>.\n     *\n     * <p class=\"note\"><strong>Note:</strong> Using this method requires that your app has the\n     * {@link android.Manifest.permission#SEND_SMS} permission.</p>\n     *\n     * <p class=\"note\"><strong>Note:</strong> Beginning with Android 4.4 (API level 19), if\n     * <em>and only if</em> an app is not selected as the default SMS app, the system automatically\n     * writes messages sent using this method to the SMS Provider (the default SMS app is always\n     * responsible for writing its sent messages to the SMS Provider). For information about\n     * how to behave as the default SMS app, see {@link android.provider.Telephony}.</p>\n     *\n     * <p class=\"note\"><strong>Note:</strong> If {@link #getDefault()} is used to instantiate this\n     * manager on a multi-SIM device, this operation may fail sending the SMS message because no\n     * suitable default subscription could be found. In this case, if {@code sentIntent} is\n     * non-null, then the {@link PendingIntent} will be sent with an error code\n     * {@code RESULT_ERROR_GENERIC_FAILURE} and an extra string {@code \"noDefault\"} containing the\n     * boolean value {@code true}. See {@link #getDefault()} for more information on the conditions\n     * where this operation may fail.\n     * </p>\n     *\n     *\n     * @param destinationAddress the address to send the message to\n     * @param scAddress is the service center address or null to use\n     *   the current default SMSC\n     * @param parts an <code>ArrayList</code> of strings that, in order,\n     *   comprise the original message\n     * @param sentIntents if not null, an <code>ArrayList</code> of\n     *   <code>PendingIntent</code>s (one for each message part) that is\n     *   broadcast when the corresponding message part has been sent.\n     *   The result code will be <code>Activity.RESULT_OK</code> for success,\n     *   or one of these errors:<br>\n     *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>\n     *  <code>RESULT_ERROR_RADIO_OFF</code><br>\n     *  <code>RESULT_ERROR_NULL_PDU</code><br>\n     *  <code>RESULT_ERROR_NO_SERVICE</code><br>\n     *  <code>RESULT_ERROR_NO_SERVICE</code><br>\n     *  <code>RESULT_ERROR_LIMIT_EXCEEDED</code><br>\n     *  <code>RESULT_ERROR_FDN_CHECK_FAILURE</code><br>\n     *  <code>RESULT_ERROR_SHORT_CODE_NOT_ALLOWED</code><br>\n     *  <code>RESULT_ERROR_SHORT_CODE_NEVER_ALLOWED</code><br>\n     *  <code>RESULT_RADIO_NOT_AVAILABLE</code><br>\n     *  <code>RESULT_NETWORK_REJECT</code><br>\n     *  <code>RESULT_INVALID_ARGUMENTS</code><br>\n     *  <code>RESULT_INVALID_STATE</code><br>\n     *  <code>RESULT_NO_MEMORY</code><br>\n     *  <code>RESULT_INVALID_SMS_FORMAT</code><br>\n     *  <code>RESULT_SYSTEM_ERROR</code><br>\n     *  <code>RESULT_MODEM_ERROR</code><br>\n     *  <code>RESULT_NETWORK_ERROR</code><br>\n     *  <code>RESULT_ENCODING_ERROR</code><br>\n     *  <code>RESULT_INVALID_SMSC_ADDRESS</code><br>\n     *  <code>RESULT_OPERATION_NOT_ALLOWED</code><br>\n     *  <code>RESULT_INTERNAL_ERROR</code><br>\n     *  <code>RESULT_NO_RESOURCES</code><br>\n     *  <code>RESULT_CANCELLED</code><br>\n     *  <code>RESULT_REQUEST_NOT_SUPPORTED</code><br>\n     *  <code>RESULT_NO_BLUETOOTH_SERVICE</code><br>\n     *  <code>RESULT_INVALID_BLUETOOTH_ADDRESS</code><br>\n     *  <code>RESULT_BLUETOOTH_DISCONNECTED</code><br>\n     *  <code>RESULT_UNEXPECTED_EVENT_STOP_SENDING</code><br>\n     *  <code>RESULT_SMS_BLOCKED_DURING_EMERGENCY</code><br>\n     *  <code>RESULT_SMS_SEND_RETRY_FAILED</code><br>\n     *  <code>RESULT_REMOTE_EXCEPTION</code><br>\n     *  <code>RESULT_NO_DEFAULT_SMS_APP</code><br>\n     *  <code>RESULT_RIL_RADIO_NOT_AVAILABLE</code><br>\n     *  <code>RESULT_RIL_SMS_SEND_FAIL_RETRY</code><br>\n     *  <code>RESULT_RIL_NETWORK_REJECT</code><br>\n     *  <code>RESULT_RIL_INVALID_STATE</code><br>\n     *  <code>RESULT_RIL_INVALID_ARGUMENTS</code><br>\n     *  <code>RESULT_RIL_NO_MEMORY</code><br>\n     *  <code>RESULT_RIL_REQUEST_RATE_LIMITED</code><br>\n     *  <code>RESULT_RIL_INVALID_SMS_FORMAT</code><br>\n     *  <code>RESULT_RIL_SYSTEM_ERR</code><br>\n     *  <code>RESULT_RIL_ENCODING_ERR</code><br>\n     *  <code>RESULT_RIL_INVALID_SMSC_ADDRESS</code><br>\n     *  <code>RESULT_RIL_MODEM_ERR</code><br>\n     *  <code>RESULT_RIL_NETWORK_ERR</code><br>\n     *  <code>RESULT_RIL_INTERNAL_ERR</code><br>\n     *  <code>RESULT_RIL_REQUEST_NOT_SUPPORTED</code><br>\n     *  <code>RESULT_RIL_INVALID_MODEM_STATE</code><br>\n     *  <code>RESULT_RIL_NETWORK_NOT_READY</code><br>\n     *  <code>RESULT_RIL_OPERATION_NOT_ALLOWED</code><br>\n     *  <code>RESULT_RIL_NO_RESOURCES</code><br>\n     *  <code>RESULT_RIL_CANCELLED</code><br>\n     *  <code>RESULT_RIL_SIM_ABSENT</code><br>\n     *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> or any of the RESULT_RIL errors,\n     *  the sentIntent may include the extra \"errorCode\" containing a radio technology specific\n     *  value, generally only useful for troubleshooting.<br>\n     *   The per-application based SMS control checks sentIntent. If sentIntent\n     *   is NULL the caller will be checked against all unknown applications,\n     *   which cause smaller number of SMS to be sent in checking period.\n     * @param deliveryIntents if not null, an <code>ArrayList</code> of\n     *   <code>PendingIntent</code>s (one for each message part) that is\n     *   broadcast when the corresponding message part has been delivered\n     *   to the recipient.  The raw pdu of the status report is in the\n     *   extended data (\"pdu\").\n     *\n     * @throws IllegalArgumentException if destinationAddress or data are empty\n     ",
    "links" : [ "android.Manifest.permission#SEND_SMS", "android.provider.Telephony", "#getDefault", "PendingIntent", "#getDefault" ]
  }, {
    "name" : "public void sendMultipartTextMessage(@NonNull String destinationAddress, @Nullable String scAddress, @NonNull List<String> parts, @Nullable List<PendingIntent> sentIntents, @Nullable List<PendingIntent> deliveryIntents, long messageId)",
    "returnType" : "void",
    "comment" : "\n     * Send a multi-part text based SMS. Same as #sendMultipartTextMessage(String, String,\n     * ArrayList, ArrayList, ArrayList), but adds an optional messageId.\n     * @param messageId An id that uniquely identifies the message requested to be sent.\n     * Used for logging and diagnostics purposes. The id may be 0.\n     *\n     * @throws IllegalArgumentException if destinationAddress or data are empty\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "public void sendMultipartTextMessage(@NonNull String destinationAddress, @Nullable String scAddress, @NonNull List<String> parts, @Nullable List<PendingIntent> sentIntents, @Nullable List<PendingIntent> deliveryIntents, @NonNull String packageName, @Nullable String attributionTag)",
    "returnType" : "void",
    "comment" : "\n     * Similar method as #sendMultipartTextMessage(String, String, ArrayList, ArrayList, ArrayList)\n     * With an additional argument.\n     *\n     * <p class=\"note\"><strong>Note:</strong> This method is intended for internal use the Telephony\n     * framework and will never trigger an SMS disambiguation dialog. If this method is called on a\n     * device that has multiple active subscriptions, this {@link SmsManager} instance has been\n     * created with {@link #getDefault()}, and no user-defined default subscription is defined, the\n     * subscription ID associated with this message will be INVALID, which will result in the SMS\n     * being sent on the subscription associated with logical slot 0. Use\n     * {@link #getSmsManagerForSubscriptionId(int)} to ensure the SMS is sent on the correct\n     * subscription.\n     * </p>\n     *\n     * @param packageName serves as the default package name if the package name that is\n     *        associated with the user id is null.\n     ",
    "links" : [ "SmsManager", "#getDefault", "#getSmsManagerForSubscriptionId" ]
  }, {
    "name" : "private void sendMultipartTextMessageInternal(String destinationAddress, String scAddress, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents, boolean persistMessage, String packageName, @Nullable String attributionTag, long messageId)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void sendMultipartTextMessageWithoutPersisting(String destinationAddress, String scAddress, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents)",
    "returnType" : "void",
    "comment" : "\n     * Send a multi-part text based SMS without writing it into the SMS Provider.\n     *\n     * <p>\n     * If this method is called on a device with multiple active subscriptions, this\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\n     * default subscription is defined, the subscription ID associated with this message will be\n     * INVALID, which will result in the SMS sent on the subscription associated with slot\n     * 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the SMS is sent using the\n     * correct subscription.\n     * </p>\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#MODIFY_PHONE_STATE} or the calling app has carrier\n     * privileges.\n     * </p>\n     *\n     * @see #sendMultipartTextMessage(String, String, ArrayList, ArrayList, ArrayList)\n     * @hide\n     *",
    "links" : [ "SmsManager", "#getDefault", "#getSmsManagerForSubscriptionId", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public void sendMultipartTextMessage(String destinationAddress, String scAddress, ArrayList<String> parts, ArrayList<PendingIntent> sentIntents, ArrayList<PendingIntent> deliveryIntents, int priority, boolean expectMore, int validityPeriod)",
    "returnType" : "void",
    "comment" : "\n     * Send a multi-part text based SMS with messaging options. The callee should have already\n     * divided the message into correctly sized parts by calling\n     * <code>divideMessage</code>.\n     *\n     * <p class=\"note\"><strong>Note:</strong> Using this method requires that your app has the\n     * {@link android.Manifest.permission#SEND_SMS} permission.</p>\n     *\n     * <p class=\"note\"><strong>Note:</strong> Beginning with Android 4.4 (API level 19), if\n     * <em>and only if</em> an app is not selected as the default SMS app, the system automatically\n     * writes messages sent using this method to the SMS Provider (the default SMS app is always\n     * responsible for writing its sent messages to the SMS Provider). For information about\n     * how to behave as the default SMS app, see {@link android.provider.Telephony}.</p>\n     *\n     * <p class=\"note\"><strong>Note:</strong> If {@link #getDefault()} is used to instantiate this\n     * manager on a multi-SIM device, this operation may fail sending the SMS message because no\n     * suitable default subscription could be found. In this case, if {@code sentIntent} is\n     * non-null, then the {@link PendingIntent} will be sent with an error code\n     * {@code RESULT_ERROR_GENERIC_FAILURE} and an extra string {@code \"noDefault\"} containing the\n     * boolean value {@code true}. See {@link #getDefault()} for more information on the conditions\n     * where this operation may fail.\n     * </p>\n\n     * @param destinationAddress the address to send the message to\n     * @param scAddress is the service center address or null to use\n     *   the current default SMSC\n     * @param parts an <code>ArrayList</code> of strings that, in order,\n     *   comprise the original message\n     * @param sentIntents if not null, an <code>ArrayList</code> of\n     *   <code>PendingIntent</code>s (one for each message part) that is\n     *   broadcast when the corresponding message part has been sent.\n     *   The result code will be <code>Activity.RESULT_OK</code> for success,\n     *   or one of these errors:<br>\n     *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>\n     *  <code>RESULT_ERROR_RADIO_OFF</code><br>\n     *  <code>RESULT_ERROR_NULL_PDU</code><br>\n     *  <code>RESULT_ERROR_NO_SERVICE</code><br>\n     *  <code>RESULT_ERROR_NO_SERVICE</code><br>\n     *  <code>RESULT_ERROR_LIMIT_EXCEEDED</code><br>\n     *  <code>RESULT_ERROR_FDN_CHECK_FAILURE</code><br>\n     *  <code>RESULT_ERROR_SHORT_CODE_NOT_ALLOWED</code><br>\n     *  <code>RESULT_ERROR_SHORT_CODE_NEVER_ALLOWED</code><br>\n     *  <code>RESULT_RADIO_NOT_AVAILABLE</code><br>\n     *  <code>RESULT_NETWORK_REJECT</code><br>\n     *  <code>RESULT_INVALID_ARGUMENTS</code><br>\n     *  <code>RESULT_INVALID_STATE</code><br>\n     *  <code>RESULT_NO_MEMORY</code><br>\n     *  <code>RESULT_INVALID_SMS_FORMAT</code><br>\n     *  <code>RESULT_SYSTEM_ERROR</code><br>\n     *  <code>RESULT_MODEM_ERROR</code><br>\n     *  <code>RESULT_NETWORK_ERROR</code><br>\n     *  <code>RESULT_ENCODING_ERROR</code><br>\n     *  <code>RESULT_INVALID_SMSC_ADDRESS</code><br>\n     *  <code>RESULT_OPERATION_NOT_ALLOWED</code><br>\n     *  <code>RESULT_INTERNAL_ERROR</code><br>\n     *  <code>RESULT_NO_RESOURCES</code><br>\n     *  <code>RESULT_CANCELLED</code><br>\n     *  <code>RESULT_REQUEST_NOT_SUPPORTED</code><br>\n     *  <code>RESULT_NO_BLUETOOTH_SERVICE</code><br>\n     *  <code>RESULT_INVALID_BLUETOOTH_ADDRESS</code><br>\n     *  <code>RESULT_BLUETOOTH_DISCONNECTED</code><br>\n     *  <code>RESULT_UNEXPECTED_EVENT_STOP_SENDING</code><br>\n     *  <code>RESULT_SMS_BLOCKED_DURING_EMERGENCY</code><br>\n     *  <code>RESULT_SMS_SEND_RETRY_FAILED</code><br>\n     *  <code>RESULT_REMOTE_EXCEPTION</code><br>\n     *  <code>RESULT_NO_DEFAULT_SMS_APP</code><br>\n     *  <code>RESULT_RIL_RADIO_NOT_AVAILABLE</code><br>\n     *  <code>RESULT_RIL_SMS_SEND_FAIL_RETRY</code><br>\n     *  <code>RESULT_RIL_NETWORK_REJECT</code><br>\n     *  <code>RESULT_RIL_INVALID_STATE</code><br>\n     *  <code>RESULT_RIL_INVALID_ARGUMENTS</code><br>\n     *  <code>RESULT_RIL_NO_MEMORY</code><br>\n     *  <code>RESULT_RIL_REQUEST_RATE_LIMITED</code><br>\n     *  <code>RESULT_RIL_INVALID_SMS_FORMAT</code><br>\n     *  <code>RESULT_RIL_SYSTEM_ERR</code><br>\n     *  <code>RESULT_RIL_ENCODING_ERR</code><br>\n     *  <code>RESULT_RIL_INVALID_SMSC_ADDRESS</code><br>\n     *  <code>RESULT_RIL_MODEM_ERR</code><br>\n     *  <code>RESULT_RIL_NETWORK_ERR</code><br>\n     *  <code>RESULT_RIL_INTERNAL_ERR</code><br>\n     *  <code>RESULT_RIL_REQUEST_NOT_SUPPORTED</code><br>\n     *  <code>RESULT_RIL_INVALID_MODEM_STATE</code><br>\n     *  <code>RESULT_RIL_NETWORK_NOT_READY</code><br>\n     *  <code>RESULT_RIL_OPERATION_NOT_ALLOWED</code><br>\n     *  <code>RESULT_RIL_NO_RESOURCES</code><br>\n     *  <code>RESULT_RIL_CANCELLED</code><br>\n     *  <code>RESULT_RIL_SIM_ABSENT</code><br>\n     *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> or any of the RESULT_RIL errors,\n     *  the sentIntent may include the extra \"errorCode\" containing a radio technology specific\n     *  value, generally only useful for troubleshooting.<br>\n     *   The per-application based SMS control checks sentIntent. If sentIntent\n     *   is NULL the caller will be checked against all unknown applications,\n     *   which cause smaller number of SMS to be sent in checking period.\n     * @param deliveryIntents if not null, an <code>ArrayList</code> of\n     *   <code>PendingIntent</code>s (one for each message part) that is\n     *   broadcast when the corresponding message part has been delivered\n     *   to the recipient.  The raw pdu of the status report is in the\n     *   extended data (\"pdu\").\n     * @param priority Priority level of the message\n     *  Refer specification See 3GPP2 C.S0015-B, v2.0, table 4.5.9-1\n     *  ---------------------------------\n     *  PRIORITY      | Level of Priority\n     *  ---------------------------------\n     *      '00'      |     Normal\n     *      '01'      |     Interactive\n     *      '10'      |     Urgent\n     *      '11'      |     Emergency\n     *  ----------------------------------\n     *  Any Other values included Negative considered as Invalid Priority Indicator of the message.\n     * @param expectMore is a boolean to indicate the sending messages through same link or not.\n     * @param validityPeriod Validity Period of the message in mins.\n     *  Refer specification 3GPP TS 23.040 V6.8.1 section 9.2.3.12.1.\n     *  Validity Period(Minimum) -> 5 mins\n     *  Validity Period(Maximum) -> 635040 mins(i.e.63 weeks).\n     *  Any Other values included Negative considered as Invalid Validity Period of the message.\n     *\n     * @throws IllegalArgumentException if destinationAddress or data are empty\n     * {@hide}\n     ",
    "links" : [ "android.Manifest.permission#SEND_SMS", "android.provider.Telephony", "#getDefault", "PendingIntent", "#getDefault" ]
  }, {
    "name" : "private void sendMultipartTextMessageInternal(String destinationAddress, String scAddress, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents, boolean persistMessage, int priority, boolean expectMore, int validityPeriod)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void sendDataMessage(String destinationAddress, String scAddress, short destinationPort, byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent)",
    "returnType" : "void",
    "comment" : "\n     * Send a data based SMS to a specific application port.\n     *\n     * <p class=\"note\"><strong>Note:</strong> Using this method requires that your app has the\n     * {@link android.Manifest.permission#SEND_SMS} permission.</p>\n     *\n     * <p class=\"note\"><strong>Note:</strong> If {@link #getDefault()} is used to instantiate this\n     * manager on a multi-SIM device, this operation may fail sending the SMS message because no\n     * suitable default subscription could be found. In this case, if {@code sentIntent} is\n     * non-null, then the {@link PendingIntent} will be sent with an error code\n     * {@code RESULT_ERROR_GENERIC_FAILURE} and an extra string {@code \"noDefault\"} containing the\n     * boolean value {@code true}. See {@link #getDefault()} for more information on the conditions\n     * where this operation may fail.\n     * </p>\n     *\n     * @param destinationAddress the address to send the message to\n     * @param scAddress is the service center address or null to use\n     *  the current default SMSC\n     * @param destinationPort the port to deliver the message to\n     * @param data the body of the message to send\n     * @param sentIntent if not NULL this <code>PendingIntent</code> is\n     *  broadcast when the message is successfully sent, or failed.\n     *  The result code will be <code>Activity.RESULT_OK</code> for success,\n     *  or one of these errors:<br>\n     *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>\n     *  <code>RESULT_ERROR_RADIO_OFF</code><br>\n     *  <code>RESULT_ERROR_NULL_PDU</code><br>\n     *  <code>RESULT_ERROR_NO_SERVICE</code><br>\n     *  <code>RESULT_ERROR_NO_SERVICE</code><br>\n     *  <code>RESULT_ERROR_LIMIT_EXCEEDED</code><br>\n     *  <code>RESULT_ERROR_FDN_CHECK_FAILURE</code><br>\n     *  <code>RESULT_ERROR_SHORT_CODE_NOT_ALLOWED</code><br>\n     *  <code>RESULT_ERROR_SHORT_CODE_NEVER_ALLOWED</code><br>\n     *  <code>RESULT_RADIO_NOT_AVAILABLE</code><br>\n     *  <code>RESULT_NETWORK_REJECT</code><br>\n     *  <code>RESULT_INVALID_ARGUMENTS</code><br>\n     *  <code>RESULT_INVALID_STATE</code><br>\n     *  <code>RESULT_NO_MEMORY</code><br>\n     *  <code>RESULT_INVALID_SMS_FORMAT</code><br>\n     *  <code>RESULT_SYSTEM_ERROR</code><br>\n     *  <code>RESULT_MODEM_ERROR</code><br>\n     *  <code>RESULT_NETWORK_ERROR</code><br>\n     *  <code>RESULT_ENCODING_ERROR</code><br>\n     *  <code>RESULT_INVALID_SMSC_ADDRESS</code><br>\n     *  <code>RESULT_OPERATION_NOT_ALLOWED</code><br>\n     *  <code>RESULT_INTERNAL_ERROR</code><br>\n     *  <code>RESULT_NO_RESOURCES</code><br>\n     *  <code>RESULT_CANCELLED</code><br>\n     *  <code>RESULT_REQUEST_NOT_SUPPORTED</code><br>\n     *  <code>RESULT_NO_BLUETOOTH_SERVICE</code><br>\n     *  <code>RESULT_INVALID_BLUETOOTH_ADDRESS</code><br>\n     *  <code>RESULT_BLUETOOTH_DISCONNECTED</code><br>\n     *  <code>RESULT_UNEXPECTED_EVENT_STOP_SENDING</code><br>\n     *  <code>RESULT_SMS_BLOCKED_DURING_EMERGENCY</code><br>\n     *  <code>RESULT_SMS_SEND_RETRY_FAILED</code><br>\n     *  <code>RESULT_REMOTE_EXCEPTION</code><br>\n     *  <code>RESULT_NO_DEFAULT_SMS_APP</code><br>\n     *  <code>RESULT_RIL_RADIO_NOT_AVAILABLE</code><br>\n     *  <code>RESULT_RIL_SMS_SEND_FAIL_RETRY</code><br>\n     *  <code>RESULT_RIL_NETWORK_REJECT</code><br>\n     *  <code>RESULT_RIL_INVALID_STATE</code><br>\n     *  <code>RESULT_RIL_INVALID_ARGUMENTS</code><br>\n     *  <code>RESULT_RIL_NO_MEMORY</code><br>\n     *  <code>RESULT_RIL_REQUEST_RATE_LIMITED</code><br>\n     *  <code>RESULT_RIL_INVALID_SMS_FORMAT</code><br>\n     *  <code>RESULT_RIL_SYSTEM_ERR</code><br>\n     *  <code>RESULT_RIL_ENCODING_ERR</code><br>\n     *  <code>RESULT_RIL_INVALID_SMSC_ADDRESS</code><br>\n     *  <code>RESULT_RIL_MODEM_ERR</code><br>\n     *  <code>RESULT_RIL_NETWORK_ERR</code><br>\n     *  <code>RESULT_RIL_INTERNAL_ERR</code><br>\n     *  <code>RESULT_RIL_REQUEST_NOT_SUPPORTED</code><br>\n     *  <code>RESULT_RIL_INVALID_MODEM_STATE</code><br>\n     *  <code>RESULT_RIL_NETWORK_NOT_READY</code><br>\n     *  <code>RESULT_RIL_OPERATION_NOT_ALLOWED</code><br>\n     *  <code>RESULT_RIL_NO_RESOURCES</code><br>\n     *  <code>RESULT_RIL_CANCELLED</code><br>\n     *  <code>RESULT_RIL_SIM_ABSENT</code><br>\n     *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> or any of the RESULT_RIL errors,\n     *  the sentIntent may include the extra \"errorCode\" containing a radio technology specific\n     *  value, generally only useful for troubleshooting.<br>\n     *  The per-application based SMS control checks sentIntent. If sentIntent\n     *  is NULL the caller will be checked against all unknown applications,\n     *  which cause smaller number of SMS to be sent in checking period.\n     * @param deliveryIntent if not NULL this <code>PendingIntent</code> is\n     *  broadcast when the message is delivered to the recipient.  The\n     *  raw pdu of the status report is in the extended data (\"pdu\").\n     *\n     * @throws IllegalArgumentException if destinationAddress or data are empty\n     ",
    "links" : [ "android.Manifest.permission#SEND_SMS", "#getDefault", "PendingIntent", "#getDefault" ]
  }, {
    "name" : "public static SmsManager getDefault()",
    "returnType" : "SmsManager",
    "comment" : "\n     * Get the SmsManager associated with the default subscription id. The instance will always be\n     * associated with the default subscription id, even if the default subscription id changes.\n     *\n     * <p class=\"note\"><strong>Note:</strong> For devices that support multiple active subscriptions\n     * at a time, SmsManager will track the subscription set by the user as the default SMS\n     * subscription. If the user has not set a default, {@link SmsManager} may\n     * start an activity to kick off a subscription disambiguation dialog. Most operations will not\n     * complete until the user has chosen the subscription that will be associated with the\n     * operation. If the user cancels the dialog without choosing a subscription, one of the\n     * following will happen, depending on the target SDK version of the application. For\n     * compatibility purposes, if the target SDK level is <= 28, telephony will still send the SMS\n     * over the first available subscription. If the target SDK level is > 28, the operation will\n     * fail to complete.\n     * </p>\n     *\n     * <p class=\"note\"><strong>Note:</strong> If this method is used to perform an operation on a\n     * device that has multiple active subscriptions, the user has not set a default SMS\n     * subscription, and the operation is being performed while the application is not in the\n     * foreground, the SMS disambiguation dialog will not be shown. The result of the operation will\n     * conclude as if the user cancelled the disambiguation dialog and the operation will finish as\n     * outlined above, depending on the target SDK version of the calling application. It is safer\n     * to use {@link #getSmsManagerForSubscriptionId(int)} if the application will perform the\n     * operation while in the background because this can cause unpredictable results, such as the\n     * operation being sent over the wrong subscription or failing completely, depending on the\n     * user's default SMS subscription setting.\n     * </p>\n     *\n     * @return the {@link SmsManager} associated with the default subscription id.\n     *\n     * @see SubscriptionManager#getDefaultSmsSubscriptionId()\n     ",
    "links" : [ "SmsManager", "#getSmsManagerForSubscriptionId", "SmsManager" ]
  }, {
    "name" : "public static SmsManager getSmsManagerForSubscriptionId(int subId)",
    "returnType" : "SmsManager",
    "comment" : "\n     * Get the instance of the SmsManager associated with a particular subscription ID.\n     *\n     * <p class=\"note\"><strong>Note:</strong> Constructing an {@link SmsManager} in this manner will\n     * never cause an SMS disambiguation dialog to appear, unlike {@link #getDefault()}.\n     * </p>\n     *\n     * @param subId an SMS subscription ID, typically accessed using {@link SubscriptionManager}\n     * @return the instance of the SmsManager associated with subscription\n     *\n     * @see SubscriptionManager#getActiveSubscriptionInfoList()\n     * @see SubscriptionManager#getDefaultSmsSubscriptionId()\n     ",
    "links" : [ "SmsManager", "#getDefault", "SubscriptionManager" ]
  }, {
    "name" : "public int getSubscriptionId()",
    "returnType" : "int",
    "comment" : "\n     * Get the associated subscription id. If the instance was returned by {@link #getDefault()},\n     * then this method may return different values at different points in time (if the user\n     * changes the default subscription id).\n     *\n     * <p class=\"note\"><strong>Note:</strong> This method used to display a disambiguation dialog to\n     * the user asking them to choose a default subscription to send SMS messages over if they\n     * haven't chosen yet. Starting in API level 29, we allow the user to not have a default set as\n     * a valid option for the default SMS subscription on multi-SIM devices. We no longer show the\n     * disambiguation dialog and return {@link SubscriptionManager#INVALID_SUBSCRIPTION_ID} if the\n     * device has multiple active subscriptions and no default is set.\n     * </p>\n     *\n     * @return associated subscription ID or {@link SubscriptionManager#INVALID_SUBSCRIPTION_ID} if\n     * the default subscription id cannot be determined or the device has multiple active\n     * subscriptions and and no default is set (\"ask every time\") by the user.\n     ",
    "links" : [ "#getDefault", "SubscriptionManager#INVALID_SUBSCRIPTION_ID", "SubscriptionManager#INVALID_SUBSCRIPTION_ID" ]
  }, {
    "name" : "private void resolveSubscriptionForOperation(SubscriptionResolverResult resolverResult)",
    "returnType" : "void",
    "comment" : "\n     * Resolves the subscription id to use for the associated operation if\n     * {@link #getSubscriptionId()} returns {@link SubscriptionManager#INVALID_SUBSCRIPTION_ID}.\n     *\n     * If app targets API level 28 or below and they are either sending the SMS from the background\n     * or the device has more than one active subscription available and no default is set, we will\n     * use the first logical slot to send the SMS and possibly fail later in the SMS sending\n     * process.\n     *\n     * Regardless of the API level, if the app is the foreground app, then we will show the SMS\n     * disambiguation dialog. If the app is in the background and tries to perform an operation, we\n     * will not show the disambiguation dialog.\n     *\n     * See {@link #getDefault()} for a detailed explanation of how this method operates.\n     *\n     * @param resolverResult The callback that will be called when the subscription is resolved or\n     *                       fails to be resolved.\n     ",
    "links" : [ "#getSubscriptionId", "SubscriptionManager#INVALID_SUBSCRIPTION_ID", "#getDefault" ]
  }, {
    "name" : "private void sendResolverResult(SubscriptionResolverResult resolverResult, int subId, boolean pickActivityShown)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static ITelephony getITelephony()",
    "returnType" : "ITelephony",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void notifySmsError(PendingIntent pendingIntent, int error)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void notifySmsError(List<PendingIntent> pendingIntents, int error)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static ISms getISmsServiceOrThrow()",
    "returnType" : "ISms",
    "comment" : "\n     * Returns the ISms service, or throws an UnsupportedOperationException if\n     * the service does not exist.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static ISms getISmsService()",
    "returnType" : "ISms",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean copyMessageToIcc(@Nullable byte[] smsc, @NonNull byte[] pdu, @StatusOnIcc int status)",
    "returnType" : "boolean",
    "comment" : "\n     * Copies a raw SMS PDU to the ICC.\n     * ICC (Integrated Circuit Card) is the card of the device.\n     * For example, this can be the SIM or USIM for GSM.\n     *\n     * <p class=\"note\"><strong>Note:</strong> This method is intended for internal use by carrier\n     * applications or the Telephony framework and will never trigger an SMS disambiguation\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\n     * default subscription is defined, the subscription ID associated with this message will be\n     * INVALID, which will result in the operation being completed on the subscription associated\n     * with logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the\n     * operation is performed on the correct subscription.\n     * </p>\n     *\n     * @param smsc the SMSC for this messag or null for the default SMSC.\n     * @param pdu the raw PDU to store.\n     * @param status message status. One of these status:\n     *               <code>STATUS_ON_ICC_READ</code>\n     *               <code>STATUS_ON_ICC_UNREAD</code>\n     *               <code>STATUS_ON_ICC_SENT</code>\n     *               <code>STATUS_ON_ICC_UNSENT</code>\n     * @return true for success. Otherwise false.\n     *\n     * @throws IllegalArgumentException if pdu is null.\n     * @hide\n     ",
    "links" : [ "SmsManager", "#getDefault", "#getSmsManagerForSubscriptionId" ]
  }, {
    "name" : "public boolean deleteMessageFromIcc(int messageIndex)",
    "returnType" : "boolean",
    "comment" : "\n     * Deletes the specified message from the ICC.\n     * ICC (Integrated Circuit Card) is the card of the device.\n     * For example, this can be the SIM or USIM for GSM.\n     *\n     * <p class=\"note\"><strong>Note:</strong> This method is intended for internal use by carrier\n     * applications or the Telephony framework and will never trigger an SMS disambiguation\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\n     * default subscription is defined, the subscription ID associated with this message will be\n     * INVALID, which will result in the operation being completed on the subscription associated\n     * with logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the\n     * operation is performed on the correct subscription.\n     * </p>\n     *\n     * @param messageIndex This is the same index used to access a message\n     * from {@link #getMessagesFromIcc()}.\n     * @return true for success, false if the operation fails. Failure can be due to IPC failure,\n     * RIL/modem error which results in SMS failed to be deleted on SIM\n     *\n     * {@hide}\n     ",
    "links" : [ "SmsManager", "#getDefault", "#getSmsManagerForSubscriptionId", "#getMessagesFromIcc" ]
  }, {
    "name" : "public boolean updateMessageOnIcc(int messageIndex, int newStatus, byte[] pdu)",
    "returnType" : "boolean",
    "comment" : "\n     * Update the specified message on the ICC.\n     * ICC (Integrated Circuit Card) is the card of the device.\n     * For example, this can be the SIM or USIM for GSM.\n     *\n     * <p class=\"note\"><strong>Note:</strong> This method is intended for internal use by carrier\n     * applications or the Telephony framework and will never trigger an SMS disambiguation\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\n     * default subscription is defined, the subscription ID associated with this message will be\n     * INVALID, which will result in the operation being completed on the subscription associated\n     * with logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the\n     * operation is performed on the correct subscription.\n     * </p>\n     *\n     * @param messageIndex record index of message to update\n     * @param newStatus new message status (STATUS_ON_ICC_READ,\n     *                  STATUS_ON_ICC_UNREAD, STATUS_ON_ICC_SENT,\n     *                  STATUS_ON_ICC_UNSENT, STATUS_ON_ICC_FREE)\n     * @param pdu the raw PDU to store\n     * @return true for success\n     *\n     * {@hide}\n     ",
    "links" : [ "SmsManager", "#getDefault", "#getSmsManagerForSubscriptionId" ]
  }, {
    "name" : "public List<SmsMessage> getMessagesFromIcc()",
    "returnType" : "List<SmsMessage>",
    "comment" : "\n     * Retrieves all messages currently stored on the ICC.\n     * ICC (Integrated Circuit Card) is the card of the device.\n     * For example, this can be the SIM or USIM for GSM.\n     *\n     * <p class=\"note\"><strong>Note:</strong> This method is intended for internal use by carrier\n     * applications or the Telephony framework and will never trigger an SMS disambiguation\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\n     * default subscription is defined, the subscription ID associated with this message will be\n     * INVALID, which will result in the operation being completed on the subscription associated\n     * with logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the\n     * operation is performed on the correct subscription.\n     * </p>\n     *\n     * @return <code>List</code> of <code>SmsMessage</code> objects\n     *\n     * {@hide}\n     ",
    "links" : [ "SmsManager", "#getDefault", "#getSmsManagerForSubscriptionId" ]
  }, {
    "name" : "public ArrayList<SmsMessage> getAllMessagesFromIcc()",
    "returnType" : "ArrayList<SmsMessage>",
    "comment" : "\n     * @return <code>ArrayList</code> of <code>SmsMessage</code> objects\n     *\n     * This is similar to {@link #getMessagesFromIcc} except that it will return ArrayList.\n     * Suggested to use {@link #getMessagesFromIcc} instead.\n     *\n     * {@hide}\n     ",
    "links" : [ "#getMessagesFromIcc", "#getMessagesFromIcc" ]
  }, {
    "name" : "public boolean enableCellBroadcastRange(int startMessageId, int endMessageId, @android.telephony.SmsCbMessage.MessageFormat int ranType)",
    "returnType" : "boolean",
    "comment" : "\n     * Enable reception of cell broadcast (SMS-CB) messages with the given\n     * message identifier range and RAN type. The RAN type specifies if this message ID\n     * belongs to 3GPP (GSM) or 3GPP2(CDMA). Note that if two different clients enable\n     * the same message identifier, they must both disable it for the device to stop\n     * receiving those messages. All received messages will be broadcast in an\n     * intent with the action \"android.provider.Telephony.SMS_CB_RECEIVED\".\n     * Note: This call is blocking, callers may want to avoid calling it from\n     * the main thread of an application.\n     *\n     * <p class=\"note\"><strong>Note:</strong> This method is intended for internal use by carrier\n     * applications or the Telephony framework and will never trigger an SMS disambiguation\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\n     * default subscription is defined, the subscription ID associated with this message will be\n     * {@link SubscriptionManager#INVALID_SUBSCRIPTION_ID}, which will result in the operation\n     * being completed on the subscription associated with logical slot 0. Use\n     * {@link #getSmsManagerForSubscriptionId(int)} to ensure the operation is performed on the\n     * correct subscription.\n     * </p>\n     *\n     * <p>Requires {@link android.Manifest.permission#RECEIVE_EMERGENCY_BROADCAST}</p>\n     *\n     * @param startMessageId first message identifier as specified in TS 23.041 (3GPP)\n     * or C.R1001-G (3GPP2)\n     * @param endMessageId last message identifier as specified in TS 23.041 (3GPP)\n     * or C.R1001-G (3GPP2)\n     * @param ranType the message format as defined in {@link SmsCbMessage}\n     * @return true if successful, false if the modem reports a failure (e.g. the given range or\n     * RAN type is invalid).\n     * @see #disableCellBroadcastRange(int, int, int)\n     *\n     * @throws IllegalArgumentException if endMessageId < startMessageId\n     * {@hide}\n     ",
    "links" : [ "SmsManager", "#getDefault", "SubscriptionManager#INVALID_SUBSCRIPTION_ID", "#getSmsManagerForSubscriptionId", "android.Manifest.permission#RECEIVE_EMERGENCY_BROADCAST", "SmsCbMessage" ]
  }, {
    "name" : "public boolean disableCellBroadcastRange(int startMessageId, int endMessageId, @android.telephony.SmsCbMessage.MessageFormat int ranType)",
    "returnType" : "boolean",
    "comment" : "\n     * Disable reception of cell broadcast (SMS-CB) messages with the given\n     * message identifier range and RAN type. The RAN type specify this message\n     * ID range belong to 3GPP (GSM) or 3GPP2(CDMA). Note that if two different\n     * clients enable the same message identifier, they must both disable it for\n     * the device to stop receiving those messages.\n     * Note: This call is blocking, callers may want to avoid calling it from\n     * the main thread of an application.\n     *\n     * <p class=\"note\"><strong>Note:</strong> This method is intended for internal use by carrier\n     * applications or the Telephony framework and will never trigger an SMS disambiguation\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\n     * default subscription is defined, the subscription ID associated with this message will be\n     * INVALID, which will result in the operation being completed on the subscription associated\n     * with logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the\n     * operation is performed on the correct subscription.\n     * </p>\n     *\n     * <p>Requires {@link android.Manifest.permission#RECEIVE_EMERGENCY_BROADCAST}</p>\n     *\n     * @param startMessageId first message identifier as specified in TS 23.041 (3GPP)\n     * or C.R1001-G (3GPP2)\n     * @param endMessageId last message identifier as specified in TS 23.041 (3GPP)\n     * or C.R1001-G (3GPP2)\n     * @param ranType the message format as defined in {@link SmsCbMessage}\n     * @return true if successful, false if the modem reports a failure (e.g. the given range or\n     * RAN type is invalid).\n     *\n     * @see #enableCellBroadcastRange(int, int, int)\n     *\n     * @throws IllegalArgumentException if endMessageId < startMessageId\n     * {@hide}\n     ",
    "links" : [ "SmsManager", "#getDefault", "#getSmsManagerForSubscriptionId", "android.Manifest.permission#RECEIVE_EMERGENCY_BROADCAST", "SmsCbMessage" ]
  }, {
    "name" : "private ArrayList<SmsMessage> createMessageListFromRawRecords(List<SmsRawData> records)",
    "returnType" : "ArrayList<SmsMessage>",
    "comment" : "\n     * Creates a list of <code>SmsMessage</code>s from a list of SmsRawData records.\n     *\n     * <p class=\"note\"><strong>Note:</strong> This method is intended for internal use by carrier\n     * applications or the Telephony framework and will never trigger an SMS disambiguation\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\n     * default subscription is defined, the subscription ID associated with this message will be\n     * INVALID, which will result in the operation being completed on the subscription associated\n     * with logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the\n     * operation is performed on the correct subscription.\n     * </p>\n     *\n     * @param records SMS EF records.\n     * @return <code>ArrayList</code> of <code>SmsMessage</code> objects.\n     ",
    "links" : [ "SmsManager", "#getDefault", "#getSmsManagerForSubscriptionId" ]
  }, {
    "name" : "public boolean isImsSmsSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * SMS over IMS is supported if IMS is registered and SMS is supported\n     * on IMS.\n     *\n     * <p class=\"note\"><strong>Note:</strong> This method is intended for internal use by carrier\n     * applications or the Telephony framework and will never trigger an SMS disambiguation\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\n     * default subscription is defined, the subscription ID associated with this message will be\n     * INVALID, which will result in the operation being completed on the subscription associated\n     * with logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the\n     * operation is performed on the correct subscription.\n     * </p>\n     *\n     * @return true if SMS over IMS is supported, false otherwise\n     *\n     * @see #getImsSmsFormat()\n     *\n     * @hide\n     ",
    "links" : [ "SmsManager", "#getDefault", "#getSmsManagerForSubscriptionId" ]
  }, {
    "name" : "public String getImsSmsFormat()",
    "returnType" : "String",
    "comment" : "\n     * Gets SMS format supported on IMS.  SMS over IMS format is either 3GPP or 3GPP2.\n     *\n     * <p class=\"note\"><strong>Note:</strong> This method is intended for internal use by carrier\n     * applications or the Telephony framework and will never trigger an SMS disambiguation\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\n     * default subscription is defined, the subscription ID associated with this message will be\n     * INVALID, which will result in the operation being completed on the subscription associated\n     * with logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the\n     * operation is performed on the correct subscription.\n     * </p>\n     *\n     * @return SmsMessage.FORMAT_3GPP,\n     *         SmsMessage.FORMAT_3GPP2\n     *      or SmsMessage.FORMAT_UNKNOWN\n     *\n     * @see #isImsSmsSupported()\n     *\n     * @hide\n     ",
    "links" : [ "SmsManager", "#getDefault", "#getSmsManagerForSubscriptionId" ]
  }, {
    "name" : "public static int getDefaultSmsSubscriptionId()",
    "returnType" : "int",
    "comment" : "\n     * Get default sms subscription id.\n     *\n     * <p class=\"note\"><strong>Note:</strong>This returns a value different from\n     * {@link SubscriptionManager#getDefaultSmsSubscriptionId} if the user has not chosen a default.\n     * In this case it returns the active subscription id if there's only one active subscription\n     * available.\n     *\n     * @return the user-defined default SMS subscription id, or the active subscription id if\n     * there's only one active subscription available, otherwise\n     * {@link SubscriptionManager#INVALID_SUBSCRIPTION_ID}.\n     ",
    "links" : [ "SubscriptionManager#getDefaultSmsSubscriptionId", "SubscriptionManager#INVALID_SUBSCRIPTION_ID" ]
  }, {
    "name" : "public boolean isSMSPromptEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Get SMS prompt property,  enabled or not\n     *\n     * @return true if enabled, false otherwise\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getSmsCapacityOnIcc()",
    "returnType" : "int",
    "comment" : "\n     * Gets the total capacity of SMS storage on RUIM and SIM cards\n     * <p>\n     * This is the number of 176 byte EF-SMS records which can be stored on the RUIM or SIM card.\n     * <p>\n     * See 3GPP TS 31.102 - 4.2.25 - EF-SMS for more information\n     *\n     * @return the total number of SMS records which can be stored on the RUIM or SIM cards.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void sendMultimediaMessage(Context context, Uri contentUri, String locationUrl, Bundle configOverrides, PendingIntent sentIntent)",
    "returnType" : "void",
    "comment" : "\n     * Send an MMS message\n     *\n     * <p class=\"note\"><strong>Note:</strong> This method will never trigger an SMS disambiguation\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\n     * default subscription is defined, the subscription ID associated with this message will be\n     * INVALID, which will result in the operation being completed on the subscription associated\n     * with logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the\n     * operation is performed on the correct subscription.\n     * </p>\n     *\n     * @param context application context\n     * @param contentUri the content Uri from which the message pdu will be read\n     * @param locationUrl the optional location url where message should be sent to\n     * @param configOverrides the carrier-specific messaging configuration values to override for\n     *  sending the message.\n     * @param sentIntent if not NULL this <code>PendingIntent</code> is\n     *  broadcast when the message is successfully sent, or failed\n     * @throws IllegalArgumentException if contentUri is empty\n     ",
    "links" : [ "SmsManager", "#getDefault", "#getSmsManagerForSubscriptionId" ]
  }, {
    "name" : "public void downloadMultimediaMessage(Context context, String locationUrl, Uri contentUri, Bundle configOverrides, PendingIntent downloadedIntent)",
    "returnType" : "void",
    "comment" : "\n     * Download an MMS message from carrier by a given location URL\n     *\n     * <p class=\"note\"><strong>Note:</strong> This method will never trigger an SMS disambiguation\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\n     * default subscription is defined, the subscription ID associated with this message will be\n     * INVALID, which will result in the operation being completed on the subscription associated\n     * with logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the\n     * operation is performed on the correct subscription.\n     * </p>\n     *\n     * @param context application context\n     * @param locationUrl the location URL of the MMS message to be downloaded, usually obtained\n     *  from the MMS WAP push notification\n     * @param contentUri the content uri to which the downloaded pdu will be written\n     * @param configOverrides the carrier-specific messaging configuration values to override for\n     *  downloading the message.\n     * @param downloadedIntent if not NULL this <code>PendingIntent</code> is\n     *  broadcast when the message is downloaded, or the download is failed\n     * @throws IllegalArgumentException if locationUrl or contentUri is empty\n     ",
    "links" : [ "SmsManager", "#getDefault", "#getSmsManagerForSubscriptionId" ]
  }, {
    "name" : "public Bundle getCarrierConfigValues()",
    "returnType" : "Bundle",
    "comment" : "\n     * Get carrier-dependent MMS configuration values.\n     *\n     * <p class=\"note\"><strong>Note:</strong> This method is intended for internal use by carrier\n     * applications or the Telephony framework and will never trigger an SMS disambiguation dialog.\n     * If this method is called on a device that has multiple active subscriptions, this {@link\n     * SmsManager} instance has been created with {@link #getDefault()}, and no user-defined default\n     * subscription is defined, the subscription ID associated with this message will be INVALID,\n     * which will result in the operation being completed on the subscription associated with\n     * logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the operation is\n     * performed on the correct subscription.\n     * </p>\n     *\n     * @return the bundle key/values pairs that contains MMS configuration values\n     *  or an empty Bundle if they cannot be found.\n     ",
    "links" : [ "#getDefault", "#getSmsManagerForSubscriptionId" ]
  }, {
    "name" : "public String createAppSpecificSmsToken(PendingIntent intent)",
    "returnType" : "String",
    "comment" : "\n     * Create a single use app specific incoming SMS request for the calling package.\n     *\n     * This method returns a token that if included in a subsequent incoming SMS message will cause\n     * {@code intent} to be sent with the SMS data.\n     *\n     * The token is only good for one use, after an SMS has been received containing the token all\n     * subsequent SMS messages with the token will be routed as normal.\n     *\n     * An app can only have one request at a time, if the app already has a request pending it will\n     * be replaced with a new request.\n     *\n     * <p class=\"note\"><strong>Note:</strong> This method will never trigger an SMS disambiguation\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\n     * default subscription is defined, the subscription ID associated with this message will be\n     * INVALID, which will result in the operation being completed on the subscription associated\n     * with logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the\n     * operation is performed on the correct subscription.\n     * </p>\n     *\n     * @return Token to include in an SMS message. The token will be 11 characters long.\n     * @see android.provider.Telephony.Sms.Intents#getMessagesFromIntent\n     ",
    "links" : [ "SmsManager", "#getDefault", "#getSmsManagerForSubscriptionId" ]
  }, {
    "name" : "public void getSmsMessagesForFinancialApp(Bundle params, @NonNull @CallbackExecutor Executor executor, @NonNull FinancialSmsCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Get SMS messages for the calling financial app.\n     * The result will be delivered asynchronously in the passing in callback interface.\n     *\n     * <p class=\"note\"><strong>Note:</strong> This method will never trigger an SMS disambiguation\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\n     * default subscription is defined, the subscription ID associated with this message will be\n     * INVALID, which will result in the operation being completed on the subscription associated\n     * with logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the\n     * operation is performed on the correct subscription.\n     * </p>\n     *\n     * @param params the parameters to filter SMS messages returned.\n     * @param executor the executor on which callback will be invoked.\n     * @param callback a callback to receive CursorWindow with SMS messages.\n     *\n     ",
    "links" : [ "SmsManager", "#getDefault", "#getSmsManagerForSubscriptionId" ]
  }, {
    "name" : "public String createAppSpecificSmsTokenWithPackageInfo(@Nullable String prefixes, @NonNull PendingIntent intent)",
    "returnType" : "String",
    "comment" : "\n     * Create a single use app specific incoming SMS request for the calling package.\n     *\n     * This method returns a token that if included in a subsequent incoming SMS message, and the\n     * SMS message has a prefix from the given prefixes list, the provided {@code intent} will be\n     * sent with the SMS data to the calling package.\n     *\n     * The token is only good for one use within a reasonable amount of time. After an SMS has been\n     * received containing the token all subsequent SMS messages with the token will be routed as\n     * normal.\n     *\n     * An app can only have one request at a time, if the app already has a request pending it will\n     * be replaced with a new request.\n     *\n     * <p class=\"note\"><strong>Note:</strong> This method will never trigger an SMS disambiguation\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\n     * default subscription is defined, the subscription ID associated with this message will be\n     * INVALID, which will result in the operation being completed on the subscription associated\n     * with logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the\n     * operation is performed on the correct subscription.\n     * </p>\n     *\n     * @param prefixes this is a list of prefixes string separated by REGEX_PREFIX_DELIMITER. The\n     *  matching SMS message should have at least one of the prefixes in the beginning of the\n     *  message.\n     * @param intent this intent is sent when the matching SMS message is received.\n     * @return Token to include in an SMS message.\n     ",
    "links" : [ "SmsManager", "#getDefault", "#getSmsManagerForSubscriptionId" ]
  }, {
    "name" : "public int checkSmsShortCodeDestination(String destAddress, String countryIso)",
    "returnType" : "int",
    "comment" : "\n     * Check if the destination address is a possible premium short code.\n     * NOTE: the caller is expected to strip non-digits from the destination number with\n     * {@link PhoneNumberUtils#extractNetworkPortion} before calling this method.\n     *\n     * <p class=\"note\"><strong>Note:</strong> This method is intended for internal use by carrier\n     * applications or the Telephony framework and will never trigger an SMS disambiguation\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\n     * default subscription is defined, the subscription ID associated with this message will be\n     * INVALID, which will result in the operation being completed on the subscription associated\n     * with logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the\n     * operation is performed on the correct subscription.\n     * </p>\n     *\n     * @param destAddress the destination address to test for possible short code\n     * @param countryIso the ISO country code\n     *\n     * @return\n     * {@link SmsManager#SMS_CATEGORY_NOT_SHORT_CODE},\n     * {@link SmsManager#SMS_CATEGORY_FREE_SHORT_CODE},\n     * {@link SmsManager#SMS_CATEGORY_POSSIBLE_PREMIUM_SHORT_CODE},\n     * {@link SmsManager#SMS_CATEGORY_PREMIUM_SHORT_CODE}, or\n     * {@link SmsManager#SMS_CATEGORY_STANDARD_SHORT_CODE}\n     *\n     * @hide\n     ",
    "links" : [ "PhoneNumberUtils#extractNetworkPortion", "SmsManager", "#getDefault", "#getSmsManagerForSubscriptionId", "SmsManager#SMS_CATEGORY_NOT_SHORT_CODE", "SmsManager#SMS_CATEGORY_FREE_SHORT_CODE", "SmsManager#SMS_CATEGORY_POSSIBLE_PREMIUM_SHORT_CODE", "SmsManager#SMS_CATEGORY_PREMIUM_SHORT_CODE", "SmsManager#SMS_CATEGORY_STANDARD_SHORT_CODE" ]
  }, {
    "name" : "public String getSmscAddress()",
    "returnType" : "String",
    "comment" : "\n     * Gets the SMSC address from (U)SIM.\n     *\n     * <p class=\"note\"><strong>Note:</strong> Using this method requires that your app is the\n     * default SMS application, or READ_PRIVILEGED_PHONE_STATE permission, or has the carrier\n     * privileges.</p>\n     *\n     * <p class=\"note\"><strong>Note:</strong> This method will never trigger an SMS disambiguation\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\n     * default subscription is defined, the subscription ID associated with this method will be\n     * INVALID, which will result in the operation being completed on the subscription associated\n     * with logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the operation\n     * is performed on the correct subscription.\n     * </p>\n     *\n     * @return the SMSC address string, null if failed.\n     ",
    "links" : [ "SmsManager", "#getDefault", "#getSmsManagerForSubscriptionId" ]
  }, {
    "name" : "public boolean setSmscAddress(@NonNull String smsc)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets the SMSC address on (U)SIM.\n     *\n     * <p class=\"note\"><strong>Note:</strong> Using this method requires that your app is the\n     * default SMS application, or has {@link android.Manifest.permission#MODIFY_PHONE_STATE}\n     * permission, or has the carrier privileges.</p>\n     *\n     * <p class=\"note\"><strong>Note:</strong> This method will never trigger an SMS disambiguation\n     * dialog. If this method is called on a device that has multiple active subscriptions, this\n     * {@link SmsManager} instance has been created with {@link #getDefault()}, and no user-defined\n     * default subscription is defined, the subscription ID associated with this method will be\n     * INVALID, which will result in the operation being completed on the subscription associated\n     * with logical slot 0. Use {@link #getSmsManagerForSubscriptionId(int)} to ensure the operation\n     * is performed on the correct subscription.\n     * </p>\n     *\n     * @param smsc the SMSC address string.\n     * @return true for success, false otherwise. Failure can be due modem returning an error.\n     ",
    "links" : [ "android.Manifest.permission#MODIFY_PHONE_STATE", "SmsManager", "#getDefault", "#getSmsManagerForSubscriptionId" ]
  }, {
    "name" : "public int getPremiumSmsConsent(@NonNull String packageName)",
    "returnType" : "int",
    "comment" : "\n     * Gets the premium SMS permission for the specified package. If the package has never\n     * been seen before, the default {@link SmsManager#PREMIUM_SMS_CONSENT_UNKNOWN}\n     * will be returned.\n     * @param packageName the name of the package to query permission\n     * @return one of {@link SmsManager#PREMIUM_SMS_CONSENT_UNKNOWN},\n     *  {@link SmsManager#PREMIUM_SMS_CONSENT_ASK_USER},\n     *  {@link SmsManager#PREMIUM_SMS_CONSENT_NEVER_ALLOW}, or\n     *  {@link SmsManager#PREMIUM_SMS_CONSENT_ALWAYS_ALLOW}\n     * @hide\n     ",
    "links" : [ "SmsManager#PREMIUM_SMS_CONSENT_UNKNOWN", "SmsManager#PREMIUM_SMS_CONSENT_UNKNOWN", "SmsManager#PREMIUM_SMS_CONSENT_ASK_USER", "SmsManager#PREMIUM_SMS_CONSENT_NEVER_ALLOW", "SmsManager#PREMIUM_SMS_CONSENT_ALWAYS_ALLOW" ]
  }, {
    "name" : "public void setPremiumSmsConsent(@NonNull String packageName, @PremiumSmsConsent int permission)",
    "returnType" : "void",
    "comment" : "\n     * Sets the premium SMS permission for the specified package and save the value asynchronously\n     * to persistent storage.\n     * @param packageName the name of the package to set permission\n     * @param permission one of {@link SmsManager#PREMIUM_SMS_CONSENT_ASK_USER},\n     *  {@link SmsManager#PREMIUM_SMS_CONSENT_NEVER_ALLOW}, or\n     *  {@link SmsManager#PREMIUM_SMS_CONSENT_ALWAYS_ALLOW}\n     * @hide\n     ",
    "links" : [ "SmsManager#PREMIUM_SMS_CONSENT_ASK_USER", "SmsManager#PREMIUM_SMS_CONSENT_NEVER_ALLOW", "SmsManager#PREMIUM_SMS_CONSENT_ALWAYS_ALLOW" ]
  }, {
    "name" : "public boolean resetAllCellBroadcastRanges()",
    "returnType" : "boolean",
    "comment" : "\n     * Reset all cell broadcast ranges. Previously enabled ranges will become invalid after this.\n     *\n     * @return {@code true} if succeeded, otherwise {@code false}.\n     *\n     * // TODO: Unhide the API in S.\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "sInstance", "sLockObject", "SMS_RECORD_LENGTH", "CDMA_SMS_RECORD_LENGTH", "sSubInstances", "mSubId", "MMS_CONFIG_APPEND_TRANSACTION_ID", "MMS_CONFIG_MMS_ENABLED", "MMS_CONFIG_GROUP_MMS_ENABLED", "MMS_CONFIG_NOTIFY_WAP_MMSC_ENABLED", "MMS_CONFIG_ALIAS_ENABLED", "MMS_CONFIG_ALLOW_ATTACH_AUDIO", "MMS_CONFIG_MULTIPART_SMS_ENABLED", "MMS_CONFIG_SMS_DELIVERY_REPORT_ENABLED", "MMS_CONFIG_SUPPORT_MMS_CONTENT_DISPOSITION", "MMS_CONFIG_SEND_MULTIPART_SMS_AS_SEPARATE_MESSAGES", "MMS_CONFIG_MMS_READ_REPORT_ENABLED", "MMS_CONFIG_MMS_DELIVERY_REPORT_ENABLED", "MMS_CONFIG_MAX_MESSAGE_SIZE", "MMS_CONFIG_MAX_IMAGE_WIDTH", "MMS_CONFIG_MAX_IMAGE_HEIGHT", "MMS_CONFIG_RECIPIENT_LIMIT", "MMS_CONFIG_ALIAS_MIN_CHARS", "MMS_CONFIG_ALIAS_MAX_CHARS", "MMS_CONFIG_SMS_TO_MMS_TEXT_THRESHOLD", "MMS_CONFIG_SMS_TO_MMS_TEXT_LENGTH_THRESHOLD", "MMS_CONFIG_MESSAGE_TEXT_MAX_SIZE", "MMS_CONFIG_SUBJECT_MAX_LENGTH", "MMS_CONFIG_HTTP_SOCKET_TIMEOUT", "MMS_CONFIG_UA_PROF_TAG_NAME", "MMS_CONFIG_USER_AGENT", "MMS_CONFIG_UA_PROF_URL", "MMS_CONFIG_HTTP_PARAMS", "MMS_CONFIG_EMAIL_GATEWAY_NUMBER", "MMS_CONFIG_NAI_SUFFIX", "MMS_CONFIG_SHOW_CELL_BROADCAST_APP_LINKS", "MMS_CONFIG_SUPPORT_HTTP_CHARSET_HEADER", "MMS_CONFIG_CLOSE_CONNECTION", "SMS_MESSAGE_PRIORITY_NOT_SPECIFIED", "SMS_MESSAGE_PERIOD_NOT_SPECIFIED", "PREMIUM_SMS_CONSENT_UNKNOWN", "PREMIUM_SMS_CONSENT_ASK_USER", "PREMIUM_SMS_CONSENT_NEVER_ALLOW", "PREMIUM_SMS_CONSENT_ALWAYS_ALLOW", "GET_TARGET_SDK_VERSION_CODE_CHANGE", "STATUS_ON_ICC_FREE", "STATUS_ON_ICC_READ", "STATUS_ON_ICC_UNREAD", "STATUS_ON_ICC_SENT", "STATUS_ON_ICC_UNSENT", "RESULT_ERROR_NONE", "RESULT_ERROR_GENERIC_FAILURE", "RESULT_ERROR_RADIO_OFF", "RESULT_ERROR_NULL_PDU", "RESULT_ERROR_NO_SERVICE", "RESULT_ERROR_LIMIT_EXCEEDED", "RESULT_ERROR_FDN_CHECK_FAILURE", "RESULT_ERROR_SHORT_CODE_NOT_ALLOWED", "RESULT_ERROR_SHORT_CODE_NEVER_ALLOWED", "RESULT_RADIO_NOT_AVAILABLE", "RESULT_NETWORK_REJECT", "RESULT_INVALID_ARGUMENTS", "RESULT_INVALID_STATE", "RESULT_NO_MEMORY", "RESULT_INVALID_SMS_FORMAT", "RESULT_SYSTEM_ERROR", "RESULT_MODEM_ERROR", "RESULT_NETWORK_ERROR", "RESULT_ENCODING_ERROR", "RESULT_INVALID_SMSC_ADDRESS", "RESULT_OPERATION_NOT_ALLOWED", "RESULT_INTERNAL_ERROR", "RESULT_NO_RESOURCES", "RESULT_CANCELLED", "RESULT_REQUEST_NOT_SUPPORTED", "RESULT_NO_BLUETOOTH_SERVICE", "RESULT_INVALID_BLUETOOTH_ADDRESS", "RESULT_BLUETOOTH_DISCONNECTED", "RESULT_UNEXPECTED_EVENT_STOP_SENDING", "RESULT_SMS_BLOCKED_DURING_EMERGENCY", "RESULT_SMS_SEND_RETRY_FAILED", "RESULT_REMOTE_EXCEPTION", "RESULT_NO_DEFAULT_SMS_APP", "RESULT_RIL_RADIO_NOT_AVAILABLE", "RESULT_RIL_SMS_SEND_FAIL_RETRY", "RESULT_RIL_NETWORK_REJECT", "RESULT_RIL_INVALID_STATE", "RESULT_RIL_INVALID_ARGUMENTS", "RESULT_RIL_NO_MEMORY", "RESULT_RIL_REQUEST_RATE_LIMITED", "RESULT_RIL_INVALID_SMS_FORMAT", "RESULT_RIL_SYSTEM_ERR", "RESULT_RIL_ENCODING_ERR", "RESULT_RIL_INVALID_SMSC_ADDRESS", "RESULT_RIL_MODEM_ERR", "RESULT_RIL_NETWORK_ERR", "RESULT_RIL_INTERNAL_ERR", "RESULT_RIL_REQUEST_NOT_SUPPORTED", "RESULT_RIL_INVALID_MODEM_STATE", "RESULT_RIL_NETWORK_NOT_READY", "RESULT_RIL_OPERATION_NOT_ALLOWED", "RESULT_RIL_NO_RESOURCES", "RESULT_RIL_CANCELLED", "RESULT_RIL_SIM_ABSENT", "RESULT_RECEIVE_DISPATCH_FAILURE", "RESULT_RECEIVE_INJECTED_NULL_PDU", "RESULT_RECEIVE_RUNTIME_EXCEPTION", "RESULT_RECEIVE_NULL_MESSAGE_FROM_RIL", "RESULT_RECEIVE_WHILE_ENCRYPTED", "RESULT_RECEIVE_SQL_EXCEPTION", "RESULT_RECEIVE_URI_EXCEPTION", "MMS_ERROR_UNSPECIFIED", "MMS_ERROR_INVALID_APN", "MMS_ERROR_UNABLE_CONNECT_MMS", "MMS_ERROR_HTTP_FAILURE", "MMS_ERROR_IO_ERROR", "MMS_ERROR_RETRY", "MMS_ERROR_CONFIGURATION_ERROR", "MMS_ERROR_NO_DATA_NETWORK", "EXTRA_MMS_DATA", "EXTRA_MMS_HTTP_STATUS", "REGEX_PREFIX_DELIMITER", "RESULT_STATUS_SUCCESS", "RESULT_STATUS_TIMEOUT", "EXTRA_SMS_MESSAGE", "EXTRA_STATUS", "EXTRA_SIM_SUBSCRIPTION_ID", "SMS_CATEGORY_NOT_SHORT_CODE", "SMS_CATEGORY_FREE_SHORT_CODE", "SMS_CATEGORY_STANDARD_SHORT_CODE", "SMS_CATEGORY_POSSIBLE_PREMIUM_SHORT_CODE", "SMS_CATEGORY_PREMIUM_SHORT_CODE" ],
  "methodNames" : [ "public void sendTextMessage(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent)", "public void sendTextMessage(@NonNull String destinationAddress, @Nullable String scAddress, @NonNull String text, @Nullable PendingIntent sentIntent, @Nullable PendingIntent deliveryIntent, long messageId)", "public void sendTextMessage(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, int priority, boolean expectMore, int validityPeriod)", "private void sendTextMessageInternal(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessage, String packageName, String attributionTag, long messageId)", "public void sendTextMessageWithoutPersisting(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent)", "private void sendTextMessageInternal(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessage, int priority, boolean expectMore, int validityPeriod)", "public void sendTextMessageWithoutPersisting(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, int priority, boolean expectMore, int validityPeriod)", "public void injectSmsPdu(byte[] pdu, @SmsMessage.Format String format, PendingIntent receivedIntent)", "public ArrayList<String> divideMessage(String text)", "public void sendMultipartTextMessage(String destinationAddress, String scAddress, ArrayList<String> parts, ArrayList<PendingIntent> sentIntents, ArrayList<PendingIntent> deliveryIntents)", "public void sendMultipartTextMessage(@NonNull String destinationAddress, @Nullable String scAddress, @NonNull List<String> parts, @Nullable List<PendingIntent> sentIntents, @Nullable List<PendingIntent> deliveryIntents, long messageId)", "public void sendMultipartTextMessage(@NonNull String destinationAddress, @Nullable String scAddress, @NonNull List<String> parts, @Nullable List<PendingIntent> sentIntents, @Nullable List<PendingIntent> deliveryIntents, @NonNull String packageName, @Nullable String attributionTag)", "private void sendMultipartTextMessageInternal(String destinationAddress, String scAddress, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents, boolean persistMessage, String packageName, @Nullable String attributionTag, long messageId)", "public void sendMultipartTextMessageWithoutPersisting(String destinationAddress, String scAddress, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents)", "public void sendMultipartTextMessage(String destinationAddress, String scAddress, ArrayList<String> parts, ArrayList<PendingIntent> sentIntents, ArrayList<PendingIntent> deliveryIntents, int priority, boolean expectMore, int validityPeriod)", "private void sendMultipartTextMessageInternal(String destinationAddress, String scAddress, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents, boolean persistMessage, int priority, boolean expectMore, int validityPeriod)", "public void sendDataMessage(String destinationAddress, String scAddress, short destinationPort, byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent)", "public static SmsManager getDefault()", "public static SmsManager getSmsManagerForSubscriptionId(int subId)", "public int getSubscriptionId()", "private void resolveSubscriptionForOperation(SubscriptionResolverResult resolverResult)", "private void sendResolverResult(SubscriptionResolverResult resolverResult, int subId, boolean pickActivityShown)", "private static ITelephony getITelephony()", "private static void notifySmsError(PendingIntent pendingIntent, int error)", "private static void notifySmsError(List<PendingIntent> pendingIntents, int error)", "private static ISms getISmsServiceOrThrow()", "private static ISms getISmsService()", "public boolean copyMessageToIcc(@Nullable byte[] smsc, @NonNull byte[] pdu, @StatusOnIcc int status)", "public boolean deleteMessageFromIcc(int messageIndex)", "public boolean updateMessageOnIcc(int messageIndex, int newStatus, byte[] pdu)", "public List<SmsMessage> getMessagesFromIcc()", "public ArrayList<SmsMessage> getAllMessagesFromIcc()", "public boolean enableCellBroadcastRange(int startMessageId, int endMessageId, @android.telephony.SmsCbMessage.MessageFormat int ranType)", "public boolean disableCellBroadcastRange(int startMessageId, int endMessageId, @android.telephony.SmsCbMessage.MessageFormat int ranType)", "private ArrayList<SmsMessage> createMessageListFromRawRecords(List<SmsRawData> records)", "public boolean isImsSmsSupported()", "public String getImsSmsFormat()", "public static int getDefaultSmsSubscriptionId()", "public boolean isSMSPromptEnabled()", "public int getSmsCapacityOnIcc()", "public void sendMultimediaMessage(Context context, Uri contentUri, String locationUrl, Bundle configOverrides, PendingIntent sentIntent)", "public void downloadMultimediaMessage(Context context, String locationUrl, Uri contentUri, Bundle configOverrides, PendingIntent downloadedIntent)", "public Bundle getCarrierConfigValues()", "public String createAppSpecificSmsToken(PendingIntent intent)", "public void getSmsMessagesForFinancialApp(Bundle params, @NonNull @CallbackExecutor Executor executor, @NonNull FinancialSmsCallback callback)", "public String createAppSpecificSmsTokenWithPackageInfo(@Nullable String prefixes, @NonNull PendingIntent intent)", "public int checkSmsShortCodeDestination(String destAddress, String countryIso)", "public String getSmscAddress()", "public boolean setSmscAddress(@NonNull String smsc)", "public int getPremiumSmsConsent(@NonNull String packageName)", "public void setPremiumSmsConsent(@NonNull String packageName, @PremiumSmsConsent int permission)", "public boolean resetAllCellBroadcastRanges()" ]
}