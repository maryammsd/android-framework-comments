{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/nio/channels/AsynchronousSocketChannel.java",
  "packageName" : "java.nio.channels",
  "className" : "AsynchronousSocketChannel",
  "comment" : "",
  "links" : [ ],
  "variables" : [ {
    "name" : "provider",
    "type" : "AsynchronousChannelProvider",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public final AsynchronousChannelProvider provider()",
    "returnType" : "AsynchronousChannelProvider",
    "comment" : "\n     * Returns the provider that created this channel.\n     *\n     * @return  The provider that created this channel\n     ",
    "links" : [ ]
  }, {
    "name" : "public static AsynchronousSocketChannel open(AsynchronousChannelGroup group) throws IOException",
    "returnType" : "AsynchronousSocketChannel",
    "comment" : "\n     * Opens an asynchronous socket channel.\n     *\n     * <p> The new channel is created by invoking the {@link\n     * AsynchronousChannelProvider#openAsynchronousSocketChannel\n     * openAsynchronousSocketChannel} method on the {@link\n     * AsynchronousChannelProvider} that created the group. If the group parameter\n     * is {@code null} then the resulting channel is created by the system-wide\n     * default provider, and bound to the <em>default group</em>.\n     *\n     * @param   group\n     *          The group to which the newly constructed channel should be bound,\n     *          or {@code null} for the default group\n     *\n     * @return  A new asynchronous socket channel\n     *\n     * @throws  ShutdownChannelGroupException\n     *          If the channel group is shutdown\n     * @throws  IOException\n     *          If an I/O error occurs\n     ",
    "links" : [ "java.nio.channels.AsynchronousChannelProvider#openAsynchronousSocketChannelopenAsynchronousSocketChannel", "java.nio.channels.AsynchronousChannelProvider" ]
  }, {
    "name" : "public static AsynchronousSocketChannel open() throws IOException",
    "returnType" : "AsynchronousSocketChannel",
    "comment" : "\n     * Opens an asynchronous socket channel.\n     *\n     * <p> This method returns an asynchronous socket channel that is bound to\n     * the <em>default group</em>.This method is equivalent to evaluating the\n     * expression:\n     * <blockquote><pre>\n     * open((AsynchronousChannelGroup)null);\n     * </pre></blockquote>\n     *\n     * @return  A new asynchronous socket channel\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract AsynchronousSocketChannel bind(SocketAddress local) throws IOException",
    "returnType" : "AsynchronousSocketChannel",
    "comment" : "\n     * @throws  ConnectionPendingException\n     *          If a connection operation is already in progress on this channel\n     * @throws  AlreadyBoundException               {@inheritDoc}\n     * @throws  UnsupportedAddressTypeException     {@inheritDoc}\n     * @throws  ClosedChannelException              {@inheritDoc}\n     * @throws  IOException                         {@inheritDoc}\n     * @throws  SecurityException\n     *          If a security manager has been installed and its\n     *          {@link SecurityManager#checkListen checkListen} method denies\n     *          the operation\n     ",
    "links" : [ "#checkListen" ]
  }, {
    "name" : "public abstract AsynchronousSocketChannel setOption(SocketOption<T> name, T value) throws IOException",
    "returnType" : "AsynchronousSocketChannel",
    "comment" : "\n     * @throws  IllegalArgumentException                {@inheritDoc}\n     * @throws  ClosedChannelException                  {@inheritDoc}\n     * @throws  IOException                             {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract AsynchronousSocketChannel shutdownInput() throws IOException",
    "returnType" : "AsynchronousSocketChannel",
    "comment" : "\n     * Shutdown the connection for reading without closing the channel.\n     *\n     * <p> Once shutdown for reading then further reads on the channel will\n     * return {@code -1}, the end-of-stream indication. If the input side of the\n     * connection is already shutdown then invoking this method has no effect.\n     * The effect on an outstanding read operation is system dependent and\n     * therefore not specified. The effect, if any, when there is data in the\n     * socket receive buffer that has not been read, or data arrives subsequently,\n     * is also system dependent.\n     *\n     * @return  The channel\n     *\n     * @throws  NotYetConnectedException\n     *          If this channel is not yet connected\n     * @throws  ClosedChannelException\n     *          If this channel is closed\n     * @throws  IOException\n     *          If some other I/O error occurs\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract AsynchronousSocketChannel shutdownOutput() throws IOException",
    "returnType" : "AsynchronousSocketChannel",
    "comment" : "\n     * Shutdown the connection for writing without closing the channel.\n     *\n     * <p> Once shutdown for writing then further attempts to write to the\n     * channel will throw {@link ClosedChannelException}. If the output side of\n     * the connection is already shutdown then invoking this method has no\n     * effect. The effect on an outstanding write operation is system dependent\n     * and therefore not specified.\n     *\n     * @return  The channel\n     *\n     * @throws  NotYetConnectedException\n     *          If this channel is not yet connected\n     * @throws  ClosedChannelException\n     *          If this channel is closed\n     * @throws  IOException\n     *          If some other I/O error occurs\n     ",
    "links" : [ "java.nio.channels.ClosedChannelException" ]
  }, {
    "name" : "public abstract SocketAddress getRemoteAddress() throws IOException",
    "returnType" : "SocketAddress",
    "comment" : "\n     * Returns the remote address to which this channel's socket is connected.\n     *\n     * <p> Where the channel is bound and connected to an Internet Protocol\n     * socket address then the return value from this method is of type {@link\n     * java.net.InetSocketAddress}.\n     *\n     * @return  The remote address; {@code null} if the channel's socket is not\n     *          connected\n     *\n     * @throws  ClosedChannelException\n     *          If the channel is closed\n     * @throws  IOException\n     *          If an I/O error occurs\n     ",
    "links" : [ "java.net.InetSocketAddress" ]
  }, {
    "name" : "public abstract void connect(SocketAddress remote, A attachment, CompletionHandler<Void, ? super A> handler)",
    "returnType" : "void",
    "comment" : "\n     * Connects this channel.\n     *\n     * <p> This method initiates an operation to connect this channel. The\n     * {@code handler} parameter is a completion handler that is invoked when\n     * the connection is successfully established or connection cannot be\n     * established. If the connection cannot be established then the channel is\n     * closed.\n     *\n     * <p> This method performs exactly the same security checks as the {@link\n     * java.net.Socket} class.  That is, if a security manager has been\n     * installed then this method verifies that its {@link\n     * java.lang.SecurityManager#checkConnect checkConnect} method permits\n     * connecting to the address and port number of the given remote endpoint.\n     *\n     * @param   <A>\n     *          The type of the attachment\n     * @param   remote\n     *          The remote address to which this channel is to be connected\n     * @param   attachment\n     *          The object to attach to the I/O operation; can be {@code null}\n     * @param   handler\n     *          The handler for consuming the result\n     *\n     * @throws  UnresolvedAddressException\n     *          If the given remote address is not fully resolved\n     * @throws  UnsupportedAddressTypeException\n     *          If the type of the given remote address is not supported\n     * @throws  AlreadyConnectedException\n     *          If this channel is already connected\n     * @throws  ConnectionPendingException\n     *          If a connection operation is already in progress on this channel\n     * @throws  ShutdownChannelGroupException\n     *          If the channel group has terminated\n     * @throws  SecurityException\n     *          If a security manager has been installed\n     *          and it does not permit access to the given remote endpoint\n     *\n     * @see #getRemoteAddress\n     ",
    "links" : [ "java.net.Socket", "java.lang.SecurityManager#checkConnect" ]
  }, {
    "name" : "public abstract Future<Void> connect(SocketAddress remote)",
    "returnType" : "Future<Void>",
    "comment" : "\n     * Connects this channel.\n     *\n     * <p> This method initiates an operation to connect this channel. This\n     * method behaves in exactly the same manner as the {@link\n     * #connect(SocketAddress, Object, CompletionHandler)} method except that\n     * instead of specifying a completion handler, this method returns a {@code\n     * Future} representing the pending result. The {@code Future}'s {@link\n     * Future#get() get} method returns {@code null} on successful completion.\n     *\n     * @param   remote\n     *          The remote address to which this channel is to be connected\n     *\n     * @return  A {@code Future} object representing the pending result\n     *\n     * @throws  UnresolvedAddressException\n     *          If the given remote address is not fully resolved\n     * @throws  UnsupportedAddressTypeException\n     *          If the type of the given remote address is not supported\n     * @throws  AlreadyConnectedException\n     *          If this channel is already connected\n     * @throws  ConnectionPendingException\n     *          If a connection operation is already in progress on this channel\n     * @throws  SecurityException\n     *          If a security manager has been installed\n     *          and it does not permit access to the given remote endpoint\n     ",
    "links" : [ "java.util.concurrent.Future#get()", "#connect(SocketAddress" ]
  }, {
    "name" : "public abstract void read(ByteBuffer dst, long timeout, TimeUnit unit, A attachment, CompletionHandler<Integer, ? super A> handler)",
    "returnType" : "void",
    "comment" : "\n     * Reads a sequence of bytes from this channel into the given buffer.\n     *\n     * <p> This method initiates an asynchronous read operation to read a\n     * sequence of bytes from this channel into the given buffer. The {@code\n     * handler} parameter is a completion handler that is invoked when the read\n     * operation completes (or fails). The result passed to the completion\n     * handler is the number of bytes read or {@code -1} if no bytes could be\n     * read because the channel has reached end-of-stream.\n     *\n     * <p> If a timeout is specified and the timeout elapses before the operation\n     * completes then the operation completes with the exception {@link\n     * InterruptedByTimeoutException}. Where a timeout occurs, and the\n     * implementation cannot guarantee that bytes have not been read, or will not\n     * be read from the channel into the given buffer, then further attempts to\n     * read from the channel will cause an unspecific runtime exception to be\n     * thrown.\n     *\n     * <p> Otherwise this method works in the same manner as the {@link\n     * AsynchronousByteChannel#read(ByteBuffer,Object,CompletionHandler)}\n     * method.\n     *\n     * @param   <A>\n     *          The type of the attachment\n     * @param   dst\n     *          The buffer into which bytes are to be transferred\n     * @param   timeout\n     *          The maximum time for the I/O operation to complete\n     * @param   unit\n     *          The time unit of the {@code timeout} argument\n     * @param   attachment\n     *          The object to attach to the I/O operation; can be {@code null}\n     * @param   handler\n     *          The handler for consuming the result\n     *\n     * @throws  IllegalArgumentException\n     *          If the buffer is read-only\n     * @throws  ReadPendingException\n     *          If a read operation is already in progress on this channel\n     * @throws  NotYetConnectedException\n     *          If this channel is not yet connected\n     * @throws  ShutdownChannelGroupException\n     *          If the channel group has terminated\n     ",
    "links" : [ "java.nio.channels.AsynchronousByteChannel#read(ByteBuffer", "java.nio.channels.InterruptedByTimeoutException" ]
  }, {
    "name" : "public final void read(ByteBuffer dst, A attachment, CompletionHandler<Integer, ? super A> handler)",
    "returnType" : "void",
    "comment" : "\n     * @throws  IllegalArgumentException        {@inheritDoc}\n     * @throws  ReadPendingException            {@inheritDoc}\n     * @throws  NotYetConnectedException\n     *          If this channel is not yet connected\n     * @throws  ShutdownChannelGroupException\n     *          If the channel group has terminated\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract Future<Integer> read(ByteBuffer dst)",
    "returnType" : "Future<Integer>",
    "comment" : "\n     * @throws  IllegalArgumentException        {@inheritDoc}\n     * @throws  ReadPendingException            {@inheritDoc}\n     * @throws  NotYetConnectedException\n     *          If this channel is not yet connected\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract void read(ByteBuffer[] dsts, int offset, int length, long timeout, TimeUnit unit, A attachment, CompletionHandler<Long, ? super A> handler)",
    "returnType" : "void",
    "comment" : "\n     * Reads a sequence of bytes from this channel into a subsequence of the\n     * given buffers. This operation, sometimes called a <em>scattering read</em>,\n     * is often useful when implementing network protocols that group data into\n     * segments consisting of one or more fixed-length headers followed by a\n     * variable-length body. The {@code handler} parameter is a completion\n     * handler that is invoked when the read operation completes (or fails). The\n     * result passed to the completion handler is the number of bytes read or\n     * {@code -1} if no bytes could be read because the channel has reached\n     * end-of-stream.\n     *\n     * <p> This method initiates a read of up to <i>r</i> bytes from this channel,\n     * where <i>r</i> is the total number of bytes remaining in the specified\n     * subsequence of the given buffer array, that is,\n     *\n     * <blockquote><pre>\n     * dsts[offset].remaining()\n     *     + dsts[offset+1].remaining()\n     *     + ... + dsts[offset+length-1].remaining()</pre></blockquote>\n     *\n     * at the moment that the read is attempted.\n     *\n     * <p> Suppose that a byte sequence of length <i>n</i> is read, where\n     * {@code 0}&nbsp;{@code <}&nbsp;<i>n</i>&nbsp;{@code <=}&nbsp;<i>r</i>.\n     * Up to the first {@code dsts[offset].remaining()} bytes of this sequence\n     * are transferred into buffer {@code dsts[offset]}, up to the next\n     * {@code dsts[offset+1].remaining()} bytes are transferred into buffer\n     * {@code dsts[offset+1]}, and so forth, until the entire byte sequence\n     * is transferred into the given buffers.  As many bytes as possible are\n     * transferred into each buffer, hence the final position of each updated\n     * buffer, except the last updated buffer, is guaranteed to be equal to\n     * that buffer's limit. The underlying operating system may impose a limit\n     * on the number of buffers that may be used in an I/O operation. Where the\n     * number of buffers (with bytes remaining), exceeds this limit, then the\n     * I/O operation is performed with the maximum number of buffers allowed by\n     * the operating system.\n     *\n     * <p> If a timeout is specified and the timeout elapses before the operation\n     * completes then it completes with the exception {@link\n     * InterruptedByTimeoutException}. Where a timeout occurs, and the\n     * implementation cannot guarantee that bytes have not been read, or will not\n     * be read from the channel into the given buffers, then further attempts to\n     * read from the channel will cause an unspecific runtime exception to be\n     * thrown.\n     *\n     * @param   <A>\n     *          The type of the attachment\n     * @param   dsts\n     *          The buffers into which bytes are to be transferred\n     * @param   offset\n     *          The offset within the buffer array of the first buffer into which\n     *          bytes are to be transferred; must be non-negative and no larger than\n     *          {@code dsts.length}\n     * @param   length\n     *          The maximum number of buffers to be accessed; must be non-negative\n     *          and no larger than {@code dsts.length - offset}\n     * @param   timeout\n     *          The maximum time for the I/O operation to complete\n     * @param   unit\n     *          The time unit of the {@code timeout} argument\n     * @param   attachment\n     *          The object to attach to the I/O operation; can be {@code null}\n     * @param   handler\n     *          The handler for consuming the result\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If the pre-conditions for the {@code offset}  and {@code length}\n     *          parameter aren't met\n     * @throws  IllegalArgumentException\n     *          If the buffer is read-only\n     * @throws  ReadPendingException\n     *          If a read operation is already in progress on this channel\n     * @throws  NotYetConnectedException\n     *          If this channel is not yet connected\n     * @throws  ShutdownChannelGroupException\n     *          If the channel group has terminated\n     ",
    "links" : [ "java.nio.channels.InterruptedByTimeoutException" ]
  }, {
    "name" : "public abstract void write(ByteBuffer src, long timeout, TimeUnit unit, A attachment, CompletionHandler<Integer, ? super A> handler)",
    "returnType" : "void",
    "comment" : "\n     * Writes a sequence of bytes to this channel from the given buffer.\n     *\n     * <p> This method initiates an asynchronous write operation to write a\n     * sequence of bytes to this channel from the given buffer. The {@code\n     * handler} parameter is a completion handler that is invoked when the write\n     * operation completes (or fails). The result passed to the completion\n     * handler is the number of bytes written.\n     *\n     * <p> If a timeout is specified and the timeout elapses before the operation\n     * completes then it completes with the exception {@link\n     * InterruptedByTimeoutException}. Where a timeout occurs, and the\n     * implementation cannot guarantee that bytes have not been written, or will\n     * not be written to the channel from the given buffer, then further attempts\n     * to write to the channel will cause an unspecific runtime exception to be\n     * thrown.\n     *\n     * <p> Otherwise this method works in the same manner as the {@link\n     * AsynchronousByteChannel#write(ByteBuffer,Object,CompletionHandler)}\n     * method.\n     *\n     * @param   <A>\n     *          The type of the attachment\n     * @param   src\n     *          The buffer from which bytes are to be retrieved\n     * @param   timeout\n     *          The maximum time for the I/O operation to complete\n     * @param   unit\n     *          The time unit of the {@code timeout} argument\n     * @param   attachment\n     *          The object to attach to the I/O operation; can be {@code null}\n     * @param   handler\n     *          The handler for consuming the result\n     *\n     * @throws  WritePendingException\n     *          If a write operation is already in progress on this channel\n     * @throws  NotYetConnectedException\n     *          If this channel is not yet connected\n     * @throws  ShutdownChannelGroupException\n     *          If the channel group has terminated\n     ",
    "links" : [ "java.nio.channels.InterruptedByTimeoutException", "java.nio.channels.AsynchronousByteChannel#write(ByteBuffer" ]
  }, {
    "name" : "public final void write(ByteBuffer src, A attachment, CompletionHandler<Integer, ? super A> handler)",
    "returnType" : "void",
    "comment" : "\n     * @throws  WritePendingException          {@inheritDoc}\n     * @throws  NotYetConnectedException\n     *          If this channel is not yet connected\n     * @throws  ShutdownChannelGroupException\n     *          If the channel group has terminated\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract Future<Integer> write(ByteBuffer src)",
    "returnType" : "Future<Integer>",
    "comment" : "\n     * @throws  WritePendingException       {@inheritDoc}\n     * @throws  NotYetConnectedException\n     *          If this channel is not yet connected\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract void write(ByteBuffer[] srcs, int offset, int length, long timeout, TimeUnit unit, A attachment, CompletionHandler<Long, ? super A> handler)",
    "returnType" : "void",
    "comment" : "\n     * Writes a sequence of bytes to this channel from a subsequence of the given\n     * buffers. This operation, sometimes called a <em>gathering write</em>, is\n     * often useful when implementing network protocols that group data into\n     * segments consisting of one or more fixed-length headers followed by a\n     * variable-length body. The {@code handler} parameter is a completion\n     * handler that is invoked when the write operation completes (or fails).\n     * The result passed to the completion handler is the number of bytes written.\n     *\n     * <p> This method initiates a write of up to <i>r</i> bytes to this channel,\n     * where <i>r</i> is the total number of bytes remaining in the specified\n     * subsequence of the given buffer array, that is,\n     *\n     * <blockquote><pre>\n     * srcs[offset].remaining()\n     *     + srcs[offset+1].remaining()\n     *     + ... + srcs[offset+length-1].remaining()</pre></blockquote>\n     *\n     * at the moment that the write is attempted.\n     *\n     * <p> Suppose that a byte sequence of length <i>n</i> is written, where\n     * {@code 0}&nbsp;{@code <}&nbsp;<i>n</i>&nbsp;{@code <=}&nbsp;<i>r</i>.\n     * Up to the first {@code srcs[offset].remaining()} bytes of this sequence\n     * are written from buffer {@code srcs[offset]}, up to the next\n     * {@code srcs[offset+1].remaining()} bytes are written from buffer\n     * {@code srcs[offset+1]}, and so forth, until the entire byte sequence is\n     * written.  As many bytes as possible are written from each buffer, hence\n     * the final position of each updated buffer, except the last updated\n     * buffer, is guaranteed to be equal to that buffer's limit. The underlying\n     * operating system may impose a limit on the number of buffers that may be\n     * used in an I/O operation. Where the number of buffers (with bytes\n     * remaining), exceeds this limit, then the I/O operation is performed with\n     * the maximum number of buffers allowed by the operating system.\n     *\n     * <p> If a timeout is specified and the timeout elapses before the operation\n     * completes then it completes with the exception {@link\n     * InterruptedByTimeoutException}. Where a timeout occurs, and the\n     * implementation cannot guarantee that bytes have not been written, or will\n     * not be written to the channel from the given buffers, then further attempts\n     * to write to the channel will cause an unspecific runtime exception to be\n     * thrown.\n     *\n     * @param   <A>\n     *          The type of the attachment\n     * @param   srcs\n     *          The buffers from which bytes are to be retrieved\n     * @param   offset\n     *          The offset within the buffer array of the first buffer from which\n     *          bytes are to be retrieved; must be non-negative and no larger\n     *          than {@code srcs.length}\n     * @param   length\n     *          The maximum number of buffers to be accessed; must be non-negative\n     *          and no larger than {@code srcs.length - offset}\n     * @param   timeout\n     *          The maximum time for the I/O operation to complete\n     * @param   unit\n     *          The time unit of the {@code timeout} argument\n     * @param   attachment\n     *          The object to attach to the I/O operation; can be {@code null}\n     * @param   handler\n     *          The handler for consuming the result\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If the pre-conditions for the {@code offset}  and {@code length}\n     *          parameter aren't met\n     * @throws  WritePendingException\n     *          If a write operation is already in progress on this channel\n     * @throws  NotYetConnectedException\n     *          If this channel is not yet connected\n     * @throws  ShutdownChannelGroupException\n     *          If the channel group has terminated\n     ",
    "links" : [ "java.nio.channels.InterruptedByTimeoutException" ]
  }, {
    "name" : "public abstract SocketAddress getLocalAddress() throws IOException",
    "returnType" : "SocketAddress",
    "comment" : "\n     * {@inheritDoc}\n     * <p>\n     * If there is a security manager set, its {@code checkConnect} method is\n     * called with the local address and {@code -1} as its arguments to see\n     * if the operation is allowed. If the operation is not allowed,\n     * a {@code SocketAddress} representing the\n     * {@link java.net.InetAddress#getLoopbackAddress loopback} address and the\n     * local port of the channel's socket is returned.\n     *\n     * @return  The {@code SocketAddress} that the socket is bound to, or the\n     *          {@code SocketAddress} representing the loopback address if\n     *          denied by the security manager, or {@code null} if the\n     *          channel's socket is not bound\n     *\n     * @throws  ClosedChannelException     {@inheritDoc}\n     * @throws  IOException                {@inheritDoc}\n     ",
    "links" : [ "java.net.InetAddress#getLoopbackAddress" ]
  } ],
  "methodNames" : [ "public final AsynchronousChannelProvider provider()", "public static AsynchronousSocketChannel open(AsynchronousChannelGroup group) throws IOException", "public static AsynchronousSocketChannel open() throws IOException", "public abstract AsynchronousSocketChannel bind(SocketAddress local) throws IOException", "public abstract AsynchronousSocketChannel setOption(SocketOption<T> name, T value) throws IOException", "public abstract AsynchronousSocketChannel shutdownInput() throws IOException", "public abstract AsynchronousSocketChannel shutdownOutput() throws IOException", "public abstract SocketAddress getRemoteAddress() throws IOException", "public abstract void connect(SocketAddress remote, A attachment, CompletionHandler<Void, ? super A> handler)", "public abstract Future<Void> connect(SocketAddress remote)", "public abstract void read(ByteBuffer dst, long timeout, TimeUnit unit, A attachment, CompletionHandler<Integer, ? super A> handler)", "public final void read(ByteBuffer dst, A attachment, CompletionHandler<Integer, ? super A> handler)", "public abstract Future<Integer> read(ByteBuffer dst)", "public abstract void read(ByteBuffer[] dsts, int offset, int length, long timeout, TimeUnit unit, A attachment, CompletionHandler<Long, ? super A> handler)", "public abstract void write(ByteBuffer src, long timeout, TimeUnit unit, A attachment, CompletionHandler<Integer, ? super A> handler)", "public final void write(ByteBuffer src, A attachment, CompletionHandler<Integer, ? super A> handler)", "public abstract Future<Integer> write(ByteBuffer src)", "public abstract void write(ByteBuffer[] srcs, int offset, int length, long timeout, TimeUnit unit, A attachment, CompletionHandler<Long, ? super A> handler)", "public abstract SocketAddress getLocalAddress() throws IOException" ],
  "variableNames" : [ "provider" ]
}