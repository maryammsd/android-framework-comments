{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/os/storage/StorageManager.java",
  "packageName" : "android.os.storage",
  "className" : "StorageManager",
  "comment" : "\n * StorageManager is the interface to the systems storage service. The storage\n * manager handles storage-related items such as Opaque Binary Blobs (OBBs).\n * <p>\n * OBBs contain a filesystem that maybe be encrypted on disk and mounted\n * on-demand from an application. OBBs are a good way of providing large amounts\n * of binary assets without packaging them into APKs as they may be multiple\n * gigabytes in size. However, due to their size, they're most likely stored in\n * a shared storage pool accessible from all programs. The system does not\n * guarantee the security of the OBB file itself: if any program modifies the\n * OBB, there is no guarantee that a read from that OBB will produce the\n * expected output.\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LOCAL_LOGV",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PROP_PRIMARY_PHYSICAL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PROP_HAS_ADOPTABLE",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PROP_HAS_RESERVED",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PROP_ADOPTABLE",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PROP_EMULATE_FBE",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PROP_SDCARDFS",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PROP_VIRTUAL_DISK",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PROP_ISOLATED_STORAGE",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PROP_ISOLATED_STORAGE_SNAPSHOT",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PROP_FUSE",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PROP_SETTINGS_FUSE",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PROP_FORCED_SCOPED_STORAGE_WHITELIST",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "UUID_PRIVATE_INTERNAL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "UUID_PRIMARY_PHYSICAL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "UUID_SYSTEM",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "UUID_DEFAULT",
    "type" : "UUID",
    "comment" : "\n     * UUID representing the default internal storage of this device which\n     * provides {@link Environment#getDataDirectory()}.\n     * <p>\n     * This value is constant across all devices and it will never change, and\n     * thus it cannot be used to uniquely identify a particular physical device.\n     *\n     * @see #getUuidForPath(File)\n     * @see ApplicationInfo#storageUuid\n     ",
    "links" : [ "Environment#getDataDirectory" ]
  }, {
    "name" : "UUID_PRIMARY_PHYSICAL_",
    "type" : "UUID",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "UUID_SYSTEM_",
    "type" : "UUID",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "ACTION_MANAGE_STORAGE",
    "type" : "String",
    "comment" : "\n     * Activity Action: Allows the user to manage their storage. This activity\n     * provides the ability to free up space on the device by deleting data such\n     * as apps.\n     * <p>\n     * If the sending application has a specific storage device or allocation\n     * size in mind, they can optionally define {@link #EXTRA_UUID} or\n     * {@link #EXTRA_REQUESTED_BYTES}, respectively.\n     * <p>\n     * This intent should be launched using\n     * {@link Activity#startActivityForResult(Intent, int)} so that the user\n     * knows which app is requesting the storage space. The returned result will\n     * be {@link Activity#RESULT_OK} if the requested space was made available,\n     * or {@link Activity#RESULT_CANCELED} otherwise.\n     ",
    "links" : [ "#EXTRA_UUID", "#EXTRA_REQUESTED_BYTES", "Activity#startActivityForResult", "Activity#RESULT_OK", "Activity#RESULT_CANCELED" ]
  }, {
    "name" : "ACTION_CLEAR_APP_CACHE",
    "type" : "String",
    "comment" : "\n     * Activity Action: Allows the user to free up space by clearing app external cache directories.\n     * The intent doesn't automatically clear cache, but shows a dialog and lets the user decide.\n     * <p>\n     * This intent should be launched using\n     * {@link Activity#startActivityForResult(Intent, int)} so that the user\n     * knows which app is requesting to clear cache. The returned result will be:\n     * {@link Activity#RESULT_OK} if the activity was launched and all cache was cleared,\n     * {@link OsConstants#EIO} if an error occurred while clearing the cache or\n     * {@link Activity#RESULT_CANCELED} otherwise.\n     ",
    "links" : [ "Activity#startActivityForResult", "Activity#RESULT_OK", "OsConstants#EIO", "Activity#RESULT_CANCELED" ]
  }, {
    "name" : "EXTRA_UUID",
    "type" : "String",
    "comment" : "\n     * Extra {@link UUID} used to indicate the storage volume where an\n     * application is interested in allocating or managing disk space.\n     *\n     * @see #ACTION_MANAGE_STORAGE\n     * @see #UUID_DEFAULT\n     * @see #getUuidForPath(File)\n     * @see Intent#putExtra(String, java.io.Serializable)\n     ",
    "links" : [ "UUID" ]
  }, {
    "name" : "EXTRA_REQUESTED_BYTES",
    "type" : "String",
    "comment" : "\n     * Extra used to indicate the total size (in bytes) that an application is\n     * interested in allocating.\n     * <p>\n     * When defined, the management UI will help guide the user to free up\n     * enough disk space to reach this requested value.\n     *\n     * @see #ACTION_MANAGE_STORAGE\n     ",
    "links" : [ ]
  }, {
    "name" : "DEBUG_ADOPTABLE_FORCE_ON",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "DEBUG_ADOPTABLE_FORCE_OFF",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "DEBUG_EMULATE_FBE",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "DEBUG_SDCARDFS_FORCE_ON",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "DEBUG_SDCARDFS_FORCE_OFF",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "DEBUG_VIRTUAL_DISK",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "DEBUG_ISOLATED_STORAGE_FORCE_ON",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "DEBUG_ISOLATED_STORAGE_FORCE_OFF",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "FLAG_STORAGE_DE",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "FLAG_STORAGE_CE",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "FLAG_STORAGE_EXTERNAL",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "FLAG_FOR_WRITE",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "FLAG_REAL_STATE",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "FLAG_INCLUDE_INVISIBLE",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "FLAG_INCLUDE_RECENT",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "FSTRIM_FLAG_DEEP",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "ENCRYPTION_STATE_NONE",
    "type" : "int",
    "comment" : " @hide The volume is not encrypted. ",
    "links" : [ ]
  }, {
    "name" : "ENCRYPTION_STATE_OK",
    "type" : "int",
    "comment" : " @hide The volume has been encrypted succesfully. ",
    "links" : [ ]
  }, {
    "name" : "ENCRYPTION_STATE_ERROR_UNKNOWN",
    "type" : "int",
    "comment" : " @hide The volume is in a bad state. ",
    "links" : [ ]
  }, {
    "name" : "ENCRYPTION_STATE_ERROR_INCOMPLETE",
    "type" : "int",
    "comment" : " @hide Encryption is incomplete ",
    "links" : [ ]
  }, {
    "name" : "ENCRYPTION_STATE_ERROR_INCONSISTENT",
    "type" : "int",
    "comment" : " @hide Encryption is incomplete and irrecoverable ",
    "links" : [ ]
  }, {
    "name" : "ENCRYPTION_STATE_ERROR_CORRUPT",
    "type" : "int",
    "comment" : " @hide Underlying data is corrupt ",
    "links" : [ ]
  }, {
    "name" : "sStorageManager",
    "type" : "IStorageManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mResolver",
    "type" : "ContentResolver",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mStorageManager",
    "type" : "IStorageManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAppOps",
    "type" : "AppOpsManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLooper",
    "type" : "Looper",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mNextNonce",
    "type" : "AtomicInteger",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDelegates",
    "type" : "ArrayList<StorageEventListenerDelegate>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mObbActionListener",
    "type" : "ObbActionListener",
    "comment" : "\n     * Binder listener for OBB action results.\n     ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_THRESHOLD_PERCENTAGE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_THRESHOLD_MAX_BYTES",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_CACHE_PERCENTAGE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_CACHE_MAX_BYTES",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_FULL_THRESHOLD_BYTES",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "FLAG_ALLOCATE_AGGRESSIVE",
    "type" : "int",
    "comment" : "\n     * Flag indicating that a disk space allocation request should operate in an\n     * aggressive mode. This flag should only be rarely used in situations that\n     * are critical to system health or security.\n     * <p>\n     * When set, the system is more aggressive about the data that it considers\n     * for possible deletion when allocating disk space.\n     * <p class=\"note\">\n     * Note: your app must hold the\n     * {@link android.Manifest.permission#ALLOCATE_AGGRESSIVE} permission for\n     * this flag to take effect.\n     * </p>\n     *\n     * @see #getAllocatableBytes(UUID, int)\n     * @see #allocateBytes(UUID, long, int)\n     * @see #allocateBytes(FileDescriptor, long, int)\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#ALLOCATE_AGGRESSIVE" ]
  }, {
    "name" : "FLAG_ALLOCATE_DEFY_ALL_RESERVED",
    "type" : "int",
    "comment" : "\n     * Flag indicating that a disk space allocation request should be allowed to\n     * clear up to all reserved disk space.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_ALLOCATE_DEFY_HALF_RESERVED",
    "type" : "int",
    "comment" : "\n     * Flag indicating that a disk space allocation request should be allowed to\n     * clear up to half of all reserved disk space.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_ALLOCATE_NON_CACHE_ONLY",
    "type" : "int",
    "comment" : "\n     * Flag indicating that a disk space check should not take into account\n     * freeable cached space when determining allocatable space.\n     *\n     * Intended for use with {@link #getAllocatableBytes()}.\n     * @hide\n     ",
    "links" : [ "#getAllocatableBytes" ]
  }, {
    "name" : "FLAG_ALLOCATE_CACHE_ONLY",
    "type" : "int",
    "comment" : "\n     * Flag indicating that a disk space check should only return freeable\n     * cached space when determining allocatable space.\n     *\n     * Intended for use with {@link #getAllocatableBytes()}.\n     * @hide\n     ",
    "links" : [ "#getAllocatableBytes" ]
  }, {
    "name" : "XATTR_CACHE_GROUP",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "XATTR_CACHE_TOMBSTONE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PROJECT_ID_EXT_DEFAULT",
    "type" : "int",
    "comment" : "\n     * Default project ID for files on external storage\n     *\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "PROJECT_ID_EXT_MEDIA_AUDIO",
    "type" : "int",
    "comment" : "\n     * project ID for audio files on external storage\n     *\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "PROJECT_ID_EXT_MEDIA_VIDEO",
    "type" : "int",
    "comment" : "\n     * project ID for video files on external storage\n     *\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "PROJECT_ID_EXT_MEDIA_IMAGE",
    "type" : "int",
    "comment" : "\n     * project ID for image files on external storage\n     *\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "QUOTA_TYPE_MEDIA_NONE",
    "type" : "int",
    "comment" : "\n     * Constant for use with\n     * {@link #updateExternalStorageFileQuotaType(String, int)} (String, int)}, to indicate the file\n     * is not a media file.\n     *\n     * @hide\n     ",
    "links" : [ "#updateExternalStorageFileQuotaType" ]
  }, {
    "name" : "QUOTA_TYPE_MEDIA_IMAGE",
    "type" : "int",
    "comment" : "\n     * Constant for use with\n     * {@link #updateExternalStorageFileQuotaType(String, int)} (String, int)}, to indicate the file\n     * is an image file.\n     *\n     * @hide\n     ",
    "links" : [ "#updateExternalStorageFileQuotaType" ]
  }, {
    "name" : "QUOTA_TYPE_MEDIA_AUDIO",
    "type" : "int",
    "comment" : "\n     * Constant for use with\n     * {@link #updateExternalStorageFileQuotaType(String, int)} (String, int)}, to indicate the file\n     * is an audio file.\n     *\n     * @hide\n     ",
    "links" : [ "#updateExternalStorageFileQuotaType" ]
  }, {
    "name" : "QUOTA_TYPE_MEDIA_VIDEO",
    "type" : "int",
    "comment" : "\n     * Constant for use with\n     * {@link #updateExternalStorageFileQuotaType(String, int)} (String, int)}, to indicate the file\n     * is a video file.\n     *\n     * @hide\n     ",
    "links" : [ "#updateExternalStorageFileQuotaType" ]
  }, {
    "name" : "mFuseAppLoopLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFuseAppLoop",
    "type" : "FuseAppLoop",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CRYPT_TYPE_PASSWORD",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CRYPT_TYPE_DEFAULT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CRYPT_TYPE_PATTERN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CRYPT_TYPE_PIN",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SYSTEM_LOCALE_KEY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "OWNER_INFO_KEY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "PATTERN_VISIBLE_KEY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "PASSWORD_VISIBLE_KEY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private int getNextNonce()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static StorageManager from(Context context)",
    "returnType" : "StorageManager",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void registerListener(StorageEventListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Registers a {@link android.os.storage.StorageEventListener StorageEventListener}.\n     *\n     * @param listener A {@link android.os.storage.StorageEventListener StorageEventListener} object.\n     *\n     * @hide\n     ",
    "links" : [ "android.os.storage.StorageEventListener", "android.os.storage.StorageEventListener" ]
  }, {
    "name" : "public void unregisterListener(StorageEventListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters a {@link android.os.storage.StorageEventListener StorageEventListener}.\n     *\n     * @param listener A {@link android.os.storage.StorageEventListener StorageEventListener} object.\n     *\n     * @hide\n     ",
    "links" : [ "android.os.storage.StorageEventListener", "android.os.storage.StorageEventListener" ]
  }, {
    "name" : "public void registerStorageVolumeCallback(@CallbackExecutor @NonNull Executor executor, @NonNull StorageVolumeCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Registers the given callback to listen for {@link StorageVolume} changes.\n     * <p>\n     * For example, this can be used to detect when a volume changes to the\n     * {@link Environment#MEDIA_MOUNTED} or {@link Environment#MEDIA_UNMOUNTED}\n     * states.\n     *\n     * @see StorageManager#unregisterStorageVolumeCallback\n     ",
    "links" : [ "StorageVolume", "Environment#MEDIA_MOUNTED", "Environment#MEDIA_UNMOUNTED" ]
  }, {
    "name" : "public void unregisterStorageVolumeCallback(@NonNull StorageVolumeCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters the given callback from listening for {@link StorageVolume}\n     * changes.\n     *\n     * @see StorageManager#registerStorageVolumeCallback\n     ",
    "links" : [ "StorageVolume" ]
  }, {
    "name" : "public void enableUsbMassStorage()",
    "returnType" : "void",
    "comment" : "\n     * Enables USB Mass Storage (UMS) on the device.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void disableUsbMassStorage()",
    "returnType" : "void",
    "comment" : "\n     * Disables USB Mass Storage (UMS) on the device.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUsbMassStorageConnected()",
    "returnType" : "boolean",
    "comment" : "\n     * Query if a USB Mass Storage (UMS) host is connected.\n     * @return true if UMS host is connected.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUsbMassStorageEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Query if a USB Mass Storage (UMS) is enabled on the device.\n     * @return true if UMS host is enabled.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean mountObb(String rawPath, String key, OnObbStateChangeListener listener)",
    "returnType" : "boolean",
    "comment" : "\n     * Mount an Opaque Binary Blob (OBB) file. If a <code>key</code> is\n     * specified, it is supplied to the mounting process to be used in any\n     * encryption used in the OBB.\n     * <p>\n     * The OBB will remain mounted for as long as the StorageManager reference\n     * is held by the application. As soon as this reference is lost, the OBBs\n     * in use will be unmounted. The {@link OnObbStateChangeListener} registered\n     * with this call will receive the success or failure of this operation.\n     * <p>\n     * <em>Note:</em> you can only mount OBB files for which the OBB tag on the\n     * file matches a package ID that is owned by the calling program's UID.\n     * That is, shared UID applications can attempt to mount any other\n     * application's OBB that shares its UID.\n     *\n     * @param rawPath the path to the OBB file\n     * @param key secret used to encrypt the OBB; may be <code>null</code> if no\n     *            encryption was used on the OBB.\n     * @param listener will receive the success or failure of the operation\n     * @return whether the mount call was successfully queued or not\n     ",
    "links" : [ "OnObbStateChangeListener" ]
  }, {
    "name" : "private ObbInfo getObbInfo(String canonicalPath)",
    "returnType" : "ObbInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean unmountObb(String rawPath, boolean force, OnObbStateChangeListener listener)",
    "returnType" : "boolean",
    "comment" : "\n     * Unmount an Opaque Binary Blob (OBB) file asynchronously. If the\n     * <code>force</code> flag is true, it will kill any application needed to\n     * unmount the given OBB (even the calling application).\n     * <p>\n     * The {@link OnObbStateChangeListener} registered with this call will\n     * receive the success or failure of this operation.\n     * <p>\n     * <em>Note:</em> you can only mount OBB files for which the OBB tag on the\n     * file matches a package ID that is owned by the calling program's UID.\n     * That is, shared UID applications can obtain access to any other\n     * application's OBB that shares its UID.\n     * <p>\n     *\n     * @param rawPath path to the OBB file\n     * @param force whether to kill any programs using this in order to unmount\n     *            it\n     * @param listener will receive the success or failure of the operation\n     * @return whether the unmount call was successfully queued or not\n     ",
    "links" : [ "OnObbStateChangeListener" ]
  }, {
    "name" : "public boolean isObbMounted(String rawPath)",
    "returnType" : "boolean",
    "comment" : "\n     * Check whether an Opaque Binary Blob (OBB) is mounted or not.\n     *\n     * @param rawPath path to OBB image\n     * @return true if OBB is mounted; false if not mounted or on error\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getMountedObbPath(String rawPath)",
    "returnType" : "String",
    "comment" : "\n     * Check the mounted path of an Opaque Binary Blob (OBB) file. This will\n     * give you the path to where you can obtain access to the internals of the\n     * OBB.\n     *\n     * @param rawPath path to OBB image\n     * @return absolute path to mounted OBB image data or <code>null</code> if\n     *         not mounted or exception encountered trying to read status\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<DiskInfo> getDisks()",
    "returnType" : "List<DiskInfo>",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public DiskInfo findDiskById(String id)",
    "returnType" : "DiskInfo",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public VolumeInfo findVolumeById(String id)",
    "returnType" : "VolumeInfo",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public VolumeInfo findVolumeByUuid(String fsUuid)",
    "returnType" : "VolumeInfo",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public VolumeRecord findRecordByUuid(String fsUuid)",
    "returnType" : "VolumeRecord",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public VolumeInfo findPrivateForEmulated(VolumeInfo emulatedVol)",
    "returnType" : "VolumeInfo",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public VolumeInfo findEmulatedForPrivate(VolumeInfo privateVol)",
    "returnType" : "VolumeInfo",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public VolumeInfo findVolumeByQualifiedUuid(String volumeUuid)",
    "returnType" : "VolumeInfo",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public UUID getUuidForPath(@NonNull File path) throws IOException",
    "returnType" : "UUID",
    "comment" : "\n     * Return a UUID identifying the storage volume that hosts the given\n     * filesystem path.\n     * <p>\n     * If this path is hosted by the default internal storage of the device at\n     * {@link Environment#getDataDirectory()}, the returned value will be\n     * {@link #UUID_DEFAULT}.\n     *\n     * @throws IOException when the storage device hosting the given path isn't\n     *             present, or when it doesn't have a valid UUID.\n     ",
    "links" : [ "Environment#getDataDirectory", "#UUID_DEFAULT" ]
  }, {
    "name" : "public File findPathForUuid(String volumeUuid) throws FileNotFoundException",
    "returnType" : "File",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAllocationSupported(@NonNull FileDescriptor fd)",
    "returnType" : "boolean",
    "comment" : "\n     * Test if the given file descriptor supports allocation of disk space using\n     * {@link #allocateBytes(FileDescriptor, long)}.\n     ",
    "links" : [ "#allocateBytes" ]
  }, {
    "name" : "public List<VolumeInfo> getVolumes()",
    "returnType" : "List<VolumeInfo>",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public List<VolumeInfo> getWritablePrivateVolumes()",
    "returnType" : "List<VolumeInfo>",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public List<VolumeRecord> getVolumeRecords()",
    "returnType" : "List<VolumeRecord>",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public String getBestVolumeDescription(VolumeInfo vol)",
    "returnType" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public VolumeInfo getPrimaryPhysicalVolume()",
    "returnType" : "VolumeInfo",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void mount(String volId)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void unmount(String volId)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void format(String volId)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public long benchmark(String volId)",
    "returnType" : "long",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void benchmark(String volId, IVoldTaskListener listener)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void partitionPublic(String diskId)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void partitionPrivate(String diskId)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void partitionMixed(String diskId, int ratio)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void wipeAdoptableDisks()",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void setVolumeNickname(String fsUuid, String nickname)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void setVolumeInited(String fsUuid, boolean inited)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void setVolumeSnoozed(String fsUuid, boolean snoozed)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void forgetVolume(String fsUuid)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public String getPrimaryStorageUuid()",
    "returnType" : "String",
    "comment" : "\n     * This is not the API you're looking for.\n     *\n     * @see PackageManager#getPrimaryStorageCurrentVolume()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setPrimaryStorageUuid(String volumeUuid, IPackageMoveObserver callback)",
    "returnType" : "void",
    "comment" : "\n     * This is not the API you're looking for.\n     *\n     * @see PackageManager#movePrimaryStorage(VolumeInfo)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public StorageVolume getStorageVolume(@NonNull File file)",
    "returnType" : "StorageVolume",
    "comment" : "\n     * Return the {@link StorageVolume} that contains the given file, or\n     * {@code null} if none.\n     ",
    "links" : [ "StorageVolume" ]
  }, {
    "name" : "public StorageVolume getStorageVolume(@NonNull Uri uri)",
    "returnType" : "StorageVolume",
    "comment" : "\n     * Return the {@link StorageVolume} that contains the given\n     * {@link MediaStore} item.\n     ",
    "links" : [ "StorageVolume", "MediaStore" ]
  }, {
    "name" : "public static StorageVolume getStorageVolume(File file, int userId)",
    "returnType" : "StorageVolume",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "private static StorageVolume getStorageVolume(StorageVolume[] volumes, File file)",
    "returnType" : "StorageVolume",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public String getVolumeState(String mountPoint)",
    "returnType" : "String",
    "comment" : "\n     * Gets the state of a volume via its mountpoint.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<StorageVolume> getStorageVolumes()",
    "returnType" : "List<StorageVolume>",
    "comment" : "\n     * Return the list of shared/external storage volumes currently available to\n     * the calling user.\n     * <p>\n     * These storage volumes are actively attached to the device, but may be in\n     * any mount state, as returned by {@link StorageVolume#getState()}. Returns\n     * both the primary shared storage device and any attached external volumes,\n     * including SD cards and USB drives.\n     ",
    "links" : [ "StorageVolume#getState" ]
  }, {
    "name" : "public List<StorageVolume> getRecentStorageVolumes()",
    "returnType" : "List<StorageVolume>",
    "comment" : "\n     * Return the list of shared/external storage volumes both currently and\n     * recently available to the calling user.\n     * <p>\n     * Recently available storage volumes are likely to reappear in the future,\n     * so apps are encouraged to preserve any indexed metadata related to these\n     * volumes to optimize user experiences.\n     ",
    "links" : [ ]
  }, {
    "name" : "public StorageVolume getPrimaryStorageVolume()",
    "returnType" : "StorageVolume",
    "comment" : "\n     * Return the primary shared/external storage volume available to the\n     * current user. This volume is the same storage device returned by\n     * {@link Environment#getExternalStorageDirectory()} and\n     * {@link Context#getExternalFilesDir(String)}.\n     ",
    "links" : [ "Environment#getExternalStorageDirectory", "Context#getExternalFilesDir" ]
  }, {
    "name" : "public static Pair<String, Long> getPrimaryStoragePathAndSize()",
    "returnType" : "Pair<String, Long>",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public long getPrimaryStorageSize()",
    "returnType" : "long",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void mkdirs(File file)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public StorageVolume[] getVolumeList()",
    "returnType" : "StorageVolume[]",
    "comment" : " @removed ",
    "links" : [ ]
  }, {
    "name" : "public static StorageVolume[] getVolumeList(int userId, int flags)",
    "returnType" : "StorageVolume[]",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public String[] getVolumePaths()",
    "returnType" : "String[]",
    "comment" : "\n     * Returns list of paths for all mountable volumes.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public StorageVolume getPrimaryVolume()",
    "returnType" : "StorageVolume",
    "comment" : " @removed ",
    "links" : [ ]
  }, {
    "name" : "public static StorageVolume getPrimaryVolume(StorageVolume[] volumes)",
    "returnType" : "StorageVolume",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public long getStorageBytesUntilLow(File path)",
    "returnType" : "long",
    "comment" : "\n     * Return the number of available bytes until the given path is considered\n     * running low on storage.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getStorageLowBytes(File path)",
    "returnType" : "long",
    "comment" : "\n     * Return the number of available bytes at which the given path is\n     * considered running low on storage.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getStorageCacheBytes(File path, @AllocateFlags int flags)",
    "returnType" : "long",
    "comment" : "\n     * Return the minimum number of bytes of storage on the device that should\n     * be reserved for cached data.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getStorageFullBytes(File path)",
    "returnType" : "long",
    "comment" : "\n     * Return the number of available bytes at which the given path is\n     * considered full.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void createUserKey(int userId, int serialNumber, boolean ephemeral)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void destroyUserKey(int userId)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void unlockUserKey(int userId, int serialNumber, byte[] token, byte[] secret)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void lockUserKey(int userId)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void prepareUserStorage(String volumeUuid, int userId, int serialNumber, int flags)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void destroyUserStorage(String volumeUuid, int userId, int flags)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isUserKeyUnlocked(int userId)",
    "returnType" : "boolean",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public boolean isEncrypted(File file)",
    "returnType" : "boolean",
    "comment" : "\n     * Return if data stored at or under the given path will be encrypted while\n     * at rest. This can help apps avoid the overhead of double-encrypting data.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isEncryptable()",
    "returnType" : "boolean",
    "comment" : " {@hide}\n     * Is this device encryptable or already encrypted?\n     * @return true for encryptable or encrypted\n     *         false not encrypted and not encryptable\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isEncrypted()",
    "returnType" : "boolean",
    "comment" : " {@hide}\n     * Is this device already encrypted?\n     * @return true for encrypted. (Implies isEncryptable() == true)\n     *         false not encrypted\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isFileEncryptedNativeOnly()",
    "returnType" : "boolean",
    "comment" : " {@hide}\n     * Is this device file encrypted?\n     * @return true for file encrypted. (Implies isEncrypted() == true)\n     *         false not encrypted or block encrypted\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isBlockEncrypted()",
    "returnType" : "boolean",
    "comment" : " {@hide}\n     * Is this device block encrypted?\n     * @return true for block encrypted. (Implies isEncrypted() == true)\n     *         false not encrypted or file encrypted\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isNonDefaultBlockEncrypted()",
    "returnType" : "boolean",
    "comment" : " {@hide}\n     * Is this device block encrypted with credentials?\n     * @return true for crediential block encrypted.\n     *         (Implies isBlockEncrypted() == true)\n     *         false not encrypted, file encrypted or default block encrypted\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isBlockEncrypting()",
    "returnType" : "boolean",
    "comment" : " {@hide}\n     * Is this device in the process of being block encrypted?\n     * @return true for encrypting.\n     *         false otherwise\n     * Whether device isEncrypted at this point is undefined\n     * Note that only system services and CryptKeeper will ever see this return\n     * true - no app will ever be launched in this state.\n     * Also note that this state will not change without a teardown of the\n     * framework, so no service needs to check for changes during their lifespan\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean inCryptKeeperBounce()",
    "returnType" : "boolean",
    "comment" : " {@hide}\n     * Is this device non default block encrypted and in the process of\n     * prompting for credentials?\n     * @return true for prompting for credentials.\n     *         (Implies isNonDefaultBlockEncrypted() == true)\n     *         false otherwise\n     * Note that only system services and CryptKeeper will ever see this return\n     * true - no app will ever be launched in this state.\n     * Also note that this state will not change without a teardown of the\n     * framework, so no service needs to check for changes during their lifespan\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isFileEncryptedEmulatedOnly()",
    "returnType" : "boolean",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isFileEncryptedNativeOrEmulated()",
    "returnType" : "boolean",
    "comment" : " {@hide}\n     * Is this device running in a file encrypted mode, either native or emulated?\n     * @return true for file encrypted, false otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean hasAdoptable()",
    "returnType" : "boolean",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static boolean hasIsolatedStorage()",
    "returnType" : "boolean",
    "comment" : "\n     * Return if the currently booted device has the \"isolated storage\" feature\n     * flag enabled. This will eventually be fully enabled in the final\n     * {@link android.os.Build.VERSION_CODES#Q} release.\n     *\n     * @hide\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#Q" ]
  }, {
    "name" : "public static File maybeTranslateEmulatedPathToInternal(File path)",
    "returnType" : "File",
    "comment" : "\n     * @deprecated disabled now that FUSE has been replaced by sdcardfs\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public File translateAppToSystem(File file, int pid, int uid)",
    "returnType" : "File",
    "comment" : "\n     * Translate given shared storage path from a path in an app sandbox\n     * namespace to a path in the system namespace.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public File translateSystemToApp(File file, int pid, int uid)",
    "returnType" : "File",
    "comment" : "\n     * Translate given shared storage path from a path in the system namespace\n     * to a path in an app sandbox namespace.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean checkPermissionAndAppOp(Context context, boolean enforce, int pid, int uid, String packageName, @NonNull String featureId, String permission, int op)",
    "returnType" : "boolean",
    "comment" : "\n     * Check that given app holds both permission and appop.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean checkPermissionAndCheckOp(Context context, boolean enforce, int pid, int uid, String packageName, String permission, int op)",
    "returnType" : "boolean",
    "comment" : "\n     * Check that given app holds both permission and appop but do not noteOp.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean checkPermissionAndAppOp(Context context, boolean enforce, int pid, int uid, String packageName, @Nullable String featureId, String permission, int op, boolean note)",
    "returnType" : "boolean",
    "comment" : "\n     * Check that given app holds both permission and appop.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean checkPermissionAndAppOp(boolean enforce, int pid, int uid, String packageName, @Nullable String featureId, String permission, int op)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean noteAppOpAllowingLegacy(boolean enforce, int pid, int uid, String packageName, @Nullable String featureId, int op)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean checkPermissionReadAudio(boolean enforce, int pid, int uid, String packageName, @Nullable String featureId)",
    "returnType" : "boolean",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public boolean checkPermissionWriteAudio(boolean enforce, int pid, int uid, String packageName, @Nullable String featureId)",
    "returnType" : "boolean",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public boolean checkPermissionReadVideo(boolean enforce, int pid, int uid, String packageName, @Nullable String featureId)",
    "returnType" : "boolean",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public boolean checkPermissionWriteVideo(boolean enforce, int pid, int uid, String packageName, @Nullable String featureId)",
    "returnType" : "boolean",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public boolean checkPermissionReadImages(boolean enforce, int pid, int uid, String packageName, @Nullable String featureId)",
    "returnType" : "boolean",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public boolean checkPermissionWriteImages(boolean enforce, int pid, int uid, String packageName, @Nullable String featureId)",
    "returnType" : "boolean",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "private boolean checkExternalStoragePermissionAndAppOp(boolean enforce, int pid, int uid, String packageName, @Nullable String featureId, String permission, int op)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public ParcelFileDescriptor openProxyFileDescriptor(int mode, ProxyFileDescriptorCallback callback, Handler handler, ThreadFactory factory) throws IOException",
    "returnType" : "ParcelFileDescriptor",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public ParcelFileDescriptor openProxyFileDescriptor(int mode, ProxyFileDescriptorCallback callback) throws IOException",
    "returnType" : "ParcelFileDescriptor",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public ParcelFileDescriptor openProxyFileDescriptor(int mode, ProxyFileDescriptorCallback callback, Handler handler) throws IOException",
    "returnType" : "ParcelFileDescriptor",
    "comment" : "\n     * Opens a seekable {@link ParcelFileDescriptor} that proxies all low-level\n     * I/O requests back to the given {@link ProxyFileDescriptorCallback}.\n     * <p>\n     * This can be useful when you want to provide quick access to a large file\n     * that isn't backed by a real file on disk, such as a file on a network\n     * share, cloud storage service, etc. As an example, you could respond to a\n     * {@link ContentResolver#openFileDescriptor(android.net.Uri, String)}\n     * request by returning a {@link ParcelFileDescriptor} created with this\n     * method, and then stream the content on-demand as requested.\n     * <p>\n     * Another useful example might be where you have an encrypted file that\n     * you're willing to decrypt on-demand, but where you want to avoid\n     * persisting the cleartext version.\n     *\n     * @param mode The desired access mode, must be one of\n     *            {@link ParcelFileDescriptor#MODE_READ_ONLY},\n     *            {@link ParcelFileDescriptor#MODE_WRITE_ONLY}, or\n     *            {@link ParcelFileDescriptor#MODE_READ_WRITE}\n     * @param callback Callback to process file operation requests issued on\n     *            returned file descriptor.\n     * @param handler Handler that invokes callback methods.\n     * @return Seekable ParcelFileDescriptor.\n     * @throws IOException\n     ",
    "links" : [ "ParcelFileDescriptor", "ProxyFileDescriptorCallback", "ContentResolver#openFileDescriptor", "ParcelFileDescriptor", "ParcelFileDescriptor#MODE_READ_ONLY", "ParcelFileDescriptor#MODE_WRITE_ONLY", "ParcelFileDescriptor#MODE_READ_WRITE" ]
  }, {
    "name" : "public int getProxyFileDescriptorMountPointId()",
    "returnType" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public long getCacheQuotaBytes(@NonNull UUID storageUuid) throws IOException",
    "returnType" : "long",
    "comment" : "\n     * Return quota size in bytes for all cached data belonging to the calling\n     * app on the given storage volume.\n     * <p>\n     * If your app goes above this quota, your cached files will be some of the\n     * first to be deleted when additional disk space is needed. Conversely, if\n     * your app stays under this quota, your cached files will be some of the\n     * last to be deleted when additional disk space is needed.\n     * <p>\n     * This quota will change over time depending on how frequently the user\n     * interacts with your app, and depending on how much system-wide disk space\n     * is used.\n     * <p class=\"note\">\n     * Note: if your app uses the {@code android:sharedUserId} manifest feature,\n     * then cached data for all packages in your shared UID is tracked together\n     * as a single unit.\n     * </p>\n     *\n     * @param storageUuid the UUID of the storage volume that you're interested\n     *            in. The UUID for a specific path can be obtained using\n     *            {@link #getUuidForPath(File)}.\n     * @throws IOException when the storage device isn't present, or when it\n     *             doesn't support cache quotas.\n     * @see #getCacheSizeBytes(UUID)\n     ",
    "links" : [ "#getUuidForPath" ]
  }, {
    "name" : "public long getCacheSizeBytes(@NonNull UUID storageUuid) throws IOException",
    "returnType" : "long",
    "comment" : "\n     * Return total size in bytes of all cached data belonging to the calling\n     * app on the given storage volume.\n     * <p>\n     * Cached data tracked by this method always includes\n     * {@link Context#getCacheDir()} and {@link Context#getCodeCacheDir()}, and\n     * it also includes {@link Context#getExternalCacheDir()} if the primary\n     * shared/external storage is hosted on the same storage device as your\n     * private data.\n     * <p class=\"note\">\n     * Note: if your app uses the {@code android:sharedUserId} manifest feature,\n     * then cached data for all packages in your shared UID is tracked together\n     * as a single unit.\n     * </p>\n     *\n     * @param storageUuid the UUID of the storage volume that you're interested\n     *            in. The UUID for a specific path can be obtained using\n     *            {@link #getUuidForPath(File)}.\n     * @throws IOException when the storage device isn't present, or when it\n     *             doesn't support cache quotas.\n     * @see #getCacheQuotaBytes(UUID)\n     ",
    "links" : [ "Context#getCacheDir", "Context#getCodeCacheDir", "Context#getExternalCacheDir", "#getUuidForPath" ]
  }, {
    "name" : "public long getAllocatableBytes(@NonNull UUID storageUuid) throws IOException",
    "returnType" : "long",
    "comment" : "\n     * Return the maximum number of new bytes that your app can allocate for\n     * itself on the given storage volume. This value is typically larger than\n     * {@link File#getUsableSpace()}, since the system may be willing to delete\n     * cached files to satisfy an allocation request. You can then allocate\n     * space for yourself using {@link #allocateBytes(UUID, long)} or\n     * {@link #allocateBytes(FileDescriptor, long)}.\n     * <p>\n     * This method is best used as a pre-flight check, such as deciding if there\n     * is enough space to store an entire music album before you allocate space\n     * for each audio file in the album. Attempts to allocate disk space beyond\n     * the returned value will fail.\n     * <p>\n     * If the returned value is not large enough for the data you'd like to\n     * persist, you can launch {@link #ACTION_MANAGE_STORAGE} with the\n     * {@link #EXTRA_UUID} and {@link #EXTRA_REQUESTED_BYTES} options to help\n     * involve the user in freeing up disk space.\n     * <p>\n     * If you're progressively allocating an unbounded amount of storage space\n     * (such as when recording a video) you should avoid calling this method\n     * more than once every 30 seconds.\n     * <p class=\"note\">\n     * Note: if your app uses the {@code android:sharedUserId} manifest feature,\n     * then allocatable space for all packages in your shared UID is tracked\n     * together as a single unit.\n     * </p>\n     *\n     * @param storageUuid the UUID of the storage volume where you're\n     *            considering allocating disk space, since allocatable space can\n     *            vary widely depending on the underlying storage device. The\n     *            UUID for a specific path can be obtained using\n     *            {@link #getUuidForPath(File)}.\n     * @return the maximum number of new bytes that the calling app can allocate\n     *         using {@link #allocateBytes(UUID, long)} or\n     *         {@link #allocateBytes(FileDescriptor, long)}.\n     * @throws IOException when the storage device isn't present, or when it\n     *             doesn't support allocating space.\n     ",
    "links" : [ "File#getUsableSpace", "#allocateBytes", "#allocateBytes", "#ACTION_MANAGE_STORAGE", "#EXTRA_UUID", "#EXTRA_REQUESTED_BYTES", "#getUuidForPath", "#allocateBytes", "#allocateBytes" ]
  }, {
    "name" : "public long getAllocatableBytes(@NonNull UUID storageUuid, @RequiresPermission @AllocateFlags int flags) throws IOException",
    "returnType" : "long",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void allocateBytes(@NonNull UUID storageUuid, @BytesLong long bytes) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Allocate the requested number of bytes for your application to use on the\n     * given storage volume. This will cause the system to delete any cached\n     * files necessary to satisfy your request.\n     * <p>\n     * Attempts to allocate disk space beyond the value returned by\n     * {@link #getAllocatableBytes(UUID)} will fail.\n     * <p>\n     * Since multiple apps can be running simultaneously, this method may be\n     * subject to race conditions. If possible, consider using\n     * {@link #allocateBytes(FileDescriptor, long)} which will guarantee\n     * that bytes are allocated to an opened file.\n     * <p>\n     * If you're progressively allocating an unbounded amount of storage space\n     * (such as when recording a video) you should avoid calling this method\n     * more than once every 60 seconds.\n     *\n     * @param storageUuid the UUID of the storage volume where you'd like to\n     *            allocate disk space. The UUID for a specific path can be\n     *            obtained using {@link #getUuidForPath(File)}.\n     * @param bytes the number of bytes to allocate.\n     * @throws IOException when the storage device isn't present, or when it\n     *             doesn't support allocating space, or if the device had\n     *             trouble allocating the requested space.\n     * @see #getAllocatableBytes(UUID)\n     ",
    "links" : [ "#getAllocatableBytes", "#allocateBytes", "#getUuidForPath" ]
  }, {
    "name" : "public void allocateBytes(@NonNull UUID storageUuid, @BytesLong long bytes, @RequiresPermission @AllocateFlags int flags) throws IOException",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void allocateBytes(FileDescriptor fd, @BytesLong long bytes) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Allocate the requested number of bytes for your application to use in the\n     * given open file. This will cause the system to delete any cached files\n     * necessary to satisfy your request.\n     * <p>\n     * Attempts to allocate disk space beyond the value returned by\n     * {@link #getAllocatableBytes(UUID)} will fail.\n     * <p>\n     * This method guarantees that bytes have been allocated to the opened file,\n     * otherwise it will throw if fast allocation is not possible. Fast\n     * allocation is typically only supported in private app data directories,\n     * and on shared/external storage devices which are emulated.\n     * <p>\n     * If you're progressively allocating an unbounded amount of storage space\n     * (such as when recording a video) you should avoid calling this method\n     * more than once every 60 seconds.\n     *\n     * @param fd the open file that you'd like to allocate disk space for.\n     * @param bytes the number of bytes to allocate. This is the desired final\n     *            size of the open file. If the open file is smaller than this\n     *            requested size, it will be extended without modifying any\n     *            existing contents. If the open file is larger than this\n     *            requested size, it will be truncated.\n     * @throws IOException when the storage device isn't present, or when it\n     *             doesn't support allocating space, or if the device had\n     *             trouble allocating the requested space.\n     * @see #isAllocationSupported(FileDescriptor)\n     * @see Environment#isExternalStorageEmulated(File)\n     ",
    "links" : [ "#getAllocatableBytes" ]
  }, {
    "name" : "public void allocateBytes(FileDescriptor fd, @BytesLong long bytes, @RequiresPermission @AllocateFlags int flags) throws IOException",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private static native boolean setQuotaProjectId(String path, long projectId)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static long getProjectIdForUser(int userId, int projectId)",
    "returnType" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void updateExternalStorageFileQuotaType(@NonNull File path, @QuotaType int quotaType) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Let StorageManager know that the quota type for a file on external storage should\n     * be updated. Android tracks quotas for various media types. Consequently, this should be\n     * called on first creation of a new file on external storage, and whenever the\n     * media type of the file is updated later.\n     *\n     * This API doesn't require any special permissions, though typical implementations\n     * will require being called from an SELinux domain that allows setting file attributes\n     * related to quota (eg the GID or project ID).\n     *\n     * The default platform user of this API is the MediaProvider process, which is\n     * responsible for managing all of external storage.\n     *\n     * @param path the path to the file for which we should update the quota type\n     * @param quotaType the quota type of the file; this is based on the\n     *                  {@code QuotaType} constants, eg\n     *                  {@code StorageManager.QUOTA_TYPE_MEDIA_AUDIO}\n     *\n     * @throws IllegalArgumentException if {@code quotaType} does not correspond to a valid\n     *                                  quota type.\n     * @throws IOException              if the quota type could not be updated.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void fixupAppDir(@NonNull File path)",
    "returnType" : "void",
    "comment" : "\n     * Asks StorageManager to fixup the permissions of an application-private directory.\n     *\n     * On devices without sdcardfs, filesystem permissions aren't magically fixed up. This\n     * is problematic mostly in application-private directories, which are owned by the\n     * application itself; if another process with elevated permissions creates a file\n     * in these directories, the UID will be wrong, and the owning package won't be able\n     * to access the files.\n     *\n     * This API can be used to recursively fix up the permissions on the passed in path.\n     * The default platform user of this API is the DownloadProvider, which can download\n     * things in application-private directories on their behalf.\n     *\n     * This API doesn't require any special permissions, because it merely changes the\n     * permissions of a directory to what they should anyway be.\n     *\n     * @param path the path for which we should fix up the permissions\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void setCacheBehavior(File path, String name, boolean enabled) throws IOException",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "private static boolean isCacheBehavior(File path, String name) throws IOException",
    "returnType" : "boolean",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void setCacheBehaviorGroup(File path, boolean group) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Enable or disable special cache behavior that treats this directory and\n     * its contents as an entire group.\n     * <p>\n     * When enabled and this directory is considered for automatic deletion by\n     * the OS, all contained files will either be deleted together, or not at\n     * all. This is useful when you have a directory that contains several\n     * related metadata files that depend on each other, such as movie file and\n     * a subtitle file.\n     * <p>\n     * When enabled, the <em>newest</em> {@link File#lastModified()} value of\n     * any contained files is considered the modified time of the entire\n     * directory.\n     * <p>\n     * This behavior can only be set on a directory, and it applies recursively\n     * to all contained files and directories.\n     ",
    "links" : [ "File#lastModified" ]
  }, {
    "name" : "public boolean isCacheBehaviorGroup(File path) throws IOException",
    "returnType" : "boolean",
    "comment" : "\n     * Read the current value set by\n     * {@link #setCacheBehaviorGroup(File, boolean)}.\n     ",
    "links" : [ "#setCacheBehaviorGroup" ]
  }, {
    "name" : "public void setCacheBehaviorTombstone(File path, boolean tombstone) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Enable or disable special cache behavior that leaves deleted cache files\n     * intact as tombstones.\n     * <p>\n     * When enabled and a file contained in this directory is automatically\n     * deleted by the OS, the file will be truncated to have a length of 0 bytes\n     * instead of being fully deleted. This is useful if you need to distinguish\n     * between a file that was deleted versus one that never existed.\n     * <p>\n     * This behavior can only be set on a directory, and it applies recursively\n     * to all contained files and directories.\n     * <p class=\"note\">\n     * Note: this behavior is ignored completely if the user explicitly requests\n     * that all cached data be cleared.\n     * </p>\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isCacheBehaviorTombstone(File path) throws IOException",
    "returnType" : "boolean",
    "comment" : "\n     * Read the current value set by\n     * {@link #setCacheBehaviorTombstone(File, boolean)}.\n     ",
    "links" : [ "#setCacheBehaviorTombstone" ]
  }, {
    "name" : "public static UUID convert(String uuid)",
    "returnType" : "UUID",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static String convert(UUID storageUuid)",
    "returnType" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public boolean isCheckpointSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Check whether the device supports filesystem checkpoint.\n     *\n     * @return true if the device supports filesystem checkpoint, false otherwise.\n     ",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "LOCAL_LOGV", "PROP_PRIMARY_PHYSICAL", "PROP_HAS_ADOPTABLE", "PROP_HAS_RESERVED", "PROP_ADOPTABLE", "PROP_EMULATE_FBE", "PROP_SDCARDFS", "PROP_VIRTUAL_DISK", "PROP_ISOLATED_STORAGE", "PROP_ISOLATED_STORAGE_SNAPSHOT", "PROP_FUSE", "PROP_SETTINGS_FUSE", "PROP_FORCED_SCOPED_STORAGE_WHITELIST", "UUID_PRIVATE_INTERNAL", "UUID_PRIMARY_PHYSICAL", "UUID_SYSTEM", "UUID_DEFAULT", "UUID_PRIMARY_PHYSICAL_", "UUID_SYSTEM_", "ACTION_MANAGE_STORAGE", "ACTION_CLEAR_APP_CACHE", "EXTRA_UUID", "EXTRA_REQUESTED_BYTES", "DEBUG_ADOPTABLE_FORCE_ON", "DEBUG_ADOPTABLE_FORCE_OFF", "DEBUG_EMULATE_FBE", "DEBUG_SDCARDFS_FORCE_ON", "DEBUG_SDCARDFS_FORCE_OFF", "DEBUG_VIRTUAL_DISK", "DEBUG_ISOLATED_STORAGE_FORCE_ON", "DEBUG_ISOLATED_STORAGE_FORCE_OFF", "FLAG_STORAGE_DE", "FLAG_STORAGE_CE", "FLAG_STORAGE_EXTERNAL", "FLAG_FOR_WRITE", "FLAG_REAL_STATE", "FLAG_INCLUDE_INVISIBLE", "FLAG_INCLUDE_RECENT", "FSTRIM_FLAG_DEEP", "ENCRYPTION_STATE_NONE", "ENCRYPTION_STATE_OK", "ENCRYPTION_STATE_ERROR_UNKNOWN", "ENCRYPTION_STATE_ERROR_INCOMPLETE", "ENCRYPTION_STATE_ERROR_INCONSISTENT", "ENCRYPTION_STATE_ERROR_CORRUPT", "sStorageManager", "mContext", "mResolver", "mStorageManager", "mAppOps", "mLooper", "mNextNonce", "mDelegates", "mObbActionListener", "DEFAULT_THRESHOLD_PERCENTAGE", "DEFAULT_THRESHOLD_MAX_BYTES", "DEFAULT_CACHE_PERCENTAGE", "DEFAULT_CACHE_MAX_BYTES", "DEFAULT_FULL_THRESHOLD_BYTES", "FLAG_ALLOCATE_AGGRESSIVE", "FLAG_ALLOCATE_DEFY_ALL_RESERVED", "FLAG_ALLOCATE_DEFY_HALF_RESERVED", "FLAG_ALLOCATE_NON_CACHE_ONLY", "FLAG_ALLOCATE_CACHE_ONLY", "XATTR_CACHE_GROUP", "XATTR_CACHE_TOMBSTONE", "PROJECT_ID_EXT_DEFAULT", "PROJECT_ID_EXT_MEDIA_AUDIO", "PROJECT_ID_EXT_MEDIA_VIDEO", "PROJECT_ID_EXT_MEDIA_IMAGE", "QUOTA_TYPE_MEDIA_NONE", "QUOTA_TYPE_MEDIA_IMAGE", "QUOTA_TYPE_MEDIA_AUDIO", "QUOTA_TYPE_MEDIA_VIDEO", "mFuseAppLoopLock", "mFuseAppLoop", "CRYPT_TYPE_PASSWORD", "CRYPT_TYPE_DEFAULT", "CRYPT_TYPE_PATTERN", "CRYPT_TYPE_PIN", "SYSTEM_LOCALE_KEY", "OWNER_INFO_KEY", "PATTERN_VISIBLE_KEY", "PASSWORD_VISIBLE_KEY" ],
  "methodNames" : [ "private int getNextNonce()", "public static StorageManager from(Context context)", "public void registerListener(StorageEventListener listener)", "public void unregisterListener(StorageEventListener listener)", "public void registerStorageVolumeCallback(@CallbackExecutor @NonNull Executor executor, @NonNull StorageVolumeCallback callback)", "public void unregisterStorageVolumeCallback(@NonNull StorageVolumeCallback callback)", "public void enableUsbMassStorage()", "public void disableUsbMassStorage()", "public boolean isUsbMassStorageConnected()", "public boolean isUsbMassStorageEnabled()", "public boolean mountObb(String rawPath, String key, OnObbStateChangeListener listener)", "private ObbInfo getObbInfo(String canonicalPath)", "public boolean unmountObb(String rawPath, boolean force, OnObbStateChangeListener listener)", "public boolean isObbMounted(String rawPath)", "public String getMountedObbPath(String rawPath)", "public List<DiskInfo> getDisks()", "public DiskInfo findDiskById(String id)", "public VolumeInfo findVolumeById(String id)", "public VolumeInfo findVolumeByUuid(String fsUuid)", "public VolumeRecord findRecordByUuid(String fsUuid)", "public VolumeInfo findPrivateForEmulated(VolumeInfo emulatedVol)", "public VolumeInfo findEmulatedForPrivate(VolumeInfo privateVol)", "public VolumeInfo findVolumeByQualifiedUuid(String volumeUuid)", "public UUID getUuidForPath(@NonNull File path) throws IOException", "public File findPathForUuid(String volumeUuid) throws FileNotFoundException", "public boolean isAllocationSupported(@NonNull FileDescriptor fd)", "public List<VolumeInfo> getVolumes()", "public List<VolumeInfo> getWritablePrivateVolumes()", "public List<VolumeRecord> getVolumeRecords()", "public String getBestVolumeDescription(VolumeInfo vol)", "public VolumeInfo getPrimaryPhysicalVolume()", "public void mount(String volId)", "public void unmount(String volId)", "public void format(String volId)", "public long benchmark(String volId)", "public void benchmark(String volId, IVoldTaskListener listener)", "public void partitionPublic(String diskId)", "public void partitionPrivate(String diskId)", "public void partitionMixed(String diskId, int ratio)", "public void wipeAdoptableDisks()", "public void setVolumeNickname(String fsUuid, String nickname)", "public void setVolumeInited(String fsUuid, boolean inited)", "public void setVolumeSnoozed(String fsUuid, boolean snoozed)", "public void forgetVolume(String fsUuid)", "public String getPrimaryStorageUuid()", "public void setPrimaryStorageUuid(String volumeUuid, IPackageMoveObserver callback)", "public StorageVolume getStorageVolume(@NonNull File file)", "public StorageVolume getStorageVolume(@NonNull Uri uri)", "public static StorageVolume getStorageVolume(File file, int userId)", "private static StorageVolume getStorageVolume(StorageVolume[] volumes, File file)", "public String getVolumeState(String mountPoint)", "public List<StorageVolume> getStorageVolumes()", "public List<StorageVolume> getRecentStorageVolumes()", "public StorageVolume getPrimaryStorageVolume()", "public static Pair<String, Long> getPrimaryStoragePathAndSize()", "public long getPrimaryStorageSize()", "public void mkdirs(File file)", "public StorageVolume[] getVolumeList()", "public static StorageVolume[] getVolumeList(int userId, int flags)", "public String[] getVolumePaths()", "public StorageVolume getPrimaryVolume()", "public static StorageVolume getPrimaryVolume(StorageVolume[] volumes)", "public long getStorageBytesUntilLow(File path)", "public long getStorageLowBytes(File path)", "public long getStorageCacheBytes(File path, @AllocateFlags int flags)", "public long getStorageFullBytes(File path)", "public void createUserKey(int userId, int serialNumber, boolean ephemeral)", "public void destroyUserKey(int userId)", "public void unlockUserKey(int userId, int serialNumber, byte[] token, byte[] secret)", "public void lockUserKey(int userId)", "public void prepareUserStorage(String volumeUuid, int userId, int serialNumber, int flags)", "public void destroyUserStorage(String volumeUuid, int userId, int flags)", "public static boolean isUserKeyUnlocked(int userId)", "public boolean isEncrypted(File file)", "public static boolean isEncryptable()", "public static boolean isEncrypted()", "public static boolean isFileEncryptedNativeOnly()", "public static boolean isBlockEncrypted()", "public static boolean isNonDefaultBlockEncrypted()", "public static boolean isBlockEncrypting()", "public static boolean inCryptKeeperBounce()", "public static boolean isFileEncryptedEmulatedOnly()", "public static boolean isFileEncryptedNativeOrEmulated()", "public static boolean hasAdoptable()", "public static boolean hasIsolatedStorage()", "public static File maybeTranslateEmulatedPathToInternal(File path)", "public File translateAppToSystem(File file, int pid, int uid)", "public File translateSystemToApp(File file, int pid, int uid)", "public static boolean checkPermissionAndAppOp(Context context, boolean enforce, int pid, int uid, String packageName, @NonNull String featureId, String permission, int op)", "public static boolean checkPermissionAndCheckOp(Context context, boolean enforce, int pid, int uid, String packageName, String permission, int op)", "private static boolean checkPermissionAndAppOp(Context context, boolean enforce, int pid, int uid, String packageName, @Nullable String featureId, String permission, int op, boolean note)", "private boolean checkPermissionAndAppOp(boolean enforce, int pid, int uid, String packageName, @Nullable String featureId, String permission, int op)", "private boolean noteAppOpAllowingLegacy(boolean enforce, int pid, int uid, String packageName, @Nullable String featureId, int op)", "public boolean checkPermissionReadAudio(boolean enforce, int pid, int uid, String packageName, @Nullable String featureId)", "public boolean checkPermissionWriteAudio(boolean enforce, int pid, int uid, String packageName, @Nullable String featureId)", "public boolean checkPermissionReadVideo(boolean enforce, int pid, int uid, String packageName, @Nullable String featureId)", "public boolean checkPermissionWriteVideo(boolean enforce, int pid, int uid, String packageName, @Nullable String featureId)", "public boolean checkPermissionReadImages(boolean enforce, int pid, int uid, String packageName, @Nullable String featureId)", "public boolean checkPermissionWriteImages(boolean enforce, int pid, int uid, String packageName, @Nullable String featureId)", "private boolean checkExternalStoragePermissionAndAppOp(boolean enforce, int pid, int uid, String packageName, @Nullable String featureId, String permission, int op)", "public ParcelFileDescriptor openProxyFileDescriptor(int mode, ProxyFileDescriptorCallback callback, Handler handler, ThreadFactory factory) throws IOException", "public ParcelFileDescriptor openProxyFileDescriptor(int mode, ProxyFileDescriptorCallback callback) throws IOException", "public ParcelFileDescriptor openProxyFileDescriptor(int mode, ProxyFileDescriptorCallback callback, Handler handler) throws IOException", "public int getProxyFileDescriptorMountPointId()", "public long getCacheQuotaBytes(@NonNull UUID storageUuid) throws IOException", "public long getCacheSizeBytes(@NonNull UUID storageUuid) throws IOException", "public long getAllocatableBytes(@NonNull UUID storageUuid) throws IOException", "public long getAllocatableBytes(@NonNull UUID storageUuid, @RequiresPermission @AllocateFlags int flags) throws IOException", "public void allocateBytes(@NonNull UUID storageUuid, @BytesLong long bytes) throws IOException", "public void allocateBytes(@NonNull UUID storageUuid, @BytesLong long bytes, @RequiresPermission @AllocateFlags int flags) throws IOException", "public void allocateBytes(FileDescriptor fd, @BytesLong long bytes) throws IOException", "public void allocateBytes(FileDescriptor fd, @BytesLong long bytes, @RequiresPermission @AllocateFlags int flags) throws IOException", "private static native boolean setQuotaProjectId(String path, long projectId)", "private static long getProjectIdForUser(int userId, int projectId)", "public void updateExternalStorageFileQuotaType(@NonNull File path, @QuotaType int quotaType) throws IOException", "public void fixupAppDir(@NonNull File path)", "private static void setCacheBehavior(File path, String name, boolean enabled) throws IOException", "private static boolean isCacheBehavior(File path, String name) throws IOException", "public void setCacheBehaviorGroup(File path, boolean group) throws IOException", "public boolean isCacheBehaviorGroup(File path) throws IOException", "public void setCacheBehaviorTombstone(File path, boolean tombstone) throws IOException", "public boolean isCacheBehaviorTombstone(File path) throws IOException", "public static UUID convert(String uuid)", "public static String convert(UUID storageUuid)", "public boolean isCheckpointSupported()" ]
}