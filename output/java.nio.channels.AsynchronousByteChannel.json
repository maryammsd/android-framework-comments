{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/nio/channels/AsynchronousByteChannel.java",
  "packageName" : "java.nio.channels",
  "className" : "AsynchronousByteChannel",
  "comment" : "",
  "links" : [ ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " void read(ByteBuffer dst, A attachment, CompletionHandler<Integer, ? super A> handler)",
    "returnType" : "void",
    "comment" : "\n     * Reads a sequence of bytes from this channel into the given buffer.\n     *\n     * <p> This method initiates an asynchronous read operation to read a\n     * sequence of bytes from this channel into the given buffer. The {@code\n     * handler} parameter is a completion handler that is invoked when the read\n     * operation completes (or fails). The result passed to the completion\n     * handler is the number of bytes read or {@code -1} if no bytes could be\n     * read because the channel has reached end-of-stream.\n     *\n     * <p> The read operation may read up to <i>r</i> bytes from the channel,\n     * where <i>r</i> is the number of bytes remaining in the buffer, that is,\n     * {@code dst.remaining()} at the time that the read is attempted. Where\n     * <i>r</i> is 0, the read operation completes immediately with a result of\n     * {@code 0} without initiating an I/O operation.\n     *\n     * <p> Suppose that a byte sequence of length <i>n</i> is read, where\n     * {@code 0}&nbsp;{@code <}&nbsp;<i>n</i>&nbsp;{@code <=}&nbsp;<i>r</i>.\n     * This byte sequence will be transferred into the buffer so that the first\n     * byte in the sequence is at index <i>p</i> and the last byte is at index\n     * <i>p</i>&nbsp;{@code +}&nbsp;<i>n</i>&nbsp;{@code -}&nbsp;{@code 1},\n     * where <i>p</i> is the buffer's position at the moment the read is\n     * performed. Upon completion the buffer's position will be equal to\n     * <i>p</i>&nbsp;{@code +}&nbsp;<i>n</i>; its limit will not have changed.\n     *\n     * <p> Buffers are not safe for use by multiple concurrent threads so care\n     * should be taken to not access the buffer until the operation has\n     * completed.\n     *\n     * <p> This method may be invoked at any time. Some channel types may not\n     * allow more than one read to be outstanding at any given time. If a thread\n     * initiates a read operation before a previous read operation has\n     * completed then a {@link ReadPendingException} will be thrown.\n     *\n     * @param   <A>\n     *          The type of the attachment\n     * @param   dst\n     *          The buffer into which bytes are to be transferred\n     * @param   attachment\n     *          The object to attach to the I/O operation; can be {@code null}\n     * @param   handler\n     *          The completion handler\n     *\n     * @throws  IllegalArgumentException\n     *          If the buffer is read-only\n     * @throws  ReadPendingException\n     *          If the channel does not allow more than one read to be outstanding\n     *          and a previous read has not completed\n     * @throws  ShutdownChannelGroupException\n     *          If the channel is associated with a {@link AsynchronousChannelGroup\n     *          group} that has terminated\n     ",
    "links" : [ "AsynchronousChannelGroupgroup", "java.nio.channels.ReadPendingException" ]
  }, {
    "name" : " Future<Integer> read(ByteBuffer dst)",
    "returnType" : "Future<Integer>",
    "comment" : "\n     * Reads a sequence of bytes from this channel into the given buffer.\n     *\n     * <p> This method initiates an asynchronous read operation to read a\n     * sequence of bytes from this channel into the given buffer. The method\n     * behaves in exactly the same manner as the {@link\n     * #read(ByteBuffer,Object,CompletionHandler)\n     * read(ByteBuffer,Object,CompletionHandler)} method except that instead\n     * of specifying a completion handler, this method returns a {@code Future}\n     * representing the pending result. The {@code Future}'s {@link Future#get()\n     * get} method returns the number of bytes read or {@code -1} if no bytes\n     * could be read because the channel has reached end-of-stream.\n     *\n     * @param   dst\n     *          The buffer into which bytes are to be transferred\n     *\n     * @return  A Future representing the result of the operation\n     *\n     * @throws  IllegalArgumentException\n     *          If the buffer is read-only\n     * @throws  ReadPendingException\n     *          If the channel does not allow more than one read to be outstanding\n     *          and a previous read has not completed\n     ",
    "links" : [ "#read(ByteBuffer", "java.util.concurrent.Future#get()" ]
  }, {
    "name" : " void write(ByteBuffer src, A attachment, CompletionHandler<Integer, ? super A> handler)",
    "returnType" : "void",
    "comment" : "\n     * Writes a sequence of bytes to this channel from the given buffer.\n     *\n     * <p> This method initiates an asynchronous write operation to write a\n     * sequence of bytes to this channel from the given buffer. The {@code\n     * handler} parameter is a completion handler that is invoked when the write\n     * operation completes (or fails). The result passed to the completion\n     * handler is the number of bytes written.\n     *\n     * <p> The write operation may write up to <i>r</i> bytes to the channel,\n     * where <i>r</i> is the number of bytes remaining in the buffer, that is,\n     * {@code src.remaining()} at the time that the write is attempted. Where\n     * <i>r</i> is 0, the write operation completes immediately with a result of\n     * {@code 0} without initiating an I/O operation.\n     *\n     * <p> Suppose that a byte sequence of length <i>n</i> is written, where\n     * {@code 0}&nbsp;{@code <}&nbsp;<i>n</i>&nbsp;{@code <=}&nbsp;<i>r</i>.\n     * This byte sequence will be transferred from the buffer starting at index\n     * <i>p</i>, where <i>p</i> is the buffer's position at the moment the\n     * write is performed; the index of the last byte written will be\n     * <i>p</i>&nbsp;{@code +}&nbsp;<i>n</i>&nbsp;{@code -}&nbsp;{@code 1}.\n     * Upon completion the buffer's position will be equal to\n     * <i>p</i>&nbsp;{@code +}&nbsp;<i>n</i>; its limit will not have changed.\n     *\n     * <p> Buffers are not safe for use by multiple concurrent threads so care\n     * should be taken to not access the buffer until the operation has\n     * completed.\n     *\n     * <p> This method may be invoked at any time. Some channel types may not\n     * allow more than one write to be outstanding at any given time. If a thread\n     * initiates a write operation before a previous write operation has\n     * completed then a {@link WritePendingException} will be thrown.\n     *\n     * @param   <A>\n     *          The type of the attachment\n     * @param   src\n     *          The buffer from which bytes are to be retrieved\n     * @param   attachment\n     *          The object to attach to the I/O operation; can be {@code null}\n     * @param   handler\n     *          The completion handler object\n     *\n     * @throws  WritePendingException\n     *          If the channel does not allow more than one write to be outstanding\n     *          and a previous write has not completed\n     * @throws  ShutdownChannelGroupException\n     *          If the channel is associated with a {@link AsynchronousChannelGroup\n     *          group} that has terminated\n     ",
    "links" : [ "AsynchronousChannelGroupgroup", "java.nio.channels.WritePendingException" ]
  }, {
    "name" : " Future<Integer> write(ByteBuffer src)",
    "returnType" : "Future<Integer>",
    "comment" : "\n     * Writes a sequence of bytes to this channel from the given buffer.\n     *\n     * <p> This method initiates an asynchronous write operation to write a\n     * sequence of bytes to this channel from the given buffer. The method\n     * behaves in exactly the same manner as the {@link\n     * #write(ByteBuffer,Object,CompletionHandler)\n     * write(ByteBuffer,Object,CompletionHandler)} method except that instead\n     * of specifying a completion handler, this method returns a {@code Future}\n     * representing the pending result. The {@code Future}'s {@link Future#get()\n     * get} method returns the number of bytes written.\n     *\n     * @param   src\n     *          The buffer from which bytes are to be retrieved\n     *\n     * @return A Future representing the result of the operation\n     *\n     * @throws  WritePendingException\n     *          If the channel does not allow more than one write to be outstanding\n     *          and a previous write has not completed\n     ",
    "links" : [ "java.util.concurrent.Future#get()", "#write(ByteBuffer" ]
  } ],
  "methodNames" : [ " void read(ByteBuffer dst, A attachment, CompletionHandler<Integer, ? super A> handler)", " Future<Integer> read(ByteBuffer dst)", " void write(ByteBuffer src, A attachment, CompletionHandler<Integer, ? super A> handler)", " Future<Integer> write(ByteBuffer src)" ],
  "variableNames" : [ ]
}