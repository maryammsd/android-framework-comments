{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/hardware/input/InputManager.java",
  "packageName" : "android.hardware.input",
  "className" : "InputManager",
  "comment" : "\n * Provides information about input devices and available key layouts.\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG",
    "type" : "boolean",
    "comment" : " To enable these logs, run: 'adb shell setprop log.tag.InputManager DEBUG' (requires restart)",
    "links" : [ ]
  }, {
    "name" : "mIm",
    "type" : "IInputManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsStylusPointerIconEnabled",
    "type" : "Boolean",
    "comment" : "\n     * Whether a PointerIcon is shown for stylus pointers.\n     * Obtain using {@link #isStylusPointerIconEnabled()}.\n     ",
    "links" : [ "#isStylusPointerIconEnabled()" ]
  }, {
    "name" : "ACTION_QUERY_KEYBOARD_LAYOUTS",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Query available keyboard layouts.\n     * <p>\n     * The input manager service locates available keyboard layouts\n     * by querying broadcast receivers that are registered for this action.\n     * An application can offer additional keyboard layouts to the user\n     * by declaring a suitable broadcast receiver in its manifest.\n     * </p><p>\n     * Here is an example broadcast receiver declaration that an application\n     * might include in its AndroidManifest.xml to advertise keyboard layouts.\n     * The meta-data specifies a resource that contains a description of each keyboard\n     * layout that is provided by the application.\n     * <pre><code>\n     * &lt;receiver android:name=\".InputDeviceReceiver\"\n     *         android:label=\"@string/keyboard_layouts_label\">\n     *     &lt;intent-filter>\n     *         &lt;action android:name=\"android.hardware.input.action.QUERY_KEYBOARD_LAYOUTS\" />\n     *     &lt;/intent-filter>\n     *     &lt;meta-data android:name=\"android.hardware.input.metadata.KEYBOARD_LAYOUTS\"\n     *             android:resource=\"@xml/keyboard_layouts\" />\n     * &lt;/receiver>\n     * </code></pre>\n     * </p><p>\n     * In the above example, the <code>@xml/keyboard_layouts</code> resource refers to\n     * an XML resource whose root element is <code>&lt;keyboard-layouts></code> that\n     * contains zero or more <code>&lt;keyboard-layout></code> elements.\n     * Each <code>&lt;keyboard-layout></code> element specifies the name, label, and location\n     * of a key character map for a particular keyboard layout.  The label on the receiver\n     * is used to name the collection of keyboard layouts provided by this receiver in the\n     * keyboard layout settings.\n     * <pre><code>\n     * &lt;?xml version=\"1.0\" encoding=\"utf-8\"?>\n     * &lt;keyboard-layouts xmlns:android=\"http://schemas.android.com/apk/res/android\">\n     *     &lt;keyboard-layout android:name=\"keyboard_layout_english_us\"\n     *             android:label=\"@string/keyboard_layout_english_us_label\"\n     *             android:keyboardLayout=\"@raw/keyboard_layout_english_us\" />\n     * &lt;/keyboard-layouts>\n     * </pre></code>\n     * </p><p>\n     * The <code>android:name</code> attribute specifies an identifier by which\n     * the keyboard layout will be known in the package.\n     * The <code>android:label</code> attribute specifies a human-readable descriptive\n     * label to describe the keyboard layout in the user interface, such as \"English (US)\".\n     * The <code>android:keyboardLayout</code> attribute refers to a\n     * <a href=\"https://source.android.com/docs/core/interaction/input/key-character-map-files\">\n     * key character map</a> resource that defines the keyboard layout.\n     * The <code>android:keyboardLocale</code> attribute specifies a comma separated list of BCP 47\n     * language tags depicting the locales supported by the keyboard layout. This attribute is\n     * optional and will be used for auto layout selection for external physical keyboards.\n     * The <code>android:keyboardLayoutType</code> attribute specifies the layoutType for the\n     * keyboard layout. This can be either empty or one of the following supported layout types:\n     * qwerty, qwertz, azerty, dvorak, colemak, workman, extended, turkish_q, turkish_f. This\n     * attribute is optional and will be used for auto layout selection for external physical\n     * keyboards.\n     * </p>\n     ",
    "links" : [ ]
  }, {
    "name" : "META_DATA_KEYBOARD_LAYOUTS",
    "type" : "String",
    "comment" : "\n     * Metadata Key: Keyboard layout metadata associated with\n     * {@link #ACTION_QUERY_KEYBOARD_LAYOUTS}.\n     * <p>\n     * Specifies the resource id of a XML resource that describes the keyboard\n     * layouts that are provided by the application.\n     * </p>\n     ",
    "links" : [ "#ACTION_QUERY_KEYBOARD_LAYOUTS" ]
  }, {
    "name" : "BLOCK_UNTRUSTED_TOUCHES",
    "type" : "long",
    "comment" : "\n     * Prevent touches from being consumed by apps if these touches passed through a non-trusted\n     * window from a different UID and are considered unsafe.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INJECT_INPUT_EVENT_MODE_ASYNC",
    "type" : "int",
    "comment" : "\n     * Input Event Injection Synchronization Mode: None.\n     * Never blocks.  Injection is asynchronous and is assumed always to be successful.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INJECT_INPUT_EVENT_MODE_WAIT_FOR_RESULT",
    "type" : "int",
    "comment" : "\n     * Input Event Injection Synchronization Mode: Wait for result.\n     * Waits for previous events to be dispatched so that the input dispatcher can\n     * determine whether input event injection will be permitted based on the current\n     * input focus.  Does not wait for the input event to finish being handled\n     * by the application.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH",
    "type" : "int",
    "comment" : "\n     * Input Event Injection Synchronization Mode: Wait for finish.\n     * Waits for the event to be delivered to the application and handled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SWITCH_STATE_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Switch State: Unknown.\n     *\n     * The system has yet to report a valid value for the switch.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SWITCH_STATE_OFF",
    "type" : "int",
    "comment" : "\n     * Switch State: Off.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SWITCH_STATE_ON",
    "type" : "int",
    "comment" : "\n     * Switch State: On.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "mGlobal",
    "type" : "InputManagerGlobal",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static InputManager getInstance()",
    "returnType" : "InputManager",
    "comment" : "\n     * Gets an instance of the input manager.\n     *\n     *  Warning: The usage of this method is not supported!\n     *\n     *  @return The input manager instance.\n     *  Use {@link Context#getSystemService(Class)}\n     *  to obtain the InputManager instance.\n     *\n     * TODO (b/277717573): Soft remove this API in version V.\n     * TODO (b/277039664): Migrate app usage off this API.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Context#getSystemService(Class)" ]
  }, {
    "name" : "public String getVelocityTrackerStrategy()",
    "returnType" : "String",
    "comment" : "\n     * Get the current VelocityTracker strategy.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public InputDevice getInputDevice(int id)",
    "returnType" : "InputDevice",
    "comment" : "\n     * Gets information about the input device with the specified id.\n     * @param id The device id.\n     * @return The input device or null if not found.\n     ",
    "links" : [ ]
  }, {
    "name" : "public InputDevice.ViewBehavior getInputDeviceViewBehavior(int deviceId)",
    "returnType" : "InputDevice.ViewBehavior",
    "comment" : "\n     * Gets the {@link InputDevice.ViewBehavior} of the input device with a given {@code id}.\n     *\n     * <p>Use this API to query a fresh view behavior instance whenever the input device\n     * changes.\n     *\n     * @param deviceId the id of the input device whose view behavior is being requested.\n     * @return the view behavior of the input device with the provided id, or {@code null} if there\n     *      is not input device with the provided id.\n     ",
    "links" : [ "InputDevice.ViewBehavior" ]
  }, {
    "name" : "public InputDevice getInputDeviceByDescriptor(String descriptor)",
    "returnType" : "InputDevice",
    "comment" : "\n     * Gets information about the input device with the specified descriptor.\n     * @param descriptor The input device descriptor.\n     * @return The input device or null if not found.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int[] getInputDeviceIds()",
    "returnType" : "int[]",
    "comment" : "\n     * Gets the ids of all input devices in the system.\n     * @return The input device ids.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isInputDeviceEnabled(int id)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if an input device is enabled. Should return true for most\n     * situations. Some system apps may disable an input device, for\n     * example to prevent unwanted touch events.\n     *\n     * @param id The input device Id.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void enableInputDevice(int id)",
    "returnType" : "void",
    "comment" : "\n     * Enables an InputDevice.\n     * <p>\n     * Requires {@link android.Manifest.permission#DISABLE_INPUT_DEVICE}.\n     * </p>\n     *\n     * @param id The input device Id.\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#DISABLE_INPUT_DEVICE" ]
  }, {
    "name" : "public void disableInputDevice(int id)",
    "returnType" : "void",
    "comment" : "\n     * Disables an InputDevice.\n     * <p>\n     * Requires {@link android.Manifest.permission#DISABLE_INPUT_DEVICE}.\n     * </p>\n     *\n     * @param id The input device Id.\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#DISABLE_INPUT_DEVICE" ]
  }, {
    "name" : "public void registerInputDeviceListener(InputDeviceListener listener, Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Registers an input device listener to receive notifications about when\n     * input devices are added, removed or changed.\n     *\n     * @param listener The listener to register.\n     * @param handler The handler on which the listener should be invoked, or null\n     * if the listener should be invoked on the calling thread's looper.\n     *\n     * @see #unregisterInputDeviceListener\n     ",
    "links" : [ ]
  }, {
    "name" : "public void unregisterInputDeviceListener(InputDeviceListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters an input device listener.\n     *\n     * @param listener The listener to unregister.\n     *\n     * @see #registerInputDeviceListener\n     ",
    "links" : [ ]
  }, {
    "name" : "public int isInTabletMode()",
    "returnType" : "int",
    "comment" : "\n     * Queries whether the device is in tablet mode.\n     *\n     * @return The tablet switch state which is one of {@link #SWITCH_STATE_UNKNOWN},\n     * {@link #SWITCH_STATE_OFF} or {@link #SWITCH_STATE_ON}.\n     * @hide\n     ",
    "links" : [ "#SWITCH_STATE_OFF", "#SWITCH_STATE_UNKNOWN", "#SWITCH_STATE_ON" ]
  }, {
    "name" : "public void registerOnTabletModeChangedListener(OnTabletModeChangedListener listener, Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Register a tablet mode changed listener.\n     *\n     * @param listener The listener to register.\n     * @param handler The handler on which the listener should be invoked, or null\n     * if the listener should be invoked on the calling thread's looper.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void unregisterOnTabletModeChangedListener(OnTabletModeChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Unregister a tablet mode changed listener.\n     *\n     * @param listener The listener to unregister.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int isMicMuted()",
    "returnType" : "int",
    "comment" : "\n     * Queries whether the device's microphone is muted\n     *\n     * @return The mic mute switch state which is one of {@link #SWITCH_STATE_UNKNOWN},\n     * {@link #SWITCH_STATE_OFF} or {@link #SWITCH_STATE_ON}.\n     * @hide\n     ",
    "links" : [ "#SWITCH_STATE_OFF", "#SWITCH_STATE_UNKNOWN", "#SWITCH_STATE_ON" ]
  }, {
    "name" : "public KeyboardLayout[] getKeyboardLayouts()",
    "returnType" : "KeyboardLayout[]",
    "comment" : "\n     * Gets information about all supported keyboard layouts.\n     * <p>\n     * The input manager consults the built-in keyboard layouts as well\n     * as all keyboard layouts advertised by applications using a\n     * {@link #ACTION_QUERY_KEYBOARD_LAYOUTS} broadcast receiver.\n     * </p>\n     *\n     * @return A list of all supported keyboard layouts.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_QUERY_KEYBOARD_LAYOUTS" ]
  }, {
    "name" : "public List<String> getKeyboardLayoutDescriptors()",
    "returnType" : "List<String>",
    "comment" : "\n     * Returns the descriptors of all supported keyboard layouts.\n     * <p>\n     * The input manager consults the built-in keyboard layouts as well as all keyboard layouts\n     * advertised by applications using a {@link #ACTION_QUERY_KEYBOARD_LAYOUTS} broadcast receiver.\n     * </p>\n     *\n     * @return The ids of all keyboard layouts which are supported by the specified input device.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_QUERY_KEYBOARD_LAYOUTS" ]
  }, {
    "name" : "public String getKeyboardLayoutTypeForLayoutDescriptor(@NonNull String layoutDescriptor)",
    "returnType" : "String",
    "comment" : "\n     * Returns the layout type of the queried layout\n     * <p>\n     * The input manager consults the built-in keyboard layouts as well as all keyboard layouts\n     * advertised by applications using a {@link #ACTION_QUERY_KEYBOARD_LAYOUTS} broadcast receiver.\n     * </p>\n     *\n     * @param layoutDescriptor The layout descriptor of the queried layout\n     * @return layout type of the queried layout\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_QUERY_KEYBOARD_LAYOUTS" ]
  }, {
    "name" : "public KeyboardLayout[] getKeyboardLayoutsForInputDevice(@NonNull InputDeviceIdentifier identifier)",
    "returnType" : "KeyboardLayout[]",
    "comment" : "\n     * TODO(b/330517633): Cleanup the unsupported API\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public KeyboardLayout getKeyboardLayout(String keyboardLayoutDescriptor)",
    "returnType" : "KeyboardLayout",
    "comment" : "\n     * Gets the keyboard layout with the specified descriptor.\n     *\n     * @param keyboardLayoutDescriptor The keyboard layout descriptor, as returned by\n     * {@link KeyboardLayout#getDescriptor()}.\n     * @return The keyboard layout, or null if it could not be loaded.\n     *\n     * @hide\n     ",
    "links" : [ "android.hardware.input.KeyboardLayout#getDescriptor()" ]
  }, {
    "name" : "public String getCurrentKeyboardLayoutForInputDevice(@NonNull InputDeviceIdentifier identifier)",
    "returnType" : "String",
    "comment" : "\n     * TODO(b/330517633): Cleanup the unsupported API\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCurrentKeyboardLayoutForInputDevice(@NonNull InputDeviceIdentifier identifier, @NonNull String keyboardLayoutDescriptor)",
    "returnType" : "void",
    "comment" : "\n     * TODO(b/330517633): Cleanup the unsupported API\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String[] getEnabledKeyboardLayoutsForInputDevice(InputDeviceIdentifier identifier)",
    "returnType" : "String[]",
    "comment" : "\n     * TODO(b/330517633): Cleanup the unsupported API\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addKeyboardLayoutForInputDevice(InputDeviceIdentifier identifier, String keyboardLayoutDescriptor)",
    "returnType" : "void",
    "comment" : "\n     * TODO(b/330517633): Cleanup the unsupported API\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeKeyboardLayoutForInputDevice(@NonNull InputDeviceIdentifier identifier, @NonNull String keyboardLayoutDescriptor)",
    "returnType" : "void",
    "comment" : "\n     * TODO(b/330517633): Cleanup the unsupported API\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void remapModifierKey(@RemappableModifierKey int fromKey, @RemappableModifierKey int toKey)",
    "returnType" : "void",
    "comment" : "\n     * Remaps modifier keys. Remapping a modifier key to itself will clear any previous remappings\n     * for that key.\n     *\n     * @param fromKey The modifier key getting remapped.\n     * @param toKey The modifier key that it is remapped to.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void clearAllModifierKeyRemappings()",
    "returnType" : "void",
    "comment" : "\n     * Clears all existing modifier key remappings\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Map<Integer, Integer> getModifierKeyRemapping()",
    "returnType" : "Map<Integer, Integer>",
    "comment" : "\n     * Provides the current modifier key remapping\n     *\n     * @return a {fromKey, toKey} map that contains the existing modifier key remappings..\n     * {@link RemappableModifierKey}\n     *\n     * @hide\n     ",
    "links" : [ "RemappableModifierKey" ]
  }, {
    "name" : "public TouchCalibration getTouchCalibration(String inputDeviceDescriptor, int surfaceRotation)",
    "returnType" : "TouchCalibration",
    "comment" : "\n     * Gets the TouchCalibration applied to the specified input device's coordinates.\n     *\n     * @param inputDeviceDescriptor The input device descriptor.\n     * @return The TouchCalibration currently assigned for use with the given\n     * input device. If none is set, an identity TouchCalibration is returned.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTouchCalibration(String inputDeviceDescriptor, int surfaceRotation, TouchCalibration calibration)",
    "returnType" : "void",
    "comment" : "\n     * Sets the TouchCalibration to apply to the specified input device's coordinates.\n     * <p>\n     * This method may have the side-effect of causing the input device in question\n     * to be reconfigured. Requires {@link android.Manifest.permission#SET_INPUT_CALIBRATION}.\n     * </p>\n     *\n     * @param inputDeviceDescriptor The input device descriptor.\n     * @param calibration The calibration to be applied\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#SET_INPUT_CALIBRATION" ]
  }, {
    "name" : "public KeyboardLayoutSelectionResult getKeyboardLayoutForInputDevice(@NonNull InputDeviceIdentifier identifier, @UserIdInt int userId, @NonNull InputMethodInfo imeInfo, @Nullable InputMethodSubtype imeSubtype)",
    "returnType" : "KeyboardLayoutSelectionResult",
    "comment" : "\n     * Gets the keyboard layout descriptor for the specified input device, userId, imeInfo and\n     * imeSubtype.\n     *\n     * @param identifier Identifier for the input device\n     * @param userId user profile ID\n     * @param imeInfo contains IME information like imeId, etc.\n     * @param imeSubtype contains IME subtype information like input languageTag, layoutType, etc.\n     * @return The keyboard layout descriptor, or null if no keyboard layout has been set.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setKeyboardLayoutForInputDevice(@NonNull InputDeviceIdentifier identifier, @UserIdInt int userId, @NonNull InputMethodInfo imeInfo, @Nullable InputMethodSubtype imeSubtype, @NonNull String keyboardLayoutDescriptor)",
    "returnType" : "void",
    "comment" : "\n     * Sets the keyboard layout descriptor for the specified input device, userId, imeInfo and\n     * imeSubtype.\n     *\n     * <p>\n     * This method may have the side-effect of causing the input device in question to be\n     * reconfigured.\n     * </p>\n     *\n     * @param identifier The identifier for the input device.\n     * @param userId user profile ID\n     * @param imeInfo contains IME information like imeId, etc.\n     * @param imeSubtype contains IME subtype information like input languageTag, layoutType, etc.\n     * @param keyboardLayoutDescriptor The keyboard layout descriptor to use, must not be null.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public KeyboardLayout[] getKeyboardLayoutListForInputDevice(InputDeviceIdentifier identifier, @UserIdInt int userId, @NonNull InputMethodInfo imeInfo, @Nullable InputMethodSubtype imeSubtype)",
    "returnType" : "KeyboardLayout[]",
    "comment" : "\n     * Gets all keyboard layouts that are enabled for the specified input device, userId, imeInfo\n     * and imeSubtype.\n     *\n     * @param identifier The identifier for the input device.\n     * @param userId user profile ID\n     * @param imeInfo contains IME information like imeId, etc.\n     * @param imeSubtype contains IME subtype information like input languageTag, layoutType, etc.\n     * @return The keyboard layout descriptors.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getMousePointerSpeed()",
    "returnType" : "int",
    "comment" : "\n     * Returns the mouse pointer speed.\n     *\n     * <p>The pointer speed is a value between {@link InputSettings#MIN_POINTER_SPEED} and\n     * {@link InputSettings#MAX_POINTER_SPEED}, the default value being\n     * {@link InputSettings#DEFAULT_POINTER_SPEED}.\n     *\n     * <p> Note that while setting the mouse pointer speed, it's possible that the input reader has\n     * only received this value and has not yet completed reconfiguring itself with this value.\n     *\n     * @hide\n     ",
    "links" : [ "android.hardware.input.InputSettings#MIN_POINTER_SPEED", "android.hardware.input.InputSettings#MAX_POINTER_SPEED", "android.hardware.input.InputSettings#DEFAULT_POINTER_SPEED" ]
  }, {
    "name" : "public void tryPointerSpeed(int speed)",
    "returnType" : "void",
    "comment" : "\n     * Changes the mouse pointer speed temporarily, but does not save the setting.\n     * <p>\n     * Requires {@link android.Manifest.permission#SET_POINTER_SPEED}.\n     * </p>\n     *\n     * @param speed The pointer speed as a value between {@link InputSettings#MIN_POINTER_SPEED} and\n     * {@link InputSettings#MAX_POINTER_SPEED}, or the default value {@link InputSettings#DEFAULT_POINTER_SPEED}.\n     *\n     * @hide\n     ",
    "links" : [ "android.hardware.input.InputSettings#MIN_POINTER_SPEED", "android.Manifest.permission#SET_POINTER_SPEED", "android.hardware.input.InputSettings#MAX_POINTER_SPEED", "android.hardware.input.InputSettings#DEFAULT_POINTER_SPEED" ]
  }, {
    "name" : "public float getMaximumObscuringOpacityForTouch()",
    "returnType" : "float",
    "comment" : "\n     * Returns the maximum allowed obscuring opacity per UID to propagate touches.\n     *\n     * <p>For certain window types (eg. {@link LayoutParams#TYPE_APPLICATION_OVERLAY}), the decision\n     * of honoring {@link LayoutParams#FLAG_NOT_TOUCHABLE} or not depends on the combined obscuring\n     * opacity of the windows above the touch-consuming window, per UID. Check documentation of\n     * {@link LayoutParams#FLAG_NOT_TOUCHABLE} for more details.\n     *\n     * <p>The value returned is between 0 (inclusive) and 1 (inclusive).\n     *\n     * @see LayoutParams#FLAG_NOT_TOUCHABLE\n     ",
    "links" : [ "android.view.WindowManager.LayoutParams#TYPE_APPLICATION_OVERLAY", "android.view.WindowManager.LayoutParams#FLAG_NOT_TOUCHABLE" ]
  }, {
    "name" : "public boolean[] deviceHasKeys(int[] keyCodes)",
    "returnType" : "boolean[]",
    "comment" : "\n     * Queries the framework about whether any physical keys exist on any currently attached input\n     * devices that are capable of producing the given array of key codes.\n     *\n     * @param keyCodes The array of key codes to query.\n     * @return A new array of the same size as the key codes array whose elements\n     * are set to true if at least one attached keyboard supports the corresponding key code\n     * at the same index in the key codes array.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean[] deviceHasKeys(int id, int[] keyCodes)",
    "returnType" : "boolean[]",
    "comment" : "\n     * Queries the framework about whether any physical keys exist on the specified input device\n     * that are capable of producing the given array of key codes.\n     *\n     * @param id The id of the input device to query or -1 to consult all devices.\n     * @param keyCodes The array of key codes to query.\n     * @return A new array of the same size as the key codes array whose elements are set to true\n     * if the given device could produce the corresponding key code at the same index in the key\n     * codes array.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getKeyCodeForKeyLocation(int deviceId, int locationKeyCode)",
    "returnType" : "int",
    "comment" : "\n     * Gets the {@link android.view.KeyEvent key code} produced by the given location on a reference\n     * QWERTY keyboard layout.\n     * <p>\n     * This API is useful for querying the physical location of keys that change the character\n     * produced based on the current locale and keyboard layout.\n     * <p>\n     * @see InputDevice#getKeyCodeForKeyLocation(int) for examples.\n     *\n     * @param locationKeyCode The location of a key specified as a key code on the QWERTY layout.\n     * This provides a consistent way of referring to the physical location of a key independently\n     * of the current keyboard layout. Also see the\n     * <a href=\"https://www.w3.org/TR/2017/CR-uievents-code-20170601/#key-alphanumeric-writing-system\">\n     * hypothetical keyboard</a> provided by the W3C, which may be helpful for identifying the\n     * physical location of a key.\n     * @return The key code produced by the key at the specified location, given the current\n     * keyboard layout. Returns {@link KeyEvent#KEYCODE_UNKNOWN} if the device does not specify\n     * {@link InputDevice#SOURCE_KEYBOARD} or the requested mapping cannot be determined.\n     *\n     * @hide\n     ",
    "links" : [ "android.view.KeyEvent", "android.view.KeyEvent#KEYCODE_UNKNOWN", "android.view.InputDevice#SOURCE_KEYBOARD" ]
  }, {
    "name" : "public Drawable getKeyboardLayoutPreview(@Nullable KeyboardLayout keyboardLayout, int width, int height)",
    "returnType" : "Drawable",
    "comment" : "\n     * Provides a Keyboard layout preview of a particular dimension.\n     *\n     * @param keyboardLayout Layout whose preview is requested. If null, will return preview of\n     *                       the default Keyboard layout defined by {@code Generic.kl}.\n     * @param width Expected width of the drawable\n     * @param height Expected height of the drawable\n     *\n     * NOTE: Width and height will auto-adjust to the width and height of the ImageView that\n     * shows the drawable but this allows the caller to provide an intrinsic width and height of\n     * the drawable allowing the ImageView to properly wrap the drawable content.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean injectInputEvent(InputEvent event, int mode, int targetUid)",
    "returnType" : "boolean",
    "comment" : "\n     * Injects an input event into the event system, targeting windows owned by the provided uid.\n     *\n     * If a valid targetUid is provided, the system will only consider injecting the input event\n     * into windows owned by the provided uid. If the input event is targeted at a window that is\n     * not owned by the provided uid, input injection will fail and a RemoteException will be\n     * thrown.\n     *\n     * The synchronization mode determines whether the method blocks while waiting for\n     * input injection to proceed.\n     * <p>\n     * Requires the {@link android.Manifest.permission#INJECT_EVENTS} permission.\n     * </p><p>\n     * Make sure you correctly set the event time and input source of the event\n     * before calling this method.\n     * </p>\n     *\n     * @param event The event to inject.\n     * @param mode The synchronization mode.  One of:\n     * {@link android.os.InputEventInjectionSync#NONE},\n     * {@link android.os.InputEventInjectionSync#WAIT_FOR_RESULT}, or\n     * {@link android.os.InputEventInjectionSync#WAIT_FOR_FINISHED}.\n     * @param targetUid The uid to target, or {@link android.os.Process#INVALID_UID} to target all\n     *                 windows.\n     * @return True if input event injection succeeded.\n     *\n     * @hide\n     ",
    "links" : [ "android.os.InputEventInjectionSync#WAIT_FOR_FINISHED", "android.os.Process#INVALID_UID", "android.Manifest.permission#INJECT_EVENTS", "android.os.InputEventInjectionSync#WAIT_FOR_RESULT", "android.os.InputEventInjectionSync#NONE" ]
  }, {
    "name" : "public boolean injectInputEvent(InputEvent event, int mode)",
    "returnType" : "boolean",
    "comment" : "\n     * Injects an input event into the event system on behalf of an application.\n     * The synchronization mode determines whether the method blocks while waiting for\n     * input injection to proceed.\n     * <p>\n     * Requires the {@link android.Manifest.permission#INJECT_EVENTS} permission.\n     * </p><p>\n     * Make sure you correctly set the event time and input source of the event\n     * before calling this method.\n     * </p>\n     *\n     * @param event The event to inject.\n     * @param mode The synchronization mode.  One of:\n     * {@link android.os.InputEventInjectionSync#NONE},\n     * {@link android.os.InputEventInjectionSync#WAIT_FOR_RESULT}, or\n     * {@link android.os.InputEventInjectionSync#WAIT_FOR_FINISHED}.\n     * @return True if input event injection succeeded.\n     *\n     * @hide\n     ",
    "links" : [ "android.os.InputEventInjectionSync#WAIT_FOR_FINISHED", "android.Manifest.permission#INJECT_EVENTS", "android.os.InputEventInjectionSync#WAIT_FOR_RESULT", "android.os.InputEventInjectionSync#NONE" ]
  }, {
    "name" : "public VerifiedInputEvent verifyInputEvent(@NonNull InputEvent event)",
    "returnType" : "VerifiedInputEvent",
    "comment" : "\n     * Verify the details of an {@link android.view.InputEvent} that came from the system.\n     * If the event did not come from the system, or its details could not be verified, then this\n     * will return {@code null}. Receiving {@code null} does not mean that the event did not\n     * originate from the system, just that we were unable to verify it. This can\n     * happen for a number of reasons during normal operation.\n     *\n     * @param event The {@link android.view.InputEvent} to check\n     *\n     * @return {@link android.view.VerifiedInputEvent}, which is a subset of the provided\n     * {@link android.view.InputEvent}\n     *         {@code null} if the event could not be verified.\n     ",
    "links" : [ "android.view.VerifiedInputEvent", "android.view.InputEvent" ]
  }, {
    "name" : "public void setPointerIconType(int iconId)",
    "returnType" : "void",
    "comment" : "\n     * This method exists for backwards-compatibility, and is a no-op.\n     *\n     * @deprecated\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setPointerIcon(PointerIcon icon, int displayId, int deviceId, int pointerId, IBinder inputToken)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean isStylusPointerIconEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Check if showing a {@link android.view.PointerIcon} for styluses is enabled.\n     *\n     * @return true if a pointer icon will be shown over the location of a\n     * stylus pointer, false if there is no pointer icon shown for styluses.\n     ",
    "links" : [ "android.view.PointerIcon" ]
  }, {
    "name" : "public void requestPointerCapture(IBinder windowToken, boolean enable)",
    "returnType" : "void",
    "comment" : "\n     * Request or release pointer capture.\n     * <p>\n     * When in capturing mode, the pointer icon disappears and all mouse events are dispatched to\n     * the window which has requested the capture. Relative position changes are available through\n     * {@link MotionEvent#getX} and {@link MotionEvent#getY}.\n     *\n     * @param enable true when requesting pointer capture, false when releasing.\n     *\n     * @hide\n     ",
    "links" : [ "android.view.MotionEvent#getX", "android.view.MotionEvent#getY" ]
  }, {
    "name" : "public InputMonitor monitorGestureInput(String name, int displayId)",
    "returnType" : "InputMonitor",
    "comment" : "\n     * Monitor input on the specified display for gestures.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addPortAssociation(@NonNull String inputPort, int displayPort)",
    "returnType" : "void",
    "comment" : "\n     * Add a runtime association between the input port and the display port. This overrides any\n     * static associations.\n     * @param inputPort the port of the input device\n     * @param displayPort the physical port of the associated display\n     * <p>\n     * Requires {@link android.Manifest.permission#ASSOCIATE_INPUT_DEVICE_TO_DISPLAY}.\n     * </p>\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#ASSOCIATE_INPUT_DEVICE_TO_DISPLAY" ]
  }, {
    "name" : "public void removePortAssociation(@NonNull String inputPort)",
    "returnType" : "void",
    "comment" : "\n     * Remove the runtime association between the input port and the display port. Any existing\n     * static association for the cleared input port will be restored.\n     * @param inputPort the port of the input device to be cleared\n     * <p>\n     * Requires {@link android.Manifest.permission#ASSOCIATE_INPUT_DEVICE_TO_DISPLAY}.\n     * </p>\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#ASSOCIATE_INPUT_DEVICE_TO_DISPLAY" ]
  }, {
    "name" : "public void addUniqueIdAssociationByPort(@NonNull String inputPort, @NonNull String displayUniqueId)",
    "returnType" : "void",
    "comment" : "\n     * Add a runtime association between the input port and display, by unique id. Input ports are\n     * expected to be unique.\n     * @param inputPort the port of the input device\n     * @param displayUniqueId the unique id of the associated display\n     * <p>\n     * Requires {@link android.Manifest.permission#ASSOCIATE_INPUT_DEVICE_TO_DISPLAY}.\n     * </p>\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#ASSOCIATE_INPUT_DEVICE_TO_DISPLAY" ]
  }, {
    "name" : "public void removeUniqueIdAssociationByPort(@NonNull String inputPort)",
    "returnType" : "void",
    "comment" : "\n     * Removes a runtime association between the input device and display.\n     * @param inputPort the port of the input device\n     * <p>\n     * Requires {@link android.Manifest.permission#ASSOCIATE_INPUT_DEVICE_TO_DISPLAY}.\n     * </p>\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#ASSOCIATE_INPUT_DEVICE_TO_DISPLAY" ]
  }, {
    "name" : "public void addUniqueIdAssociationByDescriptor(@NonNull String inputDeviceDescriptor, @NonNull String displayUniqueId)",
    "returnType" : "void",
    "comment" : "\n     * Add a runtime association between the input device name and display, by descriptor. Input\n     * device descriptors are expected to be unique per physical device, though one physical\n     * device can have multiple virtual input devices that possess the same descriptor.\n     * E.g. a keyboard with built in trackpad will be 2 different input devices with the same\n     * descriptor.\n     * @param inputDeviceDescriptor the descriptor of the input device\n     * @param displayUniqueId the unique id of the associated display\n     * <p>\n     * Requires {@link android.Manifest.permissions.ASSOCIATE_INPUT_DEVICE_TO_DISPLAY}.\n     * </p>\n     * @hide\n     ",
    "links" : [ "android.Manifest.permissions.ASSOCIATE_INPUT_DEVICE_TO_DISPLAY" ]
  }, {
    "name" : "public void removeUniqueIdAssociationByDescriptor(@NonNull String inputDeviceDescriptor)",
    "returnType" : "void",
    "comment" : "\n     * Removes a runtime association between the input device and display.\n    }\n\n    /**\n     * Removes a runtime association between the input device and display.\n     * @param inputDeviceDescriptor the descriptor of the input device\n     * <p>\n     * Requires {@link android.Manifest.permissions.ASSOCIATE_INPUT_DEVICE_TO_DISPLAY}.\n     * </p>\n     * @hide\n     ",
    "links" : [ "android.Manifest.permissions.ASSOCIATE_INPUT_DEVICE_TO_DISPLAY" ]
  }, {
    "name" : "public HostUsiVersion getHostUsiVersion(@NonNull Display display)",
    "returnType" : "HostUsiVersion",
    "comment" : "\n     * Reports the version of the Universal Stylus Initiative (USI) protocol supported by the given\n     * display, if any.\n     *\n     * @return the USI version supported by the display, or null if the device does not support USI\n     * @see <a href=\"https://universalstylus.org\">Universal Stylus Initiative</a>\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getInputDeviceBluetoothAddress(int deviceId)",
    "returnType" : "String",
    "comment" : "\n     * Returns the Bluetooth address of this input device, if known.\n     *\n     * The returned string is always null if this input device is not connected\n     * via Bluetooth, or if the Bluetooth address of the device cannot be\n     * determined. The returned address will look like: \"11:22:33:44:55:66\".\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Vibrator getInputDeviceVibrator(int deviceId, int vibratorId)",
    "returnType" : "Vibrator",
    "comment" : "\n     * Gets a vibrator service associated with an input device, always creates a new instance.\n     * @return The vibrator, never null.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void cancelCurrentTouch()",
    "returnType" : "void",
    "comment" : "\n     * Cancel all ongoing pointer gestures on all displays.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void pilferPointers(IBinder inputChannelToken)",
    "returnType" : "void",
    "comment" : "\n     * Pilfer pointers from an input channel.\n     *\n     * Takes all the current pointer event streams that are currently being sent to the given\n     * input channel and generates appropriate cancellations for all other windows that are\n     * receiving these pointers.\n     *\n     * This API is intended to be used in conjunction with spy windows. When a spy window pilfers\n     * pointers, the foreground windows and all other spy windows that are receiving any of the\n     * pointers that are currently being dispatched to the pilfering window will have those pointers\n     * canceled. Only the pilfering window will continue to receive events for the affected pointers\n     * until the pointer is lifted.\n     *\n     * This method should be used with caution as unexpected pilfering can break fundamental user\n     * interactions.\n     *\n     * @see android.os.InputConfig#SPY\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addInputDeviceBatteryListener(int deviceId, @NonNull Executor executor, @NonNull InputDeviceBatteryListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Adds a battery listener to be notified about {@link BatteryState} changes for an input\n     * device. The same listener can be registered for multiple input devices.\n     * The listener will be notified of the initial battery state of the device after it is\n     * successfully registered.\n     * @param deviceId the input device that should be monitored\n     * @param executor an executor on which the callback will be called\n     * @param listener the {@link InputDeviceBatteryListener}\n     * @see #removeInputDeviceBatteryListener(int, InputDeviceBatteryListener)\n     * @hide\n     ",
    "links" : [ "android.hardware.BatteryState", "InputDeviceBatteryListener" ]
  }, {
    "name" : "public void removeInputDeviceBatteryListener(int deviceId, @NonNull InputDeviceBatteryListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes a previously registered battery listener for an input device.\n     * @see #addInputDeviceBatteryListener(int, Executor, InputDeviceBatteryListener)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean areTouchpadGesturesAvailable(@NonNull Context context)",
    "returnType" : "boolean",
    "comment" : "\n     * Whether there is a gesture-compatible touchpad connected to the device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerKeyboardBacklightListener(@NonNull Executor executor, @NonNull KeyboardBacklightListener listener) throws IllegalArgumentException",
    "returnType" : "void",
    "comment" : "\n     * Registers a Keyboard backlight change listener to be notified about {@link\n     * KeyboardBacklightState} changes for connected keyboard devices.\n     *\n     * @param executor an executor on which the callback will be called\n     * @param listener the {@link KeyboardBacklightListener}\n     * @hide\n     * @see #unregisterKeyboardBacklightListener(KeyboardBacklightListener)\n     * @throws IllegalArgumentException if {@code listener} has already been registered previously.\n     * @throws NullPointerException if {@code listener} or {@code executor} is null.\n     ",
    "links" : [ "KeyboardBacklightListener", "android.hardware.input.KeyboardBacklightState" ]
  }, {
    "name" : "public void unregisterKeyboardBacklightListener(@NonNull KeyboardBacklightListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters a previously added Keyboard backlight change listener.\n     *\n     * @param listener the {@link KeyboardBacklightListener}\n     * @see #registerKeyboardBacklightListener(Executor, KeyboardBacklightListener)\n     * @hide\n     ",
    "links" : [ "KeyboardBacklightListener" ]
  }, {
    "name" : "public void registerStickyModifierStateListener(@NonNull Executor executor, @NonNull StickyModifierStateListener listener) throws IllegalArgumentException",
    "returnType" : "void",
    "comment" : "\n     * Registers a Sticky modifier state change listener to be notified about {@link\n     * StickyModifierState} changes.\n     *\n     * @param executor an executor on which the callback will be called\n     * @param listener the {@link StickyModifierStateListener}\n     * @throws IllegalArgumentException if {@code listener} has already been registered previously.\n     * @throws NullPointerException     if {@code listener} or {@code executor} is null.\n     * @hide\n     * @see #unregisterStickyModifierStateListener(StickyModifierStateListener)\n     ",
    "links" : [ "StickyModifierStateListener", "android.hardware.input.StickyModifierState" ]
  }, {
    "name" : "public void unregisterStickyModifierStateListener(@NonNull StickyModifierStateListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters a previously added Sticky modifier state change listener.\n     *\n     * @param listener the {@link StickyModifierStateListener}\n     * @hide\n     * @see #registerStickyModifierStateListener(Executor, StickyModifierStateListener)\n     ",
    "links" : [ "StickyModifierStateListener" ]
  } ],
  "methodNames" : [ "public static InputManager getInstance()", "public String getVelocityTrackerStrategy()", "public InputDevice getInputDevice(int id)", "public InputDevice.ViewBehavior getInputDeviceViewBehavior(int deviceId)", "public InputDevice getInputDeviceByDescriptor(String descriptor)", "public int[] getInputDeviceIds()", "public boolean isInputDeviceEnabled(int id)", "public void enableInputDevice(int id)", "public void disableInputDevice(int id)", "public void registerInputDeviceListener(InputDeviceListener listener, Handler handler)", "public void unregisterInputDeviceListener(InputDeviceListener listener)", "public int isInTabletMode()", "public void registerOnTabletModeChangedListener(OnTabletModeChangedListener listener, Handler handler)", "public void unregisterOnTabletModeChangedListener(OnTabletModeChangedListener listener)", "public int isMicMuted()", "public KeyboardLayout[] getKeyboardLayouts()", "public List<String> getKeyboardLayoutDescriptors()", "public String getKeyboardLayoutTypeForLayoutDescriptor(@NonNull String layoutDescriptor)", "public KeyboardLayout[] getKeyboardLayoutsForInputDevice(@NonNull InputDeviceIdentifier identifier)", "public KeyboardLayout getKeyboardLayout(String keyboardLayoutDescriptor)", "public String getCurrentKeyboardLayoutForInputDevice(@NonNull InputDeviceIdentifier identifier)", "public void setCurrentKeyboardLayoutForInputDevice(@NonNull InputDeviceIdentifier identifier, @NonNull String keyboardLayoutDescriptor)", "public String[] getEnabledKeyboardLayoutsForInputDevice(InputDeviceIdentifier identifier)", "public void addKeyboardLayoutForInputDevice(InputDeviceIdentifier identifier, String keyboardLayoutDescriptor)", "public void removeKeyboardLayoutForInputDevice(@NonNull InputDeviceIdentifier identifier, @NonNull String keyboardLayoutDescriptor)", "public void remapModifierKey(@RemappableModifierKey int fromKey, @RemappableModifierKey int toKey)", "public void clearAllModifierKeyRemappings()", "public Map<Integer, Integer> getModifierKeyRemapping()", "public TouchCalibration getTouchCalibration(String inputDeviceDescriptor, int surfaceRotation)", "public void setTouchCalibration(String inputDeviceDescriptor, int surfaceRotation, TouchCalibration calibration)", "public KeyboardLayoutSelectionResult getKeyboardLayoutForInputDevice(@NonNull InputDeviceIdentifier identifier, @UserIdInt int userId, @NonNull InputMethodInfo imeInfo, @Nullable InputMethodSubtype imeSubtype)", "public void setKeyboardLayoutForInputDevice(@NonNull InputDeviceIdentifier identifier, @UserIdInt int userId, @NonNull InputMethodInfo imeInfo, @Nullable InputMethodSubtype imeSubtype, @NonNull String keyboardLayoutDescriptor)", "public KeyboardLayout[] getKeyboardLayoutListForInputDevice(InputDeviceIdentifier identifier, @UserIdInt int userId, @NonNull InputMethodInfo imeInfo, @Nullable InputMethodSubtype imeSubtype)", "public int getMousePointerSpeed()", "public void tryPointerSpeed(int speed)", "public float getMaximumObscuringOpacityForTouch()", "public boolean[] deviceHasKeys(int[] keyCodes)", "public boolean[] deviceHasKeys(int id, int[] keyCodes)", "public int getKeyCodeForKeyLocation(int deviceId, int locationKeyCode)", "public Drawable getKeyboardLayoutPreview(@Nullable KeyboardLayout keyboardLayout, int width, int height)", "public boolean injectInputEvent(InputEvent event, int mode, int targetUid)", "public boolean injectInputEvent(InputEvent event, int mode)", "public VerifiedInputEvent verifyInputEvent(@NonNull InputEvent event)", "public void setPointerIconType(int iconId)", "public boolean setPointerIcon(PointerIcon icon, int displayId, int deviceId, int pointerId, IBinder inputToken)", "public boolean isStylusPointerIconEnabled()", "public void requestPointerCapture(IBinder windowToken, boolean enable)", "public InputMonitor monitorGestureInput(String name, int displayId)", "public void addPortAssociation(@NonNull String inputPort, int displayPort)", "public void removePortAssociation(@NonNull String inputPort)", "public void addUniqueIdAssociationByPort(@NonNull String inputPort, @NonNull String displayUniqueId)", "public void removeUniqueIdAssociationByPort(@NonNull String inputPort)", "public void addUniqueIdAssociationByDescriptor(@NonNull String inputDeviceDescriptor, @NonNull String displayUniqueId)", "public void removeUniqueIdAssociationByDescriptor(@NonNull String inputDeviceDescriptor)", "public HostUsiVersion getHostUsiVersion(@NonNull Display display)", "public String getInputDeviceBluetoothAddress(int deviceId)", "public Vibrator getInputDeviceVibrator(int deviceId, int vibratorId)", "public void cancelCurrentTouch()", "public void pilferPointers(IBinder inputChannelToken)", "public void addInputDeviceBatteryListener(int deviceId, @NonNull Executor executor, @NonNull InputDeviceBatteryListener listener)", "public void removeInputDeviceBatteryListener(int deviceId, @NonNull InputDeviceBatteryListener listener)", "public boolean areTouchpadGesturesAvailable(@NonNull Context context)", "public void registerKeyboardBacklightListener(@NonNull Executor executor, @NonNull KeyboardBacklightListener listener) throws IllegalArgumentException", "public void unregisterKeyboardBacklightListener(@NonNull KeyboardBacklightListener listener)", "public void registerStickyModifierStateListener(@NonNull Executor executor, @NonNull StickyModifierStateListener listener) throws IllegalArgumentException", "public void unregisterStickyModifierStateListener(@NonNull StickyModifierStateListener listener)" ],
  "variableNames" : [ "TAG", "DEBUG", "mIm", "mIsStylusPointerIconEnabled", "ACTION_QUERY_KEYBOARD_LAYOUTS", "META_DATA_KEYBOARD_LAYOUTS", "BLOCK_UNTRUSTED_TOUCHES", "INJECT_INPUT_EVENT_MODE_ASYNC", "INJECT_INPUT_EVENT_MODE_WAIT_FOR_RESULT", "INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH", "SWITCH_STATE_UNKNOWN", "SWITCH_STATE_OFF", "SWITCH_STATE_ON", "mGlobal", "mContext" ]
}