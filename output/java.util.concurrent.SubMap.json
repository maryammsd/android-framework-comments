{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/util/concurrent/ConcurrentSkipListMap.java",
  "packageName" : "java.util.concurrent",
  "className" : "SubMap",
  "comment" : "\n     * Submaps returned by {@link ConcurrentSkipListMap} submap operations\n     * represent a subrange of mappings of their underlying maps.\n     * Instances of this class support all methods of their underlying\n     * maps, differing in that mappings outside their range are ignored,\n     * and attempts to add mappings outside their ranges result in {@link\n     * IllegalArgumentException}.  Instances of this class are constructed\n     * only using the {@code subMap}, {@code headMap}, and {@code tailMap}\n     * methods of their underlying maps.\n     *\n     * @serial include\n     ",
  "links" : [ "java.util.concurrent.ConcurrentSkipListMap", "IllegalArgumentException" ],
  "variables" : [ {
    "name" : "serialVersionUID",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "m",
    "type" : "ConcurrentSkipListMap<K, V>",
    "comment" : " Underlying map ",
    "links" : [ ]
  }, {
    "name" : "lo",
    "type" : "K",
    "comment" : " lower bound key, or null if from start ",
    "links" : [ ]
  }, {
    "name" : "hi",
    "type" : "K",
    "comment" : " upper bound key, or null if to end ",
    "links" : [ ]
  }, {
    "name" : "loInclusive",
    "type" : "boolean",
    "comment" : " inclusion flag for lo ",
    "links" : [ ]
  }, {
    "name" : "hiInclusive",
    "type" : "boolean",
    "comment" : " inclusion flag for hi ",
    "links" : [ ]
  }, {
    "name" : "isDescending",
    "type" : "boolean",
    "comment" : " direction ",
    "links" : [ ]
  }, {
    "name" : "keySetView",
    "type" : "KeySet<K, V>",
    "comment" : " Lazily initialized view holders",
    "links" : [ ]
  }, {
    "name" : "valuesView",
    "type" : "Values<K, V>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "entrySetView",
    "type" : "EntrySet<K, V>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : " boolean tooLow(Object key, Comparator<? super K> cmp)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean tooHigh(Object key, Comparator<? super K> cmp)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean inBounds(Object key, Comparator<? super K> cmp)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void checkKeyBounds(K key, Comparator<? super K> cmp)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean isBeforeEnd(ConcurrentSkipListMap.Node<K, V> n, Comparator<? super K> cmp)",
    "returnType" : "boolean",
    "comment" : "\n         * Returns true if node key is less than upper bound of range.\n         ",
    "links" : [ ]
  }, {
    "name" : " ConcurrentSkipListMap.Node<K, V> loNode(Comparator<? super K> cmp)",
    "returnType" : "ConcurrentSkipListMap.Node<K, V>",
    "comment" : "\n         * Returns lowest node. This node might not be in range, so\n         * most usages need to check bounds.\n         ",
    "links" : [ ]
  }, {
    "name" : " ConcurrentSkipListMap.Node<K, V> hiNode(Comparator<? super K> cmp)",
    "returnType" : "ConcurrentSkipListMap.Node<K, V>",
    "comment" : "\n         * Returns highest node. This node might not be in range, so\n         * most usages need to check bounds.\n         ",
    "links" : [ ]
  }, {
    "name" : " K lowestKey()",
    "returnType" : "K",
    "comment" : "\n         * Returns lowest absolute key (ignoring directionality).\n         ",
    "links" : [ ]
  }, {
    "name" : " K highestKey()",
    "returnType" : "K",
    "comment" : "\n         * Returns highest absolute key (ignoring directionality).\n         ",
    "links" : [ ]
  }, {
    "name" : " Map.Entry<K, V> lowestEntry()",
    "returnType" : "Map.Entry<K, V>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " Map.Entry<K, V> highestEntry()",
    "returnType" : "Map.Entry<K, V>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " Map.Entry<K, V> removeLowest()",
    "returnType" : "Map.Entry<K, V>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " Map.Entry<K, V> removeHighest()",
    "returnType" : "Map.Entry<K, V>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " Map.Entry<K, V> getNearEntry(K key, int rel)",
    "returnType" : "Map.Entry<K, V>",
    "comment" : "\n         * Submap version of ConcurrentSkipListMap.findNearEntry.\n         ",
    "links" : [ ]
  }, {
    "name" : " K getNearKey(K key, int rel)",
    "returnType" : "K",
    "comment" : " Almost the same as getNearEntry, except for keys",
    "links" : [ ]
  }, {
    "name" : "public boolean containsKey(Object key)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public V get(Object key)",
    "returnType" : "V",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public V put(K key, V value)",
    "returnType" : "V",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public V remove(Object key)",
    "returnType" : "V",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int size()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isEmpty()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean containsValue(Object value)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void clear()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public V putIfAbsent(K key, V value)",
    "returnType" : "V",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean remove(Object key, Object value)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean replace(K key, V oldValue, V newValue)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public V replace(K key, V value)",
    "returnType" : "V",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Comparator<? super K> comparator()",
    "returnType" : "Comparator<? super K>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " SubMap<K, V> newSubMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)",
    "returnType" : "SubMap<K, V>",
    "comment" : "\n         * Utility to create submaps, where given bounds override\n         * unbounded(null) ones and/or are checked against bounded ones.\n         ",
    "links" : [ ]
  }, {
    "name" : "public SubMap<K, V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)",
    "returnType" : "SubMap<K, V>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public SubMap<K, V> headMap(K toKey, boolean inclusive)",
    "returnType" : "SubMap<K, V>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public SubMap<K, V> tailMap(K fromKey, boolean inclusive)",
    "returnType" : "SubMap<K, V>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public SubMap<K, V> subMap(K fromKey, K toKey)",
    "returnType" : "SubMap<K, V>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public SubMap<K, V> headMap(K toKey)",
    "returnType" : "SubMap<K, V>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public SubMap<K, V> tailMap(K fromKey)",
    "returnType" : "SubMap<K, V>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public SubMap<K, V> descendingMap()",
    "returnType" : "SubMap<K, V>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Map.Entry<K, V> ceilingEntry(K key)",
    "returnType" : "Map.Entry<K, V>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public K ceilingKey(K key)",
    "returnType" : "K",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Map.Entry<K, V> lowerEntry(K key)",
    "returnType" : "Map.Entry<K, V>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public K lowerKey(K key)",
    "returnType" : "K",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Map.Entry<K, V> floorEntry(K key)",
    "returnType" : "Map.Entry<K, V>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public K floorKey(K key)",
    "returnType" : "K",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Map.Entry<K, V> higherEntry(K key)",
    "returnType" : "Map.Entry<K, V>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public K higherKey(K key)",
    "returnType" : "K",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public K firstKey()",
    "returnType" : "K",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public K lastKey()",
    "returnType" : "K",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Map.Entry<K, V> firstEntry()",
    "returnType" : "Map.Entry<K, V>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Map.Entry<K, V> lastEntry()",
    "returnType" : "Map.Entry<K, V>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Map.Entry<K, V> pollFirstEntry()",
    "returnType" : "Map.Entry<K, V>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Map.Entry<K, V> pollLastEntry()",
    "returnType" : "Map.Entry<K, V>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public NavigableSet<K> keySet()",
    "returnType" : "NavigableSet<K>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public NavigableSet<K> navigableKeySet()",
    "returnType" : "NavigableSet<K>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Collection<V> values()",
    "returnType" : "Collection<V>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Set<Map.Entry<K, V>> entrySet()",
    "returnType" : "Set<Map.Entry<K, V>>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public NavigableSet<K> descendingKeySet()",
    "returnType" : "NavigableSet<K>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ " boolean tooLow(Object key, Comparator<? super K> cmp)", " boolean tooHigh(Object key, Comparator<? super K> cmp)", " boolean inBounds(Object key, Comparator<? super K> cmp)", " void checkKeyBounds(K key, Comparator<? super K> cmp)", " boolean isBeforeEnd(ConcurrentSkipListMap.Node<K, V> n, Comparator<? super K> cmp)", " ConcurrentSkipListMap.Node<K, V> loNode(Comparator<? super K> cmp)", " ConcurrentSkipListMap.Node<K, V> hiNode(Comparator<? super K> cmp)", " K lowestKey()", " K highestKey()", " Map.Entry<K, V> lowestEntry()", " Map.Entry<K, V> highestEntry()", " Map.Entry<K, V> removeLowest()", " Map.Entry<K, V> removeHighest()", " Map.Entry<K, V> getNearEntry(K key, int rel)", " K getNearKey(K key, int rel)", "public boolean containsKey(Object key)", "public V get(Object key)", "public V put(K key, V value)", "public V remove(Object key)", "public int size()", "public boolean isEmpty()", "public boolean containsValue(Object value)", "public void clear()", "public V putIfAbsent(K key, V value)", "public boolean remove(Object key, Object value)", "public boolean replace(K key, V oldValue, V newValue)", "public V replace(K key, V value)", "public Comparator<? super K> comparator()", " SubMap<K, V> newSubMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)", "public SubMap<K, V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)", "public SubMap<K, V> headMap(K toKey, boolean inclusive)", "public SubMap<K, V> tailMap(K fromKey, boolean inclusive)", "public SubMap<K, V> subMap(K fromKey, K toKey)", "public SubMap<K, V> headMap(K toKey)", "public SubMap<K, V> tailMap(K fromKey)", "public SubMap<K, V> descendingMap()", "public Map.Entry<K, V> ceilingEntry(K key)", "public K ceilingKey(K key)", "public Map.Entry<K, V> lowerEntry(K key)", "public K lowerKey(K key)", "public Map.Entry<K, V> floorEntry(K key)", "public K floorKey(K key)", "public Map.Entry<K, V> higherEntry(K key)", "public K higherKey(K key)", "public K firstKey()", "public K lastKey()", "public Map.Entry<K, V> firstEntry()", "public Map.Entry<K, V> lastEntry()", "public Map.Entry<K, V> pollFirstEntry()", "public Map.Entry<K, V> pollLastEntry()", "public NavigableSet<K> keySet()", "public NavigableSet<K> navigableKeySet()", "public Collection<V> values()", "public Set<Map.Entry<K, V>> entrySet()", "public NavigableSet<K> descendingKeySet()" ],
  "variableNames" : [ "serialVersionUID", "m", "lo", "hi", "loInclusive", "hiInclusive", "isDescending", "keySetView", "valuesView", "entrySetView" ]
}