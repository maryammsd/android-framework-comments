{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/lang/Double.java",
  "packageName" : "java.lang",
  "className" : "Double",
  "comment" : "\n * The {@code Double} class wraps a value of the primitive type\n * {@code double} in an object. An object of type\n * {@code Double} contains a single field whose type is\n * {@code double}.\n *\n * <p>In addition, this class provides several methods for converting a\n * {@code double} to a {@code String} and a\n * {@code String} to a {@code double}, as well as other\n * constants and methods useful when dealing with a\n * {@code double}.\n *\n * <!-- Android-removed: paragraph on ValueBased\n * <p>This is a <a href=\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\">value-based</a>\n * class; programmers should treat instances that are\n * {@linkplain #equals(Object) equal} as interchangeable and should not\n * use instances for synchronization, or unpredictable behavior may\n * occur. For example, in a future release, synchronization may fail.\n * -->\n *\n * <h2><a id=equivalenceRelation>Floating-point Equality, Equivalence,\n * and Comparison</a></h2>\n *\n * IEEE 754 floating-point values include finite nonzero values,\n * signed zeros ({@code +0.0} and {@code -0.0}), signed infinities\n * {@linkplain Double#POSITIVE_INFINITY positive infinity} and\n * {@linkplain Double#NEGATIVE_INFINITY negative infinity}), and\n * {@linkplain Double#NaN NaN} (not-a-number).\n *\n * <p>An <em>equivalence relation</em> on a set of values is a boolean\n * relation on pairs of values that is reflexive, symmetric, and\n * transitive. For more discussion of equivalence relations and object\n * equality, see the {@link Object#equals Object.equals}\n * specification. An equivalence relation partitions the values it\n * operates over into sets called <i>equivalence classes</i>.  All the\n * members of the equivalence class are equal to each other under the\n * relation. An equivalence class may contain only a single member. At\n * least for some purposes, all the members of an equivalence class\n * are substitutable for each other.  In particular, in a numeric\n * expression equivalent values can be <em>substituted</em> for one\n * another without changing the result of the expression, meaning\n * changing the equivalence class of the result of the expression.\n *\n * <p>Notably, the built-in {@code ==} operation on floating-point\n * values is <em>not</em> an equivalence relation. Despite not\n * defining an equivalence relation, the semantics of the IEEE 754\n * {@code ==} operator were deliberately designed to meet other needs\n * of numerical computation. There are two exceptions where the\n * properties of an equivalence relation are not satisfied by {@code\n * ==} on floating-point values:\n *\n * <ul>\n *\n * <li>If {@code v1} and {@code v2} are both NaN, then {@code v1\n * == v2} has the value {@code false}. Therefore, for two NaN\n * arguments the <em>reflexive</em> property of an equivalence\n * relation is <em>not</em> satisfied by the {@code ==} operator.\n *\n * <li>If {@code v1} represents {@code +0.0} while {@code v2}\n * represents {@code -0.0}, or vice versa, then {@code v1 == v2} has\n * the value {@code true} even though {@code +0.0} and {@code -0.0}\n * are distinguishable under various floating-point operations. For\n * example, {@code 1.0/+0.0} evaluates to positive infinity while\n * {@code 1.0/-0.0} evaluates to <em>negative</em> infinity and\n * positive infinity and negative infinity are neither equal to each\n * other nor equivalent to each other. Thus, while a signed zero input\n * most commonly determines the sign of a zero result, because of\n * dividing by zero, {@code +0.0} and {@code -0.0} may not be\n * substituted for each other in general. The sign of a zero input\n * also has a non-substitutable effect on the result of some math\n * library methods.\n *\n * </ul>\n *\n * <p>For ordered comparisons using the built-in comparison operators\n * ({@code <}, {@code <=}, etc.), NaN values have another anomalous\n * situation: a NaN is neither less than, nor greater than, nor equal\n * to any value, including itself. This means the <i>trichotomy of\n * comparison</i> does <em>not</em> hold.\n *\n * <p>To provide the appropriate semantics for {@code equals} and\n * {@code compareTo} methods, those methods cannot simply be wrappers\n * around {@code ==} or ordered comparison operations. Instead, {@link\n * Double#equals equals} defines NaN arguments to be equal to each\n * other and defines {@code +0.0} to <em>not</em> be equal to {@code\n * -0.0}, restoring reflexivity. For comparisons, {@link\n * Double#compareTo compareTo} defines a total order where {@code\n * -0.0} is less than {@code +0.0} and where a NaN is equal to itself\n * and considered greater than positive infinity.\n *\n * <p>The operational semantics of {@code equals} and {@code\n * compareTo} are expressed in terms of {@linkplain #doubleToLongBits\n * bit-wise converting} the floating-point values to integral values.\n *\n * <p>The <em>natural ordering</em> implemented by {@link #compareTo\n * compareTo} is {@linkplain Comparable consistent with equals}. That\n * is, two objects are reported as equal by {@code equals} if and only\n * if {@code compareTo} on those objects returns zero.\n *\n * <p>The adjusted behaviors defined for {@code equals} and {@code\n * compareTo} allow instances of wrapper classes to work properly with\n * conventional data structures. For example, defining NaN\n * values to be {@code equals} to one another allows NaN to be used as\n * an element of a {@link java.util.HashSet HashSet} or as the key of\n * a {@link java.util.HashMap HashMap}. Similarly, defining {@code\n * compareTo} as a total ordering, including {@code +0.0}, {@code\n * -0.0}, and NaN, allows instances of wrapper classes to be used as\n * elements of a {@link java.util.SortedSet SortedSet} or as keys of a\n * {@link java.util.SortedMap SortedMap}.\n *\n * @jls 4.2.3 Floating-Point Types, Formats, and Values\n * @jls 4.2.4. Floating-Point Operations\n * @jls 15.21.1 Numerical Equality Operators == and !=\n * @jls 15.20.1 Numerical Comparison Operators {@code <}, {@code <=}, {@code >}, and {@code >=}\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Joseph D. Darcy\n * @since 1.0\n ",
  "links" : [ "java.lang.Double#equals", "java.util.HashSet", "java.lang.Object#equals", "java.util.SortedSet", "java.lang.Double#compareTo", "java.util.HashMap", "#compareTocompareTo", "java.util.SortedMap" ],
  "variables" : [ {
    "name" : "POSITIVE_INFINITY",
    "type" : "double",
    "comment" : "\n     * A constant holding the positive infinity of type\n     * {@code double}. It is equal to the value returned by\n     * {@code Double.longBitsToDouble(0x7ff0000000000000L)}.\n     ",
    "links" : [ ]
  }, {
    "name" : "NEGATIVE_INFINITY",
    "type" : "double",
    "comment" : "\n     * A constant holding the negative infinity of type\n     * {@code double}. It is equal to the value returned by\n     * {@code Double.longBitsToDouble(0xfff0000000000000L)}.\n     ",
    "links" : [ ]
  }, {
    "name" : "NaN",
    "type" : "double",
    "comment" : "\n     * A constant holding a Not-a-Number (NaN) value of type\n     * {@code double}. It is equivalent to the value returned by\n     * {@code Double.longBitsToDouble(0x7ff8000000000000L)}.\n     ",
    "links" : [ ]
  }, {
    "name" : "MAX_VALUE",
    "type" : "double",
    "comment" : " 1.7976931348623157e+308",
    "links" : [ ]
  }, {
    "name" : "MIN_NORMAL",
    "type" : "double",
    "comment" : " 2.2250738585072014E-308",
    "links" : [ ]
  }, {
    "name" : "MIN_VALUE",
    "type" : "double",
    "comment" : " 4.9e-324",
    "links" : [ ]
  }, {
    "name" : "MAX_EXPONENT",
    "type" : "int",
    "comment" : "\n     * Maximum exponent a finite {@code double} variable may have.\n     * It is equal to the value returned by\n     * {@code Math.getExponent(Double.MAX_VALUE)}.\n     *\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "MIN_EXPONENT",
    "type" : "int",
    "comment" : "\n     * Minimum exponent a normalized {@code double} variable may\n     * have.  It is equal to the value returned by\n     * {@code Math.getExponent(Double.MIN_NORMAL)}.\n     *\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "SIZE",
    "type" : "int",
    "comment" : "\n     * The number of bits used to represent a {@code double} value.\n     *\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "PRECISION",
    "type" : "int",
    "comment" : "\n     * The number of bits in the significand of a {@code double} value.\n     * This is the parameter N in section {@jls 4.2.3} of\n     * <cite>The Java Language Specification</cite>.\n     *\n     * @since 19\n     ",
    "links" : [ ]
  }, {
    "name" : "BYTES",
    "type" : "int",
    "comment" : "\n     * The number of bytes used to represent a {@code double} value.\n     *\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPE",
    "type" : "Class<Double>",
    "comment" : "\n     * The {@code Class} instance representing the primitive type\n     * {@code double}.\n     *\n     * @since 1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "value",
    "type" : "double",
    "comment" : "\n     * The value of the Double.\n     *\n     * @serial\n     ",
    "links" : [ ]
  }, {
    "name" : "serialVersionUID",
    "type" : "long",
    "comment" : " use serialVersionUID from JDK 1.0.2 for interoperability ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static String toString(double d)",
    "returnType" : "String",
    "comment" : "\n     * Returns a string representation of the {@code double}\n     * argument. All characters mentioned below are ASCII characters.\n     * <ul>\n     * <li>If the argument is NaN, the result is the string\n     *     \"{@code NaN}\".\n     * <li>Otherwise, the result is a string that represents the sign and\n     * magnitude (absolute value) of the argument. If the sign is negative,\n     * the first character of the result is '{@code -}'\n     * ({@code '\\u005Cu002D'}); if the sign is positive, no sign character\n     * appears in the result. As for the magnitude <i>m</i>:\n     * <ul>\n     * <li>If <i>m</i> is infinity, it is represented by the characters\n     * {@code \"Infinity\"}; thus, positive infinity produces the result\n     * {@code \"Infinity\"} and negative infinity produces the result\n     * {@code \"-Infinity\"}.\n     *\n     * <li>If <i>m</i> is zero, it is represented by the characters\n     * {@code \"0.0\"}; thus, negative zero produces the result\n     * {@code \"-0.0\"} and positive zero produces the result\n     * {@code \"0.0\"}.\n     *\n     * <li>If <i>m</i> is greater than or equal to 10<sup>-3</sup> but less\n     * than 10<sup>7</sup>, then it is represented as the integer part of\n     * <i>m</i>, in decimal form with no leading zeroes, followed by\n     * '{@code .}' ({@code '\\u005Cu002E'}), followed by one or\n     * more decimal digits representing the fractional part of <i>m</i>.\n     *\n     * <li>If <i>m</i> is less than 10<sup>-3</sup> or greater than or\n     * equal to 10<sup>7</sup>, then it is represented in so-called\n     * \"computerized scientific notation.\" Let <i>n</i> be the unique\n     * integer such that 10<sup><i>n</i></sup> &le; <i>m</i> {@literal <}\n     * 10<sup><i>n</i>+1</sup>; then let <i>a</i> be the\n     * mathematically exact quotient of <i>m</i> and\n     * 10<sup><i>n</i></sup> so that 1 &le; <i>a</i> {@literal <} 10. The\n     * magnitude is then represented as the integer part of <i>a</i>,\n     * as a single decimal digit, followed by '{@code .}'\n     * ({@code '\\u005Cu002E'}), followed by decimal digits\n     * representing the fractional part of <i>a</i>, followed by the\n     * letter '{@code E}' ({@code '\\u005Cu0045'}), followed\n     * by a representation of <i>n</i> as a decimal integer, as\n     * produced by the method {@link Integer#toString(int)}.\n     * </ul>\n     * </ul>\n     * How many digits must be printed for the fractional part of\n     * <i>m</i> or <i>a</i>? There must be at least one digit to represent\n     * the fractional part, and beyond that as many, but only as many, more\n     * digits as are needed to uniquely distinguish the argument value from\n     * adjacent values of type {@code double}. That is, suppose that\n     * <i>x</i> is the exact mathematical value represented by the decimal\n     * representation produced by this method for a finite nonzero argument\n     * <i>d</i>. Then <i>d</i> must be the {@code double} value nearest\n     * to <i>x</i>; or if two {@code double} values are equally close\n     * to <i>x</i>, then <i>d</i> must be one of them and the least\n     * significant bit of the significand of <i>d</i> must be {@code 0}.\n     *\n     * <p>To create localized string representations of a floating-point\n     * value, use subclasses of {@link java.text.NumberFormat}.\n     *\n     * @param   d   the {@code double} to be converted.\n     * @return a string representation of the argument.\n     ",
    "links" : [ "java.lang.Integer#toString(int)", "java.text.NumberFormat" ]
  }, {
    "name" : "public static String toHexString(double d)",
    "returnType" : "String",
    "comment" : "\n     * Returns a hexadecimal string representation of the\n     * {@code double} argument. All characters mentioned below\n     * are ASCII characters.\n     *\n     * <ul>\n     * <li>If the argument is NaN, the result is the string\n     *     \"{@code NaN}\".\n     * <li>Otherwise, the result is a string that represents the sign\n     * and magnitude of the argument. If the sign is negative, the\n     * first character of the result is '{@code -}'\n     * ({@code '\\u005Cu002D'}); if the sign is positive, no sign\n     * character appears in the result. As for the magnitude <i>m</i>:\n     *\n     * <ul>\n     * <li>If <i>m</i> is infinity, it is represented by the string\n     * {@code \"Infinity\"}; thus, positive infinity produces the\n     * result {@code \"Infinity\"} and negative infinity produces\n     * the result {@code \"-Infinity\"}.\n     *\n     * <li>If <i>m</i> is zero, it is represented by the string\n     * {@code \"0x0.0p0\"}; thus, negative zero produces the result\n     * {@code \"-0x0.0p0\"} and positive zero produces the result\n     * {@code \"0x0.0p0\"}.\n     *\n     * <li>If <i>m</i> is a {@code double} value with a\n     * normalized representation, substrings are used to represent the\n     * significand and exponent fields.  The significand is\n     * represented by the characters {@code \"0x1.\"}\n     * followed by a lowercase hexadecimal representation of the rest\n     * of the significand as a fraction.  Trailing zeros in the\n     * hexadecimal representation are removed unless all the digits\n     * are zero, in which case a single zero is used. Next, the\n     * exponent is represented by {@code \"p\"} followed\n     * by a decimal string of the unbiased exponent as if produced by\n     * a call to {@link Integer#toString(int) Integer.toString} on the\n     * exponent value.\n     *\n     * <li>If <i>m</i> is a {@code double} value with a subnormal\n     * representation, the significand is represented by the\n     * characters {@code \"0x0.\"} followed by a\n     * hexadecimal representation of the rest of the significand as a\n     * fraction.  Trailing zeros in the hexadecimal representation are\n     * removed. Next, the exponent is represented by\n     * {@code \"p-1022\"}.  Note that there must be at\n     * least one nonzero digit in a subnormal significand.\n     *\n     * </ul>\n     *\n     * </ul>\n     *\n     * <table class=\"striped\">\n     * <caption>Examples</caption>\n     * <thead>\n     * <tr><th scope=\"col\">Floating-point Value</th><th scope=\"col\">Hexadecimal String</th>\n     * </thead>\n     * <tbody style=\"text-align:right\">\n     * <tr><th scope=\"row\">{@code 1.0}</th> <td>{@code 0x1.0p0}</td>\n     * <tr><th scope=\"row\">{@code -1.0}</th>        <td>{@code -0x1.0p0}</td>\n     * <tr><th scope=\"row\">{@code 2.0}</th> <td>{@code 0x1.0p1}</td>\n     * <tr><th scope=\"row\">{@code 3.0}</th> <td>{@code 0x1.8p1}</td>\n     * <tr><th scope=\"row\">{@code 0.5}</th> <td>{@code 0x1.0p-1}</td>\n     * <tr><th scope=\"row\">{@code 0.25}</th>        <td>{@code 0x1.0p-2}</td>\n     * <tr><th scope=\"row\">{@code Double.MAX_VALUE}</th>\n     *     <td>{@code 0x1.fffffffffffffp1023}</td>\n     * <tr><th scope=\"row\">{@code Minimum Normal Value}</th>\n     *     <td>{@code 0x1.0p-1022}</td>\n     * <tr><th scope=\"row\">{@code Maximum Subnormal Value}</th>\n     *     <td>{@code 0x0.fffffffffffffp-1022}</td>\n     * <tr><th scope=\"row\">{@code Double.MIN_VALUE}</th>\n     *     <td>{@code 0x0.0000000000001p-1022}</td>\n     * </tbody>\n     * </table>\n     * @param   d   the {@code double} to be converted.\n     * @return a hex string representation of the argument.\n     * @since 1.5\n     * @author Joseph D. Darcy\n     ",
    "links" : [ "java.lang.Integer#toString(int)" ]
  }, {
    "name" : "public static Double valueOf(String s) throws NumberFormatException",
    "returnType" : "Double",
    "comment" : "\n     * Returns a {@code Double} object holding the\n     * {@code double} value represented by the argument string\n     * {@code s}.\n     *\n     * <p>If {@code s} is {@code null}, then a\n     * {@code NullPointerException} is thrown.\n     *\n     * <p>Leading and trailing whitespace characters in {@code s}\n     * are ignored.  Whitespace is removed as if by the {@link\n     * String#trim} method; that is, both ASCII space and control\n     * characters are removed. The rest of {@code s} should\n     * constitute a <i>FloatValue</i> as described by the lexical\n     * syntax rules:\n     *\n     * <blockquote>\n     * <dl>\n     * <dt><i>FloatValue:</i>\n     * <dd><i>Sign<sub>opt</sub></i> {@code NaN}\n     * <dd><i>Sign<sub>opt</sub></i> {@code Infinity}\n     * <dd><i>Sign<sub>opt</sub> FloatingPointLiteral</i>\n     * <dd><i>Sign<sub>opt</sub> HexFloatingPointLiteral</i>\n     * <dd><i>SignedInteger</i>\n     * </dl>\n     *\n     * <dl>\n     * <dt><i>HexFloatingPointLiteral</i>:\n     * <dd> <i>HexSignificand BinaryExponent FloatTypeSuffix<sub>opt</sub></i>\n     * </dl>\n     *\n     * <dl>\n     * <dt><i>HexSignificand:</i>\n     * <dd><i>HexNumeral</i>\n     * <dd><i>HexNumeral</i> {@code .}\n     * <dd>{@code 0x} <i>HexDigits<sub>opt</sub>\n     *     </i>{@code .}<i> HexDigits</i>\n     * <dd>{@code 0X}<i> HexDigits<sub>opt</sub>\n     *     </i>{@code .} <i>HexDigits</i>\n     * </dl>\n     *\n     * <dl>\n     * <dt><i>BinaryExponent:</i>\n     * <dd><i>BinaryExponentIndicator SignedInteger</i>\n     * </dl>\n     *\n     * <dl>\n     * <dt><i>BinaryExponentIndicator:</i>\n     * <dd>{@code p}\n     * <dd>{@code P}\n     * </dl>\n     *\n     * </blockquote>\n     *\n     * where <i>Sign</i>, <i>FloatingPointLiteral</i>,\n     * <i>HexNumeral</i>, <i>HexDigits</i>, <i>SignedInteger</i> and\n     * <i>FloatTypeSuffix</i> are as defined in the lexical structure\n     * sections of\n     * <cite>The Java Language Specification</cite>,\n     * except that underscores are not accepted between digits.\n     * If {@code s} does not have the form of\n     * a <i>FloatValue</i>, then a {@code NumberFormatException}\n     * is thrown. Otherwise, {@code s} is regarded as\n     * representing an exact decimal value in the usual\n     * \"computerized scientific notation\" or as an exact\n     * hexadecimal value; this exact numerical value is then\n     * conceptually converted to an \"infinitely precise\"\n     * binary value that is then rounded to type {@code double}\n     * by the usual round-to-nearest rule of IEEE 754 floating-point\n     * arithmetic, which includes preserving the sign of a zero\n     * value.\n     *\n     * Note that the round-to-nearest rule also implies overflow and\n     * underflow behaviour; if the exact value of {@code s} is large\n     * enough in magnitude (greater than or equal to ({@link\n     * #MAX_VALUE} + {@link Math#ulp(double) ulp(MAX_VALUE)}/2),\n     * rounding to {@code double} will result in an infinity and if the\n     * exact value of {@code s} is small enough in magnitude (less\n     * than or equal to {@link #MIN_VALUE}/2), rounding to float will\n     * result in a zero.\n     *\n     * Finally, after rounding a {@code Double} object representing\n     * this {@code double} value is returned.\n     *\n     * <p> To interpret localized string representations of a\n     * floating-point value, use subclasses of {@link\n     * java.text.NumberFormat}.\n     *\n     * <p>Note that trailing format specifiers, specifiers that\n     * determine the type of a floating-point literal\n     * ({@code 1.0f} is a {@code float} value;\n     * {@code 1.0d} is a {@code double} value), do\n     * <em>not</em> influence the results of this method.  In other\n     * words, the numerical value of the input string is converted\n     * directly to the target floating-point type.  The two-step\n     * sequence of conversions, string to {@code float} followed\n     * by {@code float} to {@code double}, is <em>not</em>\n     * equivalent to converting a string directly to\n     * {@code double}. For example, the {@code float}\n     * literal {@code 0.1f} is equal to the {@code double}\n     * value {@code 0.10000000149011612}; the {@code float}\n     * literal {@code 0.1f} represents a different numerical\n     * value than the {@code double} literal\n     * {@code 0.1}. (The numerical value 0.1 cannot be exactly\n     * represented in a binary floating-point number.)\n     *\n     * <p>To avoid calling this method on an invalid string and having\n     * a {@code NumberFormatException} be thrown, the regular\n     * expression below can be used to screen the input string:\n     *\n     * <pre>{@code\n     *  final String Digits     = \"(\\\\p{Digit}+)\";\n     *  final String HexDigits  = \"(\\\\p{XDigit}+)\";\n     *  // an exponent is 'e' or 'E' followed by an optionally\n     *  // signed decimal integer.\n     *  final String Exp        = \"[eE][+-]?\"+Digits;\n     *  final String fpRegex    =\n     *      (\"[\\\\x00-\\\\x20]*\"+  // Optional leading \"whitespace\"\n     *       \"[+-]?(\" + // Optional sign character\n     *       \"NaN|\" +           // \"NaN\" string\n     *       \"Infinity|\" +      // \"Infinity\" string\n     *\n     *       // A decimal floating-point string representing a finite positive\n     *       // number without a leading sign has at most five basic pieces:\n     *       // Digits . Digits ExponentPart FloatTypeSuffix\n     *       //\n     *       // Since this method allows integer-only strings as input\n     *       // in addition to strings of floating-point literals, the\n     *       // two sub-patterns below are simplifications of the grammar\n     *       // productions from section 3.10.2 of\n     *       // The Java Language Specification.\n     *\n     *       // Digits ._opt Digits_opt ExponentPart_opt FloatTypeSuffix_opt\n     *       \"(((\"+Digits+\"(\\\\.)?(\"+Digits+\"?)(\"+Exp+\")?)|\"+\n     *\n     *       // . Digits ExponentPart_opt FloatTypeSuffix_opt\n     *       \"(\\\\.(\"+Digits+\")(\"+Exp+\")?)|\"+\n     *\n     *       // Hexadecimal strings\n     *       \"((\" +\n     *        // 0[xX] HexDigits ._opt BinaryExponent FloatTypeSuffix_opt\n     *        \"(0[xX]\" + HexDigits + \"(\\\\.)?)|\" +\n     *\n     *        // 0[xX] HexDigits_opt . HexDigits BinaryExponent FloatTypeSuffix_opt\n     *        \"(0[xX]\" + HexDigits + \"?(\\\\.)\" + HexDigits + \")\" +\n     *\n     *        \")[pP][+-]?\" + Digits + \"))\" +\n     *       \"[fFdD]?))\" +\n     *       \"[\\\\x00-\\\\x20]*\");// Optional trailing \"whitespace\"\n     *\n     *  if (Pattern.matches(fpRegex, myString))\n     *      Double.valueOf(myString); // Will not throw NumberFormatException\n     *  else {\n     *      // Perform suitable alternative action\n     *  }\n     * }</pre>\n     *\n     * @param      s   the string to be parsed.\n     * @return     a {@code Double} object holding the value\n     *             represented by the {@code String} argument.\n     * @throws     NumberFormatException  if the string does not contain a\n     *             parsable number.\n     ",
    "links" : [ "java.lang.String#trim", "#MIN_VALUE", "#MAX_VALUE", "java.lang.Math#ulp(double)", "java.text.NumberFormat" ]
  }, {
    "name" : "public static Double valueOf(double d)",
    "returnType" : "Double",
    "comment" : "\n     * Returns a {@code Double} instance representing the specified\n     * {@code double} value.\n     * If a new {@code Double} instance is not required, this method\n     * should generally be used in preference to the constructor\n     * {@link #Double(double)}, as this method is likely to yield\n     * significantly better space and time performance by caching\n     * frequently requested values.\n     *\n     * @param  d a double value.\n     * @return a {@code Double} instance representing {@code d}.\n     * @since  1.5\n     ",
    "links" : [ "#Double(double)" ]
  }, {
    "name" : "public static double parseDouble(String s) throws NumberFormatException",
    "returnType" : "double",
    "comment" : "\n     * Returns a new {@code double} initialized to the value\n     * represented by the specified {@code String}, as performed\n     * by the {@code valueOf} method of class\n     * {@code Double}.\n     *\n     * @param  s   the string to be parsed.\n     * @return the {@code double} value represented by the string\n     *         argument.\n     * @throws NullPointerException  if the string is null\n     * @throws NumberFormatException if the string does not contain\n     *         a parsable {@code double}.\n     * @see    java.lang.Double#valueOf(String)\n     * @since 1.2\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isNaN(double v)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the specified number is a\n     * Not-a-Number (NaN) value, {@code false} otherwise.\n     *\n     * @param   v   the value to be tested.\n     * @return  {@code true} if the value of the argument is NaN;\n     *          {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isInfinite(double v)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the specified number is infinitely\n     * large in magnitude, {@code false} otherwise.\n     *\n     * @param   v   the value to be tested.\n     * @return  {@code true} if the value of the argument is positive\n     *          infinity or negative infinity; {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isFinite(double d)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the argument is a finite floating-point\n     * value; returns {@code false} otherwise (for NaN and infinity\n     * arguments).\n     *\n     * @param d the {@code double} value to be tested\n     * @return {@code true} if the argument is a finite\n     * floating-point value, {@code false} otherwise.\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isNaN()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if this {@code Double} value is\n     * a Not-a-Number (NaN), {@code false} otherwise.\n     *\n     * @return  {@code true} if the value represented by this object is\n     *          NaN; {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isInfinite()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if this {@code Double} value is\n     * infinitely large in magnitude, {@code false} otherwise.\n     *\n     * @return  {@code true} if the value represented by this object is\n     *          positive infinity or negative infinity;\n     *          {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "\n     * Returns a string representation of this {@code Double} object.\n     * The primitive {@code double} value represented by this\n     * object is converted to a string exactly as if by the method\n     * {@code toString} of one argument.\n     *\n     * @return  a {@code String} representation of this object.\n     * @see java.lang.Double#toString(double)\n     ",
    "links" : [ ]
  }, {
    "name" : "public byte byteValue()",
    "returnType" : "byte",
    "comment" : "\n     * Returns the value of this {@code Double} as a {@code byte}\n     * after a narrowing primitive conversion.\n     *\n     * @return  the {@code double} value represented by this object\n     *          converted to type {@code byte}\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     * @since 1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "public short shortValue()",
    "returnType" : "short",
    "comment" : "\n     * Returns the value of this {@code Double} as a {@code short}\n     * after a narrowing primitive conversion.\n     *\n     * @return  the {@code double} value represented by this object\n     *          converted to type {@code short}\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     * @since 1.1\n     ",
    "links" : [ ]
  }, {
    "name" : "public int intValue()",
    "returnType" : "int",
    "comment" : "\n     * Returns the value of this {@code Double} as an {@code int}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     *\n     * @return  the {@code double} value represented by this object\n     *          converted to type {@code int}\n     ",
    "links" : [ ]
  }, {
    "name" : "public long longValue()",
    "returnType" : "long",
    "comment" : "\n     * Returns the value of this {@code Double} as a {@code long}\n     * after a narrowing primitive conversion.\n     *\n     * @return  the {@code double} value represented by this object\n     *          converted to type {@code long}\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     ",
    "links" : [ ]
  }, {
    "name" : "public float floatValue()",
    "returnType" : "float",
    "comment" : "\n     * Returns the value of this {@code Double} as a {@code float}\n     * after a narrowing primitive conversion.\n     *\n     * @return  the {@code double} value represented by this object\n     *          converted to type {@code float}\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     * @since 1.0\n     ",
    "links" : [ ]
  }, {
    "name" : "public double doubleValue()",
    "returnType" : "double",
    "comment" : "\n     * Returns the {@code double} value of this {@code Double} object.\n     *\n     * @return the {@code double} value represented by this object\n     ",
    "links" : [ ]
  }, {
    "name" : "public int hashCode()",
    "returnType" : "int",
    "comment" : "\n     * Returns a hash code for this {@code Double} object. The\n     * result is the exclusive OR of the two halves of the\n     * {@code long} integer bit representation, exactly as\n     * produced by the method {@link #doubleToLongBits(double)}, of\n     * the primitive {@code double} value represented by this\n     * {@code Double} object. That is, the hash code is the value\n     * of the expression:\n     *\n     * <blockquote>\n     *  {@code (int)(v^(v>>>32))}\n     * </blockquote>\n     *\n     * where {@code v} is defined by:\n     *\n     * <blockquote>\n     *  {@code long v = Double.doubleToLongBits(this.doubleValue());}\n     * </blockquote>\n     *\n     * @return  a {@code hash code} value for this object.\n     ",
    "links" : [ "#doubleToLongBits(double)" ]
  }, {
    "name" : "public static int hashCode(double value)",
    "returnType" : "int",
    "comment" : "\n     * Returns a hash code for a {@code double} value; compatible with\n     * {@code Double.hashCode()}.\n     *\n     * @param value the value to hash\n     * @return a hash code value for a {@code double} value.\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean equals(Object obj)",
    "returnType" : "boolean",
    "comment" : "\n     * Compares this object against the specified object.  The result\n     * is {@code true} if and only if the argument is not\n     * {@code null} and is a {@code Double} object that\n     * represents a {@code double} that has the same value as the\n     * {@code double} represented by this object. For this\n     * purpose, two {@code double} values are considered to be\n     * the same if and only if the method {@link\n     * #doubleToLongBits(double)} returns the identical\n     * {@code long} value when applied to each.\n     *\n     * @apiNote\n     * This method is defined in terms of {@link\n     * #doubleToLongBits(double)} rather than the {@code ==} operator\n     * on {@code double} values since the {@code ==} operator does\n     * <em>not</em> define an equivalence relation and to satisfy the\n     * {@linkplain Object#equals equals contract} an equivalence\n     * relation must be implemented; see <a\n     * href=\"#equivalenceRelation\">this discussion</a> for details of\n     * floating-point equality and equivalence.\n     *\n     * @see java.lang.Double#doubleToLongBits(double)\n     * @jls 15.21.1 Numerical Equality Operators == and !=\n     ",
    "links" : [ "#doubleToLongBits(double)" ]
  }, {
    "name" : "public static long doubleToLongBits(double value)",
    "returnType" : "long",
    "comment" : "\n     * Returns a representation of the specified floating-point value\n     * according to the IEEE 754 floating-point \"double\n     * format\" bit layout.\n     *\n     * <p>Bit 63 (the bit that is selected by the mask\n     * {@code 0x8000000000000000L}) represents the sign of the\n     * floating-point number. Bits\n     * 62-52 (the bits that are selected by the mask\n     * {@code 0x7ff0000000000000L}) represent the exponent. Bits 51-0\n     * (the bits that are selected by the mask\n     * {@code 0x000fffffffffffffL}) represent the significand\n     * (sometimes called the mantissa) of the floating-point number.\n     *\n     * <p>If the argument is positive infinity, the result is\n     * {@code 0x7ff0000000000000L}.\n     *\n     * <p>If the argument is negative infinity, the result is\n     * {@code 0xfff0000000000000L}.\n     *\n     * <p>If the argument is NaN, the result is\n     * {@code 0x7ff8000000000000L}.\n     *\n     * <p>In all cases, the result is a {@code long} integer that, when\n     * given to the {@link #longBitsToDouble(long)} method, will produce a\n     * floating-point value the same as the argument to\n     * {@code doubleToLongBits} (except all NaN values are\n     * collapsed to a single \"canonical\" NaN value).\n     *\n     * @param   value   a {@code double} precision floating-point number.\n     * @return the bits that represent the floating-point number.\n     ",
    "links" : [ "#longBitsToDouble(long)" ]
  }, {
    "name" : "public static native long doubleToRawLongBits(double value)",
    "returnType" : "long",
    "comment" : "\n     * Returns a representation of the specified floating-point value\n     * according to the IEEE 754 floating-point \"double\n     * format\" bit layout, preserving Not-a-Number (NaN) values.\n     *\n     * <p>Bit 63 (the bit that is selected by the mask\n     * {@code 0x8000000000000000L}) represents the sign of the\n     * floating-point number. Bits\n     * 62-52 (the bits that are selected by the mask\n     * {@code 0x7ff0000000000000L}) represent the exponent. Bits 51-0\n     * (the bits that are selected by the mask\n     * {@code 0x000fffffffffffffL}) represent the significand\n     * (sometimes called the mantissa) of the floating-point number.\n     *\n     * <p>If the argument is positive infinity, the result is\n     * {@code 0x7ff0000000000000L}.\n     *\n     * <p>If the argument is negative infinity, the result is\n     * {@code 0xfff0000000000000L}.\n     *\n     * <p>If the argument is NaN, the result is the {@code long}\n     * integer representing the actual NaN value.  Unlike the\n     * {@code doubleToLongBits} method,\n     * {@code doubleToRawLongBits} does not collapse all the bit\n     * patterns encoding a NaN to a single \"canonical\" NaN\n     * value.\n     *\n     * <p>In all cases, the result is a {@code long} integer that,\n     * when given to the {@link #longBitsToDouble(long)} method, will\n     * produce a floating-point value the same as the argument to\n     * {@code doubleToRawLongBits}.\n     *\n     * @param   value   a {@code double} precision floating-point number.\n     * @return the bits that represent the floating-point number.\n     * @since 1.3\n     ",
    "links" : [ "#longBitsToDouble(long)" ]
  }, {
    "name" : "public static native double longBitsToDouble(long bits)",
    "returnType" : "double",
    "comment" : "\n     * Returns the {@code double} value corresponding to a given\n     * bit representation.\n     * The argument is considered to be a representation of a\n     * floating-point value according to the IEEE 754 floating-point\n     * \"double format\" bit layout.\n     *\n     * <p>If the argument is {@code 0x7ff0000000000000L}, the result\n     * is positive infinity.\n     *\n     * <p>If the argument is {@code 0xfff0000000000000L}, the result\n     * is negative infinity.\n     *\n     * <p>If the argument is any value in the range\n     * {@code 0x7ff0000000000001L} through\n     * {@code 0x7fffffffffffffffL} or in the range\n     * {@code 0xfff0000000000001L} through\n     * {@code 0xffffffffffffffffL}, the result is a NaN.  No IEEE\n     * 754 floating-point operation provided by Java can distinguish\n     * between two NaN values of the same type with different bit\n     * patterns.  Distinct values of NaN are only distinguishable by\n     * use of the {@code Double.doubleToRawLongBits} method.\n     *\n     * <p>In all other cases, let <i>s</i>, <i>e</i>, and <i>m</i> be three\n     * values that can be computed from the argument:\n     *\n     * <blockquote><pre>{@code\n     * int s = ((bits >> 63) == 0) ? 1 : -1;\n     * int e = (int)((bits >> 52) & 0x7ffL);\n     * long m = (e == 0) ?\n     *                 (bits & 0xfffffffffffffL) << 1 :\n     *                 (bits & 0xfffffffffffffL) | 0x10000000000000L;\n     * }</pre></blockquote>\n     *\n     * Then the floating-point result equals the value of the mathematical\n     * expression <i>s</i>&middot;<i>m</i>&middot;2<sup><i>e</i>-1075</sup>.\n     *\n     * <p>Note that this method may not be able to return a\n     * {@code double} NaN with exactly same bit pattern as the\n     * {@code long} argument.  IEEE 754 distinguishes between two\n     * kinds of NaNs, quiet NaNs and <i>signaling NaNs</i>.  The\n     * differences between the two kinds of NaN are generally not\n     * visible in Java.  Arithmetic operations on signaling NaNs turn\n     * them into quiet NaNs with a different, but often similar, bit\n     * pattern.  However, on some processors merely copying a\n     * signaling NaN also performs that conversion.  In particular,\n     * copying a signaling NaN to return it to the calling method\n     * may perform this conversion.  So {@code longBitsToDouble}\n     * may not be able to return a {@code double} with a\n     * signaling NaN bit pattern.  Consequently, for some\n     * {@code long} values,\n     * {@code doubleToRawLongBits(longBitsToDouble(start))} may\n     * <i>not</i> equal {@code start}.  Moreover, which\n     * particular bit patterns represent signaling NaNs is platform\n     * dependent; although all NaN bit patterns, quiet or signaling,\n     * must be in the NaN range identified above.\n     *\n     * @param   bits   any {@code long} integer.\n     * @return  the {@code double} floating-point value with the same\n     *          bit pattern.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int compareTo(Double anotherDouble)",
    "returnType" : "int",
    "comment" : "\n     * Compares two {@code Double} objects numerically.\n     *\n     * This method imposes a total order on {@code Double} objects\n     * with two differences compared to the incomplete order defined by\n     * the Java language numerical comparison operators ({@code <, <=,\n     * ==, >=, >}) on {@code double} values.\n     *\n     * <ul><li> A NaN is <em>unordered</em> with respect to other\n     *          values and unequal to itself under the comparison\n     *          operators.  This method chooses to define {@code\n     *          Double.NaN} to be equal to itself and greater than all\n     *          other {@code double} values (including {@code\n     *          Double.POSITIVE_INFINITY}).\n     *\n     *      <li> Positive zero and negative zero compare equal\n     *      numerically, but are distinct and distinguishable values.\n     *      This method chooses to define positive zero ({@code +0.0d}),\n     *      to be greater than negative zero ({@code -0.0d}).\n     * </ul>\n\n     * This ensures that the <i>natural ordering</i> of {@code Double}\n     * objects imposed by this method is <i>consistent with\n     * equals</i>; see <a href=\"#equivalenceRelation\">this\n     * discussion</a> for details of floating-point comparison and\n     * ordering.\n     *\n     * @param   anotherDouble   the {@code Double} to be compared.\n     * @return  the value {@code 0} if {@code anotherDouble} is\n     *          numerically equal to this {@code Double}; a value\n     *          less than {@code 0} if this {@code Double}\n     *          is numerically less than {@code anotherDouble};\n     *          and a value greater than {@code 0} if this\n     *          {@code Double} is numerically greater than\n     *          {@code anotherDouble}.\n     *\n     * @jls 15.20.1 Numerical Comparison Operators {@code <}, {@code <=}, {@code >}, and {@code >=}\n     * @since   1.2\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int compare(double d1, double d2)",
    "returnType" : "int",
    "comment" : "\n     * Compares the two specified {@code double} values. The sign\n     * of the integer value returned is the same as that of the\n     * integer that would be returned by the call:\n     * <pre>\n     *    new Double(d1).compareTo(new Double(d2))\n     * </pre>\n     *\n     * @param   d1        the first {@code double} to compare\n     * @param   d2        the second {@code double} to compare\n     * @return  the value {@code 0} if {@code d1} is\n     *          numerically equal to {@code d2}; a value less than\n     *          {@code 0} if {@code d1} is numerically less than\n     *          {@code d2}; and a value greater than {@code 0}\n     *          if {@code d1} is numerically greater than\n     *          {@code d2}.\n     * @since 1.4\n     ",
    "links" : [ ]
  }, {
    "name" : "public static double sum(double a, double b)",
    "returnType" : "double",
    "comment" : "\n     * Adds two {@code double} values together as per the + operator.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the sum of {@code a} and {@code b}\n     * @jls 4.2.4 Floating-Point Operations\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static double max(double a, double b)",
    "returnType" : "double",
    "comment" : "\n     * Returns the greater of two {@code double} values\n     * as if by calling {@link Math#max(double, double) Math.max}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the greater of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     ",
    "links" : [ "java.lang.Math#max(double" ]
  }, {
    "name" : "public static double min(double a, double b)",
    "returnType" : "double",
    "comment" : "\n     * Returns the smaller of two {@code double} values\n     * as if by calling {@link Math#min(double, double) Math.min}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the smaller of {@code a} and {@code b}.\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     ",
    "links" : [ "java.lang.Math#min(double" ]
  }, {
    "name" : "public Optional<Double> describeConstable()",
    "returnType" : "Optional<Double>",
    "comment" : "\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain Double} instance\n     * @since 12\n     * @hide\n     ",
    "links" : [ "java.util.Optional" ]
  }, {
    "name" : "public Double resolveConstantDesc(MethodHandles.Lookup lookup)",
    "returnType" : "Double",
    "comment" : "\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain Double} instance\n     * @since 12\n     * @hide\n     ",
    "links" : [ "java.lang.constant.ConstantDesc" ]
  } ],
  "methodNames" : [ "public static String toString(double d)", "public static String toHexString(double d)", "public static Double valueOf(String s) throws NumberFormatException", "public static Double valueOf(double d)", "public static double parseDouble(String s) throws NumberFormatException", "public static boolean isNaN(double v)", "public static boolean isInfinite(double v)", "public static boolean isFinite(double d)", "public boolean isNaN()", "public boolean isInfinite()", "public String toString()", "public byte byteValue()", "public short shortValue()", "public int intValue()", "public long longValue()", "public float floatValue()", "public double doubleValue()", "public int hashCode()", "public static int hashCode(double value)", "public boolean equals(Object obj)", "public static long doubleToLongBits(double value)", "public static native long doubleToRawLongBits(double value)", "public static native double longBitsToDouble(long bits)", "public int compareTo(Double anotherDouble)", "public static int compare(double d1, double d2)", "public static double sum(double a, double b)", "public static double max(double a, double b)", "public static double min(double a, double b)", "public Optional<Double> describeConstable()", "public Double resolveConstantDesc(MethodHandles.Lookup lookup)" ],
  "variableNames" : [ "POSITIVE_INFINITY", "NEGATIVE_INFINITY", "NaN", "MAX_VALUE", "MIN_NORMAL", "MIN_VALUE", "MAX_EXPONENT", "MIN_EXPONENT", "SIZE", "PRECISION", "BYTES", "TYPE", "value", "serialVersionUID" ]
}