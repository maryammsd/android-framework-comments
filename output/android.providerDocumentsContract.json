{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/provider/DocumentsContract.java",
  "packageName" : "android.provider",
  "className" : "DocumentsContract",
  "comment" : "\n * Defines the contract between a documents provider and the platform.\n * <p>\n * To create a document provider, extend {@link DocumentsProvider}, which\n * provides a foundational implementation of this contract.\n * <p>\n * All client apps must hold a valid URI permission grant to access documents,\n * typically issued when a user makes a selection through\n * {@link Intent#ACTION_OPEN_DOCUMENT}, {@link Intent#ACTION_CREATE_DOCUMENT},\n * or {@link Intent#ACTION_OPEN_DOCUMENT_TREE}.\n *\n * @see DocumentsProvider\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PROVIDER_INTERFACE",
    "type" : "String",
    "comment" : "\n     * Intent action used to identify {@link DocumentsProvider} instances. This\n     * is used in the {@code <intent-filter>} of a {@code <provider>}.\n     ",
    "links" : [ "DocumentsProvider" ]
  }, {
    "name" : "EXTRA_PACKAGE_NAME",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_SHOW_ADVANCED",
    "type" : "String",
    "comment" : "\n     * The value is decide whether to show advance mode or not.\n     * If the value is true, the local/device storage root must be\n     * visible in DocumentsUI.\n     *\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_TARGET_URI",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "QUERY_ARG_DISPLAY_NAME",
    "type" : "String",
    "comment" : "\n     * Key for {@link DocumentsProvider} to query display name is matched.\n     * The match of display name is partial matching and case-insensitive.\n     * Ex: The value is \"o\", the display name of the results will contain\n     * both \"foo\" and \"Open\".\n     *\n     * @see DocumentsProvider#querySearchDocuments(String, String[],\n     *      Bundle)\n     ",
    "links" : [ "DocumentsProvider" ]
  }, {
    "name" : "QUERY_ARG_MIME_TYPES",
    "type" : "String",
    "comment" : "\n     * Key for {@link DocumentsProvider} to query mime types is matched.\n     * The value is a string array, it can support different mime types.\n     * Each items will be treated as \"OR\" condition. Ex: {\"image/*\" ,\n     * \"video/*\"}. The mime types of the results will contain both image\n     * type and video type.\n     *\n     * @see DocumentsProvider#querySearchDocuments(String, String[],\n     *      Bundle)\n     ",
    "links" : [ "DocumentsProvider" ]
  }, {
    "name" : "QUERY_ARG_FILE_SIZE_OVER",
    "type" : "String",
    "comment" : "\n     * Key for {@link DocumentsProvider} to query the file size in bytes is\n     * larger than the value.\n     *\n     * @see DocumentsProvider#querySearchDocuments(String, String[],\n     *      Bundle)\n     ",
    "links" : [ "DocumentsProvider" ]
  }, {
    "name" : "QUERY_ARG_LAST_MODIFIED_AFTER",
    "type" : "String",
    "comment" : "\n     * Key for {@link DocumentsProvider} to query the last modified time\n     * is newer than the value. The unit is in milliseconds since\n     * January 1, 1970 00:00:00.0 UTC.\n     *\n     * @see DocumentsProvider#querySearchDocuments(String, String[],\n     *      Bundle)\n     * @see Document#COLUMN_LAST_MODIFIED\n     ",
    "links" : [ "DocumentsProvider" ]
  }, {
    "name" : "QUERY_ARG_EXCLUDE_MEDIA",
    "type" : "String",
    "comment" : "\n     * Key for {@link DocumentsProvider} to decide whether the files that\n     * have been added to MediaStore should be excluded. If the value is\n     * true, exclude them. Otherwise, include them.\n     *\n     * @see DocumentsProvider#querySearchDocuments(String, String[],\n     *      Bundle)\n     ",
    "links" : [ "DocumentsProvider" ]
  }, {
    "name" : "EXTRA_INITIAL_URI",
    "type" : "String",
    "comment" : "\n     * Sets the desired initial location visible to user when file chooser is shown.\n     *\n     * <p>Applicable to {@link Intent} with actions:\n     * <ul>\n     *      <li>{@link Intent#ACTION_OPEN_DOCUMENT}</li>\n     *      <li>{@link Intent#ACTION_CREATE_DOCUMENT}</li>\n     *      <li>{@link Intent#ACTION_OPEN_DOCUMENT_TREE}</li>\n     * </ul>\n     *\n     * <p>Location should specify a document URI or a tree URI with document ID. If\n     * this URI identifies a non-directory, document navigator will attempt to use the parent\n     * of the document as the initial location.\n     *\n     * <p>The initial location is system specific if this extra is missing or document navigator\n     * failed to locate the desired initial location.\n     ",
    "links" : [ "Intent", "Intent#ACTION_OPEN_DOCUMENT", "Intent#ACTION_CREATE_DOCUMENT", "Intent#ACTION_OPEN_DOCUMENT_TREE" ]
  }, {
    "name" : "EXTRA_EXCLUDE_SELF",
    "type" : "String",
    "comment" : "\n     * Set this in a DocumentsUI intent to cause a package's own roots to be\n     * excluded from the roots list.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_ORIENTATION",
    "type" : "String",
    "comment" : "\n     * An extra number of degrees that an image should be rotated during the\n     * decode process to be presented correctly.\n     *\n     * @see AssetFileDescriptor#getExtras()\n     * @see android.provider.MediaStore.Images.ImageColumns#ORIENTATION\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PROMPT",
    "type" : "String",
    "comment" : "\n     * Overrides the default prompt text in DocumentsUI when set in an intent.\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_DOCUMENT_SETTINGS",
    "type" : "String",
    "comment" : "\n     * Action of intent issued by DocumentsUI when user wishes to open/configure/manage a particular\n     * document in the provider application.\n     *\n     * <p>When issued, the intent will include the URI of the document as the intent data.\n     *\n     * <p>A provider wishing to provide support for this action should do two things.\n     * <li>Add an {@code <intent-filter>} matching this action.\n     * <li>When supplying information in {@link DocumentsProvider#queryChildDocuments}, include\n     * {@link Document#FLAG_SUPPORTS_SETTINGS} in the flags for each document that supports\n     * settings.\n     ",
    "links" : [ "DocumentsProvider#queryChildDocuments", "Document#FLAG_SUPPORTS_SETTINGS" ]
  }, {
    "name" : "ACTION_MANAGE_DOCUMENT",
    "type" : "String",
    "comment" : "\n     * The action to manage document in Downloads root in DocumentsUI.\n     *  {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_DOCUMENT_ROOT_SETTINGS",
    "type" : "String",
    "comment" : "\n     * The action to launch the settings of this root.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTERNAL_STORAGE_PROVIDER_AUTHORITY",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTERNAL_STORAGE_PRIMARY_EMULATED_ROOT_ID",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PACKAGE_DOCUMENTS_UI",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "METADATA_TYPES",
    "type" : "String",
    "comment" : "\n     * Get string array identifies the type or types of metadata returned\n     * using DocumentsContract#getDocumentMetadata.\n     *\n     * @see #getDocumentMetadata(ContentResolver, Uri)\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_EXIF",
    "type" : "String",
    "comment" : "\n     * Get Exif information using DocumentsContract#getDocumentMetadata.\n     *\n     * @see #getDocumentMetadata(ContentResolver, Uri)\n     ",
    "links" : [ ]
  }, {
    "name" : "METADATA_TREE_COUNT",
    "type" : "String",
    "comment" : "\n     * Get total count of all documents currently stored under the given\n     * directory tree. Only valid for {@link Document#MIME_TYPE_DIR} documents.\n     *\n     * @see #getDocumentMetadata(ContentResolver, Uri)\n     ",
    "links" : [ "Document#MIME_TYPE_DIR" ]
  }, {
    "name" : "METADATA_TREE_SIZE",
    "type" : "String",
    "comment" : "\n     * Get total size of all documents currently stored under the given\n     * directory tree. Only valid for {@link Document#MIME_TYPE_DIR} documents.\n     *\n     * @see #getDocumentMetadata(ContentResolver, Uri)\n     ",
    "links" : [ "Document#MIME_TYPE_DIR" ]
  }, {
    "name" : "EXTRA_LOADING",
    "type" : "String",
    "comment" : "\n     * Optional boolean flag included in a directory {@link Cursor#getExtras()}\n     * indicating that a document provider is still loading data. For example, a\n     * provider has returned some results, but is still waiting on an\n     * outstanding network request. The provider must send a content changed\n     * notification when loading is finished.\n     *\n     * @see ContentResolver#notifyChange(Uri, android.database.ContentObserver,\n     *      boolean)\n     ",
    "links" : [ "Cursor#getExtras" ]
  }, {
    "name" : "EXTRA_INFO",
    "type" : "String",
    "comment" : "\n     * Optional string included in a directory {@link Cursor#getExtras()}\n     * providing an informational message that should be shown to a user. For\n     * example, a provider may wish to indicate that not all documents are\n     * available.\n     ",
    "links" : [ "Cursor#getExtras" ]
  }, {
    "name" : "EXTRA_ERROR",
    "type" : "String",
    "comment" : "\n     * Optional string included in a directory {@link Cursor#getExtras()}\n     * providing an error message that should be shown to a user. For example, a\n     * provider may wish to indicate that a network error occurred. The user may\n     * choose to retry, resulting in a new query.\n     ",
    "links" : [ "Cursor#getExtras" ]
  }, {
    "name" : "EXTRA_RESULT",
    "type" : "String",
    "comment" : "\n     * Optional result (I'm thinking boolean) answer to a question.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "METHOD_CREATE_DOCUMENT",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "METHOD_RENAME_DOCUMENT",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "METHOD_DELETE_DOCUMENT",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "METHOD_COPY_DOCUMENT",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "METHOD_MOVE_DOCUMENT",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "METHOD_IS_CHILD_DOCUMENT",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "METHOD_REMOVE_DOCUMENT",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "METHOD_EJECT_ROOT",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "METHOD_FIND_DOCUMENT_PATH",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "METHOD_CREATE_WEB_LINK_INTENT",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "METHOD_GET_DOCUMENT_METADATA",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PARENT_URI",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_URI",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_URI_PERMISSIONS",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_OPTIONS",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PATH_ROOT",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PATH_RECENT",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PATH_DOCUMENT",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PATH_CHILDREN",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PATH_SEARCH",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PATH_TREE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PARAM_QUERY",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PARAM_MANAGE",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static Uri buildRootsUri(String authority)",
    "returnType" : "Uri",
    "comment" : "\n     * Build URI representing the roots of a document provider. When queried, a\n     * provider will return one or more rows with columns defined by\n     * {@link Root}.\n     *\n     * @see DocumentsProvider#queryRoots(String[])\n     ",
    "links" : [ "Root" ]
  }, {
    "name" : "public static Uri buildRootUri(String authority, String rootId)",
    "returnType" : "Uri",
    "comment" : "\n     * Build URI representing the given {@link Root#COLUMN_ROOT_ID} in a\n     * document provider.\n     *\n     * @see #getRootId(Uri)\n     ",
    "links" : [ "Root#COLUMN_ROOT_ID" ]
  }, {
    "name" : "public static Uri buildRecentDocumentsUri(String authority, String rootId)",
    "returnType" : "Uri",
    "comment" : "\n     * Build URI representing the recently modified documents of a specific root\n     * in a document provider. When queried, a provider will return zero or more\n     * rows with columns defined by {@link Document}.\n     *\n     * @see DocumentsProvider#queryRecentDocuments(String, String[])\n     * @see #getRootId(Uri)\n     ",
    "links" : [ "Document" ]
  }, {
    "name" : "public static Uri buildTreeDocumentUri(String authority, String documentId)",
    "returnType" : "Uri",
    "comment" : "\n     * Build URI representing access to descendant documents of the given\n     * {@link Document#COLUMN_DOCUMENT_ID}.\n     *\n     * @see #getTreeDocumentId(Uri)\n     ",
    "links" : [ "Document#COLUMN_DOCUMENT_ID" ]
  }, {
    "name" : "public static Uri buildDocumentUri(String authority, String documentId)",
    "returnType" : "Uri",
    "comment" : "\n     * Build URI representing the target {@link Document#COLUMN_DOCUMENT_ID} in\n     * a document provider. When queried, a provider will return a single row\n     * with columns defined by {@link Document}.\n     *\n     * @see DocumentsProvider#queryDocument(String, String[])\n     * @see #getDocumentId(Uri)\n     ",
    "links" : [ "Document#COLUMN_DOCUMENT_ID", "Document" ]
  }, {
    "name" : "public static Uri buildDocumentUriAsUser(@NonNull String authority, @NonNull String documentId, @NonNull UserHandle user)",
    "returnType" : "Uri",
    "comment" : "\n     * Builds URI as described in {@link #buildDocumentUri(String, String)}, but such that it will\n     * be associated with the given user.\n     *\n     * @hide\n     ",
    "links" : [ "#buildDocumentUri" ]
  }, {
    "name" : "public static Uri buildBaseDocumentUri(String authority)",
    "returnType" : "Uri",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "private static Uri.Builder getBaseDocumentUriBuilder(String authority)",
    "returnType" : "Uri.Builder",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static Uri buildDocumentUriUsingTree(Uri treeUri, String documentId)",
    "returnType" : "Uri",
    "comment" : "\n     * Build URI representing the target {@link Document#COLUMN_DOCUMENT_ID} in\n     * a document provider. When queried, a provider will return a single row\n     * with columns defined by {@link Document}.\n     * <p>\n     * However, instead of directly accessing the target document, the returned\n     * URI will leverage access granted through a subtree URI, typically\n     * returned by {@link Intent#ACTION_OPEN_DOCUMENT_TREE}. The target document\n     * must be a descendant (child, grandchild, etc) of the subtree.\n     * <p>\n     * This is typically used to access documents under a user-selected\n     * directory tree, since it doesn't require the user to separately confirm\n     * each new document access.\n     *\n     * @param treeUri the subtree to leverage to gain access to the target\n     *            document. The target directory must be a descendant of this\n     *            subtree.\n     * @param documentId the target document, which the caller may not have\n     *            direct access to.\n     * @see Intent#ACTION_OPEN_DOCUMENT_TREE\n     * @see DocumentsProvider#isChildDocument(String, String)\n     * @see #buildDocumentUri(String, String)\n     ",
    "links" : [ "Document#COLUMN_DOCUMENT_ID", "Document", "Intent#ACTION_OPEN_DOCUMENT_TREE" ]
  }, {
    "name" : "public static Uri buildDocumentUriMaybeUsingTree(Uri baseUri, String documentId)",
    "returnType" : "Uri",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static Uri buildChildDocumentsUri(String authority, String parentDocumentId)",
    "returnType" : "Uri",
    "comment" : "\n     * Build URI representing the children of the target directory in a document\n     * provider. When queried, a provider will return zero or more rows with\n     * columns defined by {@link Document}.\n     *\n     * @param parentDocumentId the document to return children for, which must\n     *            be a directory with MIME type of\n     *            {@link Document#MIME_TYPE_DIR}.\n     * @see DocumentsProvider#queryChildDocuments(String, String[], String)\n     * @see #getDocumentId(Uri)\n     ",
    "links" : [ "Document", "Document#MIME_TYPE_DIR" ]
  }, {
    "name" : "public static Uri buildChildDocumentsUriUsingTree(Uri treeUri, String parentDocumentId)",
    "returnType" : "Uri",
    "comment" : "\n     * Build URI representing the children of the target directory in a document\n     * provider. When queried, a provider will return zero or more rows with\n     * columns defined by {@link Document}.\n     * <p>\n     * However, instead of directly accessing the target directory, the returned\n     * URI will leverage access granted through a subtree URI, typically\n     * returned by {@link Intent#ACTION_OPEN_DOCUMENT_TREE}. The target\n     * directory must be a descendant (child, grandchild, etc) of the subtree.\n     * <p>\n     * This is typically used to access documents under a user-selected\n     * directory tree, since it doesn't require the user to separately confirm\n     * each new document access.\n     *\n     * @param treeUri the subtree to leverage to gain access to the target\n     *            document. The target directory must be a descendant of this\n     *            subtree.\n     * @param parentDocumentId the document to return children for, which the\n     *            caller may not have direct access to, and which must be a\n     *            directory with MIME type of {@link Document#MIME_TYPE_DIR}.\n     * @see Intent#ACTION_OPEN_DOCUMENT_TREE\n     * @see DocumentsProvider#isChildDocument(String, String)\n     * @see #buildChildDocumentsUri(String, String)\n     ",
    "links" : [ "Document", "Intent#ACTION_OPEN_DOCUMENT_TREE", "Document#MIME_TYPE_DIR" ]
  }, {
    "name" : "public static Uri buildSearchDocumentsUri(String authority, String rootId, String query)",
    "returnType" : "Uri",
    "comment" : "\n     * Build URI representing a search for matching documents under a specific\n     * root in a document provider. When queried, a provider will return zero or\n     * more rows with columns defined by {@link Document}.\n     *\n     * @see DocumentsProvider#querySearchDocuments(String, String, String[])\n     * @see #getRootId(Uri)\n     * @see #getSearchDocumentsQuery(Uri)\n     ",
    "links" : [ "Document" ]
  }, {
    "name" : "public static boolean matchSearchQueryArguments(Bundle queryArgs, String displayName, String mimeType, long lastModified, long size)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the values match the query arguments.\n     *\n     * @param queryArgs the query arguments\n     * @param displayName the display time to check against\n     * @param mimeType the mime type to check against\n     * @param lastModified the last modified time to check against\n     * @param size the size to check against\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String[] getHandledQueryArguments(Bundle queryArgs)",
    "returnType" : "String[]",
    "comment" : "\n     * Get the handled query arguments from the query bundle. The handled arguments are\n     * {@link DocumentsContract#QUERY_ARG_EXCLUDE_MEDIA},\n     * {@link DocumentsContract#QUERY_ARG_DISPLAY_NAME},\n     * {@link DocumentsContract#QUERY_ARG_MIME_TYPES},\n     * {@link DocumentsContract#QUERY_ARG_FILE_SIZE_OVER} and\n     * {@link DocumentsContract#QUERY_ARG_LAST_MODIFIED_AFTER}.\n     *\n     * @param queryArgs the query arguments to be parsed.\n     * @return the handled query arguments\n     * @hide\n     ",
    "links" : [ "DocumentsContract#QUERY_ARG_EXCLUDE_MEDIA", "DocumentsContract#QUERY_ARG_DISPLAY_NAME", "DocumentsContract#QUERY_ARG_MIME_TYPES", "DocumentsContract#QUERY_ARG_FILE_SIZE_OVER", "DocumentsContract#QUERY_ARG_LAST_MODIFIED_AFTER" ]
  }, {
    "name" : "public static boolean isDocumentUri(Context context, @Nullable Uri uri)",
    "returnType" : "boolean",
    "comment" : "\n     * Test if the given URI represents a {@link Document} backed by a\n     * {@link DocumentsProvider}.\n     *\n     * @see #buildDocumentUri(String, String)\n     * @see #buildDocumentUriUsingTree(Uri, String)\n     ",
    "links" : [ "Document", "DocumentsProvider" ]
  }, {
    "name" : "public static boolean isRootsUri(@NonNull Context context, @Nullable Uri uri)",
    "returnType" : "boolean",
    "comment" : "\n     * Test if the given URI represents all roots of the authority\n     * backed by {@link DocumentsProvider}.\n     *\n     * @see #buildRootsUri(String)\n     ",
    "links" : [ "DocumentsProvider" ]
  }, {
    "name" : "public static boolean isRootUri(@NonNull Context context, @Nullable Uri uri)",
    "returnType" : "boolean",
    "comment" : "\n     * Test if the given URI represents specific root backed by {@link DocumentsProvider}.\n     *\n     * @see #buildRootUri(String, String)\n     ",
    "links" : [ "DocumentsProvider" ]
  }, {
    "name" : "public static boolean isContentUri(@Nullable Uri uri)",
    "returnType" : "boolean",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isTreeUri(Uri uri)",
    "returnType" : "boolean",
    "comment" : "\n     * Test if the given URI represents a {@link Document} tree.\n     *\n     * @see #buildTreeDocumentUri(String, String)\n     * @see #getTreeDocumentId(Uri)\n     ",
    "links" : [ "Document" ]
  }, {
    "name" : "private static boolean isRootUri(Context context, @Nullable Uri uri, int pathSize)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean isDocumentsProvider(Context context, String authority)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static String getRootId(Uri rootUri)",
    "returnType" : "String",
    "comment" : "\n     * Extract the {@link Root#COLUMN_ROOT_ID} from the given URI.\n     ",
    "links" : [ "Root#COLUMN_ROOT_ID" ]
  }, {
    "name" : "public static String getDocumentId(Uri documentUri)",
    "returnType" : "String",
    "comment" : "\n     * Extract the {@link Document#COLUMN_DOCUMENT_ID} from the given URI.\n     *\n     * @see #isDocumentUri(Context, Uri)\n     ",
    "links" : [ "Document#COLUMN_DOCUMENT_ID" ]
  }, {
    "name" : "public static String getTreeDocumentId(Uri documentUri)",
    "returnType" : "String",
    "comment" : "\n     * Extract the via {@link Document#COLUMN_DOCUMENT_ID} from the given URI.\n     ",
    "links" : [ "Document#COLUMN_DOCUMENT_ID" ]
  }, {
    "name" : "public static String getSearchDocumentsQuery(Uri searchDocumentsUri)",
    "returnType" : "String",
    "comment" : "\n     * Extract the search query from a URI built by\n     * {@link #buildSearchDocumentsUri(String, String, String)}.\n     ",
    "links" : [ "#buildSearchDocumentsUri" ]
  }, {
    "name" : "public static String getSearchDocumentsQuery(@NonNull Bundle bundle)",
    "returnType" : "String",
    "comment" : "\n     * Extract the search query from a Bundle\n     * {@link #QUERY_ARG_DISPLAY_NAME}.\n     * {@hide}\n     ",
    "links" : [ "#QUERY_ARG_DISPLAY_NAME" ]
  }, {
    "name" : "public static Uri setManageMode(@NonNull Uri uri)",
    "returnType" : "Uri",
    "comment" : "\n     * Build URI that append the query parameter {@link PARAM_MANAGE} to\n     * enable the manage mode.\n     * @see DocumentsProvider#queryChildDocumentsForManage(String parentDocId, String[], String)\n     * {@hide}\n     ",
    "links" : [ "PARAM_MANAGE" ]
  }, {
    "name" : "public static boolean isManageMode(@NonNull Uri uri)",
    "returnType" : "boolean",
    "comment" : "\n     * Extract the manage mode from a URI built by\n     * {@link #setManageMode(Uri)}.\n     * {@hide}\n     ",
    "links" : [ "#setManageMode" ]
  }, {
    "name" : "public static Bitmap getDocumentThumbnail(@NonNull ContentResolver content, @NonNull Uri documentUri, @NonNull Point size, @Nullable CancellationSignal signal) throws FileNotFoundException",
    "returnType" : "Bitmap",
    "comment" : "\n     * Return thumbnail representing the document at the given URI. Callers are\n     * responsible for their own in-memory caching.\n     *\n     * @param documentUri document to return thumbnail for, which must have\n     *            {@link Document#FLAG_SUPPORTS_THUMBNAIL} set.\n     * @param size optimal thumbnail size desired. A provider may return a\n     *            thumbnail of a different size, but never more than double the\n     *            requested size.\n     * @param signal signal used to indicate if caller is no longer interested\n     *            in the thumbnail.\n     * @return decoded thumbnail, or {@code null} if problem was encountered.\n     * @see DocumentsProvider#openDocumentThumbnail(String, Point,\n     *      android.os.CancellationSignal)\n     ",
    "links" : [ "Document#FLAG_SUPPORTS_THUMBNAIL" ]
  }, {
    "name" : "public static Uri createDocument(@NonNull ContentResolver content, @NonNull Uri parentDocumentUri, @NonNull String mimeType, @NonNull String displayName) throws FileNotFoundException",
    "returnType" : "Uri",
    "comment" : "\n     * Create a new document with given MIME type and display name.\n     *\n     * @param parentDocumentUri directory with {@link Document#FLAG_DIR_SUPPORTS_CREATE}\n     * @param mimeType MIME type of new document\n     * @param displayName name of new document\n     * @return newly created document, or {@code null} if failed\n     ",
    "links" : [ "Document#FLAG_DIR_SUPPORTS_CREATE" ]
  }, {
    "name" : "public static boolean isChildDocument(@NonNull ContentResolver content, @NonNull Uri parentDocumentUri, @NonNull Uri childDocumentUri) throws FileNotFoundException",
    "returnType" : "boolean",
    "comment" : "\n     * Test if a document is descendant (child, grandchild, etc) from the given\n     * parent.\n     *\n     * @param parentDocumentUri parent to verify against.\n     * @param childDocumentUri child to verify.\n     * @return if given document is a descendant of the given parent.\n     * @see Root#FLAG_SUPPORTS_IS_CHILD\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Uri renameDocument(@NonNull ContentResolver content, @NonNull Uri documentUri, @NonNull String displayName) throws FileNotFoundException",
    "returnType" : "Uri",
    "comment" : "\n     * Change the display name of an existing document.\n     * <p>\n     * If the underlying provider needs to create a new\n     * {@link Document#COLUMN_DOCUMENT_ID} to represent the updated display\n     * name, that new document is returned and the original document is no\n     * longer valid. Otherwise, the original document is returned.\n     *\n     * @param documentUri document with {@link Document#FLAG_SUPPORTS_RENAME}\n     * @param displayName updated name for document\n     * @return the existing or new document after the rename, or {@code null} if\n     *         failed.\n     ",
    "links" : [ "Document#COLUMN_DOCUMENT_ID", "Document#FLAG_SUPPORTS_RENAME" ]
  }, {
    "name" : "public static boolean deleteDocument(@NonNull ContentResolver content, @NonNull Uri documentUri) throws FileNotFoundException",
    "returnType" : "boolean",
    "comment" : "\n     * Delete the given document.\n     *\n     * @param documentUri document with {@link Document#FLAG_SUPPORTS_DELETE}\n     * @return if the document was deleted successfully.\n     ",
    "links" : [ "Document#FLAG_SUPPORTS_DELETE" ]
  }, {
    "name" : "public static Uri copyDocument(@NonNull ContentResolver content, @NonNull Uri sourceDocumentUri, @NonNull Uri targetParentDocumentUri) throws FileNotFoundException",
    "returnType" : "Uri",
    "comment" : "\n     * Copies the given document.\n     *\n     * @param sourceDocumentUri document with {@link Document#FLAG_SUPPORTS_COPY}\n     * @param targetParentDocumentUri document which will become a parent of the source\n     *         document's copy.\n     * @return the copied document, or {@code null} if failed.\n     ",
    "links" : [ "Document#FLAG_SUPPORTS_COPY" ]
  }, {
    "name" : "public static Uri moveDocument(@NonNull ContentResolver content, @NonNull Uri sourceDocumentUri, @NonNull Uri sourceParentDocumentUri, @NonNull Uri targetParentDocumentUri) throws FileNotFoundException",
    "returnType" : "Uri",
    "comment" : "\n     * Moves the given document under a new parent.\n     *\n     * @param sourceDocumentUri document with {@link Document#FLAG_SUPPORTS_MOVE}\n     * @param sourceParentDocumentUri parent document of the document to move.\n     * @param targetParentDocumentUri document which will become a new parent of the source\n     *         document.\n     * @return the moved document, or {@code null} if failed.\n     ",
    "links" : [ "Document#FLAG_SUPPORTS_MOVE" ]
  }, {
    "name" : "public static boolean removeDocument(@NonNull ContentResolver content, @NonNull Uri documentUri, @NonNull Uri parentDocumentUri) throws FileNotFoundException",
    "returnType" : "boolean",
    "comment" : "\n     * Removes the given document from a parent directory.\n     *\n     * <p>In contrast to {@link #deleteDocument} it requires specifying the parent.\n     * This method is especially useful if the document can be in multiple parents.\n     *\n     * @param documentUri document with {@link Document#FLAG_SUPPORTS_REMOVE}\n     * @param parentDocumentUri parent document of the document to remove.\n     * @return true if the document was removed successfully.\n     ",
    "links" : [ "#deleteDocument", "Document#FLAG_SUPPORTS_REMOVE" ]
  }, {
    "name" : "public static void ejectRoot(@NonNull ContentResolver content, @NonNull Uri rootUri)",
    "returnType" : "void",
    "comment" : "\n     * Ejects the given root. It throws {@link IllegalStateException} when ejection failed.\n     *\n     * @param rootUri root with {@link Root#FLAG_SUPPORTS_EJECT} to be ejected\n     ",
    "links" : [ "IllegalStateException", "Root#FLAG_SUPPORTS_EJECT" ]
  }, {
    "name" : "public static Bundle getDocumentMetadata(@NonNull ContentResolver content, @NonNull Uri documentUri) throws FileNotFoundException",
    "returnType" : "Bundle",
    "comment" : "\n     * Returns metadata associated with the document. The type of metadata returned\n     * is specific to the document type. For example the data returned for an image\n     * file will likely consist primarily or solely of EXIF metadata.\n     *\n     * <p>The returned {@link Bundle} will contain zero or more entries depending\n     * on the type of data supported by the document provider.\n     *\n     * <ol>\n     * <li>A {@link DocumentsContract#METADATA_TYPES} containing a {@code String[]} value.\n     *     The string array identifies the type or types of metadata returned. Each\n     *     value in the can be used to access a {@link Bundle} of data\n     *     containing that type of data.\n     * <li>An entry each for each type of returned metadata. Each set of metadata is\n     *     itself represented as a bundle and accessible via a string key naming\n     *     the type of data.\n     * </ol>\n     *\n     * <p>Example:\n     * <p><pre><code>\n     *     Bundle metadata = DocumentsContract.getDocumentMetadata(client, imageDocUri, tags);\n     *     if (metadata.containsKey(DocumentsContract.METADATA_EXIF)) {\n     *         Bundle exif = metadata.getBundle(DocumentsContract.METADATA_EXIF);\n     *         int imageLength = exif.getInt(ExifInterface.TAG_IMAGE_LENGTH);\n     *     }\n     * </code></pre>\n     *\n     * @param documentUri a Document URI\n     * @return a Bundle of Bundles.\n     ",
    "links" : [ "Bundle", "DocumentsContract#METADATA_TYPES", "Bundle" ]
  }, {
    "name" : "public static Path findDocumentPath(@NonNull ContentResolver content, @NonNull Uri treeUri) throws FileNotFoundException",
    "returnType" : "Path",
    "comment" : "\n     * Finds the canonical path from the top of the document tree.\n     *\n     * The {@link Path#getPath()} of the return value contains the document ID\n     * of all documents along the path from the top the document tree to the\n     * requested document, both inclusive.\n     *\n     * The {@link Path#getRootId()} of the return value returns {@code null}.\n     *\n     * @param treeUri treeUri of the document which path is requested.\n     * @return the path of the document, or {@code null} if failed.\n     * @see DocumentsProvider#findDocumentPath(String, String)\n     ",
    "links" : [ "Path#getPath", "Path#getRootId" ]
  }, {
    "name" : "public static IntentSender createWebLinkIntent(@NonNull ContentResolver content, @NonNull Uri uri, @Nullable Bundle options) throws FileNotFoundException",
    "returnType" : "IntentSender",
    "comment" : "\n     * Creates an intent for obtaining a web link for the specified document.\n     *\n     * <p>Note, that due to internal limitations, if there is already a web link\n     * intent created for the specified document but with different options,\n     * then it may be overridden.\n     *\n     * <p>Providers are required to show confirmation UI for all new permissions granted\n     * for the linked document.\n     *\n     * <p>If list of recipients is known, then it should be passed in options as\n     * {@link Intent#EXTRA_EMAIL} as a list of email addresses. Note, that\n     * this is just a hint for the provider, which can ignore the list. In either\n     * case the provider is required to show a UI for letting the user confirm\n     * any new permission grants.\n     *\n     * <p>Note, that the entire <code>options</code> bundle will be sent to the provider\n     * backing the passed <code>uri</code>. Make sure that you trust the provider\n     * before passing any sensitive information.\n     *\n     * <p>Since this API may show a UI, it cannot be called from background.\n     *\n     * <p>In order to obtain the Web Link use code like this:\n     * <pre><code>\n     * void onSomethingHappened() {\n     *   IntentSender sender = DocumentsContract.createWebLinkIntent(<i>...</i>);\n     *   if (sender != null) {\n     *     startIntentSenderForResult(\n     *         sender,\n     *         WEB_LINK_REQUEST_CODE,\n     *         null, 0, 0, 0, null);\n     *   }\n     * }\n     *\n     * <i>(...)</i>\n     *\n     * void onActivityResult(int requestCode, int resultCode, Intent data) {\n     *   if (requestCode == WEB_LINK_REQUEST_CODE && resultCode == RESULT_OK) {\n     *     Uri weblinkUri = data.getData();\n     *     <i>...</i>\n     *   }\n     * }\n     * </code></pre>\n     *\n     * @param uri uri for the document to create a link to.\n     * @param options Extra information for generating the link.\n     * @return an intent sender to obtain the web link, or null if the document\n     *      is not linkable, or creating the intent sender failed.\n     * @see DocumentsProvider#createWebLinkIntent(String, Bundle)\n     * @see Intent#EXTRA_EMAIL\n     ",
    "links" : [ "Intent#EXTRA_EMAIL" ]
  }, {
    "name" : "public static AssetFileDescriptor openImageThumbnail(File file) throws FileNotFoundException",
    "returnType" : "AssetFileDescriptor",
    "comment" : "\n     * Open the given image for thumbnail purposes, using any embedded EXIF\n     * thumbnail if available, and providing orientation hints from the parent\n     * image.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void rethrowIfNecessary(Exception e) throws FileNotFoundException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "PROVIDER_INTERFACE", "EXTRA_PACKAGE_NAME", "EXTRA_SHOW_ADVANCED", "EXTRA_TARGET_URI", "QUERY_ARG_DISPLAY_NAME", "QUERY_ARG_MIME_TYPES", "QUERY_ARG_FILE_SIZE_OVER", "QUERY_ARG_LAST_MODIFIED_AFTER", "QUERY_ARG_EXCLUDE_MEDIA", "EXTRA_INITIAL_URI", "EXTRA_EXCLUDE_SELF", "EXTRA_ORIENTATION", "EXTRA_PROMPT", "ACTION_DOCUMENT_SETTINGS", "ACTION_MANAGE_DOCUMENT", "ACTION_DOCUMENT_ROOT_SETTINGS", "EXTERNAL_STORAGE_PROVIDER_AUTHORITY", "EXTERNAL_STORAGE_PRIMARY_EMULATED_ROOT_ID", "PACKAGE_DOCUMENTS_UI", "METADATA_TYPES", "METADATA_EXIF", "METADATA_TREE_COUNT", "METADATA_TREE_SIZE", "EXTRA_LOADING", "EXTRA_INFO", "EXTRA_ERROR", "EXTRA_RESULT", "METHOD_CREATE_DOCUMENT", "METHOD_RENAME_DOCUMENT", "METHOD_DELETE_DOCUMENT", "METHOD_COPY_DOCUMENT", "METHOD_MOVE_DOCUMENT", "METHOD_IS_CHILD_DOCUMENT", "METHOD_REMOVE_DOCUMENT", "METHOD_EJECT_ROOT", "METHOD_FIND_DOCUMENT_PATH", "METHOD_CREATE_WEB_LINK_INTENT", "METHOD_GET_DOCUMENT_METADATA", "EXTRA_PARENT_URI", "EXTRA_URI", "EXTRA_URI_PERMISSIONS", "EXTRA_OPTIONS", "PATH_ROOT", "PATH_RECENT", "PATH_DOCUMENT", "PATH_CHILDREN", "PATH_SEARCH", "PATH_TREE", "PARAM_QUERY", "PARAM_MANAGE" ],
  "methodNames" : [ "public static Uri buildRootsUri(String authority)", "public static Uri buildRootUri(String authority, String rootId)", "public static Uri buildRecentDocumentsUri(String authority, String rootId)", "public static Uri buildTreeDocumentUri(String authority, String documentId)", "public static Uri buildDocumentUri(String authority, String documentId)", "public static Uri buildDocumentUriAsUser(@NonNull String authority, @NonNull String documentId, @NonNull UserHandle user)", "public static Uri buildBaseDocumentUri(String authority)", "private static Uri.Builder getBaseDocumentUriBuilder(String authority)", "public static Uri buildDocumentUriUsingTree(Uri treeUri, String documentId)", "public static Uri buildDocumentUriMaybeUsingTree(Uri baseUri, String documentId)", "public static Uri buildChildDocumentsUri(String authority, String parentDocumentId)", "public static Uri buildChildDocumentsUriUsingTree(Uri treeUri, String parentDocumentId)", "public static Uri buildSearchDocumentsUri(String authority, String rootId, String query)", "public static boolean matchSearchQueryArguments(Bundle queryArgs, String displayName, String mimeType, long lastModified, long size)", "public static String[] getHandledQueryArguments(Bundle queryArgs)", "public static boolean isDocumentUri(Context context, @Nullable Uri uri)", "public static boolean isRootsUri(@NonNull Context context, @Nullable Uri uri)", "public static boolean isRootUri(@NonNull Context context, @Nullable Uri uri)", "public static boolean isContentUri(@Nullable Uri uri)", "public static boolean isTreeUri(Uri uri)", "private static boolean isRootUri(Context context, @Nullable Uri uri, int pathSize)", "private static boolean isDocumentsProvider(Context context, String authority)", "public static String getRootId(Uri rootUri)", "public static String getDocumentId(Uri documentUri)", "public static String getTreeDocumentId(Uri documentUri)", "public static String getSearchDocumentsQuery(Uri searchDocumentsUri)", "public static String getSearchDocumentsQuery(@NonNull Bundle bundle)", "public static Uri setManageMode(@NonNull Uri uri)", "public static boolean isManageMode(@NonNull Uri uri)", "public static Bitmap getDocumentThumbnail(@NonNull ContentResolver content, @NonNull Uri documentUri, @NonNull Point size, @Nullable CancellationSignal signal) throws FileNotFoundException", "public static Uri createDocument(@NonNull ContentResolver content, @NonNull Uri parentDocumentUri, @NonNull String mimeType, @NonNull String displayName) throws FileNotFoundException", "public static boolean isChildDocument(@NonNull ContentResolver content, @NonNull Uri parentDocumentUri, @NonNull Uri childDocumentUri) throws FileNotFoundException", "public static Uri renameDocument(@NonNull ContentResolver content, @NonNull Uri documentUri, @NonNull String displayName) throws FileNotFoundException", "public static boolean deleteDocument(@NonNull ContentResolver content, @NonNull Uri documentUri) throws FileNotFoundException", "public static Uri copyDocument(@NonNull ContentResolver content, @NonNull Uri sourceDocumentUri, @NonNull Uri targetParentDocumentUri) throws FileNotFoundException", "public static Uri moveDocument(@NonNull ContentResolver content, @NonNull Uri sourceDocumentUri, @NonNull Uri sourceParentDocumentUri, @NonNull Uri targetParentDocumentUri) throws FileNotFoundException", "public static boolean removeDocument(@NonNull ContentResolver content, @NonNull Uri documentUri, @NonNull Uri parentDocumentUri) throws FileNotFoundException", "public static void ejectRoot(@NonNull ContentResolver content, @NonNull Uri rootUri)", "public static Bundle getDocumentMetadata(@NonNull ContentResolver content, @NonNull Uri documentUri) throws FileNotFoundException", "public static Path findDocumentPath(@NonNull ContentResolver content, @NonNull Uri treeUri) throws FileNotFoundException", "public static IntentSender createWebLinkIntent(@NonNull ContentResolver content, @NonNull Uri uri, @Nullable Bundle options) throws FileNotFoundException", "public static AssetFileDescriptor openImageThumbnail(File file) throws FileNotFoundException", "private static void rethrowIfNecessary(Exception e) throws FileNotFoundException" ]
}