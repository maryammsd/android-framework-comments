{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/time/chrono/ChronoLocalDate.java",
  "packageName" : "java.time.chrono",
  "className" : "ChronoLocalDate",
  "comment" : "\n * A date without time-of-day or time-zone in an arbitrary chronology, intended\n * for advanced globalization use cases.\n * <p>\n * <b>Most applications should declare method signatures, fields and variables\n * as {@link LocalDate}, not this interface.</b>\n * <p>\n * A {@code ChronoLocalDate} is the abstract representation of a date where the\n * {@code Chronology chronology}, or calendar system, is pluggable.\n * The date is defined in terms of fields expressed by {@link TemporalField},\n * where most common implementations are defined in {@link ChronoField}.\n * The chronology defines how the calendar system operates and the meaning of\n * the standard fields.\n *\n * <h2>When to use this interface</h2>\n * The design of the API encourages the use of {@code LocalDate} rather than this\n * interface, even in the case where the application needs to deal with multiple\n * calendar systems.\n * <p>\n * This concept can seem surprising at first, as the natural way to globalize an\n * application might initially appear to be to abstract the calendar system.\n * However, as explored below, abstracting the calendar system is usually the wrong\n * approach, resulting in logic errors and hard to find bugs.\n * As such, it should be considered an application-wide architectural decision to choose\n * to use this interface as opposed to {@code LocalDate}.\n *\n * <h3>Architectural issues to consider</h3>\n * These are some of the points that must be considered before using this interface\n * throughout an application.\n * <p>\n * 1) Applications using this interface, as opposed to using just {@code LocalDate},\n * face a significantly higher probability of bugs. This is because the calendar system\n * in use is not known at development time. A key cause of bugs is where the developer\n * applies assumptions from their day-to-day knowledge of the ISO calendar system\n * to code that is intended to deal with any arbitrary calendar system.\n * The section below outlines how those assumptions can cause problems\n * The primary mechanism for reducing this increased risk of bugs is a strong code review process.\n * This should also be considered a extra cost in maintenance for the lifetime of the code.\n * <p>\n * 2) This interface does not enforce immutability of implementations.\n * While the implementation notes indicate that all implementations must be immutable\n * there is nothing in the code or type system to enforce this. Any method declared\n * to accept a {@code ChronoLocalDate} could therefore be passed a poorly or\n * maliciously written mutable implementation.\n * <p>\n * 3) Applications using this interface  must consider the impact of eras.\n * {@code LocalDate} shields users from the concept of eras, by ensuring that {@code getYear()}\n * returns the proleptic year. That decision ensures that developers can think of\n * {@code LocalDate} instances as consisting of three fields - year, month-of-year and day-of-month.\n * By contrast, users of this interface must think of dates as consisting of four fields -\n * era, year-of-era, month-of-year and day-of-month. The extra era field is frequently\n * forgotten, yet it is of vital importance to dates in an arbitrary calendar system.\n * For example, in the Japanese calendar system, the era represents the reign of an Emperor.\n * Whenever one reign ends and another starts, the year-of-era is reset to one.\n * <p>\n * 4) The only agreed international standard for passing a date between two systems\n * is the ISO-8601 standard which requires the ISO calendar system. Using this interface\n * throughout the application will inevitably lead to the requirement to pass the date\n * across a network or component boundary, requiring an application specific protocol or format.\n * <p>\n * 5) Long term persistence, such as a database, will almost always only accept dates in the\n * ISO-8601 calendar system (or the related Julian-Gregorian). Passing around dates in other\n * calendar systems increases the complications of interacting with persistence.\n * <p>\n * 6) Most of the time, passing a {@code ChronoLocalDate} throughout an application\n * is unnecessary, as discussed in the last section below.\n *\n * <h3>False assumptions causing bugs in multi-calendar system code</h3>\n * As indicated above, there are many issues to consider when try to use and manipulate a\n * date in an arbitrary calendar system. These are some of the key issues.\n * <p>\n * Code that queries the day-of-month and assumes that the value will never be more than\n * 31 is invalid. Some calendar systems have more than 31 days in some months.\n * <p>\n * Code that adds 12 months to a date and assumes that a year has been added is invalid.\n * Some calendar systems have a different number of months, such as 13 in the Coptic or Ethiopic.\n * <p>\n * Code that adds one month to a date and assumes that the month-of-year value will increase\n * by one or wrap to the next year is invalid. Some calendar systems have a variable number\n * of months in a year, such as the Hebrew.\n * <p>\n * Code that adds one month, then adds a second one month and assumes that the day-of-month\n * will remain close to its original value is invalid. Some calendar systems have a large difference\n * between the length of the longest month and the length of the shortest month.\n * For example, the Coptic or Ethiopic have 12 months of 30 days and 1 month of 5 days.\n * <p>\n * Code that adds seven days and assumes that a week has been added is invalid.\n * Some calendar systems have weeks of other than seven days, such as the French Revolutionary.\n * <p>\n * Code that assumes that because the year of {@code date1} is greater than the year of {@code date2}\n * then {@code date1} is after {@code date2} is invalid. This is invalid for all calendar systems\n * when referring to the year-of-era, and especially untrue of the Japanese calendar system\n * where the year-of-era restarts with the reign of every new Emperor.\n * <p>\n * Code that treats month-of-year one and day-of-month one as the start of the year is invalid.\n * Not all calendar systems start the year when the month value is one.\n * <p>\n * In general, manipulating a date, and even querying a date, is wide open to bugs when the\n * calendar system is unknown at development time. This is why it is essential that code using\n * this interface is subjected to additional code reviews. It is also why an architectural\n * decision to avoid this interface type is usually the correct one.\n *\n * <h3>Using LocalDate instead</h3>\n * The primary alternative to using this interface throughout your application is as follows.\n * <ul>\n * <li>Declare all method signatures referring to dates in terms of {@code LocalDate}.\n * <li>Either store the chronology (calendar system) in the user profile or lookup\n *  the chronology from the user locale\n * <li>Convert the ISO {@code LocalDate} to and from the user's preferred calendar system during\n *  printing and parsing\n * </ul>\n * This approach treats the problem of globalized calendar systems as a localization issue\n * and confines it to the UI layer. This approach is in keeping with other localization\n * issues in the java platform.\n * <p>\n * As discussed above, performing calculations on a date where the rules of the calendar system\n * are pluggable requires skill and is not recommended.\n * Fortunately, the need to perform calculations on a date in an arbitrary calendar system\n * is extremely rare. For example, it is highly unlikely that the business rules of a library\n * book rental scheme will allow rentals to be for one month, where meaning of the month\n * is dependent on the user's preferred calendar system.\n * <p>\n * A key use case for calculations on a date in an arbitrary calendar system is producing\n * a month-by-month calendar for display and user interaction. Again, this is a UI issue,\n * and use of this interface solely within a few methods of the UI layer may be justified.\n * <p>\n * In any other part of the system, where a date must be manipulated in a calendar system\n * other than ISO, the use case will generally specify the calendar system to use.\n * For example, an application may need to calculate the next Islamic or Hebrew holiday\n * which may require manipulating the date.\n * This kind of use case can be handled as follows:\n * <ul>\n * <li>start from the ISO {@code LocalDate} being passed to the method\n * <li>convert the date to the alternate calendar system, which for this use case is known\n *  rather than arbitrary\n * <li>perform the calculation\n * <li>convert back to {@code LocalDate}\n * </ul>\n * Developers writing low-level frameworks or libraries should also avoid this interface.\n * Instead, one of the two general purpose access interfaces should be used.\n * Use {@link TemporalAccessor} if read-only access is required, or use {@link Temporal}\n * if read-write access is required.\n *\n * @implSpec\n * This interface must be implemented with care to ensure other classes operate correctly.\n * All implementations that can be instantiated must be final, immutable and thread-safe.\n * Subclasses should be Serializable wherever possible.\n * <p>\n * Additional calendar systems may be added to the system.\n * See {@link Chronology} for more details.\n *\n * @since 1.8\n ",
  "links" : [ "java.time.temporal.ChronoField", "java.time.chrono.Chronology", "java.time.LocalDate", "java.time.temporal.TemporalField", "java.time.temporal.Temporal", "java.time.temporal.TemporalAccessor" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " static Comparator<ChronoLocalDate> timeLineOrder()",
    "returnType" : "Comparator<ChronoLocalDate>",
    "comment" : "\n     * Gets a comparator that compares {@code ChronoLocalDate} in\n     * time-line order ignoring the chronology.\n     * <p>\n     * This comparator differs from the comparison in {@link #compareTo} in that it\n     * only compares the underlying date and not the chronology.\n     * This allows dates in different calendar systems to be compared based\n     * on the position of the date on the local time-line.\n     * The underlying comparison is equivalent to comparing the epoch-day.\n     *\n     * @return a comparator that compares in time-line order ignoring the chronology\n     * @see #isAfter\n     * @see #isBefore\n     * @see #isEqual\n     ",
    "links" : [ "#compareTo" ]
  }, {
    "name" : " static ChronoLocalDate from(TemporalAccessor temporal)",
    "returnType" : "ChronoLocalDate",
    "comment" : "\n     * Obtains an instance of {@code ChronoLocalDate} from a temporal object.\n     * <p>\n     * This obtains a local date based on the specified temporal.\n     * A {@code TemporalAccessor} represents an arbitrary set of date and time information,\n     * which this factory converts to an instance of {@code ChronoLocalDate}.\n     * <p>\n     * The conversion extracts and combines the chronology and the date\n     * from the temporal object. The behavior is equivalent to using\n     * {@link Chronology#date(TemporalAccessor)} with the extracted chronology.\n     * Implementations are permitted to perform optimizations such as accessing\n     * those fields that are equivalent to the relevant objects.\n     * <p>\n     * This method matches the signature of the functional interface {@link TemporalQuery}\n     * allowing it to be used as a query via method reference, {@code ChronoLocalDate::from}.\n     *\n     * @param temporal  the temporal object to convert, not null\n     * @return the date, not null\n     * @throws DateTimeException if unable to convert to a {@code ChronoLocalDate}\n     * @see Chronology#date(TemporalAccessor)\n     ",
    "links" : [ "java.time.chrono.Chronology#date(TemporalAccessor)", "java.time.temporal.TemporalQuery" ]
  }, {
    "name" : " Chronology getChronology()",
    "returnType" : "Chronology",
    "comment" : "\n     * Gets the chronology of this date.\n     * <p>\n     * The {@code Chronology} represents the calendar system in use.\n     * The era and other fields in {@link ChronoField} are defined by the chronology.\n     *\n     * @return the chronology, not null\n     ",
    "links" : [ "java.time.temporal.ChronoField" ]
  }, {
    "name" : " Era getEra()",
    "returnType" : "Era",
    "comment" : "\n     * Gets the era, as defined by the chronology.\n     * <p>\n     * The era is, conceptually, the largest division of the time-line.\n     * Most calendar systems have a single epoch dividing the time-line into two eras.\n     * However, some have multiple eras, such as one for the reign of each leader.\n     * The exact meaning is determined by the {@code Chronology}.\n     * <p>\n     * All correctly implemented {@code Era} classes are singletons, thus it\n     * is valid code to write {@code date.getEra() == SomeChrono.ERA_NAME)}.\n     * <p>\n     * This default implementation uses {@link Chronology#eraOf(int)}.\n     *\n     * @return the chronology specific era constant applicable at this date, not null\n     ",
    "links" : [ "java.time.chrono.Chronology#eraOf(int)" ]
  }, {
    "name" : " boolean isLeapYear()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the year is a leap year, as defined by the calendar system.\n     * <p>\n     * A leap-year is a year of a longer length than normal.\n     * The exact meaning is determined by the chronology with the constraint that\n     * a leap-year must imply a year-length longer than a non leap-year.\n     * <p>\n     * This default implementation uses {@link Chronology#isLeapYear(long)}.\n     *\n     * @return true if this date is in a leap year, false otherwise\n     ",
    "links" : [ "java.time.chrono.Chronology#isLeapYear(long)" ]
  }, {
    "name" : " int lengthOfMonth()",
    "returnType" : "int",
    "comment" : "\n     * Returns the length of the month represented by this date, as defined by the calendar system.\n     * <p>\n     * This returns the length of the month in days.\n     *\n     * @return the length of the month in days\n     ",
    "links" : [ ]
  }, {
    "name" : " int lengthOfYear()",
    "returnType" : "int",
    "comment" : "\n     * Returns the length of the year represented by this date, as defined by the calendar system.\n     * <p>\n     * This returns the length of the year in days.\n     * <p>\n     * The default implementation uses {@link #isLeapYear()} and returns 365 or 366.\n     *\n     * @return the length of the year in days\n     ",
    "links" : [ "#isLeapYear()" ]
  }, {
    "name" : " boolean isSupported(TemporalField field)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the specified field is supported.\n     * <p>\n     * This checks if the specified field can be queried on this date.\n     * If false, then calling the {@link #range(TemporalField) range},\n     * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}\n     * methods will throw an exception.\n     * <p>\n     * The set of supported fields is defined by the chronology and normally includes\n     * all {@code ChronoField} date fields.\n     * <p>\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}\n     * passing {@code this} as the argument.\n     * Whether the field is supported is determined by the field.\n     *\n     * @param field  the field to check, null returns false\n     * @return true if the field can be queried, false if not\n     ",
    "links" : [ "#range(TemporalField)", "#get(TemporalField)", "#with(TemporalField" ]
  }, {
    "name" : " boolean isSupported(TemporalUnit unit)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the specified unit is supported.\n     * <p>\n     * This checks if the specified unit can be added to or subtracted from this date.\n     * If false, then calling the {@link #plus(long, TemporalUnit)} and\n     * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.\n     * <p>\n     * The set of supported units is defined by the chronology and normally includes\n     * all {@code ChronoUnit} date units except {@code FOREVER}.\n     * <p>\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}\n     * passing {@code this} as the argument.\n     * Whether the unit is supported is determined by the unit.\n     *\n     * @param unit  the unit to check, null returns false\n     * @return true if the unit can be added/subtracted, false if not\n     ",
    "links" : [ "#plus(long", "#minus(long" ]
  }, {
    "name" : " ChronoLocalDate with(TemporalAdjuster adjuster)",
    "returnType" : "ChronoLocalDate",
    "comment" : "\n     * {@inheritDoc}\n     * @throws DateTimeException {@inheritDoc}\n     * @throws ArithmeticException {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : " ChronoLocalDate with(TemporalField field, long newValue)",
    "returnType" : "ChronoLocalDate",
    "comment" : "\n     * {@inheritDoc}\n     * @throws DateTimeException {@inheritDoc}\n     * @throws UnsupportedTemporalTypeException {@inheritDoc}\n     * @throws ArithmeticException {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : " ChronoLocalDate plus(TemporalAmount amount)",
    "returnType" : "ChronoLocalDate",
    "comment" : "\n     * {@inheritDoc}\n     * @throws DateTimeException {@inheritDoc}\n     * @throws ArithmeticException {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : " ChronoLocalDate plus(long amountToAdd, TemporalUnit unit)",
    "returnType" : "ChronoLocalDate",
    "comment" : "\n     * {@inheritDoc}\n     * @throws DateTimeException {@inheritDoc}\n     * @throws ArithmeticException {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : " ChronoLocalDate minus(TemporalAmount amount)",
    "returnType" : "ChronoLocalDate",
    "comment" : "\n     * {@inheritDoc}\n     * @throws DateTimeException {@inheritDoc}\n     * @throws ArithmeticException {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : " ChronoLocalDate minus(long amountToSubtract, TemporalUnit unit)",
    "returnType" : "ChronoLocalDate",
    "comment" : "\n     * {@inheritDoc}\n     * @throws DateTimeException {@inheritDoc}\n     * @throws UnsupportedTemporalTypeException {@inheritDoc}\n     * @throws ArithmeticException {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : " R query(TemporalQuery<R> query)",
    "returnType" : "R",
    "comment" : "\n     * Queries this date using the specified query.\n     * <p>\n     * This queries this date using the specified query strategy object.\n     * The {@code TemporalQuery} object defines the logic to be used to\n     * obtain the result. Read the documentation of the query to understand\n     * what the result of this method will be.\n     * <p>\n     * The result of this method is obtained by invoking the\n     * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the\n     * specified query passing {@code this} as the argument.\n     *\n     * @param <R> the type of the result\n     * @param query  the query to invoke, not null\n     * @return the query result, null may be returned (defined by the query)\n     * @throws DateTimeException if unable to query (defined by the query)\n     * @throws ArithmeticException if numeric overflow occurs (defined by the query)\n     ",
    "links" : [ "java.time.temporal.TemporalQuery#queryFrom(TemporalAccessor)" ]
  }, {
    "name" : " Temporal adjustInto(Temporal temporal)",
    "returnType" : "Temporal",
    "comment" : "\n     * Adjusts the specified temporal object to have the same date as this object.\n     * <p>\n     * This returns a temporal object of the same observable type as the input\n     * with the date changed to be the same as this.\n     * <p>\n     * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}\n     * passing {@link ChronoField#EPOCH_DAY} as the field.\n     * <p>\n     * In most cases, it is clearer to reverse the calling pattern by using\n     * {@link Temporal#with(TemporalAdjuster)}:\n     * <pre>\n     *   // these two lines are equivalent, but the second approach is recommended\n     *   temporal = thisLocalDate.adjustInto(temporal);\n     *   temporal = temporal.with(thisLocalDate);\n     * </pre>\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param temporal  the target object to be adjusted, not null\n     * @return the adjusted object, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     ",
    "links" : [ "java.time.temporal.Temporal#with(TemporalField", "java.time.temporal.ChronoField#EPOCH_DAY", "java.time.temporal.Temporal#with(TemporalAdjuster)" ]
  }, {
    "name" : " long until(Temporal endExclusive, TemporalUnit unit)",
    "returnType" : "long",
    "comment" : "\n     * Calculates the amount of time until another date in terms of the specified unit.\n     * <p>\n     * This calculates the amount of time between two {@code ChronoLocalDate}\n     * objects in terms of a single {@code TemporalUnit}.\n     * The start and end points are {@code this} and the specified date.\n     * The result will be negative if the end is before the start.\n     * The {@code Temporal} passed to this method is converted to a\n     * {@code ChronoLocalDate} using {@link Chronology#date(TemporalAccessor)}.\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two dates.\n     * For example, the amount in days between two dates can be calculated\n     * using {@code startDate.until(endDate, DAYS)}.\n     * <p>\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method.\n     * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:\n     * <pre>\n     *   // these two lines are equivalent\n     *   amount = start.until(end, MONTHS);\n     *   amount = MONTHS.between(start, end);\n     * </pre>\n     * The choice should be made based on which makes the code more readable.\n     * <p>\n     * The calculation is implemented in this method for {@link ChronoUnit}.\n     * The units {@code DAYS}, {@code WEEKS}, {@code MONTHS}, {@code YEARS},\n     * {@code DECADES}, {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS}\n     * should be supported by all implementations.\n     * Other {@code ChronoUnit} values will throw an exception.\n     * <p>\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the converted input temporal as\n     * the second argument.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param endExclusive  the end date, exclusive, which is converted to a\n     *  {@code ChronoLocalDate} in the same chronology, not null\n     * @param unit  the unit to measure the amount in, not null\n     * @return the amount of time between this date and the end date\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to a {@code ChronoLocalDate}\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     ",
    "links" : [ "java.time.chrono.Chronology#date(TemporalAccessor)", "java.time.temporal.ChronoUnit", "java.time.temporal.TemporalUnit#between(Temporal" ]
  }, {
    "name" : " ChronoPeriod until(ChronoLocalDate endDateExclusive)",
    "returnType" : "ChronoPeriod",
    "comment" : "\n     * Calculates the period between this date and another date as a {@code ChronoPeriod}.\n     * <p>\n     * This calculates the period between two dates. All supplied chronologies\n     * calculate the period using years, months and days, however the\n     * {@code ChronoPeriod} API allows the period to be represented using other units.\n     * <p>\n     * The start and end points are {@code this} and the specified date.\n     * The result will be negative if the end is before the start.\n     * The negative sign will be the same in each of year, month and day.\n     * <p>\n     * The calculation is performed using the chronology of this date.\n     * If necessary, the input date will be converted to match.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param endDateExclusive  the end date, exclusive, which may be in any chronology, not null\n     * @return the period between this date and the end date, not null\n     * @throws DateTimeException if the period cannot be calculated\n     * @throws ArithmeticException if numeric overflow occurs\n     ",
    "links" : [ ]
  }, {
    "name" : " String format(DateTimeFormatter formatter)",
    "returnType" : "String",
    "comment" : "\n     * Formats this date using the specified formatter.\n     * <p>\n     * This date will be passed to the formatter to produce a string.\n     * <p>\n     * The default implementation must behave as follows:\n     * <pre>\n     *  return formatter.format(this);\n     * </pre>\n     *\n     * @param formatter  the formatter to use, not null\n     * @return the formatted date string, not null\n     * @throws DateTimeException if an error occurs during printing\n     ",
    "links" : [ ]
  }, {
    "name" : " ChronoLocalDateTime<?> atTime(LocalTime localTime)",
    "returnType" : "ChronoLocalDateTime<?>",
    "comment" : "\n     * Combines this date with a time to create a {@code ChronoLocalDateTime}.\n     * <p>\n     * This returns a {@code ChronoLocalDateTime} formed from this date at the specified time.\n     * All possible combinations of date and time are valid.\n     *\n     * @param localTime  the local time to use, not null\n     * @return the local date-time formed from this date and the specified time, not null\n     ",
    "links" : [ ]
  }, {
    "name" : " long toEpochDay()",
    "returnType" : "long",
    "comment" : "\n     * Converts this date to the Epoch Day.\n     * <p>\n     * The {@link ChronoField#EPOCH_DAY Epoch Day count} is a simple\n     * incrementing count of days where day 0 is 1970-01-01 (ISO).\n     * This definition is the same for all chronologies, enabling conversion.\n     * <p>\n     * This default implementation queries the {@code EPOCH_DAY} field.\n     *\n     * @return the Epoch Day equivalent to this date\n     ",
    "links" : [ "java.time.temporal.ChronoField#EPOCH_DAY" ]
  }, {
    "name" : " int compareTo(ChronoLocalDate other)",
    "returnType" : "int",
    "comment" : "\n     * Compares this date to another date, including the chronology.\n     * <p>\n     * The comparison is based first on the underlying time-line date, then\n     * on the chronology.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     * <p>\n     * For example, the following is the comparator order:\n     * <ol>\n     * <li>{@code 2012-12-03 (ISO)}</li>\n     * <li>{@code 2012-12-04 (ISO)}</li>\n     * <li>{@code 2555-12-04 (ThaiBuddhist)}</li>\n     * <li>{@code 2012-12-05 (ISO)}</li>\n     * </ol>\n     * Values #2 and #3 represent the same date on the time-line.\n     * When two values represent the same date, the chronology ID is compared to distinguish them.\n     * This step is needed to make the ordering \"consistent with equals\".\n     * <p>\n     * If all the date objects being compared are in the same chronology, then the\n     * additional chronology stage is not required and only the local date is used.\n     * To compare the dates of two {@code TemporalAccessor} instances, including dates\n     * in two different chronologies, use {@link ChronoField#EPOCH_DAY} as a comparator.\n     * <p>\n     * This default implementation performs the comparison defined above.\n     *\n     * @param other  the other date to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     ",
    "links" : [ "Comparable", "java.time.temporal.ChronoField#EPOCH_DAY" ]
  }, {
    "name" : " boolean isAfter(ChronoLocalDate other)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if this date is after the specified date ignoring the chronology.\n     * <p>\n     * This method differs from the comparison in {@link #compareTo} in that it\n     * only compares the underlying date and not the chronology.\n     * This allows dates in different calendar systems to be compared based\n     * on the time-line position.\n     * This is equivalent to using {@code date1.toEpochDay() > date2.toEpochDay()}.\n     * <p>\n     * This default implementation performs the comparison based on the epoch-day.\n     *\n     * @param other  the other date to compare to, not null\n     * @return true if this is after the specified date\n     ",
    "links" : [ "#compareTo" ]
  }, {
    "name" : " boolean isBefore(ChronoLocalDate other)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if this date is before the specified date ignoring the chronology.\n     * <p>\n     * This method differs from the comparison in {@link #compareTo} in that it\n     * only compares the underlying date and not the chronology.\n     * This allows dates in different calendar systems to be compared based\n     * on the time-line position.\n     * This is equivalent to using {@code date1.toEpochDay() < date2.toEpochDay()}.\n     * <p>\n     * This default implementation performs the comparison based on the epoch-day.\n     *\n     * @param other  the other date to compare to, not null\n     * @return true if this is before the specified date\n     ",
    "links" : [ "#compareTo" ]
  }, {
    "name" : " boolean isEqual(ChronoLocalDate other)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if this date is equal to the specified date ignoring the chronology.\n     * <p>\n     * This method differs from the comparison in {@link #compareTo} in that it\n     * only compares the underlying date and not the chronology.\n     * This allows dates in different calendar systems to be compared based\n     * on the time-line position.\n     * This is equivalent to using {@code date1.toEpochDay() == date2.toEpochDay()}.\n     * <p>\n     * This default implementation performs the comparison based on the epoch-day.\n     *\n     * @param other  the other date to compare to, not null\n     * @return true if the underlying date is equal to the specified date\n     ",
    "links" : [ "#compareTo" ]
  }, {
    "name" : " boolean equals(Object obj)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if this date is equal to another date, including the chronology.\n     * <p>\n     * Compares this date with another ensuring that the date and chronology are the same.\n     * <p>\n     * To compare the dates of two {@code TemporalAccessor} instances, including dates\n     * in two different chronologies, use {@link ChronoField#EPOCH_DAY} as a comparator.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if this is equal to the other date\n     ",
    "links" : [ "java.time.temporal.ChronoField#EPOCH_DAY" ]
  }, {
    "name" : " int hashCode()",
    "returnType" : "int",
    "comment" : "\n     * A hash code for this date.\n     *\n     * @return a suitable hash code\n     ",
    "links" : [ ]
  }, {
    "name" : " String toString()",
    "returnType" : "String",
    "comment" : "\n     * Outputs this date as a {@code String}.\n     * <p>\n     * The output will include the full local date.\n     *\n     * @return the formatted date, not null\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ " static Comparator<ChronoLocalDate> timeLineOrder()", " static ChronoLocalDate from(TemporalAccessor temporal)", " Chronology getChronology()", " Era getEra()", " boolean isLeapYear()", " int lengthOfMonth()", " int lengthOfYear()", " boolean isSupported(TemporalField field)", " boolean isSupported(TemporalUnit unit)", " ChronoLocalDate with(TemporalAdjuster adjuster)", " ChronoLocalDate with(TemporalField field, long newValue)", " ChronoLocalDate plus(TemporalAmount amount)", " ChronoLocalDate plus(long amountToAdd, TemporalUnit unit)", " ChronoLocalDate minus(TemporalAmount amount)", " ChronoLocalDate minus(long amountToSubtract, TemporalUnit unit)", " R query(TemporalQuery<R> query)", " Temporal adjustInto(Temporal temporal)", " long until(Temporal endExclusive, TemporalUnit unit)", " ChronoPeriod until(ChronoLocalDate endDateExclusive)", " String format(DateTimeFormatter formatter)", " ChronoLocalDateTime<?> atTime(LocalTime localTime)", " long toEpochDay()", " int compareTo(ChronoLocalDate other)", " boolean isAfter(ChronoLocalDate other)", " boolean isBefore(ChronoLocalDate other)", " boolean isEqual(ChronoLocalDate other)", " boolean equals(Object obj)", " int hashCode()", " String toString()" ],
  "variableNames" : [ ]
}