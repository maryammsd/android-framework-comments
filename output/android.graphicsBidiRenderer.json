{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/graphics/BidiRenderer.java",
  "packageName" : "android.graphics",
  "className" : "BidiRenderer",
  "comment" : "\n * Render the text by breaking it into various scripts and using the right font for each script.\n * Can be used to measure the text without actually drawing it.\n ",
  "variables" : [ {
    "name" : "JETBRAINS_VENDOR_ID",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "JAVA_VENDOR",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SCALEX_WORKAROUND_LIMIT",
    "type" : "double",
    "comment" : " When scaleX is bigger than this, we need to apply the workaround for http://b.android.com/211659 ",
    "links" : [ ]
  }, {
    "name" : "mGraphics",
    "type" : "Graphics2D",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPaint",
    "type" : "Paint_Delegate",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mText",
    "type" : "char[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBounds",
    "type" : "RectF",
    "comment" : " Bounds of the text drawn so far.",
    "links" : [ ]
  }, {
    "name" : "mBaseline",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBidi",
    "type" : "Bidi",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public BidiRenderer setRenderLocation(float x, float y)",
    "returnType" : "BidiRenderer",
    "comment" : "\n     *\n     * @param x The x-coordinate of the left edge of where the text should be drawn on the given\n     *            graphics.\n     * @param y The y-coordinate at which to draw the text on the given mGraphics.\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "public RectF renderText(int start, int limit, int bidiFlags, float[] advances, int advancesIndex, boolean draw)",
    "returnType" : "RectF",
    "comment" : "\n     * Perform Bidi Analysis on the text and then render it.\n     * <p/>\n     * To skip the analysis and render unidirectional text, see {@link\n     * #renderText(int, int, boolean, float[], int, boolean)}\n     ",
    "links" : [ ]
  }, {
    "name" : "public RectF renderText(int start, int limit, boolean isRtl, float[] advances, int advancesIndex, boolean draw)",
    "returnType" : "RectF",
    "comment" : "\n     * Render unidirectional text.\n     * <p/>\n     * This method can also be used to measure the width of the text without actually drawing it.\n     * <p/>\n     * @param start index of the first character\n     * @param limit index of the first character that should not be rendered.\n     * @param isRtl is the text right-to-left\n     * @param advances If not null, then advances for each character to be rendered are returned\n     *            here.\n     * @param advancesIndex index into advances from where the advances need to be filled.\n     * @param draw If true and {@code graphics} is not null, draw the rendered text on the graphics\n     *            at the given co-ordinates\n     * @return A rectangle specifying the bounds of the text drawn.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void renderScript(int start, int limit, Font preferredFont, int flag, float[] advances, int advancesIndex, boolean draw)",
    "returnType" : "void",
    "comment" : "\n     * Render a script run to the right of the bounds passed. Use the preferred font to render as\n     * much as possible. This also implements a fallback mechanism to render characters that cannot\n     * be drawn using the preferred font.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void logFontWarning()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void render(int start, int limit, Font font, int flag, float[] advances, int advancesIndex, boolean draw)",
    "returnType" : "void",
    "comment" : "\n     * Renders the text to the right of the bounds with the given font.\n     * @param font The font to render the text with.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static RectF awtRectToAndroidRect(Rectangle2D awtRec, float offsetX, float offsetY, @Nullable RectF destination)",
    "returnType" : "RectF",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static List<ScriptRun> getScriptRuns(char[] text, int start, int limit, List<FontInfo> fonts)",
    "returnType" : "List<ScriptRun>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static Font getScriptFont(char[] text, int start, int limit, List<FontInfo> fonts)",
    "returnType" : "Font",
    "comment" : " TODO: Replace this method with one which returns the font based on the scriptCode.",
    "links" : [ ]
  }, {
    "name" : "private static int getIcuFlags(int bidiFlag)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "variableNames" : [ "JETBRAINS_VENDOR_ID", "JAVA_VENDOR", "SCALEX_WORKAROUND_LIMIT", "mGraphics", "mPaint", "mText", "mBounds", "mBaseline", "mBidi" ],
  "methodNames" : [ "public BidiRenderer setRenderLocation(float x, float y)", "public RectF renderText(int start, int limit, int bidiFlags, float[] advances, int advancesIndex, boolean draw)", "public RectF renderText(int start, int limit, boolean isRtl, float[] advances, int advancesIndex, boolean draw)", "private void renderScript(int start, int limit, Font preferredFont, int flag, float[] advances, int advancesIndex, boolean draw)", "private static void logFontWarning()", "private void render(int start, int limit, Font font, int flag, float[] advances, int advancesIndex, boolean draw)", "private static RectF awtRectToAndroidRect(Rectangle2D awtRec, float offsetX, float offsetY, @Nullable RectF destination)", "private static List<ScriptRun> getScriptRuns(char[] text, int start, int limit, List<FontInfo> fonts)", "private static Font getScriptFont(char[] text, int start, int limit, List<FontInfo> fonts)", "private static int getIcuFlags(int bidiFlag)" ]
}