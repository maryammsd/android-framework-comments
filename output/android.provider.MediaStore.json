{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/provider/MediaStore.java",
  "packageName" : "android.provider",
  "className" : "MediaStore",
  "comment" : "\n * The contract between the media provider and applications. Contains\n * definitions for the supported URIs and columns.\n * <p>\n * The media provider provides an indexed collection of common media types, such\n * as {@link Audio}, {@link Video}, and {@link Images}, from any attached\n * storage devices. Each collection is organized based on the primary MIME type\n * of the underlying content; for example, {@code image/*} content is indexed\n * under {@link Images}. The {@link Files} collection provides a broad view\n * across all collections, and does not filter by MIME type.\n ",
  "links" : [ "Video", "Images", "Audio", "Files" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "AUTHORITY",
    "type" : "String",
    "comment" : " The authority for the media provider ",
    "links" : [ ]
  }, {
    "name" : "AUTHORITY_URI",
    "type" : "Uri",
    "comment" : " A content:// style uri to the authority for the media provider ",
    "links" : [ ]
  }, {
    "name" : "AUTHORITY_LEGACY",
    "type" : "String",
    "comment" : "\n     * The authority for a legacy instance of the media provider, before it was\n     * converted into a Mainline module. When initializing for the first time,\n     * the Mainline module will connect to this legacy instance to migrate\n     * important user settings, such as {@link BaseColumns#_ID},\n     * {@link MediaColumns#IS_FAVORITE}, and more.\n     * <p>\n     * The legacy instance is expected to meet the exact same API contract\n     * expressed here in {@link MediaStore}, to facilitate smooth data\n     * migrations. Interactions that would normally interact with\n     * {@link #AUTHORITY} can be redirected to work with the legacy instance\n     * using {@link #rewriteToLegacy(Uri)}.\n     *\n     * @hide\n     ",
    "links" : [ "#IS_FAVORITE", "#AUTHORITY", "android.provider.MediaStore", "android.provider.BaseColumns#_ID", "#rewriteToLegacy(Uri)" ]
  }, {
    "name" : "AUTHORITY_LEGACY_URI",
    "type" : "Uri",
    "comment" : "\n     * @see #AUTHORITY_LEGACY\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "VOLUME_INTERNAL",
    "type" : "String",
    "comment" : "\n     * Synthetic volume name that provides a view of all content across the\n     * \"internal\" storage of the device.\n     * <p>\n     * This synthetic volume provides a merged view of all media distributed\n     * with the device, such as built-in ringtones and wallpapers.\n     * <p>\n     * Because this is a synthetic volume, you can't insert new content into\n     * this volume.\n     ",
    "links" : [ ]
  }, {
    "name" : "VOLUME_EXTERNAL",
    "type" : "String",
    "comment" : "\n     * Synthetic volume name that provides a view of all content across the\n     * \"external\" storage of the device.\n     * <p>\n     * This synthetic volume provides a merged view of all media across all\n     * currently attached external storage devices.\n     * <p>\n     * Because this is a synthetic volume, you can't insert new content into\n     * this volume. Instead, you can insert content into a specific storage\n     * volume obtained from {@link #getExternalVolumeNames(Context)}.\n     ",
    "links" : [ "#getExternalVolumeNames(Context)" ]
  }, {
    "name" : "VOLUME_EXTERNAL_PRIMARY",
    "type" : "String",
    "comment" : "\n     * Specific volume name that represents the primary external storage device\n     * at {@link Environment#getExternalStorageDirectory()}.\n     * <p>\n     * This volume may not always be available, such as when the user has\n     * ejected the device. You can find a list of all specific volume names\n     * using {@link #getExternalVolumeNames(Context)}.\n     ",
    "links" : [ "#getExternalVolumeNames(Context)", "android.os.Environment#getExternalStorageDirectory()" ]
  }, {
    "name" : "VOLUME_DEMO",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "RESOLVE_PLAYLIST_MEMBERS_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "RUN_IDLE_MAINTENANCE_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "WAIT_FOR_IDLE_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "SCAN_FILE_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "SCAN_VOLUME_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "CREATE_WRITE_REQUEST_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "CREATE_TRASH_REQUEST_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "CREATE_FAVORITE_REQUEST_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "CREATE_DELETE_REQUEST_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "GET_VERSION_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "GET_GENERATION_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "START_LEGACY_MIGRATION_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "FINISH_LEGACY_MIGRATION_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTERNAL_STORAGE_PROVIDER_AUTHORITY",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "GET_DOCUMENT_URI_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "GET_MEDIA_URI_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "GET_REDACTED_MEDIA_URI_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "GET_REDACTED_MEDIA_URI_LIST_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_URI_LIST",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "QUERY_ARG_REDACTED_URI",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_URI",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_URI_PERMISSIONS",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_CLIP_DATA",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_CONTENT_VALUES",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_RESULT",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_FILE_DESCRIPTOR",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_LOCAL_PROVIDER",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_IS_STABLE_URIS_ENABLED",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "IS_SYSTEM_GALLERY_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_IS_SYSTEM_GALLERY_UID",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_IS_SYSTEM_GALLERY_RESPONSE",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "IS_CURRENT_CLOUD_PROVIDER_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "IS_SUPPORTED_CLOUD_PROVIDER_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "NOTIFY_CLOUD_MEDIA_CHANGED_EVENT_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "SYNC_PROVIDERS_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "GET_CLOUD_PROVIDER_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "GET_CLOUD_PROVIDER_RESULT",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "GET_CLOUD_PROVIDER_LABEL_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "SET_CLOUD_PROVIDER_RESULT",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "SET_CLOUD_PROVIDER_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_CLOUD_PROVIDER",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_CLOUD_PROVIDER_RESULT",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "GET_CLOUD_PROVIDER_DETAILS",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "GET_CLOUD_PROVIDER_DETAILS_RESULT",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "CREATE_SURFACE_CONTROLLER",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "GRANT_MEDIA_READ_FOR_PACKAGE_CALL",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "REVOKE_READ_GRANT_FOR_PACKAGE_CALL",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "USES_FUSE_PASSTHROUGH",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "USES_FUSE_PASSTHROUGH_RESULT",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PICKER_MEDIA_INIT_CALL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_LOCAL_ONLY",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_ALBUM_ID",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_ALBUM_AUTHORITY",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_CALLING_PACKAGE_UID",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "SET_STABLE_URIS_FLAG",
    "type" : "String",
    "comment" : "\n     * Only used for testing.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "RUN_IDLE_MAINTENANCE_FOR_STABLE_URIS",
    "type" : "String",
    "comment" : "\n     * Only used for testing.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "READ_BACKUP",
    "type" : "String",
    "comment" : "\n     * Only used for testing.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "GET_OWNER_PACKAGE_NAME",
    "type" : "String",
    "comment" : "\n     * Only used for testing.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "GET_BACKUP_FILES",
    "type" : "String",
    "comment" : "\n     * Only used for testing.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "GET_RECOVERY_DATA",
    "type" : "String",
    "comment" : "\n     * Only used for testing.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "REMOVE_RECOVERY_DATA",
    "type" : "String",
    "comment" : "\n     * Only used for testing.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "DELETE_BACKED_UP_FILE_PATHS",
    "type" : "String",
    "comment" : "\n     * Only used for testing.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "QUERY_ARG_MIME_TYPE",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "QUERY_ARG_SIZE_BYTES",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "QUERY_ARG_ALBUM_ID",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "QUERY_ARG_ALBUM_AUTHORITY",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PARAM_DELETE_DATA",
    "type" : "String",
    "comment" : "\n     * This is for internal use by the media scanner only.\n     * Name of the (optional) Uri parameter that determines whether to skip deleting\n     * the file pointed to by the _data column, when deleting the database entry.\n     * The only appropriate value for this parameter is \"false\", in which case the\n     * delete will be skipped. Note especially that setting this to true, or omitting\n     * the parameter altogether, will perform the default action, which is different\n     * for different types of media.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PARAM_INCLUDE_PENDING",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PARAM_PROGRESS",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PARAM_REQUIRE_ORIGINAL",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PARAM_LIMIT",
    "type" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "MY_USER_ID",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "MY_UID",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PER_USER_RANGE",
    "type" : "int",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "PICK_IMAGES_MAX_LIMIT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "INTENT_ACTION_MUSIC_PLAYER",
    "type" : "String",
    "comment" : "\n     * Activity Action: Launch a music player.\n     * The activity should be able to play, browse, or manipulate music files stored on the device.\n     *\n     * @deprecated Use {@link android.content.Intent#CATEGORY_APP_MUSIC} instead.\n     ",
    "links" : [ "android.content.Intent#CATEGORY_APP_MUSIC" ]
  }, {
    "name" : "INTENT_ACTION_MEDIA_SEARCH",
    "type" : "String",
    "comment" : "\n     * Activity Action: Perform a search for media.\n     * Contains at least the {@link android.app.SearchManager#QUERY} extra.\n     * May also contain any combination of the following extras:\n     * EXTRA_MEDIA_ARTIST, EXTRA_MEDIA_ALBUM, EXTRA_MEDIA_TITLE, EXTRA_MEDIA_FOCUS\n     *\n     * @see android.provider.MediaStore#EXTRA_MEDIA_ARTIST\n     * @see android.provider.MediaStore#EXTRA_MEDIA_ALBUM\n     * @see android.provider.MediaStore#EXTRA_MEDIA_TITLE\n     * @see android.provider.MediaStore#EXTRA_MEDIA_FOCUS\n     ",
    "links" : [ "android.app.SearchManager#QUERY" ]
  }, {
    "name" : "INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH",
    "type" : "String",
    "comment" : "\n     * An intent to perform a search for music media and automatically play content from the\n     * result when possible. This can be fired, for example, by the result of a voice recognition\n     * command to listen to music.\n     * <p>This intent always includes the {@link android.provider.MediaStore#EXTRA_MEDIA_FOCUS}\n     * and {@link android.app.SearchManager#QUERY} extras. The\n     * {@link android.provider.MediaStore#EXTRA_MEDIA_FOCUS} extra determines the search mode, and\n     * the value of the {@link android.app.SearchManager#QUERY} extra depends on the search mode.\n     * For more information about the search modes for this intent, see\n     * <a href=\"{@docRoot}guide/components/intents-common.html#PlaySearch\">Play music based\n     * on a search query</a> in <a href=\"{@docRoot}guide/components/intents-common.html\">Common\n     * Intents</a>.</p>\n     *\n     * <p>This intent makes the most sense for apps that can support large-scale search of music,\n     * such as services connected to an online database of music which can be streamed and played\n     * on the device.</p>\n     ",
    "links" : [ "android.provider.MediaStore#EXTRA_MEDIA_FOCUS", "android.app.SearchManager#QUERY" ]
  }, {
    "name" : "INTENT_ACTION_TEXT_OPEN_FROM_SEARCH",
    "type" : "String",
    "comment" : "\n     * An intent to perform a search for readable media and automatically play content from the\n     * result when possible. This can be fired, for example, by the result of a voice recognition\n     * command to read a book or magazine.\n     * <p>\n     * Contains the {@link android.app.SearchManager#QUERY} extra, which is a string that can\n     * contain any type of unstructured text search, like the name of a book or magazine, an author\n     * a genre, a publisher, or any combination of these.\n     * <p>\n     * Because this intent includes an open-ended unstructured search string, it makes the most\n     * sense for apps that can support large-scale search of text media, such as services connected\n     * to an online database of books and/or magazines which can be read on the device.\n     ",
    "links" : [ "android.app.SearchManager#QUERY" ]
  }, {
    "name" : "INTENT_ACTION_VIDEO_PLAY_FROM_SEARCH",
    "type" : "String",
    "comment" : "\n     * An intent to perform a search for video media and automatically play content from the\n     * result when possible. This can be fired, for example, by the result of a voice recognition\n     * command to play movies.\n     * <p>\n     * Contains the {@link android.app.SearchManager#QUERY} extra, which is a string that can\n     * contain any type of unstructured video search, like the name of a movie, one or more actors,\n     * a genre, or any combination of these.\n     * <p>\n     * Because this intent includes an open-ended unstructured search string, it makes the most\n     * sense for apps that can support large-scale search of video, such as services connected to an\n     * online database of videos which can be streamed and played on the device.\n     ",
    "links" : [ "android.app.SearchManager#QUERY" ]
  }, {
    "name" : "EXTRA_MEDIA_ARTIST",
    "type" : "String",
    "comment" : "\n     * The name of the Intent-extra used to define the artist\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_MEDIA_ALBUM",
    "type" : "String",
    "comment" : "\n     * The name of the Intent-extra used to define the album\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_MEDIA_TITLE",
    "type" : "String",
    "comment" : "\n     * The name of the Intent-extra used to define the song title\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_MEDIA_GENRE",
    "type" : "String",
    "comment" : "\n     * The name of the Intent-extra used to define the genre.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_MEDIA_PLAYLIST",
    "type" : "String",
    "comment" : "\n     * The name of the Intent-extra used to define the playlist.\n     *\n     * @deprecated Android playlists are now deprecated. We will keep the current\n     *             functionality for compatibility resons, but we will no longer take feature\n     *             request. We do not advise adding new usages of Android Playlists. M3U files can\n     *             be used as an alternative.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_MEDIA_RADIO_CHANNEL",
    "type" : "String",
    "comment" : "\n     * The name of the Intent-extra used to define the radio channel.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_MEDIA_FOCUS",
    "type" : "String",
    "comment" : "\n     * The name of the Intent-extra used to define the search focus. The search focus\n     * indicates whether the search should be for things related to the artist, album\n     * or song that is identified by the other extras.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_SCREEN_ORIENTATION",
    "type" : "String",
    "comment" : "\n     * The name of the Intent-extra used to control the orientation of a ViewImage or a MovieView.\n     * This is an int property that overrides the activity's requestedOrientation.\n     * @see android.content.pm.ActivityInfo#SCREEN_ORIENTATION_UNSPECIFIED\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_FULL_SCREEN",
    "type" : "String",
    "comment" : "\n     * The name of an Intent-extra used to control the UI of a ViewImage.\n     * This is a boolean property that overrides the activity's default fullscreen state.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_SHOW_ACTION_ICONS",
    "type" : "String",
    "comment" : "\n     * The name of an Intent-extra used to control the UI of a ViewImage.\n     * This is a boolean property that specifies whether or not to show action icons.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_FINISH_ON_COMPLETION",
    "type" : "String",
    "comment" : "\n     * The name of the Intent-extra used to control the onCompletion behavior of a MovieView. This\n     * is a boolean property that specifies whether or not to finish the MovieView activity when the\n     * movie completes playing. The default value is true, which means to automatically exit the\n     * movie player activity when the movie completes playing.\n     ",
    "links" : [ ]
  }, {
    "name" : "INTENT_ACTION_STILL_IMAGE_CAMERA",
    "type" : "String",
    "comment" : " The name of the Intent action used to launch a camera in still image mode. ",
    "links" : [ ]
  }, {
    "name" : "META_DATA_STILL_IMAGE_CAMERA_PREWARM_SERVICE",
    "type" : "String",
    "comment" : "\n     * Name under which an activity handling {@link #INTENT_ACTION_STILL_IMAGE_CAMERA} or\n     * {@link #INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE} publishes the service name for its prewarm\n     * service.\n     * <p>\n     * This meta-data should reference the fully qualified class name of the prewarm service\n     * extending {@code CameraPrewarmService}.\n     * <p>\n     * The prewarm service will get bound and receive a prewarm signal\n     * {@code CameraPrewarmService#onPrewarm()} when a camera launch intent fire might be imminent.\n     * An application implementing a prewarm service should do the absolute minimum amount of work\n     * to initialize the camera in order to reduce startup time in likely case that shortly after a\n     * camera launch intent would be sent.\n     ",
    "links" : [ "#INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE", "#INTENT_ACTION_STILL_IMAGE_CAMERA" ]
  }, {
    "name" : "META_DATA_REVIEW_GALLERY_PREWARM_SERVICE",
    "type" : "java.lang.String",
    "comment" : "\n     * Name under which an activity handling {@link #ACTION_REVIEW} or\n     * {@link #ACTION_REVIEW_SECURE} publishes the service name for its prewarm\n     * service.\n     * <p>\n     * This meta-data should reference the fully qualified class name of the prewarm service\n     * <p>\n     * The prewarm service can be bound before starting {@link #ACTION_REVIEW} or\n     * {@link #ACTION_REVIEW_SECURE}.\n     * An application implementing this prewarm service should do the absolute minimum amount of\n     * work to initialize its resources to efficiently handle an {@link #ACTION_REVIEW} or\n     * {@link #ACTION_REVIEW_SECURE} in the near future.\n     ",
    "links" : [ "#ACTION_REVIEW_SECURE", "#ACTION_REVIEW" ]
  }, {
    "name" : "INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE",
    "type" : "String",
    "comment" : "\n     * The name of the Intent action used to launch a camera in still image mode\n     * for use when the device is secured (e.g. with a pin, password, pattern,\n     * or face unlock). Applications responding to this intent must not expose\n     * any personal content like existing photos or videos on the device. The\n     * applications should be careful not to share any photo or video with other\n     * applications or internet. The activity should use {@link\n     * Activity#setShowWhenLocked} to display\n     * on top of the lock screen while secured. There is no activity stack when\n     * this flag is used, so launching more than one activity is strongly\n     * discouraged.\n     ",
    "links" : [ "android.app.Activity#setShowWhenLocked" ]
  }, {
    "name" : "INTENT_ACTION_VIDEO_CAMERA",
    "type" : "String",
    "comment" : "\n     * The name of the Intent action used to launch a camera in video mode.\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_IMAGE_CAPTURE",
    "type" : "String",
    "comment" : "\n     * Standard Intent action that can be sent to have the camera application\n     * capture an image and return it.\n     * <p>\n     * The caller may pass an extra EXTRA_OUTPUT to control where this image will be written.\n     * If the EXTRA_OUTPUT is not present, then a small sized image is returned as a Bitmap\n     * object in the extra field. This is useful for applications that only need a small image.\n     * If the EXTRA_OUTPUT is present, then the full-sized image will be written to the Uri\n     * value of EXTRA_OUTPUT.\n     * As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this uri can also be supplied through\n     * {@link android.content.Intent#setClipData(ClipData)}. If using this approach, you still must\n     * supply the uri through the EXTRA_OUTPUT field for compatibility with old applications.\n     * If you don't set a ClipData, it will be copied there for you when calling\n     * {@link Context#startActivity(Intent)}.\n     * <p>\n     * Regardless of whether or not EXTRA_OUTPUT is present, when an image is captured via this\n     * intent, {@link android.hardware.Camera#ACTION_NEW_PICTURE} won't be broadcasted.\n     * <p>\n     * Note: if you app targets {@link android.os.Build.VERSION_CODES#M M} and above\n     * and declares as using the {@link android.Manifest.permission#CAMERA} permission which\n     * is not granted, then attempting to use this action will result in a {@link\n     * java.lang.SecurityException}.\n     *\n     *  @see #EXTRA_OUTPUT\n     *  @see android.hardware.Camera#ACTION_NEW_PICTURE\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#LOLLIPOP", "android.hardware.Camera#ACTION_NEW_PICTURE", "android.Manifest.permission#CAMERA", "java.lang.SecurityException", "android.content.Intent#setClipData(ClipData)", "android.content.Context#startActivity(Intent)", "android.os.Build.VERSION_CODES#M" ]
  }, {
    "name" : "ACTION_IMAGE_CAPTURE_SECURE",
    "type" : "String",
    "comment" : "\n     * Intent action that can be sent to have the camera application capture an image and return\n     * it when the device is secured (e.g. with a pin, password, pattern, or face unlock).\n     * Applications responding to this intent must not expose any personal content like existing\n     * photos or videos on the device. The applications should be careful not to share any photo\n     * or video with other applications or Internet. The activity should use {@link\n     * Activity#setShowWhenLocked} to display on top of the\n     * lock screen while secured. There is no activity stack when this flag is used, so\n     * launching more than one activity is strongly discouraged.\n     * <p>\n     * The caller may pass an extra EXTRA_OUTPUT to control where this image will be written.\n     * If the EXTRA_OUTPUT is not present, then a small sized image is returned as a Bitmap\n     * object in the extra field. This is useful for applications that only need a small image.\n     * If the EXTRA_OUTPUT is present, then the full-sized image will be written to the Uri\n     * value of EXTRA_OUTPUT.\n     * As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this uri can also be supplied through\n     * {@link android.content.Intent#setClipData(ClipData)}. If using this approach, you still must\n     * supply the uri through the EXTRA_OUTPUT field for compatibility with old applications.\n     * If you don't set a ClipData, it will be copied there for you when calling\n     * {@link Context#startActivity(Intent)}.\n     * <p>\n     * Regardless of whether or not EXTRA_OUTPUT is present, when an image is captured via this\n     * intent, {@link android.hardware.Camera#ACTION_NEW_PICTURE} won't be broadcasted.\n     *\n     * @see #ACTION_IMAGE_CAPTURE\n     * @see #EXTRA_OUTPUT\n     * @see android.hardware.Camera#ACTION_NEW_PICTURE\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#LOLLIPOP", "android.hardware.Camera#ACTION_NEW_PICTURE", "android.app.Activity#setShowWhenLocked", "android.content.Intent#setClipData(ClipData)", "android.content.Context#startActivity(Intent)" ]
  }, {
    "name" : "ACTION_VIDEO_CAPTURE",
    "type" : "String",
    "comment" : "\n     * Standard Intent action that can be sent to have the camera application\n     * capture a video and return it.\n     * <p>\n     * The caller may pass in an extra EXTRA_VIDEO_QUALITY to control the video quality.\n     * <p>\n     * The caller may pass in an extra EXTRA_OUTPUT to control\n     * where the video is written.\n     * <ul>\n     * <li>If EXTRA_OUTPUT is not present, the video will be written to the standard location\n     * for videos, and the Uri of that location will be returned in the data field of the Uri.\n     * {@link android.hardware.Camera#ACTION_NEW_VIDEO} will also be broadcasted when the video\n     * is recorded.\n     * <li>If EXTRA_OUTPUT is assigned a Uri value, no\n     * {@link android.hardware.Camera#ACTION_NEW_VIDEO} will be broadcasted. As of\n     * {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this uri can also be\n     * supplied through {@link android.content.Intent#setClipData(ClipData)}.  If using this\n     * approach, you still must supply the uri through the EXTRA_OUTPUT field for compatibility\n     * with old applications. If you don't set a ClipData, it will be copied there for you when\n     * calling {@link Context#startActivity(Intent)}.\n     * </ul>\n     *\n     * <p>Note: if you app targets {@link android.os.Build.VERSION_CODES#M M} and above\n     * and declares as using the {@link android.Manifest.permission#CAMERA} permission which\n     * is not granted, then atempting to use this action will result in a {@link\n     * java.lang.SecurityException}.\n     *\n     * @see #EXTRA_OUTPUT\n     * @see #EXTRA_VIDEO_QUALITY\n     * @see #EXTRA_SIZE_LIMIT\n     * @see #EXTRA_DURATION_LIMIT\n     * @see android.hardware.Camera#ACTION_NEW_VIDEO\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#LOLLIPOP", "android.Manifest.permission#CAMERA", "java.lang.SecurityException", "android.content.Intent#setClipData(ClipData)", "android.content.Context#startActivity(Intent)", "android.hardware.Camera#ACTION_NEW_VIDEO", "android.os.Build.VERSION_CODES#M" ]
  }, {
    "name" : "ACTION_REVIEW",
    "type" : "String",
    "comment" : "\n     * Standard action that can be sent to review the given media file.\n     * <p>\n     * The launched application is expected to provide a large-scale view of the\n     * given media file, while allowing the user to quickly access other\n     * recently captured media files.\n     * <p>\n     * Input: {@link Intent#getData} is URI of the primary media item to\n     * initially display.\n     *\n     * @see #ACTION_REVIEW_SECURE\n     * @see #EXTRA_BRIGHTNESS\n     ",
    "links" : [ "android.app.PendingIntent#getData" ]
  }, {
    "name" : "ACTION_REVIEW_SECURE",
    "type" : "String",
    "comment" : "\n     * Standard action that can be sent to review the given media file when the\n     * device is secured (e.g. with a pin, password, pattern, or face unlock).\n     * The applications should be careful not to share any media with other\n     * applications or Internet. The activity should use\n     * {@link Activity#setShowWhenLocked} to display on top of the lock screen\n     * while secured. There is no activity stack when this flag is used, so\n     * launching more than one activity is strongly discouraged.\n     * <p>\n     * The launched application is expected to provide a large-scale view of the\n     * given primary media file, while only allowing the user to quickly access\n     * other media from an explicit secondary list.\n     * <p>\n     * Input: {@link Intent#getData} is URI of the primary media item to\n     * initially display. {@link Intent#getClipData} is the limited list of\n     * secondary media items that the user is allowed to review. If\n     * {@link Intent#getClipData} is undefined, then no other media access\n     * should be allowed.\n     *\n     * @see #EXTRA_BRIGHTNESS\n     ",
    "links" : [ "android.app.PendingIntent#getData", "android.app.Activity#setShowWhenLocked", "android.app.PendingIntent#getClipData" ]
  }, {
    "name" : "EXTRA_BRIGHTNESS",
    "type" : "String",
    "comment" : "\n     * When defined, the launched application is requested to set the given\n     * brightness value via\n     * {@link android.view.WindowManager.LayoutParams#screenBrightness} to help\n     * ensure a smooth transition when launching {@link #ACTION_REVIEW} or\n     * {@link #ACTION_REVIEW_SECURE} intents.\n     ",
    "links" : [ "#ACTION_REVIEW_SECURE", "#ACTION_REVIEW", "android.view.WindowManager.LayoutParams#screenBrightness" ]
  }, {
    "name" : "EXTRA_VIDEO_QUALITY",
    "type" : "String",
    "comment" : "\n     * The name of the Intent-extra used to control the quality of a recorded video. This is an\n     * integer property. Currently value 0 means low quality, suitable for MMS messages, and\n     * value 1 means high quality. In the future other quality levels may be added.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_SIZE_LIMIT",
    "type" : "String",
    "comment" : "\n     * Specify the maximum allowed size.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_DURATION_LIMIT",
    "type" : "String",
    "comment" : "\n     * Specify the maximum allowed recording duration in seconds.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_OUTPUT",
    "type" : "String",
    "comment" : "\n     * The name of the Intent-extra used to indicate a content resolver Uri to be used to\n     * store the requested image or video.\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_PICK_IMAGES",
    "type" : "String",
    "comment" : "\n     * Activity Action: Allow the user to select images or videos provided by system and return it.\n     * This is different than {@link Intent#ACTION_PICK} and {@link Intent#ACTION_GET_CONTENT} in\n     * that\n     *\n     * <ul>\n     *   <li>the data for this action is provided by the system\n     *   <li>this action is only used for picking images and videos\n     *   <li>caller gets read access to user picked items even without storage permissions\n     * </ul>\n     *\n     * <p>Callers can optionally specify MIME type (such as {@code image/*} or {@code video/*}),\n     * resulting in a range of content selection that the caller is interested in. The optional MIME\n     * type can be requested with {@link Intent#setType(String)}.\n     *\n     * <p>If the caller needs multiple returned items (or caller wants to allow multiple selection),\n     * then it can specify {@link MediaStore#EXTRA_PICK_IMAGES_MAX} to indicate this.\n     *\n     * <p>When the caller requests multiple selection, the value of {@link\n     * MediaStore#EXTRA_PICK_IMAGES_MAX} must be a positive integer greater than 1 and less than or\n     * equal to {@link MediaStore#getPickImagesMaxLimit}, otherwise {@link Activity#RESULT_CANCELED}\n     * is returned. Use {@link MediaStore#EXTRA_PICK_IMAGES_IN_ORDER} in multiple selection mode to\n     * allow the user to pick images in order.\n     *\n     * <p>Callers may use {@link Intent#EXTRA_LOCAL_ONLY} to limit content selection to local data.\n     *\n     * <p>Output: MediaStore content URI(s) of the item(s) that was picked. Unlike other MediaStore\n     * URIs, these are referred to as 'picker' URIs and expose a limited set of read-only\n     * operations. Specifically, picker URIs can only be opened for read and queried for columns in\n     * {@link PickerMediaColumns}.\n     *\n     * <p>Before this API, apps could use {@link Intent#ACTION_GET_CONTENT}. However, {@link\n     * #ACTION_PICK_IMAGES} is now the recommended option for images and videos, since it offers a\n     * better user experience.\n     ",
    "links" : [ "android.app.PendingIntent#ACTION_PICK", "android.app.Activity#RESULT_CANCELED", "android.app.PendingIntent#setType(String)", "android.provider.MediaStore#getPickImagesMaxLimit", "android.provider.MediaStore#EXTRA_PICK_IMAGES_MAX", "#ACTION_PICK_IMAGES", "android.app.PendingIntent#EXTRA_LOCAL_ONLY", "android.app.PendingIntent#ACTION_GET_CONTENT", "PickerMediaColumns", "android.provider.MediaStore#EXTRA_PICK_IMAGES_IN_ORDER" ]
  }, {
    "name" : "ACTION_USER_SELECT_IMAGES_FOR_APP",
    "type" : "String",
    "comment" : "\n     * Activity Action: This is a system action for when users choose to select media to share with\n     * an app rather than granting allow all visual media.\n     *\n     * <p>\n     * Callers must specify the intent-extra integer\n     * {@link Intent#EXTRA_UID} with the uid of the app that\n     * will receive the MediaProvider grants for the selected files.\n     * <p>\n     * Callers can optionally specify MIME type (such as {@code image/*} or {@code video/*}),\n     * resulting in a range of content selection that the caller is interested in. The optional MIME\n     * type can be requested with {@link Intent#setType(String)}.\n     * <p>\n     * This action does not alter any permission state for the app, and does not check any\n     * permission state for the app in the underlying media provider file access grants.\n     *\n     * <p>If images/videos were successfully picked this will return {@link Activity#RESULT_OK}\n     * otherwise {@link Activity#RESULT_CANCELED} is returned.\n     *\n     * <p><strong>NOTE:</strong> You should probably not use this. This action requires the {@link\n     * Manifest.permission#GRANT_RUNTIME_PERMISSIONS } permission.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.Activity#RESULT_CANCELED", "android.app.PendingIntent#EXTRA_UID", "android.app.PendingIntent#setType(String)", "android.app.Activity#RESULT_OK", "Manifest.permission#GRANT_RUNTIME_PERMISSIONS" ]
  }, {
    "name" : "ACTION_PICK_IMAGES_SETTINGS",
    "type" : "String",
    "comment" : "\n     * Activity Action: Launch settings controlling images or videos selection with\n     * {@link #ACTION_PICK_IMAGES}.\n     *\n     * The settings page allows a user to change the enabled {@link CloudMediaProvider} on the\n     * device and other media selection configurations.\n     *\n     * @see #ACTION_PICK_IMAGES\n     * @see #isCurrentCloudMediaProviderAuthority(ContentResolver, String)\n     ",
    "links" : [ "#ACTION_PICK_IMAGES", "android.provider.CloudMediaProvider" ]
  }, {
    "name" : "EXTRA_PICK_IMAGES_IN_ORDER",
    "type" : "String",
    "comment" : "\n     * The name of an optional intent-extra used to allow ordered selection of items. Set this extra\n     * to true to allow the user to see the order of their selected items. The result returned to\n     * the caller will be the same as the user selected order. This extra is only allowed via the\n     * {@link MediaStore#ACTION_PICK_IMAGES}.\n     *\n     * <p>The value of this intent-extra should be a boolean. Default value is false.\n     *\n     * @see #ACTION_PICK_IMAGES\n     ",
    "links" : [ "android.provider.MediaStore#ACTION_PICK_IMAGES" ]
  }, {
    "name" : "EXTRA_PICK_IMAGES_MAX",
    "type" : "String",
    "comment" : "\n     * The name of an optional intent-extra used to allow multiple selection of\n     * items and constrain maximum number of items that can be returned by\n     * {@link MediaStore#ACTION_PICK_IMAGES}, action may still return nothing\n     * (0 items) if the user chooses to cancel.\n     * <p>\n     * The value of this intent-extra should be a positive integer greater\n     * than 1 and less than or equal to\n     * {@link MediaStore#getPickImagesMaxLimit}, otherwise\n     * {@link Activity#RESULT_CANCELED} is returned.\n     ",
    "links" : [ "android.app.Activity#RESULT_CANCELED", "android.provider.MediaStore#getPickImagesMaxLimit", "android.provider.MediaStore#ACTION_PICK_IMAGES" ]
  }, {
    "name" : "EXTRA_PICK_IMAGES_ACCENT_COLOR",
    "type" : "String",
    "comment" : "\n     * The name of an optional intent-extra used to allow apps to specify the picker accent color.\n     * The extra can only be specified in {@link MediaStore#ACTION_PICK_IMAGES}.\n     * The accent color will be used for various primary elements in the PhotoPicker view.\n     * All other colors will be set based on android material guidelines.\n     * <p>\n     * The value of this intent extra should be a long color value. The alpha component of the\n     * given color is not taken into account while setting the accent color. We assume full color\n     * opacity.\n     * Only colors with luminance(can also be understood as brightness) greater than 0.05 and\n     * less than 0.9 are permitted.\n     * Luminance of a color is determined using:\n     * luminance = Color.luminance(color)\n     *       where color is the input accent color to be set.\n     * Check {@link Color} docs for more details on color luminance and long color values.\n     * In case the luminance of the input color is unacceptable, picker colors will be set\n     * based on the colors of the device android theme.\n     * In case of an invalid input color value i.e. the input color cannot be parsed,\n     * {@code IllegalArgumentException} is thrown.\n     ",
    "links" : [ "Color", "android.provider.MediaStore#ACTION_PICK_IMAGES" ]
  }, {
    "name" : "EXTRA_PICK_IMAGES_LAUNCH_TAB",
    "type" : "String",
    "comment" : "\n     * The name of an optional intent-extra used to allow apps to specify the tab the picker should\n     * open with. The extra can only be specified in {@link MediaStore#ACTION_PICK_IMAGES}.\n     * <p>\n     * The value of this intent-extra must be one of: {@link MediaStore#PICK_IMAGES_TAB_ALBUMS}\n     * for the albums tab and {@link MediaStore#PICK_IMAGES_TAB_IMAGES} for the photos tab.\n     * The system will decide which tab to open by default and in most cases,\n     * it is {@link MediaStore#PICK_IMAGES_TAB_IMAGES} i.e. the photos tab.\n     ",
    "links" : [ "android.provider.MediaStore#PICK_IMAGES_TAB_IMAGES", "android.provider.MediaStore#ACTION_PICK_IMAGES", "android.provider.MediaStore#PICK_IMAGES_TAB_ALBUMS" ]
  }, {
    "name" : "PICK_IMAGES_TAB_ALBUMS",
    "type" : "int",
    "comment" : "\n     * One of the permitted values for {@link MediaStore#EXTRA_PICK_IMAGES_LAUNCH_TAB} to open the\n     * picker with albums tab.\n     ",
    "links" : [ "android.provider.MediaStore#EXTRA_PICK_IMAGES_LAUNCH_TAB" ]
  }, {
    "name" : "PICK_IMAGES_TAB_IMAGES",
    "type" : "int",
    "comment" : "\n     * One of the permitted values for {@link MediaStore#EXTRA_PICK_IMAGES_LAUNCH_TAB} to open the\n     * picker with photos tab.\n     ",
    "links" : [ "android.provider.MediaStore#EXTRA_PICK_IMAGES_LAUNCH_TAB" ]
  }, {
    "name" : "EXTRA_ACCEPT_ORIGINAL_MEDIA_FORMAT",
    "type" : "String",
    "comment" : "\n     * Specify that the caller wants to receive the original media format without transcoding.\n     *\n     * <b>Caution: using this flag can cause app\n     * compatibility issues whenever Android adds support for new media formats.</b>\n     * Clients should instead specify their supported media capabilities explicitly\n     * in their manifest or with the {@link #EXTRA_MEDIA_CAPABILITIES} {@code open} flag.\n     *\n     * This option is useful for apps that don't attempt to parse the actual byte contents of media\n     * files, such as playback using {@link MediaPlayer} or for off-device backup. Note that the\n     * {@link android.Manifest.permission#ACCESS_MEDIA_LOCATION} permission will still be required\n     * to avoid sensitive metadata redaction, similar to {@link #setRequireOriginal(Uri)}.\n     * </ul>\n     *\n     * Note that this flag overrides any explicitly declared {@code media_capabilities.xml} or\n     * {@link ApplicationMediaCapabilities} extras specified in the same {@code open} request.\n     *\n     * <p>This option can be added to the {@code opts} {@link Bundle} in various\n     * {@link ContentResolver} {@code open} methods.\n     *\n     * @see ContentResolver#openTypedAssetFileDescriptor(Uri, String, Bundle)\n     * @see ContentResolver#openTypedAssetFile(Uri, String, Bundle, CancellationSignal)\n     * @see #setRequireOriginal(Uri)\n     * @see MediaStore#getOriginalMediaFormatFileDescriptor(Context, ParcelFileDescriptor)\n     ",
    "links" : [ "#EXTRA_MEDIA_CAPABILITIES", "android.Manifest.permission#ACCESS_MEDIA_LOCATION", "android.os.Bundle", "#setRequireOriginal(Uri)", "android.content.ContentResolver", "android.media.ApplicationMediaCapabilities", "android.media.MediaPlayer" ]
  }, {
    "name" : "EXTRA_MEDIA_CAPABILITIES",
    "type" : "String",
    "comment" : "\n     * Specify the {@link ApplicationMediaCapabilities} that should be used while opening a media.\n     *\n     * If the capabilities specified matches the format of the original file, the app will receive\n     * the original file, otherwise, it will get transcoded to a default supported format.\n     *\n     * This flag takes higher precedence over the applications declared\n     * {@code media_capabilities.xml} and is useful for apps that want to have more granular control\n     * over their supported media capabilities.\n     *\n     * <p>This option can be added to the {@code opts} {@link Bundle} in various\n     * {@link ContentResolver} {@code open} methods.\n     *\n     * @see ContentResolver#openTypedAssetFileDescriptor(Uri, String, Bundle)\n     * @see ContentResolver#openTypedAssetFile(Uri, String, Bundle, CancellationSignal)\n     ",
    "links" : [ "android.os.Bundle", "android.content.ContentResolver", "android.media.ApplicationMediaCapabilities" ]
  }, {
    "name" : "EXTRA_MEDIA_CAPABILITIES_UID",
    "type" : "String",
    "comment" : "\n     * Specify the UID of the app that should be used to determine supported media capabilities\n     * while opening a media.\n     *\n     * If this specified UID is found to be capable of handling the original media file format, the\n     * app will receive the original file, otherwise, the file will get transcoded to a default\n     * format supported by the specified UID.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PICKER_PRE_SELECTION_URIS",
    "type" : "String",
    "comment" : "\n     * The name of an optional intent-extra used to specify URIs for pre-selection in photo picker\n     * opened with {@link MediaStore#ACTION_PICK_IMAGES} in multi-select mode.\n     *\n     * <p>Only MediaStore content URI(s) of the item(s) received as a result of\n     * {@link MediaStore#ACTION_PICK_IMAGES} action are accepted. The value of this intent-extra\n     * should be an ArrayList of type parcelables. Default value is null. Maximum number of URIs\n     * that can be accepted is limited by the value passed in\n     * {@link MediaStore#EXTRA_PICK_IMAGES_MAX} as part of the {@link MediaStore#ACTION_PICK_IMAGES}\n     * intent. In case the count of input URIs is greater than the limit then\n     * {@code IllegalArgumentException} is thrown.</p>\n     *\n     * <p>The provided list will be checked for permissions and authority. Any URI that is\n     * inaccessible, doesn't match the current authorities(local or cloud) or is invalid will be\n     * filtered out.</p>\n     *\n     * <p>The items corresponding to the URIs will appear selected when the photo picker is opened.\n     * In the case of {@link MediaStore#EXTRA_PICK_IMAGES_IN_ORDER} the chronological order of the\n     * input list will be used for ordered selection of the pre-selected items.</p>\n     *\n     * <p>This is not a mechanism to revoke permissions for items, i.e. de-selection of a\n     * pre-selected item by the user will not result in revocation of the grant.</p>\n     ",
    "links" : [ "android.provider.MediaStore#EXTRA_PICK_IMAGES_MAX", "android.provider.MediaStore#ACTION_PICK_IMAGES", "android.provider.MediaStore#EXTRA_PICK_IMAGES_IN_ORDER" ]
  }, {
    "name" : "EXTRA_MODE",
    "type" : "String",
    "comment" : "\n     * Flag used to set file mode in bundle for opening a document.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "UNKNOWN_STRING",
    "type" : "String",
    "comment" : "\n      * The string that is used when a media attribute is not known. For example,\n      * if an audio file does not have any meta data, the artist and album columns\n      * will be set to this value.\n      ",
    "links" : [ ]
  }, {
    "name" : "QUERY_ARG_RELATED_URI",
    "type" : "String",
    "comment" : "\n     * Specify a {@link Uri} that is \"related\" to the current operation being\n     * performed.\n     * <p>\n     * This is typically used to allow an operation that may normally be\n     * rejected, such as making a copy of a pre-existing image located under a\n     * {@link MediaColumns#RELATIVE_PATH} where new images are not allowed.\n     * <p>\n     * It's strongly recommended that when making a copy of pre-existing content\n     * that you define the \"original document ID\" GUID as defined by the <em>XMP\n     * Media Management</em> standard.\n     * <p>\n     * This key can be placed in a {@link Bundle} of extras and passed to\n     * {@link ContentResolver#insert}.\n     ",
    "links" : [ "#RELATIVE_PATH", "android.os.Bundle", "android.net.Uri", "android.content.ContentResolver#insert" ]
  }, {
    "name" : "QUERY_ARG_ALLOW_MOVEMENT",
    "type" : "String",
    "comment" : "\n     * Flag that can be used to enable movement of media items on disk through\n     * {@link ContentResolver#update} calls. This is typically true for\n     * third-party apps, but false for system components.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.ContentResolver#update" ]
  }, {
    "name" : "QUERY_ARG_DEFER_SCAN",
    "type" : "String",
    "comment" : "\n     * Flag that indicates that a media scan that was triggered as part of\n     * {@link ContentResolver#update} should be asynchronous. This flag should\n     * only be used when {@link ContentResolver#update} operation needs to\n     * return early without updating metadata for the file. This may make other\n     * apps see incomplete metadata for the updated file as scan runs\n     * asynchronously here.\n     * Note that when this flag is set, the published file will not appear in\n     * default query until the deferred scan is complete.\n     * Most apps shouldn't set this flag.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.ContentResolver#update" ]
  }, {
    "name" : "QUERY_ARG_INCLUDE_RECENTLY_UNMOUNTED_VOLUMES",
    "type" : "String",
    "comment" : "\n     * Flag that requests {@link ContentResolver#query} to include content from\n     * recently unmounted volumes.\n     * <p>\n     * When the flag is set, {@link ContentResolver#query} will return content\n     * from all volumes(i.e., both mounted and recently unmounted volume whose\n     * content is still held by MediaProvider).\n     * <p>\n     * Note that the query result doesn't provide any hint for content from\n     * unmounted volume. It's strongly recommended to use default query to\n     * avoid accessing/operating on the content that are not available on the\n     * device.\n     * <p>\n     * The flag is useful for apps which manage their own database and\n     * query MediaStore in order to synchronize between MediaStore database\n     * and their own database.\n     ",
    "links" : [ "android.content.ContentResolver#query" ]
  }, {
    "name" : "QUERY_ARG_MATCH_PENDING",
    "type" : "String",
    "comment" : "\n     * Specify how {@link MediaColumns#IS_PENDING} items should be filtered when\n     * performing a {@link MediaStore} operation.\n     * <p>\n     * This key can be placed in a {@link Bundle} of extras and passed to\n     * {@link ContentResolver#query}, {@link ContentResolver#update}, or\n     * {@link ContentResolver#delete}.\n     * <p>\n     * By default, pending items are filtered away from operations.\n     ",
    "links" : [ "android.content.ContentResolver#delete", "android.os.Bundle", "#IS_PENDING", "android.provider.MediaStore", "android.content.ContentResolver#update", "android.content.ContentResolver#query" ]
  }, {
    "name" : "QUERY_ARG_MATCH_TRASHED",
    "type" : "String",
    "comment" : "\n     * Specify how {@link MediaColumns#IS_TRASHED} items should be filtered when\n     * performing a {@link MediaStore} operation.\n     * <p>\n     * This key can be placed in a {@link Bundle} of extras and passed to\n     * {@link ContentResolver#query}, {@link ContentResolver#update}, or\n     * {@link ContentResolver#delete}.\n     * <p>\n     * By default, trashed items are filtered away from operations.\n     *\n     * @see MediaColumns#IS_TRASHED\n     * @see MediaStore#QUERY_ARG_MATCH_TRASHED\n     * @see MediaStore#createTrashRequest\n     ",
    "links" : [ "android.content.ContentResolver#delete", "android.os.Bundle", "android.provider.MediaStore", "android.content.ContentResolver#update", "#IS_TRASHED", "android.content.ContentResolver#query" ]
  }, {
    "name" : "QUERY_ARG_MATCH_FAVORITE",
    "type" : "String",
    "comment" : "\n     * Specify how {@link MediaColumns#IS_FAVORITE} items should be filtered\n     * when performing a {@link MediaStore} operation.\n     * <p>\n     * This key can be placed in a {@link Bundle} of extras and passed to\n     * {@link ContentResolver#query}, {@link ContentResolver#update}, or\n     * {@link ContentResolver#delete}.\n     * <p>\n     * By default, favorite items are <em>not</em> filtered away from\n     * operations.\n     *\n     * @see MediaColumns#IS_FAVORITE\n     * @see MediaStore#QUERY_ARG_MATCH_FAVORITE\n     * @see MediaStore#createFavoriteRequest\n     ",
    "links" : [ "android.content.ContentResolver#delete", "#IS_FAVORITE", "android.os.Bundle", "android.provider.MediaStore", "android.content.ContentResolver#update", "android.content.ContentResolver#query" ]
  }, {
    "name" : "QUERY_ARG_LATEST_SELECTION_ONLY",
    "type" : "String",
    "comment" : "\n     * Flag that indicates if only the latest selection in the photoPicker for\n     * the calling app should be returned. If set to true, all items that were\n     * granted to the calling app in the last selection are returned.\n     *\n     * <p>Selection in this scenario refers to when the user selects items in\n     * <b> the permission prompt photo picker</b>. The access for these items\n     * is granted to the calling app and these grants are persisted unless the\n     * user deselects a granted item explicitly.</p>\n     *\n     * <p>The result excludes items owned by the calling app unless they are\n     * explicitly selected by the user.</p>\n     *\n     * <p>Note: If there has been no user selections after the introduction of\n     * this feature then all the granted items will be returned.</p>\n     *\n     * <p>This key can be placed in a {@link Bundle} of extras and passed to\n     * {@link ContentResolver#query}.</p>\n     *\n     * @see android.Manifest.permission#READ_MEDIA_VISUAL_USER_SELECTED\n     ",
    "links" : [ "android.os.Bundle", "android.content.ContentResolver#query" ]
  }, {
    "name" : "ACCESS_MEDIA_OWNER_PACKAGE_NAME_PERMISSION",
    "type" : "String",
    "comment" : "\n     * Permission that grants access to {@link MediaColumns#OWNER_PACKAGE_NAME}\n     * of every accessible media file.\n     ",
    "links" : [ "#OWNER_PACKAGE_NAME" ]
  }, {
    "name" : "MATCH_DEFAULT",
    "type" : "int",
    "comment" : "\n     * Value indicating that the default matching behavior should be used, as\n     * defined by the key documentation.\n     ",
    "links" : [ ]
  }, {
    "name" : "MATCH_INCLUDE",
    "type" : "int",
    "comment" : "\n     * Value indicating that operations should include items matching the\n     * criteria defined by this key.\n     * <p>\n     * Note that items <em>not</em> matching the criteria <em>may</em> also be\n     * included depending on the default behavior documented by the key. If you\n     * want to operate exclusively on matching items, use {@link #MATCH_ONLY}.\n     ",
    "links" : [ "#MATCH_ONLY" ]
  }, {
    "name" : "MATCH_EXCLUDE",
    "type" : "int",
    "comment" : "\n     * Value indicating that operations should exclude items matching the\n     * criteria defined by this key.\n     ",
    "links" : [ ]
  }, {
    "name" : "MATCH_ONLY",
    "type" : "int",
    "comment" : "\n     * Value indicating that operations should only operate on items explicitly\n     * matching the criteria defined by this key.\n     ",
    "links" : [ ]
  }, {
    "name" : "PATTERN_VOLUME_NAME",
    "type" : "Pattern",
    "comment" : "\n     * Regex that matches paths under well-known storage paths.\n     * Copied from FileUtils.java\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_SCANNER_VOLUME",
    "type" : "String",
    "comment" : "\n     * Name of current volume being scanned by the media scanner.\n     ",
    "links" : [ ]
  }, {
    "name" : "MEDIA_IGNORE_FILENAME",
    "type" : "String",
    "comment" : "\n     * Name of the file signaling the media scanner to ignore media in the containing directory\n     * and its subdirectories. Developers should use this to avoid application graphics showing\n     * up in the Gallery and likewise prevent application sounds and music from showing up in\n     * the Music app.\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static int getPickImagesMaxLimit()",
    "returnType" : "int",
    "comment" : "\n     * The maximum limit for the number of items that can be selected using\n     * {@link MediaStore#ACTION_PICK_IMAGES} when launched in multiple selection mode.\n     * This can be used as a constant value for {@link MediaStore#EXTRA_PICK_IMAGES_MAX}.\n     ",
    "links" : [ "android.provider.MediaStore#EXTRA_PICK_IMAGES_MAX", "android.provider.MediaStore#ACTION_PICK_IMAGES" ]
  }, {
    "name" : "public static Uri setIncludePending(@NonNull Uri uri)",
    "returnType" : "Uri",
    "comment" : "\n     * Update the given {@link Uri} to also include any pending media items from\n     * calls such as\n     * {@link ContentResolver#query(Uri, String[], Bundle, CancellationSignal)}.\n     * By default no pending items are returned.\n     *\n     * @see MediaColumns#IS_PENDING\n     * @deprecated consider migrating to {@link #QUERY_ARG_MATCH_PENDING} which\n     *             is more expressive.\n     ",
    "links" : [ "android.content.ContentResolver#query(Uri", "android.net.Uri", "#QUERY_ARG_MATCH_PENDING" ]
  }, {
    "name" : "public static Uri.Builder setIncludePending(@NonNull Uri.Builder uriBuilder)",
    "returnType" : "Uri.Builder",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static boolean getIncludePending(@NonNull Uri uri)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static Uri setRequireOriginal(@NonNull Uri uri)",
    "returnType" : "Uri",
    "comment" : "\n     * Update the given {@link Uri} to indicate that the caller requires the\n     * original file contents when calling\n     * {@link ContentResolver#openFileDescriptor(Uri, String)}.\n     * <p>\n     * This can be useful when the caller wants to ensure they're backing up the\n     * exact bytes of the underlying media, without any Exif redaction being\n     * performed.\n     * <p>\n     * If the original file contents cannot be provided, a\n     * {@link UnsupportedOperationException} will be thrown when the returned\n     * {@link Uri} is used, such as when the caller doesn't hold\n     * {@link android.Manifest.permission#ACCESS_MEDIA_LOCATION}.\n     *\n     * @see MediaStore#getRequireOriginal(Uri)\n     ",
    "links" : [ "android.Manifest.permission#ACCESS_MEDIA_LOCATION", "android.net.Uri", "android.content.ContentResolver#openFileDescriptor(Uri", "UnsupportedOperationException" ]
  }, {
    "name" : "public static boolean getRequireOriginal(@NonNull Uri uri)",
    "returnType" : "boolean",
    "comment" : "\n     * Return if the caller requires the original file contents when calling\n     * {@link ContentResolver#openFileDescriptor(Uri, String)}.\n     *\n     * @see MediaStore#setRequireOriginal(Uri)\n     ",
    "links" : [ "android.content.ContentResolver#openFileDescriptor(Uri" ]
  }, {
    "name" : "public static ParcelFileDescriptor getOriginalMediaFormatFileDescriptor(@NonNull Context context, @NonNull ParcelFileDescriptor fileDescriptor) throws IOException",
    "returnType" : "ParcelFileDescriptor",
    "comment" : "\n     * Returns {@link ParcelFileDescriptor} representing the original media file format for\n     * {@code fileDescriptor}.\n     *\n     * <p>Media files may get transcoded based on an application's media capabilities requirements.\n     * However, in various cases, when the application needs access to the original media file, or\n     * doesn't attempt to parse the actual byte contents of media files, such as playback using\n     * {@link MediaPlayer} or for off-device backup, this method can be useful.\n     *\n     * <p>This method is applicable only for media files managed by {@link MediaStore}.\n     *\n     * <p>The method returns the original file descriptor with the same permission that the caller\n     * has for the input file descriptor.\n     *\n     * @throws IOException if the given {@link ParcelFileDescriptor} could not be converted\n     *\n     * @see MediaStore#EXTRA_ACCEPT_ORIGINAL_MEDIA_FORMAT\n     ",
    "links" : [ "android.os.ParcelFileDescriptor", "android.provider.MediaStore", "android.media.MediaPlayer" ]
  }, {
    "name" : "public static Uri rewriteToLegacy(@NonNull Uri uri)",
    "returnType" : "Uri",
    "comment" : "\n     * Rewrite the given {@link Uri} to point at\n     * {@link MediaStore#AUTHORITY_LEGACY}.\n     *\n     * @see #AUTHORITY_LEGACY\n     * @hide\n     ",
    "links" : [ "android.provider.MediaStore#AUTHORITY_LEGACY", "android.net.Uri" ]
  }, {
    "name" : "public static void startLegacyMigration(@NonNull ContentResolver resolver, @NonNull String volumeName)",
    "returnType" : "void",
    "comment" : "\n     * Called by the Mainline module to signal to {@link #AUTHORITY_LEGACY} that\n     * data migration is starting.\n     *\n     * @hide\n     ",
    "links" : [ "#AUTHORITY_LEGACY" ]
  }, {
    "name" : "public static void finishLegacyMigration(@NonNull ContentResolver resolver, @NonNull String volumeName)",
    "returnType" : "void",
    "comment" : "\n     * Called by the Mainline module to signal to {@link #AUTHORITY_LEGACY} that\n     * data migration is finished. The legacy provider may choose to perform\n     * clean-up operations at this point, such as deleting databases.\n     *\n     * @hide\n     ",
    "links" : [ "#AUTHORITY_LEGACY" ]
  }, {
    "name" : "private static PendingIntent createRequest(@NonNull ContentResolver resolver, @NonNull String method, @NonNull Collection<Uri> uris, @Nullable ContentValues values)",
    "returnType" : "PendingIntent",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static PendingIntent createWriteRequest(@NonNull ContentResolver resolver, @NonNull Collection<Uri> uris)",
    "returnType" : "PendingIntent",
    "comment" : "\n     * Create a {@link PendingIntent} that will prompt the user to grant your\n     * app write access for the requested media items.\n     * <p>\n     * This call only generates the request for a prompt; to display the prompt,\n     * call {@link Activity#startIntentSenderForResult} with\n     * {@link PendingIntent#getIntentSender()}. You can then determine if the\n     * user granted your request by testing for {@link Activity#RESULT_OK} in\n     * {@link Activity#onActivityResult}. The requested operation will have\n     * completely finished before this activity result is delivered.\n     * <p>\n     * Permissions granted through this mechanism are tied to the lifecycle of\n     * the {@link Activity} that requests them. If you need to retain\n     * longer-term access for background actions, you can place items into a\n     * {@link ClipData} or {@link Intent} which can then be passed to\n     * {@link Context#startService} or\n     * {@link android.app.job.JobInfo.Builder#setClipData}. Be sure to include\n     * any relevant access modes you want to retain, such as\n     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION}.\n     * <p>\n     * The displayed prompt will reflect all the media items you're requesting,\n     * including those for which you already hold write access. If you want to\n     * determine if you already hold write access before requesting access, use\n     * {@link Context#checkUriPermission(Uri, int, int, int)} with\n     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION}.\n     * <p>\n     * For security and performance reasons this method does not support\n     * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} or\n     * {@link Intent#FLAG_GRANT_PREFIX_URI_PERMISSION}.\n     * <p>\n     * The write access granted through this request is general-purpose, and\n     * once obtained you can directly {@link ContentResolver#update} columns\n     * like {@link MediaColumns#IS_FAVORITE}, {@link MediaColumns#IS_TRASHED},\n     * or {@link ContentResolver#delete}.\n     *\n     * @param resolver Used to connect with {@link MediaStore#AUTHORITY}.\n     *            Typically this value is {@link Context#getContentResolver()},\n     *            but if you need more explicit lifecycle controls, you can\n     *            obtain a {@link ContentProviderClient} and wrap it using\n     *            {@link ContentResolver#wrap(ContentProviderClient)}.\n     * @param uris The set of media items to include in this request. Each item\n     *            must be hosted by {@link MediaStore#AUTHORITY} and must\n     *            reference a specific media item by {@link BaseColumns#_ID}.\n     ",
    "links" : [ "android.content.Context#startService", "android.content.ContentResolver#delete", "android.app.PendingIntent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION", "android.content.Context#checkUriPermission(Uri", "android.app.PendingIntent#getIntentSender()", "android.app.Activity#onActivityResult", "android.provider.BaseColumns#_ID", "android.app.PendingIntent", "android.app.job.JobInfo.Builder#setClipData", "android.provider.MediaStore#AUTHORITY", "android.content.ContentResolver#wrap(ContentProviderClient)", "#IS_TRASHED", "android.content.ClipData", "android.app.Activity#startIntentSenderForResult", "android.app.Activity#RESULT_OK", "#IS_FAVORITE", "android.app.PendingIntent#FLAG_GRANT_PREFIX_URI_PERMISSION", "android.content.Context#getContentResolver()", "android.content.ContentProviderClient", "android.content.ContentResolver#update", "android.app.Activity", "android.app.PendingIntent#FLAG_GRANT_WRITE_URI_PERMISSION" ]
  }, {
    "name" : "public static PendingIntent createTrashRequest(@NonNull ContentResolver resolver, @NonNull Collection<Uri> uris, boolean value)",
    "returnType" : "PendingIntent",
    "comment" : "\n     * Create a {@link PendingIntent} that will prompt the user to trash the\n     * requested media items. When the user approves this request,\n     * {@link MediaColumns#IS_TRASHED} is set on these items.\n     * <p>\n     * This call only generates the request for a prompt; to display the prompt,\n     * call {@link Activity#startIntentSenderForResult} with\n     * {@link PendingIntent#getIntentSender()}. You can then determine if the\n     * user granted your request by testing for {@link Activity#RESULT_OK} in\n     * {@link Activity#onActivityResult}. The requested operation will have\n     * completely finished before this activity result is delivered.\n     * <p>\n     * The displayed prompt will reflect all the media items you're requesting,\n     * including those for which you already hold write access. If you want to\n     * determine if you already hold write access before requesting access, use\n     * {@link Context#checkUriPermission(Uri, int, int, int)} with\n     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION}.\n     *\n     * @param resolver Used to connect with {@link MediaStore#AUTHORITY}.\n     *            Typically this value is {@link Context#getContentResolver()},\n     *            but if you need more explicit lifecycle controls, you can\n     *            obtain a {@link ContentProviderClient} and wrap it using\n     *            {@link ContentResolver#wrap(ContentProviderClient)}.\n     * @param uris The set of media items to include in this request. Each item\n     *            must be hosted by {@link MediaStore#AUTHORITY} and must\n     *            reference a specific media item by {@link BaseColumns#_ID}.\n     * @param value The {@link MediaColumns#IS_TRASHED} value to apply.\n     * @see MediaColumns#IS_TRASHED\n     * @see MediaStore#QUERY_ARG_MATCH_TRASHED\n     ",
    "links" : [ "android.content.Context#checkUriPermission(Uri", "android.app.PendingIntent#getIntentSender()", "android.app.Activity#onActivityResult", "android.provider.BaseColumns#_ID", "android.app.PendingIntent", "android.provider.MediaStore#AUTHORITY", "android.content.ContentResolver#wrap(ContentProviderClient)", "#IS_TRASHED", "android.app.Activity#startIntentSenderForResult", "android.app.Activity#RESULT_OK", "android.content.Context#getContentResolver()", "android.content.ContentProviderClient", "android.app.PendingIntent#FLAG_GRANT_WRITE_URI_PERMISSION" ]
  }, {
    "name" : "public static PendingIntent createFavoriteRequest(@NonNull ContentResolver resolver, @NonNull Collection<Uri> uris, boolean value)",
    "returnType" : "PendingIntent",
    "comment" : "\n     * Create a {@link PendingIntent} that will prompt the user to favorite the\n     * requested media items. When the user approves this request,\n     * {@link MediaColumns#IS_FAVORITE} is set on these items.\n     * <p>\n     * This call only generates the request for a prompt; to display the prompt,\n     * call {@link Activity#startIntentSenderForResult} with\n     * {@link PendingIntent#getIntentSender()}. You can then determine if the\n     * user granted your request by testing for {@link Activity#RESULT_OK} in\n     * {@link Activity#onActivityResult}. The requested operation will have\n     * completely finished before this activity result is delivered.\n     * <p>\n     * The displayed prompt will reflect all the media items you're requesting,\n     * including those for which you already hold write access. If you want to\n     * determine if you already hold write access before requesting access, use\n     * {@link Context#checkUriPermission(Uri, int, int, int)} with\n     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION}.\n     *\n     * @param resolver Used to connect with {@link MediaStore#AUTHORITY}.\n     *            Typically this value is {@link Context#getContentResolver()},\n     *            but if you need more explicit lifecycle controls, you can\n     *            obtain a {@link ContentProviderClient} and wrap it using\n     *            {@link ContentResolver#wrap(ContentProviderClient)}.\n     * @param uris The set of media items to include in this request. Each item\n     *            must be hosted by {@link MediaStore#AUTHORITY} and must\n     *            reference a specific media item by {@link BaseColumns#_ID}.\n     * @param value The {@link MediaColumns#IS_FAVORITE} value to apply.\n     * @see MediaColumns#IS_FAVORITE\n     * @see MediaStore#QUERY_ARG_MATCH_FAVORITE\n     ",
    "links" : [ "android.content.Context#checkUriPermission(Uri", "android.app.PendingIntent#getIntentSender()", "android.app.Activity#onActivityResult", "android.provider.BaseColumns#_ID", "android.app.PendingIntent", "android.provider.MediaStore#AUTHORITY", "android.content.ContentResolver#wrap(ContentProviderClient)", "android.app.Activity#startIntentSenderForResult", "#IS_FAVORITE", "android.app.Activity#RESULT_OK", "android.content.Context#getContentResolver()", "android.content.ContentProviderClient", "android.app.PendingIntent#FLAG_GRANT_WRITE_URI_PERMISSION" ]
  }, {
    "name" : "public static PendingIntent createDeleteRequest(@NonNull ContentResolver resolver, @NonNull Collection<Uri> uris)",
    "returnType" : "PendingIntent",
    "comment" : "\n     * Create a {@link PendingIntent} that will prompt the user to permanently\n     * delete the requested media items. When the user approves this request,\n     * {@link ContentResolver#delete} will be called on these items.\n     * <p>\n     * This call only generates the request for a prompt; to display the prompt,\n     * call {@link Activity#startIntentSenderForResult} with\n     * {@link PendingIntent#getIntentSender()}. You can then determine if the\n     * user granted your request by testing for {@link Activity#RESULT_OK} in\n     * {@link Activity#onActivityResult}. The requested operation will have\n     * completely finished before this activity result is delivered.\n     * <p>\n     * The displayed prompt will reflect all the media items you're requesting,\n     * including those for which you already hold write access. If you want to\n     * determine if you already hold write access before requesting access, use\n     * {@link Context#checkUriPermission(Uri, int, int, int)} with\n     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION}.\n     *\n     * @param resolver Used to connect with {@link MediaStore#AUTHORITY}.\n     *            Typically this value is {@link Context#getContentResolver()},\n     *            but if you need more explicit lifecycle controls, you can\n     *            obtain a {@link ContentProviderClient} and wrap it using\n     *            {@link ContentResolver#wrap(ContentProviderClient)}.\n     * @param uris The set of media items to include in this request. Each item\n     *            must be hosted by {@link MediaStore#AUTHORITY} and must\n     *            reference a specific media item by {@link BaseColumns#_ID}.\n     ",
    "links" : [ "android.content.ContentResolver#delete", "android.content.Context#checkUriPermission(Uri", "android.app.PendingIntent#getIntentSender()", "android.app.Activity#onActivityResult", "android.provider.BaseColumns#_ID", "android.app.PendingIntent", "android.provider.MediaStore#AUTHORITY", "android.content.ContentResolver#wrap(ContentProviderClient)", "android.app.Activity#startIntentSenderForResult", "android.app.Activity#RESULT_OK", "android.content.Context#getContentResolver()", "android.content.ContentProviderClient", "android.app.PendingIntent#FLAG_GRANT_WRITE_URI_PERMISSION" ]
  }, {
    "name" : "public static String getVolumeName(@NonNull File path)",
    "returnType" : "String",
    "comment" : "\n     * @deprecated since this method doesn't have a {@link Context}, we can't\n     *             find the actual {@link StorageVolume} for the given path, so\n     *             only a vague guess is returned. Callers should use\n     *             {@link StorageManager#getStorageVolume(File)} instead.\n     * @hide\n     ",
    "links" : [ "android.content.Context", "android.os.storage.StorageVolume", "android.os.storage.StorageManager#getStorageVolume(File)" ]
  }, {
    "name" : "public static Set<String> getExternalVolumeNames(@NonNull Context context)",
    "returnType" : "Set<String>",
    "comment" : "\n     * Return list of all specific volume names that make up\n     * {@link #VOLUME_EXTERNAL}. This includes a unique volume name for each\n     * shared storage device that is currently attached, which typically\n     * includes {@link MediaStore#VOLUME_EXTERNAL_PRIMARY}.\n     * <p>\n     * Each specific volume name can be passed to APIs like\n     * {@link MediaStore.Images.Media#getContentUri(String)} to interact with\n     * media on that storage device.\n     ",
    "links" : [ "android.provider.MediaStore#VOLUME_EXTERNAL_PRIMARY", "MediaStore.Images.Media#getContentUri(String)", "#VOLUME_EXTERNAL" ]
  }, {
    "name" : "public static Set<String> getRecentExternalVolumeNames(@NonNull Context context)",
    "returnType" : "Set<String>",
    "comment" : "\n     * Return list of all recent volume names that have been part of\n     * {@link #VOLUME_EXTERNAL}.\n     * <p>\n     * These volume names are not currently mounted, but they're likely to\n     * reappear in the future, so apps are encouraged to preserve any indexed\n     * metadata related to these volumes to optimize user experiences.\n     * <p>\n     * Each specific volume name can be passed to APIs like\n     * {@link MediaStore.Images.Media#getContentUri(String)} to interact with\n     * media on that storage device.\n     ",
    "links" : [ "MediaStore.Images.Media#getContentUri(String)", "#VOLUME_EXTERNAL" ]
  }, {
    "name" : "public static String getVolumeName(@NonNull Uri uri)",
    "returnType" : "String",
    "comment" : "\n     * Return the volume name that the given {@link Uri} references.\n     ",
    "links" : [ "android.net.Uri" ]
  }, {
    "name" : "public static boolean isKnownVolume(@NonNull String volumeName)",
    "returnType" : "boolean",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static String checkArgumentVolumeName(@NonNull String volumeName)",
    "returnType" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static Uri getMediaScannerUri()",
    "returnType" : "Uri",
    "comment" : "\n     * Uri for querying the state of the media scanner.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getVersion(@NonNull Context context)",
    "returnType" : "String",
    "comment" : "\n     * Return an opaque version string describing the {@link MediaStore} state.\n     * <p>\n     * Applications that import data from {@link MediaStore} into their own\n     * caches can use this to detect that {@link MediaStore} has undergone\n     * substantial changes, and that data should be rescanned.\n     * <p>\n     * No other assumptions should be made about the meaning of the version.\n     * <p>\n     * This method returns the version for\n     * {@link MediaStore#VOLUME_EXTERNAL_PRIMARY}; to obtain a version for a\n     * different volume, use {@link #getVersion(Context, String)}.\n     ",
    "links" : [ "android.provider.MediaStore#VOLUME_EXTERNAL_PRIMARY", "android.provider.MediaStore", "#getVersion(Context" ]
  }, {
    "name" : "public static String getVersion(@NonNull Context context, @NonNull String volumeName)",
    "returnType" : "String",
    "comment" : "\n     * Return an opaque version string describing the {@link MediaStore} state.\n     * <p>\n     * Applications that import data from {@link MediaStore} into their own\n     * caches can use this to detect that {@link MediaStore} has undergone\n     * substantial changes, and that data should be rescanned.\n     * <p>\n     * No other assumptions should be made about the meaning of the version.\n     *\n     * @param volumeName specific volume to obtain an opaque version string for.\n     *            Must be one of the values returned from\n     *            {@link #getExternalVolumeNames(Context)}.\n     ",
    "links" : [ "#getExternalVolumeNames(Context)", "android.provider.MediaStore" ]
  }, {
    "name" : "public static long getGeneration(@NonNull Context context, @NonNull String volumeName)",
    "returnType" : "long",
    "comment" : "\n     * Return the latest generation value for the given volume.\n     * <p>\n     * Generation numbers are useful for apps that are attempting to quickly\n     * identify exactly which media items have been added or changed since a\n     * previous point in time. Generation numbers are monotonically increasing\n     * over time, and can be safely arithmetically compared.\n     * <p>\n     * Detecting media changes using generation numbers is more robust than\n     * using {@link MediaColumns#DATE_ADDED} or\n     * {@link MediaColumns#DATE_MODIFIED}, since those values may change in\n     * unexpected ways when apps use {@link File#setLastModified(long)} or when\n     * the system clock is set incorrectly.\n     * <p>\n     * Note that before comparing these detailed generation values, you should\n     * first confirm that the overall version hasn't changed by checking\n     * {@link MediaStore#getVersion(Context, String)}, since that indicates when\n     * a more radical change has occurred. If the overall version changes, you\n     * should assume that generation numbers have been reset and perform a full\n     * synchronization pass.\n     *\n     * @param volumeName specific volume to obtain an generation value for. Must\n     *            be one of the values returned from\n     *            {@link #getExternalVolumeNames(Context)}.\n     * @see MediaColumns#GENERATION_ADDED\n     * @see MediaColumns#GENERATION_MODIFIED\n     ",
    "links" : [ "#getExternalVolumeNames(Context)", "android.provider.MediaStore#getVersion(Context", "#DATE_ADDED", "java.io.File#setLastModified(long)", "#DATE_MODIFIED" ]
  }, {
    "name" : "public static long getGeneration(@NonNull ContentResolver resolver, @NonNull String volumeName)",
    "returnType" : "long",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static Uri getDocumentUri(@NonNull Context context, @NonNull Uri mediaUri)",
    "returnType" : "Uri",
    "comment" : "\n     * Return a {@link DocumentsProvider} Uri that is an equivalent to the given\n     * {@link MediaStore} Uri.\n     * <p>\n     * This allows apps with Storage Access Framework permissions to convert\n     * between {@link MediaStore} and {@link DocumentsProvider} Uris that refer\n     * to the same underlying item. Note that this method doesn't grant any new\n     * permissions; callers must already hold permissions obtained with\n     * {@link Intent#ACTION_OPEN_DOCUMENT} or related APIs.\n     *\n     * @param mediaUri The {@link MediaStore} Uri to convert.\n     * @return An equivalent {@link DocumentsProvider} Uri. Returns {@code null}\n     *         if no equivalent was found.\n     * @see #getMediaUri(Context, Uri)\n     ",
    "links" : [ "android.app.PendingIntent#ACTION_OPEN_DOCUMENT", "android.provider.MediaStore", "android.provider.DocumentsProvider" ]
  }, {
    "name" : "public static Uri getMediaUri(@NonNull Context context, @NonNull Uri documentUri)",
    "returnType" : "Uri",
    "comment" : "\n     * Return a {@link MediaStore} Uri that is an equivalent to the given\n     * {@link DocumentsProvider} Uri. This only supports {@code ExternalStorageProvider}\n     * and {@code MediaDocumentsProvider} Uris.\n     * <p>\n     * This allows apps with Storage Access Framework permissions to convert\n     * between {@link MediaStore} and {@link DocumentsProvider} Uris that refer\n     * to the same underlying item.\n     * Note that this method doesn't grant any new permissions, but it grants the same access to\n     * the Media Store Uri as the caller has to the given DocumentsProvider Uri; callers must\n     * already hold permissions for documentUri obtained with {@link Intent#ACTION_OPEN_DOCUMENT}\n     * or related APIs.\n     *\n     * @param documentUri The {@link DocumentsProvider} Uri to convert.\n     * @return An equivalent {@link MediaStore} Uri. Returns {@code null} if no\n     *         equivalent was found.\n     * @see #getDocumentUri(Context, Uri)\n     ",
    "links" : [ "android.app.PendingIntent#ACTION_OPEN_DOCUMENT", "android.provider.MediaStore", "android.provider.DocumentsProvider" ]
  }, {
    "name" : "public static boolean isCurrentSystemGallery(@NonNull ContentResolver resolver, int uid, @NonNull String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the given application is the current system gallery of the device.\n     * <p>\n     * The system gallery is one app chosen by the OEM that has read & write access to all photos\n     * and videos on the device and control over folders in media collections.\n     *\n     * @param resolver The {@link ContentResolver} used to connect with\n     * {@link MediaStore#AUTHORITY}. Typically this value is {@link Context#getContentResolver()}.\n     * @param uid The uid to be checked if it is the current system gallery.\n     * @param packageName The package name to be checked if it is the current system gallery.\n     ",
    "links" : [ "android.content.ContentResolver", "android.content.Context#getContentResolver()", "android.provider.MediaStore#AUTHORITY" ]
  }, {
    "name" : "private static Uri maybeRemoveUserId(@NonNull Uri uri)",
    "returnType" : "Uri",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static List<Uri> maybeRemoveUserId(@NonNull List<Uri> uris)",
    "returnType" : "List<Uri>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static int getUserIdFromUri(Uri uri)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static Uri maybeAddUserId(@NonNull Uri uri, String userId)",
    "returnType" : "Uri",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static List<Uri> maybeAddUserId(@NonNull List<Uri> uris, String userId)",
    "returnType" : "List<Uri>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static Uri getRedactedUri(@NonNull ContentResolver resolver, @NonNull Uri uri)",
    "returnType" : "Uri",
    "comment" : "\n     * Returns an EXIF redacted version of {@code uri} i.e. a {@link Uri} with metadata such as\n     * location, GPS datestamp etc. redacted from the EXIF headers.\n     * <p>\n     * A redacted Uri can be used to share a file with another application wherein exposing\n     * sensitive information in EXIF headers is not desirable.\n     * Note:\n     * 1. Redacted uris cannot be granted write access and can neither be used to perform any kind\n     * of write operations.\n     * 2. To get a redacted uri the caller must hold read permission to {@code uri}.\n     *\n     * @param resolver The {@link ContentResolver} used to connect with\n     * {@link MediaStore#AUTHORITY}. Typically this value is gotten from\n     * {@link Context#getContentResolver()}\n     * @param uri the {@link Uri} Uri to convert\n     * @return redacted version of the {@code uri}. Returns {@code null} when the given\n     * {@link Uri} could not be found or is unsupported\n     * @throws SecurityException if the caller doesn't have the read access to {@code uri}\n     * @see #getRedactedUri(ContentResolver, List)\n     ",
    "links" : [ "android.content.ContentResolver", "android.content.Context#getContentResolver()", "android.net.Uri", "android.provider.MediaStore#AUTHORITY" ]
  }, {
    "name" : "private static void verifyUrisBelongToSingleUserId(@NonNull List<Uri> uris)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static List<Uri> getRedactedUri(@NonNull ContentResolver resolver, @NonNull List<Uri> uris)",
    "returnType" : "List<Uri>",
    "comment" : "\n     * Returns a list of EXIF redacted version of {@code uris} i.e. a {@link Uri} with metadata\n     * such as location, GPS datestamp etc. redacted from the EXIF headers.\n     * <p>\n     * A redacted Uri can be used to share a file with another application wherein exposing\n     * sensitive information in EXIF headers is not desirable.\n     * Note:\n     * 1. Order of the returned uris follow the order of the {@code uris}.\n     * 2. Redacted uris cannot be granted write access and can neither be used to perform any kind\n     * of write operations.\n     * 3. To get a redacted uri the caller must hold read permission to its corresponding uri.\n     *\n     * @param resolver The {@link ContentResolver} used to connect with\n     * {@link MediaStore#AUTHORITY}. Typically this value is gotten from\n     * {@link Context#getContentResolver()}\n     * @param uris the list of {@link Uri} Uri to convert\n     * @return a list with redacted version of {@code uris}, in the same order. Returns {@code null}\n     * when the corresponding {@link Uri} could not be found or is unsupported\n     * @throws SecurityException if the caller doesn't have the read access to all the elements\n     * in {@code uris}\n     * @throws IllegalArgumentException if all the uris in {@code uris} don't belong to same user id\n     * @see #getRedactedUri(ContentResolver, Uri)\n     ",
    "links" : [ "android.content.ContentResolver", "android.content.Context#getContentResolver()", "android.net.Uri", "android.provider.MediaStore#AUTHORITY" ]
  }, {
    "name" : "public static void resolvePlaylistMembers(@NonNull ContentResolver resolver, @NonNull Uri playlistUri)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static void runIdleMaintenance(@NonNull ContentResolver resolver)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static void setStableUrisFlag(@NonNull ContentResolver resolver, @NonNull String volumeName, boolean isEnabled)",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static void runIdleMaintenanceForStableUris(@NonNull ContentResolver resolver)",
    "returnType" : "void",
    "comment" : "\n     * Only used for testing.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String readBackup(@NonNull ContentResolver resolver, String volumeName, String filePath)",
    "returnType" : "String",
    "comment" : "\n     * Only used for testing.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getOwnerPackageName(@NonNull ContentResolver resolver, int ownerId)",
    "returnType" : "String",
    "comment" : "\n     * Only used for testing.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void deleteBackedUpFilePaths(@NonNull ContentResolver resolver, String volumeName)",
    "returnType" : "void",
    "comment" : "\n     * Only used for testing.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String[] getBackupFiles(@NonNull ContentResolver resolver)",
    "returnType" : "String[]",
    "comment" : "\n     * Only used for testing.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String[] getRecoveryData(@NonNull ContentResolver resolver)",
    "returnType" : "String[]",
    "comment" : "\n     * Only used for testing.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void removeRecoveryData(@NonNull ContentResolver resolver)",
    "returnType" : "void",
    "comment" : "\n     * Only used for testing.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void waitForIdle(@NonNull ContentResolver resolver)",
    "returnType" : "void",
    "comment" : "\n     * Block until any pending operations have finished, such as\n     * {@link #scanFile} or {@link #scanVolume} requests.\n     *\n     * @hide\n     ",
    "links" : [ "#scanVolume", "#scanFile" ]
  }, {
    "name" : "public static Uri scanFile(@NonNull ContentResolver resolver, @NonNull File file)",
    "returnType" : "Uri",
    "comment" : "\n     * Perform a blocking scan of the given {@link File}, returning the\n     * {@link Uri} of the scanned file.\n     *\n     * @hide\n     ",
    "links" : [ "android.net.Uri", "java.io.File" ]
  }, {
    "name" : "public static void scanVolume(@NonNull ContentResolver resolver, @NonNull String volumeName)",
    "returnType" : "void",
    "comment" : "\n     * Perform a blocking scan of the given storage volume.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean canManageMedia(@NonNull Context context)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the calling app is granted {@link android.Manifest.permission#MANAGE_MEDIA}\n     * or not.\n     * <p>Declaring the permission {@link android.Manifest.permission#MANAGE_MEDIA} isn't\n     * enough to gain the access.\n     * <p>To request access, use {@link android.provider.Settings#ACTION_REQUEST_MANAGE_MEDIA}.\n     *\n     * @param context the request context\n     * @return true, the calling app is granted the permission. Otherwise, false\n     *\n     * @see android.Manifest.permission#MANAGE_MEDIA\n     * @see android.provider.Settings#ACTION_REQUEST_MANAGE_MEDIA\n     * @see #createDeleteRequest(ContentResolver, Collection)\n     * @see #createTrashRequest(ContentResolver, Collection, boolean)\n     * @see #createWriteRequest(ContentResolver, Collection)\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_MEDIA", "android.provider.Settings#ACTION_REQUEST_MANAGE_MEDIA" ]
  }, {
    "name" : "public static boolean isCurrentCloudMediaProviderAuthority(@NonNull ContentResolver resolver, @NonNull String authority)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if and only if the caller with {@code authority} is the currently\n     * enabled {@link CloudMediaProvider}. More specifically, {@code false} is also returned\n     * if the calling uid doesn't match the uid of the {@code authority}.\n     *\n     * @see android.provider.CloudMediaProvider\n     * @see #isSupportedCloudMediaProviderAuthority(ContentResolver, String)\n     ",
    "links" : [ "android.provider.CloudMediaProvider" ]
  }, {
    "name" : "public static boolean isSupportedCloudMediaProviderAuthority(@NonNull ContentResolver resolver, @NonNull String authority)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if and only if the caller with {@code authority} is a supported\n     * {@link CloudMediaProvider}. More specifically, {@code false} is also returned\n     * if the calling uid doesn't match the uid of the {@code authority}.\n     *\n     * @see android.provider.CloudMediaProvider\n     * @see #isCurrentCloudMediaProviderAuthority(ContentResolver, String)\n     ",
    "links" : [ "android.provider.CloudMediaProvider" ]
  }, {
    "name" : "public static void notifyCloudMediaChangedEvent(@NonNull ContentResolver resolver, @NonNull String authority, @NonNull String currentMediaCollectionId) throws SecurityException",
    "returnType" : "void",
    "comment" : "\n     * Notifies the OS about a cloud media event requiring a full or incremental media collection\n     * sync for the currently enabled cloud provider, {@code authority}.\n     *\n     * The OS will schedule the sync in the background and will attempt to batch frequent\n     * notifications into a single sync event.\n     *\n     * If the caller is not the currently enabled cloud provider as returned by\n     * {@link #isCurrentCloudMediaProviderAuthority(ContentResolver, String)}, the request will be\n     * unsuccessful.\n     *\n     * @throws SecurityException if the request was unsuccessful.\n     ",
    "links" : [ "#isCurrentCloudMediaProviderAuthority(ContentResolver" ]
  }, {
    "name" : "private static boolean callForCloudProvider(ContentResolver resolver, String method, String callingAuthority)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static String getCurrentCloudProvider(@NonNull ContentResolver resolver)",
    "returnType" : "String",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static void grantMediaReadForPackage(@NonNull Context context, int packageUid, List<Uri> uris)",
    "returnType" : "void",
    "comment" : "\n     * Grant {@link com.android.providers.media.MediaGrants} for the given package, for the\n     * list of local (to the device) content uris. These must be valid picker uris.\n     *\n     * @hide\n     ",
    "links" : [ "com.android.providers.media.MediaGrants" ]
  }, {
    "name" : "public static void revokeMediaReadForPackages(@NonNull Context context, int packageUid, @NonNull List<Uri> uris)",
    "returnType" : "void",
    "comment" : "\n     * Revoke {@link com.android.providers.media.MediaGrants} for the given package, for the\n     * list of local (to the device) content uris. These must be valid picker uris.\n     *\n     * @hide\n     ",
    "links" : [ "com.android.providers.media.MediaGrants" ]
  } ],
  "methodNames" : [ "public static int getPickImagesMaxLimit()", "public static Uri setIncludePending(@NonNull Uri uri)", "public static Uri.Builder setIncludePending(@NonNull Uri.Builder uriBuilder)", "public static boolean getIncludePending(@NonNull Uri uri)", "public static Uri setRequireOriginal(@NonNull Uri uri)", "public static boolean getRequireOriginal(@NonNull Uri uri)", "public static ParcelFileDescriptor getOriginalMediaFormatFileDescriptor(@NonNull Context context, @NonNull ParcelFileDescriptor fileDescriptor) throws IOException", "public static Uri rewriteToLegacy(@NonNull Uri uri)", "public static void startLegacyMigration(@NonNull ContentResolver resolver, @NonNull String volumeName)", "public static void finishLegacyMigration(@NonNull ContentResolver resolver, @NonNull String volumeName)", "private static PendingIntent createRequest(@NonNull ContentResolver resolver, @NonNull String method, @NonNull Collection<Uri> uris, @Nullable ContentValues values)", "public static PendingIntent createWriteRequest(@NonNull ContentResolver resolver, @NonNull Collection<Uri> uris)", "public static PendingIntent createTrashRequest(@NonNull ContentResolver resolver, @NonNull Collection<Uri> uris, boolean value)", "public static PendingIntent createFavoriteRequest(@NonNull ContentResolver resolver, @NonNull Collection<Uri> uris, boolean value)", "public static PendingIntent createDeleteRequest(@NonNull ContentResolver resolver, @NonNull Collection<Uri> uris)", "public static String getVolumeName(@NonNull File path)", "public static Set<String> getExternalVolumeNames(@NonNull Context context)", "public static Set<String> getRecentExternalVolumeNames(@NonNull Context context)", "public static String getVolumeName(@NonNull Uri uri)", "public static boolean isKnownVolume(@NonNull String volumeName)", "public static String checkArgumentVolumeName(@NonNull String volumeName)", "public static Uri getMediaScannerUri()", "public static String getVersion(@NonNull Context context)", "public static String getVersion(@NonNull Context context, @NonNull String volumeName)", "public static long getGeneration(@NonNull Context context, @NonNull String volumeName)", "public static long getGeneration(@NonNull ContentResolver resolver, @NonNull String volumeName)", "public static Uri getDocumentUri(@NonNull Context context, @NonNull Uri mediaUri)", "public static Uri getMediaUri(@NonNull Context context, @NonNull Uri documentUri)", "public static boolean isCurrentSystemGallery(@NonNull ContentResolver resolver, int uid, @NonNull String packageName)", "private static Uri maybeRemoveUserId(@NonNull Uri uri)", "private static List<Uri> maybeRemoveUserId(@NonNull List<Uri> uris)", "private static int getUserIdFromUri(Uri uri)", "private static Uri maybeAddUserId(@NonNull Uri uri, String userId)", "private static List<Uri> maybeAddUserId(@NonNull List<Uri> uris, String userId)", "public static Uri getRedactedUri(@NonNull ContentResolver resolver, @NonNull Uri uri)", "private static void verifyUrisBelongToSingleUserId(@NonNull List<Uri> uris)", "public static List<Uri> getRedactedUri(@NonNull ContentResolver resolver, @NonNull List<Uri> uris)", "public static void resolvePlaylistMembers(@NonNull ContentResolver resolver, @NonNull Uri playlistUri)", "public static void runIdleMaintenance(@NonNull ContentResolver resolver)", "public static void setStableUrisFlag(@NonNull ContentResolver resolver, @NonNull String volumeName, boolean isEnabled)", "public static void runIdleMaintenanceForStableUris(@NonNull ContentResolver resolver)", "public static String readBackup(@NonNull ContentResolver resolver, String volumeName, String filePath)", "public static String getOwnerPackageName(@NonNull ContentResolver resolver, int ownerId)", "public static void deleteBackedUpFilePaths(@NonNull ContentResolver resolver, String volumeName)", "public static String[] getBackupFiles(@NonNull ContentResolver resolver)", "public static String[] getRecoveryData(@NonNull ContentResolver resolver)", "public static void removeRecoveryData(@NonNull ContentResolver resolver)", "public static void waitForIdle(@NonNull ContentResolver resolver)", "public static Uri scanFile(@NonNull ContentResolver resolver, @NonNull File file)", "public static void scanVolume(@NonNull ContentResolver resolver, @NonNull String volumeName)", "public static boolean canManageMedia(@NonNull Context context)", "public static boolean isCurrentCloudMediaProviderAuthority(@NonNull ContentResolver resolver, @NonNull String authority)", "public static boolean isSupportedCloudMediaProviderAuthority(@NonNull ContentResolver resolver, @NonNull String authority)", "public static void notifyCloudMediaChangedEvent(@NonNull ContentResolver resolver, @NonNull String authority, @NonNull String currentMediaCollectionId) throws SecurityException", "private static boolean callForCloudProvider(ContentResolver resolver, String method, String callingAuthority)", "public static String getCurrentCloudProvider(@NonNull ContentResolver resolver)", "public static void grantMediaReadForPackage(@NonNull Context context, int packageUid, List<Uri> uris)", "public static void revokeMediaReadForPackages(@NonNull Context context, int packageUid, @NonNull List<Uri> uris)" ],
  "variableNames" : [ "TAG", "AUTHORITY", "AUTHORITY_URI", "AUTHORITY_LEGACY", "AUTHORITY_LEGACY_URI", "VOLUME_INTERNAL", "VOLUME_EXTERNAL", "VOLUME_EXTERNAL_PRIMARY", "VOLUME_DEMO", "RESOLVE_PLAYLIST_MEMBERS_CALL", "RUN_IDLE_MAINTENANCE_CALL", "WAIT_FOR_IDLE_CALL", "SCAN_FILE_CALL", "SCAN_VOLUME_CALL", "CREATE_WRITE_REQUEST_CALL", "CREATE_TRASH_REQUEST_CALL", "CREATE_FAVORITE_REQUEST_CALL", "CREATE_DELETE_REQUEST_CALL", "GET_VERSION_CALL", "GET_GENERATION_CALL", "START_LEGACY_MIGRATION_CALL", "FINISH_LEGACY_MIGRATION_CALL", "EXTERNAL_STORAGE_PROVIDER_AUTHORITY", "GET_DOCUMENT_URI_CALL", "GET_MEDIA_URI_CALL", "GET_REDACTED_MEDIA_URI_CALL", "GET_REDACTED_MEDIA_URI_LIST_CALL", "EXTRA_URI_LIST", "QUERY_ARG_REDACTED_URI", "EXTRA_URI", "EXTRA_URI_PERMISSIONS", "EXTRA_CLIP_DATA", "EXTRA_CONTENT_VALUES", "EXTRA_RESULT", "EXTRA_FILE_DESCRIPTOR", "EXTRA_LOCAL_PROVIDER", "EXTRA_IS_STABLE_URIS_ENABLED", "IS_SYSTEM_GALLERY_CALL", "EXTRA_IS_SYSTEM_GALLERY_UID", "EXTRA_IS_SYSTEM_GALLERY_RESPONSE", "IS_CURRENT_CLOUD_PROVIDER_CALL", "IS_SUPPORTED_CLOUD_PROVIDER_CALL", "NOTIFY_CLOUD_MEDIA_CHANGED_EVENT_CALL", "SYNC_PROVIDERS_CALL", "GET_CLOUD_PROVIDER_CALL", "GET_CLOUD_PROVIDER_RESULT", "GET_CLOUD_PROVIDER_LABEL_CALL", "SET_CLOUD_PROVIDER_RESULT", "SET_CLOUD_PROVIDER_CALL", "EXTRA_CLOUD_PROVIDER", "EXTRA_CLOUD_PROVIDER_RESULT", "GET_CLOUD_PROVIDER_DETAILS", "GET_CLOUD_PROVIDER_DETAILS_RESULT", "CREATE_SURFACE_CONTROLLER", "GRANT_MEDIA_READ_FOR_PACKAGE_CALL", "REVOKE_READ_GRANT_FOR_PACKAGE_CALL", "USES_FUSE_PASSTHROUGH", "USES_FUSE_PASSTHROUGH_RESULT", "PICKER_MEDIA_INIT_CALL", "EXTRA_LOCAL_ONLY", "EXTRA_ALBUM_ID", "EXTRA_ALBUM_AUTHORITY", "EXTRA_CALLING_PACKAGE_UID", "SET_STABLE_URIS_FLAG", "RUN_IDLE_MAINTENANCE_FOR_STABLE_URIS", "READ_BACKUP", "GET_OWNER_PACKAGE_NAME", "GET_BACKUP_FILES", "GET_RECOVERY_DATA", "REMOVE_RECOVERY_DATA", "DELETE_BACKED_UP_FILE_PATHS", "QUERY_ARG_MIME_TYPE", "QUERY_ARG_SIZE_BYTES", "QUERY_ARG_ALBUM_ID", "QUERY_ARG_ALBUM_AUTHORITY", "PARAM_DELETE_DATA", "PARAM_INCLUDE_PENDING", "PARAM_PROGRESS", "PARAM_REQUIRE_ORIGINAL", "PARAM_LIMIT", "MY_USER_ID", "MY_UID", "PER_USER_RANGE", "PICK_IMAGES_MAX_LIMIT", "INTENT_ACTION_MUSIC_PLAYER", "INTENT_ACTION_MEDIA_SEARCH", "INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH", "INTENT_ACTION_TEXT_OPEN_FROM_SEARCH", "INTENT_ACTION_VIDEO_PLAY_FROM_SEARCH", "EXTRA_MEDIA_ARTIST", "EXTRA_MEDIA_ALBUM", "EXTRA_MEDIA_TITLE", "EXTRA_MEDIA_GENRE", "EXTRA_MEDIA_PLAYLIST", "EXTRA_MEDIA_RADIO_CHANNEL", "EXTRA_MEDIA_FOCUS", "EXTRA_SCREEN_ORIENTATION", "EXTRA_FULL_SCREEN", "EXTRA_SHOW_ACTION_ICONS", "EXTRA_FINISH_ON_COMPLETION", "INTENT_ACTION_STILL_IMAGE_CAMERA", "META_DATA_STILL_IMAGE_CAMERA_PREWARM_SERVICE", "META_DATA_REVIEW_GALLERY_PREWARM_SERVICE", "INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE", "INTENT_ACTION_VIDEO_CAMERA", "ACTION_IMAGE_CAPTURE", "ACTION_IMAGE_CAPTURE_SECURE", "ACTION_VIDEO_CAPTURE", "ACTION_REVIEW", "ACTION_REVIEW_SECURE", "EXTRA_BRIGHTNESS", "EXTRA_VIDEO_QUALITY", "EXTRA_SIZE_LIMIT", "EXTRA_DURATION_LIMIT", "EXTRA_OUTPUT", "ACTION_PICK_IMAGES", "ACTION_USER_SELECT_IMAGES_FOR_APP", "ACTION_PICK_IMAGES_SETTINGS", "EXTRA_PICK_IMAGES_IN_ORDER", "EXTRA_PICK_IMAGES_MAX", "EXTRA_PICK_IMAGES_ACCENT_COLOR", "EXTRA_PICK_IMAGES_LAUNCH_TAB", "PICK_IMAGES_TAB_ALBUMS", "PICK_IMAGES_TAB_IMAGES", "EXTRA_ACCEPT_ORIGINAL_MEDIA_FORMAT", "EXTRA_MEDIA_CAPABILITIES", "EXTRA_MEDIA_CAPABILITIES_UID", "EXTRA_PICKER_PRE_SELECTION_URIS", "EXTRA_MODE", "UNKNOWN_STRING", "QUERY_ARG_RELATED_URI", "QUERY_ARG_ALLOW_MOVEMENT", "QUERY_ARG_DEFER_SCAN", "QUERY_ARG_INCLUDE_RECENTLY_UNMOUNTED_VOLUMES", "QUERY_ARG_MATCH_PENDING", "QUERY_ARG_MATCH_TRASHED", "QUERY_ARG_MATCH_FAVORITE", "QUERY_ARG_LATEST_SELECTION_ONLY", "ACCESS_MEDIA_OWNER_PACKAGE_NAME_PERMISSION", "MATCH_DEFAULT", "MATCH_INCLUDE", "MATCH_EXCLUDE", "MATCH_ONLY", "PATTERN_VOLUME_NAME", "MEDIA_SCANNER_VOLUME", "MEDIA_IGNORE_FILENAME" ]
}