{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/hardware/display/DisplayManager.java",
  "packageName" : "android.hardware.display",
  "className" : "DisplayManager",
  "comment" : "\n * Manages the properties of attached displays.\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mGlobal",
    "type" : "DisplayManagerGlobal",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDisplays",
    "type" : "SparseArray<Display>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTempDisplays",
    "type" : "ArrayList<Display>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_WIFI_DISPLAY_STATUS_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast receiver that indicates when the Wifi display status changes.\n     * <p>\n     * The status is provided as a {@link WifiDisplayStatus} object in the\n     * {@link #EXTRA_WIFI_DISPLAY_STATUS} extra.\n     * </p><p>\n     * This broadcast is only sent to registered receivers and can only be sent by the system.\n     * </p>\n     * @hide\n     ",
    "links" : [ "#EXTRA_WIFI_DISPLAY_STATUS", "android.hardware.display.WifiDisplayStatus" ]
  }, {
    "name" : "EXTRA_WIFI_DISPLAY_STATUS",
    "type" : "String",
    "comment" : "\n     * Contains a {@link WifiDisplayStatus} object.\n     * @hide\n     ",
    "links" : [ "android.hardware.display.WifiDisplayStatus" ]
  }, {
    "name" : "DISPLAY_CATEGORY_PRESENTATION",
    "type" : "String",
    "comment" : "\n     * Display category: Presentation displays.\n     * <p>\n     * This category can be used to identify secondary displays that are suitable for\n     * use as presentation displays such as external or wireless displays.  Applications\n     * may automatically project their content to presentation displays to provide\n     * richer second screen experiences.\n     * </p>\n     *\n     * @see android.app.Presentation\n     * @see Display#FLAG_PRESENTATION\n     * @see #getDisplays(String)\n     ",
    "links" : [ ]
  }, {
    "name" : "VIRTUAL_DISPLAY_FLAG_PUBLIC",
    "type" : "int",
    "comment" : "\n     * Virtual display flag: Create a public display.\n     *\n     * <h3>Public virtual displays</h3>\n     * <p>\n     * When this flag is set, the virtual display is public.\n     * </p><p>\n     * A public virtual display behaves just like most any other display that is connected\n     * to the system such as an external or wireless display.  Applications can open\n     * windows on the display and the system may mirror the contents of other displays\n     * onto it.\n     * </p><p>\n     * Creating a public virtual display that isn't restricted to own-content only implicitly\n     * creates an auto-mirroring display. See {@link #VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR} for\n     * restrictions on who is allowed to create an auto-mirroring display.\n     * </p>\n     *\n     * <h3>Private virtual displays</h3>\n     * <p>\n     * When this flag is not set, the virtual display is private as defined by the\n     * {@link Display#FLAG_PRIVATE} display flag.\n     * </p>\n     *\n     * <p>\n     * A private virtual display belongs to the application that created it.  Only the a owner of a\n     * private virtual display and the apps that are already on that display are allowed to place\n     * windows upon it.  The private virtual display also does not participate in display mirroring:\n     * it will neither receive mirrored content from another display nor allow its own content to be\n     * mirrored elsewhere.  More precisely, the only processes that are allowed to enumerate or\n     * interact with the private display are those that have the same UID as the application that\n     * originally created the private virtual display or as the activities that are already on that\n     * display.\n     * </p>\n     *\n     * @see #createVirtualDisplay\n     * @see #VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY\n     * @see #VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR\n     ",
    "links" : [ "android.view.Display#FLAG_PRIVATE", "#VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR" ]
  }, {
    "name" : "VIRTUAL_DISPLAY_FLAG_PRESENTATION",
    "type" : "int",
    "comment" : "\n     * Virtual display flag: Create a presentation display.\n     *\n     * <h3>Presentation virtual displays</h3>\n     * <p>\n     * When this flag is set, the virtual display is registered as a presentation\n     * display in the {@link #DISPLAY_CATEGORY_PRESENTATION presentation display category}.\n     * Applications may automatically project their content to presentation displays\n     * to provide richer second screen experiences.\n     * </p>\n     *\n     * <h3>Non-presentation virtual displays</h3>\n     * <p>\n     * When this flag is not set, the virtual display is not registered as a presentation\n     * display.  Applications can still project their content on the display but they\n     * will typically not do so automatically.  This option is appropriate for\n     * more special-purpose displays.\n     * </p>\n     *\n     * @see android.app.Presentation\n     * @see #createVirtualDisplay\n     * @see #DISPLAY_CATEGORY_PRESENTATION\n     * @see Display#FLAG_PRESENTATION\n     ",
    "links" : [ "#DISPLAY_CATEGORY_PRESENTATION" ]
  }, {
    "name" : "VIRTUAL_DISPLAY_FLAG_SECURE",
    "type" : "int",
    "comment" : "\n     * Virtual display flag: Create a secure display.\n     *\n     * <h3>Secure virtual displays</h3>\n     * <p>\n     * When this flag is set, the virtual display is considered secure as defined\n     * by the {@link Display#FLAG_SECURE} display flag.  The caller promises to take\n     * reasonable measures, such as over-the-air encryption, to prevent the contents\n     * of the display from being intercepted or recorded on a persistent medium.\n     * </p><p>\n     * Creating a secure virtual display requires the CAPTURE_SECURE_VIDEO_OUTPUT permission.\n     * This permission is reserved for use by system components and is not available to\n     * third-party applications.\n     * </p>\n     *\n     * <h3>Non-secure virtual displays</h3>\n     * <p>\n     * When this flag is not set, the virtual display is considered unsecure.\n     * The content of secure windows will be blanked if shown on this display.\n     * </p>\n     *\n     * @see Display#FLAG_SECURE\n     * @see #createVirtualDisplay\n     ",
    "links" : [ "android.view.Display#FLAG_SECURE" ]
  }, {
    "name" : "VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY",
    "type" : "int",
    "comment" : "\n     * Virtual display flag: Only show this display's own content; do not mirror\n     * the content of another display.\n     *\n     * <p>\n     * This flag is used in conjunction with {@link #VIRTUAL_DISPLAY_FLAG_PUBLIC}.\n     * Ordinarily public virtual displays will automatically mirror the content of the\n     * default display if they have no windows of their own.  When this flag is\n     * specified, the virtual display will only ever show its own content and\n     * will be blanked instead if it has no windows.\n     * </p>\n     *\n     * <p>\n     * This flag is mutually exclusive with {@link #VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR}.  If both\n     * flags are specified then the own-content only behavior will be applied.\n     * </p>\n     *\n     * <p>\n     * This behavior of this flag is implied whenever neither {@link #VIRTUAL_DISPLAY_FLAG_PUBLIC}\n     * nor {@link #VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR} have been set.  This flag is only required to\n     * override the default behavior when creating a public display.\n     * </p>\n     *\n     * @see #createVirtualDisplay\n     ",
    "links" : [ "#VIRTUAL_DISPLAY_FLAG_PUBLIC", "#VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR" ]
  }, {
    "name" : "VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR",
    "type" : "int",
    "comment" : "\n     * Virtual display flag: Allows content to be mirrored on private displays when no content is\n     * being shown.\n     *\n     * <p>\n     * This flag is mutually exclusive with {@link #VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY}.\n     * If both flags are specified then the own-content only behavior will be applied.\n     * </p>\n     *\n     * <p>\n     * The behavior of this flag is implied whenever {@link #VIRTUAL_DISPLAY_FLAG_PUBLIC} is set\n     * and {@link #VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY} has not been set.   This flag is only\n     * required to override the default behavior when creating a private display.\n     * </p>\n     *\n     * <p>\n     * Creating an auto-mirroing virtual display requires the CAPTURE_VIDEO_OUTPUT\n     * or CAPTURE_SECURE_VIDEO_OUTPUT permission.\n     * These permissions are reserved for use by system components and are not available to\n     * third-party applications.\n     *\n     * Alternatively, an appropriate {@link MediaProjection} may be used to create an\n     * auto-mirroring virtual display.\n     * </p>\n     *\n     * @see #createVirtualDisplay\n     ",
    "links" : [ "#VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY", "android.media.projection.MediaProjection", "#VIRTUAL_DISPLAY_FLAG_PUBLIC" ]
  }, {
    "name" : "VIRTUAL_DISPLAY_FLAG_CAN_SHOW_WITH_INSECURE_KEYGUARD",
    "type" : "int",
    "comment" : " TODO: Update name and documentation and un-hide the flag. Don't change the value before that.",
    "links" : [ ]
  }, {
    "name" : "VIRTUAL_DISPLAY_FLAG_SUPPORTS_TOUCH",
    "type" : "int",
    "comment" : "\n     * Virtual display flag: Specifies that the virtual display can be associated with a\n     * touchpad device that matches its uniqueId.\n     *\n     * @see #createVirtualDisplay\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "VIRTUAL_DISPLAY_FLAG_ROTATES_WITH_CONTENT",
    "type" : "int",
    "comment" : "\n     * Virtual display flag: Indicates that the orientation of this display device is coupled to\n     * the rotation of its associated logical display.\n     *\n     * @see #createVirtualDisplay\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "VIRTUAL_DISPLAY_FLAG_DESTROY_CONTENT_ON_REMOVAL",
    "type" : "int",
    "comment" : " TODO (b/114338689): Remove the flag and use WindowManager#REMOVE_CONTENT_MODE_DESTROY",
    "links" : [ ]
  }, {
    "name" : "VIRTUAL_DISPLAY_FLAG_SHOULD_SHOW_SYSTEM_DECORATIONS",
    "type" : "int",
    "comment" : " TODO (b/114338689): Remove the flag and use IWindowManager#setShouldShowSystemDecors",
    "links" : [ ]
  }, {
    "name" : "VIRTUAL_DISPLAY_FLAG_TRUSTED",
    "type" : "int",
    "comment" : "\n     * Virtual display flags: Indicates that the display is trusted to show system decorations and\n     * receive inputs without users' touch.\n     *\n     * @see #createVirtualDisplay\n     * @see #VIRTUAL_DISPLAY_FLAG_SHOULD_SHOW_SYSTEM_DECORATIONS\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public Display getDisplay(int displayId)",
    "returnType" : "Display",
    "comment" : "\n     * Gets information about a logical display.\n     *\n     * The display metrics may be adjusted to provide compatibility\n     * for legacy applications.\n     *\n     * @param displayId The logical display id.\n     * @return The display object, or null if there is no valid display with the given id.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Display[] getDisplays()",
    "returnType" : "Display[]",
    "comment" : "\n     * Gets all currently valid logical displays.\n     *\n     * @return An array containing all displays.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Display[] getDisplays(String category)",
    "returnType" : "Display[]",
    "comment" : "\n     * Gets all currently valid logical displays of the specified category.\n     * <p>\n     * When there are multiple displays in a category the returned displays are sorted\n     * of preference.  For example, if the requested category is\n     * {@link #DISPLAY_CATEGORY_PRESENTATION} and there are multiple presentation displays\n     * then the displays are sorted so that the first display in the returned array\n     * is the most preferred presentation display.  The application may simply\n     * use the first display or allow the user to choose.\n     * </p>\n     *\n     * @param category The requested display category or null to return all displays.\n     * @return An array containing all displays sorted by order of preference.\n     *\n     * @see #DISPLAY_CATEGORY_PRESENTATION\n     ",
    "links" : [ "#DISPLAY_CATEGORY_PRESENTATION" ]
  }, {
    "name" : "private void addAllDisplaysLocked(ArrayList<Display> displays, int[] displayIds)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void addPresentationDisplaysLocked(ArrayList<Display> displays, int[] displayIds, int matchType)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private Display getOrCreateDisplayLocked(int displayId, boolean assumeValid)",
    "returnType" : "Display",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void registerDisplayListener(DisplayListener listener, Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Registers an display listener to receive notifications about when\n     * displays are added, removed or changed.\n     *\n     * @param listener The listener to register.\n     * @param handler The handler on which the listener should be invoked, or null\n     * if the listener should be invoked on the calling thread's looper.\n     *\n     * @see #unregisterDisplayListener\n     ",
    "links" : [ ]
  }, {
    "name" : "public void unregisterDisplayListener(DisplayListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters a display listener.\n     *\n     * @param listener The listener to unregister.\n     *\n     * @see #registerDisplayListener\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startWifiDisplayScan()",
    "returnType" : "void",
    "comment" : "\n     * Starts scanning for available Wifi displays.\n     * The results are sent as a {@link #ACTION_WIFI_DISPLAY_STATUS_CHANGED} broadcast.\n     * <p>\n     * Calls to this method nest and must be matched by an equal number of calls to\n     * {@link #stopWifiDisplayScan()}.\n     * </p><p>\n     * Requires {@link android.Manifest.permission#CONFIGURE_WIFI_DISPLAY}.\n     * </p>\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_WIFI_DISPLAY_STATUS_CHANGED", "#stopWifiDisplayScan()", "android.Manifest.permission#CONFIGURE_WIFI_DISPLAY" ]
  }, {
    "name" : "public void stopWifiDisplayScan()",
    "returnType" : "void",
    "comment" : "\n     * Stops scanning for available Wifi displays.\n     * <p>\n     * Requires {@link android.Manifest.permission#CONFIGURE_WIFI_DISPLAY}.\n     * </p>\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#CONFIGURE_WIFI_DISPLAY" ]
  }, {
    "name" : "public void connectWifiDisplay(String deviceAddress)",
    "returnType" : "void",
    "comment" : "\n     * Connects to a Wifi display.\n     * The results are sent as a {@link #ACTION_WIFI_DISPLAY_STATUS_CHANGED} broadcast.\n     * <p>\n     * Automatically remembers the display after a successful connection, if not\n     * already remembered.\n     * </p><p>\n     * Requires {@link android.Manifest.permission#CONFIGURE_WIFI_DISPLAY}.\n     * </p>\n     *\n     * @param deviceAddress The MAC address of the device to which we should connect.\n     * @hide\n     ",
    "links" : [ "#ACTION_WIFI_DISPLAY_STATUS_CHANGED", "android.Manifest.permission#CONFIGURE_WIFI_DISPLAY" ]
  }, {
    "name" : "public void pauseWifiDisplay()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void resumeWifiDisplay()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void disconnectWifiDisplay()",
    "returnType" : "void",
    "comment" : "\n     * Disconnects from the current Wifi display.\n     * The results are sent as a {@link #ACTION_WIFI_DISPLAY_STATUS_CHANGED} broadcast.\n     * @hide\n     ",
    "links" : [ "#ACTION_WIFI_DISPLAY_STATUS_CHANGED" ]
  }, {
    "name" : "public void renameWifiDisplay(String deviceAddress, String alias)",
    "returnType" : "void",
    "comment" : "\n     * Renames a Wifi display.\n     * <p>\n     * The display must already be remembered for this call to succeed.  In other words,\n     * we must already have successfully connected to the display at least once and then\n     * not forgotten it.\n     * </p><p>\n     * Requires {@link android.Manifest.permission#CONFIGURE_WIFI_DISPLAY}.\n     * </p>\n     *\n     * @param deviceAddress The MAC address of the device to rename.\n     * @param alias The alias name by which to remember the device, or null\n     * or empty if no alias should be used.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#CONFIGURE_WIFI_DISPLAY" ]
  }, {
    "name" : "public void forgetWifiDisplay(String deviceAddress)",
    "returnType" : "void",
    "comment" : "\n     * Forgets a previously remembered Wifi display.\n     * <p>\n     * Automatically disconnects from the display if currently connected to it.\n     * </p><p>\n     * Requires {@link android.Manifest.permission#CONFIGURE_WIFI_DISPLAY}.\n     * </p>\n     *\n     * @param deviceAddress The MAC address of the device to forget.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#CONFIGURE_WIFI_DISPLAY" ]
  }, {
    "name" : "public WifiDisplayStatus getWifiDisplayStatus()",
    "returnType" : "WifiDisplayStatus",
    "comment" : "\n     * Gets the current Wifi display status.\n     * Watch for changes in the status by registering a broadcast receiver for\n     * {@link #ACTION_WIFI_DISPLAY_STATUS_CHANGED}.\n     *\n     * @return The current Wifi display status.\n     * @hide\n     ",
    "links" : [ "#ACTION_WIFI_DISPLAY_STATUS_CHANGED" ]
  }, {
    "name" : "public void setSaturationLevel(float level)",
    "returnType" : "void",
    "comment" : "\n     * Set the level of color saturation to apply to the display.\n     * @param level The amount of saturation to apply, between 0 and 1 inclusive.\n     * 0 produces a grayscale image, 1 is normal.\n     *\n     * @hide\n     * @deprecated use {@link ColorDisplayManager#setSaturationLevel(int)} instead. The level passed\n     * as a parameter here will be rounded to the nearest hundredth.\n     ",
    "links" : [ "android.hardware.display.ColorDisplayManager#setSaturationLevel(int)" ]
  }, {
    "name" : "public VirtualDisplay createVirtualDisplay(@NonNull String name, int width, int height, int densityDpi, @Nullable Surface surface, int flags)",
    "returnType" : "VirtualDisplay",
    "comment" : "\n     * Creates a virtual display.\n     *\n     * @see #createVirtualDisplay(String, int, int, int, Surface, int,\n     * VirtualDisplay.Callback, Handler)\n     ",
    "links" : [ ]
  }, {
    "name" : "public VirtualDisplay createVirtualDisplay(@NonNull String name, int width, int height, int densityDpi, @Nullable Surface surface, int flags, @Nullable VirtualDisplay.Callback callback, @Nullable Handler handler)",
    "returnType" : "VirtualDisplay",
    "comment" : "\n     * Creates a virtual display.\n     * <p>\n     * The content of a virtual display is rendered to a {@link Surface} provided\n     * by the application.\n     * </p><p>\n     * The virtual display should be {@link VirtualDisplay#release released}\n     * when no longer needed.  Because a virtual display renders to a surface\n     * provided by the application, it will be released automatically when the\n     * process terminates and all remaining windows on it will be forcibly removed.\n     * </p><p>\n     * The behavior of the virtual display depends on the flags that are provided\n     * to this method.  By default, virtual displays are created to be private,\n     * non-presentation and unsecure.  Permissions may be required to use certain flags.\n     * </p><p>\n     * As of {@link android.os.Build.VERSION_CODES#KITKAT_WATCH}, the surface may\n     * be attached or detached dynamically using {@link VirtualDisplay#setSurface}.\n     * Previously, the surface had to be non-null when {@link #createVirtualDisplay}\n     * was called and could not be changed for the lifetime of the display.\n     * </p><p>\n     * Detaching the surface that backs a virtual display has a similar effect to\n     * turning off the screen.\n     * </p>\n     *\n     * @param name The name of the virtual display, must be non-empty.\n     * @param width The width of the virtual display in pixels, must be greater than 0.\n     * @param height The height of the virtual display in pixels, must be greater than 0.\n     * @param densityDpi The density of the virtual display in dpi, must be greater than 0.\n     * @param surface The surface to which the content of the virtual display should\n     * be rendered, or null if there is none initially.\n     * @param flags A combination of virtual display flags:\n     * {@link #VIRTUAL_DISPLAY_FLAG_PUBLIC}, {@link #VIRTUAL_DISPLAY_FLAG_PRESENTATION},\n     * {@link #VIRTUAL_DISPLAY_FLAG_SECURE}, {@link #VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY},\n     * or {@link #VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR}.\n     * @param callback Callback to call when the state of the {@link VirtualDisplay} changes\n     * @param handler The handler on which the listener should be invoked, or null\n     * if the listener should be invoked on the calling thread's looper.\n     * @return The newly created virtual display, or null if the application could\n     * not create the virtual display.\n     *\n     * @throws SecurityException if the caller does not have permission to create\n     * a virtual display with the specified flags.\n     ",
    "links" : [ "#VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY", "android.view.Surface", "#VIRTUAL_DISPLAY_FLAG_SECURE", "android.hardware.display.VirtualDisplay#release", "android.hardware.display.VirtualDisplay#setSurface", "#VIRTUAL_DISPLAY_FLAG_PRESENTATION", "#VIRTUAL_DISPLAY_FLAG_PUBLIC", "android.os.Build.VERSION_CODES#KITKAT_WATCH", "android.hardware.display.VirtualDisplay", "#createVirtualDisplay", "#VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR" ]
  }, {
    "name" : "public VirtualDisplay createVirtualDisplay(@Nullable MediaProjection projection, @NonNull String name, int width, int height, int densityDpi, @Nullable Surface surface, int flags, @Nullable VirtualDisplay.Callback callback, @Nullable Handler handler, @Nullable String uniqueId)",
    "returnType" : "VirtualDisplay",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public VirtualDisplay createVirtualDisplay(@Nullable MediaProjection projection, @NonNull VirtualDisplayConfig virtualDisplayConfig, @Nullable VirtualDisplay.Callback callback, @Nullable Handler handler)",
    "returnType" : "VirtualDisplay",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public Point getStableDisplaySize()",
    "returnType" : "Point",
    "comment" : "\n     * Gets the stable device display size, in pixels.\n     *\n     * This should really only be used for things like server-side filtering of available\n     * applications. Most applications don't need the level of stability guaranteed by this and\n     * should instead query either the size of the display they're currently running on or the\n     * size of the default display.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<BrightnessChangeEvent> getBrightnessEvents()",
    "returnType" : "List<BrightnessChangeEvent>",
    "comment" : "\n     * Fetch {@link BrightnessChangeEvent}s.\n     * @hide until we make it a system api.\n     ",
    "links" : [ "android.hardware.display.BrightnessChangeEvent" ]
  }, {
    "name" : "public List<AmbientBrightnessDayStats> getAmbientBrightnessStats()",
    "returnType" : "List<AmbientBrightnessDayStats>",
    "comment" : "\n     * Fetch {@link AmbientBrightnessDayStats}s.\n     *\n     * @hide until we make it a system api\n     ",
    "links" : [ "android.hardware.display.AmbientBrightnessDayStats" ]
  }, {
    "name" : "public void setBrightnessConfiguration(BrightnessConfiguration c)",
    "returnType" : "void",
    "comment" : "\n     * Sets the global display brightness configuration.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setBrightnessConfigurationForUser(BrightnessConfiguration c, int userId, String packageName)",
    "returnType" : "void",
    "comment" : "\n     * Sets the global display brightness configuration for a specific user.\n     *\n     * Note this requires the INTERACT_ACROSS_USERS permission if setting the configuration for a\n     * user other than the one you're currently running as.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public BrightnessConfiguration getBrightnessConfiguration()",
    "returnType" : "BrightnessConfiguration",
    "comment" : "\n     * Gets the global display brightness configuration or the default curve if one hasn't been set.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public BrightnessConfiguration getBrightnessConfigurationForUser(int userId)",
    "returnType" : "BrightnessConfiguration",
    "comment" : "\n     * Gets the global display brightness configuration or the default curve if one hasn't been set\n     * for a specific user.\n     *\n     * Note this requires the INTERACT_ACROSS_USERS permission if getting the configuration for a\n     * user other than the one you're currently running as.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public BrightnessConfiguration getDefaultBrightnessConfiguration()",
    "returnType" : "BrightnessConfiguration",
    "comment" : "\n     * Gets the default global display brightness configuration or null one hasn't\n     * been configured.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isMinimalPostProcessingRequested(int displayId)",
    "returnType" : "boolean",
    "comment" : "\n     * Gets the last requested minimal post processing setting for the display with displayId.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTemporaryBrightness(float brightness)",
    "returnType" : "void",
    "comment" : "\n     * Temporarily sets the brightness of the display.\n     * <p>\n     * Requires the {@link android.Manifest.permission#CONTROL_DISPLAY_BRIGHTNESS} permission.\n     * </p>\n     *\n     * @param brightness The brightness value from 0.0f to 1.0f.\n     *\n     * @hide Requires signature permission.\n     ",
    "links" : [ "android.Manifest.permission#CONTROL_DISPLAY_BRIGHTNESS" ]
  }, {
    "name" : "public void setTemporaryAutoBrightnessAdjustment(float adjustment)",
    "returnType" : "void",
    "comment" : "\n     * Temporarily sets the auto brightness adjustment factor.\n     * <p>\n     * Requires the {@link android.Manifest.permission#CONTROL_DISPLAY_BRIGHTNESS} permission.\n     * </p>\n     *\n     * @param adjustment The adjustment factor from -1.0 to 1.0.\n     *\n     * @hide Requires signature permission.\n     ",
    "links" : [ "android.Manifest.permission#CONTROL_DISPLAY_BRIGHTNESS" ]
  }, {
    "name" : "public Pair<float[], float[]> getMinimumBrightnessCurve()",
    "returnType" : "Pair<float[], float[]>",
    "comment" : "\n     * Returns the minimum brightness curve, which guarantess that any brightness curve that dips\n     * below it is rejected by the system.\n     * This prevent auto-brightness from setting the screen so dark as to prevent the user from\n     * resetting or disabling it, and maps lux to the absolute minimum nits that are still readable\n     * in that ambient brightness.\n     *\n     * @return The minimum brightness curve (as lux values and their corresponding nits values).\n     *\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "DEBUG", "mContext", "mGlobal", "mLock", "mDisplays", "mTempDisplays", "ACTION_WIFI_DISPLAY_STATUS_CHANGED", "EXTRA_WIFI_DISPLAY_STATUS", "DISPLAY_CATEGORY_PRESENTATION", "VIRTUAL_DISPLAY_FLAG_PUBLIC", "VIRTUAL_DISPLAY_FLAG_PRESENTATION", "VIRTUAL_DISPLAY_FLAG_SECURE", "VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY", "VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR", "VIRTUAL_DISPLAY_FLAG_CAN_SHOW_WITH_INSECURE_KEYGUARD", "VIRTUAL_DISPLAY_FLAG_SUPPORTS_TOUCH", "VIRTUAL_DISPLAY_FLAG_ROTATES_WITH_CONTENT", "VIRTUAL_DISPLAY_FLAG_DESTROY_CONTENT_ON_REMOVAL", "VIRTUAL_DISPLAY_FLAG_SHOULD_SHOW_SYSTEM_DECORATIONS", "VIRTUAL_DISPLAY_FLAG_TRUSTED" ],
  "methodNames" : [ "public Display getDisplay(int displayId)", "public Display[] getDisplays()", "public Display[] getDisplays(String category)", "private void addAllDisplaysLocked(ArrayList<Display> displays, int[] displayIds)", "private void addPresentationDisplaysLocked(ArrayList<Display> displays, int[] displayIds, int matchType)", "private Display getOrCreateDisplayLocked(int displayId, boolean assumeValid)", "public void registerDisplayListener(DisplayListener listener, Handler handler)", "public void unregisterDisplayListener(DisplayListener listener)", "public void startWifiDisplayScan()", "public void stopWifiDisplayScan()", "public void connectWifiDisplay(String deviceAddress)", "public void pauseWifiDisplay()", "public void resumeWifiDisplay()", "public void disconnectWifiDisplay()", "public void renameWifiDisplay(String deviceAddress, String alias)", "public void forgetWifiDisplay(String deviceAddress)", "public WifiDisplayStatus getWifiDisplayStatus()", "public void setSaturationLevel(float level)", "public VirtualDisplay createVirtualDisplay(@NonNull String name, int width, int height, int densityDpi, @Nullable Surface surface, int flags)", "public VirtualDisplay createVirtualDisplay(@NonNull String name, int width, int height, int densityDpi, @Nullable Surface surface, int flags, @Nullable VirtualDisplay.Callback callback, @Nullable Handler handler)", "public VirtualDisplay createVirtualDisplay(@Nullable MediaProjection projection, @NonNull String name, int width, int height, int densityDpi, @Nullable Surface surface, int flags, @Nullable VirtualDisplay.Callback callback, @Nullable Handler handler, @Nullable String uniqueId)", "public VirtualDisplay createVirtualDisplay(@Nullable MediaProjection projection, @NonNull VirtualDisplayConfig virtualDisplayConfig, @Nullable VirtualDisplay.Callback callback, @Nullable Handler handler)", "public Point getStableDisplaySize()", "public List<BrightnessChangeEvent> getBrightnessEvents()", "public List<AmbientBrightnessDayStats> getAmbientBrightnessStats()", "public void setBrightnessConfiguration(BrightnessConfiguration c)", "public void setBrightnessConfigurationForUser(BrightnessConfiguration c, int userId, String packageName)", "public BrightnessConfiguration getBrightnessConfiguration()", "public BrightnessConfiguration getBrightnessConfigurationForUser(int userId)", "public BrightnessConfiguration getDefaultBrightnessConfiguration()", "public boolean isMinimalPostProcessingRequested(int displayId)", "public void setTemporaryBrightness(float brightness)", "public void setTemporaryAutoBrightnessAdjustment(float adjustment)", "public Pair<float[], float[]> getMinimumBrightnessCurve()" ]
}