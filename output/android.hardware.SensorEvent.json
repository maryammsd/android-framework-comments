{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/hardware/SensorEvent.java",
  "packageName" : "android.hardware",
  "className" : "SensorEvent",
  "comment" : "",
  "variables" : [ {
    "name" : "values",
    "type" : "float[]",
    "comment" : "\n     * <p>\n     * The length and contents of the {@link #values values} array depends on\n     * which {@link android.hardware.Sensor sensor} type is being monitored (see\n     * also {@link SensorEvent} for a definition of the coordinate system used).\n     * </p>\n     *\n     * <h4>{@link android.hardware.Sensor#TYPE_ACCELEROMETER\n     * Sensor.TYPE_ACCELEROMETER}:</h4> All values are in SI units (m/s^2)\n     *\n     * <ul>\n     * <li> values[0]: Acceleration minus Gx on the x-axis </li>\n     * <li> values[1]: Acceleration minus Gy on the y-axis </li>\n     * <li> values[2]: Acceleration minus Gz on the z-axis </li>\n     * </ul>\n     *\n     * <p>\n     * A sensor of this type measures the acceleration applied to the device\n     * (<b>Ad</b>). Conceptually, it does so by measuring forces applied to the\n     * sensor itself (<b>Fs</b>) using the relation:\n     * </p>\n     *\n     * <b><center>Ad = - &#8721;Fs / mass</center></b>\n     *\n     * <p>\n     * In particular, the force of gravity is always influencing the measured\n     * acceleration:\n     * </p>\n     *\n     * <b><center>Ad = -g - &#8721;F / mass</center></b>\n     *\n     * <p>\n     * For this reason, when the device is sitting on a table (and obviously not\n     * accelerating), the accelerometer reads a magnitude of <b>g</b> = 9.81\n     * m/s^2\n     * </p>\n     *\n     * <p>\n     * Similarly, when the device is in free-fall and therefore dangerously\n     * accelerating towards to ground at 9.81 m/s^2, its accelerometer reads a\n     * magnitude of 0 m/s^2.\n     * </p>\n     *\n     * <p>\n     * It should be apparent that in order to measure the real acceleration of\n     * the device, the contribution of the force of gravity must be eliminated.\n     * This can be achieved by applying a <i>high-pass</i> filter. Conversely, a\n     * <i>low-pass</i> filter can be used to isolate the force of gravity.\n     * </p>\n     *\n     * <pre class=\"prettyprint\">\n     *\n     *     public void onSensorChanged(SensorEvent event)\n     *     {\n     *          // alpha is calculated as t / (t + dT)\n     *          // with t, the low-pass filter's time-constant\n     *          // and dT, the event delivery rate\n     *\n     *          final float alpha = 0.8;\n     *\n     *          gravity[0] = alpha * gravity[0] + (1 - alpha) * event.values[0];\n     *          gravity[1] = alpha * gravity[1] + (1 - alpha) * event.values[1];\n     *          gravity[2] = alpha * gravity[2] + (1 - alpha) * event.values[2];\n     *\n     *          linear_acceleration[0] = event.values[0] - gravity[0];\n     *          linear_acceleration[1] = event.values[1] - gravity[1];\n     *          linear_acceleration[2] = event.values[2] - gravity[2];\n     *     }\n     * </pre>\n     *\n     * <p>\n     * <u>Examples</u>:\n     * <ul>\n     * <li>When the device lies flat on a table and is pushed on its left side\n     * toward the right, the x acceleration value is positive.</li>\n     *\n     * <li>When the device lies flat on a table, the acceleration value is\n     * +9.81, which correspond to the acceleration of the device (0 m/s^2) minus\n     * the force of gravity (-9.81 m/s^2).</li>\n     *\n     * <li>When the device lies flat on a table and is pushed toward the sky\n     * with an acceleration of A m/s^2, the acceleration value is equal to\n     * A+9.81 which correspond to the acceleration of the device (+A m/s^2)\n     * minus the force of gravity (-9.81 m/s^2).</li>\n     * </ul>\n     *\n     *\n     * <h4>{@link android.hardware.Sensor#TYPE_MAGNETIC_FIELD\n     * Sensor.TYPE_MAGNETIC_FIELD}:</h4>\n     * All values are in micro-Tesla (uT) and measure the ambient magnetic field\n     * in the X, Y and Z axis.\n     *\n     * <h4>{@link android.hardware.Sensor#TYPE_GYROSCOPE Sensor.TYPE_GYROSCOPE}:\n     * </h4> All values are in radians/second and measure the rate of rotation\n     * around the device's local X, Y and Z axis. The coordinate system is the\n     * same as is used for the acceleration sensor. Rotation is positive in the\n     * counter-clockwise direction. That is, an observer looking from some\n     * positive location on the x, y or z axis at a device positioned on the\n     * origin would report positive rotation if the device appeared to be\n     * rotating counter clockwise. Note that this is the standard mathematical\n     * definition of positive rotation and does not agree with the definition of\n     * roll given earlier.\n     * <ul>\n     * <li> values[0]: Angular speed around the x-axis </li>\n     * <li> values[1]: Angular speed around the y-axis </li>\n     * <li> values[2]: Angular speed around the z-axis </li>\n     * </ul>\n     * <p>\n     * Typically the output of the gyroscope is integrated over time to\n     * calculate a rotation describing the change of angles over the time step,\n     * for example:\n     * </p>\n     *\n     * <pre class=\"prettyprint\">\n     *     private static final float NS2S = 1.0f / 1000000000.0f;\n     *     private final float[] deltaRotationVector = new float[4]();\n     *     private float timestamp;\n     *\n     *     public void onSensorChanged(SensorEvent event) {\n     *          // This time step's delta rotation to be multiplied by the current rotation\n     *          // after computing it from the gyro sample data.\n     *          if (timestamp != 0) {\n     *              final float dT = (event.timestamp - timestamp) * NS2S;\n     *              // Axis of the rotation sample, not normalized yet.\n     *              float axisX = event.values[0];\n     *              float axisY = event.values[1];\n     *              float axisZ = event.values[2];\n     *\n     *              // Calculate the angular speed of the sample\n     *              float omegaMagnitude = sqrt(axisX*axisX + axisY*axisY + axisZ*axisZ);\n     *\n     *              // Normalize the rotation vector if it's big enough to get the axis\n     *              if (omegaMagnitude > EPSILON) {\n     *                  axisX /= omegaMagnitude;\n     *                  axisY /= omegaMagnitude;\n     *                  axisZ /= omegaMagnitude;\n     *              }\n     *\n     *              // Integrate around this axis with the angular speed by the time step\n     *              // in order to get a delta rotation from this sample over the time step\n     *              // We will convert this axis-angle representation of the delta rotation\n     *              // into a quaternion before turning it into the rotation matrix.\n     *              float thetaOverTwo = omegaMagnitude * dT / 2.0f;\n     *              float sinThetaOverTwo = sin(thetaOverTwo);\n     *              float cosThetaOverTwo = cos(thetaOverTwo);\n     *              deltaRotationVector[0] = sinThetaOverTwo * axisX;\n     *              deltaRotationVector[1] = sinThetaOverTwo * axisY;\n     *              deltaRotationVector[2] = sinThetaOverTwo * axisZ;\n     *              deltaRotationVector[3] = cosThetaOverTwo;\n     *          }\n     *          timestamp = event.timestamp;\n     *          float[] deltaRotationMatrix = new float[9];\n     *          SensorManager.getRotationMatrixFromVector(deltaRotationMatrix, deltaRotationVector);\n     *          // User code should concatenate the delta rotation we computed with the current\n     *          // rotation in order to get the updated rotation.\n     *          // rotationCurrent = rotationCurrent * deltaRotationMatrix;\n     *     }\n     * </pre>\n     * <p>\n     * In practice, the gyroscope noise and offset will introduce some errors\n     * which need to be compensated for. This is usually done using the\n     * information from other sensors, but is beyond the scope of this document.\n     * </p>\n     * <h4>{@link android.hardware.Sensor#TYPE_LIGHT Sensor.TYPE_LIGHT}:</h4>\n     * <ul>\n     * <li>values[0]: Ambient light level in SI lux units </li>\n     * </ul>\n     *\n     * <h4>{@link android.hardware.Sensor#TYPE_PRESSURE Sensor.TYPE_PRESSURE}:</h4>\n     * <ul>\n     * <li>values[0]: Atmospheric pressure in hPa (millibar) </li>\n     * </ul>\n     *\n     * <h4>{@link android.hardware.Sensor#TYPE_PROXIMITY Sensor.TYPE_PROXIMITY}:\n     * </h4>\n     *\n     * <ul>\n     * <li>values[0]: Proximity sensor distance measured in centimeters </li>\n     * </ul>\n     *\n     * <p>\n     * <b>Note:</b> Some proximity sensors only support a binary <i>near</i> or\n     * <i>far</i> measurement. In this case, the sensor should report its\n     * {@link android.hardware.Sensor#getMaximumRange() maximum range} value in\n     * the <i>far</i> state and a lesser value in the <i>near</i> state.\n     * </p>\n     *\n     *  <h4>{@link android.hardware.Sensor#TYPE_GRAVITY Sensor.TYPE_GRAVITY}:</h4>\n     *  <p>A three dimensional vector indicating the direction and magnitude of gravity.  Units\n     *  are m/s^2. The coordinate system is the same as is used by the acceleration sensor.</p>\n     *  <p><b>Note:</b> When the device is at rest, the output of the gravity sensor should be\n     *  identical to that of the accelerometer.</p>\n     *\n     *  <h4>\n     *  {@link android.hardware.Sensor#TYPE_LINEAR_ACCELERATION Sensor.TYPE_LINEAR_ACCELERATION}:\n     *  </h4> A three dimensional vector indicating acceleration along each device axis, not\n     *  including gravity. All values have units of m/s^2.  The coordinate system is the same as is\n     *  used by the acceleration sensor.\n     *  <p>The output of the accelerometer, gravity and  linear-acceleration sensors must obey the\n     *  following relation:</p>\n     *  <p><ul>acceleration = gravity + linear-acceleration</ul></p>\n     *\n     *  <h4>{@link android.hardware.Sensor#TYPE_ROTATION_VECTOR Sensor.TYPE_ROTATION_VECTOR}:</h4>\n     *  <p>The rotation vector represents the orientation of the device as a combination of an\n     *  <i>angle</i> and an <i>axis</i>, in which the device has rotated through an angle &#952\n     *  around an axis &lt;x, y, z>.</p>\n     *  <p>The three elements of the rotation vector are\n     *  &lt;x*sin(&#952/2), y*sin(&#952/2), z*sin(&#952/2)>, such that the magnitude of the rotation\n     *  vector is equal to sin(&#952/2), and the direction of the rotation vector is equal to the\n     *  direction of the axis of rotation.</p>\n     *  </p>The three elements of the rotation vector are equal to\n     *  the last three components of a <b>unit</b> quaternion\n     *  &lt;cos(&#952/2), x*sin(&#952/2), y*sin(&#952/2), z*sin(&#952/2)>.</p>\n     *  <p>Elements of the rotation vector are unitless.\n     *  The x,y, and z axis are defined in the same way as the acceleration\n     *  sensor.</p>\n     *  The reference coordinate system is defined as a direct orthonormal basis,\n     *  where:\n     * </p>\n     *\n     * <ul>\n     * <li>X is defined as the vector product <b>Y.Z</b> (It is tangential to\n     * the ground at the device's current location and roughly points East).</li>\n     * <li>Y is tangential to the ground at the device's current location and\n     * points towards magnetic north.</li>\n     * <li>Z points towards the sky and is perpendicular to the ground.</li>\n     * </ul>\n     *\n     * <p>\n     * <center><img src=\"../../../images/axis_globe.png\"\n     * alt=\"World coordinate-system diagram.\" border=\"0\" /></center>\n     * </p>\n     *\n     * <ul>\n     * <li> values[0]: x*sin(&#952/2) </li>\n     * <li> values[1]: y*sin(&#952/2) </li>\n     * <li> values[2]: z*sin(&#952/2) </li>\n     * <li> values[3]: cos(&#952/2) </li>\n     * <li> values[4]: estimated heading Accuracy (in radians) (-1 if unavailable)</li>\n     * </ul>\n     * <p> values[3], originally optional, will always be present from SDK Level 18 onwards.\n     * values[4] is a new value that has been added in SDK Level 18.\n     * </p>\n     *\n     * <h4>{@link android.hardware.Sensor#TYPE_ORIENTATION\n     * Sensor.TYPE_ORIENTATION}:</h4> All values are angles in degrees.\n     *\n     * <ul>\n     * <li> values[0]: Azimuth, angle between the magnetic north direction and the\n     * y-axis, around the z-axis (0 to 359). 0=North, 90=East, 180=South,\n     * 270=West\n     * </p>\n     *\n     * <p>\n     * values[1]: Pitch, rotation around x-axis (-180 to 180), with positive\n     * values when the z-axis moves <b>toward</b> the y-axis.\n     * </p>\n     *\n     * <p>\n     * values[2]: Roll, rotation around the y-axis (-90 to 90)\n     * increasing as the device moves clockwise.\n     * </p>\n     * </ul>\n     *\n     * <p>\n     * <b>Note:</b> This definition is different from <b>yaw, pitch and roll</b>\n     * used in aviation where the X axis is along the long side of the plane\n     * (tail to nose).\n     * </p>\n     *\n     * <p>\n     * <b>Note:</b> This sensor type exists for legacy reasons, please use\n     * {@link android.hardware.Sensor#TYPE_ROTATION_VECTOR\n     * rotation vector sensor type} and\n     * {@link android.hardware.SensorManager#getRotationMatrix\n     * getRotationMatrix()} in conjunction with\n     * {@link android.hardware.SensorManager#remapCoordinateSystem\n     * remapCoordinateSystem()} and\n     * {@link android.hardware.SensorManager#getOrientation getOrientation()} to\n     * compute these values instead.\n     * </p>\n     *\n     * <p>\n     * <b>Important note:</b> For historical reasons the roll angle is positive\n     * in the clockwise direction (mathematically speaking, it should be\n     * positive in the counter-clockwise direction).\n     * </p>\n     *\n     * <h4>{@link android.hardware.Sensor#TYPE_RELATIVE_HUMIDITY\n     * Sensor.TYPE_RELATIVE_HUMIDITY}:</h4>\n     * <ul>\n     * <li> values[0]: Relative ambient air humidity in percent </li>\n     * </ul>\n     * <p>\n     * When relative ambient air humidity and ambient temperature are\n     * measured, the dew point and absolute humidity can be calculated.\n     * </p>\n     * <u>Dew Point</u>\n     * <p>\n     * The dew point is the temperature to which a given parcel of air must be\n     * cooled, at constant barometric pressure, for water vapor to condense\n     * into water.\n     * </p>\n     * <center><pre>\n     *                    ln(RH/100%) + m&#183;t/(T<sub>n</sub>+t)\n     * t<sub>d</sub>(t,RH) = T<sub>n</sub> &#183; ------------------------------\n     *                 m - [ln(RH/100%) + m&#183;t/(T<sub>n</sub>+t)]\n     * </pre></center>\n     * <dl>\n     * <dt>t<sub>d</sub></dt> <dd>dew point temperature in &deg;C</dd>\n     * <dt>t</dt>             <dd>actual temperature in &deg;C</dd>\n     * <dt>RH</dt>            <dd>actual relative humidity in %</dd>\n     * <dt>m</dt>             <dd>17.62</dd>\n     * <dt>T<sub>n</sub></dt> <dd>243.12 &deg;C</dd>\n     * </dl>\n     * <p>for example:</p>\n     * <pre class=\"prettyprint\">\n     * h = Math.log(rh / 100.0) + (17.62 * t) / (243.12 + t);\n     * td = 243.12 * h / (17.62 - h);\n     * </pre>\n     * <u>Absolute Humidity</u>\n     * <p>\n     * The absolute humidity is the mass of water vapor in a particular volume\n     * of dry air. The unit is g/m<sup>3</sup>.\n     * </p>\n     * <center><pre>\n     *                    RH/100%&#183;A&#183;exp(m&#183;t/(T<sub>n</sub>+t))\n     * d<sub>v</sub>(t,RH) = 216.7 &#183; -------------------------\n     *                           273.15 + t\n     * </pre></center>\n     * <dl>\n     * <dt>d<sub>v</sub></dt> <dd>absolute humidity in g/m<sup>3</sup></dd>\n     * <dt>t</dt>             <dd>actual temperature in &deg;C</dd>\n     * <dt>RH</dt>            <dd>actual relative humidity in %</dd>\n     * <dt>m</dt>             <dd>17.62</dd>\n     * <dt>T<sub>n</sub></dt> <dd>243.12 &deg;C</dd>\n     * <dt>A</dt>             <dd>6.112 hPa</dd>\n     * </dl>\n     * <p>for example:</p>\n     * <pre class=\"prettyprint\">\n     * dv = 216.7 *\n     * (rh / 100.0 * 6.112 * Math.exp(17.62 * t / (243.12 + t)) / (273.15 + t));\n     * </pre>\n     *\n     * <h4>{@link android.hardware.Sensor#TYPE_AMBIENT_TEMPERATURE Sensor.TYPE_AMBIENT_TEMPERATURE}:\n     * </h4>\n     *\n     * <ul>\n     * <li> values[0]: ambient (room) temperature in degree Celsius.</li>\n     * </ul>\n     *\n     *\n     * <h4>{@link android.hardware.Sensor#TYPE_MAGNETIC_FIELD_UNCALIBRATED\n     * Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED}:</h4>\n     * Similar to {@link android.hardware.Sensor#TYPE_MAGNETIC_FIELD},\n     * but the hard iron calibration is reported separately instead of being included\n     * in the measurement. Factory calibration and temperature compensation will still\n     * be applied to the \"uncalibrated\" measurement. Assumptions that the magnetic field\n     * is due to the Earth's poles is avoided.\n     * <p>\n     * The values array is shown below:\n     * <ul>\n     * <li> values[0] = x_uncalib </li>\n     * <li> values[1] = y_uncalib </li>\n     * <li> values[2] = z_uncalib </li>\n     * <li> values[3] = x_bias </li>\n     * <li> values[4] = y_bias </li>\n     * <li> values[5] = z_bias </li>\n     * </ul>\n     * </p>\n     * <p>\n     * x_uncalib, y_uncalib, z_uncalib are the measured magnetic field in X, Y, Z axes.\n     * Soft iron and temperature calibrations are applied. But the hard iron\n     * calibration is not applied. The values are in micro-Tesla (uT).\n     * </p>\n     * <p>\n     * x_bias, y_bias, z_bias give the iron bias estimated in X, Y, Z axes.\n     * Each field is a component of the estimated hard iron calibration.\n     * The values are in micro-Tesla (uT).\n     * </p>\n     * <p> Hard iron - These distortions arise due to the magnetized iron, steel or permanent\n     * magnets on the device.\n     * Soft iron - These distortions arise due to the interaction with the earth's magnetic\n     * field.\n     * </p>\n     * <h4> {@link android.hardware.Sensor#TYPE_GAME_ROTATION_VECTOR\n     * Sensor.TYPE_GAME_ROTATION_VECTOR}:</h4>\n     * Identical to {@link android.hardware.Sensor#TYPE_ROTATION_VECTOR} except that it\n     * doesn't use the geomagnetic field. Therefore the Y axis doesn't\n     * point north, but instead to some other reference, that reference is\n     * allowed to drift by the same order of magnitude as the gyroscope\n     * drift around the Z axis.\n     * <p>\n     * In the ideal case, a phone rotated and returning to the same real-world\n     * orientation will report the same game rotation vector\n     * (without using the earth's geomagnetic field). However, the orientation\n     * may drift somewhat over time. See {@link android.hardware.Sensor#TYPE_ROTATION_VECTOR}\n     * for a detailed description of the values. This sensor will not have\n     * the estimated heading accuracy value.\n     * </p>\n     *\n     * <h4> {@link android.hardware.Sensor#TYPE_GYROSCOPE_UNCALIBRATED\n     * Sensor.TYPE_GYROSCOPE_UNCALIBRATED}:</h4>\n     * All values are in radians/second and measure the rate of rotation\n     * around the X, Y and Z axis. An estimation of the drift on each axis is\n     * reported as well.\n     * <p>\n     * No gyro-drift compensation is performed. Factory calibration and temperature\n     * compensation is still applied to the rate of rotation (angular speeds).\n     * </p>\n     * <p>\n     * The coordinate system is the same as is used for the\n     * {@link android.hardware.Sensor#TYPE_ACCELEROMETER}\n     * Rotation is positive in the counter-clockwise direction (right-hand rule).\n     * That is, an observer looking from some positive location on the x, y or z axis\n     * at a device positioned on the origin would report positive rotation if the device\n     * appeared to be rotating counter clockwise.\n     * The range would at least be 17.45 rad/s (ie: ~1000 deg/s).\n     * <ul>\n     * <li> values[0] : angular speed (w/o drift compensation) around the X axis in rad/s </li>\n     * <li> values[1] : angular speed (w/o drift compensation) around the Y axis in rad/s </li>\n     * <li> values[2] : angular speed (w/o drift compensation) around the Z axis in rad/s </li>\n     * <li> values[3] : estimated drift around X axis in rad/s </li>\n     * <li> values[4] : estimated drift around Y axis in rad/s </li>\n     * <li> values[5] : estimated drift around Z axis in rad/s </li>\n     * </ul>\n     * </p>\n     * <p><b>Pro Tip:</b> Always use the length of the values array while performing operations\n     * on it. In earlier versions, this used to be always 3 which has changed now. </p>\n     *\n     *   <h4>{@link android.hardware.Sensor#TYPE_POSE_6DOF\n     * Sensor.TYPE_POSE_6DOF}:</h4>\n     *\n     * A TYPE_POSE_6DOF event consists of a rotation expressed as a quaternion and a translation\n     * expressed in SI units. The event also contains a delta rotation and translation that show\n     * how the device?s pose has changed since the previous sequence numbered pose.\n     * The event uses the cannonical Android Sensor axes.\n     *\n     *\n     * <ul>\n     * <li> values[0]: x*sin(&#952/2) </li>\n     * <li> values[1]: y*sin(&#952/2) </li>\n     * <li> values[2]: z*sin(&#952/2) </li>\n     * <li> values[3]: cos(&#952/2)   </li>\n     *\n     *\n     * <li> values[4]: Translation along x axis from an arbitrary origin. </li>\n     * <li> values[5]: Translation along y axis from an arbitrary origin. </li>\n     * <li> values[6]: Translation along z axis from an arbitrary origin. </li>\n     *\n     * <li> values[7]:  Delta quaternion rotation x*sin(&#952/2) </li>\n     * <li> values[8]:  Delta quaternion rotation y*sin(&#952/2) </li>\n     * <li> values[9]:  Delta quaternion rotation z*sin(&#952/2) </li>\n     * <li> values[10]: Delta quaternion rotation cos(&#952/2) </li>\n     *\n     * <li> values[11]: Delta translation along x axis. </li>\n     * <li> values[12]: Delta translation along y axis. </li>\n     * <li> values[13]: Delta translation along z axis. </li>\n     *\n     * <li> values[14]: Sequence number </li>\n     *\n     * </ul>\n     *\n     *   <h4>{@link android.hardware.Sensor#TYPE_STATIONARY_DETECT\n     * Sensor.TYPE_STATIONARY_DETECT}:</h4>\n     *\n     * A TYPE_STATIONARY_DETECT event is produced if the device has been\n     * stationary for at least 5 seconds with a maximal latency of 5\n     * additional seconds. ie: it may take up anywhere from 5 to 10 seconds\n     * afte the device has been at rest to trigger this event.\n     *\n     * The only allowed value is 1.0.\n     *\n     * <ul>\n     *  <li> values[0]: 1.0 </li>\n     * </ul>\n     *\n     *   <h4>{@link android.hardware.Sensor#TYPE_MOTION_DETECT\n     * Sensor.TYPE_MOTION_DETECT}:</h4>\n     *\n     * A TYPE_MOTION_DETECT event is produced if the device has been in\n     * motion  for at least 5 seconds with a maximal latency of 5\n     * additional seconds. ie: it may take up anywhere from 5 to 10 seconds\n     * afte the device has been at rest to trigger this event.\n     *\n     * The only allowed value is 1.0.\n     *\n     * <ul>\n     *  <li> values[0]: 1.0 </li>\n     * </ul>\n     *\n     *   <h4>{@link android.hardware.Sensor#TYPE_HEART_BEAT\n     * Sensor.TYPE_HEART_BEAT}:</h4>\n     *\n     * A sensor of this type returns an event everytime a hear beat peak is\n     * detected.\n     *\n     * Peak here ideally corresponds to the positive peak in the QRS complex of\n     * an ECG signal.\n     *\n     * <ul>\n     *  <li> values[0]: confidence</li>\n     * </ul>\n     *\n     * <p>\n     * A confidence value of 0.0 indicates complete uncertainty - that a peak\n     * is as likely to be at the indicated timestamp as anywhere else.\n     * A confidence value of 1.0 indicates complete certainly - that a peak is\n     * completely unlikely to be anywhere else on the QRS complex.\n     * </p>\n     *\n     * <h4>{@link android.hardware.Sensor#TYPE_LOW_LATENCY_OFFBODY_DETECT\n     * Sensor.TYPE_LOW_LATENCY_OFFBODY_DETECT}:</h4>\n     *\n     * <p>\n     * A sensor of this type returns an event every time the device transitions\n     * from off-body to on-body and from on-body to off-body (e.g. a wearable\n     * device being removed from the wrist would trigger an event indicating an\n     * off-body transition). The event returned will contain a single value to\n     * indicate off-body state:\n     * </p>\n     *\n     * <ul>\n     *  <li> values[0]: off-body state</li>\n     * </ul>\n     *\n     * <p>\n     *     Valid values for off-body state:\n     * <ul>\n     *  <li> 1.0 (device is on-body)</li>\n     *  <li> 0.0 (device is off-body)</li>\n     * </ul>\n     * </p>\n     *\n     * <p>\n     * When a sensor of this type is activated, it must deliver the initial\n     * on-body or off-body event representing the current device state within\n     * 5 seconds of activating the sensor.\n     * </p>\n     *\n     * <p>\n     * This sensor must be able to detect and report an on-body to off-body\n     * transition within 1 second of the device being removed from the body,\n     * and must be able to detect and report an off-body to on-body transition\n     * within 5 seconds of the device being put back onto the body.\n     * </p>\n     *\n     * <h4>{@link android.hardware.Sensor#TYPE_ACCELEROMETER_UNCALIBRATED\n     * Sensor.TYPE_ACCELEROMETER_UNCALIBRATED}:</h4> All values are in SI\n     * units (m/s^2)\n     *\n     * Similar to {@link android.hardware.Sensor#TYPE_ACCELEROMETER},\n     * Factory calibration and temperature compensation will still be applied\n     * to the \"uncalibrated\" measurement.\n     *\n     * <p>\n     * The values array is shown below:\n     * <ul>\n     * <li> values[0] = x_uncalib without bias compensation </li>\n     * <li> values[1] = y_uncalib without bias compensation </li>\n     * <li> values[2] = z_uncalib without bias compensation </li>\n     * <li> values[3] = estimated x_bias </li>\n     * <li> values[4] = estimated y_bias </li>\n     * <li> values[5] = estimated z_bias </li>\n     * </ul>\n     * </p>\n     * <p>\n     * x_uncalib, y_uncalib, z_uncalib are the measured acceleration in X, Y, Z\n     * axes similar to the  {@link android.hardware.Sensor#TYPE_ACCELEROMETER},\n     * without any bias correction (factory bias compensation and any\n     * temperature compensation is allowed).\n     * x_bias, y_bias, z_bias are the estimated biases.\n     * </p>\n     *\n     * <h4>{@link android.hardware.Sensor#TYPE_HINGE_ANGLE Sensor.TYPE_HINGE_ANGLE}:</h4>\n     *\n     * A sensor of this type measures the angle, in degrees, between two integral parts of the\n     * device. Movement of a hinge measured by this sensor type is expected to alter the ways in\n     * which the user may interact with the device, for example by unfolding or revealing a display.\n     *\n     * <ul>\n     *  <li> values[0]: Measured hinge angle between 0 and 360 degrees inclusive</li>\n     * </ul>\n     *\n     * @see GeomagneticField\n     ",
    "links" : [ "android.hardware.SensorManager#remapCoordinateSystemremapCoordinateSystem()", "android.hardware.Sensor#TYPE_ORIENTATIONSensor.TYPE_ORIENTATION", "android.hardware.Sensor#TYPE_HINGE_ANGLE", "android.hardware.Sensor#TYPE_LIGHT", "android.hardware.Sensor#TYPE_GYROSCOPE_UNCALIBRATEDSensor.TYPE_GYROSCOPE_UNCALIBRATED", "android.hardware.Sensor#getMaximumRange()", "android.hardware.Sensor#TYPE_AMBIENT_TEMPERATURE", "android.hardware.Sensor#TYPE_LOW_LATENCY_OFFBODY_DETECTSensor.TYPE_LOW_LATENCY_OFFBODY_DETECT", "android.hardware.Sensor#TYPE_ACCELEROMETER_UNCALIBRATEDSensor.TYPE_ACCELEROMETER_UNCALIBRATED", "android.hardware.SensorEvent", "android.hardware.Sensor#TYPE_GAME_ROTATION_VECTORSensor.TYPE_GAME_ROTATION_VECTOR", "android.hardware.SensorManager#getRotationMatrixgetRotationMatrix()", "#values", "android.hardware.SensorManager#getOrientation", "android.hardware.Sensor", "android.hardware.Sensor#TYPE_STATIONARY_DETECTSensor.TYPE_STATIONARY_DETECT", "android.hardware.Sensor#TYPE_PRESSURE", "android.hardware.Sensor#TYPE_ROTATION_VECTOR", "android.hardware.Sensor#TYPE_GYROSCOPE", "android.hardware.Sensor#TYPE_ACCELEROMETERSensor.TYPE_ACCELEROMETER", "android.hardware.Sensor#TYPE_MAGNETIC_FIELD", "android.hardware.Sensor#TYPE_HEART_BEATSensor.TYPE_HEART_BEAT", "android.hardware.Sensor#TYPE_MAGNETIC_FIELD_UNCALIBRATEDSensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED", "android.hardware.Sensor#TYPE_MAGNETIC_FIELDSensor.TYPE_MAGNETIC_FIELD", "android.hardware.Sensor#TYPE_ROTATION_VECTORrotation", "android.hardware.Sensor#TYPE_POSE_6DOFSensor.TYPE_POSE_6DOF", "android.hardware.Sensor#TYPE_GRAVITY", "android.hardware.Sensor#TYPE_RELATIVE_HUMIDITYSensor.TYPE_RELATIVE_HUMIDITY", "android.hardware.Sensor#TYPE_ACCELEROMETER", "android.hardware.Sensor#TYPE_MOTION_DETECTSensor.TYPE_MOTION_DETECT", "android.hardware.Sensor#TYPE_PROXIMITY", "android.hardware.Sensor#TYPE_LINEAR_ACCELERATION" ]
  }, {
    "name" : "sensor",
    "type" : "Sensor",
    "comment" : "\n     * The sensor that generated this event. See\n     * {@link android.hardware.SensorManager SensorManager} for details.\n     ",
    "links" : [ "android.hardware.SensorManager" ]
  }, {
    "name" : "accuracy",
    "type" : "int",
    "comment" : "\n     * The accuracy of this event. See {@link android.hardware.SensorManager\n     * SensorManager} for details.\n     ",
    "links" : [ "android.hardware.SensorManagerSensorManager" ]
  }, {
    "name" : "timestamp",
    "type" : "long",
    "comment" : "\n     * The time in nanoseconds at which the event happened. For a given sensor,\n     * each new sensor event should be monotonically increasing using the same\n     * time base as {@link android.os.SystemClock#elapsedRealtimeNanos()}.\n     ",
    "links" : [ "android.os.SystemClock#elapsedRealtimeNanos()" ]
  } ],
  "methods" : [ ],
  "variableNames" : [ "values", "sensor", "accuracy", "timestamp" ],
  "methodNames" : [ ]
}