{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/companion/CompanionDeviceManager.java",
  "packageName" : "android.companion",
  "className" : "CompanionDeviceManager",
  "comment" : "\n * System level service for managing companion devices\n *\n * See <a href=\"{@docRoot}guide/topics/connectivity/companion-device-pairing\">this guide</a>\n * for a usage example.\n *\n * <p>To obtain an instance call {@link Context#getSystemService}({@link\n * Context#COMPANION_DEVICE_SERVICE}) Then, call {@link #associate(AssociationRequest,\n * Callback, Handler)} to initiate the flow of associating current package with a\n * device selected by user.</p>\n *\n * @see CompanionDeviceManager#associate\n * @see AssociationRequest\n ",
  "variables" : [ {
    "name" : "DEBUG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LOG_TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "EXTRA_DEVICE",
    "type" : "String",
    "comment" : "\n     * A device, returned in the activity result of the {@link IntentSender} received in\n     * {@link Callback#onDeviceFound}\n     *\n     * Type is:\n     * <ul>\n     *     <li>for classic Bluetooth - {@link android.bluetooth.BluetoothDevice}</li>\n     *     <li>for Bluetooth LE - {@link android.bluetooth.le.ScanResult}</li>\n     *     <li>for WiFi - {@link android.net.wifi.ScanResult}</li>\n     * </ul>\n     ",
    "links" : [ "IntentSender", "Callback#onDeviceFound", "android.bluetooth.BluetoothDevice", "android.bluetooth.le.ScanResult", "android.net.wifi.ScanResult" ]
  }, {
    "name" : "COMPANION_DEVICE_DISCOVERY_PACKAGE_NAME",
    "type" : "String",
    "comment" : "\n     * The package name of the companion device discovery component.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "mService",
    "type" : "ICompanionDeviceManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public void associate(@NonNull AssociationRequest request, @NonNull Callback callback, @Nullable Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Associate this app with a companion device, selected by user\n     *\n     * <p>Once at least one appropriate device is found, {@code callback} will be called with a\n     * {@link PendingIntent} that can be used to show the list of available devices for the user\n     * to select.\n     * It should be started for result (i.e. using\n     * {@link android.app.Activity#startIntentSenderForResult}), as the resulting\n     * {@link android.content.Intent} will contain extra {@link #EXTRA_DEVICE}, with the selected\n     * device. (e.g. {@link android.bluetooth.BluetoothDevice})</p>\n     *\n     * <p>If your app needs to be excluded from battery optimizations (run in the background)\n     * or to have unrestricted data access (use data in the background) you can declare that\n     * you use the {@link android.Manifest.permission#REQUEST_COMPANION_RUN_IN_BACKGROUND} and {@link\n     * android.Manifest.permission#REQUEST_COMPANION_USE_DATA_IN_BACKGROUND} respectively. Note that these\n     * special capabilities have a negative effect on the device's battery and user's data\n     * usage, therefore you should requested them when absolutely necessary.</p>\n     *\n     * <p>You can call {@link #getAssociations} to get the list of currently associated\n     * devices, and {@link #disassociate} to remove an association. Consider doing so when the\n     * association is no longer relevant to avoid unnecessary battery and/or data drain resulting\n     * from special privileges that the association provides</p>\n     *\n     * <p>Calling this API requires a uses-feature\n     * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>\n     *\n     * @param request specific details about this request\n     * @param callback will be called once there's at least one device found for user to choose from\n     * @param handler A handler to control which thread the callback will be delivered on, or null,\n     *                to deliver it on main thread\n     *\n     * @see AssociationRequest\n     ",
    "links" : [ "PendingIntent", "android.app.Activity#startIntentSenderForResult", "android.content.Intent", "#EXTRA_DEVICE", "android.bluetooth.BluetoothDevice", "android.Manifest.permission#REQUEST_COMPANION_RUN_IN_BACKGROUND", "#getAssociations", "#disassociate", "PackageManager#FEATURE_COMPANION_DEVICE_SETUP" ]
  }, {
    "name" : "public List<String> getAssociations()",
    "returnType" : "List<String>",
    "comment" : "\n     * <p>Calling this API requires a uses-feature\n     * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>\n     *\n     * @return a list of MAC addresses of devices that have been previously associated with the\n     * current app. You can use these with {@link #disassociate}\n     ",
    "links" : [ "PackageManager#FEATURE_COMPANION_DEVICE_SETUP", "#disassociate" ]
  }, {
    "name" : "public void disassociate(@NonNull String deviceMacAddress)",
    "returnType" : "void",
    "comment" : "\n     * Remove the association between this app and the device with the given mac address.\n     *\n     * <p>Any privileges provided via being associated with a given device will be revoked</p>\n     *\n     * <p>Consider doing so when the\n     * association is no longer relevant to avoid unnecessary battery and/or data drain resulting\n     * from special privileges that the association provides</p>\n     *\n     * <p>Calling this API requires a uses-feature\n     * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>\n     *\n     * @param deviceMacAddress the MAC address of device to disassociate from this app\n     ",
    "links" : [ "PackageManager#FEATURE_COMPANION_DEVICE_SETUP" ]
  }, {
    "name" : "public void requestNotificationAccess(ComponentName component)",
    "returnType" : "void",
    "comment" : "\n     * Request notification access for the given component.\n     *\n     * The given component must follow the protocol specified in {@link NotificationListenerService}\n     *\n     * Only components from the same {@link ComponentName#getPackageName package} as the calling app\n     * are allowed.\n     *\n     * Your app must have an association with a device before calling this API\n     *\n     * <p>Calling this API requires a uses-feature\n     * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>\n     ",
    "links" : [ "NotificationListenerService", "ComponentName#getPackageName", "PackageManager#FEATURE_COMPANION_DEVICE_SETUP" ]
  }, {
    "name" : "public boolean hasNotificationAccess(ComponentName component)",
    "returnType" : "boolean",
    "comment" : "\n     * Check whether the given component can access the notifications via a\n     * {@link NotificationListenerService}\n     *\n     * Your app must have an association with a device before calling this API\n     *\n     * <p>Calling this API requires a uses-feature\n     * {@link PackageManager#FEATURE_COMPANION_DEVICE_SETUP} declaration in the manifest</p>\n     *\n     * @param component the name of the component\n     * @return whether the given component has the notification listener permission\n     ",
    "links" : [ "NotificationListenerService", "PackageManager#FEATURE_COMPANION_DEVICE_SETUP" ]
  }, {
    "name" : "public boolean isDeviceAssociatedForWifiConnection(@NonNull String packageName, @NonNull MacAddress macAddress, @NonNull UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if a given package was {@link #associate associated} with a device with given\n     * Wi-Fi MAC address for a given user.\n     *\n     * <p>This is a system API protected by the\n     * {@link andrioid.Manifest.permission#MANAGE_COMPANION_DEVICES} permission, thatâ€™s currently\n     * called by the Android Wi-Fi stack to determine whether user consent is required to connect\n     * to a Wi-Fi network. Devices that have been pre-registered as companion devices will not\n     * require user consent to connect.</p>\n     *\n     * <p>Note if the caller has the\n     * {@link android.Manifest.permission#COMPANION_APPROVE_WIFI_CONNECTIONS} permission, this\n     * method will return true by default.</p>\n     *\n     * @param packageName the name of the package that has the association with the companion device\n     * @param macAddress the Wi-Fi MAC address or BSSID of the companion device to check for\n     * @param user the user handle that currently hosts the package being queried for a companion\n     *             device association\n     * @return whether a corresponding association record exists\n     *\n     * @hide\n     ",
    "links" : [ "#associate", "andrioid.Manifest.permission#MANAGE_COMPANION_DEVICES", "android.Manifest.permission#COMPANION_APPROVE_WIFI_CONNECTIONS" ]
  }, {
    "name" : "private boolean checkFeaturePresent()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private Activity getActivity()",
    "returnType" : "Activity",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private String getCallingPackage()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  } ],
  "variableNames" : [ "DEBUG", "LOG_TAG", "EXTRA_DEVICE", "COMPANION_DEVICE_DISCOVERY_PACKAGE_NAME", "mService", "mContext" ],
  "methodNames" : [ "public void associate(@NonNull AssociationRequest request, @NonNull Callback callback, @Nullable Handler handler)", "public List<String> getAssociations()", "public void disassociate(@NonNull String deviceMacAddress)", "public void requestNotificationAccess(ComponentName component)", "public boolean hasNotificationAccess(ComponentName component)", "public boolean isDeviceAssociatedForWifiConnection(@NonNull String packageName, @NonNull MacAddress macAddress, @NonNull UserHandle user)", "private boolean checkFeaturePresent()", "private Activity getActivity()", "private String getCallingPackage()" ]
}