{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/lang/AutoCloseable.java",
  "packageName" : "java.lang",
  "className" : "AutoCloseable",
  "comment" : "\n * An object that may hold resources (such as file or socket handles)\n * until it is closed. The {@link #close()} method of an {@code AutoCloseable}\n * object is called automatically when exiting a {@code\n * try}-with-resources block for which the object has been declared in\n * the resource specification header. This construction ensures prompt\n * release, avoiding resource exhaustion exceptions and errors that\n * may otherwise occur.\n *\n * @apiNote\n * <p>It is possible, and in fact common, for a base class to\n * implement AutoCloseable even though not all of its subclasses or\n * instances will hold releasable resources.  For code that must operate\n * in complete generality, or when it is known that the {@code AutoCloseable}\n * instance requires resource release, it is recommended to use {@code\n * try}-with-resources constructions. However, when using facilities such as\n * {@link java.util.stream.Stream} that support both I/O-based and\n * non-I/O-based forms, {@code try}-with-resources blocks are in\n * general unnecessary when using non-I/O-based forms.\n *\n * @author Josh Bloch\n * @since 1.7\n ",
  "links" : [ "java.util.stream.Stream", "#close()" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " void close() throws Exception",
    "returnType" : "void",
    "comment" : "\n     * Closes this resource, relinquishing any underlying resources.\n     * This method is invoked automatically on objects managed by the\n     * {@code try}-with-resources statement.\n     *\n     * @apiNote\n     * While this interface method is declared to throw {@code\n     * Exception}, implementers are <em>strongly</em> encouraged to\n     * declare concrete implementations of the {@code close} method to\n     * throw more specific exceptions, or to throw no exception at all\n     * if the close operation cannot fail.\n     *\n     * <p> Cases where the close operation may fail require careful\n     * attention by implementers. It is strongly advised to relinquish\n     * the underlying resources and to internally <em>mark</em> the\n     * resource as closed, prior to throwing the exception. The {@code\n     * close} method is unlikely to be invoked more than once and so\n     * this ensures that the resources are released in a timely manner.\n     * Furthermore it reduces problems that could arise when the resource\n     * wraps, or is wrapped, by another resource.\n     *\n     * <p><em>Implementers of this interface are also strongly advised\n     * to not have the {@code close} method throw {@link\n     * InterruptedException}.</em>\n     *\n     * This exception interacts with a thread's interrupted status,\n     * and runtime misbehavior is likely to occur if an {@code\n     * InterruptedException} is {@linkplain Throwable#addSuppressed\n     * suppressed}.\n     *\n     * More generally, if it would cause problems for an\n     * exception to be suppressed, the {@code AutoCloseable.close}\n     * method should not throw it.\n     *\n     * <p>Note that unlike the {@link java.io.Closeable#close close}\n     * method of {@link java.io.Closeable}, this {@code close} method\n     * is <em>not</em> required to be idempotent.  In other words,\n     * calling this {@code close} method more than once may have some\n     * visible side effect, unlike {@code Closeable.close} which is\n     * required to have no effect if called more than once.\n     *\n     * However, implementers of this interface are strongly encouraged\n     * to make their {@code close} methods idempotent.\n     *\n     * @throws Exception if this resource cannot be closed\n     ",
    "links" : [ "java.io.Closeable#close", "java.lang.InterruptedException", "java.io.Closeable" ]
  } ],
  "methodNames" : [ " void close() throws Exception" ],
  "variableNames" : [ ]
}