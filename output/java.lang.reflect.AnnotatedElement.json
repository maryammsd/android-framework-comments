{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/lang/reflect/AnnotatedElement.java",
  "packageName" : "java.lang.reflect",
  "className" : "AnnotatedElement",
  "comment" : "\n * Represents an annotated element of the program currently running in this\n * VM.  This interface allows annotations to be read reflectively.  All\n * annotations returned by methods in this interface are immutable and\n * serializable. The arrays returned by methods of this interface may be modified\n * by callers without affecting the arrays returned to other callers.\n *\n * <p>Android note: methods that return multiple annotations of different types such as\n * {@link #getAnnotations()} and {@link #getDeclaredAnnotations()} can be affected\n * by the explicit character-code ordering of annotations types specified by the DEX format.\n * Annotations of different types on a single element are not guaranteed to be returned in the order\n * they are declared in source.\n *\n * <p>The {@link #getAnnotationsByType(Class)} and {@link\n * #getDeclaredAnnotationsByType(Class)} methods support multiple\n * annotations of the same type on an element. If the argument to\n * either method is a repeatable annotation type (JLS 9.6), then the\n * method will \"look through\" a container annotation (JLS 9.7), if\n * present, and return any annotations inside the container. Container\n * annotations may be generated at compile-time to wrap multiple\n * annotations of the argument type.\n *\n * <p>The terms <em>directly present</em>, <em>indirectly present</em>,\n * <em>present</em>, and <em>associated</em> are used throughout this\n * interface to describe precisely which annotations are returned by\n * methods:\n *\n * <ul>\n *\n * <li> An annotation <i>A</i> is <em>directly present</em> on an\n * element <i>E</i> if <i>E</i> is annotated by <i>A</i> in the original source.\n *\n * <li>An annotation <i>A</i> is <em>indirectly present</em> on an\n * element <i>E</i> if <i>E</i> is annotated by a container annotation\n * of <i>A</i>.\n *\n * <li>An annotation <i>A</i> is present on an element <i>E</i> if either:\n *\n * <ul>\n *\n * <li><i>A</i> is directly present on <i>E</i>; or\n *\n * <li>No annotation of <i>A</i> 's type is directly present on\n * <i>E</i>, and <i>E</i> is a class, and <i>A</i> 's type is\n * inheritable, and <i>A</i> is present on the superclass of <i>E</i>.\n *\n * </ul>\n *\n * <li>An annotation <i>A</i> is <em>associated</em> with an element <i>E</i>\n * if either:\n *\n * <ul>\n *\n * <li><i>A</i> is directly or indirectly present on <i>E</i>; or\n *\n * <li>No annotation of <i>A</i> 's type is directly or indirectly\n * present on <i>E</i>, and <i>E</i> is a class, and <i>A</i>'s type\n * is inheritable, and <i>A</i> is associated with the superclass of\n * <i>E</i>.\n *\n * </ul>\n *\n * </ul>\n *\n * <p>The table below summarizes which kind of annotation presence\n * different methods in this interface examine.\n *\n * <table class=\"plain\">\n * <caption>Overview of kind of presence detected by different AnnotatedElement methods</caption>\n * <thead>\n * <tr><th colspan=2 scope=\"col\">Method</th>\n *     <th colspan=4 scope=\"col\">Kind of Presence</th>\n * <tr><th scope=\"col\">Return Type</th>\n *     <th scope=\"col\">Signature</th>\n *     <th scope=\"col\">Directly Present</th>\n *     <th scope=\"col\">Indirectly Present</th>\n *     <th scope=\"col\">Present</th>\n *     <th scope=\"col\">Associated</th>\n * </thead>\n * <tbody>\n * <tr><td style=\"text-align:right\">{@code T}</td>\n * <th scope=\"row\" style=\"font-weight:normal; text-align:left\">{@link #getAnnotation(Class) getAnnotation(Class&lt;T&gt;)}\n * <td></td><td></td><td style=\"text-align:center\">X</td><td></td>\n * </tr>\n * <tr><td style=\"text-align:right\">{@code Annotation[]}</td>\n * <th scope=\"row\" style=\"font-weight:normal; text-align:left\">{@link #getAnnotations getAnnotations()}\n * <td></td><td></td><td style=\"text-align:center\">X</td><td></td>\n * </tr>\n * <tr><td style=\"text-align:right\">{@code T[]}</td>\n * <th scope=\"row\" style=\"font-weight:normal; text-align:left\">{@link #getAnnotationsByType(Class) getAnnotationsByType(Class&lt;T&gt;)}\n * <td></td><td></td><td></td><td style=\"text-align:center\">X</td>\n * </tr>\n * <tr><td style=\"text-align:right\">{@code T}</td>\n * <th scope=\"row\" style=\"font-weight:normal; text-align:left\">{@link #getDeclaredAnnotation(Class) getDeclaredAnnotation(Class&lt;T&gt;)}\n * <td style=\"text-align:center\">X</td><td></td><td></td><td></td>\n * </tr>\n * <tr><td style=\"text-align:right\">{@code Annotation[]}</td>\n * <th scope=\"row\" style=\"font-weight:normal; text-align:left\">{@link #getDeclaredAnnotations getDeclaredAnnotations()}\n * <td style=\"text-align:center\">X</td><td></td><td></td><td></td>\n * </tr>\n * <tr><td style=\"text-align:right\">{@code T[]}</td>\n * <th scope=\"row\" style=\"font-weight:normal; text-align:left\">{@link #getDeclaredAnnotationsByType(Class) getDeclaredAnnotationsByType(Class&lt;T&gt;)}\n * <td style=\"text-align:center\">X</td><td style=\"text-align:center\">X</td><td></td><td></td>\n * </tr>\n * </tbody>\n * </table>\n *\n * <p>For an invocation of {@code get[Declared]AnnotationsByType( Class <\n * T >)}, the order of annotations which are directly or indirectly\n * present on an element <i>E</i> is computed as if indirectly present\n * annotations on <i>E</i> are directly present on <i>E</i> in place\n * of their container annotation, in the order in which they appear in\n * the value element of the container annotation.\n *\n * <p>There are several compatibility concerns to keep in mind if an\n * annotation type <i>T</i> is originally <em>not</em> repeatable and\n * later modified to be repeatable.\n *\n * The containing annotation type for <i>T</i> is <i>TC</i>.\n *\n * <ul>\n *\n * <li>Modifying <i>T</i> to be repeatable is source and binary\n * compatible with existing uses of <i>T</i> and with existing uses\n * of <i>TC</i>.\n *\n * That is, for source compatibility, source code with annotations of\n * type <i>T</i> or of type <i>TC</i> will still compile. For binary\n * compatibility, class files with annotations of type <i>T</i> or of\n * type <i>TC</i> (or with other kinds of uses of type <i>T</i> or of\n * type <i>TC</i>) will link against the modified version of <i>T</i>\n * if they linked against the earlier version.\n *\n * (An annotation type <i>TC</i> may informally serve as an acting\n * containing annotation type before <i>T</i> is modified to be\n * formally repeatable. Alternatively, when <i>T</i> is made\n * repeatable, <i>TC</i> can be introduced as a new type.)\n *\n * <li>If an annotation type <i>TC</i> is present on an element, and\n * <i>T</i> is modified to be repeatable with <i>TC</i> as its\n * containing annotation type then:\n *\n * <ul>\n *\n * <li>The change to <i>T</i> is behaviorally compatible with respect\n * to the {@code get[Declared]Annotation(Class<T>)} (called with an\n * argument of <i>T</i> or <i>TC</i>) and {@code\n * get[Declared]Annotations()} methods because the results of the\n * methods will not change due to <i>TC</i> becoming the containing\n * annotation type for <i>T</i>.\n *\n * <li>The change to <i>T</i> changes the results of the {@code\n * get[Declared]AnnotationsByType(Class<T>)} methods called with an\n * argument of <i>T</i>, because those methods will now recognize an\n * annotation of type <i>TC</i> as a container annotation for <i>T</i>\n * and will \"look through\" it to expose annotations of type <i>T</i>.\n *\n * </ul>\n *\n * <li>If an annotation of type <i>T</i> is present on an\n * element and <i>T</i> is made repeatable and more annotations of\n * type <i>T</i> are added to the element:\n *\n * <ul>\n *\n * <li> The addition of the annotations of type <i>T</i> is both\n * source compatible and binary compatible.\n *\n * <li>The addition of the annotations of type <i>T</i> changes the results\n * of the {@code get[Declared]Annotation(Class<T>)} methods and {@code\n * get[Declared]Annotations()} methods, because those methods will now\n * only see a container annotation on the element and not see an\n * annotation of type <i>T</i>.\n *\n * <li>The addition of the annotations of type <i>T</i> changes the\n * results of the {@code get[Declared]AnnotationsByType(Class<T>)}\n * methods, because their results will expose the additional\n * annotations of type <i>T</i> whereas previously they exposed only a\n * single annotation of type <i>T</i>.\n *\n * </ul>\n *\n * </ul>\n *\n * <p>If an annotation returned by a method in this interface contains\n * (directly or indirectly) a {@link Class}-valued member referring to\n * a class that is not accessible in this VM, attempting to read the class\n * by calling the relevant Class-returning method on the returned annotation\n * will result in a {@link TypeNotPresentException}.\n *\n * <p>Similarly, attempting to read an enum-valued member will result in\n * a {@link EnumConstantNotPresentException} if the enum constant in the\n * annotation is no longer present in the enum type.\n *\n * <p>If an annotation type <i>T</i> is (meta-)annotated with an\n * {@code @Repeatable} annotation whose value element indicates a type\n * <i>TC</i>, but <i>TC</i> does not declare a {@code value()} method\n * with a return type of <i>T</i>{@code []}, then an exception of type\n * {@link java.lang.annotation.AnnotationFormatError} is thrown.\n *\n * <p>Finally, attempting to read a member whose definition has evolved\n * incompatibly will result in a {@link\n * java.lang.annotation.AnnotationTypeMismatchException} or an\n * {@link java.lang.annotation.IncompleteAnnotationException}.\n *\n * @see java.lang.EnumConstantNotPresentException\n * @see java.lang.TypeNotPresentException\n * @see AnnotationFormatError\n * @see java.lang.annotation.AnnotationTypeMismatchException\n * @see java.lang.annotation.IncompleteAnnotationException\n * @since 1.5\n * @author Josh Bloch\n ",
  "links" : [ "TypeNotPresentException", "java.lang.annotation.IncompleteAnnotationException", "java.lang.annotation.AnnotationTypeMismatchException", "#getDeclaredAnnotationsByType(Class)", "java.lang.annotation.AnnotationFormatError", "#getAnnotations()", "#getAnnotationsByType(Class)", "#getDeclaredAnnotation(Class)", "#getAnnotations", "#getAnnotation(Class)", "#getDeclaredAnnotations", "#getDeclaredAnnotations()", "Class", "EnumConstantNotPresentException" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " boolean isAnnotationPresent(Class<? extends Annotation> annotationClass)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if an annotation for the specified type\n     * is <em>present</em> on this element, else false.  This method\n     * is designed primarily for convenient access to marker annotations.\n     *\n     * <p>The truth value returned by this method is equivalent to:\n     * {@code getAnnotation(annotationClass) != null}\n     *\n     * <p>The body of the default method is specified to be the code\n     * above.\n     *\n     * @param annotationClass the Class object corresponding to the\n     *        annotation type\n     * @return true if an annotation for the specified annotation\n     *     type is present on this element, else false\n     * @throws NullPointerException if the given annotation class is null\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : " T getAnnotation(Class<T> annotationClass)",
    "returnType" : "T",
    "comment" : "\n     * Returns this element's annotation for the specified type if\n     * such an annotation is <em>present</em>, else null.\n     *\n     * @param <T> the type of the annotation to query for and return if present\n     * @param annotationClass the Class object corresponding to the\n     *        annotation type\n     * @return this element's annotation for the specified annotation type if\n     *     present on this element, else null\n     * @throws NullPointerException if the given annotation class is null\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : " Annotation[] getAnnotations()",
    "returnType" : "Annotation[]",
    "comment" : "\n     * Returns annotations that are <em>present</em> on this element.\n     *\n     * If there are no annotations <em>present</em> on this element, the return\n     * value is an array of length 0.\n     *\n     * The caller of this method is free to modify the returned array; it will\n     * have no effect on the arrays returned to other callers.\n     *\n     * @return annotations present on this element\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : " T[] getAnnotationsByType(Class<T> annotationClass)",
    "returnType" : "T[]",
    "comment" : "\n     * Returns annotations that are <em>associated</em> with this element.\n     *\n     * If there are no annotations <em>associated</em> with this element, the return\n     * value is an array of length 0.\n     *\n     * The difference between this method and {@link #getAnnotation(Class)}\n     * is that this method detects if its argument is a <em>repeatable\n     * annotation type</em> (JLS 9.6), and if so, attempts to find one or\n     * more annotations of that type by \"looking through\" a container\n     * annotation.\n     *\n     * The caller of this method is free to modify the returned array; it will\n     * have no effect on the arrays returned to other callers.\n     *\n     * @implSpec The default implementation first calls {@link\n     * #getDeclaredAnnotationsByType(Class)} passing {@code\n     * annotationClass} as the argument. If the returned array has\n     * length greater than zero, the array is returned. If the returned\n     * array is zero-length and this {@code AnnotatedElement} is a\n     * class and the argument type is an inheritable annotation type,\n     * and the superclass of this {@code AnnotatedElement} is non-null,\n     * then the returned result is the result of calling {@link\n     * #getAnnotationsByType(Class)} on the superclass with {@code\n     * annotationClass} as the argument. Otherwise, a zero-length\n     * array is returned.\n     *\n     * @param <T> the type of the annotation to query for and return if present\n     * @param annotationClass the Class object corresponding to the\n     *        annotation type\n     * @return all this element's annotations for the specified annotation type if\n     *     associated with this element, else an array of length zero\n     * @throws NullPointerException if the given annotation class is null\n     * @since 1.8\n     ",
    "links" : [ "#getAnnotation(Class)", "#getDeclaredAnnotationsByType(Class)", "#getAnnotationsByType(Class)" ]
  }, {
    "name" : " T getDeclaredAnnotation(Class<T> annotationClass)",
    "returnType" : "T",
    "comment" : "\n     * Returns this element's annotation for the specified type if\n     * such an annotation is <em>directly present</em>, else null.\n     *\n     * This method ignores inherited annotations. (Returns null if no\n     * annotations are directly present on this element.)\n     *\n     * @implSpec The default implementation first performs a null check\n     * and then loops over the results of {@link\n     * #getDeclaredAnnotations} returning the first annotation whose\n     * annotation type matches the argument type.\n     *\n     * @param <T> the type of the annotation to query for and return if directly present\n     * @param annotationClass the Class object corresponding to the\n     *        annotation type\n     * @return this element's annotation for the specified annotation type if\n     *     directly present on this element, else null\n     * @throws NullPointerException if the given annotation class is null\n     * @since 1.8\n     ",
    "links" : [ "#getDeclaredAnnotations" ]
  }, {
    "name" : " T[] getDeclaredAnnotationsByType(Class<T> annotationClass)",
    "returnType" : "T[]",
    "comment" : "\n     * Returns this element's annotation(s) for the specified type if\n     * such annotations are either <em>directly present</em> or\n     * <em>indirectly present</em>. This method ignores inherited\n     * annotations.\n     *\n     * If there are no specified annotations directly or indirectly\n     * present on this element, the return value is an array of length\n     * 0.\n     *\n     * The difference between this method and {@link\n     * #getDeclaredAnnotation(Class)} is that this method detects if its\n     * argument is a <em>repeatable annotation type</em> (JLS 9.6), and if so,\n     * attempts to find one or more annotations of that type by \"looking\n     * through\" a container annotation if one is present.\n     *\n     * The caller of this method is free to modify the returned array; it will\n     * have no effect on the arrays returned to other callers.\n     *\n     * @implSpec The default implementation may call {@link\n     * #getDeclaredAnnotation(Class)} one or more times to find a\n     * directly present annotation and, if the annotation type is\n     * repeatable, to find a container annotation. If annotations of\n     * the annotation type {@code annotationClass} are found to be both\n     * directly and indirectly present, then {@link\n     * #getDeclaredAnnotations()} will get called to determine the\n     * order of the elements in the returned array.\n     *\n     * <p>Alternatively, the default implementation may call {@link\n     * #getDeclaredAnnotations()} a single time and the returned array\n     * examined for both directly and indirectly present\n     * annotations. The results of calling {@link\n     * #getDeclaredAnnotations()} are assumed to be consistent with the\n     * results of calling {@link #getDeclaredAnnotation(Class)}.\n     *\n     * @param <T> the type of the annotation to query for and return\n     * if directly or indirectly present\n     * @param annotationClass the Class object corresponding to the\n     *        annotation type\n     * @return all this element's annotations for the specified annotation type if\n     *     directly or indirectly present on this element, else an array of length zero\n     * @throws NullPointerException if the given annotation class is null\n     * @since 1.8\n     ",
    "links" : [ "#getDeclaredAnnotation(Class)", "#getDeclaredAnnotations()" ]
  }, {
    "name" : " Annotation[] getDeclaredAnnotations()",
    "returnType" : "Annotation[]",
    "comment" : "\n     * Returns annotations that are <em>directly present</em> on this element.\n     * This method ignores inherited annotations.\n     *\n     * If there are no annotations <em>directly present</em> on this element,\n     * the return value is an array of length 0.\n     *\n     * The caller of this method is free to modify the returned array; it will\n     * have no effect on the arrays returned to other callers.\n     *\n     * @return annotations directly present on this element\n     * @since 1.5\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ " boolean isAnnotationPresent(Class<? extends Annotation> annotationClass)", " T getAnnotation(Class<T> annotationClass)", " Annotation[] getAnnotations()", " T[] getAnnotationsByType(Class<T> annotationClass)", " T getDeclaredAnnotation(Class<T> annotationClass)", " T[] getDeclaredAnnotationsByType(Class<T> annotationClass)", " Annotation[] getDeclaredAnnotations()" ],
  "variableNames" : [ ]
}