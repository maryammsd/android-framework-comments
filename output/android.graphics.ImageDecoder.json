{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/graphics/ImageDecoder.java",
  "packageName" : "android.graphics",
  "className" : "ImageDecoder",
  "comment" : "\n *  <p>A class for converting encoded images (like {@code PNG}, {@code JPEG},\n *  {@code WEBP}, {@code GIF}, or {@code HEIF}) into {@link Drawable} or\n *  {@link Bitmap} objects.\n *\n *  <p>To use it, first create a {@link Source Source} using one of the\n *  {@code createSource} overloads. For example, to decode from a {@link Uri}, call\n *  {@link #createSource(ContentResolver, Uri)} and pass the result to\n *  {@link #decodeDrawable(Source)} or {@link #decodeBitmap(Source)}:\n *\n *  <pre class=\"prettyprint\">\n *  File file = new File(...);\n *  ImageDecoder.Source source = ImageDecoder.createSource(file);\n *  Drawable drawable = ImageDecoder.decodeDrawable(source);\n *  </pre>\n *\n *  <p>To change the default settings, pass the {@link Source Source} and an\n *  {@link OnHeaderDecodedListener OnHeaderDecodedListener} to\n *  {@link #decodeDrawable(Source, OnHeaderDecodedListener)} or\n *  {@link #decodeBitmap(Source, OnHeaderDecodedListener)}. For example, to\n *  create a sampled image with half the width and height of the original image,\n *  call {@link #setTargetSampleSize setTargetSampleSize(2)} inside\n *  {@link OnHeaderDecodedListener#onHeaderDecoded onHeaderDecoded}:\n *\n *  <pre class=\"prettyprint\">\n *  OnHeaderDecodedListener listener = new OnHeaderDecodedListener() {\n *      public void onHeaderDecoded(ImageDecoder decoder, ImageInfo info, Source source) {\n *          decoder.setTargetSampleSize(2);\n *      }\n *  };\n *  Drawable drawable = ImageDecoder.decodeDrawable(source, listener);\n *  </pre>\n *\n *  <p>The {@link ImageInfo ImageInfo} contains information about the encoded image, like\n *  its width and height, and the {@link Source Source} can be used to match to a particular\n *  {@link Source Source} if a single {@link OnHeaderDecodedListener OnHeaderDecodedListener}\n *  is used with multiple {@link Source Source} objects.\n *\n *  <p>The {@link OnHeaderDecodedListener OnHeaderDecodedListener} can also be implemented\n *  as a lambda:\n *\n *  <pre class=\"prettyprint\">\n *  Drawable drawable = ImageDecoder.decodeDrawable(source, (decoder, info, src) -&gt; {\n *      decoder.setTargetSampleSize(2);\n *  });\n *  </pre>\n *\n *  <p>If the encoded image is an animated {@code GIF} or {@code WEBP},\n *  {@link #decodeDrawable decodeDrawable} will return an {@link AnimatedImageDrawable}. To\n *  start its animation, call {@link AnimatedImageDrawable#start AnimatedImageDrawable.start()}:\n *\n *  <pre class=\"prettyprint\">\n *  Drawable drawable = ImageDecoder.decodeDrawable(source);\n *  if (drawable instanceof AnimatedImageDrawable) {\n *      ((AnimatedImageDrawable) drawable).start();\n *  }\n *  </pre>\n *\n *  <p>By default, a {@link Bitmap} created by {@link ImageDecoder} (including\n *  one that is inside a {@link Drawable}) will be immutable (i.e.\n *  {@link Bitmap#isMutable Bitmap.isMutable()} returns {@code false}), and it\n *  will typically have {@code Config} {@link Bitmap.Config#HARDWARE}. Although\n *  these properties can be changed with {@link #setMutableRequired setMutableRequired(true)}\n *  (which is only compatible with {@link #decodeBitmap(Source)} and\n *  {@link #decodeBitmap(Source, OnHeaderDecodedListener)}) and {@link #setAllocator},\n *  it is also possible to apply custom effects regardless of the mutability of\n *  the final returned object by passing a {@link PostProcessor} to\n *  {@link #setPostProcessor setPostProcessor}. A {@link PostProcessor} can also be a lambda:\n *\n *  <pre class=\"prettyprint\">\n *  Drawable drawable = ImageDecoder.decodeDrawable(source, (decoder, info, src) -&gt; {\n *      decoder.setPostProcessor((canvas) -&gt; {\n *              // This will create rounded corners.\n *              Path path = new Path();\n *              path.setFillType(Path.FillType.INVERSE_EVEN_ODD);\n *              int width = canvas.getWidth();\n *              int height = canvas.getHeight();\n *              path.addRoundRect(0, 0, width, height, 20, 20, Path.Direction.CW);\n *              Paint paint = new Paint();\n *              paint.setAntiAlias(true);\n *              paint.setColor(Color.TRANSPARENT);\n *              paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC));\n *              canvas.drawPath(path, paint);\n *              return PixelFormat.TRANSLUCENT;\n *      });\n *  });\n *  </pre>\n *\n *  <p>If the encoded image is incomplete or contains an error, or if an\n *  {@link Exception} occurs during decoding, a {@link DecodeException DecodeException}\n *  will be thrown. In some cases, the {@link ImageDecoder} may have decoded part of\n *  the image. In order to display the partial image, an\n *  {@link OnPartialImageListener OnPartialImageListener} must be passed to\n *  {@link #setOnPartialImageListener setOnPartialImageListener}. For example:\n *\n *  <pre class=\"prettyprint\">\n *  Drawable drawable = ImageDecoder.decodeDrawable(source, (decoder, info, src) -&gt; {\n *      decoder.setOnPartialImageListener((DecodeException e) -&gt; {\n *              // Returning true indicates to create a Drawable or Bitmap even\n *              // if the whole image could not be decoded. Any remaining lines\n *              // will be blank.\n *              return true;\n *      });\n *  });\n *  </pre>\n ",
  "links" : [ "#decodeDrawable(Source)", "#setTargetSampleSize", "android.net.Uri", "android.system.ErrnoException", "#setPostProcessor", "Source", "#decodeBitmap(Source", "android.graphics.ImageDecoder", "#setOnPartialImageListener", "#onHeaderDecoded", "android.graphics.drawable.AnimatedImageDrawable", "ImageInfo", "android.graphics.PostProcessor", "#decodeDrawable(Source", "android.graphics.drawable.AnimatedImageDrawable#start", "Bitmap.Config#HARDWARE", "#setMutableRequired", "#createSource(ContentResolver", "#decodeBitmap(Source)", "DecodeException", "OnPartialImageListener", "android.graphics.Bitmap#isMutable", "#setAllocator", "android.graphics.Bitmap", "#decodeDrawable", "OnHeaderDecodedListener" ],
  "variables" : [ {
    "name" : "mNativePtr",
    "type" : "long",
    "comment" : " Fields",
    "links" : [ ]
  }, {
    "name" : "mWidth",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHeight",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAnimated",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsNinePatch",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDesiredWidth",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDesiredHeight",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAllocator",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUnpremultipliedRequired",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMutable",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mConserveMemory",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDecodeAsAlphaMask",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDesiredColorSpace",
    "type" : "ColorSpace",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCropRect",
    "type" : "Rect",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOutPaddingRect",
    "type" : "Rect",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSource",
    "type" : "Source",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPostProcessor",
    "type" : "PostProcessor",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOnPartialImageListener",
    "type" : "OnPartialImageListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInputStream",
    "type" : "InputStream",
    "comment" : " Objects for interacting with the input.",
    "links" : [ ]
  }, {
    "name" : "mOwnsInputStream",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTempStorage",
    "type" : "byte[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAssetFd",
    "type" : "AssetFileDescriptor",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mClosed",
    "type" : "AtomicBoolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCloseGuard",
    "type" : "CloseGuard",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ALLOCATOR_DEFAULT",
    "type" : "int",
    "comment" : "\n     *  Use the default allocation for the pixel memory.\n     *\n     *  Will typically result in a {@link Bitmap.Config#HARDWARE}\n     *  allocation, but may be software for small images. In addition, this will\n     *  switch to software when HARDWARE is incompatible, e.g.\n     *  {@link #setMutableRequired setMutableRequired(true)} or\n     *  {@link #setDecodeAsAlphaMaskEnabled setDecodeAsAlphaMaskEnabled(true)}.\n     ",
    "links" : [ "Bitmap.Config#HARDWARE", "#setMutableRequired", "#setDecodeAsAlphaMaskEnabled" ]
  }, {
    "name" : "ALLOCATOR_SOFTWARE",
    "type" : "int",
    "comment" : "\n     *  Use a software allocation for the pixel memory.\n     *\n     *  <p>Useful for drawing to a software {@link Canvas} or for\n     *  accessing the pixels on the final output.\n     ",
    "links" : [ "android.graphics.Canvas" ]
  }, {
    "name" : "ALLOCATOR_SHARED_MEMORY",
    "type" : "int",
    "comment" : "\n     *  Use shared memory for the pixel memory.\n     *\n     *  <p>Useful for sharing across processes.\n     ",
    "links" : [ ]
  }, {
    "name" : "ALLOCATOR_HARDWARE",
    "type" : "int",
    "comment" : "\n     *  Require a {@link Bitmap.Config#HARDWARE} {@link Bitmap}.\n     *\n     *  <p>When this is combined with incompatible options, like\n     *  {@link #setMutableRequired setMutableRequired(true)} or\n     *  {@link #setDecodeAsAlphaMaskEnabled setDecodeAsAlphaMaskEnabled(true)},\n     *  {@link #decodeDrawable decodeDrawable} or {@link #decodeBitmap decodeBitmap}\n     *  will throw an {@link java.lang.IllegalStateException}.\n     ",
    "links" : [ "java.lang.IllegalStateException", "#decodeBitmap", "android.graphics.Bitmap", "#decodeDrawable", "Bitmap.Config#HARDWARE", "#setMutableRequired", "#setDecodeAsAlphaMaskEnabled" ]
  }, {
    "name" : "MEMORY_POLICY_LOW_RAM",
    "type" : "int",
    "comment" : "\n     * Save memory if possible by using a denser {@link Bitmap.Config} at the\n     * cost of some image quality.\n     *\n     * <p>For example an opaque 8-bit image may be compressed into an\n     * {@link Bitmap.Config#RGB_565} configuration, sacrificing image\n     * quality to save memory.\n     ",
    "links" : [ "Bitmap.Config#RGB_565", "Bitmap.Config" ]
  }, {
    "name" : "MEMORY_POLICY_DEFAULT",
    "type" : "int",
    "comment" : "\n     * Use the most natural {@link Bitmap.Config} for the internal {@link Bitmap}.\n     *\n     * <p>This is the recommended default for most applications and usages. This\n     * will use the closest {@link Bitmap.Config} for the encoded source. If the\n     * encoded source does not exactly match any {@link Bitmap.Config}, the next\n     * highest quality {@link Bitmap.Config} will be used avoiding any loss in\n     * image quality.\n     ",
    "links" : [ "android.graphics.Bitmap", "Bitmap.Config" ]
  }, {
    "name" : "sIsHevcDecoderSupported",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sIsHevcDecoderSupportedInitialized",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sIsHevcDecoderSupportedLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sIsP010SupportedForAV1",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sIsP010SupportedForHEVC",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sIsP010SupportedFlagsInitialized",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sIsP010SupportedLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private static ImageDecoder createFromFile(@NonNull File file, boolean preferAnimation, @NonNull Source source) throws IOException",
    "returnType" : "ImageDecoder",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static ImageDecoder createFromStream(@NonNull InputStream is, boolean closeInputStream, boolean preferAnimation, Source source) throws IOException",
    "returnType" : "ImageDecoder",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static ImageDecoder createFromAssetFileDescriptor(@NonNull AssetFileDescriptor assetFd, boolean preferAnimation, Source source) throws IOException",
    "returnType" : "ImageDecoder",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static ImageDecoder createFromAsset(AssetInputStream ais, boolean preferAnimation, Source source) throws IOException",
    "returnType" : "ImageDecoder",
    "comment" : "\n     *  ImageDecoder will own the AssetInputStream.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void finalize() throws Throwable",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static boolean isMimeTypeSupported(@NonNull String mimeType)",
    "returnType" : "boolean",
    "comment" : "\n     * Return if the given MIME type is a supported file format that can be\n     * decoded by this class. This can be useful to determine if a file can be\n     * decoded directly, or if it needs to be converted into a more general\n     * format using an API like {@link ContentResolver#openTypedAssetFile}.\n     ",
    "links" : [ "android.content.ContentResolver#openTypedAssetFile" ]
  }, {
    "name" : "public static Source createSource(@NonNull Resources res, int resId)",
    "returnType" : "Source",
    "comment" : "\n     * Create a new {@link Source Source} from a resource.\n     *\n     * @param res the {@link Resources} object containing the image data.\n     * @param resId resource ID of the image data.\n     * @return a new Source object, which can be passed to\n     *      {@link #decodeDrawable decodeDrawable} or\n     *      {@link #decodeBitmap decodeBitmap}.\n     ",
    "links" : [ "#decodeBitmap", "#decodeDrawable", "Source", "android.content.res.Resources" ]
  }, {
    "name" : "public static Source createSource(@NonNull ContentResolver cr, @NonNull Uri uri)",
    "returnType" : "Source",
    "comment" : "\n     * Create a new {@link Source Source} from a {@link android.net.Uri}.\n     *\n     * <h5>Accepts the following URI schemes:</h5>\n     * <ul>\n     * <li>content ({@link ContentResolver#SCHEME_CONTENT})</li>\n     * <li>android.resource ({@link ContentResolver#SCHEME_ANDROID_RESOURCE})</li>\n     * <li>file ({@link ContentResolver#SCHEME_FILE})</li>\n     * </ul>\n     *\n     * @param cr to retrieve from.\n     * @param uri of the image file.\n     * @return a new Source object, which can be passed to\n     *      {@link #decodeDrawable decodeDrawable} or\n     *      {@link #decodeBitmap decodeBitmap}.\n     ",
    "links" : [ "#decodeBitmap", "android.content.ContentResolver#SCHEME_CONTENT", "android.net.Uri", "#decodeDrawable", "Source", "android.content.ContentResolver#SCHEME_ANDROID_RESOURCE", "android.content.ContentResolver#SCHEME_FILE" ]
  }, {
    "name" : "public static Source createSource(@NonNull ContentResolver cr, @NonNull Uri uri, @Nullable Resources res)",
    "returnType" : "Source",
    "comment" : "\n     * Provide Resources for density scaling.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Source createSource(@NonNull AssetManager assets, @NonNull String fileName)",
    "returnType" : "Source",
    "comment" : "\n     * Create a new {@link Source Source} from a file in the \"assets\" directory.\n     ",
    "links" : [ "Source" ]
  }, {
    "name" : "public static Source createSource(@NonNull byte[] data, int offset, int length) throws ArrayIndexOutOfBoundsException",
    "returnType" : "Source",
    "comment" : "\n     * Create a new {@link Source Source} from a byte array.\n     *\n     * <p>Note: If this {@code Source} is passed to {@link #decodeDrawable decodeDrawable},\n     * and the encoded image is animated, the returned {@link AnimatedImageDrawable}\n     * will continue reading from {@code data}, so its contents must not\n     * be modified, even after the {@code AnimatedImageDrawable} is returned.\n     * {@code data}'s contents should never be modified during decode.</p>\n     *\n     * @param data byte array of compressed image data.\n     * @param offset offset into data for where the decoder should begin\n     *      parsing.\n     * @param length number of bytes, beginning at offset, to parse.\n     * @return a new Source object, which can be passed to\n     *      {@link #decodeDrawable decodeDrawable} or\n     *      {@link #decodeBitmap decodeBitmap}.\n     * @throws NullPointerException if data is null.\n     * @throws ArrayIndexOutOfBoundsException if offset and length are\n     *      not within data.\n     ",
    "links" : [ "#decodeBitmap", "#decodeDrawable", "android.graphics.drawable.AnimatedImageDrawable", "Source" ]
  }, {
    "name" : "public static Source createSource(@NonNull byte[] data)",
    "returnType" : "Source",
    "comment" : "\n     * Create a new {@link Source Source} from a byte array.\n     *\n     * <p>Note: If this {@code Source} is passed to {@link #decodeDrawable decodeDrawable},\n     * and the encoded image is animated, the returned {@link AnimatedImageDrawable}\n     * will continue reading from {@code data}, so its contents must not\n     * be modified, even after the {@code AnimatedImageDrawable} is returned.\n     * {@code data}'s contents should never be modified during decode.</p>\n     *\n     * @param data byte array of compressed image data.\n     * @return a new Source object, which can be passed to\n     *      {@link #decodeDrawable decodeDrawable} or\n     *      {@link #decodeBitmap decodeBitmap}.\n     * @throws NullPointerException if data is null.\n     ",
    "links" : [ "#decodeBitmap", "#decodeDrawable", "android.graphics.drawable.AnimatedImageDrawable", "Source" ]
  }, {
    "name" : "public static Source createSource(@NonNull ByteBuffer buffer)",
    "returnType" : "Source",
    "comment" : "\n     * Create a new {@link Source Source} from a {@link java.nio.ByteBuffer}.\n     *\n     * <p>Decoding will start from {@link java.nio.ByteBuffer#position() buffer.position()}.\n     * The position of {@code buffer} will not be affected.</p>\n     *\n     * <p>Note: If this {@code Source} is passed to {@link #decodeDrawable decodeDrawable},\n     * and the encoded image is animated, the returned {@link AnimatedImageDrawable}\n     * will continue reading from the {@code buffer}, so its contents must not\n     * be modified, even after the {@code AnimatedImageDrawable} is returned.\n     * {@code buffer}'s contents should never be modified during decode.</p>\n     *\n     * @return a new Source object, which can be passed to\n     *      {@link #decodeDrawable decodeDrawable} or\n     *      {@link #decodeBitmap decodeBitmap}.\n     ",
    "links" : [ "#decodeBitmap", "#decodeDrawable", "android.graphics.drawable.AnimatedImageDrawable", "java.nio.ByteBuffer#position()", "Source", "java.nio.ByteBuffer" ]
  }, {
    "name" : "public static Source createSource(Resources res, @NonNull InputStream is)",
    "returnType" : "Source",
    "comment" : "\n     * Internal API used to generate bitmaps for use by Drawables (i.e. BitmapDrawable)\n     *\n     * <p>Unlike other Sources, this one cannot be reused.</p>\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Source createSource(Resources res, @NonNull InputStream is, int density)",
    "returnType" : "Source",
    "comment" : "\n     * Internal API used to generate bitmaps for use by Drawables (i.e. BitmapDrawable)\n     *\n     * <p>Unlike other Sources, this one cannot be reused.</p>\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Source createSource(@NonNull File file)",
    "returnType" : "Source",
    "comment" : "\n     * Create a new {@link Source Source} from a {@link java.io.File}.\n     * <p>\n     * This method should only be used for files that you have direct access to;\n     * if you'd like to work with files hosted outside your app, use an API like\n     * {@link #createSource(Callable)} or\n     * {@link #createSource(ContentResolver, Uri)}.\n     * @return a new Source object, which can be passed to\n     *      {@link #decodeDrawable decodeDrawable} or\n     *      {@link #decodeBitmap decodeBitmap}.\n     ",
    "links" : [ "#decodeBitmap", "#createSource(Callable)", "#decodeDrawable", "#createSource(ContentResolver", "Source", "java.io.File" ]
  }, {
    "name" : "public static Source createSource(@NonNull Callable<AssetFileDescriptor> callable)",
    "returnType" : "Source",
    "comment" : "\n     * Create a new {@link Source Source} from a {@link Callable} that returns a\n     * new {@link AssetFileDescriptor} for each request. This provides control\n     * over how the {@link AssetFileDescriptor} is created, such as passing\n     * options into {@link ContentResolver#openTypedAssetFileDescriptor}, or\n     * enabling use of a {@link android.os.CancellationSignal}.\n     * <p>\n     * It's important for the given {@link Callable} to return a new, unique\n     * {@link AssetFileDescriptor} for each invocation, to support reuse of the\n     * returned {@link Source Source}.\n     *\n     * @return a new Source object, which can be passed to\n     *         {@link #decodeDrawable decodeDrawable} or {@link #decodeBitmap\n     *         decodeBitmap}.\n     ",
    "links" : [ "android.content.res.AssetFileDescriptor", "android.content.ContentResolver#openTypedAssetFileDescriptor", "android.os.CancellationSignal", "#decodeDrawable", "#decodeBitmapdecodeBitmap", "java.util.concurrent.Callable", "Source" ]
  }, {
    "name" : "private Size getSampledSize(int sampleSize)",
    "returnType" : "Size",
    "comment" : "\n     *  Return the width and height of a given sample size.\n     *\n     *  <p>This takes an input that functions like\n     *  {@link BitmapFactory.Options#inSampleSize}. It returns a width and\n     *  height that can be achieved by sampling the encoded image. Other widths\n     *  and heights may be supported, but will require an additional (internal)\n     *  scaling step. Such internal scaling is *not* supported with\n     *  {@link #setUnpremultipliedRequired} set to {@code true}.</p>\n     *\n     *  @param sampleSize Sampling rate of the encoded image.\n     *  @return {@link android.util.Size} of the width and height after\n     *      sampling.\n     ",
    "links" : [ "BitmapFactory.Options#inSampleSize", "#setUnpremultipliedRequired", "android.util.Size" ]
  }, {
    "name" : "public void setTargetSize(@Px @IntRange(from = 1) int width, @Px @IntRange(from = 1) int height)",
    "returnType" : "void",
    "comment" : "\n     *  Specify the size of the output {@link Drawable} or {@link Bitmap}.\n     *\n     *  <p>By default, the output size will match the size of the encoded\n     *  image, which can be retrieved from the {@link ImageInfo ImageInfo} in\n     *  {@link OnHeaderDecodedListener#onHeaderDecoded onHeaderDecoded}.</p>\n     *\n     *  <p>This will sample or scale the output to an arbitrary size that may\n     *  be smaller or larger than the encoded size.</p>\n     *\n     *  <p>Only the last call to this or {@link #setTargetSampleSize} is\n     *  respected.</p>\n     *\n     *  <p>Like all setters on ImageDecoder, this must be called inside\n     *  {@link OnHeaderDecodedListener#onHeaderDecoded onHeaderDecoded}.</p>\n     *\n     *  @param width width in pixels of the output, must be greater than 0\n     *  @param height height in pixels of the output, must be greater than 0\n     ",
    "links" : [ "#onHeaderDecoded", "android.graphics.Bitmap", "#setTargetSampleSize", "android.graphics.drawable.AnimatedImageDrawable", "ImageInfo" ]
  }, {
    "name" : "private int getTargetDimension(int original, int sampleSize, int computed)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setTargetSampleSize(@IntRange(from = 1) int sampleSize)",
    "returnType" : "void",
    "comment" : "\n     *  Set the target size with a sampleSize.\n     *\n     *  <p>By default, the output size will match the size of the encoded\n     *  image, which can be retrieved from the {@link ImageInfo ImageInfo} in\n     *  {@link OnHeaderDecodedListener#onHeaderDecoded onHeaderDecoded}.</p>\n     *\n     *  <p>Requests the decoder to subsample the original image, returning a\n     *  smaller image to save memory. The {@code sampleSize} is the number of pixels\n     *  in either dimension that correspond to a single pixel in the output.\n     *  For example, {@code sampleSize == 4} returns an image that is 1/4 the\n     *  width/height of the original, and 1/16 the number of pixels.</p>\n     *\n     *  <p>Must be greater than or equal to 1.</p>\n     *\n     *  <p>This has the same effect as calling {@link #setTargetSize} with\n     *  dimensions based on the {@code sampleSize}. Unlike dividing the original\n     *  width and height by the {@code sampleSize} manually, calling this method\n     *  allows {@code ImageDecoder} to round in the direction that it can do most\n     *  efficiently.</p>\n     *\n     *  <p>Only the last call to this or {@link #setTargetSize} is respected.</p>\n     *\n     *  <p>Like all setters on ImageDecoder, this must be called inside\n     *  {@link OnHeaderDecodedListener#onHeaderDecoded onHeaderDecoded}.</p>\n     *\n     *  @param sampleSize sampling rate of the encoded image.\n     ",
    "links" : [ "#onHeaderDecoded", "#setTargetSize", "ImageInfo" ]
  }, {
    "name" : "private boolean requestedResize()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setAllocator(@Allocator int allocator)",
    "returnType" : "void",
    "comment" : "\n     *  Choose the backing for the pixel memory.\n     *\n     *  <p>This is ignored for animated drawables.</p>\n     *\n     *  <p>Like all setters on ImageDecoder, this must be called inside\n     *  {@link OnHeaderDecodedListener#onHeaderDecoded onHeaderDecoded}.</p>\n     *\n     *  @param allocator Type of allocator to use.\n     ",
    "links" : [ "#onHeaderDecoded" ]
  }, {
    "name" : "public int getAllocator()",
    "returnType" : "int",
    "comment" : "\n     *  Return the allocator for the pixel memory.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setUnpremultipliedRequired(boolean unpremultipliedRequired)",
    "returnType" : "void",
    "comment" : "\n     *  Specify whether the {@link Bitmap} should have unpremultiplied pixels.\n     *\n     *  <p>By default, ImageDecoder will create a {@link Bitmap} with\n     *  premultiplied pixels, which is required for drawing with the\n     *  {@link android.view.View} system (i.e. to a {@link Canvas}). Calling\n     *  this method with a value of {@code true} will result in\n     *  {@link #decodeBitmap} returning a {@link Bitmap} with unpremultiplied\n     *  pixels. See {@link Bitmap#isPremultiplied Bitmap.isPremultiplied()}.\n     *  This is incompatible with {@link #decodeDrawable decodeDrawable};\n     *  attempting to decode an unpremultiplied {@link Drawable} will throw an\n     *  {@link java.lang.IllegalStateException}. </p>\n     *\n     *  <p>Like all setters on ImageDecoder, this must be called inside\n     *  {@link OnHeaderDecodedListener#onHeaderDecoded onHeaderDecoded}.</p>\n     ",
    "links" : [ "#onHeaderDecoded", "java.lang.IllegalStateException", "#decodeBitmap", "android.graphics.Bitmap#isPremultiplied", "android.graphics.Bitmap", "#decodeDrawable", "android.view.View", "android.graphics.drawable.AnimatedImageDrawable", "android.graphics.Canvas" ]
  }, {
    "name" : "public boolean isUnpremultipliedRequired()",
    "returnType" : "boolean",
    "comment" : "\n     *  Return whether the {@link Bitmap} will have unpremultiplied pixels.\n     ",
    "links" : [ "android.graphics.Bitmap" ]
  }, {
    "name" : "public void setPostProcessor(@Nullable PostProcessor postProcessor)",
    "returnType" : "void",
    "comment" : "\n     *  Modify the image after decoding and scaling.\n     *\n     *  <p>This allows adding effects prior to returning a {@link Drawable} or\n     *  {@link Bitmap}. For a {@code Drawable} or an immutable {@code Bitmap},\n     *  this is the only way to process the image after decoding.</p>\n     *\n     *  <p>If combined with {@link #setTargetSize} and/or {@link #setCrop},\n     *  {@link PostProcessor#onPostProcess} occurs last.</p>\n     *\n     *  <p>If set on a nine-patch image, the nine-patch data is ignored.</p>\n     *\n     *  <p>For an animated image, the drawing commands drawn on the\n     *  {@link Canvas} will be recorded immediately and then applied to each\n     *  frame.</p>\n     *\n     *  <p>Like all setters on ImageDecoder, this must be called inside\n     *  {@link OnHeaderDecodedListener#onHeaderDecoded onHeaderDecoded}.</p>\n     *\n     ",
    "links" : [ "#onHeaderDecoded", "android.graphics.PostProcessor#onPostProcess", "android.graphics.Bitmap", "android.graphics.drawable.AnimatedImageDrawable", "#setTargetSize", "android.graphics.Canvas", "#setCrop" ]
  }, {
    "name" : "public PostProcessor getPostProcessor()",
    "returnType" : "PostProcessor",
    "comment" : "\n     *  Return the {@link PostProcessor} currently set.\n     ",
    "links" : [ "android.graphics.PostProcessor" ]
  }, {
    "name" : "public void setOnPartialImageListener(@Nullable OnPartialImageListener listener)",
    "returnType" : "void",
    "comment" : "\n     *  Set (replace) the {@link OnPartialImageListener} on this object.\n     *\n     *  <p>Will be called if there is an error in the input. Without one, an\n     *  error will result in an {@code Exception} being thrown.</p>\n     *\n     *  <p>Like all setters on ImageDecoder, this must be called inside\n     *  {@link OnHeaderDecodedListener#onHeaderDecoded onHeaderDecoded}.</p>\n     *\n     ",
    "links" : [ "#onHeaderDecoded", "OnPartialImageListener" ]
  }, {
    "name" : "public OnPartialImageListener getOnPartialImageListener()",
    "returnType" : "OnPartialImageListener",
    "comment" : "\n     *  Return the {@link OnPartialImageListener OnPartialImageListener} currently set.\n     ",
    "links" : [ "OnPartialImageListener" ]
  }, {
    "name" : "public void setCrop(@Nullable Rect subset)",
    "returnType" : "void",
    "comment" : "\n     *  Crop the output to {@code subset} of the (possibly) scaled image.\n     *\n     *  <p>{@code subset} must be contained within the size set by\n     *  {@link #setTargetSize} or the bounds of the image if setTargetSize was\n     *  not called. Otherwise an {@link IllegalStateException} will be thrown by\n     *  {@link #decodeDrawable decodeDrawable}/{@link #decodeBitmap decodeBitmap}.</p>\n     *\n     *  <p>NOT intended as a replacement for\n     *  {@link BitmapRegionDecoder#decodeRegion BitmapRegionDecoder.decodeRegion()}.\n     *  This supports all formats, but merely crops the output.</p>\n     *\n     *  <p>Like all setters on ImageDecoder, this must be called inside\n     *  {@link OnHeaderDecodedListener#onHeaderDecoded onHeaderDecoded}.</p>\n     *\n     ",
    "links" : [ "#onHeaderDecoded", "IllegalStateException", "#decodeBitmap", "android.graphics.BitmapRegionDecoder#decodeRegion", "#decodeDrawable", "#setTargetSize" ]
  }, {
    "name" : "public Rect getCrop()",
    "returnType" : "Rect",
    "comment" : "\n     *  Return the cropping rectangle, if set.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOutPaddingRect(@NonNull Rect outPadding)",
    "returnType" : "void",
    "comment" : "\n     *  Set a Rect for retrieving nine patch padding.\n     *\n     *  If the image is a nine patch, this Rect will be set to the padding\n     *  rectangle during decode. Otherwise it will not be modified.\n     *\n     *  <p>Like all setters on ImageDecoder, this must be called inside\n     *  {@link OnHeaderDecodedListener#onHeaderDecoded onHeaderDecoded}.</p>\n     *\n     *  @hide\n     *  Must be public for access from android.graphics.drawable,\n     *  but must not be called from outside the UI module.\n     ",
    "links" : [ "#onHeaderDecoded" ]
  }, {
    "name" : "public void setMutableRequired(boolean mutable)",
    "returnType" : "void",
    "comment" : "\n     *  Specify whether the {@link Bitmap} should be mutable.\n     *\n     *  <p>By default, a {@link Bitmap} created by {@link #decodeBitmap decodeBitmap}\n     *  will be immutable i.e. {@link Bitmap#isMutable() Bitmap.isMutable()} returns\n     *  {@code false}. This can be changed with {@code setMutableRequired(true)}.\n     *\n     *  <p>Mutable Bitmaps are incompatible with {@link #ALLOCATOR_HARDWARE},\n     *  because {@link Bitmap.Config#HARDWARE} Bitmaps cannot be mutable.\n     *  Attempting to combine them will throw an\n     *  {@link java.lang.IllegalStateException}.</p>\n     *\n     *  <p>Mutable Bitmaps are also incompatible with {@link #decodeDrawable decodeDrawable},\n     *  which would require retrieving the Bitmap from the returned Drawable in\n     *  order to modify. Attempting to decode a mutable {@link Drawable} will\n     *  throw an {@link java.lang.IllegalStateException}.</p>\n     *\n     *  <p>Like all setters on ImageDecoder, this must be called inside\n     *  {@link OnHeaderDecodedListener#onHeaderDecoded onHeaderDecoded}.</p>\n     ",
    "links" : [ "#onHeaderDecoded", "#ALLOCATOR_HARDWARE", "java.lang.IllegalStateException", "#decodeBitmap", "android.graphics.Bitmap", "#decodeDrawable", "android.graphics.Bitmap#isMutable()", "Bitmap.Config#HARDWARE", "android.graphics.drawable.AnimatedImageDrawable" ]
  }, {
    "name" : "public boolean isMutableRequired()",
    "returnType" : "boolean",
    "comment" : "\n     *  Return whether the decoded {@link Bitmap} will be mutable.\n     ",
    "links" : [ "android.graphics.Bitmap" ]
  }, {
    "name" : "public void setMemorySizePolicy(@MemoryPolicy int policy)",
    "returnType" : "void",
    "comment" : "\n     *  Specify the memory policy for the decoded {@link Bitmap}.\n     *\n     *  <p>Like all setters on ImageDecoder, this must be called inside\n     *  {@link OnHeaderDecodedListener#onHeaderDecoded onHeaderDecoded}.</p>\n     ",
    "links" : [ "#onHeaderDecoded", "android.graphics.Bitmap" ]
  }, {
    "name" : "public int getMemorySizePolicy()",
    "returnType" : "int",
    "comment" : "\n     *  Retrieve the memory policy for the decoded {@link Bitmap}.\n     ",
    "links" : [ "android.graphics.Bitmap" ]
  }, {
    "name" : "public void setDecodeAsAlphaMaskEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     *  Specify whether to potentially treat the output as an alpha mask.\n     *\n     *  <p>If this is set to {@code true} and the image is encoded in a format\n     *  with only one channel, treat that channel as alpha. Otherwise this call has\n     *  no effect.</p>\n     *\n     *  <p>This is incompatible with {@link #ALLOCATOR_HARDWARE}. Trying to\n     *  combine them will result in {@link #decodeDrawable decodeDrawable}/\n     *  {@link #decodeBitmap decodeBitmap} throwing an\n     *  {@link java.lang.IllegalStateException}.</p>\n     *\n     *  <p>Like all setters on ImageDecoder, this must be called inside\n     *  {@link OnHeaderDecodedListener#onHeaderDecoded onHeaderDecoded}.</p>\n     ",
    "links" : [ "#onHeaderDecoded", "#ALLOCATOR_HARDWARE", "java.lang.IllegalStateException", "#decodeBitmap", "#decodeDrawable" ]
  }, {
    "name" : "public boolean isDecodeAsAlphaMaskEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     *  Return whether to treat single channel input as alpha.\n     *\n     *  <p>This returns whether {@link #setDecodeAsAlphaMaskEnabled} was set to\n     *  {@code true}. It may still return {@code true} even if the image has\n     *  more than one channel and therefore will not be treated as an alpha\n     *  mask.</p>\n     ",
    "links" : [ "#setDecodeAsAlphaMaskEnabled" ]
  }, {
    "name" : "public void setTargetColorSpace(ColorSpace colorSpace)",
    "returnType" : "void",
    "comment" : "\n     * Specify the desired {@link ColorSpace} for the output.\n     *\n     * <p>If non-null, the decoder will try to decode into {@code colorSpace}.\n     * If it is null, which is the default, or the request cannot be met, the\n     * decoder will pick either the color space embedded in the image or the\n     * {@link ColorSpace} best suited for the requested image configuration\n     * (for instance {@link ColorSpace.Named#SRGB sRGB} for the\n     * {@link Bitmap.Config#ARGB_8888} configuration and\n     * {@link ColorSpace.Named#EXTENDED_SRGB EXTENDED_SRGB} for\n     * {@link Bitmap.Config#RGBA_F16}).</p>\n     *\n     * <p class=\"note\">Only {@link ColorSpace.Model#RGB} color spaces are\n     * currently supported. An <code>IllegalArgumentException</code> will\n     * be thrown by {@link #decodeDrawable decodeDrawable}/\n     * {@link #decodeBitmap decodeBitmap} when setting a non-RGB color space\n     * such as {@link ColorSpace.Named#CIE_LAB Lab}.</p>\n     *\n     * <p class=\"note\">Prior to {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE},\n     * the specified color space's transfer function must be\n     * an {@link ColorSpace.Rgb.TransferParameters ICC parametric curve}. An\n     * <code>IllegalArgumentException</code> will be thrown by the decode methods\n     * if calling {@link ColorSpace.Rgb#getTransferParameters()} on the\n     * specified color space returns null.\n     * Starting from {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE},\n     * the color spaces with non ICC parametric curve transfer function are allowed.\n     * E.g., {@link ColorSpace.Named#BT2020_HLG BT2020_HLG}.\n     * </p>\n     *\n     * <p>Like all setters on ImageDecoder, this must be called inside\n     * {@link OnHeaderDecodedListener#onHeaderDecoded onHeaderDecoded}.</p>\n     ",
    "links" : [ "ColorSpace.Named#EXTENDED_SRGB", "Bitmap.Config#RGBA_F16", "ColorSpace.Rgb.TransferParameters", "#decodeBitmap", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "ColorSpace.Named#CIE_LAB", "ColorSpace.Named#SRGB", "#onHeaderDecoded", "ColorSpace.Named#BT2020_HLG", "#decodeDrawable", "ColorSpace.Rgb#getTransferParameters()", "android.graphics.ColorSpace", "Bitmap.Config#ARGB_8888", "ColorSpace.Model#RGB" ]
  }, {
    "name" : "public void close()",
    "returnType" : "void",
    "comment" : "\n     * Closes this resource, relinquishing any underlying resources. This method\n     * is invoked automatically on objects managed by the try-with-resources\n     * statement.\n     *\n     * <p>This is an implementation detail of {@link ImageDecoder}, and should\n     * never be called manually.</p>\n     ",
    "links" : [ "android.graphics.ImageDecoder" ]
  }, {
    "name" : "private void checkState(boolean animated)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void checkSubset(int width, int height, Rect r)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean checkForExtended()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private long getColorSpacePtr()",
    "returnType" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private Bitmap decodeBitmapInternal() throws IOException",
    "returnType" : "Bitmap",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void callHeaderDecoded(@Nullable OnHeaderDecodedListener listener, @NonNull Source src)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static ImageInfo decodeHeader(@NonNull Source src) throws IOException",
    "returnType" : "ImageInfo",
    "comment" : "\n     * Return {@link ImageInfo} from a {@code Source}.\n     *\n     * <p>Returns the same {@link ImageInfo} object that a usual decoding process would return as\n     * part of {@link OnHeaderDecodedListener}.\n     *\n     * @param src representing the encoded image.\n     * @return ImageInfo describing the image.\n     * @throws IOException if {@code src} is not found, is an unsupported format, or cannot be\n     *     decoded for any reason.\n     * @hide\n     ",
    "links" : [ "OnHeaderDecodedListener", "ImageInfo" ]
  }, {
    "name" : "public static Drawable decodeDrawable(@NonNull Source src, @NonNull OnHeaderDecodedListener listener) throws IOException",
    "returnType" : "Drawable",
    "comment" : "\n     *  Create a {@link Drawable} from a {@code Source}.\n     *\n     *  @param src representing the encoded image.\n     *  @param listener for learning the {@link ImageInfo ImageInfo} and changing any\n     *      default settings on the {@code ImageDecoder}. This will be called on\n     *      the same thread as {@code decodeDrawable} before that method returns.\n     *      This is required in order to change any of the default settings.\n     *  @return Drawable for displaying the image.\n     *  @throws IOException if {@code src} is not found, is an unsupported\n     *      format, or cannot be decoded for any reason.\n     ",
    "links" : [ "android.graphics.drawable.AnimatedImageDrawable", "ImageInfo" ]
  }, {
    "name" : "private static Drawable decodeDrawableImpl(@NonNull Source src, @Nullable OnHeaderDecodedListener listener) throws IOException",
    "returnType" : "Drawable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static Drawable decodeDrawable(@NonNull Source src) throws IOException",
    "returnType" : "Drawable",
    "comment" : "\n     *  Create a {@link Drawable} from a {@code Source}.\n     *\n     *  <p>Since there is no {@link OnHeaderDecodedListener OnHeaderDecodedListener},\n     *  the default settings will be used. In order to change any settings, call\n     *  {@link #decodeDrawable(Source, OnHeaderDecodedListener)} instead.</p>\n     *\n     *  @param src representing the encoded image.\n     *  @return Drawable for displaying the image.\n     *  @throws IOException if {@code src} is not found, is an unsupported\n     *      format, or cannot be decoded for any reason.\n     ",
    "links" : [ "#decodeDrawable(Source", "android.graphics.drawable.AnimatedImageDrawable", "OnHeaderDecodedListener" ]
  }, {
    "name" : "public static Bitmap decodeBitmap(@NonNull Source src, @NonNull OnHeaderDecodedListener listener) throws IOException",
    "returnType" : "Bitmap",
    "comment" : "\n     *  Create a {@link Bitmap} from a {@code Source}.\n     *\n     *  @param src representing the encoded image.\n     *  @param listener for learning the {@link ImageInfo ImageInfo} and changing any\n     *      default settings on the {@code ImageDecoder}. This will be called on\n     *      the same thread as {@code decodeBitmap} before that method returns.\n     *      This is required in order to change any of the default settings.\n     *  @return Bitmap containing the image.\n     *  @throws IOException if {@code src} is not found, is an unsupported\n     *      format, or cannot be decoded for any reason.\n     ",
    "links" : [ "android.graphics.Bitmap", "ImageInfo" ]
  }, {
    "name" : "private static Bitmap decodeBitmapImpl(@NonNull Source src, @Nullable OnHeaderDecodedListener listener) throws IOException",
    "returnType" : "Bitmap",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static AutoCloseable traceDecoderSource(ImageDecoder decoder)",
    "returnType" : "AutoCloseable",
    "comment" : "\n     * This describes the decoder in traces to ease debugging. It has to be called after\n     * header has been decoded and width/height have been populated. It should be used\n     * inside a try-with-resources call to automatically complete the trace.\n     ",
    "links" : [ ]
  }, {
    "name" : "private int computeDensity(@NonNull Source src)",
    "returnType" : "int",
    "comment" : " This method may modify the decoder so it must be called prior to performing the decode",
    "links" : [ ]
  }, {
    "name" : "private String getMimeType()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private ColorSpace getColorSpace()",
    "returnType" : "ColorSpace",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static Bitmap decodeBitmap(@NonNull Source src) throws IOException",
    "returnType" : "Bitmap",
    "comment" : "\n     *  Create a {@link Bitmap} from a {@code Source}.\n     *\n     *  <p>Since there is no {@link OnHeaderDecodedListener OnHeaderDecodedListener},\n     *  the default settings will be used. In order to change any settings, call\n     *  {@link #decodeBitmap(Source, OnHeaderDecodedListener)} instead.</p>\n     *\n     *  @param src representing the encoded image.\n     *  @return Bitmap containing the image.\n     *  @throws IOException if {@code src} is not found, is an unsupported\n     *      format, or cannot be decoded for any reason.\n     ",
    "links" : [ "android.graphics.Bitmap", "OnHeaderDecodedListener", "#decodeBitmap(Source" ]
  }, {
    "name" : "private static boolean isHevcDecoderSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Check if HEVC decoder is supported by the device.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean isP010SupportedForAV1()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the device supports decoding 10-bit AV1.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean isP010SupportedForHEVC()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the device supports decoding 10-bit HEVC.\n     * This method is called by JNI.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void checkP010SupportforAV1HEVC()",
    "returnType" : "void",
    "comment" : "\n     * Checks if the device supports decoding 10-bit for the given mime type.\n     ",
    "links" : [ ]
  }, {
    "name" : "private int postProcessAndRelease(@NonNull Canvas canvas)",
    "returnType" : "int",
    "comment" : "\n     * Private method called by JNI.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void onPartialImage(@DecodeException.Error int error, @Nullable Throwable cause) throws DecodeException",
    "returnType" : "void",
    "comment" : "\n     * Private method called by JNI.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static String describeDecoderForTrace(@NonNull ImageDecoder decoder)",
    "returnType" : "String",
    "comment" : "\n     * Returns a short string describing what passed ImageDecoder is loading -\n     * it reports image dimensions, desired dimensions (if any) and source resource.\n     *\n     * The string appears in perf traces to simplify search for slow or memory intensive\n     * image loads.\n     *\n     * Example: ID#w=300;h=250;dw=150;dh=150;src=Resource{name=@resource}\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static native ImageDecoder nCreate(long asset, boolean preferAnimation, Source src) throws IOException",
    "returnType" : "ImageDecoder",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native ImageDecoder nCreate(ByteBuffer buffer, int position, int limit, boolean preferAnimation, Source src) throws IOException",
    "returnType" : "ImageDecoder",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native ImageDecoder nCreate(byte[] data, int offset, int length, boolean preferAnimation, Source src) throws IOException",
    "returnType" : "ImageDecoder",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native ImageDecoder nCreate(InputStream is, byte[] storage, boolean preferAnimation, Source src) throws IOException",
    "returnType" : "ImageDecoder",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native ImageDecoder nCreate(FileDescriptor fd, long length, boolean preferAnimation, Source src) throws IOException",
    "returnType" : "ImageDecoder",
    "comment" : " The fd must be seekable.",
    "links" : [ ]
  }, {
    "name" : "private static native Bitmap nDecodeBitmap(long nativePtr, @NonNull ImageDecoder decoder, boolean doPostProcess, int width, int height, @Nullable Rect cropRect, boolean mutable, int allocator, boolean unpremulRequired, boolean conserveMemory, boolean decodeAsAlphaMask, long desiredColorSpace, boolean extended) throws IOException",
    "returnType" : "Bitmap",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native Size nGetSampledSize(long nativePtr, int sampleSize)",
    "returnType" : "Size",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nGetPadding(long nativePtr, @NonNull Rect outRect)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native void nClose(long nativePtr)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native String nGetMimeType(long nativePtr)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static native ColorSpace nGetColorSpace(long nativePtr)",
    "returnType" : "ColorSpace",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ "private static ImageDecoder createFromFile(@NonNull File file, boolean preferAnimation, @NonNull Source source) throws IOException", "private static ImageDecoder createFromStream(@NonNull InputStream is, boolean closeInputStream, boolean preferAnimation, Source source) throws IOException", "private static ImageDecoder createFromAssetFileDescriptor(@NonNull AssetFileDescriptor assetFd, boolean preferAnimation, Source source) throws IOException", "private static ImageDecoder createFromAsset(AssetInputStream ais, boolean preferAnimation, Source source) throws IOException", "protected void finalize() throws Throwable", "public static boolean isMimeTypeSupported(@NonNull String mimeType)", "public static Source createSource(@NonNull Resources res, int resId)", "public static Source createSource(@NonNull ContentResolver cr, @NonNull Uri uri)", "public static Source createSource(@NonNull ContentResolver cr, @NonNull Uri uri, @Nullable Resources res)", "public static Source createSource(@NonNull AssetManager assets, @NonNull String fileName)", "public static Source createSource(@NonNull byte[] data, int offset, int length) throws ArrayIndexOutOfBoundsException", "public static Source createSource(@NonNull byte[] data)", "public static Source createSource(@NonNull ByteBuffer buffer)", "public static Source createSource(Resources res, @NonNull InputStream is)", "public static Source createSource(Resources res, @NonNull InputStream is, int density)", "public static Source createSource(@NonNull File file)", "public static Source createSource(@NonNull Callable<AssetFileDescriptor> callable)", "private Size getSampledSize(int sampleSize)", "public void setTargetSize(@Px @IntRange(from = 1) int width, @Px @IntRange(from = 1) int height)", "private int getTargetDimension(int original, int sampleSize, int computed)", "public void setTargetSampleSize(@IntRange(from = 1) int sampleSize)", "private boolean requestedResize()", "public void setAllocator(@Allocator int allocator)", "public int getAllocator()", "public void setUnpremultipliedRequired(boolean unpremultipliedRequired)", "public boolean isUnpremultipliedRequired()", "public void setPostProcessor(@Nullable PostProcessor postProcessor)", "public PostProcessor getPostProcessor()", "public void setOnPartialImageListener(@Nullable OnPartialImageListener listener)", "public OnPartialImageListener getOnPartialImageListener()", "public void setCrop(@Nullable Rect subset)", "public Rect getCrop()", "public void setOutPaddingRect(@NonNull Rect outPadding)", "public void setMutableRequired(boolean mutable)", "public boolean isMutableRequired()", "public void setMemorySizePolicy(@MemoryPolicy int policy)", "public int getMemorySizePolicy()", "public void setDecodeAsAlphaMaskEnabled(boolean enabled)", "public boolean isDecodeAsAlphaMaskEnabled()", "public void setTargetColorSpace(ColorSpace colorSpace)", "public void close()", "private void checkState(boolean animated)", "private static void checkSubset(int width, int height, Rect r)", "private boolean checkForExtended()", "private long getColorSpacePtr()", "private Bitmap decodeBitmapInternal() throws IOException", "private void callHeaderDecoded(@Nullable OnHeaderDecodedListener listener, @NonNull Source src)", "public static ImageInfo decodeHeader(@NonNull Source src) throws IOException", "public static Drawable decodeDrawable(@NonNull Source src, @NonNull OnHeaderDecodedListener listener) throws IOException", "private static Drawable decodeDrawableImpl(@NonNull Source src, @Nullable OnHeaderDecodedListener listener) throws IOException", "public static Drawable decodeDrawable(@NonNull Source src) throws IOException", "public static Bitmap decodeBitmap(@NonNull Source src, @NonNull OnHeaderDecodedListener listener) throws IOException", "private static Bitmap decodeBitmapImpl(@NonNull Source src, @Nullable OnHeaderDecodedListener listener) throws IOException", "private static AutoCloseable traceDecoderSource(ImageDecoder decoder)", "private int computeDensity(@NonNull Source src)", "private String getMimeType()", "private ColorSpace getColorSpace()", "public static Bitmap decodeBitmap(@NonNull Source src) throws IOException", "private static boolean isHevcDecoderSupported()", "private static boolean isP010SupportedForAV1()", "private static boolean isP010SupportedForHEVC()", "private static void checkP010SupportforAV1HEVC()", "private int postProcessAndRelease(@NonNull Canvas canvas)", "private void onPartialImage(@DecodeException.Error int error, @Nullable Throwable cause) throws DecodeException", "private static String describeDecoderForTrace(@NonNull ImageDecoder decoder)", "private static native ImageDecoder nCreate(long asset, boolean preferAnimation, Source src) throws IOException", "private static native ImageDecoder nCreate(ByteBuffer buffer, int position, int limit, boolean preferAnimation, Source src) throws IOException", "private static native ImageDecoder nCreate(byte[] data, int offset, int length, boolean preferAnimation, Source src) throws IOException", "private static native ImageDecoder nCreate(InputStream is, byte[] storage, boolean preferAnimation, Source src) throws IOException", "private static native ImageDecoder nCreate(FileDescriptor fd, long length, boolean preferAnimation, Source src) throws IOException", "private static native Bitmap nDecodeBitmap(long nativePtr, @NonNull ImageDecoder decoder, boolean doPostProcess, int width, int height, @Nullable Rect cropRect, boolean mutable, int allocator, boolean unpremulRequired, boolean conserveMemory, boolean decodeAsAlphaMask, long desiredColorSpace, boolean extended) throws IOException", "private static native Size nGetSampledSize(long nativePtr, int sampleSize)", "private static native void nGetPadding(long nativePtr, @NonNull Rect outRect)", "private static native void nClose(long nativePtr)", "private static native String nGetMimeType(long nativePtr)", "private static native ColorSpace nGetColorSpace(long nativePtr)" ],
  "variableNames" : [ "mNativePtr", "mWidth", "mHeight", "mAnimated", "mIsNinePatch", "mDesiredWidth", "mDesiredHeight", "mAllocator", "mUnpremultipliedRequired", "mMutable", "mConserveMemory", "mDecodeAsAlphaMask", "mDesiredColorSpace", "mCropRect", "mOutPaddingRect", "mSource", "mPostProcessor", "mOnPartialImageListener", "mInputStream", "mOwnsInputStream", "mTempStorage", "mAssetFd", "mClosed", "mCloseGuard", "ALLOCATOR_DEFAULT", "ALLOCATOR_SOFTWARE", "ALLOCATOR_SHARED_MEMORY", "ALLOCATOR_HARDWARE", "MEMORY_POLICY_LOW_RAM", "MEMORY_POLICY_DEFAULT", "sIsHevcDecoderSupported", "sIsHevcDecoderSupportedInitialized", "sIsHevcDecoderSupportedLock", "sIsP010SupportedForAV1", "sIsP010SupportedForHEVC", "sIsP010SupportedFlagsInitialized", "sIsP010SupportedLock" ]
}