{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/app/NotificationManager.java",
  "packageName" : "android.app",
  "className" : "NotificationManager",
  "comment" : "\n * Class to notify the user of events that happen.  This is how you tell\n * the user that something has happened in the background. {@more}\n *\n * Notifications can take different forms:\n * <ul>\n *      <li>A persistent icon that goes in the status bar and is accessible\n *          through the launcher, (when the user selects it, a designated Intent\n *          can be launched),</li>\n *      <li>Turning on or flashing LEDs on the device, or</li>\n *      <li>Alerting the user by flashing the backlight, playing a sound,\n *          or vibrating.</li>\n * </ul>\n *\n * <p>\n * Each of the notify methods takes an int id parameter and optionally a\n * {@link String} tag parameter, which may be {@code null}.  These parameters\n * are used to form a pair (tag, id), or ({@code null}, id) if tag is\n * unspecified.  This pair identifies this notification from your app to the\n * system, so that pair should be unique within your app.  If you call one\n * of the notify methods with a (tag, id) pair that is currently active and\n * a new set of notification parameters, it will be updated.  For example,\n * if you pass a new status bar icon, the old icon in the status bar will\n * be replaced with the new one.  This is also the same tag and id you pass\n * to the {@link #cancel(int)} or {@link #cancel(String, int)} method to clear\n * this notification.\n *\n * <div class=\"special reference\">\n * <h3>Developer Guides</h3>\n * <p>For a guide to creating notifications, read the\n * <a href=\"{@docRoot}guide/topics/ui/notifiers/notifications.html\">Status Bar Notifications</a>\n * developer guide.</p>\n * </div>\n *\n * @see android.app.Notification\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "localLOGV",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_APP_BLOCK_STATE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Intent that is broadcast when an application is blocked or unblocked.\n     *\n     * This broadcast is only sent to the app whose block state has changed.\n     *\n     * Input: nothing\n     * Output: {@link #EXTRA_BLOCKED_STATE}\n     ",
    "links" : [ "#EXTRA_BLOCKED_STATE" ]
  }, {
    "name" : "ACTION_NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Intent that is broadcast when a {@link NotificationChannel} is blocked\n     * (when {@link NotificationChannel#getImportance()} is {@link #IMPORTANCE_NONE}) or unblocked\n     * (when {@link NotificationChannel#getImportance()} is anything other than\n     * {@link #IMPORTANCE_NONE}).\n     *\n     * This broadcast is only sent to the app that owns the channel that has changed.\n     *\n     * Input: nothing\n     * Output: {@link #EXTRA_NOTIFICATION_CHANNEL_ID}\n     * Output: {@link #EXTRA_BLOCKED_STATE}\n     ",
    "links" : [ "#IMPORTANCE_NONE", "android.app.NotificationChannel#getImportance()", "android.app.NotificationChannel", "#EXTRA_NOTIFICATION_CHANNEL_ID", "#EXTRA_BLOCKED_STATE" ]
  }, {
    "name" : "EXTRA_NOTIFICATION_CHANNEL_ID",
    "type" : "String",
    "comment" : "\n     * Extra for {@link #ACTION_NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED} containing the id of the\n     * {@link NotificationChannel} which has a new blocked state.\n     *\n     * The value will be the {@link NotificationChannel#getId()} of the channel.\n     ",
    "links" : [ "android.app.NotificationChannel#getId()", "android.app.NotificationChannel", "#ACTION_NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED" ]
  }, {
    "name" : "EXTRA_NOTIFICATION_CHANNEL_GROUP_ID",
    "type" : "String",
    "comment" : "\n     * Extra for {@link #ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED} containing the id\n     * of the {@link NotificationChannelGroup} which has a new blocked state.\n     *\n     * The value will be the {@link NotificationChannelGroup#getId()} of the group.\n     ",
    "links" : [ "android.app.NotificationChannelGroup#getId()", "android.app.NotificationChannelGroup", "#ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED" ]
  }, {
    "name" : "EXTRA_BLOCKED_STATE",
    "type" : "String",
    "comment" : "\n     * Extra for {@link #ACTION_NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED} or\n     * {@link #ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED} containing the new blocked\n     * state as a boolean.\n     *\n     * The value will be {@code true} if this channel or group is now blocked and {@code false} if\n     * this channel or group is now unblocked.\n     ",
    "links" : [ "#ACTION_NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED", "#ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED" ]
  }, {
    "name" : "ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Intent that is broadcast when a {@link NotificationChannelGroup} is\n     * {@link NotificationChannelGroup#isBlocked() blocked} or unblocked.\n     *\n     * This broadcast is only sent to the app that owns the channel group that has changed.\n     *\n     * Input: nothing\n     * Output: {@link #EXTRA_NOTIFICATION_CHANNEL_GROUP_ID}\n     * Output: {@link #EXTRA_BLOCKED_STATE}\n     ",
    "links" : [ "#EXTRA_NOTIFICATION_CHANNEL_GROUP_ID", "android.app.NotificationChannelGroup", "#EXTRA_BLOCKED_STATE", "android.app.NotificationChannelGroup#isBlocked()" ]
  }, {
    "name" : "ACTION_AUTOMATIC_ZEN_RULE_STATUS_CHANGED",
    "type" : "String",
    "comment" : "\n     * Intent that is broadcast when the status of an {@link AutomaticZenRule} has changed.\n     *\n     * <p>Use this to know whether you need to continue monitor to device state in order to\n     * provide up-to-date states (with {@link #setAutomaticZenRuleState(String, Condition)}) for\n     * this rule.</p>\n     *\n     * Input: nothing\n     * Output: {@link #EXTRA_AUTOMATIC_ZEN_RULE_ID}\n     * Output: {@link #EXTRA_AUTOMATIC_ZEN_RULE_STATUS}\n     ",
    "links" : [ "#EXTRA_AUTOMATIC_ZEN_RULE_ID", "#EXTRA_AUTOMATIC_ZEN_RULE_STATUS", "android.app.AutomaticZenRule", "#setAutomaticZenRuleState(String" ]
  }, {
    "name" : "EXTRA_AUTOMATIC_ZEN_RULE_STATUS",
    "type" : "String",
    "comment" : "\n     * Integer extra for {@link #ACTION_AUTOMATIC_ZEN_RULE_STATUS_CHANGED} containing the state of\n     * the {@link AutomaticZenRule}.\n     *\n     * <p>\n     *     The value will be one of {@link #AUTOMATIC_RULE_STATUS_ENABLED},\n     *     {@link #AUTOMATIC_RULE_STATUS_DISABLED}, {@link #AUTOMATIC_RULE_STATUS_REMOVED},\n     *     {@link #AUTOMATIC_RULE_STATUS_UNKNOWN}.\n     * </p>\n     ",
    "links" : [ "#AUTOMATIC_RULE_STATUS_REMOVED", "#ACTION_AUTOMATIC_ZEN_RULE_STATUS_CHANGED", "#AUTOMATIC_RULE_STATUS_UNKNOWN", "#AUTOMATIC_RULE_STATUS_ENABLED", "android.app.AutomaticZenRule", "#AUTOMATIC_RULE_STATUS_DISABLED" ]
  }, {
    "name" : "EXTRA_AUTOMATIC_ZEN_RULE_ID",
    "type" : "String",
    "comment" : "\n     * String extra for {@link #ACTION_AUTOMATIC_ZEN_RULE_STATUS_CHANGED} containing the id of the\n     * {@link AutomaticZenRule} (see {@link #addAutomaticZenRule(AutomaticZenRule)}) that has\n     * changed.\n     ",
    "links" : [ "#ACTION_AUTOMATIC_ZEN_RULE_STATUS_CHANGED", "android.app.AutomaticZenRule", "#addAutomaticZenRule(AutomaticZenRule)" ]
  }, {
    "name" : "AUTOMATIC_RULE_STATUS_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Constant value for {@link #EXTRA_AUTOMATIC_ZEN_RULE_STATUS} - the current status of the\n     * rule is unknown at your target sdk version, and you should continue to provide state changes\n     * via {@link #setAutomaticZenRuleState(String, Condition)}.\n     ",
    "links" : [ "#EXTRA_AUTOMATIC_ZEN_RULE_STATUS", "#setAutomaticZenRuleState(String" ]
  }, {
    "name" : "AUTOMATIC_RULE_STATUS_ENABLED",
    "type" : "int",
    "comment" : "\n     * Constant value for {@link #EXTRA_AUTOMATIC_ZEN_RULE_STATUS} - the given rule currently\n     * exists and is enabled. You should continue to provide state changes via\n     * {@link #setAutomaticZenRuleState(String, Condition)}.\n     ",
    "links" : [ "#EXTRA_AUTOMATIC_ZEN_RULE_STATUS", "#setAutomaticZenRuleState(String" ]
  }, {
    "name" : "AUTOMATIC_RULE_STATUS_DISABLED",
    "type" : "int",
    "comment" : "\n     * Constant value for {@link #EXTRA_AUTOMATIC_ZEN_RULE_STATUS} - the given rule currently\n     * exists but is disabled. You do not need to continue to provide state changes via\n     * {@link #setAutomaticZenRuleState(String, Condition)} until the rule is reenabled.\n     ",
    "links" : [ "#EXTRA_AUTOMATIC_ZEN_RULE_STATUS", "#setAutomaticZenRuleState(String" ]
  }, {
    "name" : "AUTOMATIC_RULE_STATUS_REMOVED",
    "type" : "int",
    "comment" : "\n     * Constant value for {@link #EXTRA_AUTOMATIC_ZEN_RULE_STATUS} - the given rule has been\n     * deleted. Further calls to {@link #setAutomaticZenRuleState(String, Condition)} will be\n     * ignored.\n     ",
    "links" : [ "#EXTRA_AUTOMATIC_ZEN_RULE_STATUS", "#setAutomaticZenRuleState(String" ]
  }, {
    "name" : "ACTION_EFFECTS_SUPPRESSOR_CHANGED",
    "type" : "String",
    "comment" : "\n     * Intent that is broadcast when the state of {@link #getEffectsSuppressor()} changes.\n     * This broadcast is only sent to registered receivers.\n     *\n     * @hide\n     ",
    "links" : [ "#getEffectsSuppressor()" ]
  }, {
    "name" : "ACTION_NOTIFICATION_POLICY_ACCESS_GRANTED_CHANGED",
    "type" : "String",
    "comment" : "\n     * Intent that is broadcast when the state of {@link #isNotificationPolicyAccessGranted()}\n     * changes.\n     *\n     * This broadcast is only sent to registered receivers, and only to the apps that have changed.\n     ",
    "links" : [ "#isNotificationPolicyAccessGranted()" ]
  }, {
    "name" : "ACTION_NOTIFICATION_POLICY_CHANGED",
    "type" : "String",
    "comment" : "\n     * Intent that is broadcast when the state of getNotificationPolicy() changes.\n     * This broadcast is only sent to registered receivers.\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_INTERRUPTION_FILTER_CHANGED",
    "type" : "String",
    "comment" : "\n     * Intent that is broadcast when the state of getCurrentInterruptionFilter() changes.\n     * This broadcast is only sent to registered receivers.\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_INTERRUPTION_FILTER_CHANGED_INTERNAL",
    "type" : "String",
    "comment" : "\n     * Intent that is broadcast when the state of getCurrentInterruptionFilter() changes.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INTERRUPTION_FILTER_ALL",
    "type" : "int",
    "comment" : "\n     * {@link #getCurrentInterruptionFilter() Interruption filter} constant -\n     *     Normal interruption filter - no notifications are suppressed.\n     ",
    "links" : [ "#getCurrentInterruptionFilter()" ]
  }, {
    "name" : "INTERRUPTION_FILTER_PRIORITY",
    "type" : "int",
    "comment" : "\n     * {@link #getCurrentInterruptionFilter() Interruption filter} constant -\n     *     Priority interruption filter - all notifications are suppressed except those that match\n     *     the priority criteria. Some audio streams are muted. See\n     *     {@link Policy#priorityCallSenders}, {@link Policy#priorityCategories},\n     *     {@link Policy#priorityMessageSenders} to define or query this criteria. Users can\n     *     additionally specify packages that can bypass this interruption filter.\n     ",
    "links" : [ "android.service.notification.ZenPolicy#priorityCallSenders", "android.service.notification.ZenPolicy#priorityCategories", "android.service.notification.ZenPolicy#priorityMessageSenders", "#getCurrentInterruptionFilter()" ]
  }, {
    "name" : "INTERRUPTION_FILTER_NONE",
    "type" : "int",
    "comment" : "\n     * {@link #getCurrentInterruptionFilter() Interruption filter} constant -\n     *     No interruptions filter - all notifications are suppressed and all audio streams (except\n     *     those used for phone calls) and vibrations are muted.\n     ",
    "links" : [ "#getCurrentInterruptionFilter()" ]
  }, {
    "name" : "INTERRUPTION_FILTER_ALARMS",
    "type" : "int",
    "comment" : "\n     * {@link #getCurrentInterruptionFilter() Interruption filter} constant -\n     *     Alarms only interruption filter - all notifications except those of category\n     *     {@link Notification#CATEGORY_ALARM} are suppressed. Some audio streams are muted.\n     ",
    "links" : [ "#getCurrentInterruptionFilter()", "android.service.notification.StatusBarNotification#CATEGORY_ALARM" ]
  }, {
    "name" : "INTERRUPTION_FILTER_UNKNOWN",
    "type" : "int",
    "comment" : " {@link #getCurrentInterruptionFilter() Interruption filter} constant - returned when\n     * the value is unavailable for any reason.\n     ",
    "links" : [ "#getCurrentInterruptionFilter()" ]
  }, {
    "name" : "ACTION_AUTOMATIC_ZEN_RULE",
    "type" : "String",
    "comment" : "\n     * Activity Action: Launch an Automatic Zen Rule configuration screen\n     * <p>\n     * Input: Optionally, {@link #EXTRA_AUTOMATIC_RULE_ID}, if the configuration screen for an\n     * existing rule should be displayed. If the rule id is missing or null, apps should display\n     * a configuration screen where users can create a new instance of the rule.\n     * <p>\n     * Output: Nothing\n     * <p>\n     *     You can have multiple activities handling this intent, if you support multiple\n     *     {@link AutomaticZenRule rules}. In order for the system to properly display all of your\n     *     rule types so that users can create new instances or configure existing ones, you need\n     *     to add some extra metadata ({@link #META_DATA_AUTOMATIC_RULE_TYPE})\n     *     to your activity tag in your manifest. If you'd like to limit the number of rules a user\n     *     can create from this flow, you can additionally optionally include\n     *     {@link #META_DATA_RULE_INSTANCE_LIMIT}.\n     *\n     *     For example,\n     *     &lt;meta-data\n     *         android:name=\"android.app.zen.automatic.ruleType\"\n     *         android:value=\"@string/my_condition_rule\">\n     *     &lt;/meta-data>\n     *     &lt;meta-data\n     *         android:name=\"android.app.zen.automatic.ruleInstanceLimit\"\n     *         android:value=\"1\">\n     *     &lt;/meta-data>\n     * </p>\n     * </p>\n     *\n     * @see #addAutomaticZenRule(AutomaticZenRule)\n     ",
    "links" : [ "#EXTRA_AUTOMATIC_RULE_ID", "#META_DATA_RULE_INSTANCE_LIMIT", "android.app.AutomaticZenRule", "#META_DATA_AUTOMATIC_RULE_TYPE" ]
  }, {
    "name" : "EXTRA_AUTOMATIC_RULE_ID",
    "type" : "String",
    "comment" : "\n     * Used as an optional string extra on {@link #ACTION_AUTOMATIC_ZEN_RULE} intents. If\n     * provided, contains the id of the {@link AutomaticZenRule} (as returned from\n     * {@link NotificationManager#addAutomaticZenRule(AutomaticZenRule)}) for which configuration\n     * settings should be displayed.\n     ",
    "links" : [ "android.app.NotificationManager#addAutomaticZenRule(AutomaticZenRule)", "#ACTION_AUTOMATIC_ZEN_RULE", "android.app.AutomaticZenRule" ]
  }, {
    "name" : "META_DATA_AUTOMATIC_RULE_TYPE",
    "type" : "String",
    "comment" : "\n     * A required {@code meta-data} tag for activities that handle\n     * {@link #ACTION_AUTOMATIC_ZEN_RULE}.\n     *\n     * This tag should contain a localized name of the type of the zen rule provided by the\n     * activity.\n     ",
    "links" : [ "#ACTION_AUTOMATIC_ZEN_RULE" ]
  }, {
    "name" : "META_DATA_RULE_INSTANCE_LIMIT",
    "type" : "String",
    "comment" : "\n     * An optional {@code meta-data} tag for activities that handle\n     * {@link #ACTION_AUTOMATIC_ZEN_RULE}.\n     *\n     * This tag should contain the maximum number of rule instances that\n     * can be created for this rule type. Omit or enter a value <= 0 to allow unlimited instances.\n     ",
    "links" : [ "#ACTION_AUTOMATIC_ZEN_RULE" ]
  }, {
    "name" : "VISIBILITY_NO_OVERRIDE",
    "type" : "int",
    "comment" : " Value signifying that the user has not expressed a per-app visibility override value.\n     * @hide ",
    "links" : [ ]
  }, {
    "name" : "IMPORTANCE_UNSPECIFIED",
    "type" : "int",
    "comment" : "\n     * Value signifying that the user has not expressed an importance.\n     *\n     * This value is for persisting preferences, and should never be associated with\n     * an actual notification.\n     ",
    "links" : [ ]
  }, {
    "name" : "IMPORTANCE_NONE",
    "type" : "int",
    "comment" : "\n     * A notification with no importance: does not show in the shade.\n     ",
    "links" : [ ]
  }, {
    "name" : "IMPORTANCE_MIN",
    "type" : "int",
    "comment" : "\n     * Min notification importance: only shows in the shade, below the fold.  This should\n     * not be used with {@link Service#startForeground(int, Notification) Service.startForeground}\n     * since a foreground service is supposed to be something the user cares about so it does\n     * not make semantic sense to mark its notification as minimum importance.  If you do this\n     * as of Android version {@link android.os.Build.VERSION_CODES#O}, the system will show\n     * a higher-priority notification about your app running in the background.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "android.annotation.SystemService#startForeground(int" ]
  }, {
    "name" : "IMPORTANCE_LOW",
    "type" : "int",
    "comment" : "\n     * Low notification importance: Shows in the shade, and potentially in the status bar\n     * (see {@link #shouldHideSilentStatusBarIcons()}), but is not audibly intrusive.\n     ",
    "links" : [ "#shouldHideSilentStatusBarIcons()" ]
  }, {
    "name" : "IMPORTANCE_DEFAULT",
    "type" : "int",
    "comment" : "\n     * Default notification importance: shows everywhere, makes noise, but does not visually\n     * intrude.\n     ",
    "links" : [ ]
  }, {
    "name" : "IMPORTANCE_HIGH",
    "type" : "int",
    "comment" : "\n     * Higher notification importance: shows everywhere, makes noise and peeks. May use full screen\n     * intents.\n     ",
    "links" : [ ]
  }, {
    "name" : "IMPORTANCE_MAX",
    "type" : "int",
    "comment" : "\n     * Unused.\n     ",
    "links" : [ ]
  }, {
    "name" : "BUBBLE_PREFERENCE_NONE",
    "type" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "BUBBLE_PREFERENCE_ALL",
    "type" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "BUBBLE_PREFERENCE_SELECTED",
    "type" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "sService",
    "type" : "INotificationManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static INotificationManager getService()",
    "returnType" : "INotificationManager",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static NotificationManager from(Context context)",
    "returnType" : "NotificationManager",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public void notify(int id, Notification notification)",
    "returnType" : "void",
    "comment" : "\n     * Post a notification to be shown in the status bar. If a notification with\n     * the same id has already been posted by your application and has not yet been canceled, it\n     * will be replaced by the updated information.\n     *\n     * @param id An identifier for this notification unique within your\n     *        application.\n     * @param notification A {@link Notification} object describing what to show the user. Must not\n     *        be null.\n     ",
    "links" : [ "android.service.notification.StatusBarNotification" ]
  }, {
    "name" : "public void notify(String tag, int id, Notification notification)",
    "returnType" : "void",
    "comment" : "\n     * Posts a notification to be shown in the status bar. If a notification with\n     * the same tag and id has already been posted by your application and has not yet been\n     * canceled, it will be replaced by the updated information.\n     *\n     * All {@link android.service.notification.NotificationListenerService listener services} will\n     * be granted {@link Intent#FLAG_GRANT_READ_URI_PERMISSION} access to any {@link Uri uris}\n     * provided on this notification or the\n     * {@link NotificationChannel} this notification is posted to using\n     * {@link Context#grantUriPermission(String, Uri, int)}. Permission will be revoked when the\n     * notification is canceled, or you can revoke permissions with\n     * {@link Context#revokeUriPermission(Uri, int)}.\n     *\n     * @param tag A string identifier for this notification.  May be {@code null}.\n     * @param id An identifier for this notification.  The pair (tag, id) must be unique\n     *        within your application.\n     * @param notification A {@link Notification} object describing what to\n     *        show the user. Must not be null.\n     ",
    "links" : [ "android.content.Context#revokeUriPermission(Uri", "android.service.notification.NotificationListenerService", "android.net.Uri", "android.app.NotificationChannel", "android.content.Intent#FLAG_GRANT_READ_URI_PERMISSION", "android.content.Context#grantUriPermission(String", "android.service.notification.StatusBarNotification" ]
  }, {
    "name" : "public void notifyAsPackage(@NonNull String targetPackage, @Nullable String tag, int id, @NonNull Notification notification)",
    "returnType" : "void",
    "comment" : "\n     * Posts a notification as a specified package to be shown in the status bar. If a notification\n     * with the same tag and id has already been posted for that package and has not yet been\n     * canceled, it will be replaced by the updated information.\n     *\n     * All {@link android.service.notification.NotificationListenerService listener services} will\n     * be granted {@link Intent#FLAG_GRANT_READ_URI_PERMISSION} access to any {@link Uri uris}\n     * provided on this notification or the\n     * {@link NotificationChannel} this notification is posted to using\n     * {@link Context#grantUriPermission(String, Uri, int)}. Permission will be revoked when the\n     * notification is canceled, or you can revoke permissions with\n     * {@link Context#revokeUriPermission(Uri, int)}.\n     *\n     * @param targetPackage The package to post the notification as. The package must have granted\n     *                      you access to post notifications on their behalf with\n     *                      {@link #setNotificationDelegate(String)}.\n     * @param tag A string identifier for this notification.  May be {@code null}.\n     * @param id An identifier for this notification.  The pair (tag, id) must be unique\n     *        within your application.\n     * @param notification A {@link Notification} object describing what to\n     *        show the user. Must not be null.\n     ",
    "links" : [ "#setNotificationDelegate(String)", "android.content.Context#revokeUriPermission(Uri", "android.service.notification.NotificationListenerService", "android.net.Uri", "android.app.NotificationChannel", "android.content.Intent#FLAG_GRANT_READ_URI_PERMISSION", "android.content.Context#grantUriPermission(String", "android.service.notification.StatusBarNotification" ]
  }, {
    "name" : "public void notifyAsUser(String tag, int id, Notification notification, UserHandle user)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private Notification fixNotification(Notification notification)",
    "returnType" : "Notification",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void fixLegacySmallIcon(Notification n, String pkg)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void cancel(int id)",
    "returnType" : "void",
    "comment" : "\n     * Cancels a previously posted notification.\n     *\n     *  <p>If the notification does not currently represent a\n     *  {@link Service#startForeground(int, Notification) foreground service}, it will be\n     *  removed from the UI and live\n     *  {@link android.service.notification.NotificationListenerService notification listeners}\n     *  will be informed so they can remove the notification from their UIs.</p>\n     ",
    "links" : [ "android.annotation.SystemService#startForeground(int", "android.service.notification.NotificationListenerService" ]
  }, {
    "name" : "public void cancel(@Nullable String tag, int id)",
    "returnType" : "void",
    "comment" : "\n     * Cancels a previously posted notification.\n     *\n     *  <p>If the notification does not currently represent a\n     *  {@link Service#startForeground(int, Notification) foreground service}, it will be\n     *  removed from the UI and live\n     *  {@link android.service.notification.NotificationListenerService notification listeners}\n     *  will be informed so they can remove the notification from their UIs.</p>\n     ",
    "links" : [ "android.annotation.SystemService#startForeground(int", "android.service.notification.NotificationListenerService" ]
  }, {
    "name" : "public void cancelAsPackage(@NonNull String targetPackage, @Nullable String tag, int id)",
    "returnType" : "void",
    "comment" : "\n     * Cancels a previously posted notification.\n     *\n     * <p>If the notification does not currently represent a\n     * {@link Service#startForeground(int, Notification) foreground service}, it will be\n     * removed from the UI and live\n     * {@link android.service.notification.NotificationListenerService notification listeners}\n     * will be informed so they can remove the notification from their UIs.</p>\n     *\n     * <p>This method may be used by {@link #getNotificationDelegate() a notification delegate} to\n     * cancel notifications that they have posted via {@link #notifyAsPackage(String, String, int,\n     * Notification)}.</p>\n     *\n     * @param targetPackage The package to cancel the notification as. If this package is not your\n     *                      package, you can only cancel notifications you posted with\n     *                      {@link #notifyAsPackage(String, String, int, Notification).\n     * @param tag A string identifier for this notification.  May be {@code null}.\n     * @param id An identifier for this notification.\n     ",
    "links" : [ "#notifyAsPackage(String", "android.annotation.SystemService#startForeground(int", "android.service.notification.NotificationListenerService", "#getNotificationDelegate()" ]
  }, {
    "name" : "public void cancelAsUser(String tag, int id, UserHandle user)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void cancelAll()",
    "returnType" : "void",
    "comment" : "\n     * Cancel all previously shown notifications. See {@link #cancel} for the\n     * detailed behavior.\n     ",
    "links" : [ "#cancel" ]
  }, {
    "name" : "public void setNotificationDelegate(@Nullable String delegate)",
    "returnType" : "void",
    "comment" : "\n     * Allows a package to post notifications on your behalf using\n     * {@link #notifyAsPackage(String, String, int, Notification)}.\n     *\n     * This can be used to allow persistent processes to post notifications based on messages\n     * received on your behalf from the cloud, without your process having to wake up.\n     *\n     * You can check if you have an allowed delegate with {@link #getNotificationDelegate()} and\n     * revoke your delegate by passing null to this method.\n     *\n     * @param delegate Package name of the app which can send notifications on your behalf.\n     ",
    "links" : [ "#notifyAsPackage(String", "#getNotificationDelegate()" ]
  }, {
    "name" : "public String getNotificationDelegate()",
    "returnType" : "String",
    "comment" : "\n     * Returns the {@link #setNotificationDelegate(String) delegate} that can post notifications on\n     * your behalf, if there currently is one.\n     ",
    "links" : [ "#setNotificationDelegate(String)" ]
  }, {
    "name" : "public boolean canNotifyAsPackage(@NonNull String pkg)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether you are allowed to post notifications on behalf of a given package, with\n     * {@link #notifyAsPackage(String, String, int, Notification)}.\n     *\n     * See {@link #setNotificationDelegate(String)}.\n     ",
    "links" : [ "#setNotificationDelegate(String)", "#notifyAsPackage(String" ]
  }, {
    "name" : "public void createNotificationChannelGroup(@NonNull NotificationChannelGroup group)",
    "returnType" : "void",
    "comment" : "\n     * Creates a group container for {@link NotificationChannel} objects.\n     *\n     * This can be used to rename an existing group.\n     * <p>\n     *     Group information is only used for presentation, not for behavior. Groups are optional\n     *     for channels, and you can have a mix of channels that belong to groups and channels\n     *     that do not.\n     * </p>\n     * <p>\n     *     For example, if your application supports multiple accounts, and those accounts will\n     *     have similar channels, you can create a group for each account with account specific\n     *     labels instead of appending account information to each channel's label.\n     * </p>\n     *\n     * @param group The group to create\n     ",
    "links" : [ "android.app.NotificationChannel" ]
  }, {
    "name" : "public void createNotificationChannelGroups(@NonNull List<NotificationChannelGroup> groups)",
    "returnType" : "void",
    "comment" : "\n     * Creates multiple notification channel groups.\n     *\n     * @param groups The list of groups to create\n     ",
    "links" : [ ]
  }, {
    "name" : "public void createNotificationChannel(@NonNull NotificationChannel channel)",
    "returnType" : "void",
    "comment" : "\n     * Creates a notification channel that notifications can be posted to.\n     *\n     * This can also be used to restore a deleted channel and to update an existing channel's\n     * name, description, group, and/or importance.\n     *\n     * <p>The name and description should only be changed if the locale changes\n     * or in response to the user renaming this channel. For example, if a user has a channel\n     * named 'John Doe' that represents messages from a 'John Doe', and 'John Doe' changes his name\n     * to 'John Smith,' the channel can be renamed to match.\n     *\n     * <p>The importance of an existing channel will only be changed if the new importance is lower\n     * than the current value and the user has not altered any settings on this channel.\n     *\n     * <p>The group an existing channel will only be changed if the channel does not already\n     * belong to a group.\n     *\n     * All other fields are ignored for channels that already exist.\n     *\n     * @param channel  the channel to create.  Note that the created channel may differ from this\n     *                 value. If the provided channel is malformed, a RemoteException will be\n     *                 thrown.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void createNotificationChannels(@NonNull List<NotificationChannel> channels)",
    "returnType" : "void",
    "comment" : "\n     * Creates multiple notification channels that different notifications can be posted to. See\n     * {@link #createNotificationChannel(NotificationChannel)}.\n     *\n     * @param channels the list of channels to attempt to create.\n     ",
    "links" : [ "#createNotificationChannel(NotificationChannel)" ]
  }, {
    "name" : "public NotificationChannel getNotificationChannel(String channelId)",
    "returnType" : "NotificationChannel",
    "comment" : "\n     * Returns the notification channel settings for a given channel id.\n     *\n     * <p>The channel must belong to your package, or to a package you are an approved notification\n     * delegate for (see {@link #canNotifyAsPackage(String)}), or it will not be returned. To query\n     * a channel as a notification delegate, call this method from a context created for that\n     * package (see {@link Context#createPackageContext(String, int)}).</p>\n     ",
    "links" : [ "#canNotifyAsPackage(String)", "android.content.Context#createPackageContext(String" ]
  }, {
    "name" : "public NotificationChannel getNotificationChannel(@NonNull String channelId, @NonNull String conversationId)",
    "returnType" : "NotificationChannel",
    "comment" : "\n     * Returns the notification channel settings for a given channel and\n     * {@link ShortcutInfo#getId() conversation id}.\n     *\n     * <p>The channel must belong to your package, or to a package you are an approved notification\n     * delegate for (see {@link #canNotifyAsPackage(String)}), or it will not be returned. To query\n     * a channel as a notification delegate, call this method from a context created for that\n     * package (see {@link Context#createPackageContext(String, int)}).</p>\n     ",
    "links" : [ "android.content.pm.ShortcutInfo#getId()", "#canNotifyAsPackage(String)", "android.content.Context#createPackageContext(String" ]
  }, {
    "name" : "public List<NotificationChannel> getNotificationChannels()",
    "returnType" : "List<NotificationChannel>",
    "comment" : "\n     * Returns all notification channels belonging to the calling package.\n     *\n     * <p>Approved notification delegates (see {@link #canNotifyAsPackage(String)}) can query\n     * notification channels belonging to packages they are the delegate for. To do so, call this\n     * method from a context created for that package (see\n     * {@link Context#createPackageContext(String, int)}).</p>\n     ",
    "links" : [ "#canNotifyAsPackage(String)", "android.content.Context#createPackageContext(String" ]
  }, {
    "name" : "public void deleteNotificationChannel(String channelId)",
    "returnType" : "void",
    "comment" : "\n     * Deletes the given notification channel.\n     *\n     * <p>If you {@link #createNotificationChannel(NotificationChannel) create} a new channel with\n     * this same id, the deleted channel will be un-deleted with all of the same settings it\n     * had before it was deleted.\n     ",
    "links" : [ "#createNotificationChannel(NotificationChannel)" ]
  }, {
    "name" : "public NotificationChannelGroup getNotificationChannelGroup(String channelGroupId)",
    "returnType" : "NotificationChannelGroup",
    "comment" : "\n     * Returns the notification channel group settings for a given channel group id.\n     *\n     * The channel group must belong to your package, or null will be returned.\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<NotificationChannelGroup> getNotificationChannelGroups()",
    "returnType" : "List<NotificationChannelGroup>",
    "comment" : "\n     * Returns all notification channel groups belonging to the calling app.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void deleteNotificationChannelGroup(String groupId)",
    "returnType" : "void",
    "comment" : "\n     * Deletes the given notification channel group, and all notification channels that\n     * belong to it.\n     ",
    "links" : [ ]
  }, {
    "name" : "public ComponentName getEffectsSuppressor()",
    "returnType" : "ComponentName",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean matchesCallFilter(Bundle extras)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isSystemConditionProviderEnabled(String path)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setZenMode(int mode, Uri conditionId, String reason)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getZenMode()",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public ZenModeConfig getZenModeConfig()",
    "returnType" : "ZenModeConfig",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public NotificationManager.Policy getConsolidatedNotificationPolicy()",
    "returnType" : "NotificationManager.Policy",
    "comment" : "\n     * Returns the currently applied notification policy.\n     *\n     * <p>\n     * If {@link #getCurrentInterruptionFilter} is equal to {@link #INTERRUPTION_FILTER_ALL},\n     * then the consolidated notification policy will match the default notification policy\n     * returned by {@link #getNotificationPolicy}.\n     * </p>\n     ",
    "links" : [ "#getCurrentInterruptionFilter", "#getNotificationPolicy", "#INTERRUPTION_FILTER_ALL" ]
  }, {
    "name" : "public int getRuleInstanceCount(ComponentName owner)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Map<String, AutomaticZenRule> getAutomaticZenRules()",
    "returnType" : "Map<String, AutomaticZenRule>",
    "comment" : "\n     * Returns AutomaticZenRules owned by the caller.\n     *\n     * <p>\n     * Throws a SecurityException if policy access is not granted to this package.\n     * See {@link #isNotificationPolicyAccessGranted}.\n     ",
    "links" : [ "#isNotificationPolicyAccessGranted" ]
  }, {
    "name" : "public AutomaticZenRule getAutomaticZenRule(String id)",
    "returnType" : "AutomaticZenRule",
    "comment" : "\n     * Returns the AutomaticZenRule with the given id, if it exists and the caller has access.\n     *\n     * <p>\n     * Throws a SecurityException if policy access is not granted to this package.\n     * See {@link #isNotificationPolicyAccessGranted}.\n     *\n     * <p>\n     * Returns null if there are no zen rules that match the given id, or if the calling package\n     * doesn't own the matching rule. See {@link AutomaticZenRule#getOwner}.\n     ",
    "links" : [ "android.app.AutomaticZenRule#getOwner", "#isNotificationPolicyAccessGranted" ]
  }, {
    "name" : "public String addAutomaticZenRule(AutomaticZenRule automaticZenRule)",
    "returnType" : "String",
    "comment" : "\n     * Creates the given zen rule.\n     *\n     * <p>\n     * Throws a SecurityException if policy access is not granted to this package.\n     * See {@link #isNotificationPolicyAccessGranted}.\n     *\n     * @param automaticZenRule the rule to create.\n     * @return The id of the newly created rule; null if the rule could not be created.\n     ",
    "links" : [ "#isNotificationPolicyAccessGranted" ]
  }, {
    "name" : "public boolean updateAutomaticZenRule(String id, AutomaticZenRule automaticZenRule)",
    "returnType" : "boolean",
    "comment" : "\n     * Updates the given zen rule.\n     *\n     * <p>\n     * Throws a SecurityException if policy access is not granted to this package.\n     * See {@link #isNotificationPolicyAccessGranted}.\n     *\n     * <p>\n     * Callers can only update rules that they own. See {@link AutomaticZenRule#getOwner}.\n     * @param id The id of the rule to update\n     * @param automaticZenRule the rule to update.\n     * @return Whether the rule was successfully updated.\n     ",
    "links" : [ "android.app.AutomaticZenRule#getOwner", "#isNotificationPolicyAccessGranted" ]
  }, {
    "name" : "public void setAutomaticZenRuleState(@NonNull String id, @NonNull Condition condition)",
    "returnType" : "void",
    "comment" : "\n     * Informs the notification manager that the state of an {@link AutomaticZenRule} has changed.\n     * Use this method to put the system into Do Not Disturb mode or request that it exits Do Not\n     * Disturb mode. The calling app must own the provided {@link android.app.AutomaticZenRule}.\n     * <p>\n     *     This method can be used in conjunction with or as a replacement to\n     *     {@link android.service.notification.ConditionProviderService#notifyCondition(Condition)}.\n     * </p>\n     * @param id The id of the rule whose state should change\n     * @param condition The new state of this rule\n     ",
    "links" : [ "android.service.notification.ConditionProviderService#notifyCondition(Condition)", "android.app.AutomaticZenRule" ]
  }, {
    "name" : "public boolean removeAutomaticZenRule(String id)",
    "returnType" : "boolean",
    "comment" : "\n     * Deletes the automatic zen rule with the given id.\n     *\n     * <p>\n     * Throws a SecurityException if policy access is not granted to this package.\n     * See {@link #isNotificationPolicyAccessGranted}.\n     *\n     * <p>\n     * Callers can only delete rules that they own. See {@link AutomaticZenRule#getOwner}.\n     * @param id the id of the rule to delete.\n     * @return Whether the rule was successfully deleted.\n     ",
    "links" : [ "android.app.AutomaticZenRule#getOwner", "#isNotificationPolicyAccessGranted" ]
  }, {
    "name" : "public boolean removeAutomaticZenRules(String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Deletes all automatic zen rules owned by the given package.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getImportance()",
    "returnType" : "int",
    "comment" : "\n     * Returns the user specified importance for notifications from the calling\n     * package.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean areNotificationsEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether notifications from the calling package are blocked.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean areBubblesAllowed()",
    "returnType" : "boolean",
    "comment" : "\n     * Gets whether all notifications posted by this app can appear outside of the\n     * notification shade, floating over other apps' content.\n     *\n     * <p>This value will be ignored for notifications that are posted to channels that do not\n     * allow bubbles ({@link NotificationChannel#canBubble()}.\n     *\n     * @see Notification#getBubbleMetadata()\n     ",
    "links" : [ "android.app.NotificationChannel#canBubble()" ]
  }, {
    "name" : "public void silenceNotificationSound()",
    "returnType" : "void",
    "comment" : "\n     * Silences the current notification sound, if ones currently playing.\n     * <p>\n     * It is intended to handle use-cases such as silencing a ringing call\n     * when the user presses the volume button during ringing.\n     * <p>\n     * If this method is called prior to when the notification begins playing, the sound will not be\n     * silenced.  As such it is not intended as a means to avoid playing of a sound.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean areNotificationsPaused()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether notifications from this package are temporarily hidden. This\n     * could be done because the package was marked as distracting to the user via\n     * {@code PackageManager#setDistractingPackageRestrictions(String[], int)} or because the\n     * package is {@code PackageManager#setPackagesSuspended(String[], boolean, PersistableBundle,\n     * PersistableBundle, SuspendDialogInfo) suspended}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isNotificationPolicyAccessGranted()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks the ability to modify notification do not disturb policy for the calling package.\n     *\n     * <p>\n     * Returns true if the calling package can modify notification policy.\n     *\n     * <p>\n     * Apps can request policy access by sending the user to the activity that matches the system\n     * intent action {@link android.provider.Settings#ACTION_NOTIFICATION_POLICY_ACCESS_SETTINGS}.\n     *\n     * <p>\n     * Use {@link #ACTION_NOTIFICATION_POLICY_ACCESS_GRANTED_CHANGED} to listen for\n     * user grant or denial of this access.\n     ",
    "links" : [ "android.provider.Settings#ACTION_NOTIFICATION_POLICY_ACCESS_SETTINGS", "#ACTION_NOTIFICATION_POLICY_ACCESS_GRANTED_CHANGED" ]
  }, {
    "name" : "public boolean isNotificationListenerAccessGranted(ComponentName listener)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether the user has approved a given\n     * {@link android.service.notification.NotificationListenerService}.\n     *\n     * <p>\n     * The listener service must belong to the calling app.\n     *\n     * <p>\n     * Apps can request notification listener access by sending the user to the activity that\n     * matches the system intent action\n     * {@link android.provider.Settings#ACTION_NOTIFICATION_LISTENER_SETTINGS}.\n     ",
    "links" : [ "android.service.notification.NotificationListenerService", "android.provider.Settings#ACTION_NOTIFICATION_LISTENER_SETTINGS" ]
  }, {
    "name" : "public boolean isNotificationAssistantAccessGranted(@NonNull ComponentName assistant)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether the user has approved a given\n     * {@link android.service.notification.NotificationAssistantService}.\n     *\n     * <p>\n     * The assistant service must belong to the calling app.\n     *\n     * <p>\n     * Apps can request notification assistant access by sending the user to the activity that\n     * matches the system intent action\n     * TODO: STOPSHIP: Add correct intent\n     * {@link android.provider.Settings#ACTION_MANAGE_DEFAULT_APPS_SETTINGS}.\n     * @hide\n     ",
    "links" : [ "android.provider.Settings#ACTION_MANAGE_DEFAULT_APPS_SETTINGS", "android.service.notification.NotificationAssistantService" ]
  }, {
    "name" : "public boolean shouldHideSilentStatusBarIcons()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the user wants silent notifications (see {@link #IMPORTANCE_LOW} to appear\n     * in the status bar.\n     *\n     * <p>Only available for {@link #isNotificationListenerAccessGranted(ComponentName) notification\n     * listeners}.\n     ",
    "links" : [ "#IMPORTANCE_LOW", "#isNotificationListenerAccessGranted(ComponentName)" ]
  }, {
    "name" : "public List<String> getAllowedAssistantAdjustments()",
    "returnType" : "List<String>",
    "comment" : "\n     * Returns the list of {@link android.service.notification.Adjustment adjustment keys} that can\n     * be modified by the current {@link android.service.notification.NotificationAssistantService}.\n     *\n     * <p>Only callable by the current\n     * {@link android.service.notification.NotificationAssistantService}.\n     * See {@link #isNotificationAssistantAccessGranted(ComponentName)}</p>\n     * @hide\n     ",
    "links" : [ "android.service.notification.Adjustment", "android.service.notification.NotificationAssistantService", "#isNotificationAssistantAccessGranted(ComponentName)" ]
  }, {
    "name" : "public void allowAssistantAdjustment(String capability)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void disallowAssistantAdjustment(String capability)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isNotificationPolicyAccessGrantedForPackage(String pkg)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public List<String> getEnabledNotificationListenerPackages()",
    "returnType" : "List<String>",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Policy getNotificationPolicy()",
    "returnType" : "Policy",
    "comment" : "\n     * Gets the current user-specified default notification policy.\n     *\n     * <p>\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setNotificationPolicy(@NonNull Policy policy)",
    "returnType" : "void",
    "comment" : "\n     * Sets the current notification policy.\n     *\n     * <p>\n     * Only available if policy access is granted to this package.\n     * See {@link #isNotificationPolicyAccessGranted}.\n     *\n     * @param policy The new desired policy.\n     ",
    "links" : [ "#isNotificationPolicyAccessGranted" ]
  }, {
    "name" : "public void setNotificationPolicyAccessGranted(String pkg, boolean granted)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void setNotificationListenerAccessGranted(ComponentName listener, boolean granted)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void setNotificationListenerAccessGrantedForUser(ComponentName listener, int userId, boolean granted)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void setNotificationAssistantAccessGranted(@Nullable ComponentName assistant, boolean granted)",
    "returnType" : "void",
    "comment" : "\n     * Grants/revokes Notification Assistant access to {@code assistant} for current user.\n     * To grant access for a particular user, obtain this service by using the {@link Context}\n     * provided by {@link Context#createPackageContextAsUser}\n     *\n     * @param assistant Name of component to grant/revoke access or {@code null} to revoke access to\n     *                  current assistant\n     * @param granted Grant/revoke access\n     * @hide\n     ",
    "links" : [ "android.content.Context", "android.content.Context#createPackageContextAsUser" ]
  }, {
    "name" : "public List<ComponentName> getEnabledNotificationListeners(int userId)",
    "returnType" : "List<ComponentName>",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public ComponentName getAllowedNotificationAssistant()",
    "returnType" : "ComponentName",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private static void checkRequired(String name, Object value)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public StatusBarNotification[] getActiveNotifications()",
    "returnType" : "StatusBarNotification[]",
    "comment" : "\n     * Recover a list of active notifications: ones that have been posted by the calling app that\n     * have not yet been dismissed by the user or {@link #cancel(String, int)}ed by the app.\n     *\n     * <p><Each notification is embedded in a {@link StatusBarNotification} object, including the\n     * original <code>tag</code> and <code>id</code> supplied to\n     * {@link #notify(String, int, Notification) notify()}\n     * (via {@link StatusBarNotification#getTag() getTag()} and\n     * {@link StatusBarNotification#getId() getId()}) as well as a copy of the original\n     * {@link Notification} object (via {@link StatusBarNotification#getNotification()}).\n     * </p>\n     * <p>From {@link Build.VERSION_CODES#Q}, will also return notifications you've posted as an\n     * app's notification delegate via\n     * {@link NotificationManager#notifyAsPackage(String, String, int, Notification)}.\n     * </p>\n     *\n     * @return An array of {@link StatusBarNotification}.\n     ",
    "links" : [ "#notify(String", "android.service.notification.StatusBarNotification#getId()", "Build.VERSION_CODES#Q", "#cancel(String", "android.app.NotificationManager#notifyAsPackage(String", "android.service.notification.StatusBarNotification#getNotification()", "android.service.notification.StatusBarNotification#getTag()", "android.service.notification.StatusBarNotification" ]
  }, {
    "name" : "public final int getCurrentInterruptionFilter()",
    "returnType" : "int",
    "comment" : "\n     * Gets the current notification interruption filter.\n     * <p>\n     * The interruption filter defines which notifications are allowed to\n     * interrupt the user (e.g. via sound &amp; vibration) and is applied\n     * globally.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void setInterruptionFilter(@InterruptionFilter int interruptionFilter)",
    "returnType" : "void",
    "comment" : "\n     * Sets the current notification interruption filter.\n     * <p>\n     * The interruption filter defines which notifications are allowed to\n     * interrupt the user (e.g. via sound &amp; vibration) and is applied\n     * globally.\n     * <p>\n     * Only available if policy access is granted to this package. See\n     * {@link #isNotificationPolicyAccessGranted}.\n     ",
    "links" : [ "#isNotificationPolicyAccessGranted" ]
  }, {
    "name" : "public static int zenModeToInterruptionFilter(int zen)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static int zenModeFromInterruptionFilter(int interruptionFilter, int defValue)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "localLOGV", "ACTION_APP_BLOCK_STATE_CHANGED", "ACTION_NOTIFICATION_CHANNEL_BLOCK_STATE_CHANGED", "EXTRA_NOTIFICATION_CHANNEL_ID", "EXTRA_NOTIFICATION_CHANNEL_GROUP_ID", "EXTRA_BLOCKED_STATE", "ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED", "ACTION_AUTOMATIC_ZEN_RULE_STATUS_CHANGED", "EXTRA_AUTOMATIC_ZEN_RULE_STATUS", "EXTRA_AUTOMATIC_ZEN_RULE_ID", "AUTOMATIC_RULE_STATUS_UNKNOWN", "AUTOMATIC_RULE_STATUS_ENABLED", "AUTOMATIC_RULE_STATUS_DISABLED", "AUTOMATIC_RULE_STATUS_REMOVED", "ACTION_EFFECTS_SUPPRESSOR_CHANGED", "ACTION_NOTIFICATION_POLICY_ACCESS_GRANTED_CHANGED", "ACTION_NOTIFICATION_POLICY_CHANGED", "ACTION_INTERRUPTION_FILTER_CHANGED", "ACTION_INTERRUPTION_FILTER_CHANGED_INTERNAL", "INTERRUPTION_FILTER_ALL", "INTERRUPTION_FILTER_PRIORITY", "INTERRUPTION_FILTER_NONE", "INTERRUPTION_FILTER_ALARMS", "INTERRUPTION_FILTER_UNKNOWN", "ACTION_AUTOMATIC_ZEN_RULE", "EXTRA_AUTOMATIC_RULE_ID", "META_DATA_AUTOMATIC_RULE_TYPE", "META_DATA_RULE_INSTANCE_LIMIT", "VISIBILITY_NO_OVERRIDE", "IMPORTANCE_UNSPECIFIED", "IMPORTANCE_NONE", "IMPORTANCE_MIN", "IMPORTANCE_LOW", "IMPORTANCE_DEFAULT", "IMPORTANCE_HIGH", "IMPORTANCE_MAX", "BUBBLE_PREFERENCE_NONE", "BUBBLE_PREFERENCE_ALL", "BUBBLE_PREFERENCE_SELECTED", "sService", "mContext" ],
  "methodNames" : [ "public static INotificationManager getService()", "public static NotificationManager from(Context context)", "public void notify(int id, Notification notification)", "public void notify(String tag, int id, Notification notification)", "public void notifyAsPackage(@NonNull String targetPackage, @Nullable String tag, int id, @NonNull Notification notification)", "public void notifyAsUser(String tag, int id, Notification notification, UserHandle user)", "private Notification fixNotification(Notification notification)", "private void fixLegacySmallIcon(Notification n, String pkg)", "public void cancel(int id)", "public void cancel(@Nullable String tag, int id)", "public void cancelAsPackage(@NonNull String targetPackage, @Nullable String tag, int id)", "public void cancelAsUser(String tag, int id, UserHandle user)", "public void cancelAll()", "public void setNotificationDelegate(@Nullable String delegate)", "public String getNotificationDelegate()", "public boolean canNotifyAsPackage(@NonNull String pkg)", "public void createNotificationChannelGroup(@NonNull NotificationChannelGroup group)", "public void createNotificationChannelGroups(@NonNull List<NotificationChannelGroup> groups)", "public void createNotificationChannel(@NonNull NotificationChannel channel)", "public void createNotificationChannels(@NonNull List<NotificationChannel> channels)", "public NotificationChannel getNotificationChannel(String channelId)", "public NotificationChannel getNotificationChannel(@NonNull String channelId, @NonNull String conversationId)", "public List<NotificationChannel> getNotificationChannels()", "public void deleteNotificationChannel(String channelId)", "public NotificationChannelGroup getNotificationChannelGroup(String channelGroupId)", "public List<NotificationChannelGroup> getNotificationChannelGroups()", "public void deleteNotificationChannelGroup(String groupId)", "public ComponentName getEffectsSuppressor()", "public boolean matchesCallFilter(Bundle extras)", "public boolean isSystemConditionProviderEnabled(String path)", "public void setZenMode(int mode, Uri conditionId, String reason)", "public int getZenMode()", "public ZenModeConfig getZenModeConfig()", "public NotificationManager.Policy getConsolidatedNotificationPolicy()", "public int getRuleInstanceCount(ComponentName owner)", "public Map<String, AutomaticZenRule> getAutomaticZenRules()", "public AutomaticZenRule getAutomaticZenRule(String id)", "public String addAutomaticZenRule(AutomaticZenRule automaticZenRule)", "public boolean updateAutomaticZenRule(String id, AutomaticZenRule automaticZenRule)", "public void setAutomaticZenRuleState(@NonNull String id, @NonNull Condition condition)", "public boolean removeAutomaticZenRule(String id)", "public boolean removeAutomaticZenRules(String packageName)", "public int getImportance()", "public boolean areNotificationsEnabled()", "public boolean areBubblesAllowed()", "public void silenceNotificationSound()", "public boolean areNotificationsPaused()", "public boolean isNotificationPolicyAccessGranted()", "public boolean isNotificationListenerAccessGranted(ComponentName listener)", "public boolean isNotificationAssistantAccessGranted(@NonNull ComponentName assistant)", "public boolean shouldHideSilentStatusBarIcons()", "public List<String> getAllowedAssistantAdjustments()", "public void allowAssistantAdjustment(String capability)", "public void disallowAssistantAdjustment(String capability)", "public boolean isNotificationPolicyAccessGrantedForPackage(String pkg)", "public List<String> getEnabledNotificationListenerPackages()", "public Policy getNotificationPolicy()", "public void setNotificationPolicy(@NonNull Policy policy)", "public void setNotificationPolicyAccessGranted(String pkg, boolean granted)", "public void setNotificationListenerAccessGranted(ComponentName listener, boolean granted)", "public void setNotificationListenerAccessGrantedForUser(ComponentName listener, int userId, boolean granted)", "public void setNotificationAssistantAccessGranted(@Nullable ComponentName assistant, boolean granted)", "public List<ComponentName> getEnabledNotificationListeners(int userId)", "public ComponentName getAllowedNotificationAssistant()", "private static void checkRequired(String name, Object value)", "public StatusBarNotification[] getActiveNotifications()", "public final int getCurrentInterruptionFilter()", "public final void setInterruptionFilter(@InterruptionFilter int interruptionFilter)", "public static int zenModeToInterruptionFilter(int zen)", "public static int zenModeFromInterruptionFilter(int interruptionFilter, int defValue)" ]
}