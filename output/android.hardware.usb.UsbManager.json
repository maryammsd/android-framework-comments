{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/hardware/usb/UsbManager.java",
  "packageName" : "android.hardware.usb",
  "className" : "UsbManager",
  "comment" : "\n * This class allows you to access the state of USB and communicate with USB devices.\n * Currently only host mode is supported in the public API.\n *\n * <div class=\"special reference\">\n * <h3>Developer Guides</h3>\n * <p>For more information about communicating with USB hardware, read the\n * <a href=\"{@docRoot}guide/topics/connectivity/usb/index.html\">USB developer guide</a>.</p>\n * </div>\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_USB_STATE",
    "type" : "String",
    "comment" : "\n     * Broadcast Action:  A sticky broadcast for USB state change events when in device mode.\n     *\n     * This is a sticky broadcast for clients that includes USB connected/disconnected state,\n     * <ul>\n     * <li> {@link #USB_CONNECTED} boolean indicating whether USB is connected or disconnected.\n     * <li> {@link #USB_HOST_CONNECTED} boolean indicating whether USB is connected or\n     *     disconnected as host.\n     * <li> {@link #USB_CONFIGURED} boolean indicating whether USB is configured.\n     * currently zero if not configured, one for configured.\n     * <li> {@link #USB_FUNCTION_ADB} boolean extra indicating whether the\n     * adb function is enabled\n     * <li> {@link #USB_FUNCTION_RNDIS} boolean extra indicating whether the\n     * RNDIS ethernet function is enabled\n     * <li> {@link #USB_FUNCTION_MTP} boolean extra indicating whether the\n     * MTP function is enabled\n     * <li> {@link #USB_FUNCTION_PTP} boolean extra indicating whether the\n     * PTP function is enabled\n     * <li> {@link #USB_FUNCTION_ACCESSORY} boolean extra indicating whether the\n     * accessory function is enabled\n     * <li> {@link #USB_FUNCTION_AUDIO_SOURCE} boolean extra indicating whether the\n     * audio source function is enabled\n     * <li> {@link #USB_FUNCTION_MIDI} boolean extra indicating whether the\n     * MIDI function is enabled\n     * </ul>\n     * If the sticky intent has not been found, that indicates USB is disconnected,\n     * USB is not configued, MTP function is enabled, and all the other functions are disabled.\n     *\n     * {@hide}\n     ",
    "links" : [ "#USB_FUNCTION_ADB", "#USB_FUNCTION_RNDIS", "#USB_FUNCTION_MIDI", "#USB_FUNCTION_MTP", "#USB_FUNCTION_PTP", "#USB_FUNCTION_ACCESSORY", "#USB_HOST_CONNECTED", "#USB_FUNCTION_AUDIO_SOURCE", "#USB_CONNECTED", "#USB_CONFIGURED" ]
  }, {
    "name" : "ACTION_USB_PORT_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: A broadcast for USB port changes.\n     *\n     * This intent is sent when a USB port is added, removed, or changes state.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_USB_DEVICE_ATTACHED",
    "type" : "String",
    "comment" : "\n     * Activity intent sent when user attaches a USB device.\n     *\n     * This intent is sent when a USB device is attached to the USB bus when in host mode.\n     * <ul>\n     * <li> {@link #EXTRA_DEVICE} containing the {@link android.hardware.usb.UsbDevice}\n     * for the attached device\n     * </ul>\n     ",
    "links" : [ "#EXTRA_DEVICE", "android.hardware.usb.UsbDevice" ]
  }, {
    "name" : "ACTION_USB_DEVICE_DETACHED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action:  A broadcast for USB device detached event.\n     *\n     * This intent is sent when a USB device is detached from the USB bus when in host mode.\n     * <ul>\n     * <li> {@link #EXTRA_DEVICE} containing the {@link android.hardware.usb.UsbDevice}\n     * for the detached device\n     * </ul>\n     ",
    "links" : [ "#EXTRA_DEVICE", "android.hardware.usb.UsbDevice" ]
  }, {
    "name" : "ACTION_USB_ACCESSORY_ATTACHED",
    "type" : "String",
    "comment" : "\n     * Activity intent sent when user attaches a USB accessory.\n     *\n     * <ul>\n     * <li> {@link #EXTRA_ACCESSORY} containing the {@link android.hardware.usb.UsbAccessory}\n     * for the attached accessory\n     * </ul>\n     ",
    "links" : [ "#EXTRA_ACCESSORY", "android.hardware.usb.UsbAccessory" ]
  }, {
    "name" : "ACTION_USB_ACCESSORY_DETACHED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action:  A broadcast for USB accessory detached event.\n     *\n     * This intent is sent when a USB accessory is detached.\n     * <ul>\n     * <li> {@link #EXTRA_ACCESSORY} containing the {@link UsbAccessory}\n     * for the attached accessory that was detached\n     * </ul>\n     ",
    "links" : [ "#EXTRA_ACCESSORY", "android.hardware.usb.UsbAccessory" ]
  }, {
    "name" : "USB_CONNECTED",
    "type" : "String",
    "comment" : "\n     * Boolean extra indicating whether USB is connected or disconnected.\n     * Used in extras for the {@link #ACTION_USB_STATE} broadcast.\n     *\n     * {@hide}\n     ",
    "links" : [ "#ACTION_USB_STATE" ]
  }, {
    "name" : "USB_HOST_CONNECTED",
    "type" : "String",
    "comment" : "\n     * Boolean extra indicating whether USB is connected or disconnected as host.\n     * Used in extras for the {@link #ACTION_USB_STATE} broadcast.\n     *\n     * {@hide}\n     ",
    "links" : [ "#ACTION_USB_STATE" ]
  }, {
    "name" : "USB_CONFIGURED",
    "type" : "String",
    "comment" : "\n     * Boolean extra indicating whether USB is configured.\n     * Used in extras for the {@link #ACTION_USB_STATE} broadcast.\n     *\n     * {@hide}\n     ",
    "links" : [ "#ACTION_USB_STATE" ]
  }, {
    "name" : "USB_DATA_UNLOCKED",
    "type" : "String",
    "comment" : "\n     * Boolean extra indicating whether confidential user data, such as photos, should be\n     * made available on the USB connection. This variable will only be set when the user\n     * has explicitly asked for this data to be unlocked.\n     * Used in extras for the {@link #ACTION_USB_STATE} broadcast.\n     *\n     * {@hide}\n     ",
    "links" : [ "#ACTION_USB_STATE" ]
  }, {
    "name" : "USB_FUNCTION_NONE",
    "type" : "String",
    "comment" : "\n     * A placeholder indicating that no USB function is being specified.\n     * Used for compatibility with old init scripts to indicate no functions vs. charging function.\n     *\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "USB_FUNCTION_ADB",
    "type" : "String",
    "comment" : "\n     * Name of the adb USB function.\n     * Used in extras for the {@link #ACTION_USB_STATE} broadcast\n     *\n     * {@hide}\n     ",
    "links" : [ "#ACTION_USB_STATE" ]
  }, {
    "name" : "USB_FUNCTION_RNDIS",
    "type" : "String",
    "comment" : "\n     * Name of the RNDIS ethernet USB function.\n     * Used in extras for the {@link #ACTION_USB_STATE} broadcast\n     *\n     * {@hide}\n     ",
    "links" : [ "#ACTION_USB_STATE" ]
  }, {
    "name" : "USB_FUNCTION_MTP",
    "type" : "String",
    "comment" : "\n     * Name of the MTP USB function.\n     * Used in extras for the {@link #ACTION_USB_STATE} broadcast\n     *\n     * {@hide}\n     ",
    "links" : [ "#ACTION_USB_STATE" ]
  }, {
    "name" : "USB_FUNCTION_PTP",
    "type" : "String",
    "comment" : "\n     * Name of the PTP USB function.\n     * Used in extras for the {@link #ACTION_USB_STATE} broadcast\n     *\n     * {@hide}\n     ",
    "links" : [ "#ACTION_USB_STATE" ]
  }, {
    "name" : "USB_FUNCTION_AUDIO_SOURCE",
    "type" : "String",
    "comment" : "\n     * Name of the audio source USB function.\n     * Used in extras for the {@link #ACTION_USB_STATE} broadcast\n     *\n     * {@hide}\n     ",
    "links" : [ "#ACTION_USB_STATE" ]
  }, {
    "name" : "USB_FUNCTION_MIDI",
    "type" : "String",
    "comment" : "\n     * Name of the MIDI USB function.\n     * Used in extras for the {@link #ACTION_USB_STATE} broadcast\n     *\n     * {@hide}\n     ",
    "links" : [ "#ACTION_USB_STATE" ]
  }, {
    "name" : "USB_FUNCTION_ACCESSORY",
    "type" : "String",
    "comment" : "\n     * Name of the Accessory USB function.\n     * Used in extras for the {@link #ACTION_USB_STATE} broadcast\n     *\n     * {@hide}\n     ",
    "links" : [ "#ACTION_USB_STATE" ]
  }, {
    "name" : "USB_FUNCTION_NCM",
    "type" : "String",
    "comment" : "\n     * Name of the NCM USB function.\n     * Used in extras for the {@link #ACTION_USB_STATE} broadcast\n     *\n     * {@hide}\n     ",
    "links" : [ "#ACTION_USB_STATE" ]
  }, {
    "name" : "EXTRA_PORT",
    "type" : "String",
    "comment" : "\n     * Name of extra for {@link #ACTION_USB_PORT_CHANGED}\n     * containing the {@link UsbPort} object for the port.\n     *\n     * @hide\n     ",
    "links" : [ "android.hardware.usb.UsbPort", "#ACTION_USB_PORT_CHANGED" ]
  }, {
    "name" : "EXTRA_PORT_STATUS",
    "type" : "String",
    "comment" : "\n     * Name of extra for {@link #ACTION_USB_PORT_CHANGED}\n     * containing the {@link UsbPortStatus} object for the port, or null if the port\n     * was removed.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_USB_PORT_CHANGED", "android.hardware.usb.UsbPortStatus" ]
  }, {
    "name" : "EXTRA_DEVICE",
    "type" : "String",
    "comment" : "\n     * Name of extra for {@link #ACTION_USB_DEVICE_ATTACHED} and\n     * {@link #ACTION_USB_DEVICE_DETACHED} broadcasts\n     * containing the {@link UsbDevice} object for the device.\n     ",
    "links" : [ "#ACTION_USB_DEVICE_DETACHED", "#ACTION_USB_DEVICE_ATTACHED", "android.hardware.usb.UsbDevice" ]
  }, {
    "name" : "EXTRA_ACCESSORY",
    "type" : "String",
    "comment" : "\n     * Name of extra for {@link #ACTION_USB_ACCESSORY_ATTACHED} and\n     * {@link #ACTION_USB_ACCESSORY_DETACHED} broadcasts\n     * containing the {@link UsbAccessory} object for the accessory.\n     ",
    "links" : [ "#ACTION_USB_ACCESSORY_DETACHED", "android.hardware.usb.UsbAccessory", "#ACTION_USB_ACCESSORY_ATTACHED" ]
  }, {
    "name" : "EXTRA_PERMISSION_GRANTED",
    "type" : "String",
    "comment" : "\n     * Name of extra added to the {@link android.app.PendingIntent}\n     * passed into {@link #requestPermission(UsbDevice, PendingIntent)}\n     * or {@link #requestPermission(UsbAccessory, PendingIntent)}\n     * containing a boolean value indicating whether the user granted permission or not.\n     ",
    "links" : [ "#requestPermission(UsbAccessory", "#requestPermission(UsbDevice", "android.app.PendingIntent" ]
  }, {
    "name" : "EXTRA_PACKAGE",
    "type" : "String",
    "comment" : "\n     * Name of extra added to start systemui.usb.UsbPermissionActivity\n     * containing package name of the app which requests USB permission.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_CAN_BE_DEFAULT",
    "type" : "String",
    "comment" : "\n     * Name of extra added to start systemui.usb.UsbPermissionActivity\n     * containing the whether the app which requests USB permission can be set as default handler\n     * for USB device attach event or USB accessory attach event or not.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FUNCTION_NONE",
    "type" : "long",
    "comment" : "\n     * Code for the charging usb function. Passed into {@link #setCurrentFunctions(long)}\n     * {@hide}\n     ",
    "links" : [ "#setCurrentFunctions(long)" ]
  }, {
    "name" : "FUNCTION_MTP",
    "type" : "long",
    "comment" : "\n     * Code for the mtp usb function. Passed as a mask into {@link #setCurrentFunctions(long)}\n     * {@hide}\n     ",
    "links" : [ "#setCurrentFunctions(long)" ]
  }, {
    "name" : "FUNCTION_PTP",
    "type" : "long",
    "comment" : "\n     * Code for the ptp usb function. Passed as a mask into {@link #setCurrentFunctions(long)}\n     * {@hide}\n     ",
    "links" : [ "#setCurrentFunctions(long)" ]
  }, {
    "name" : "FUNCTION_RNDIS",
    "type" : "long",
    "comment" : "\n     * Code for the rndis usb function. Passed as a mask into {@link #setCurrentFunctions(long)}\n     * {@hide}\n     ",
    "links" : [ "#setCurrentFunctions(long)" ]
  }, {
    "name" : "FUNCTION_MIDI",
    "type" : "long",
    "comment" : "\n     * Code for the midi usb function. Passed as a mask into {@link #setCurrentFunctions(long)}\n     * {@hide}\n     ",
    "links" : [ "#setCurrentFunctions(long)" ]
  }, {
    "name" : "FUNCTION_ACCESSORY",
    "type" : "long",
    "comment" : "\n     * Code for the accessory usb function.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "FUNCTION_AUDIO_SOURCE",
    "type" : "long",
    "comment" : "\n     * Code for the audio source usb function.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "FUNCTION_ADB",
    "type" : "long",
    "comment" : "\n     * Code for the adb usb function.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "FUNCTION_NCM",
    "type" : "long",
    "comment" : "\n     * Code for the ncm source usb function.\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "SETTABLE_FUNCTIONS",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "FUNCTION_NAME_TO_CODE",
    "type" : "Map<String, Long>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mService",
    "type" : "IUsbManager",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public HashMap<String, UsbDevice> getDeviceList()",
    "returnType" : "HashMap<String, UsbDevice>",
    "comment" : "\n     * Returns a HashMap containing all USB devices currently attached.\n     * USB device name is the key for the returned HashMap.\n     * The result will be empty if no devices are attached, or if\n     * USB host mode is inactive or unsupported.\n     *\n     * @return HashMap containing all connected USB devices.\n     ",
    "links" : [ ]
  }, {
    "name" : "public UsbDeviceConnection openDevice(UsbDevice device)",
    "returnType" : "UsbDeviceConnection",
    "comment" : "\n     * Opens the device so it can be used to send and receive\n     * data using {@link android.hardware.usb.UsbRequest}.\n     *\n     * @param device the device to open\n     * @return a {@link UsbDeviceConnection}, or {@code null} if open failed\n     ",
    "links" : [ "android.hardware.usb.UsbRequest", "android.hardware.usb.UsbDeviceConnection" ]
  }, {
    "name" : "public UsbAccessory[] getAccessoryList()",
    "returnType" : "UsbAccessory[]",
    "comment" : "\n     * Returns a list of currently attached USB accessories.\n     * (in the current implementation there can be at most one)\n     *\n     * @return list of USB accessories, or null if none are attached.\n     ",
    "links" : [ ]
  }, {
    "name" : "public ParcelFileDescriptor openAccessory(UsbAccessory accessory)",
    "returnType" : "ParcelFileDescriptor",
    "comment" : "\n     * Opens a file descriptor for reading and writing data to the USB accessory.\n     *\n     * <p>If data is read from the {@link java.io.InputStream} created from this file descriptor all\n     * data of a USB transfer should be read at once. If only a partial request is read the rest of\n     * the transfer is dropped.\n     *\n     * @param accessory the USB accessory to open\n     * @return file descriptor, or null if the accessory could not be opened.\n     ",
    "links" : [ "java.io.InputStream" ]
  }, {
    "name" : "public ParcelFileDescriptor getControlFd(long function)",
    "returnType" : "ParcelFileDescriptor",
    "comment" : "\n     * Gets the functionfs control file descriptor for the given function, with\n     * the usb descriptors and strings already written. The file descriptor is used\n     * by the function implementation to handle events and control requests.\n     *\n     * @param function to get control fd for. Currently {@link #FUNCTION_MTP} and\n     * {@link #FUNCTION_PTP} are supported.\n     * @return A ParcelFileDescriptor holding the valid fd, or null if the fd was not found.\n     *\n     * {@hide}\n     ",
    "links" : [ "#FUNCTION_MTP", "#FUNCTION_PTP" ]
  }, {
    "name" : "public boolean hasPermission(UsbDevice device)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the caller has permission to access the device.\n     * Permission might have been granted temporarily via\n     * {@link #requestPermission(UsbDevice, PendingIntent)} or\n     * by the user choosing the caller as the default application for the device.\n     * Permission for USB devices of class {@link UsbConstants#USB_CLASS_VIDEO} for clients that\n     * target SDK {@link android.os.Build.VERSION_CODES#P} and above can be granted only if they\n     * have additionally the {@link android.Manifest.permission#CAMERA} permission.\n     *\n     * @param device to check permissions for\n     * @return true if caller has permission\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#P", "#requestPermission(UsbDevice", "android.hardware.usb.UsbConstants#USB_CLASS_VIDEO", "android.Manifest.permission#CAMERA" ]
  }, {
    "name" : "public boolean hasPermission(UsbAccessory accessory)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the caller has permission to access the accessory.\n     * Permission might have been granted temporarily via\n     * {@link #requestPermission(UsbAccessory, PendingIntent)} or\n     * by the user choosing the caller as the default application for the accessory.\n     *\n     * @param accessory to check permissions for\n     * @return true if caller has permission\n     ",
    "links" : [ "#requestPermission(UsbAccessory" ]
  }, {
    "name" : "public void requestPermission(UsbDevice device, PendingIntent pi)",
    "returnType" : "void",
    "comment" : "\n     * Requests temporary permission for the given package to access the device.\n     * This may result in a system dialog being displayed to the user\n     * if permission had not already been granted.\n     * Success or failure is returned via the {@link android.app.PendingIntent} pi.\n     * If successful, this grants the caller permission to access the device only\n     * until the device is disconnected.\n     *\n     * The following extras will be added to pi:\n     * <ul>\n     * <li> {@link #EXTRA_DEVICE} containing the device passed into this call\n     * <li> {@link #EXTRA_PERMISSION_GRANTED} containing boolean indicating whether\n     * permission was granted by the user\n     * </ul>\n     *\n     * Permission for USB devices of class {@link UsbConstants#USB_CLASS_VIDEO} for clients that\n     * target SDK {@link android.os.Build.VERSION_CODES#P} and above can be granted only if they\n     * have additionally the {@link android.Manifest.permission#CAMERA} permission.\n     *\n     * @param device to request permissions for\n     * @param pi PendingIntent for returning result\n     ",
    "links" : [ "#EXTRA_DEVICE", "android.os.Build.VERSION_CODES#P", "#EXTRA_PERMISSION_GRANTED", "android.hardware.usb.UsbConstants#USB_CLASS_VIDEO", "android.Manifest.permission#CAMERA", "android.app.PendingIntent" ]
  }, {
    "name" : "public void requestPermission(UsbAccessory accessory, PendingIntent pi)",
    "returnType" : "void",
    "comment" : "\n     * Requests temporary permission for the given package to access the accessory.\n     * This may result in a system dialog being displayed to the user\n     * if permission had not already been granted.\n     * Success or failure is returned via the {@link android.app.PendingIntent} pi.\n     * If successful, this grants the caller permission to access the accessory only\n     * until the device is disconnected.\n     *\n     * The following extras will be added to pi:\n     * <ul>\n     * <li> {@link #EXTRA_ACCESSORY} containing the accessory passed into this call\n     * <li> {@link #EXTRA_PERMISSION_GRANTED} containing boolean indicating whether\n     * permission was granted by the user\n     * </ul>\n     *\n     * @param accessory to request permissions for\n     * @param pi PendingIntent for returning result\n     ",
    "links" : [ "#EXTRA_ACCESSORY", "#EXTRA_PERMISSION_GRANTED", "android.app.PendingIntent" ]
  }, {
    "name" : "public void grantPermission(UsbDevice device)",
    "returnType" : "void",
    "comment" : "\n     * Grants permission for USB device without showing system dialog.\n     * Only system components can call this function.\n     * @param device to request permissions for\n     *\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public void grantPermission(UsbDevice device, int uid)",
    "returnType" : "void",
    "comment" : "\n     * Grants permission for USB device to given uid without showing system dialog.\n     * Only system components can call this function.\n     * @param device to request permissions for\n     * @uid uid to give permission\n     *\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public void grantPermission(UsbDevice device, String packageName)",
    "returnType" : "void",
    "comment" : "\n     * Grants permission to specified package for USB device without showing system dialog.\n     * Only system components can call this function, as it requires the MANAGE_USB permission.\n     * @param device to request permissions for\n     * @param packageName of package to grant permissions\n     *\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isFunctionEnabled(String function)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the specified USB function is currently enabled when in device mode.\n     * <p>\n     * USB functions represent interfaces which are published to the host to access\n     * services offered by the device.\n     * </p>\n     *\n     * @deprecated use getCurrentFunctions() instead.\n     * @param function name of the USB function\n     * @return true if the USB function is enabled\n     *\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCurrentFunctions(@UsbFunctionMode long functions)",
    "returnType" : "void",
    "comment" : "\n     * Sets the current USB functions when in device mode.\n     * <p>\n     * USB functions represent interfaces which are published to the host to access\n     * services offered by the device.\n     * </p><p>\n     * This method is intended to select among primary USB functions.  The system may\n     * automatically activate additional functions such as {@link #USB_FUNCTION_ADB}\n     * or {@link #USB_FUNCTION_ACCESSORY} based on other settings and states.\n     * </p><p>\n     * An argument of 0 indicates that the device is charging, and can pick any\n     * appropriate function for that purpose.\n     * </p><p>\n     * Note: This function is asynchronous and may fail silently without applying\n     * the requested changes.\n     * </p>\n     *\n     * @param functions the USB function(s) to set, as a bitwise mask.\n     *                  Must satisfy {@link UsbManager#areSettableFunctions}\n     *\n     * {@hide}\n     ",
    "links" : [ "#USB_FUNCTION_ADB", "#USB_FUNCTION_ACCESSORY", "android.hardware.usb.UsbManager#areSettableFunctions" ]
  }, {
    "name" : "public void setCurrentFunction(String functions, boolean usbDataUnlocked)",
    "returnType" : "void",
    "comment" : "\n     * Sets the current USB functions when in device mode.\n     *\n     * @deprecated use setCurrentFunctions(long) instead.\n     * @param functions the USB function(s) to set.\n     * @param usbDataUnlocked unused\n\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getCurrentFunctions()",
    "returnType" : "long",
    "comment" : "\n     * Returns the current USB functions in device mode.\n     * <p>\n     * This function returns the state of primary USB functions and can return a\n     * mask containing any usb function(s) except for ADB.\n     * </p>\n     *\n     * @return The currently enabled functions, in a bitwise mask.\n     * A zero mask indicates that the current function is the charging function.\n     *\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setScreenUnlockedFunctions(long functions)",
    "returnType" : "void",
    "comment" : "\n     * Sets the screen unlocked functions, which are persisted and set as the current functions\n     * whenever the screen is unlocked.\n     * <p>\n     * A zero mask has the effect of switching off this feature, so functions\n     * no longer change on screen unlock.\n     * </p><p>\n     * Note: When the screen is on, this method will apply given functions as current functions,\n     * which is asynchronous and may fail silently without applying the requested changes.\n     * </p>\n     *\n     * @param functions functions to set, in a bitwise mask.\n     *                  Must satisfy {@link UsbManager#areSettableFunctions}\n     *\n     * {@hide}\n     ",
    "links" : [ "android.hardware.usb.UsbManager#areSettableFunctions" ]
  }, {
    "name" : "public long getScreenUnlockedFunctions()",
    "returnType" : "long",
    "comment" : "\n     * Gets the current screen unlocked functions.\n     *\n     * @return The currently set screen enabled functions.\n     * A zero mask indicates that the screen unlocked functions feature is not enabled.\n     *\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public void resetUsbGadget()",
    "returnType" : "void",
    "comment" : "\n     * Resets the USB Gadget.\n     * <p>\n     * Performs USB data stack reset through USB Gadget HAL.\n     * It will force USB data connection reset. The connection will disconnect and reconnect.\n     * </p>\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<UsbPort> getPorts()",
    "returnType" : "List<UsbPort>",
    "comment" : "\n     * Returns a list of physical USB ports on the device.\n     * <p>\n     * This list is guaranteed to contain all dual-role USB Type C ports but it might\n     * be missing other ports depending on whether the kernel USB drivers have been\n     * updated to publish all of the device's ports through the new \"dual_role_usb\"\n     * device class (which supports all types of ports despite its name).\n     * </p>\n     *\n     * @return The list of USB ports\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " UsbPortStatus getPortStatus(UsbPort port)",
    "returnType" : "UsbPortStatus",
    "comment" : "\n     * Should only be called by {@link UsbPort#getStatus}.\n     *\n     * @hide\n     ",
    "links" : [ "android.hardware.usb.UsbPort#getStatus" ]
  }, {
    "name" : " void setPortRoles(UsbPort port, int powerRole, int dataRole)",
    "returnType" : "void",
    "comment" : "\n     * Should only be called by {@link UsbPort#setRoles}.\n     *\n     * @hide\n     ",
    "links" : [ "android.hardware.usb.UsbPort#setRoles" ]
  }, {
    "name" : " void enableContaminantDetection(@NonNull UsbPort port, boolean enable)",
    "returnType" : "void",
    "comment" : "\n     * Enables USB port contaminant detection algorithm.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setUsbDeviceConnectionHandler(@Nullable ComponentName usbDeviceConnectionHandler)",
    "returnType" : "void",
    "comment" : "\n     * Sets the component that will handle USB device connection.\n     * <p>\n     * Setting component allows to specify external USB host manager to handle use cases, where\n     * selection dialog for an activity that will handle USB device is undesirable.\n     * Only system components can call this function, as it requires the MANAGE_USB permission.\n     *\n     * @param usbDeviceConnectionHandler The component to handle usb connections,\n     * {@code null} to unset.\n     *\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean areSettableFunctions(long functions)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the given functions are valid inputs to UsbManager.\n     * Currently the empty functions or any of MTP, PTP, RNDIS, MIDI are accepted.\n     *\n     * @return Whether the mask is settable.\n     *\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String usbFunctionsToString(long functions)",
    "returnType" : "String",
    "comment" : "\n     * Converts the given function mask to string. Maintains ordering with respect to init scripts.\n     *\n     * @return String representation of given mask\n     *\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static long usbFunctionsFromString(String functions)",
    "returnType" : "long",
    "comment" : "\n     * Parses a string of usb functions that are comma separated.\n     *\n     * @return A mask of all valid functions in the string\n     *\n     * {@hide}\n     ",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "ACTION_USB_STATE", "ACTION_USB_PORT_CHANGED", "ACTION_USB_DEVICE_ATTACHED", "ACTION_USB_DEVICE_DETACHED", "ACTION_USB_ACCESSORY_ATTACHED", "ACTION_USB_ACCESSORY_DETACHED", "USB_CONNECTED", "USB_HOST_CONNECTED", "USB_CONFIGURED", "USB_DATA_UNLOCKED", "USB_FUNCTION_NONE", "USB_FUNCTION_ADB", "USB_FUNCTION_RNDIS", "USB_FUNCTION_MTP", "USB_FUNCTION_PTP", "USB_FUNCTION_AUDIO_SOURCE", "USB_FUNCTION_MIDI", "USB_FUNCTION_ACCESSORY", "USB_FUNCTION_NCM", "EXTRA_PORT", "EXTRA_PORT_STATUS", "EXTRA_DEVICE", "EXTRA_ACCESSORY", "EXTRA_PERMISSION_GRANTED", "EXTRA_PACKAGE", "EXTRA_CAN_BE_DEFAULT", "FUNCTION_NONE", "FUNCTION_MTP", "FUNCTION_PTP", "FUNCTION_RNDIS", "FUNCTION_MIDI", "FUNCTION_ACCESSORY", "FUNCTION_AUDIO_SOURCE", "FUNCTION_ADB", "FUNCTION_NCM", "SETTABLE_FUNCTIONS", "FUNCTION_NAME_TO_CODE", "mContext", "mService" ],
  "methodNames" : [ "public HashMap<String, UsbDevice> getDeviceList()", "public UsbDeviceConnection openDevice(UsbDevice device)", "public UsbAccessory[] getAccessoryList()", "public ParcelFileDescriptor openAccessory(UsbAccessory accessory)", "public ParcelFileDescriptor getControlFd(long function)", "public boolean hasPermission(UsbDevice device)", "public boolean hasPermission(UsbAccessory accessory)", "public void requestPermission(UsbDevice device, PendingIntent pi)", "public void requestPermission(UsbAccessory accessory, PendingIntent pi)", "public void grantPermission(UsbDevice device)", "public void grantPermission(UsbDevice device, int uid)", "public void grantPermission(UsbDevice device, String packageName)", "public boolean isFunctionEnabled(String function)", "public void setCurrentFunctions(@UsbFunctionMode long functions)", "public void setCurrentFunction(String functions, boolean usbDataUnlocked)", "public long getCurrentFunctions()", "public void setScreenUnlockedFunctions(long functions)", "public long getScreenUnlockedFunctions()", "public void resetUsbGadget()", "public List<UsbPort> getPorts()", " UsbPortStatus getPortStatus(UsbPort port)", " void setPortRoles(UsbPort port, int powerRole, int dataRole)", " void enableContaminantDetection(@NonNull UsbPort port, boolean enable)", "public void setUsbDeviceConnectionHandler(@Nullable ComponentName usbDeviceConnectionHandler)", "public static boolean areSettableFunctions(long functions)", "public static String usbFunctionsToString(long functions)", "public static long usbFunctionsFromString(String functions)" ]
}