{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/util/stream/IntStream.java",
  "packageName" : "java.util.stream",
  "className" : "IntStream",
  "comment" : "\n * A sequence of primitive int-valued elements supporting sequential and parallel\n * aggregate operations.  This is the {@code int} primitive specialization of\n * {@link Stream}.\n *\n * <p>The following example illustrates an aggregate operation using\n * {@link Stream} and {@link IntStream}, computing the sum of the weights of the\n * red widgets:\n *\n * <pre>{@code\n *     int sum = widgets.stream()\n *                      .filter(w -> w.getColor() == RED)\n *                      .mapToInt(w -> w.getWeight())\n *                      .sum();\n * }</pre>\n *\n * See the class documentation for {@link Stream} and the package documentation\n * for <a href=\"package-summary.html\">java.util.stream</a> for additional\n * specification of streams, stream operations, stream pipelines, and\n * parallelism.\n *\n * @since 1.8\n * @see Stream\n * @see <a href=\"package-summary.html\">java.util.stream</a>\n ",
  "links" : [ "java.util.stream.IntStream", "java.util.stream.Stream" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " IntStream filter(IntPredicate predicate)",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns a stream consisting of the elements of this stream that match\n     * the given predicate.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * @param predicate a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                  <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                  predicate to apply to each element to determine if it\n     *                  should be included\n     * @return the new stream\n     ",
    "links" : [ ]
  }, {
    "name" : " IntStream map(IntUnaryOperator mapper)",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns a stream consisting of the results of applying the given\n     * function to the elements of this stream.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * @param mapper a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *               <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *               function to apply to each element\n     * @return the new stream\n     ",
    "links" : [ ]
  }, {
    "name" : " Stream<U> mapToObj(IntFunction<? extends U> mapper)",
    "returnType" : "Stream<U>",
    "comment" : "\n     * Returns an object-valued {@code Stream} consisting of the results of\n     * applying the given function to the elements of this stream.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">\n     *     intermediate operation</a>.\n     *\n     * @param <U> the element type of the new stream\n     * @param mapper a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *               <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *               function to apply to each element\n     * @return the new stream\n     ",
    "links" : [ ]
  }, {
    "name" : " LongStream mapToLong(IntToLongFunction mapper)",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns a {@code LongStream} consisting of the results of applying the\n     * given function to the elements of this stream.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * @param mapper a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *               <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *               function to apply to each element\n     * @return the new stream\n     ",
    "links" : [ ]
  }, {
    "name" : " DoubleStream mapToDouble(IntToDoubleFunction mapper)",
    "returnType" : "DoubleStream",
    "comment" : "\n     * Returns a {@code DoubleStream} consisting of the results of applying the\n     * given function to the elements of this stream.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * @param mapper a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *               <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *               function to apply to each element\n     * @return the new stream\n     ",
    "links" : [ ]
  }, {
    "name" : " IntStream flatMap(IntFunction<? extends IntStream> mapper)",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns a stream consisting of the results of replacing each element of\n     * this stream with the contents of a mapped stream produced by applying\n     * the provided mapping function to each element.  Each mapped stream is\n     * {@link java.util.stream.BaseStream#close() closed} after its contents\n     * have been placed into this stream.  (If a mapped stream is {@code null}\n     * an empty stream is used, instead.)\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * @param mapper a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *               <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *               function to apply to each element which produces an\n     *               {@code IntStream} of new values\n     * @return the new stream\n     * @see Stream#flatMap(Function)\n     ",
    "links" : [ "java.util.stream.BaseStream#close()" ]
  }, {
    "name" : " IntStream mapMulti(IntMapMultiConsumer mapper)",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns a stream consisting of the results of replacing each element of\n     * this stream with multiple elements, specifically zero or more elements.\n     * Replacement is performed by applying the provided mapping function to each\n     * element in conjunction with a {@linkplain IntConsumer consumer} argument\n     * that accepts replacement elements. The mapping function calls the consumer\n     * zero or more times to provide the replacement elements.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * <p>If the {@linkplain IntConsumer consumer} argument is used outside the scope of\n     * its application to the mapping function, the results are undefined.\n     *\n     * @implSpec\n     * The default implementation invokes {@link #flatMap flatMap} on this stream,\n     * passing a function that behaves as follows. First, it calls the mapper function\n     * with an {@code IntConsumer} that accumulates replacement elements into a newly created\n     * internal buffer. When the mapper function returns, it creates an {@code IntStream} from the\n     * internal buffer. Finally, it returns this stream to {@code flatMap}.\n     *\n     * @param mapper a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *               <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *               function that generates replacement elements\n     * @return the new stream\n     * @see Stream#mapMulti Stream.mapMulti\n     * @since 16\n     ",
    "links" : [ "#flatMap" ]
  }, {
    "name" : " IntStream distinct()",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns a stream consisting of the distinct elements of this stream.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">stateful\n     * intermediate operation</a>.\n     *\n     * @return the new stream\n     ",
    "links" : [ ]
  }, {
    "name" : " IntStream sorted()",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns a stream consisting of the elements of this stream in sorted\n     * order.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">stateful\n     * intermediate operation</a>.\n     *\n     * @return the new stream\n     ",
    "links" : [ ]
  }, {
    "name" : " IntStream peek(IntConsumer action)",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns a stream consisting of the elements of this stream, additionally\n     * performing the provided action on each element as elements are consumed\n     * from the resulting stream.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * <p>For parallel stream pipelines, the action may be called at\n     * whatever time and in whatever thread the element is made available by the\n     * upstream operation.  If the action modifies shared state,\n     * it is responsible for providing the required synchronization.\n     *\n     * @apiNote This method exists mainly to support debugging, where you want\n     * to see the elements as they flow past a certain point in a pipeline:\n     * <pre>{@code\n     *     IntStream.of(1, 2, 3, 4)\n     *         .filter(e -> e > 2)\n     *         .peek(e -> System.out.println(\"Filtered value: \" + e))\n     *         .map(e -> e * e)\n     *         .peek(e -> System.out.println(\"Mapped value: \" + e))\n     *         .sum();\n     * }</pre>\n     *\n     * <p>In cases where the stream implementation is able to optimize away the\n     * production of some or all the elements (such as with short-circuiting\n     * operations like {@code findFirst}, or in the example described in\n     * {@link #count}), the action will not be invoked for those elements.\n     *\n     * @param action a <a href=\"package-summary.html#NonInterference\">\n     *               non-interfering</a> action to perform on the elements as\n     *               they are consumed from the stream\n     * @return the new stream\n     ",
    "links" : [ "#count" ]
  }, {
    "name" : " IntStream limit(long maxSize)",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns a stream consisting of the elements of this stream, truncated\n     * to be no longer than {@code maxSize} in length.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">short-circuiting\n     * stateful intermediate operation</a>.\n     *\n     * @apiNote\n     * While {@code limit()} is generally a cheap operation on sequential\n     * stream pipelines, it can be quite expensive on ordered parallel pipelines,\n     * especially for large values of {@code maxSize}, since {@code limit(n)}\n     * is constrained to return not just any <em>n</em> elements, but the\n     * <em>first n</em> elements in the encounter order.  Using an unordered\n     * stream source (such as {@link #generate(IntSupplier)}) or removing the\n     * ordering constraint with {@link #unordered()} may result in significant\n     * speedups of {@code limit()} in parallel pipelines, if the semantics of\n     * your situation permit.  If consistency with encounter order is required,\n     * and you are experiencing poor performance or memory utilization with\n     * {@code limit()} in parallel pipelines, switching to sequential execution\n     * with {@link #sequential()} may improve performance.\n     *\n     * @param maxSize the number of elements the stream should be limited to\n     * @return the new stream\n     * @throws IllegalArgumentException if {@code maxSize} is negative\n     ",
    "links" : [ "#generate(IntSupplier)", "#unordered()", "#sequential()" ]
  }, {
    "name" : " IntStream skip(long n)",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns a stream consisting of the remaining elements of this stream\n     * after discarding the first {@code n} elements of the stream.\n     * If this stream contains fewer than {@code n} elements then an\n     * empty stream will be returned.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">stateful\n     * intermediate operation</a>.\n     *\n     * @apiNote\n     * While {@code skip()} is generally a cheap operation on sequential\n     * stream pipelines, it can be quite expensive on ordered parallel pipelines,\n     * especially for large values of {@code n}, since {@code skip(n)}\n     * is constrained to skip not just any <em>n</em> elements, but the\n     * <em>first n</em> elements in the encounter order.  Using an unordered\n     * stream source (such as {@link #generate(IntSupplier)}) or removing the\n     * ordering constraint with {@link #unordered()} may result in significant\n     * speedups of {@code skip()} in parallel pipelines, if the semantics of\n     * your situation permit.  If consistency with encounter order is required,\n     * and you are experiencing poor performance or memory utilization with\n     * {@code skip()} in parallel pipelines, switching to sequential execution\n     * with {@link #sequential()} may improve performance.\n     *\n     * @param n the number of leading elements to skip\n     * @return the new stream\n     * @throws IllegalArgumentException if {@code n} is negative\n     ",
    "links" : [ "#generate(IntSupplier)", "#unordered()", "#sequential()" ]
  }, {
    "name" : " IntStream takeWhile(IntPredicate predicate)",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns, if this stream is ordered, a stream consisting of the longest\n     * prefix of elements taken from this stream that match the given predicate.\n     * Otherwise returns, if this stream is unordered, a stream consisting of a\n     * subset of elements taken from this stream that match the given predicate.\n     *\n     * <p>If this stream is ordered then the longest prefix is a contiguous\n     * sequence of elements of this stream that match the given predicate.  The\n     * first element of the sequence is the first element of this stream, and\n     * the element immediately following the last element of the sequence does\n     * not match the given predicate.\n     *\n     * <p>If this stream is unordered, and some (but not all) elements of this\n     * stream match the given predicate, then the behavior of this operation is\n     * nondeterministic; it is free to take any subset of matching elements\n     * (which includes the empty set).\n     *\n     * <p>Independent of whether this stream is ordered or unordered if all\n     * elements of this stream match the given predicate then this operation\n     * takes all elements (the result is the same as the input), or if no\n     * elements of the stream match the given predicate then no elements are\n     * taken (the result is an empty stream).\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">short-circuiting\n     * stateful intermediate operation</a>.\n     *\n     * @implSpec\n     * The default implementation obtains the {@link #spliterator() spliterator}\n     * of this stream, wraps that spliterator so as to support the semantics\n     * of this operation on traversal, and returns a new stream associated with\n     * the wrapped spliterator.  The returned stream preserves the execution\n     * characteristics of this stream (namely parallel or sequential execution\n     * as per {@link #isParallel()}) but the wrapped spliterator may choose to\n     * not support splitting.  When the returned stream is closed, the close\n     * handlers for both the returned and this stream are invoked.\n     *\n     * @apiNote\n     * While {@code takeWhile()} is generally a cheap operation on sequential\n     * stream pipelines, it can be quite expensive on ordered parallel\n     * pipelines, since the operation is constrained to return not just any\n     * valid prefix, but the longest prefix of elements in the encounter order.\n     * Using an unordered stream source (such as {@link #generate(IntSupplier)})\n     * or removing the ordering constraint with {@link #unordered()} may result\n     * in significant speedups of {@code takeWhile()} in parallel pipelines, if\n     * the semantics of your situation permit.  If consistency with encounter\n     * order is required, and you are experiencing poor performance or memory\n     * utilization with {@code takeWhile()} in parallel pipelines, switching to\n     * sequential execution with {@link #sequential()} may improve performance.\n     *\n     * @param predicate a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                  <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                  predicate to apply to elements to determine the longest\n     *                  prefix of elements.\n     * @return the new stream\n     * @since 9\n     ",
    "links" : [ "#generate(IntSupplier)", "#spliterator()", "#isParallel()", "#unordered()", "#sequential()" ]
  }, {
    "name" : " IntStream dropWhile(IntPredicate predicate)",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns, if this stream is ordered, a stream consisting of the remaining\n     * elements of this stream after dropping the longest prefix of elements\n     * that match the given predicate.  Otherwise returns, if this stream is\n     * unordered, a stream consisting of the remaining elements of this stream\n     * after dropping a subset of elements that match the given predicate.\n     *\n     * <p>If this stream is ordered then the longest prefix is a contiguous\n     * sequence of elements of this stream that match the given predicate.  The\n     * first element of the sequence is the first element of this stream, and\n     * the element immediately following the last element of the sequence does\n     * not match the given predicate.\n     *\n     * <p>If this stream is unordered, and some (but not all) elements of this\n     * stream match the given predicate, then the behavior of this operation is\n     * nondeterministic; it is free to drop any subset of matching elements\n     * (which includes the empty set).\n     *\n     * <p>Independent of whether this stream is ordered or unordered if all\n     * elements of this stream match the given predicate then this operation\n     * drops all elements (the result is an empty stream), or if no elements of\n     * the stream match the given predicate then no elements are dropped (the\n     * result is the same as the input).\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">stateful\n     * intermediate operation</a>.\n     *\n     * @implSpec\n     * The default implementation obtains the {@link #spliterator() spliterator}\n     * of this stream, wraps that spliterator so as to support the semantics\n     * of this operation on traversal, and returns a new stream associated with\n     * the wrapped spliterator.  The returned stream preserves the execution\n     * characteristics of this stream (namely parallel or sequential execution\n     * as per {@link #isParallel()}) but the wrapped spliterator may choose to\n     * not support splitting.  When the returned stream is closed, the close\n     * handlers for both the returned and this stream are invoked.\n     *\n     * @apiNote\n     * While {@code dropWhile()} is generally a cheap operation on sequential\n     * stream pipelines, it can be quite expensive on ordered parallel\n     * pipelines, since the operation is constrained to return not just any\n     * valid prefix, but the longest prefix of elements in the encounter order.\n     * Using an unordered stream source (such as {@link #generate(IntSupplier)})\n     * or removing the ordering constraint with {@link #unordered()} may result\n     * in significant speedups of {@code dropWhile()} in parallel pipelines, if\n     * the semantics of your situation permit.  If consistency with encounter\n     * order is required, and you are experiencing poor performance or memory\n     * utilization with {@code dropWhile()} in parallel pipelines, switching to\n     * sequential execution with {@link #sequential()} may improve performance.\n     *\n     * @param predicate a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                  <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                  predicate to apply to elements to determine the longest\n     *                  prefix of elements.\n     * @return the new stream\n     * @since 9\n     ",
    "links" : [ "#generate(IntSupplier)", "#spliterator()", "#isParallel()", "#unordered()", "#sequential()" ]
  }, {
    "name" : " void forEach(IntConsumer action)",
    "returnType" : "void",
    "comment" : "\n     * Performs an action for each element of this stream.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * <p>For parallel stream pipelines, this operation does <em>not</em>\n     * guarantee to respect the encounter order of the stream, as doing so\n     * would sacrifice the benefit of parallelism.  For any given element, the\n     * action may be performed at whatever time and in whatever thread the\n     * library chooses.  If the action accesses shared state, it is\n     * responsible for providing the required synchronization.\n     *\n     * @param action a <a href=\"package-summary.html#NonInterference\">\n     *               non-interfering</a> action to perform on the elements\n     ",
    "links" : [ ]
  }, {
    "name" : " void forEachOrdered(IntConsumer action)",
    "returnType" : "void",
    "comment" : "\n     * Performs an action for each element of this stream, guaranteeing that\n     * each element is processed in encounter order for streams that have a\n     * defined encounter order.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * @param action a <a href=\"package-summary.html#NonInterference\">\n     *               non-interfering</a> action to perform on the elements\n     * @see #forEach(IntConsumer)\n     ",
    "links" : [ ]
  }, {
    "name" : " int[] toArray()",
    "returnType" : "int[]",
    "comment" : "\n     * Returns an array containing the elements of this stream.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * @return an array containing the elements of this stream\n     ",
    "links" : [ ]
  }, {
    "name" : " int reduce(int identity, IntBinaryOperator op)",
    "returnType" : "int",
    "comment" : "\n     * Performs a <a href=\"package-summary.html#Reduction\">reduction</a> on the\n     * elements of this stream, using the provided identity value and an\n     * <a href=\"package-summary.html#Associativity\">associative</a>\n     * accumulation function, and returns the reduced value.  This is equivalent\n     * to:\n     * <pre>{@code\n     *     int result = identity;\n     *     for (int element : this stream)\n     *         result = accumulator.applyAsInt(result, element)\n     *     return result;\n     * }</pre>\n     *\n     * but is not constrained to execute sequentially.\n     *\n     * <p>The {@code identity} value must be an identity for the accumulator\n     * function. This means that for all {@code x},\n     * {@code accumulator.apply(identity, x)} is equal to {@code x}.\n     * The {@code accumulator} function must be an\n     * <a href=\"package-summary.html#Associativity\">associative</a> function.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * @apiNote Sum, min and max are all special cases of reduction that can be\n     * expressed using this method.\n     * For example, summing a stream can be expressed as:\n     *\n     * <pre>{@code\n     *     int sum = integers.reduce(0, (a, b) -> a+b);\n     * }</pre>\n     *\n     * or more compactly:\n     *\n     * <pre>{@code\n     *     int sum = integers.reduce(0, Integer::sum);\n     * }</pre>\n     *\n     * <p>While this may seem a more roundabout way to perform an aggregation\n     * compared to simply mutating a running total in a loop, reduction\n     * operations parallelize more gracefully, without needing additional\n     * synchronization and with greatly reduced risk of data races.\n     *\n     * @param identity the identity value for the accumulating function\n     * @param op an <a href=\"package-summary.html#Associativity\">associative</a>,\n     *           <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *           <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *           function for combining two values\n     * @return the result of the reduction\n     * @see #sum()\n     * @see #min()\n     * @see #max()\n     * @see #average()\n     ",
    "links" : [ ]
  }, {
    "name" : " OptionalInt reduce(IntBinaryOperator op)",
    "returnType" : "OptionalInt",
    "comment" : "\n     * Performs a <a href=\"package-summary.html#Reduction\">reduction</a> on the\n     * elements of this stream, using an\n     * <a href=\"package-summary.html#Associativity\">associative</a> accumulation\n     * function, and returns an {@code OptionalInt} describing the reduced value,\n     * if any. This is equivalent to:\n     * <pre>{@code\n     *     boolean foundAny = false;\n     *     int result = null;\n     *     for (int element : this stream) {\n     *         if (!foundAny) {\n     *             foundAny = true;\n     *             result = element;\n     *         }\n     *         else\n     *             result = accumulator.applyAsInt(result, element);\n     *     }\n     *     return foundAny ? OptionalInt.of(result) : OptionalInt.empty();\n     * }</pre>\n     *\n     * but is not constrained to execute sequentially.\n     *\n     * <p>The {@code accumulator} function must be an\n     * <a href=\"package-summary.html#Associativity\">associative</a> function.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * @param op an <a href=\"package-summary.html#Associativity\">associative</a>,\n     *           <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *           <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *           function for combining two values\n     * @return the result of the reduction\n     * @see #reduce(int, IntBinaryOperator)\n     ",
    "links" : [ ]
  }, {
    "name" : " R collect(Supplier<R> supplier, ObjIntConsumer<R> accumulator, BiConsumer<R, R> combiner)",
    "returnType" : "R",
    "comment" : "\n     * Performs a <a href=\"package-summary.html#MutableReduction\">mutable\n     * reduction</a> operation on the elements of this stream.  A mutable\n     * reduction is one in which the reduced value is a mutable result container,\n     * such as an {@code ArrayList}, and elements are incorporated by updating\n     * the state of the result rather than by replacing the result.  This\n     * produces a result equivalent to:\n     * <pre>{@code\n     *     R result = supplier.get();\n     *     for (int element : this stream)\n     *         accumulator.accept(result, element);\n     *     return result;\n     * }</pre>\n     *\n     * <p>Like {@link #reduce(int, IntBinaryOperator)}, {@code collect} operations\n     * can be parallelized without requiring additional synchronization.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * @param <R> the type of the mutable result container\n     * @param supplier a function that creates a new mutable result container.\n     *                 For a parallel execution, this function may be called\n     *                 multiple times and must return a fresh value each time.\n     * @param accumulator an <a href=\"package-summary.html#Associativity\">associative</a>,\n     *                    <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                    <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                    function that must fold an element into a result\n     *                    container.\n     * @param combiner an <a href=\"package-summary.html#Associativity\">associative</a>,\n     *                    <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                    <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                    function that accepts two partial result containers\n     *                    and merges them, which must be compatible with the\n     *                    accumulator function.  The combiner function must fold\n     *                    the elements from the second result container into the\n     *                    first result container.\n     * @return the result of the reduction\n     * @see Stream#collect(Supplier, BiConsumer, BiConsumer)\n     ",
    "links" : [ "#reduce(int" ]
  }, {
    "name" : " int sum()",
    "returnType" : "int",
    "comment" : "\n     * Returns the sum of elements in this stream.  This is a special case\n     * of a <a href=\"package-summary.html#Reduction\">reduction</a>\n     * and is equivalent to:\n     * <pre>{@code\n     *     return reduce(0, Integer::sum);\n     * }</pre>\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * @return the sum of elements in this stream\n     ",
    "links" : [ ]
  }, {
    "name" : " OptionalInt min()",
    "returnType" : "OptionalInt",
    "comment" : "\n     * Returns an {@code OptionalInt} describing the minimum element of this\n     * stream, or an empty optional if this stream is empty.  This is a special\n     * case of a <a href=\"package-summary.html#Reduction\">reduction</a>\n     * and is equivalent to:\n     * <pre>{@code\n     *     return reduce(Integer::min);\n     * }</pre>\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal operation</a>.\n     *\n     * @return an {@code OptionalInt} containing the minimum element of this\n     * stream, or an empty {@code OptionalInt} if the stream is empty\n     ",
    "links" : [ ]
  }, {
    "name" : " OptionalInt max()",
    "returnType" : "OptionalInt",
    "comment" : "\n     * Returns an {@code OptionalInt} describing the maximum element of this\n     * stream, or an empty optional if this stream is empty.  This is a special\n     * case of a <a href=\"package-summary.html#Reduction\">reduction</a>\n     * and is equivalent to:\n     * <pre>{@code\n     *     return reduce(Integer::max);\n     * }</pre>\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * @return an {@code OptionalInt} containing the maximum element of this\n     * stream, or an empty {@code OptionalInt} if the stream is empty\n     ",
    "links" : [ ]
  }, {
    "name" : " long count()",
    "returnType" : "long",
    "comment" : "\n     * Returns the count of elements in this stream.  This is a special case of\n     * a <a href=\"package-summary.html#Reduction\">reduction</a> and is\n     * equivalent to:\n     * <pre>{@code\n     *     return mapToLong(e -> 1L).sum();\n     * }</pre>\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal operation</a>.\n     *\n     * @apiNote\n     * An implementation may choose to not execute the stream pipeline (either\n     * sequentially or in parallel) if it is capable of computing the count\n     * directly from the stream source.  In such cases no source elements will\n     * be traversed and no intermediate operations will be evaluated.\n     * Behavioral parameters with side-effects, which are strongly discouraged\n     * except for harmless cases such as debugging, may be affected.  For\n     * example, consider the following stream:\n     * <pre>{@code\n     *     IntStream s = IntStream.of(1, 2, 3, 4);\n     *     long count = s.peek(System.out::println).count();\n     * }</pre>\n     * The number of elements covered by the stream source is known and the\n     * intermediate operation, {@code peek}, does not inject into or remove\n     * elements from the stream (as may be the case for {@code flatMap} or\n     * {@code filter} operations).  Thus the count is 4 and there is no need to\n     * execute the pipeline and, as a side-effect, print out the elements.\n     *\n     * @return the count of elements in this stream\n     ",
    "links" : [ ]
  }, {
    "name" : " OptionalDouble average()",
    "returnType" : "OptionalDouble",
    "comment" : "\n     * Returns an {@code OptionalDouble} describing the arithmetic mean of elements of\n     * this stream, or an empty optional if this stream is empty.  This is a\n     * special case of a\n     * <a href=\"package-summary.html#Reduction\">reduction</a>.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * @return an {@code OptionalDouble} containing the average element of this\n     * stream, or an empty optional if the stream is empty\n     ",
    "links" : [ ]
  }, {
    "name" : " IntSummaryStatistics summaryStatistics()",
    "returnType" : "IntSummaryStatistics",
    "comment" : "\n     * Returns an {@code IntSummaryStatistics} describing various\n     * summary data about the elements of this stream.  This is a special\n     * case of a <a href=\"package-summary.html#Reduction\">reduction</a>.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">terminal\n     * operation</a>.\n     *\n     * @return an {@code IntSummaryStatistics} describing various summary data\n     * about the elements of this stream\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean anyMatch(IntPredicate predicate)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether any elements of this stream match the provided\n     * predicate.  May not evaluate the predicate on all elements if not\n     * necessary for determining the result.  If the stream is empty then\n     * {@code false} is returned and the predicate is not evaluated.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">short-circuiting\n     * terminal operation</a>.\n     *\n     * @apiNote\n     * This method evaluates the <em>existential quantification</em> of the\n     * predicate over the elements of the stream (for some x P(x)).\n     *\n     * @param predicate a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                  <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                  predicate to apply to elements of this stream\n     * @return {@code true} if any elements of the stream match the provided\n     * predicate, otherwise {@code false}\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean allMatch(IntPredicate predicate)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether all elements of this stream match the provided predicate.\n     * May not evaluate the predicate on all elements if not necessary for\n     * determining the result.  If the stream is empty then {@code true} is\n     * returned and the predicate is not evaluated.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">short-circuiting\n     * terminal operation</a>.\n     *\n     * @apiNote\n     * This method evaluates the <em>universal quantification</em> of the\n     * predicate over the elements of the stream (for all x P(x)).  If the\n     * stream is empty, the quantification is said to be <em>vacuously\n     * satisfied</em> and is always {@code true} (regardless of P(x)).\n     *\n     * @param predicate a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                  <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                  predicate to apply to elements of this stream\n     * @return {@code true} if either all elements of the stream match the\n     * provided predicate or the stream is empty, otherwise {@code false}\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean noneMatch(IntPredicate predicate)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether no elements of this stream match the provided predicate.\n     * May not evaluate the predicate on all elements if not necessary for\n     * determining the result.  If the stream is empty then {@code true} is\n     * returned and the predicate is not evaluated.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">short-circuiting\n     * terminal operation</a>.\n     *\n     * @apiNote\n     * This method evaluates the <em>universal quantification</em> of the\n     * negated predicate over the elements of the stream (for all x ~P(x)).  If\n     * the stream is empty, the quantification is said to be vacuously satisfied\n     * and is always {@code true}, regardless of P(x).\n     *\n     * @param predicate a <a href=\"package-summary.html#NonInterference\">non-interfering</a>,\n     *                  <a href=\"package-summary.html#Statelessness\">stateless</a>\n     *                  predicate to apply to elements of this stream\n     * @return {@code true} if either no elements of the stream match the\n     * provided predicate or the stream is empty, otherwise {@code false}\n     ",
    "links" : [ ]
  }, {
    "name" : " OptionalInt findFirst()",
    "returnType" : "OptionalInt",
    "comment" : "\n     * Returns an {@link OptionalInt} describing the first element of this\n     * stream, or an empty {@code OptionalInt} if the stream is empty.  If the\n     * stream has no encounter order, then any element may be returned.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">short-circuiting\n     * terminal operation</a>.\n     *\n     * @return an {@code OptionalInt} describing the first element of this stream,\n     * or an empty {@code OptionalInt} if the stream is empty\n     ",
    "links" : [ "java.util.OptionalInt" ]
  }, {
    "name" : " OptionalInt findAny()",
    "returnType" : "OptionalInt",
    "comment" : "\n     * Returns an {@link OptionalInt} describing some element of the stream, or\n     * an empty {@code OptionalInt} if the stream is empty.\n     *\n     * <p>This is a <a href=\"package-summary.html#StreamOps\">short-circuiting\n     * terminal operation</a>.\n     *\n     * <p>The behavior of this operation is explicitly nondeterministic; it is\n     * free to select any element in the stream.  This is to allow for maximal\n     * performance in parallel operations; the cost is that multiple invocations\n     * on the same source may not return the same result.  (If a stable result\n     * is desired, use {@link #findFirst()} instead.)\n     *\n     * @return an {@code OptionalInt} describing some element of this stream, or\n     * an empty {@code OptionalInt} if the stream is empty\n     * @see #findFirst()\n     ",
    "links" : [ "#findFirst()", "java.util.OptionalInt" ]
  }, {
    "name" : " LongStream asLongStream()",
    "returnType" : "LongStream",
    "comment" : "\n     * Returns a {@code LongStream} consisting of the elements of this stream,\n     * converted to {@code long}.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * @return a {@code LongStream} consisting of the elements of this stream,\n     * converted to {@code long}\n     ",
    "links" : [ ]
  }, {
    "name" : " DoubleStream asDoubleStream()",
    "returnType" : "DoubleStream",
    "comment" : "\n     * Returns a {@code DoubleStream} consisting of the elements of this stream,\n     * converted to {@code double}.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * @return a {@code DoubleStream} consisting of the elements of this stream,\n     * converted to {@code double}\n     ",
    "links" : [ ]
  }, {
    "name" : " Stream<Integer> boxed()",
    "returnType" : "Stream<Integer>",
    "comment" : "\n     * Returns a {@code Stream} consisting of the elements of this stream,\n     * each boxed to an {@code Integer}.\n     *\n     * <p>This is an <a href=\"package-summary.html#StreamOps\">intermediate\n     * operation</a>.\n     *\n     * @return a {@code Stream} consistent of the elements of this stream,\n     * each boxed to an {@code Integer}\n     ",
    "links" : [ ]
  }, {
    "name" : " IntStream sequential()",
    "returnType" : "IntStream",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " IntStream parallel()",
    "returnType" : "IntStream",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " PrimitiveIterator.OfInt iterator()",
    "returnType" : "PrimitiveIterator.OfInt",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " Spliterator.OfInt spliterator()",
    "returnType" : "Spliterator.OfInt",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static Builder builder()",
    "returnType" : "Builder",
    "comment" : "\n     * Returns a builder for an {@code IntStream}.\n     *\n     * @return a stream builder\n     ",
    "links" : [ ]
  }, {
    "name" : "public static IntStream empty()",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns an empty sequential {@code IntStream}.\n     *\n     * @return an empty sequential stream\n     ",
    "links" : [ ]
  }, {
    "name" : "public static IntStream of(int t)",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns a sequential {@code IntStream} containing a single element.\n     *\n     * @param t the single element\n     * @return a singleton sequential stream\n     ",
    "links" : [ ]
  }, {
    "name" : "public static IntStream of(int... values)",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns a sequential ordered stream whose elements are the specified values.\n     *\n     * @param values the elements of the new stream\n     * @return the new stream\n     ",
    "links" : [ ]
  }, {
    "name" : "public static IntStream iterate(final int seed, final IntUnaryOperator f)",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns an infinite sequential ordered {@code IntStream} produced by iterative\n     * application of a function {@code f} to an initial element {@code seed},\n     * producing a {@code Stream} consisting of {@code seed}, {@code f(seed)},\n     * {@code f(f(seed))}, etc.\n     *\n     * <p>The first element (position {@code 0}) in the {@code IntStream} will be\n     * the provided {@code seed}.  For {@code n > 0}, the element at position\n     * {@code n}, will be the result of applying the function {@code f} to the\n     * element at position {@code n - 1}.\n     *\n     * <p>The action of applying {@code f} for one element\n     * <a href=\"../concurrent/package-summary.html#MemoryVisibility\"><i>happens-before</i></a>\n     * the action of applying {@code f} for subsequent elements.  For any given\n     * element the action may be performed in whatever thread the library\n     * chooses.\n     *\n     * @param seed the initial element\n     * @param f a function to be applied to the previous element to produce\n     *          a new element\n     * @return a new sequential {@code IntStream}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static IntStream iterate(int seed, IntPredicate hasNext, IntUnaryOperator next)",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns a sequential ordered {@code IntStream} produced by iterative\n     * application of the given {@code next} function to an initial element,\n     * conditioned on satisfying the given {@code hasNext} predicate.  The\n     * stream terminates as soon as the {@code hasNext} predicate returns false.\n     *\n     * <p>{@code IntStream.iterate} should produce the same sequence of elements as\n     * produced by the corresponding for-loop:\n     * <pre>{@code\n     *     for (int index=seed; hasNext.test(index); index = next.applyAsInt(index)) {\n     *         ...\n     *     }\n     * }</pre>\n     *\n     * <p>The resulting sequence may be empty if the {@code hasNext} predicate\n     * does not hold on the seed value.  Otherwise the first element will be the\n     * supplied {@code seed} value, the next element (if present) will be the\n     * result of applying the {@code next} function to the {@code seed} value,\n     * and so on iteratively until the {@code hasNext} predicate indicates that\n     * the stream should terminate.\n     *\n     * <p>The action of applying the {@code hasNext} predicate to an element\n     * <a href=\"../concurrent/package-summary.html#MemoryVisibility\"><i>happens-before</i></a>\n     * the action of applying the {@code next} function to that element.  The\n     * action of applying the {@code next} function for one element\n     * <i>happens-before</i> the action of applying the {@code hasNext}\n     * predicate for subsequent elements.  For any given element an action may\n     * be performed in whatever thread the library chooses.\n     *\n     * @param seed the initial element\n     * @param hasNext a predicate to apply to elements to determine when the\n     *                stream must terminate.\n     * @param next a function to be applied to the previous element to produce\n     *             a new element\n     * @return a new sequential {@code IntStream}\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public static IntStream generate(IntSupplier s)",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns an infinite sequential unordered stream where each element is\n     * generated by the provided {@code IntSupplier}.  This is suitable for\n     * generating constant streams, streams of random elements, etc.\n     *\n     * @param s the {@code IntSupplier} for generated elements\n     * @return a new infinite sequential unordered {@code IntStream}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static IntStream range(int startInclusive, int endExclusive)",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns a sequential ordered {@code IntStream} from {@code startInclusive}\n     * (inclusive) to {@code endExclusive} (exclusive) by an incremental step of\n     * {@code 1}.\n     *\n     * @apiNote\n     * <p>An equivalent sequence of increasing values can be produced\n     * sequentially using a {@code for} loop as follows:\n     * <pre>{@code\n     *     for (int i = startInclusive; i < endExclusive ; i++) { ... }\n     * }</pre>\n     *\n     * @param startInclusive the (inclusive) initial value\n     * @param endExclusive the exclusive upper bound\n     * @return a sequential {@code IntStream} for the range of {@code int}\n     *         elements\n     ",
    "links" : [ ]
  }, {
    "name" : "public static IntStream rangeClosed(int startInclusive, int endInclusive)",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns a sequential ordered {@code IntStream} from {@code startInclusive}\n     * (inclusive) to {@code endInclusive} (inclusive) by an incremental step of\n     * {@code 1}.\n     *\n     * @apiNote\n     * <p>An equivalent sequence of increasing values can be produced\n     * sequentially using a {@code for} loop as follows:\n     * <pre>{@code\n     *     for (int i = startInclusive; i <= endInclusive ; i++) { ... }\n     * }</pre>\n     *\n     * @param startInclusive the (inclusive) initial value\n     * @param endInclusive the inclusive upper bound\n     * @return a sequential {@code IntStream} for the range of {@code int}\n     *         elements\n     ",
    "links" : [ ]
  }, {
    "name" : "public static IntStream concat(IntStream a, IntStream b)",
    "returnType" : "IntStream",
    "comment" : "\n     * Creates a lazily concatenated stream whose elements are all the\n     * elements of the first stream followed by all the elements of the\n     * second stream.  The resulting stream is ordered if both\n     * of the input streams are ordered, and parallel if either of the input\n     * streams is parallel.  When the resulting stream is closed, the close\n     * handlers for both input streams are invoked.\n     *\n     * <p>This method operates on the two input streams and binds each stream\n     * to its source.  As a result subsequent modifications to an input stream\n     * source may not be reflected in the concatenated stream result.\n     *\n     * @implNote\n     * Use caution when constructing streams from repeated concatenation.\n     * Accessing an element of a deeply concatenated stream can result in deep\n     * call chains, or even {@code StackOverflowError}.\n     *\n     * @apiNote\n     * To preserve optimization opportunities this method binds each stream to\n     * its source and accepts only two streams as parameters.  For example, the\n     * exact size of the concatenated stream source can be computed if the exact\n     * size of each input stream source is known.\n     * To concatenate more streams without binding, or without nested calls to\n     * this method, try creating a stream of streams and flat-mapping with the\n     * identity function, for example:\n     * <pre>{@code\n     *     IntStream concat = Stream.of(s1, s2, s3, s4).flatMapToInt(s -> s);\n     * }</pre>\n     *\n     * @param a the first stream\n     * @param b the second stream\n     * @return the concatenation of the two input streams\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ " IntStream filter(IntPredicate predicate)", " IntStream map(IntUnaryOperator mapper)", " Stream<U> mapToObj(IntFunction<? extends U> mapper)", " LongStream mapToLong(IntToLongFunction mapper)", " DoubleStream mapToDouble(IntToDoubleFunction mapper)", " IntStream flatMap(IntFunction<? extends IntStream> mapper)", " IntStream mapMulti(IntMapMultiConsumer mapper)", " IntStream distinct()", " IntStream sorted()", " IntStream peek(IntConsumer action)", " IntStream limit(long maxSize)", " IntStream skip(long n)", " IntStream takeWhile(IntPredicate predicate)", " IntStream dropWhile(IntPredicate predicate)", " void forEach(IntConsumer action)", " void forEachOrdered(IntConsumer action)", " int[] toArray()", " int reduce(int identity, IntBinaryOperator op)", " OptionalInt reduce(IntBinaryOperator op)", " R collect(Supplier<R> supplier, ObjIntConsumer<R> accumulator, BiConsumer<R, R> combiner)", " int sum()", " OptionalInt min()", " OptionalInt max()", " long count()", " OptionalDouble average()", " IntSummaryStatistics summaryStatistics()", " boolean anyMatch(IntPredicate predicate)", " boolean allMatch(IntPredicate predicate)", " boolean noneMatch(IntPredicate predicate)", " OptionalInt findFirst()", " OptionalInt findAny()", " LongStream asLongStream()", " DoubleStream asDoubleStream()", " Stream<Integer> boxed()", " IntStream sequential()", " IntStream parallel()", " PrimitiveIterator.OfInt iterator()", " Spliterator.OfInt spliterator()", "public static Builder builder()", "public static IntStream empty()", "public static IntStream of(int t)", "public static IntStream of(int... values)", "public static IntStream iterate(final int seed, final IntUnaryOperator f)", "public static IntStream iterate(int seed, IntPredicate hasNext, IntUnaryOperator next)", "public static IntStream generate(IntSupplier s)", "public static IntStream range(int startInclusive, int endExclusive)", "public static IntStream rangeClosed(int startInclusive, int endInclusive)", "public static IntStream concat(IntStream a, IntStream b)" ],
  "variableNames" : [ ]
}