{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/org/xmlpull/v1/XmlPullParser.java",
  "packageName" : "org.xmlpull.v1",
  "className" : "XmlPullParser",
  "comment" : "",
  "links" : [ ],
  "variables" : [ {
    "name" : "NO_NAMESPACE",
    "type" : "String",
    "comment" : " This constant represents the default namespace (empty string \"\") ",
    "links" : [ ]
  }, {
    "name" : "START_DOCUMENT",
    "type" : "int",
    "comment" : "\n     * Signalize that parser is at the very beginning of the document\n     * and nothing was read yet.\n     * This event type can only be observed by calling getEvent()\n     * before the first call to next(), nextToken, or nextTag()</a>).\n     *\n     * @see #next\n     * @see #nextToken\n     ",
    "links" : [ ]
  }, {
    "name" : "END_DOCUMENT",
    "type" : "int",
    "comment" : "\n     * Logical end of the xml document. Returned from getEventType, next()\n     * and nextToken()\n     * when the end of the input document has been reached.\n     * <p><strong>NOTE:</strong> subsequent calls to\n     * <a href=\"#next()\">next()</a> or <a href=\"#nextToken()\">nextToken()</a>\n     * may result in exception being thrown.\n     *\n     * @see #next\n     * @see #nextToken\n     ",
    "links" : [ ]
  }, {
    "name" : "START_TAG",
    "type" : "int",
    "comment" : "\n     * Returned from getEventType(),\n     * <a href=\"#next()\">next()</a>, <a href=\"#nextToken()\">nextToken()</a> when\n     * a start tag was read.\n     * The name of start tag is available from getName(), its namespace and prefix are\n     * available from getNamespace() and getPrefix()\n     * if <a href='#FEATURE_PROCESS_NAMESPACES'>namespaces are enabled</a>.\n     * See getAttribute* methods to retrieve element attributes.\n     * See getNamespace* methods to retrieve newly declared namespaces.\n     *\n     * @see #next\n     * @see #nextToken\n     * @see #getName\n     * @see #getPrefix\n     * @see #getNamespace\n     * @see #getAttributeCount\n     * @see #getDepth\n     * @see #getNamespaceCount\n     * @see #getNamespace\n     * @see #FEATURE_PROCESS_NAMESPACES\n     ",
    "links" : [ ]
  }, {
    "name" : "END_TAG",
    "type" : "int",
    "comment" : "\n     * Returned from getEventType(), <a href=\"#next()\">next()</a>, or\n     * <a href=\"#nextToken()\">nextToken()</a> when an end tag was read.\n     * The name of start tag is available from getName(), its\n     * namespace and prefix are\n     * available from getNamespace() and getPrefix().\n     *\n     * @see #next\n     * @see #nextToken\n     * @see #getName\n     * @see #getPrefix\n     * @see #getNamespace\n     * @see #FEATURE_PROCESS_NAMESPACES\n     ",
    "links" : [ ]
  }, {
    "name" : "TEXT",
    "type" : "int",
    "comment" : "\n     * Character data was read and will is available by calling getText().\n     * <p><strong>Please note:</strong> <a href=\"#next()\">next()</a> will\n     * accumulate multiple\n     * events into one TEXT event, skipping IGNORABLE_WHITESPACE,\n     * PROCESSING_INSTRUCTION and COMMENT events,\n     * In contrast, <a href=\"#nextToken()\">nextToken()</a> will stop reading\n     * text when any other event is observed.\n     * Also, when the state was reached by calling next(), the text value will\n     * be normalized, whereas getText() will\n     * return unnormalized content in the case of nextToken(). This allows\n     * an exact roundtrip without changing line ends when examining low\n     * level events, whereas for high level applications the text is\n     * normalized appropriately.\n     *\n     * @see #next\n     * @see #nextToken\n     * @see #getText\n     ",
    "links" : [ ]
  }, {
    "name" : "CDSECT",
    "type" : "int",
    "comment" : "\n     * A CDATA sections was just read;\n     * this token is available only from calls to <a href=\"#nextToken()\">nextToken()</a>.\n     * A call to next() will accumulate various text events into a single event\n     * of type TEXT. The text contained in the CDATA section is available\n     * by calling getText().\n     *\n     * @see #nextToken\n     * @see #getText\n     ",
    "links" : [ ]
  }, {
    "name" : "ENTITY_REF",
    "type" : "int",
    "comment" : "\n     * An entity reference was just read;\n     * this token is available from <a href=\"#nextToken()\">nextToken()</a>\n     * only. The entity name is available by calling getName(). If available,\n     * the replacement text can be obtained by calling getText(); otherwise,\n     * the user is responsible for resolving the entity reference.\n     * This event type is never returned from next(); next() will\n     * accumulate the replacement text and other text\n     * events to a single TEXT event.\n     *\n     * @see #nextToken\n     * @see #getText\n     ",
    "links" : [ ]
  }, {
    "name" : "IGNORABLE_WHITESPACE",
    "type" : "int",
    "comment" : "\n     * Ignorable whitespace was just read.\n     * This token is available only from <a href=\"#nextToken()\">nextToken()</a>).\n     * For non-validating\n     * parsers, this event is only reported by nextToken() when outside\n     * the root element.\n     * Validating parsers may be able to detect ignorable whitespace at\n     * other locations.\n     * The ignorable whitespace string is available by calling getText()\n     *\n     * <p><strong>NOTE:</strong> this is different from calling the\n     *  isWhitespace() method, since text content\n     *  may be whitespace but not ignorable.\n     *\n     * Ignorable whitespace is skipped by next() automatically; this event\n     * type is never returned from next().\n     *\n     * @see #nextToken\n     * @see #getText\n     ",
    "links" : [ ]
  }, {
    "name" : "PROCESSING_INSTRUCTION",
    "type" : "int",
    "comment" : "\n     * An XML processing instruction declaration was just read. This\n     * event type is available only via <a href=\"#nextToken()\">nextToken()</a>.\n     * getText() will return text that is inside the processing instruction.\n     * Calls to next() will skip processing instructions automatically.\n     * @see #nextToken\n     * @see #getText\n     ",
    "links" : [ ]
  }, {
    "name" : "COMMENT",
    "type" : "int",
    "comment" : "\n     * An XML comment was just read. This event type is this token is\n     * available via <a href=\"#nextToken()\">nextToken()</a> only;\n     * calls to next() will skip comments automatically.\n     * The content of the comment can be accessed using the getText()\n     * method.\n     *\n     * @see #nextToken\n     * @see #getText\n     ",
    "links" : [ ]
  }, {
    "name" : "DOCDECL",
    "type" : "int",
    "comment" : "\n     * An XML document type declaration was just read. This token is\n     * available from <a href=\"#nextToken()\">nextToken()</a> only.\n     * The unparsed text inside the doctype is available via\n     * the getText() method.\n     *\n     * @see #nextToken\n     * @see #getText\n     ",
    "links" : [ ]
  }, {
    "name" : "TYPES",
    "type" : "String[]",
    "comment" : "\n     * This array can be used to convert the event type integer constants\n     * such as START_TAG or TEXT to\n     * to a string. For example, the value of TYPES[START_TAG] is\n     * the string \"START_TAG\".\n     *\n     * This array is intended for diagnostic output only. Relying\n     * on the contents of the array may be dangerous since malicious\n     * applications may alter the array, although it is final, due\n     * to limitations of the Java language.\n     ",
    "links" : [ ]
  }, {
    "name" : "FEATURE_PROCESS_NAMESPACES",
    "type" : "String",
    "comment" : "\n     * This feature determines whether the parser processes\n     * namespaces. As for all features, the default value is false.\n     * <p><strong>NOTE:</strong> The value can not be changed during\n     * parsing an must be set before parsing.\n     *\n     * @see #getFeature\n     * @see #setFeature\n     ",
    "links" : [ ]
  }, {
    "name" : "FEATURE_REPORT_NAMESPACE_ATTRIBUTES",
    "type" : "String",
    "comment" : "\n     * This feature determines whether namespace attributes are\n     * exposed via the attribute access methods. Like all features,\n     * the default value is false. This feature cannot be changed\n     * during parsing.\n     *\n     * @see #getFeature\n     * @see #setFeature\n     ",
    "links" : [ ]
  }, {
    "name" : "FEATURE_PROCESS_DOCDECL",
    "type" : "String",
    "comment" : "\n     * This feature determines whether the document declaration\n     * is processed. If set to false,\n     * the DOCDECL event type is reported by nextToken()\n     * and ignored by next().\n     *\n     * If this feature is activated, then the document declaration\n     * must be processed by the parser.\n     *\n     * <p><strong>Please note:</strong> If the document type declaration\n     * was ignored, entity references may cause exceptions\n     * later in the parsing process.\n     * The default value of this feature is false. It cannot be changed\n     * during parsing.\n     *\n     * @see #getFeature\n     * @see #setFeature\n     ",
    "links" : [ ]
  }, {
    "name" : "FEATURE_VALIDATION",
    "type" : "String",
    "comment" : "\n     * If this feature is activated, all validation errors as\n     * defined in the XML 1.0 specification are reported.\n     * This implies that FEATURE_PROCESS_DOCDECL is true and both, the\n     * internal and external document type declaration will be processed.\n     * <p><strong>Please Note:</strong> This feature can not be changed\n     * during parsing. The default value is false.\n     *\n     * @see #getFeature\n     * @see #setFeature\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : " void setFeature(String name, boolean state) throws XmlPullParserException",
    "returnType" : "void",
    "comment" : "\n     * Use this call to change the general behaviour of the parser,\n     * such as namespace processing or doctype declaration handling.\n     * This method must be called before the first call to next or\n     * nextToken. Otherwise, an exception is thrown.\n     * <p>Example: call setFeature(FEATURE_PROCESS_NAMESPACES, true) in order\n     * to switch on namespace processing. The initial settings correspond\n     * to the properties requested from the XML Pull Parser factory.\n     * If none were requested, all features are deactivated by default.\n     *\n     * @exception XmlPullParserException If the feature is not supported or can not be set\n     * @exception IllegalArgumentException If string with the feature name is null\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean getFeature(String name)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void setProperty(String name, Object value) throws XmlPullParserException",
    "returnType" : "void",
    "comment" : "\n     * Set the value of a property.\n     *\n     * The property name is any fully-qualified URI.\n     *\n     * @exception XmlPullParserException If the property is not supported or can not be set\n     * @exception IllegalArgumentException If string with the property name is null\n     ",
    "links" : [ ]
  }, {
    "name" : " Object getProperty(String name)",
    "returnType" : "Object",
    "comment" : "\n     * Look up the value of a property.\n     *\n     * The property name is any fully-qualified URI.\n     * <p><strong>NOTE:</strong> unknown properties are <strong>always</strong>\n     * returned as null.\n     *\n     * @param name The name of property to be retrieved.\n     * @return The value of named property.\n     ",
    "links" : [ ]
  }, {
    "name" : " void setInput(Reader in) throws XmlPullParserException",
    "returnType" : "void",
    "comment" : "\n     * Set the input source for parser to the given reader and\n     * resets the parser. The event type is set to the initial value\n     * START_DOCUMENT.\n     * Setting the reader to null will just stop parsing and\n     * reset parser state,\n     * allowing the parser to free internal resources\n     * such as parsing buffers.\n     ",
    "links" : [ ]
  }, {
    "name" : " void setInput(InputStream inputStream, String inputEncoding) throws XmlPullParserException",
    "returnType" : "void",
    "comment" : "\n     * Sets the input stream the parser is going to process.\n     * This call resets the parser state and sets the event type\n     * to the initial value START_DOCUMENT.\n     *\n     * <p><strong>NOTE:</strong> If an input encoding string is passed,\n     *  it MUST be used. Otherwise,\n     *  if inputEncoding is null, the parser SHOULD try to determine\n     *  input encoding following XML 1.0 specification (see below).\n     *  If encoding detection is supported then following feature\n     *  <a href=\"http://xmlpull.org/v1/doc/features.html#detect-encoding\">http://xmlpull.org/v1/doc/features.html#detect-encoding</a>\n     *  MUST be true and otherwise it must be false.\n     *\n     * @param inputStream contains a raw byte input stream of possibly\n     *     unknown encoding (when inputEncoding is null).\n     *\n     * @param inputEncoding if not null it MUST be used as encoding for inputStream\n     ",
    "links" : [ ]
  }, {
    "name" : " String getInputEncoding()",
    "returnType" : "String",
    "comment" : "\n     * Returns the input encoding if known, null otherwise.\n     * If setInput(InputStream, inputEncoding) was called with an inputEncoding\n     * value other than null, this value must be returned\n     * from this method. Otherwise, if inputEncoding is null and\n     * the parser supports the encoding detection feature\n     * (http://xmlpull.org/v1/doc/features.html#detect-encoding),\n     * it must return the detected encoding.\n     * If setInput(Reader) was called, null is returned.\n     * After first call to next if XML declaration was present this method\n     * will return encoding declared.\n     ",
    "links" : [ ]
  }, {
    "name" : " void defineEntityReplacementText(String entityName, String replacementText) throws XmlPullParserException",
    "returnType" : "void",
    "comment" : "\n     * Set new value for entity replacement text as defined in\n     * <a href=\"http://www.w3.org/TR/REC-xml#intern-replacement\">XML 1.0 Section 4.5\n     * Construction of Internal Entity Replacement Text</a>.\n     * If FEATURE_PROCESS_DOCDECL or FEATURE_VALIDATION are set, calling this\n     * function will result in an exception -- when processing of DOCDECL is\n     * enabled, there is no need to the entity replacement text manually.\n     *\n     * <p>The motivation for this function is to allow very small\n     * implementations of XMLPULL that will work in J2ME environments.\n     * Though these implementations may not be able to process the document type\n     * declaration, they still can work with known DTDs by using this function.\n     *\n     * <p><b>Please notes:</b> The given value is used literally as replacement text\n     * and it corresponds to declaring entity in DTD that has all special characters\n     * escaped: left angle bracket is replaced with &amp;lt;, ampersand with &amp;amp;\n     * and so on.\n     *\n     * <p><b>Note:</b> The given value is the literal replacement text and must not\n     * contain any other entity reference (if it contains any entity reference\n     * there will be no further replacement).\n     *\n     * <p><b>Note:</b> The list of pre-defined entity names will\n     * always contain standard XML entities such as\n     * amp (&amp;amp;), lt (&amp;lt;), gt (&amp;gt;), quot (&amp;quot;), and apos (&amp;apos;).\n     * Those cannot be redefined by this method!\n     *\n     * @see #setInput\n     * @see #FEATURE_PROCESS_DOCDECL\n     * @see #FEATURE_VALIDATION\n     ",
    "links" : [ ]
  }, {
    "name" : " int getNamespaceCount(int depth) throws XmlPullParserException",
    "returnType" : "int",
    "comment" : "\n     * Returns the numbers of elements in the namespace stack for the given\n     * depth.\n     * If namespaces are not enabled, 0 is returned.\n     *\n     * <p><b>NOTE:</b> when parser is on END_TAG then it is allowed to call\n     *  this function with getDepth()+1 argument to retrieve position of namespace\n     *  prefixes and URIs that were declared on corresponding START_TAG.\n     * <p><b>NOTE:</b> to retrieve list of namespaces declared in current element:<pre>\n     *       XmlPullParser pp = ...\n     *       int nsStart = pp.getNamespaceCount(pp.getDepth()-1);\n     *       int nsEnd = pp.getNamespaceCount(pp.getDepth());\n     *       for (int i = nsStart; i < nsEnd; i++) {\n     *          String prefix = pp.getNamespacePrefix(i);\n     *          String ns = pp.getNamespaceUri(i);\n     *           // ...\n     *      }\n     * </pre>\n     *\n     * @see #getNamespacePrefix\n     * @see #getNamespaceUri\n     * @see #getNamespace()\n     * @see #getNamespace(String)\n     ",
    "links" : [ ]
  }, {
    "name" : " String getNamespacePrefix(int pos) throws XmlPullParserException",
    "returnType" : "String",
    "comment" : "\n     * Returns the namespace prefix for the given position\n     * in the namespace stack.\n     * Default namespace declaration (xmlns='...') will have null as prefix.\n     * If the given index is out of range, an exception is thrown.\n     * <p><b>Please note:</b> when the parser is on an END_TAG,\n     * namespace prefixes that were declared\n     * in the corresponding START_TAG are still accessible\n     * although they are no longer in scope.\n     ",
    "links" : [ ]
  }, {
    "name" : " String getNamespaceUri(int pos) throws XmlPullParserException",
    "returnType" : "String",
    "comment" : "\n     * Returns the namespace URI for the given position in the\n     * namespace stack\n     * If the position is out of range, an exception is thrown.\n     * <p><b>NOTE:</b> when parser is on END_TAG then namespace prefixes that were declared\n     *  in corresponding START_TAG are still accessible even though they are not in scope\n     ",
    "links" : [ ]
  }, {
    "name" : " String getNamespace(String prefix)",
    "returnType" : "String",
    "comment" : "\n     * Returns the URI corresponding to the given prefix,\n     * depending on current state of the parser.\n     *\n     * <p>If the prefix was not declared in the current scope,\n     * null is returned. The default namespace is included\n     * in the namespace table and is available via\n     * getNamespace (null).\n     *\n     * <p>This method is a convenience method for\n     *\n     * <pre>\n     *  for (int i = getNamespaceCount(getDepth ())-1; i >= 0; i--) {\n     *   if (getNamespacePrefix(i).equals( prefix )) {\n     *     return getNamespaceUri(i);\n     *   }\n     *  }\n     *  return null;\n     * </pre>\n     *\n     * <p><strong>Please note:</strong> parser implementations\n     * may provide more efficient lookup, e.g. using a Hashtable.\n     * The 'xml' prefix is bound to \"http://www.w3.org/XML/1998/namespace\", as\n     * defined in the\n     * <a href=\"http://www.w3.org/TR/REC-xml-names/#ns-using\">Namespaces in XML</a>\n     * specification. Analogous, the 'xmlns' prefix is resolved to\n     * <a href=\"http://www.w3.org/2000/xmlns/\">http://www.w3.org/2000/xmlns/</a>\n     *\n     * @see #getNamespaceCount\n     * @see #getNamespacePrefix\n     * @see #getNamespaceUri\n     ",
    "links" : [ ]
  }, {
    "name" : " int getDepth()",
    "returnType" : "int",
    "comment" : "\n     * Returns the current depth of the element.\n     * Outside the root element, the depth is 0. The\n     * depth is incremented by 1 when a start tag is reached.\n     * The depth is decremented AFTER the end tag\n     * event was observed.\n     *\n     * <pre>\n     * &lt;!-- outside --&gt;     0\n     * &lt;root>                  1\n     *   sometext                 1\n     *     &lt;foobar&gt;         2\n     *     &lt;/foobar&gt;        2\n     * &lt;/root&gt;              1\n     * &lt;!-- outside --&gt;     0\n     * </pre>\n     ",
    "links" : [ ]
  }, {
    "name" : " String getPositionDescription()",
    "returnType" : "String",
    "comment" : "\n     * Returns a short text describing the current parser state, including\n     * the position, a\n     * description of the current event and the data source if known.\n     * This method is especially useful to provide meaningful\n     * error messages and for debugging purposes.\n     ",
    "links" : [ ]
  }, {
    "name" : " int getLineNumber()",
    "returnType" : "int",
    "comment" : "\n     * Returns the current line number, starting from 1.\n     * When the parser does not know the current line number\n     * or can not determine it,  -1 is returned (e.g. for WBXML).\n     *\n     * @return current line number or -1 if unknown.\n     ",
    "links" : [ ]
  }, {
    "name" : " int getColumnNumber()",
    "returnType" : "int",
    "comment" : "\n     * Returns the current column number, starting from 1.\n     * When the parser does not know the current column number\n     * or can not determine it,  -1 is returned (e.g. for WBXML).\n     *\n     * @return current column number or -1 if unknown.\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean isWhitespace() throws XmlPullParserException",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether the current TEXT event contains only whitespace\n     * characters.\n     * For IGNORABLE_WHITESPACE, this is always true.\n     * For TEXT and CDSECT, false is returned when the current event text\n     * contains at least one non-white space character. For any other\n     * event type an exception is thrown.\n     *\n     * <p><b>Please note:</b> non-validating parsers are not\n     * able to distinguish whitespace and ignorable whitespace,\n     * except from whitespace outside the root element. Ignorable\n     * whitespace is reported as separate event, which is exposed\n     * via nextToken only.\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : " String getText()",
    "returnType" : "String",
    "comment" : "\n     * Returns the text content of the current event as String.\n     * The value returned depends on current event type,\n     * for example for TEXT event it is element content\n     * (this is typical case when next() is used).\n     *\n     * See description of nextToken() for detailed description of\n     * possible returned values for different types of events.\n     *\n     * <p><strong>NOTE:</strong> in case of ENTITY_REF, this method returns\n     * the entity replacement text (or null if not available). This is\n     * the only case where\n     * getText() and getTextCharacters() return different values.\n     *\n     * @see #getEventType\n     * @see #next\n     * @see #nextToken\n     ",
    "links" : [ ]
  }, {
    "name" : " char[] getTextCharacters(int[] holderForStartAndLength)",
    "returnType" : "char[]",
    "comment" : "\n     * Returns the buffer that contains the text of the current event,\n     * as well as the start offset and length relevant for the current\n     * event. See getText(), next() and nextToken() for description of possible returned values.\n     *\n     * <p><strong>Please note:</strong> this buffer must not\n     * be modified and its content MAY change after a call to\n     * next() or nextToken(). This method will always return the\n     * same value as getText(), except for ENTITY_REF. In the case\n     * of ENTITY ref, getText() returns the replacement text and\n     * this method returns the actual input buffer containing the\n     * entity name.\n     * If getText() returns null, this method returns null as well and\n     * the values returned in the holder array MUST be -1 (both start\n     * and length).\n     *\n     * @see #getText\n     * @see #next\n     * @see #nextToken\n     *\n     * @param holderForStartAndLength Must hold an 2-element int array\n     * into which the start offset and length values will be written.\n     * @return char buffer that contains the text of the current event\n     *  (null if the current event has no text associated).\n     ",
    "links" : [ ]
  }, {
    "name" : " String getNamespace()",
    "returnType" : "String",
    "comment" : "\n     * Returns the namespace URI of the current element.\n     * The default namespace is represented\n     * as empty string.\n     * If namespaces are not enabled, an empty String (\"\") is always returned.\n     * The current event must be START_TAG or END_TAG; otherwise,\n     * null is returned.\n     ",
    "links" : [ ]
  }, {
    "name" : " String getName()",
    "returnType" : "String",
    "comment" : "\n     * For START_TAG or END_TAG events, the (local) name of the current\n     * element is returned when namespaces are enabled. When namespace\n     * processing is disabled, the raw name is returned.\n     * For ENTITY_REF events, the entity name is returned.\n     * If the current event is not START_TAG, END_TAG, or ENTITY_REF,\n     * null is returned.\n     * <p><b>Please note:</b> To reconstruct the raw element name\n     *  when namespaces are enabled and the prefix is not null,\n     * you will need to  add the prefix and a colon to localName..\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : " String getPrefix()",
    "returnType" : "String",
    "comment" : "\n     * Returns the prefix of the current element.\n     * If the element is in the default namespace (has no prefix),\n     * null is returned.\n     * If namespaces are not enabled, or the current event\n     * is not  START_TAG or END_TAG, null is returned.\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean isEmptyElementTag() throws XmlPullParserException",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the current event is START_TAG and the tag\n     * is degenerated\n     * (e.g. &lt;foobar/&gt;).\n     * <p><b>NOTE:</b> if the parser is not on START_TAG, an exception\n     * will be thrown.\n     ",
    "links" : [ ]
  }, {
    "name" : " int getAttributeCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of attributes of the current start tag, or\n     * -1 if the current event type is not START_TAG\n     *\n     * @see #getAttributeNamespace\n     * @see #getAttributeName\n     * @see #getAttributePrefix\n     * @see #getAttributeValue\n     ",
    "links" : [ ]
  }, {
    "name" : " String getAttributeNamespace(int index)",
    "returnType" : "String",
    "comment" : "\n     * Returns the namespace URI of the attribute\n     * with the given index (starts from 0).\n     * Returns an empty string (\"\") if namespaces are not enabled\n     * or the attribute has no namespace.\n     * Throws an IndexOutOfBoundsException if the index is out of range\n     * or the current event type is not START_TAG.\n     *\n     * <p><strong>NOTE:</strong> if FEATURE_REPORT_NAMESPACE_ATTRIBUTES is set\n     * then namespace attributes (xmlns:ns='...') must be reported\n     * with namespace\n     * <a href=\"http://www.w3.org/2000/xmlns/\">http://www.w3.org/2000/xmlns/</a>\n     * (visit this URL for description!).\n     * The default namespace attribute (xmlns=\"...\") will be reported with empty namespace.\n     * <p><strong>NOTE:</strong>The xml prefix is bound as defined in\n     * <a href=\"http://www.w3.org/TR/REC-xml-names/#ns-using\">Namespaces in XML</a>\n     * specification to \"http://www.w3.org/XML/1998/namespace\".\n     *\n     * @param index zero-based index of attribute\n     * @return attribute namespace,\n     *   empty string (\"\") is returned  if namespaces processing is not enabled or\n     *   namespaces processing is enabled but attribute has no namespace (it has no prefix).\n     ",
    "links" : [ ]
  }, {
    "name" : " String getAttributeName(int index)",
    "returnType" : "String",
    "comment" : "\n     * Returns the local name of the specified attribute\n     * if namespaces are enabled or just attribute name if namespaces are disabled.\n     * Throws an IndexOutOfBoundsException if the index is out of range\n     * or current event type is not START_TAG.\n     *\n     * @param index zero-based index of attribute\n     * @return attribute name (null is never returned)\n     ",
    "links" : [ ]
  }, {
    "name" : " String getAttributePrefix(int index)",
    "returnType" : "String",
    "comment" : "\n     * Returns the prefix of the specified attribute\n     * Returns null if the element has no prefix.\n     * If namespaces are disabled it will always return null.\n     * Throws an IndexOutOfBoundsException if the index is out of range\n     * or current event type is not START_TAG.\n     *\n     * @param index zero-based index of attribute\n     * @return attribute prefix or null if namespaces processing is not enabled.\n     ",
    "links" : [ ]
  }, {
    "name" : " String getAttributeType(int index)",
    "returnType" : "String",
    "comment" : "\n     * Returns the type of the specified attribute\n     * If parser is non-validating it MUST return CDATA.\n     *\n     * @param index zero-based index of attribute\n     * @return attribute type (null is never returned)\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean isAttributeDefault(int index)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns if the specified attribute was not in input was declared in XML.\n     * If parser is non-validating it MUST always return false.\n     * This information is part of XML infoset:\n     *\n     * @param index zero-based index of attribute\n     * @return false if attribute was in input\n     ",
    "links" : [ ]
  }, {
    "name" : " String getAttributeValue(int index)",
    "returnType" : "String",
    "comment" : "\n     * Returns the given attributes value.\n     * Throws an IndexOutOfBoundsException if the index is out of range\n     * or current event type is not START_TAG.\n     *\n     * <p><strong>NOTE:</strong> attribute value must be normalized\n     * (including entity replacement text if PROCESS_DOCDECL is false) as described in\n     * <a href=\"http://www.w3.org/TR/REC-xml#AVNormalize\">XML 1.0 section\n     * 3.3.3 Attribute-Value Normalization</a>\n     *\n     * @see #defineEntityReplacementText\n     *\n     * @param index zero-based index of attribute\n     * @return value of attribute (null is never returned)\n     ",
    "links" : [ ]
  }, {
    "name" : " String getAttributeValue(String namespace, String name)",
    "returnType" : "String",
    "comment" : "\n     * Returns the attributes value identified by namespace URI and namespace localName.\n     * If namespaces are disabled namespace must be null.\n     * If current event type is not START_TAG then IndexOutOfBoundsException will be thrown.\n     *\n     * <p><strong>NOTE:</strong> attribute value must be normalized\n     * (including entity replacement text if PROCESS_DOCDECL is false) as described in\n     * <a href=\"http://www.w3.org/TR/REC-xml#AVNormalize\">XML 1.0 section\n     * 3.3.3 Attribute-Value Normalization</a>\n     *\n     * @see #defineEntityReplacementText\n     *\n     * @param namespace Namespace of the attribute if namespaces are enabled otherwise must be null\n     * @param name If namespaces enabled local name of attribute otherwise just attribute name\n     * @return value of attribute or null if attribute with given name does not exist\n     ",
    "links" : [ ]
  }, {
    "name" : " int getEventType() throws XmlPullParserException",
    "returnType" : "int",
    "comment" : "\n     * Returns the type of the current event (START_TAG, END_TAG, TEXT, etc.)\n     *\n     * @see #next()\n     * @see #nextToken()\n     ",
    "links" : [ ]
  }, {
    "name" : " int next() throws XmlPullParserException, IOException",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " int nextToken() throws XmlPullParserException, IOException",
    "returnType" : "int",
    "comment" : "\n     * This method works similarly to next() but will expose\n     * additional event types (COMMENT, CDSECT, DOCDECL, ENTITY_REF, PROCESSING_INSTRUCTION, or\n     * IGNORABLE_WHITESPACE) if they are available in input.\n     *\n     * <p>If special feature\n     * <a href=\"http://xmlpull.org/v1/doc/features.html#xml-roundtrip\">FEATURE_XML_ROUNDTRIP</a>\n     * (identified by URI: http://xmlpull.org/v1/doc/features.html#xml-roundtrip)\n     * is enabled it is possible to do XML document round trip ie. reproduce\n     * exectly on output the XML input using getText():\n     * returned content is always unnormalized (exactly as in input).\n     * Otherwise returned content is end-of-line normalized as described\n     * <a href=\"http://www.w3.org/TR/REC-xml#sec-line-ends\">XML 1.0 End-of-Line Handling</a>\n     * and. Also when this feature is enabled exact content of START_TAG, END_TAG,\n     * DOCDECL and PROCESSING_INSTRUCTION is available.\n     *\n     * <p>Here is the list of tokens that can be  returned from nextToken()\n     * and what getText() and getTextCharacters() returns:<dl>\n     * <dt>START_DOCUMENT<dd>null\n     * <dt>END_DOCUMENT<dd>null\n     * <dt>START_TAG<dd>null unless FEATURE_XML_ROUNDTRIP\n     *   enabled and then returns XML tag, ex: &lt;tag attr='val'>\n     * <dt>END_TAG<dd>null unless FEATURE_XML_ROUNDTRIP\n     *  id enabled and then returns XML tag, ex: &lt;/tag>\n     * <dt>TEXT<dd>return element content.\n     *  <br>Note: that element content may be delivered in multiple consecutive TEXT events.\n     * <dt>IGNORABLE_WHITESPACE<dd>return characters that are determined to be ignorable white\n     * space. If the FEATURE_XML_ROUNDTRIP is enabled all whitespace content outside root\n     * element will always reported as IGNORABLE_WHITESPACE otherwise reporting is optional.\n     *  <br>Note: that element content may be delivered in multiple consecutive IGNORABLE_WHITESPACE events.\n     * <dt>CDSECT<dd>\n     * return text <em>inside</em> CDATA\n     *  (ex. 'fo&lt;o' from &lt;!CDATA[fo&lt;o]]>)\n     * <dt>PROCESSING_INSTRUCTION<dd>\n     *  if FEATURE_XML_ROUNDTRIP is true\n     *  return exact PI content ex: 'pi foo' from &lt;?pi foo?>\n     *  otherwise it may be exact PI content or concatenation of PI target,\n     * space and data so for example for\n     *   &lt;?target    data?> string &quot;target data&quot; may\n     *       be returned if FEATURE_XML_ROUNDTRIP is false.\n     * <dt>COMMENT<dd>return comment content ex. 'foo bar' from &lt;!--foo bar-->\n     * <dt>ENTITY_REF<dd>getText() MUST return entity replacement text if PROCESS_DOCDECL is false\n     * otherwise getText() MAY return null,\n     * additionally getTextCharacters() MUST return entity name\n     * (for example 'entity_name' for &amp;entity_name;).\n     * <br><b>NOTE:</b> this is the only place where value returned from getText() and\n     *   getTextCharacters() <b>are different</b>\n     * <br><b>NOTE:</b> it is user responsibility to resolve entity reference\n     *    if PROCESS_DOCDECL is false and there is no entity replacement text set in\n     *    defineEntityReplacementText() method (getText() will be null)\n     * <br><b>NOTE:</b> character entities (ex. &amp;#32;) and standard entities such as\n     *  &amp;amp; &amp;lt; &amp;gt; &amp;quot; &amp;apos; are reported as well\n     *  and are <b>not</b> reported as TEXT tokens but as ENTITY_REF tokens!\n     *  This requirement is added to allow to do roundtrip of XML documents!\n     * <dt>DOCDECL<dd>\n     * if FEATURE_XML_ROUNDTRIP is true or PROCESS_DOCDECL is false\n     * then return what is inside of DOCDECL for example it returns:<pre>\n     * &quot; titlepage SYSTEM \"http://www.foo.bar/dtds/typo.dtd\"\n     * [&lt;!ENTITY % active.links \"INCLUDE\">]&quot;</pre>\n     * <p>for input document that contained:<pre>\n     * &lt;!DOCTYPE titlepage SYSTEM \"http://www.foo.bar/dtds/typo.dtd\"\n     * [&lt;!ENTITY % active.links \"INCLUDE\">]></pre>\n     * otherwise if FEATURE_XML_ROUNDTRIP is false and PROCESS_DOCDECL is true\n     *    then what is returned is undefined (it may be even null)\n     * </dd>\n     * </dl>\n     *\n     * <p><strong>NOTE:</strong> there is no guarantee that there will only one TEXT or\n     * IGNORABLE_WHITESPACE event from nextToken() as parser may chose to deliver element content in\n     * multiple tokens (dividing element content into chunks)\n     *\n     * <p><strong>NOTE:</strong> whether returned text of token is end-of-line normalized\n     *  is depending on FEATURE_XML_ROUNDTRIP.\n     *\n     * <p><strong>NOTE:</strong> XMLDecl (&lt;?xml ...?&gt;) is not reported but its content\n     * is available through optional properties (see class description above).\n     *\n     * @see #next\n     * @see #START_TAG\n     * @see #TEXT\n     * @see #END_TAG\n     * @see #END_DOCUMENT\n     * @see #COMMENT\n     * @see #DOCDECL\n     * @see #PROCESSING_INSTRUCTION\n     * @see #ENTITY_REF\n     * @see #IGNORABLE_WHITESPACE\n     ",
    "links" : [ ]
  }, {
    "name" : " void require(int type, String namespace, String name) throws XmlPullParserException, IOException",
    "returnType" : "void",
    "comment" : "\n     * Test if the current event is of the given type and if the\n     * namespace and name do match. null will match any namespace\n     * and any name. If the test is not passed, an exception is\n     * thrown. The exception text indicates the parser position,\n     * the expected event and the current event that is not meeting the\n     * requirement.\n     *\n     * <p>Essentially it does this\n     * <pre>\n     *  if (type != getEventType()\n     *  || (namespace != null &amp;&amp;  !namespace.equals( getNamespace () ) )\n     *  || (name != null &amp;&amp;  !name.equals( getName() ) ) )\n     *     throw new XmlPullParserException( \"expected \"+ TYPES[ type ]+getPositionDescription());\n     * </pre>\n     ",
    "links" : [ ]
  }, {
    "name" : " String nextText() throws XmlPullParserException, IOException",
    "returnType" : "String",
    "comment" : "\n     * If current event is START_TAG then if next element is TEXT then element content is returned\n     * or if next event is END_TAG then empty string is returned, otherwise exception is thrown.\n     * After calling this function successfully parser will be positioned on END_TAG.\n     *\n     * <p>The motivation for this function is to allow to parse consistently both\n     * empty elements and elements that has non empty content, for example for input: <ol>\n     * <li>&lt;tag&gt;foo&lt;/tag&gt;\n     * <li>&lt;tag&gt;&lt;/tag&gt; (which is equivalent to &lt;tag/&gt;\n     * both input can be parsed with the same code:\n     * <pre>\n     *   p.nextTag()\n     *   p.requireEvent(p.START_TAG, \"\", \"tag\");\n     *   String content = p.nextText();\n     *   p.requireEvent(p.END_TAG, \"\", \"tag\");\n     * </pre>\n     * This function together with nextTag make it very easy to parse XML that has\n     * no mixed content.\n     *\n     *\n     * <p>Essentially it does this\n     * <pre>\n     *  if(getEventType() != START_TAG) {\n     *     throw new XmlPullParserException(\n     *       \"parser must be on START_TAG to read next text\", this, null);\n     *  }\n     *  int eventType = next();\n     *  if(eventType == TEXT) {\n     *     String result = getText();\n     *     eventType = next();\n     *     if(eventType != END_TAG) {\n     *       throw new XmlPullParserException(\n     *          \"event TEXT it must be immediately followed by END_TAG\", this, null);\n     *      }\n     *      return result;\n     *  } else if(eventType == END_TAG) {\n     *     return \"\";\n     *  } else {\n     *     throw new XmlPullParserException(\n     *       \"parser must be on START_TAG or TEXT to read text\", this, null);\n     *  }\n     * </pre>\n     *\n     * <p><strong>Warning:</strong> Prior to API level 14, the pull parser returned by {@code\n     * android.util.Xml} did not always advance to the END_TAG event when this method was called.\n     * Work around by using manually advancing after calls to nextText(): <pre>\n     *  String text = xpp.nextText();\n     *  if (xpp.getEventType() != XmlPullParser.END_TAG) {\n     *      xpp.next();\n     *  }\n     * </pre>\n     ",
    "links" : [ ]
  }, {
    "name" : " int nextTag() throws XmlPullParserException, IOException",
    "returnType" : "int",
    "comment" : "\n     * Call next() and return event if it is START_TAG or END_TAG\n     * otherwise throw an exception.\n     * It will skip whitespace TEXT before actual tag if any.\n     *\n     * <p>essentially it does this\n     * <pre>\n     *   int eventType = next();\n     *   if(eventType == TEXT &amp;&amp;  isWhitespace()) {   // skip whitespace\n     *      eventType = next();\n     *   }\n     *   if (eventType != START_TAG &amp;&amp;  eventType != END_TAG) {\n     *      throw new XmlPullParserException(\"expected start or end tag\", this, null);\n     *   }\n     *   return eventType;\n     * </pre>\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ " void setFeature(String name, boolean state) throws XmlPullParserException", " boolean getFeature(String name)", " void setProperty(String name, Object value) throws XmlPullParserException", " Object getProperty(String name)", " void setInput(Reader in) throws XmlPullParserException", " void setInput(InputStream inputStream, String inputEncoding) throws XmlPullParserException", " String getInputEncoding()", " void defineEntityReplacementText(String entityName, String replacementText) throws XmlPullParserException", " int getNamespaceCount(int depth) throws XmlPullParserException", " String getNamespacePrefix(int pos) throws XmlPullParserException", " String getNamespaceUri(int pos) throws XmlPullParserException", " String getNamespace(String prefix)", " int getDepth()", " String getPositionDescription()", " int getLineNumber()", " int getColumnNumber()", " boolean isWhitespace() throws XmlPullParserException", " String getText()", " char[] getTextCharacters(int[] holderForStartAndLength)", " String getNamespace()", " String getName()", " String getPrefix()", " boolean isEmptyElementTag() throws XmlPullParserException", " int getAttributeCount()", " String getAttributeNamespace(int index)", " String getAttributeName(int index)", " String getAttributePrefix(int index)", " String getAttributeType(int index)", " boolean isAttributeDefault(int index)", " String getAttributeValue(int index)", " String getAttributeValue(String namespace, String name)", " int getEventType() throws XmlPullParserException", " int next() throws XmlPullParserException, IOException", " int nextToken() throws XmlPullParserException, IOException", " void require(int type, String namespace, String name) throws XmlPullParserException, IOException", " String nextText() throws XmlPullParserException, IOException", " int nextTag() throws XmlPullParserException, IOException" ],
  "variableNames" : [ "NO_NAMESPACE", "START_DOCUMENT", "END_DOCUMENT", "START_TAG", "END_TAG", "TEXT", "CDSECT", "ENTITY_REF", "IGNORABLE_WHITESPACE", "PROCESSING_INSTRUCTION", "COMMENT", "DOCDECL", "TYPES", "FEATURE_PROCESS_NAMESPACES", "FEATURE_REPORT_NAMESPACE_ATTRIBUTES", "FEATURE_PROCESS_DOCDECL", "FEATURE_VALIDATION" ]
}