{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/util/regex/Matcher.java",
  "packageName" : "java.util.regex",
  "className" : "Matcher",
  "comment" : "",
  "links" : [ ],
  "variables" : [ {
    "name" : "parentPattern",
    "type" : "Pattern",
    "comment" : "\n     * The Pattern object that created this Matcher.\n     ",
    "links" : [ ]
  }, {
    "name" : "groups",
    "type" : "int[]",
    "comment" : "\n     * Holds the offsets for the most recent match.\n     ",
    "links" : [ ]
  }, {
    "name" : "from",
    "type" : "int",
    "comment" : "\n     * The range within the sequence that is to be matched (between  0\n     * and text.length()).\n     ",
    "links" : [ ]
  }, {
    "name" : "to",
    "type" : "int",
    "comment" : "\n     * The range within the sequence that is to be matched (between  0\n     * and text.length()).\n     ",
    "links" : [ ]
  }, {
    "name" : "text",
    "type" : "String",
    "comment" : "\n     * Holds the input text.\n     ",
    "links" : [ ]
  }, {
    "name" : "matchFound",
    "type" : "boolean",
    "comment" : "\n     * Reflects whether a match has been found during the most recent find\n     * operation.\n     ",
    "links" : [ ]
  }, {
    "name" : "nativeMatcher",
    "type" : "MatcherNative",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "appendPos",
    "type" : "int",
    "comment" : "\n     * The index of the last position appended in a substitution.\n     ",
    "links" : [ ]
  }, {
    "name" : "originalInput",
    "type" : "CharSequence",
    "comment" : "\n     * Holds the original CharSequence for use in {@link #reset}. {@link #text} is used during\n     * matching. Note that CharSequence is mutable while String is not, so reset can cause the input\n     * to match to change.\n     ",
    "links" : [ "#reset", "#text" ]
  }, {
    "name" : "transparentBounds",
    "type" : "boolean",
    "comment" : "\n     * If transparentBounds is true then the boundaries of this\n     * matcher's region are transparent to lookahead, lookbehind,\n     * and boundary matching constructs that try to see beyond them.\n     ",
    "links" : [ ]
  }, {
    "name" : "anchoringBounds",
    "type" : "boolean",
    "comment" : "\n     * If anchoringBounds is true then the boundaries of this\n     * matcher's region match anchors such as ^ and $.\n     ",
    "links" : [ ]
  }, {
    "name" : "modCount",
    "type" : "int",
    "comment" : "\n     * Number of times this matcher's state has been modified\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_INVALID_GROUP_REFERENCE",
    "type" : "long",
    "comment" : "\n     * Since Android 14, {@link Matcher} becomes stricter for the replacement syntax and\n     * group references used by its methods, e.g. {@link #appendReplacement(StringBuffer, String)}.\n     *\n     * This flag is enabled for apps targeting Android 14+.\n     *\n     * @hide\n     ",
    "links" : [ "#appendReplacement(StringBuffer", "java.util.regex.Matcher" ]
  } ],
  "methods" : [ {
    "name" : "public Pattern pattern()",
    "returnType" : "Pattern",
    "comment" : "\n     * Returns the pattern that is interpreted by this matcher.\n     *\n     * @return  The pattern for which this matcher was created\n     ",
    "links" : [ ]
  }, {
    "name" : "public MatchResult toMatchResult()",
    "returnType" : "MatchResult",
    "comment" : "\n     * Returns the match state of this matcher as a {@link MatchResult}.\n     * The result is unaffected by subsequent operations performed upon this\n     * matcher.\n     *\n     * @return  a {@code MatchResult} with the state of this matcher\n     * @throws IllegalStateException if no match is found.\n     * @since 1.5\n     ",
    "links" : [ "java.util.regex.MatchResult" ]
  }, {
    "name" : "private MatchResult toMatchResult(String text)",
    "returnType" : "MatchResult",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Matcher usePattern(Pattern newPattern)",
    "returnType" : "Matcher",
    "comment" : "\n     * Changes the {@code Pattern} that this {@code Matcher} uses to\n     * find matches with.\n     *\n     * <p> This method causes this matcher to lose information\n     * about the groups of the last match that occurred. The\n     * matcher's position in the input is maintained and its\n     * last append position is unaffected.</p>\n     *\n     * @param  newPattern\n     *         The new pattern used by this matcher\n     * @return  This matcher\n     * @throws  IllegalArgumentException\n     *          If newPattern is {@code null}\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public Matcher reset()",
    "returnType" : "Matcher",
    "comment" : "\n     * Resets this matcher.\n     *\n     * <p> Resetting a matcher discards all of its explicit state information\n     * and sets its append position to zero. The matcher's region is set to the\n     * default region, which is its entire character sequence. The anchoring\n     * and transparency of this matcher's region boundaries are unaffected.\n     *\n     * @return  This matcher\n     ",
    "links" : [ ]
  }, {
    "name" : "public Matcher reset(CharSequence input)",
    "returnType" : "Matcher",
    "comment" : "\n     * Resets this matcher with a new input sequence.\n     *\n     * <p> Resetting a matcher discards all of its explicit state information\n     * and sets its append position to zero.  The matcher's region is set to\n     * the default region, which is its entire character sequence.  The\n     * anchoring and transparency of this matcher's region boundaries are\n     * unaffected.\n     *\n     * @param  input\n     *         The new input character sequence\n     *\n     * @return  This matcher\n     ",
    "links" : [ ]
  }, {
    "name" : "public int start()",
    "returnType" : "int",
    "comment" : "\n     * Returns the start index of the previous match.\n     *\n     * @return  The index of the first character matched\n     *\n     * @throws  IllegalStateException\n     *          If no match has yet been attempted,\n     *          or if the previous match operation failed\n     ",
    "links" : [ ]
  }, {
    "name" : "public int start(int group)",
    "returnType" : "int",
    "comment" : "\n     * Returns the start index of the subsequence captured by the given group\n     * during the previous match operation.\n     *\n     * <p> <a href=\"Pattern.html#cg\">Capturing groups</a> are indexed from left\n     * to right, starting at one.  Group zero denotes the entire pattern, so\n     * the expression <i>m.</i>{@code start(0)} is equivalent to\n     * <i>m.</i>{@code start()}.  </p>\n     *\n     * @param  group\n     *         The index of a capturing group in this matcher's pattern\n     *\n     * @return  The index of the first character captured by the group,\n     *          or {@code -1} if the match was successful but the group\n     *          itself did not match anything\n     *\n     * @throws  IllegalStateException\n     *          If no match has yet been attempted,\n     *          or if the previous match operation failed\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If there is no capturing group in the pattern\n     *          with the given index\n     ",
    "links" : [ ]
  }, {
    "name" : "public int start(String name)",
    "returnType" : "int",
    "comment" : "\n     * Returns the start index of the subsequence captured by the given\n     * <a href=\"Pattern.html#groupname\">named-capturing group</a> during the\n     * previous match operation.\n     *\n     * @param  name\n     *         The name of a named-capturing group in this matcher's pattern\n     *\n     * @return  The index of the first character captured by the group,\n     *          or {@code -1} if the match was successful but the group\n     *          itself did not match anything\n     *\n     * @throws  IllegalStateException\n     *          If no match has yet been attempted,\n     *          or if the previous match operation failed\n     *\n     * @throws  IllegalArgumentException\n     *          If there is no capturing group in the pattern\n     *          with the given name\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public int end()",
    "returnType" : "int",
    "comment" : "\n     * Returns the offset after the last character matched.\n     *\n     * @return  The offset after the last character matched\n     *\n     * @throws  IllegalStateException\n     *          If no match has yet been attempted,\n     *          or if the previous match operation failed\n     ",
    "links" : [ ]
  }, {
    "name" : "public int end(int group)",
    "returnType" : "int",
    "comment" : "\n     * Returns the offset after the last character of the subsequence\n     * captured by the given group during the previous match operation.\n     *\n     * <p> <a href=\"Pattern.html#cg\">Capturing groups</a> are indexed from left\n     * to right, starting at one.  Group zero denotes the entire pattern, so\n     * the expression <i>m.</i>{@code end(0)} is equivalent to\n     * <i>m.</i>{@code end()}.  </p>\n     *\n     * @param  group\n     *         The index of a capturing group in this matcher's pattern\n     *\n     * @return  The offset after the last character captured by the group,\n     *          or {@code -1} if the match was successful\n     *          but the group itself did not match anything\n     *\n     * @throws  IllegalStateException\n     *          If no match has yet been attempted,\n     *          or if the previous match operation failed\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If there is no capturing group in the pattern\n     *          with the given index\n     ",
    "links" : [ ]
  }, {
    "name" : "public int end(String name)",
    "returnType" : "int",
    "comment" : "\n     * Returns the offset after the last character of the subsequence\n     * captured by the given <a href=\"Pattern.html#groupname\">named-capturing\n     * group</a> during the previous match operation.\n     *\n     * @param  name\n     *         The name of a named-capturing group in this matcher's pattern\n     *\n     * @return  The offset after the last character captured by the group,\n     *          or {@code -1} if the match was successful\n     *          but the group itself did not match anything\n     *\n     * @throws  IllegalStateException\n     *          If no match has yet been attempted,\n     *          or if the previous match operation failed\n     *\n     * @throws  IllegalArgumentException\n     *          If there is no capturing group in the pattern\n     *          with the given name\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public String group()",
    "returnType" : "String",
    "comment" : "\n     * Returns the input subsequence matched by the previous match.\n     *\n     * <p> For a matcher <i>m</i> with input sequence <i>s</i>,\n     * the expressions <i>m.</i>{@code group()} and\n     * <i>s.</i>{@code substring(}<i>m.</i>{@code start(),}&nbsp;<i>m.</i>\n     * {@code end())} are equivalent.  </p>\n     *\n     * <p> Note that some patterns, for example {@code a*}, match the empty\n     * string.  This method will return the empty string when the pattern\n     * successfully matches the empty string in the input.  </p>\n     *\n     * @return The (possibly empty) subsequence matched by the previous match,\n     *         in string form\n     *\n     * @throws  IllegalStateException\n     *          If no match has yet been attempted,\n     *          or if the previous match operation failed\n     ",
    "links" : [ ]
  }, {
    "name" : "public String group(int group)",
    "returnType" : "String",
    "comment" : "\n     * Returns the input subsequence captured by the given group during the\n     * previous match operation.\n     *\n     * <p> For a matcher <i>m</i>, input sequence <i>s</i>, and group index\n     * <i>g</i>, the expressions <i>m.</i>{@code group(}<i>g</i>{@code )} and\n     * <i>s.</i>{@code substring(}<i>m.</i>{@code start(}<i>g</i>{@code\n     * ),}&nbsp;<i>m.</i>{@code end(}<i>g</i>{@code ))}\n     * are equivalent.  </p>\n     *\n     * <p> <a href=\"Pattern.html#cg\">Capturing groups</a> are indexed from left\n     * to right, starting at one.  Group zero denotes the entire pattern, so\n     * the expression {@code m.group(0)} is equivalent to {@code m.group()}.\n     * </p>\n     *\n     * <p> If the match was successful but the group specified failed to match\n     * any part of the input sequence, then {@code null} is returned. Note\n     * that some groups, for example {@code (a*)}, match the empty string.\n     * This method will return the empty string when such a group successfully\n     * matches the empty string in the input.  </p>\n     *\n     * @param  group\n     *         The index of a capturing group in this matcher's pattern\n     *\n     * @return  The (possibly empty) subsequence captured by the group\n     *          during the previous match, or {@code null} if the group\n     *          failed to match part of the input\n     *\n     * @throws  IllegalStateException\n     *          If no match has yet been attempted,\n     *          or if the previous match operation failed\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If there is no capturing group in the pattern\n     *          with the given index\n     ",
    "links" : [ ]
  }, {
    "name" : "public String group(String name)",
    "returnType" : "String",
    "comment" : "\n     * Returns the input subsequence captured by the given\n     * <a href=\"Pattern.html#groupname\">named-capturing group</a> during the\n     * previous match operation.\n     *\n     * <p> If the match was successful but the group specified failed to match\n     * any part of the input sequence, then {@code null} is returned. Note\n     * that some groups, for example {@code (a*)}, match the empty string.\n     * This method will return the empty string when such a group successfully\n     * matches the empty string in the input.  </p>\n     *\n     * @param  name\n     *         The name of a named-capturing group in this matcher's pattern\n     *\n     * @return  The (possibly empty) subsequence captured by the named group\n     *          during the previous match, or {@code null} if the group\n     *          failed to match part of the input\n     *\n     * @throws  IllegalStateException\n     *          If no match has yet been attempted,\n     *          or if the previous match operation failed\n     *\n     * @throws  IllegalArgumentException\n     *          If there is no capturing group in the pattern\n     *          with the given name\n     * @since 1.7\n     ",
    "links" : [ ]
  }, {
    "name" : "public int groupCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of capturing groups in this matcher's pattern.\n     *\n     * <p> Group zero denotes the entire pattern by convention. It is not\n     * included in this count.\n     *\n     * <p> Any non-negative integer smaller than or equal to the value\n     * returned by this method is guaranteed to be a valid group index for\n     * this matcher.  </p>\n     *\n     * @return The number of capturing groups in this matcher's pattern\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean matches()",
    "returnType" : "boolean",
    "comment" : "\n     * Attempts to match the entire region against the pattern.\n     *\n     * <p> If the match succeeds then more information can be obtained via the\n     * {@code start}, {@code end}, and {@code group} methods.  </p>\n     *\n     * @return  {@code true} if, and only if, the entire region sequence\n     *          matches this matcher's pattern\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean find()",
    "returnType" : "boolean",
    "comment" : "\n     * Attempts to find the next subsequence of the input sequence that matches\n     * the pattern.\n     *\n     * <p> This method starts at the beginning of this matcher's region, or, if\n     * a previous invocation of the method was successful and the matcher has\n     * not since been reset, at the first character not matched by the previous\n     * match.\n     *\n     * <p> If the match succeeds then more information can be obtained via the\n     * {@code start}, {@code end}, and {@code group} methods.  </p>\n     *\n     * @return  {@code true} if, and only if, a subsequence of the input\n     *          sequence matches this matcher's pattern\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean find(int start)",
    "returnType" : "boolean",
    "comment" : "\n     * Resets this matcher and then attempts to find the next subsequence of\n     * the input sequence that matches the pattern, starting at the specified\n     * index.\n     *\n     * <p> If the match succeeds then more information can be obtained via the\n     * {@code start}, {@code end}, and {@code group} methods, and subsequent\n     * invocations of the {@link #find()} method will start at the first\n     * character not matched by this match.  </p>\n     *\n     * @param start the index to start searching for a match\n     * @throws  IndexOutOfBoundsException\n     *          If start is less than zero or if start is greater than the\n     *          length of the input sequence.\n     *\n     * @return  {@code true} if, and only if, a subsequence of the input\n     *          sequence starting at the given index matches this matcher's\n     *          pattern\n     ",
    "links" : [ "#find()" ]
  }, {
    "name" : "public boolean lookingAt()",
    "returnType" : "boolean",
    "comment" : "\n     * Attempts to match the input sequence, starting at the beginning of the\n     * region, against the pattern.\n     *\n     * <p> Like the {@link #matches matches} method, this method always starts\n     * at the beginning of the region; unlike that method, it does not\n     * require that the entire region be matched.\n     *\n     * <p> If the match succeeds then more information can be obtained via the\n     * {@code start}, {@code end}, and {@code group} methods.  </p>\n     *\n     * @return  {@code true} if, and only if, a prefix of the input\n     *          sequence matches this matcher's pattern\n     ",
    "links" : [ "#matches" ]
  }, {
    "name" : "public static String quoteReplacement(String s)",
    "returnType" : "String",
    "comment" : "\n     * Returns a literal replacement {@code String} for the specified\n     * {@code String}.\n     *\n     * This method produces a {@code String} that will work\n     * as a literal replacement {@code s} in the\n     * {@code appendReplacement} method of the {@link Matcher} class.\n     * The {@code String} produced will match the sequence of characters\n     * in {@code s} treated as a literal sequence. Slashes ('\\') and\n     * dollar signs ('$') will be given no special meaning.\n     *\n     * @param  s The string to be literalized\n     * @return  A literal string replacement\n     * @since 1.5\n     ",
    "links" : [ "java.util.regex.Matcher" ]
  }, {
    "name" : "public Matcher appendReplacement(StringBuffer sb, String replacement)",
    "returnType" : "Matcher",
    "comment" : "\n     * Implements a non-terminal append-and-replace step.\n     *\n     * <p> This method performs the following actions: </p>\n     *\n     * <ol>\n     *\n     *   <li><p> It reads characters from the input sequence, starting at the\n     *   append position, and appends them to the given string buffer.  It\n     *   stops after reading the last character preceding the previous match,\n     *   that is, the character at index {@link\n     *   #start()}&nbsp;{@code -}&nbsp;{@code 1}.  </p></li>\n     *\n     *   <li><p> It appends the given replacement string to the string buffer.\n     *   </p></li>\n     *\n     *   <li><p> It sets the append position of this matcher to the index of\n     *   the last character matched, plus one, that is, to {@link #end()}.\n     *   </p></li>\n     *\n     * </ol>\n     *\n     * <p> The replacement string may contain references to subsequences\n     * captured during the previous match: Each occurrence of\n     * <code>${</code><i>name</i><code>}</code> or {@code $}<i>g</i>\n     * will be replaced by the result of evaluating the corresponding\n     * {@link #group(String) group(name)} or {@link #group(int) group(g)}\n     * respectively. For {@code $}<i>g</i>,\n     * the first number after the {@code $} is always treated as part of\n     * the group reference. Subsequent numbers are incorporated into g if\n     * they would form a legal group reference. Only the numerals '0'\n     * through '9' are considered as potential components of the group\n     * reference. If the second group matched the string {@code \"foo\"}, for\n     * example, then passing the replacement string {@code \"$2bar\"} would\n     * cause {@code \"foobar\"} to be appended to the string buffer. A dollar\n     * sign ({@code $}) may be included as a literal in the replacement\n     * string by preceding it with a backslash ({@code \\$}).\n     *\n     * <p> Note that backslashes ({@code \\}) and dollar signs ({@code $}) in\n     * the replacement string may cause the results to be different than if it\n     * were being treated as a literal replacement string. Dollar signs may be\n     * treated as references to captured subsequences as described above, and\n     * backslashes are used to escape literal characters in the replacement\n     * string.\n     *\n     * <p> This method is intended to be used in a loop together with the\n     * {@link #appendTail(StringBuffer) appendTail} and {@link #find() find}\n     * methods.  The following code, for example, writes {@code one dog two dogs\n     * in the yard} to the standard-output stream: </p>\n     *\n     * <blockquote><pre>\n     * Pattern p = Pattern.compile(\"cat\");\n     * Matcher m = p.matcher(\"one cat two cats in the yard\");\n     * StringBuffer sb = new StringBuffer();\n     * while (m.find()) {\n     *     m.appendReplacement(sb, \"dog\");\n     * }\n     * m.appendTail(sb);\n     * System.out.println(sb.toString());</pre></blockquote>\n     *\n     * @param  sb\n     *         The target string buffer\n     *\n     * @param  replacement\n     *         The replacement string\n     *\n     * @return  This matcher\n     *\n     * @throws  IllegalStateException\n     *          If no match has yet been attempted,\n     *          or if the previous match operation failed\n     *\n     * @throws  IllegalArgumentException\n     *          If the replacement string refers to a named-capturing\n     *          group that does not exist in the pattern\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If the replacement string refers to a capturing group\n     *          that does not exist in the pattern\n     ",
    "links" : [ "#group(String)", "#start()", "#end()", "#appendTail(StringBuffer)", "#find()", "#group(int)" ]
  }, {
    "name" : "private void appendReplacementInternal(StringBuilder sb, String replacement)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void appendEvaluated(StringBuilder buffer, String s)",
    "returnType" : "void",
    "comment" : "\n     * Internal helper method to append a given string to a given string buffer.\n     * If the string contains any references to groups, these are replaced by\n     * the corresponding group's contents.\n     *\n     * @param buffer the string builder.\n     * @param s the string to append.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Matcher appendReplacement(StringBuilder sb, String replacement)",
    "returnType" : "Matcher",
    "comment" : "\n     * Implements a non-terminal append-and-replace step.\n     *\n     * <p> This method performs the following actions: </p>\n     *\n     * <ol>\n     *\n     *   <li><p> It reads characters from the input sequence, starting at the\n     *   append position, and appends them to the given string builder.  It\n     *   stops after reading the last character preceding the previous match,\n     *   that is, the character at index {@link\n     *   #start()}&nbsp;{@code -}&nbsp;{@code 1}.  </p></li>\n     *\n     *   <li><p> It appends the given replacement string to the string builder.\n     *   </p></li>\n     *\n     *   <li><p> It sets the append position of this matcher to the index of\n     *   the last character matched, plus one, that is, to {@link #end()}.\n     *   </p></li>\n     *\n     * </ol>\n     *\n     * <p> The replacement string may contain references to subsequences\n     * captured during the previous match: Each occurrence of\n     * {@code $}<i>g</i> will be replaced by the result of\n     * evaluating {@link #group(int) group}{@code (}<i>g</i>{@code )}.\n     * The first number after the {@code $} is always treated as part of\n     * the group reference. Subsequent numbers are incorporated into g if\n     * they would form a legal group reference. Only the numerals '0'\n     * through '9' are considered as potential components of the group\n     * reference. If the second group matched the string {@code \"foo\"}, for\n     * example, then passing the replacement string {@code \"$2bar\"} would\n     * cause {@code \"foobar\"} to be appended to the string builder. A dollar\n     * sign ({@code $}) may be included as a literal in the replacement\n     * string by preceding it with a backslash ({@code \\$}).\n     *\n     * <p> Note that backslashes ({@code \\}) and dollar signs ({@code $}) in\n     * the replacement string may cause the results to be different than if it\n     * were being treated as a literal replacement string. Dollar signs may be\n     * treated as references to captured subsequences as described above, and\n     * backslashes are used to escape literal characters in the replacement\n     * string.\n     *\n     * <p> This method is intended to be used in a loop together with the\n     * {@link #appendTail(StringBuilder) appendTail} and\n     * {@link #find() find} methods. The following code, for example, writes\n     * {@code one dog two dogs in the yard} to the standard-output stream: </p>\n     *\n     * <blockquote><pre>\n     * Pattern p = Pattern.compile(\"cat\");\n     * Matcher m = p.matcher(\"one cat two cats in the yard\");\n     * StringBuilder sb = new StringBuilder();\n     * while (m.find()) {\n     *     m.appendReplacement(sb, \"dog\");\n     * }\n     * m.appendTail(sb);\n     * System.out.println(sb.toString());</pre></blockquote>\n     *\n     * @param  sb\n     *         The target string builder\n     * @param  replacement\n     *         The replacement string\n     * @return  This matcher\n     *\n     * @throws  IllegalStateException\n     *          If no match has yet been attempted,\n     *          or if the previous match operation failed\n     * @throws  IllegalArgumentException\n     *          If the replacement string refers to a named-capturing\n     *          group that does not exist in the pattern\n     * @throws  IndexOutOfBoundsException\n     *          If the replacement string refers to a capturing group\n     *          that does not exist in the pattern\n     * @since 9\n     ",
    "links" : [ "#start()", "#end()", "#appendTail(StringBuilder)", "#find()", "#group(int)" ]
  }, {
    "name" : "public StringBuilder appendExpandedReplacement(String replacement, StringBuilder result)",
    "returnType" : "StringBuilder",
    "comment" : "\n     * Processes replacement string to replace group references with\n     * groups.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public StringBuffer appendTail(StringBuffer sb)",
    "returnType" : "StringBuffer",
    "comment" : "\n     * Implements a terminal append-and-replace step.\n     *\n     * <p> This method reads characters from the input sequence, starting at\n     * the append position, and appends them to the given string buffer.  It is\n     * intended to be invoked after one or more invocations of the {@link\n     * #appendReplacement(StringBuffer, String) appendReplacement} method in\n     * order to copy the remainder of the input sequence.  </p>\n     *\n     * @param  sb\n     *         The target string buffer\n     *\n     * @return  The target string buffer\n     ",
    "links" : [ "#appendReplacement(StringBuffer" ]
  }, {
    "name" : "public StringBuilder appendTail(StringBuilder sb)",
    "returnType" : "StringBuilder",
    "comment" : "\n     * Implements a terminal append-and-replace step.\n     *\n     * <p> This method reads characters from the input sequence, starting at\n     * the append position, and appends them to the given string builder.  It is\n     * intended to be invoked after one or more invocations of the {@link\n     * #appendReplacement(StringBuilder, String)\n     * appendReplacement} method in order to copy the remainder of the input\n     * sequence.  </p>\n     *\n     * @param  sb\n     *         The target string builder\n     *\n     * @return  The target string builder\n     *\n     * @since 9\n     ",
    "links" : [ "#appendReplacement(StringBuilder" ]
  }, {
    "name" : "public String replaceAll(String replacement)",
    "returnType" : "String",
    "comment" : "\n     * Replaces every subsequence of the input sequence that matches the\n     * pattern with the given replacement string.\n     *\n     * <p> This method first resets this matcher.  It then scans the input\n     * sequence looking for matches of the pattern.  Characters that are not\n     * part of any match are appended directly to the result string; each match\n     * is replaced in the result by the replacement string.  The replacement\n     * string may contain references to captured subsequences as in the {@link\n     * #appendReplacement appendReplacement} method.\n     *\n     * <p> Note that backslashes ({@code \\}) and dollar signs ({@code $}) in\n     * the replacement string may cause the results to be different than if it\n     * were being treated as a literal replacement string. Dollar signs may be\n     * treated as references to captured subsequences as described above, and\n     * backslashes are used to escape literal characters in the replacement\n     * string.\n     *\n     * <p> Given the regular expression {@code a*b}, the input\n     * {@code \"aabfooaabfooabfoob\"}, and the replacement string\n     * {@code \"-\"}, an invocation of this method on a matcher for that\n     * expression would yield the string {@code \"-foo-foo-foo-\"}.\n     *\n     * <p> Invoking this method changes this matcher's state.  If the matcher\n     * is to be used in further matching operations then it should first be\n     * reset.  </p>\n     *\n     * @param  replacement\n     *         The replacement string\n     *\n     * @return  The string constructed by replacing each matching subsequence\n     *          by the replacement string, substituting captured subsequences\n     *          as needed\n     ",
    "links" : [ "#appendReplacement" ]
  }, {
    "name" : "public String replaceAll(Function<MatchResult, String> replacer)",
    "returnType" : "String",
    "comment" : "\n     * Replaces every subsequence of the input sequence that matches the\n     * pattern with the result of applying the given replacer function to the\n     * match result of this matcher corresponding to that subsequence.\n     * Exceptions thrown by the function are relayed to the caller.\n     *\n     * <p> This method first resets this matcher.  It then scans the input\n     * sequence looking for matches of the pattern.  Characters that are not\n     * part of any match are appended directly to the result string; each match\n     * is replaced in the result by the applying the replacer function that\n     * returns a replacement string.  Each replacement string may contain\n     * references to captured subsequences as in the {@link #appendReplacement\n     * appendReplacement} method.\n     *\n     * <p> Note that backslashes ({@code \\}) and dollar signs ({@code $}) in\n     * a replacement string may cause the results to be different than if it\n     * were being treated as a literal replacement string. Dollar signs may be\n     * treated as references to captured subsequences as described above, and\n     * backslashes are used to escape literal characters in the replacement\n     * string.\n     *\n     * <p> Given the regular expression {@code dog}, the input\n     * {@code \"zzzdogzzzdogzzz\"}, and the function\n     * {@code mr -> mr.group().toUpperCase()}, an invocation of this method on\n     * a matcher for that expression would yield the string\n     * {@code \"zzzDOGzzzDOGzzz\"}.\n     *\n     * <p> Invoking this method changes this matcher's state.  If the matcher\n     * is to be used in further matching operations then it should first be\n     * reset.  </p>\n     *\n     * <p> The replacer function should not modify this matcher's state during\n     * replacement.  This method will, on a best-effort basis, throw a\n     * {@link java.util.ConcurrentModificationException} if such modification is\n     * detected.\n     *\n     * <p> The state of each match result passed to the replacer function is\n     * guaranteed to be constant only for the duration of the replacer function\n     * call and only if the replacer function does not modify this matcher's\n     * state.\n     *\n     * @implNote\n     * This implementation applies the replacer function to this matcher, which\n     * is an instance of {@code MatchResult}.\n     *\n     * @param  replacer\n     *         The function to be applied to the match result of this matcher\n     *         that returns a replacement string.\n     * @return  The string constructed by replacing each matching subsequence\n     *          with the result of applying the replacer function to that\n     *          matched subsequence, substituting captured subsequences as\n     *          needed.\n     * @throws NullPointerException if the replacer function is null\n     * @throws ConcurrentModificationException if it is detected, on a\n     *         best-effort basis, that the replacer function modified this\n     *         matcher's state\n     * @since 9\n     ",
    "links" : [ "#appendReplacementappendReplacement", "java.util.ConcurrentModificationException" ]
  }, {
    "name" : "public Stream<MatchResult> results()",
    "returnType" : "Stream<MatchResult>",
    "comment" : "\n     * Returns a stream of match results for each subsequence of the input\n     * sequence that matches the pattern.  The match results occur in the\n     * same order as the matching subsequences in the input sequence.\n     *\n     * <p> Each match result is produced as if by {@link #toMatchResult()}.\n     *\n     * <p> This method does not reset this matcher.  Matching starts on\n     * initiation of the terminal stream operation either at the beginning of\n     * this matcher's region, or, if the matcher has not since been reset, at\n     * the first character not matched by a previous match.\n     *\n     * <p> If the matcher is to be used for further matching operations after\n     * the terminal stream operation completes then it should be first reset.\n     *\n     * <p> This matcher's state should not be modified during execution of the\n     * returned stream's pipeline.  The returned stream's source\n     * {@code Spliterator} is <em>fail-fast</em> and will, on a best-effort\n     * basis, throw a {@link java.util.ConcurrentModificationException} if such\n     * modification is detected.\n     *\n     * @return a sequential stream of match results.\n     * @since 9\n     ",
    "links" : [ "java.util.ConcurrentModificationException", "#toMatchResult()" ]
  }, {
    "name" : "public String replaceFirst(String replacement)",
    "returnType" : "String",
    "comment" : "\n     * Replaces the first subsequence of the input sequence that matches the\n     * pattern with the given replacement string.\n     *\n     * <p> This method first resets this matcher.  It then scans the input\n     * sequence looking for a match of the pattern.  Characters that are not\n     * part of the match are appended directly to the result string; the match\n     * is replaced in the result by the replacement string.  The replacement\n     * string may contain references to captured subsequences as in the {@link\n     * #appendReplacement appendReplacement} method.\n     *\n     * <p>Note that backslashes ({@code \\}) and dollar signs ({@code $}) in\n     * the replacement string may cause the results to be different than if it\n     * were being treated as a literal replacement string. Dollar signs may be\n     * treated as references to captured subsequences as described above, and\n     * backslashes are used to escape literal characters in the replacement\n     * string.\n     *\n     * <p> Given the regular expression {@code dog}, the input\n     * {@code \"zzzdogzzzdogzzz\"}, and the replacement string\n     * {@code \"cat\"}, an invocation of this method on a matcher for that\n     * expression would yield the string {@code \"zzzcatzzzdogzzz\"}.  </p>\n     *\n     * <p> Invoking this method changes this matcher's state.  If the matcher\n     * is to be used in further matching operations then it should first be\n     * reset.  </p>\n     *\n     * @param  replacement\n     *         The replacement string\n     * @return  The string constructed by replacing the first matching\n     *          subsequence by the replacement string, substituting captured\n     *          subsequences as needed\n     ",
    "links" : [ "#appendReplacement" ]
  }, {
    "name" : "public String replaceFirst(Function<MatchResult, String> replacer)",
    "returnType" : "String",
    "comment" : "\n     * Replaces the first subsequence of the input sequence that matches the\n     * pattern with the result of applying the given replacer function to the\n     * match result of this matcher corresponding to that subsequence.\n     * Exceptions thrown by the replace function are relayed to the caller.\n     *\n     * <p> This method first resets this matcher.  It then scans the input\n     * sequence looking for a match of the pattern.  Characters that are not\n     * part of the match are appended directly to the result string; the match\n     * is replaced in the result by the applying the replacer function that\n     * returns a replacement string.  The replacement string may contain\n     * references to captured subsequences as in the {@link #appendReplacement\n     * appendReplacement} method.\n     *\n     * <p>Note that backslashes ({@code \\}) and dollar signs ({@code $}) in\n     * the replacement string may cause the results to be different than if it\n     * were being treated as a literal replacement string. Dollar signs may be\n     * treated as references to captured subsequences as described above, and\n     * backslashes are used to escape literal characters in the replacement\n     * string.\n     *\n     * <p> Given the regular expression {@code dog}, the input\n     * {@code \"zzzdogzzzdogzzz\"}, and the function\n     * {@code mr -> mr.group().toUpperCase()}, an invocation of this method on\n     * a matcher for that expression would yield the string\n     * {@code \"zzzDOGzzzdogzzz\"}.\n     *\n     * <p> Invoking this method changes this matcher's state.  If the matcher\n     * is to be used in further matching operations then it should first be\n     * reset.\n     *\n     * <p> The replacer function should not modify this matcher's state during\n     * replacement.  This method will, on a best-effort basis, throw a\n     * {@link java.util.ConcurrentModificationException} if such modification is\n     * detected.\n     *\n     * <p> The state of the match result passed to the replacer function is\n     * guaranteed to be constant only for the duration of the replacer function\n     * call and only if the replacer function does not modify this matcher's\n     * state.\n     *\n     * @implNote\n     * This implementation applies the replacer function to this matcher, which\n     * is an instance of {@code MatchResult}.\n     *\n     * @param  replacer\n     *         The function to be applied to the match result of this matcher\n     *         that returns a replacement string.\n     * @return  The string constructed by replacing the first matching\n     *          subsequence with the result of applying the replacer function to\n     *          the matched subsequence, substituting captured subsequences as\n     *          needed.\n     * @throws NullPointerException if the replacer function is null\n     * @throws ConcurrentModificationException if it is detected, on a\n     *         best-effort basis, that the replacer function modified this\n     *         matcher's state\n     * @since 9\n     ",
    "links" : [ "#appendReplacementappendReplacement", "java.util.ConcurrentModificationException" ]
  }, {
    "name" : "public Matcher region(int start, int end)",
    "returnType" : "Matcher",
    "comment" : "\n     * Sets the limits of this matcher's region. The region is the part of the\n     * input sequence that will be searched to find a match. Invoking this\n     * method resets the matcher, and then sets the region to start at the\n     * index specified by the {@code start} parameter and end at the\n     * index specified by the {@code end} parameter.\n     *\n     * <p>Depending on the transparency and anchoring being used (see\n     * {@link #useTransparentBounds(boolean) useTransparentBounds} and\n     * {@link #useAnchoringBounds(boolean) useAnchoringBounds}), certain\n     * constructs such as anchors may behave differently at or around the\n     * boundaries of the region.\n     *\n     * @param  start\n     *         The index to start searching at (inclusive)\n     * @param  end\n     *         The index to end searching at (exclusive)\n     * @throws  IndexOutOfBoundsException\n     *          If start or end is less than zero, if\n     *          start is greater than the length of the input sequence, if\n     *          end is greater than the length of the input sequence, or if\n     *          start is greater than end.\n     * @return  this matcher\n     * @since 1.5\n     ",
    "links" : [ "#useTransparentBounds(boolean)", "#useAnchoringBounds(boolean)" ]
  }, {
    "name" : "public int regionStart()",
    "returnType" : "int",
    "comment" : "\n     * Reports the start index of this matcher's region. The\n     * searches this matcher conducts are limited to finding matches\n     * within {@link #regionStart() regionStart} (inclusive) and\n     * {@link #regionEnd() regionEnd} (exclusive).\n     *\n     * @return  The starting point of this matcher's region\n     * @since 1.5\n     ",
    "links" : [ "#regionEnd()", "#regionStart()" ]
  }, {
    "name" : "public int regionEnd()",
    "returnType" : "int",
    "comment" : "\n     * Reports the end index (exclusive) of this matcher's region.\n     * The searches this matcher conducts are limited to finding matches\n     * within {@link #regionStart() regionStart} (inclusive) and\n     * {@link #regionEnd() regionEnd} (exclusive).\n     *\n     * @return  the ending point of this matcher's region\n     * @since 1.5\n     ",
    "links" : [ "#regionEnd()", "#regionStart()" ]
  }, {
    "name" : "public boolean hasTransparentBounds()",
    "returnType" : "boolean",
    "comment" : "\n     * Queries the transparency of region bounds for this matcher.\n     *\n     * <p> This method returns {@code true} if this matcher uses\n     * <i>transparent</i> bounds, {@code false} if it uses <i>opaque</i>\n     * bounds.\n     *\n     * <p> See {@link #useTransparentBounds(boolean) useTransparentBounds} for a\n     * description of transparent and opaque bounds.\n     *\n     * <p> By default, a matcher uses opaque region boundaries.\n     *\n     * @return {@code true} iff this matcher is using transparent bounds,\n     *         {@code false} otherwise.\n     * @see java.util.regex.Matcher#useTransparentBounds(boolean)\n     * @since 1.5\n     ",
    "links" : [ "#useTransparentBounds(boolean)" ]
  }, {
    "name" : "public Matcher useTransparentBounds(boolean b)",
    "returnType" : "Matcher",
    "comment" : "\n     * Sets the transparency of region bounds for this matcher.\n     *\n     * <p> Invoking this method with an argument of {@code true} will set this\n     * matcher to use <i>transparent</i> bounds. If the boolean\n     * argument is {@code false}, then <i>opaque</i> bounds will be used.\n     *\n     * <p> Using transparent bounds, the boundaries of this\n     * matcher's region are transparent to lookahead, lookbehind,\n     * and boundary matching constructs. Those constructs can see beyond the\n     * boundaries of the region to see if a match is appropriate.\n     *\n     * <p> Using opaque bounds, the boundaries of this matcher's\n     * region are opaque to lookahead, lookbehind, and boundary matching\n     * constructs that may try to see beyond them. Those constructs cannot\n     * look past the boundaries so they will fail to match anything outside\n     * of the region.\n     *\n     * <p> By default, a matcher uses opaque bounds.\n     *\n     * @param  b a boolean indicating whether to use opaque or transparent\n     *         regions\n     * @return this matcher\n     * @see java.util.regex.Matcher#hasTransparentBounds\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasAnchoringBounds()",
    "returnType" : "boolean",
    "comment" : "\n     * Queries the anchoring of region bounds for this matcher.\n     *\n     * <p> This method returns {@code true} if this matcher uses\n     * <i>anchoring</i> bounds, {@code false} otherwise.\n     *\n     * <p> See {@link #useAnchoringBounds(boolean) useAnchoringBounds} for a\n     * description of anchoring bounds.\n     *\n     * <p> By default, a matcher uses anchoring region boundaries.\n     *\n     * @return {@code true} iff this matcher is using anchoring bounds,\n     *         {@code false} otherwise.\n     * @see java.util.regex.Matcher#useAnchoringBounds(boolean)\n     * @since 1.5\n     ",
    "links" : [ "#useAnchoringBounds(boolean)" ]
  }, {
    "name" : "public Matcher useAnchoringBounds(boolean b)",
    "returnType" : "Matcher",
    "comment" : "\n     * Sets the anchoring of region bounds for this matcher.\n     *\n     * <p> Invoking this method with an argument of {@code true} will set this\n     * matcher to use <i>anchoring</i> bounds. If the boolean\n     * argument is {@code false}, then <i>non-anchoring</i> bounds will be\n     * used.\n     *\n     * <p> Using anchoring bounds, the boundaries of this\n     * matcher's region match anchors such as ^ and $.\n     *\n     * <p> Without anchoring bounds, the boundaries of this\n     * matcher's region will not match anchors such as ^ and $.\n     *\n     * <p> By default, a matcher uses anchoring region boundaries.\n     *\n     * @param  b a boolean indicating whether or not to use anchoring bounds.\n     * @return this matcher\n     * @see java.util.regex.Matcher#hasAnchoringBounds\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "\n     * <p>Returns the string representation of this matcher. The\n     * string representation of a {@code Matcher} contains information\n     * that may be useful for debugging. The exact format is unspecified.\n     *\n     * @return  The string representation of this matcher\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hitEnd()",
    "returnType" : "boolean",
    "comment" : "\n     * <p>Returns true if the end of input was hit by the search engine in\n     * the last match operation performed by this matcher.\n     *\n     * <p>When this method returns true, then it is possible that more input\n     * would have changed the result of the last search.\n     *\n     * @return  true iff the end of input was hit in the last match; false\n     *          otherwise\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean requireEnd()",
    "returnType" : "boolean",
    "comment" : "\n     * <p>Returns true if more input could change a positive match into a\n     * negative one.\n     *\n     * <p>If this method returns true, and a match was found, then more\n     * input could cause the match to be lost. If this method returns false\n     * and a match was found, then more input might change the match but the\n     * match won't be lost. If a match was not found, then requireEnd has no\n     * meaning.\n     *\n     * @return  true iff more input could change a positive match into a\n     *          negative one.\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : " int getTextLength()",
    "returnType" : "int",
    "comment" : "\n     * Returns the end index of the text.\n     *\n     * @return the index after the last character in the text\n     ",
    "links" : [ ]
  }, {
    "name" : " CharSequence getSubSequence(int beginIndex, int endIndex)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Generates a String from this matcher's input in the specified range.\n     *\n     * @param  beginIndex   the beginning index, inclusive\n     * @param  endIndex     the ending index, exclusive\n     * @return A String generated from this matcher's input\n     ",
    "links" : [ ]
  }, {
    "name" : "private Matcher reset(CharSequence input, int start, int end)",
    "returnType" : "Matcher",
    "comment" : "\n     * Resets the Matcher. A new input sequence and a new region can be\n     * specified. Results of a previous find get lost. The next attempt to find\n     * an occurrence of the Pattern in the string will start at the beginning of\n     * the region. This is the internal version of reset() to which the several\n     * public versions delegate.\n     *\n     * @param input\n     *            the input sequence.\n     * @param start\n     *            the start of the region.\n     * @param end\n     *            the end of the region.\n     *\n     * @return the matcher itself.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void resetForInput()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void ensureMatch()",
    "returnType" : "void",
    "comment" : "\n     * Makes sure that a successful match has been made. Is invoked internally\n     * from various places in the class.\n     *\n     * @throws IllegalStateException\n     *             if no successful match has been made.\n     ",
    "links" : [ ]
  }, {
    "name" : "private int getMatchedGroupIndex(String name)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ "public Pattern pattern()", "public MatchResult toMatchResult()", "private MatchResult toMatchResult(String text)", "public Matcher usePattern(Pattern newPattern)", "public Matcher reset()", "public Matcher reset(CharSequence input)", "public int start()", "public int start(int group)", "public int start(String name)", "public int end()", "public int end(int group)", "public int end(String name)", "public String group()", "public String group(int group)", "public String group(String name)", "public int groupCount()", "public boolean matches()", "public boolean find()", "public boolean find(int start)", "public boolean lookingAt()", "public static String quoteReplacement(String s)", "public Matcher appendReplacement(StringBuffer sb, String replacement)", "private void appendReplacementInternal(StringBuilder sb, String replacement)", "public void appendEvaluated(StringBuilder buffer, String s)", "public Matcher appendReplacement(StringBuilder sb, String replacement)", "public StringBuilder appendExpandedReplacement(String replacement, StringBuilder result)", "public StringBuffer appendTail(StringBuffer sb)", "public StringBuilder appendTail(StringBuilder sb)", "public String replaceAll(String replacement)", "public String replaceAll(Function<MatchResult, String> replacer)", "public Stream<MatchResult> results()", "public String replaceFirst(String replacement)", "public String replaceFirst(Function<MatchResult, String> replacer)", "public Matcher region(int start, int end)", "public int regionStart()", "public int regionEnd()", "public boolean hasTransparentBounds()", "public Matcher useTransparentBounds(boolean b)", "public boolean hasAnchoringBounds()", "public Matcher useAnchoringBounds(boolean b)", "public String toString()", "public boolean hitEnd()", "public boolean requireEnd()", " int getTextLength()", " CharSequence getSubSequence(int beginIndex, int endIndex)", "private Matcher reset(CharSequence input, int start, int end)", "private void resetForInput()", "private void ensureMatch()", "private int getMatchedGroupIndex(String name)" ],
  "variableNames" : [ "parentPattern", "groups", "from", "to", "text", "matchFound", "nativeMatcher", "appendPos", "originalInput", "transparentBounds", "anchoringBounds", "modCount", "DISALLOW_INVALID_GROUP_REFERENCE" ]
}