{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/provider/ContactsContract.java",
  "packageName" : "android.provider",
  "className" : "RawContacts",
  "comment" : "\n     * Constants for the raw contacts table, which contains one row of contact\n     * information for each person in each synced account. Sync adapters and\n     * contact management apps\n     * are the primary consumers of this API.\n     *\n     * <h3>Aggregation</h3>\n     * <p>\n     * As soon as a raw contact is inserted or whenever its constituent data\n     * changes, the provider will check if the raw contact matches other\n     * existing raw contacts and if so will aggregate it with those. The\n     * aggregation is reflected in the {@link RawContacts} table by the change of the\n     * {@link #CONTACT_ID} field, which is the reference to the aggregate contact.\n     * </p>\n     * <p>\n     * Changes to the structured name, organization, phone number, email address,\n     * or nickname trigger a re-aggregation.\n     * </p>\n     * <p>\n     * See also {@link AggregationExceptions} for a mechanism to control\n     * aggregation programmatically.\n     * </p>\n     *\n     * <h3>Operations</h3>\n     * <dl>\n     * <dt><b>Insert</b></dt>\n     * <dd>\n     * <p>\n     * Raw contacts can be inserted incrementally or in a batch.\n     * The incremental method is more traditional but less efficient.\n     * It should be used\n     * only if no {@link Data} values are available at the time the raw contact is created:\n     * <pre>\n     * ContentValues values = new ContentValues();\n     * values.put(RawContacts.ACCOUNT_TYPE, accountType);\n     * values.put(RawContacts.ACCOUNT_NAME, accountName);\n     * Uri rawContactUri = getContentResolver().insert(RawContacts.CONTENT_URI, values);\n     * long rawContactId = ContentUris.parseId(rawContactUri);\n     * </pre>\n     * </p>\n     * <p>\n     * Once {@link Data} values become available, insert those.\n     * For example, here's how you would insert a name:\n     *\n     * <pre>\n     * values.clear();\n     * values.put(Data.RAW_CONTACT_ID, rawContactId);\n     * values.put(Data.MIMETYPE, StructuredName.CONTENT_ITEM_TYPE);\n     * values.put(StructuredName.DISPLAY_NAME, &quot;Mike Sullivan&quot;);\n     * getContentResolver().insert(Data.CONTENT_URI, values);\n     * </pre>\n     * </p>\n     * <p>\n     * The batch method is by far preferred.  It inserts the raw contact and its\n     * constituent data rows in a single database transaction\n     * and causes at most one aggregation pass.\n     * <pre>\n     * ArrayList&lt;ContentProviderOperation&gt; ops =\n     *          new ArrayList&lt;ContentProviderOperation&gt;();\n     * ...\n     * int rawContactInsertIndex = ops.size();\n     * ops.add(ContentProviderOperation.newInsert(RawContacts.CONTENT_URI)\n     *          .withValue(RawContacts.ACCOUNT_TYPE, accountType)\n     *          .withValue(RawContacts.ACCOUNT_NAME, accountName)\n     *          .build());\n     *\n     * ops.add(ContentProviderOperation.newInsert(Data.CONTENT_URI)\n     *          .withValueBackReference(Data.RAW_CONTACT_ID, rawContactInsertIndex)\n     *          .withValue(Data.MIMETYPE, StructuredName.CONTENT_ITEM_TYPE)\n     *          .withValue(StructuredName.DISPLAY_NAME, &quot;Mike Sullivan&quot;)\n     *          .build());\n     *\n     * getContentResolver().applyBatch(ContactsContract.AUTHORITY, ops);\n     * </pre>\n     * </p>\n     * <p>\n     * Note the use of {@link ContentProviderOperation.Builder#withValueBackReference(String, int)}\n     * to refer to the as-yet-unknown index value of the raw contact inserted in the\n     * first operation.\n     * </p>\n     *\n     * <dt><b>Update</b></dt>\n     * <dd><p>\n     * Raw contacts can be updated incrementally or in a batch.\n     * Batch mode should be used whenever possible.\n     * The procedures and considerations are analogous to those documented above for inserts.\n     * </p></dd>\n     * <dt><b>Delete</b></dt>\n     * <dd><p>When a raw contact is deleted, all of its Data rows as well as StatusUpdates,\n     * AggregationExceptions, PhoneLookup rows are deleted automatically. When all raw\n     * contacts associated with a {@link Contacts} row are deleted, the {@link Contacts} row\n     * itself is also deleted automatically.\n     * </p>\n     * <p>\n     * The invocation of {@code resolver.delete(...)}, does not immediately delete\n     * a raw contacts row.\n     * Instead, it sets the {@link #DELETED} flag on the raw contact and\n     * removes the raw contact from its aggregate contact.\n     * The sync adapter then deletes the raw contact from the server and\n     * finalizes phone-side deletion by calling {@code resolver.delete(...)}\n     * again and passing the {@link ContactsContract#CALLER_IS_SYNCADAPTER} query parameter.<p>\n     * <p>Some sync adapters are read-only, meaning that they only sync server-side\n     * changes to the phone, but not the reverse.  If one of those raw contacts\n     * is marked for deletion, it will remain on the phone.  However it will be\n     * effectively invisible, because it will not be part of any aggregate contact.\n     * </dd>\n     *\n     * <dt><b>Query</b></dt>\n     * <dd>\n     * <p>\n     * It is easy to find all raw contacts in a Contact:\n     * <pre>\n     * Cursor c = getContentResolver().query(RawContacts.CONTENT_URI,\n     *          new String[]{RawContacts._ID},\n     *          RawContacts.CONTACT_ID + \"=?\",\n     *          new String[]{String.valueOf(contactId)}, null);\n     * </pre>\n     * </p>\n     * <p>\n     * To find raw contacts within a specific account,\n     * you can either put the account name and type in the selection or pass them as query\n     * parameters.  The latter approach is preferable, especially when you can reuse the\n     * URI:\n     * <pre>\n     * Uri rawContactUri = RawContacts.CONTENT_URI.buildUpon()\n     *          .appendQueryParameter(RawContacts.ACCOUNT_NAME, accountName)\n     *          .appendQueryParameter(RawContacts.ACCOUNT_TYPE, accountType)\n     *          .build();\n     * Cursor c1 = getContentResolver().query(rawContactUri,\n     *          RawContacts.STARRED + \"&lt;&gt;0\", null, null, null);\n     * ...\n     * Cursor c2 = getContentResolver().query(rawContactUri,\n     *          RawContacts.DELETED + \"&lt;&gt;0\", null, null, null);\n     * </pre>\n     * </p>\n     * <p>The best way to read a raw contact along with all the data associated with it is\n     * by using the {@link Entity} directory. If the raw contact has data rows,\n     * the Entity cursor will contain a row for each data row.  If the raw contact has no\n     * data rows, the cursor will still contain one row with the raw contact-level information.\n     * <pre>\n     * Uri rawContactUri = ContentUris.withAppendedId(RawContacts.CONTENT_URI, rawContactId);\n     * Uri entityUri = Uri.withAppendedPath(rawContactUri, Entity.CONTENT_DIRECTORY);\n     * Cursor c = getContentResolver().query(entityUri,\n     *          new String[]{RawContacts.SOURCE_ID, Entity.DATA_ID, Entity.MIMETYPE, Entity.DATA1},\n     *          null, null, null);\n     * try {\n     *     while (c.moveToNext()) {\n     *         String sourceId = c.getString(0);\n     *         if (!c.isNull(1)) {\n     *             String mimeType = c.getString(2);\n     *             String data = c.getString(3);\n     *             ...\n     *         }\n     *     }\n     * } finally {\n     *     c.close();\n     * }\n     * </pre>\n     * </p>\n     * </dd>\n     * </dl>\n     * <h2>Columns</h2>\n     *\n     * <table class=\"jd-sumtable\">\n     * <tr>\n     * <th colspan='4'>RawContacts</th>\n     * </tr>\n     * <tr>\n     * <td>long</td>\n     * <td>{@link #_ID}</td>\n     * <td>read-only</td>\n     * <td>Row ID. Sync adapters should try to preserve row IDs during updates. In other words,\n     * it is much better for a sync adapter to update a raw contact rather than to delete and\n     * re-insert it.</td>\n     * </tr>\n     * <tr>\n     * <td>long</td>\n     * <td>{@link #CONTACT_ID}</td>\n     * <td>read-only</td>\n     * <td>The ID of the row in the {@link ContactsContract.Contacts} table\n     * that this raw contact belongs\n     * to. Raw contacts are linked to contacts by the aggregation process, which can be controlled\n     * by the {@link #AGGREGATION_MODE} field and {@link AggregationExceptions}.</td>\n     * </tr>\n     * <tr>\n     * <td>int</td>\n     * <td>{@link #AGGREGATION_MODE}</td>\n     * <td>read/write</td>\n     * <td>A mechanism that allows programmatic control of the aggregation process. The allowed\n     * values are {@link #AGGREGATION_MODE_DEFAULT}, {@link #AGGREGATION_MODE_DISABLED}\n     * and {@link #AGGREGATION_MODE_SUSPENDED}. See also {@link AggregationExceptions}.</td>\n     * </tr>\n     * <tr>\n     * <td>int</td>\n     * <td>{@link #DELETED}</td>\n     * <td>read/write</td>\n     * <td>The \"deleted\" flag: \"0\" by default, \"1\" if the row has been marked\n     * for deletion. When {@link android.content.ContentResolver#delete} is\n     * called on a raw contact, it is marked for deletion and removed from its\n     * aggregate contact. The sync adaptor deletes the raw contact on the server and\n     * then calls ContactResolver.delete once more, this time passing the\n     * {@link ContactsContract#CALLER_IS_SYNCADAPTER} query parameter to finalize\n     * the data removal.</td>\n     * </tr>\n     * <tr>\n     * <td>int</td>\n     * <td>{@link #STARRED}</td>\n     * <td>read/write</td>\n     * <td>An indicator for favorite contacts: '1' if favorite, '0' otherwise.\n     * Changing this field immediately affects the corresponding aggregate contact:\n     * if any raw contacts in that aggregate contact are starred, then the contact\n     * itself is marked as starred.</td>\n     * </tr>\n     * <tr>\n     * <td>String</td>\n     * <td>{@link #CUSTOM_RINGTONE}</td>\n     * <td>read/write</td>\n     * <td>A custom ringtone associated with a raw contact. Typically this is the\n     * URI returned by an activity launched with the\n     * {@link android.media.RingtoneManager#ACTION_RINGTONE_PICKER} intent.\n     * To have an effect on the corresponding value of the aggregate contact, this field\n     * should be set at the time the raw contact is inserted. To set a custom\n     * ringtone on a contact, use the field {@link ContactsContract.Contacts#CUSTOM_RINGTONE\n     * Contacts.CUSTOM_RINGTONE}\n     * instead.</td>\n     * </tr>\n     * <tr>\n     * <td>int</td>\n     * <td>{@link #SEND_TO_VOICEMAIL}</td>\n     * <td>read/write</td>\n     * <td>An indicator of whether calls from this raw contact should be forwarded\n     * directly to voice mail ('1') or not ('0'). To have an effect\n     * on the corresponding value of the aggregate contact, this field\n     * should be set at the time the raw contact is inserted.</td>\n     * </tr>\n     * <tr>\n     * <td>String</td>\n     * <td>{@link #ACCOUNT_NAME}</td>\n     * <td>read/write-once</td>\n     * <td>The name of the account instance to which this row belongs, which when paired with\n     * {@link #ACCOUNT_TYPE} identifies a specific account.\n     * For example, this will be the Gmail address if it is a Google account.\n     * It should be set at the time the raw contact is inserted and never\n     * changed afterwards.</td>\n     * </tr>\n     * <tr>\n     * <td>String</td>\n     * <td>{@link #ACCOUNT_TYPE}</td>\n     * <td>read/write-once</td>\n     * <td>\n     * <p>\n     * The type of account to which this row belongs, which when paired with\n     * {@link #ACCOUNT_NAME} identifies a specific account.\n     * It should be set at the time the raw contact is inserted and never\n     * changed afterwards.\n     * </p>\n     * <p>\n     * To ensure uniqueness, new account types should be chosen according to the\n     * Java package naming convention.  Thus a Google account is of type \"com.google\".\n     * </p>\n     * </td>\n     * </tr>\n     * <tr>\n     * <td>String</td>\n     * <td>{@link #DATA_SET}</td>\n     * <td>read/write-once</td>\n     * <td>\n     * <p>\n     * The data set within the account that this row belongs to.  This allows\n     * multiple sync adapters for the same account type to distinguish between\n     * each others' data.  The combination of {@link #ACCOUNT_TYPE},\n     * {@link #ACCOUNT_NAME}, and {@link #DATA_SET} identifies a set of data\n     * that is associated with a single sync adapter.\n     * </p>\n     * <p>\n     * This is empty by default, and is completely optional.  It only needs to\n     * be populated if multiple sync adapters are entering distinct data for\n     * the same account type and account name.\n     * </p>\n     * <p>\n     * It should be set at the time the raw contact is inserted and never\n     * changed afterwards.\n     * </p>\n     * </td>\n     * </tr>\n     * <tr>\n     * <td>String</td>\n     * <td>{@link #SOURCE_ID}</td>\n     * <td>read/write</td>\n     * <td>String that uniquely identifies this row to its source account.\n     * Typically it is set at the time the raw contact is inserted and never\n     * changed afterwards. The one notable exception is a new raw contact: it\n     * will have an account name and type (and possibly a data set), but no\n     * source id. This indicates to the sync adapter that a new contact needs\n     * to be created server-side and its ID stored in the corresponding\n     * SOURCE_ID field on the phone.\n     * </td>\n     * </tr>\n     * <tr>\n     * <td>int</td>\n     * <td>{@link #VERSION}</td>\n     * <td>read-only</td>\n     * <td>Version number that is updated whenever this row or its related data\n     * changes. This field can be used for optimistic locking of a raw contact.\n     * </td>\n     * </tr>\n     * <tr>\n     * <td>int</td>\n     * <td>{@link #DIRTY}</td>\n     * <td>read/write</td>\n     * <td>Flag indicating that {@link #VERSION} has changed, and this row needs\n     * to be synchronized by its owning account.  The value is set to \"1\" automatically\n     * whenever the raw contact changes, unless the URI has the\n     * {@link ContactsContract#CALLER_IS_SYNCADAPTER} query parameter specified.\n     * The sync adapter should always supply this query parameter to prevent\n     * unnecessary synchronization: user changes some data on the server,\n     * the sync adapter updates the contact on the phone (without the\n     * CALLER_IS_SYNCADAPTER flag) flag, which sets the DIRTY flag,\n     * which triggers a sync to bring the changes to the server.\n     * </td>\n     * </tr>\n     * <tr>\n     * <td>String</td>\n     * <td>{@link #SYNC1}</td>\n     * <td>read/write</td>\n     * <td>Generic column provided for arbitrary use by sync adapters.\n     * The content provider\n     * stores this information on behalf of the sync adapter but does not\n     * interpret it in any way.\n     * </td>\n     * </tr>\n     * <tr>\n     * <td>String</td>\n     * <td>{@link #SYNC2}</td>\n     * <td>read/write</td>\n     * <td>Generic column for use by sync adapters.\n     * </td>\n     * </tr>\n     * <tr>\n     * <td>String</td>\n     * <td>{@link #SYNC3}</td>\n     * <td>read/write</td>\n     * <td>Generic column for use by sync adapters.\n     * </td>\n     * </tr>\n     * <tr>\n     * <td>String</td>\n     * <td>{@link #SYNC4}</td>\n     * <td>read/write</td>\n     * <td>Generic column for use by sync adapters.\n     * </td>\n     * </tr>\n     * </table>\n     ",
  "links" : [ "#SYNC2", "#SYNC3", "#SYNC4", "#AGGREGATION_MODE_SUSPENDED", "#SYNC1", "#DELETED", "#AGGREGATION_MODE_DISABLED", "android.content.Entity", "android.media.RingtoneManager#ACTION_RINGTONE_PICKER", "#ACCOUNT_TYPE", "RawContacts", "#CONTACT_ID", "#SOURCE_ID", "#AGGREGATION_MODE", "android.content.ContentResolver#delete", "#STARRED", "#SEND_TO_VOICEMAIL", "#CUSTOM_RINGTONE", "#_ID", "#AGGREGATION_MODE_DEFAULT", "#DATA_SET", "Data", "ContactsContract.Contacts", "AggregationExceptions", "android.provider.ContactsContract#CALLER_IS_SYNCADAPTER", "#DIRTY", "#ACCOUNT_NAME", "android.provider.Contacts", "ContactsContract.Contacts#CUSTOM_RINGTONEContacts.CUSTOM_RINGTONE", "#VERSION", "ContentProviderOperation.Builder#withValueBackReference(String" ],
  "variables" : [ {
    "name" : "CONTENT_URI",
    "type" : "Uri",
    "comment" : "\n         * The content:// style URI for this table, which requests a directory of\n         * raw contact rows matching the selection criteria.\n         ",
    "links" : [ ]
  }, {
    "name" : "CONTENT_TYPE",
    "type" : "String",
    "comment" : "\n         * The MIME type of the results from {@link #CONTENT_URI} when a specific\n         * ID value is not provided, and multiple raw contacts may be returned.\n         ",
    "links" : [ "#CONTENT_URI" ]
  }, {
    "name" : "CONTENT_ITEM_TYPE",
    "type" : "String",
    "comment" : "\n         * The MIME type of the results when a raw contact ID is appended to {@link #CONTENT_URI},\n         * yielding a subdirectory of a single person.\n         ",
    "links" : [ "#CONTENT_URI" ]
  }, {
    "name" : "AGGREGATION_MODE_DEFAULT",
    "type" : "int",
    "comment" : "\n         * Aggregation mode: aggregate immediately after insert or update operation(s) are complete.\n         ",
    "links" : [ ]
  }, {
    "name" : "AGGREGATION_MODE_IMMEDIATE",
    "type" : "int",
    "comment" : "\n         * Aggregation mode: aggregate at the time the raw contact is inserted/updated.\n         * @deprecated Aggregation is synchronous, this historic value is a no-op\n         ",
    "links" : [ ]
  }, {
    "name" : "AGGREGATION_MODE_SUSPENDED",
    "type" : "int",
    "comment" : "\n         * <p>\n         * Aggregation mode: aggregation suspended temporarily, and is likely to be resumed later.\n         * Changes to the raw contact will update the associated aggregate contact but will not\n         * result in any change in how the contact is aggregated. Similar to\n         * {@link #AGGREGATION_MODE_DISABLED}, but maintains a link to the corresponding\n         * {@link Contacts} aggregate.\n         * </p>\n         * <p>\n         * This can be used to postpone aggregation until after a series of updates, for better\n         * performance and/or user experience.\n         * </p>\n         * <p>\n         * Note that changing\n         * {@link #AGGREGATION_MODE} from {@link #AGGREGATION_MODE_SUSPENDED} to\n         * {@link #AGGREGATION_MODE_DEFAULT} does not trigger an aggregation pass, but any\n         * subsequent\n         * change to the raw contact's data will.\n         * </p>\n         ",
    "links" : [ "#AGGREGATION_MODE_SUSPENDED", "#AGGREGATION_MODE_DEFAULT", "android.provider.Contacts", "#AGGREGATION_MODE_DISABLED", "#AGGREGATION_MODE" ]
  }, {
    "name" : "AGGREGATION_MODE_DISABLED",
    "type" : "int",
    "comment" : "\n         * <p>\n         * Aggregation mode: never aggregate this raw contact.  The raw contact will not\n         * have a corresponding {@link Contacts} aggregate and therefore will not be included in\n         * {@link Contacts} query results.\n         * </p>\n         * <p>\n         * For example, this mode can be used for a raw contact that is marked for deletion while\n         * waiting for the deletion to occur on the server side.\n         * </p>\n         *\n         * @see #AGGREGATION_MODE_SUSPENDED\n         ",
    "links" : [ "android.provider.Contacts" ]
  } ],
  "methods" : [ {
    "name" : "public static Uri getContactLookupUri(ContentResolver resolver, Uri rawContactUri)",
    "returnType" : "Uri",
    "comment" : "\n         * Build a {@link android.provider.ContactsContract.Contacts#CONTENT_LOOKUP_URI}\n         * style {@link Uri} for the parent {@link android.provider.ContactsContract.Contacts}\n         * entry of the given {@link RawContacts} entry.\n         ",
    "links" : [ "android.provider.ContactsContract.Contacts", "android.provider.ContactsContract.Contacts#CONTENT_LOOKUP_URI", "RawContacts", "android.net.Uri" ]
  }, {
    "name" : "public static String getLocalAccountName(@NonNull Context context)",
    "returnType" : "String",
    "comment" : "\n         * The default value used for {@link #ACCOUNT_NAME} of raw contacts when they are inserted\n         * without a value for this column.\n         *\n         * <p>This account is used to identify contacts that are only stored locally in the\n         * contacts database instead of being associated with an {@link Account} managed by an\n         * installed application.\n         *\n         * <p>When this returns null then {@link #getLocalAccountType} will also return null and\n         * when it is non-null {@link #getLocalAccountType} will also return a non-null value.\n         ",
    "links" : [ "#getLocalAccountType", "#ACCOUNT_NAME", "android.accounts.Account" ]
  }, {
    "name" : "public static String getLocalAccountType(@NonNull Context context)",
    "returnType" : "String",
    "comment" : "\n         * The default value used for {@link #ACCOUNT_TYPE} of raw contacts when they are inserted\n         * without a value for this column.\n         *\n         * <p>This account is used to identify contacts that are only stored locally in the\n         * contacts database instead of being associated with an {@link Account} managed by an\n         * installed application.\n         *\n         * <p>When this returns null then {@link #getLocalAccountName} will also return null and\n         * when it is non-null {@link #getLocalAccountName} will also return a non-null value.\n         ",
    "links" : [ "#ACCOUNT_TYPE", "android.accounts.Account", "#getLocalAccountName" ]
  }, {
    "name" : "public static EntityIterator newEntityIterator(Cursor cursor)",
    "returnType" : "EntityIterator",
    "comment" : "\n         * TODO: javadoc\n         * @param cursor\n         * @return\n         ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public static Uri getContactLookupUri(ContentResolver resolver, Uri rawContactUri)", "public static String getLocalAccountName(@NonNull Context context)", "public static String getLocalAccountType(@NonNull Context context)", "public static EntityIterator newEntityIterator(Cursor cursor)" ],
  "variableNames" : [ "CONTENT_URI", "CONTENT_TYPE", "CONTENT_ITEM_TYPE", "AGGREGATION_MODE_DEFAULT", "AGGREGATION_MODE_IMMEDIATE", "AGGREGATION_MODE_SUSPENDED", "AGGREGATION_MODE_DISABLED" ]
}