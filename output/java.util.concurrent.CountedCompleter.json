{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/util/concurrent/CountedCompleter.java",
  "packageName" : "java.util.concurrent",
  "className" : "CountedCompleter",
  "comment" : "\n * A {@link ForkJoinTask} with a completion action performed when\n * triggered and there are no remaining pending actions.\n * CountedCompleters are in general more robust in the\n * presence of subtask stalls and blockage than are other forms of\n * ForkJoinTasks, but are less intuitive to program.  Uses of\n * CountedCompleter are similar to those of other completion based\n * components (such as {@link java.nio.channels.CompletionHandler})\n * except that multiple <em>pending</em> completions may be necessary\n * to trigger the completion action {@link #onCompletion(CountedCompleter)},\n * not just one.\n * Unless initialized otherwise, the {@linkplain #getPendingCount pending\n * count} starts at zero, but may be (atomically) changed using\n * methods {@link #setPendingCount}, {@link #addToPendingCount}, and\n * {@link #compareAndSetPendingCount}. Upon invocation of {@link\n * #tryComplete}, if the pending action count is nonzero, it is\n * decremented; otherwise, the completion action is performed, and if\n * this completer itself has a completer, the process is continued\n * with its completer.  As is the case with related synchronization\n * components such as {@link Phaser} and {@link Semaphore}, these methods\n * affect only internal counts; they do not establish any further\n * internal bookkeeping. In particular, the identities of pending\n * tasks are not maintained. As illustrated below, you can create\n * subclasses that do record some or all pending tasks or their\n * results when needed.  As illustrated below, utility methods\n * supporting customization of completion traversals are also\n * provided. However, because CountedCompleters provide only basic\n * synchronization mechanisms, it may be useful to create further\n * abstract subclasses that maintain linkages, fields, and additional\n * support methods appropriate for a set of related usages.\n *\n * <p>A concrete CountedCompleter class must define method {@link\n * #compute}, that should in most cases (as illustrated below), invoke\n * {@code tryComplete()} once before returning. The class may also\n * optionally override method {@link #onCompletion(CountedCompleter)}\n * to perform an action upon normal completion, and method\n * {@link #onExceptionalCompletion(Throwable, CountedCompleter)} to\n * perform an action upon any exception.\n *\n * <p>CountedCompleters most often do not bear results, in which case\n * they are normally declared as {@code CountedCompleter<Void>}, and\n * will always return {@code null} as a result value.  In other cases,\n * you should override method {@link #getRawResult} to provide a\n * result from {@code join(), invoke()}, and related methods.  In\n * general, this method should return the value of a field (or a\n * function of one or more fields) of the CountedCompleter object that\n * holds the result upon completion. Method {@link #setRawResult} by\n * default plays no role in CountedCompleters.  It is possible, but\n * rarely applicable, to override this method to maintain other\n * objects or fields holding result data.\n *\n * <p>A CountedCompleter that does not itself have a completer (i.e.,\n * one for which {@link #getCompleter} returns {@code null}) can be\n * used as a regular ForkJoinTask with this added functionality.\n * However, any completer that in turn has another completer serves\n * only as an internal helper for other computations, so its own task\n * status (as reported in methods such as {@link ForkJoinTask#isDone})\n * is arbitrary; this status changes only upon explicit invocations of\n * {@link #complete}, {@link ForkJoinTask#cancel},\n * {@link ForkJoinTask#completeExceptionally(Throwable)} or upon\n * exceptional completion of method {@code compute}. Upon any\n * exceptional completion, the exception may be relayed to a task's\n * completer (and its completer, and so on), if one exists and it has\n * not otherwise already completed. Similarly, cancelling an internal\n * CountedCompleter has only a local effect on that completer, so is\n * not often useful.\n *\n * <p><b>Sample Usages.</b>\n *\n * <p><b>Parallel recursive decomposition.</b> CountedCompleters may\n * be arranged in trees similar to those often used with {@link\n * RecursiveAction}s, although the constructions involved in setting\n * them up typically vary. Here, the completer of each task is its\n * parent in the computation tree. Even though they entail a bit more\n * bookkeeping, CountedCompleters may be better choices when applying\n * a possibly time-consuming operation (that cannot be further\n * subdivided) to each element of an array or collection; especially\n * when the operation takes a significantly different amount of time\n * to complete for some elements than others, either because of\n * intrinsic variation (for example I/O) or auxiliary effects such as\n * garbage collection.  Because CountedCompleters provide their own\n * continuations, other tasks need not block waiting to perform them.\n *\n * <p>For example, here is an initial version of a utility method that\n * uses divide-by-two recursive decomposition to divide work into\n * single pieces (leaf tasks). Even when work is split into individual\n * calls, tree-based techniques are usually preferable to directly\n * forking leaf tasks, because they reduce inter-thread communication\n * and improve load balancing. In the recursive case, the second of\n * each pair of subtasks to finish triggers completion of their parent\n * (because no result combination is performed, the default no-op\n * implementation of method {@code onCompletion} is not overridden).\n * The utility method sets up the root task and invokes it (here,\n * implicitly using the {@link ForkJoinPool#commonPool()}).  It is\n * straightforward and reliable (but not optimal) to always set the\n * pending count to the number of child tasks and call {@code\n * tryComplete()} immediately before returning.\n *\n * <pre> {@code\n * public static <E> void forEach(E[] array, Consumer<E> action) {\n *   class Task extends CountedCompleter<Void> {\n *     final int lo, hi;\n *     Task(Task parent, int lo, int hi) {\n *       super(parent); this.lo = lo; this.hi = hi;\n *     }\n *\n *     public void compute() {\n *       if (hi - lo >= 2) {\n *         int mid = (lo + hi) >>> 1;\n *         // must set pending count before fork\n *         setPendingCount(2);\n *         new Task(this, mid, hi).fork(); // right child\n *         new Task(this, lo, mid).fork(); // left child\n *       }\n *       else if (hi > lo)\n *         action.accept(array[lo]);\n *       tryComplete();\n *     }\n *   }\n *   new Task(null, 0, array.length).invoke();\n * }}</pre>\n *\n * This design can be improved by noticing that in the recursive case,\n * the task has nothing to do after forking its right task, so can\n * directly invoke its left task before returning. (This is an analog\n * of tail recursion removal.)  Also, when the last action in a task\n * is to fork or invoke a subtask (a \"tail call\"), the call to {@code\n * tryComplete()} can be optimized away, at the cost of making the\n * pending count look \"off by one\".\n *\n * <pre> {@code\n *     public void compute() {\n *       if (hi - lo >= 2) {\n *         int mid = (lo + hi) >>> 1;\n *         setPendingCount(1); // looks off by one, but correct!\n *         new Task(this, mid, hi).fork(); // right child\n *         new Task(this, lo, mid).compute(); // direct invoke\n *       } else {\n *         if (hi > lo)\n *           action.accept(array[lo]);\n *         tryComplete();\n *       }\n *     }}</pre>\n *\n * As a further optimization, notice that the left task need not even exist.\n * Instead of creating a new one, we can continue using the original task,\n * and add a pending count for each fork.  Additionally, because no task\n * in this tree implements an {@link #onCompletion(CountedCompleter)} method,\n * {@code tryComplete} can be replaced with {@link #propagateCompletion}.\n *\n * <pre> {@code\n *     public void compute() {\n *       int n = hi - lo;\n *       for (; n >= 2; n /= 2) {\n *         addToPendingCount(1);\n *         new Task(this, lo + n/2, lo + n).fork();\n *       }\n *       if (n > 0)\n *         action.accept(array[lo]);\n *       propagateCompletion();\n *     }}</pre>\n *\n * When pending counts can be precomputed, they can be established in\n * the constructor:\n *\n * <pre> {@code\n * public static <E> void forEach(E[] array, Consumer<E> action) {\n *   class Task extends CountedCompleter<Void> {\n *     final int lo, hi;\n *     Task(Task parent, int lo, int hi) {\n *       super(parent, 31 - Integer.numberOfLeadingZeros(hi - lo));\n *       this.lo = lo; this.hi = hi;\n *     }\n *\n *     public void compute() {\n *       for (int n = hi - lo; n >= 2; n /= 2)\n *         new Task(this, lo + n/2, lo + n).fork();\n *       action.accept(array[lo]);\n *       propagateCompletion();\n *     }\n *   }\n *   if (array.length > 0)\n *     new Task(null, 0, array.length).invoke();\n * }}</pre>\n *\n * Additional optimizations of such classes might entail specializing\n * classes for leaf steps, subdividing by say, four, instead of two\n * per iteration, and using an adaptive threshold instead of always\n * subdividing down to single elements.\n *\n * <p><b>Searching.</b> A tree of CountedCompleters can search for a\n * value or property in different parts of a data structure, and\n * report a result in an {@link\n * java.util.concurrent.atomic.AtomicReference AtomicReference} as\n * soon as one is found. The others can poll the result to avoid\n * unnecessary work. (You could additionally {@linkplain #cancel\n * cancel} other tasks, but it is usually simpler and more efficient\n * to just let them notice that the result is set and if so skip\n * further processing.)  Illustrating again with an array using full\n * partitioning (again, in practice, leaf tasks will almost always\n * process more than one element):\n *\n * <pre> {@code\n * class Searcher<E> extends CountedCompleter<E> {\n *   final E[] array; final AtomicReference<E> result; final int lo, hi;\n *   Searcher(CountedCompleter<?> p, E[] array, AtomicReference<E> result, int lo, int hi) {\n *     super(p);\n *     this.array = array; this.result = result; this.lo = lo; this.hi = hi;\n *   }\n *   public E getRawResult() { return result.get(); }\n *   public void compute() { // similar to ForEach version 3\n *     int l = lo, h = hi;\n *     while (result.get() == null && h >= l) {\n *       if (h - l >= 2) {\n *         int mid = (l + h) >>> 1;\n *         addToPendingCount(1);\n *         new Searcher(this, array, result, mid, h).fork();\n *         h = mid;\n *       }\n *       else {\n *         E x = array[l];\n *         if (matches(x) && result.compareAndSet(null, x))\n *           quietlyCompleteRoot(); // root task is now joinable\n *         break;\n *       }\n *     }\n *     tryComplete(); // normally complete whether or not found\n *   }\n *   boolean matches(E e) { ... } // return true if found\n *\n *   public static <E> E search(E[] array) {\n *       return new Searcher<E>(null, array, new AtomicReference<E>(), 0, array.length).invoke();\n *   }\n * }}</pre>\n *\n * In this example, as well as others in which tasks have no other\n * effects except to {@code compareAndSet} a common result, the\n * trailing unconditional invocation of {@code tryComplete} could be\n * made conditional ({@code if (result.get() == null) tryComplete();})\n * because no further bookkeeping is required to manage completions\n * once the root task completes.\n *\n * <p><b>Recording subtasks.</b> CountedCompleter tasks that combine\n * results of multiple subtasks usually need to access these results\n * in method {@link #onCompletion(CountedCompleter)}. As illustrated in the following\n * class (that performs a simplified form of map-reduce where mappings\n * and reductions are all of type {@code E}), one way to do this in\n * divide and conquer designs is to have each subtask record its\n * sibling, so that it can be accessed in method {@code onCompletion}.\n * This technique applies to reductions in which the order of\n * combining left and right results does not matter; ordered\n * reductions require explicit left/right designations.  Variants of\n * other streamlinings seen in the above examples may also apply.\n *\n * <pre> {@code\n * class MyMapper<E> { E apply(E v) {  ...  } }\n * class MyReducer<E> { E apply(E x, E y) {  ...  } }\n * class MapReducer<E> extends CountedCompleter<E> {\n *   final E[] array; final MyMapper<E> mapper;\n *   final MyReducer<E> reducer; final int lo, hi;\n *   MapReducer<E> sibling;\n *   E result;\n *   MapReducer(CountedCompleter<?> p, E[] array, MyMapper<E> mapper,\n *              MyReducer<E> reducer, int lo, int hi) {\n *     super(p);\n *     this.array = array; this.mapper = mapper;\n *     this.reducer = reducer; this.lo = lo; this.hi = hi;\n *   }\n *   public void compute() {\n *     if (hi - lo >= 2) {\n *       int mid = (lo + hi) >>> 1;\n *       MapReducer<E> left = new MapReducer(this, array, mapper, reducer, lo, mid);\n *       MapReducer<E> right = new MapReducer(this, array, mapper, reducer, mid, hi);\n *       left.sibling = right;\n *       right.sibling = left;\n *       setPendingCount(1); // only right is pending\n *       right.fork();\n *       left.compute();     // directly execute left\n *     }\n *     else {\n *       if (hi > lo)\n *           result = mapper.apply(array[lo]);\n *       tryComplete();\n *     }\n *   }\n *   public void onCompletion(CountedCompleter<?> caller) {\n *     if (caller != this) {\n *       MapReducer<E> child = (MapReducer<E>)caller;\n *       MapReducer<E> sib = child.sibling;\n *       if (sib == null || sib.result == null)\n *         result = child.result;\n *       else\n *         result = reducer.apply(child.result, sib.result);\n *     }\n *   }\n *   public E getRawResult() { return result; }\n *\n *   public static <E> E mapReduce(E[] array, MyMapper<E> mapper, MyReducer<E> reducer) {\n *     return new MapReducer<E>(null, array, mapper, reducer,\n *                              0, array.length).invoke();\n *   }\n * }}</pre>\n *\n * Here, method {@code onCompletion} takes a form common to many\n * completion designs that combine results. This callback-style method\n * is triggered once per task, in either of the two different contexts\n * in which the pending count is, or becomes, zero: (1) by a task\n * itself, if its pending count is zero upon invocation of {@code\n * tryComplete}, or (2) by any of its subtasks when they complete and\n * decrement the pending count to zero. The {@code caller} argument\n * distinguishes cases.  Most often, when the caller is {@code this},\n * no action is necessary. Otherwise the caller argument can be used\n * (usually via a cast) to supply a value (and/or links to other\n * values) to be combined.  Assuming proper use of pending counts, the\n * actions inside {@code onCompletion} occur (once) upon completion of\n * a task and its subtasks. No additional synchronization is required\n * within this method to ensure thread safety of accesses to fields of\n * this task or other completed tasks.\n *\n * <p><b>Completion Traversals.</b> If using {@code onCompletion} to\n * process completions is inapplicable or inconvenient, you can use\n * methods {@link #firstComplete} and {@link #nextComplete} to create\n * custom traversals.  For example, to define a MapReducer that only\n * splits out right-hand tasks in the form of the third ForEach\n * example, the completions must cooperatively reduce along\n * unexhausted subtask links, which can be done as follows:\n *\n * <pre> {@code\n * class MapReducer<E> extends CountedCompleter<E> { // version 2\n *   final E[] array; final MyMapper<E> mapper;\n *   final MyReducer<E> reducer; final int lo, hi;\n *   MapReducer<E> forks, next; // record subtask forks in list\n *   E result;\n *   MapReducer(CountedCompleter<?> p, E[] array, MyMapper<E> mapper,\n *              MyReducer<E> reducer, int lo, int hi, MapReducer<E> next) {\n *     super(p);\n *     this.array = array; this.mapper = mapper;\n *     this.reducer = reducer; this.lo = lo; this.hi = hi;\n *     this.next = next;\n *   }\n *   public void compute() {\n *     int l = lo, h = hi;\n *     while (h - l >= 2) {\n *       int mid = (l + h) >>> 1;\n *       addToPendingCount(1);\n *       (forks = new MapReducer(this, array, mapper, reducer, mid, h, forks)).fork();\n *       h = mid;\n *     }\n *     if (h > l)\n *       result = mapper.apply(array[l]);\n *     // process completions by reducing along and advancing subtask links\n *     for (CountedCompleter<?> c = firstComplete(); c != null; c = c.nextComplete()) {\n *       for (MapReducer t = (MapReducer)c, s = t.forks; s != null; s = t.forks = s.next)\n *         t.result = reducer.apply(t.result, s.result);\n *     }\n *   }\n *   public E getRawResult() { return result; }\n *\n *   public static <E> E mapReduce(E[] array, MyMapper<E> mapper, MyReducer<E> reducer) {\n *     return new MapReducer<E>(null, array, mapper, reducer,\n *                              0, array.length, null).invoke();\n *   }\n * }}</pre>\n *\n * <p><b>Triggers.</b> Some CountedCompleters are themselves never\n * forked, but instead serve as bits of plumbing in other designs;\n * including those in which the completion of one or more async tasks\n * triggers another async task. For example:\n *\n * <pre> {@code\n * class HeaderBuilder extends CountedCompleter<...> { ... }\n * class BodyBuilder extends CountedCompleter<...> { ... }\n * class PacketSender extends CountedCompleter<...> {\n *   PacketSender(...) { super(null, 1); ... } // trigger on second completion\n *   public void compute() { } // never called\n *   public void onCompletion(CountedCompleter<?> caller) { sendPacket(); }\n * }\n * // sample use:\n * PacketSender p = new PacketSender();\n * new HeaderBuilder(p, ...).fork();\n * new BodyBuilder(p, ...).fork();}</pre>\n *\n * @since 1.8\n * @author Doug Lea\n ",
  "links" : [ "java.util.concurrent.ForkJoinTask#isDone", "java.util.concurrent.ForkJoinTask", "#compute", "#tryComplete", "java.util.concurrent.Semaphore", "#nextComplete", "java.nio.channels.CompletionHandler", "#setRawResult", "#getRawResult", "java.util.concurrent.RecursiveAction", "#propagateCompletion", "#compareAndSetPendingCount", "java.util.concurrent.ForkJoinTask#cancel", "#setPendingCount", "java.util.concurrent.atomic.AtomicReference", "#onExceptionalCompletion(Throwable", "java.util.concurrent.Phaser", "java.util.concurrent.ForkJoinTask#completeExceptionally(Throwable)", "#addToPendingCount", "#complete", "#firstComplete", "#onCompletion(CountedCompleter)", "#getCompleter", "java.util.concurrent.ForkJoinPool#commonPool()" ],
  "variables" : [ {
    "name" : "serialVersionUID",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "completer",
    "type" : "CountedCompleter<?>",
    "comment" : " This task's completer, or null if none ",
    "links" : [ ]
  }, {
    "name" : "pending",
    "type" : "int",
    "comment" : " The number of pending tasks until completion ",
    "links" : [ ]
  }, {
    "name" : "PENDING",
    "type" : "VarHandle",
    "comment" : " VarHandle mechanics",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public abstract void compute()",
    "returnType" : "void",
    "comment" : "\n     * The main computation performed by this task.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onCompletion(CountedCompleter<?> caller)",
    "returnType" : "void",
    "comment" : "\n     * Performs an action when method {@link #tryComplete} is invoked\n     * and the pending count is zero, or when the unconditional\n     * method {@link #complete} is invoked.  By default, this method\n     * does nothing. You can distinguish cases by checking the\n     * identity of the given caller argument. If not equal to {@code\n     * this}, then it is typically a subtask that may contain results\n     * (and/or links to other results) to combine.\n     *\n     * @param caller the task invoking this method (which may\n     * be this task itself)\n     ",
    "links" : [ "#tryComplete", "#complete" ]
  }, {
    "name" : "public boolean onExceptionalCompletion(Throwable ex, CountedCompleter<?> caller)",
    "returnType" : "boolean",
    "comment" : "\n     * Performs an action when method {@link\n     * #completeExceptionally(Throwable)} is invoked or method {@link\n     * #compute} throws an exception, and this task has not already\n     * otherwise completed normally. On entry to this method, this task\n     * {@link ForkJoinTask#isCompletedAbnormally}.  The return value\n     * of this method controls further propagation: If {@code true}\n     * and this task has a completer that has not completed, then that\n     * completer is also completed exceptionally, with the same\n     * exception as this completer.  The default implementation of\n     * this method does nothing except return {@code true}.\n     *\n     * @param ex the exception\n     * @param caller the task invoking this method (which may\n     * be this task itself)\n     * @return {@code true} if this exception should be propagated to this\n     * task's completer, if one exists\n     ",
    "links" : [ "java.util.concurrent.ForkJoinTask#isCompletedAbnormally", "#compute", "#completeExceptionally(Throwable)" ]
  }, {
    "name" : "public final CountedCompleter<?> getCompleter()",
    "returnType" : "CountedCompleter<?>",
    "comment" : "\n     * Returns the completer established in this task's constructor,\n     * or {@code null} if none.\n     *\n     * @return the completer\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int getPendingCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the current pending count.\n     *\n     * @return the current pending count\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void setPendingCount(int count)",
    "returnType" : "void",
    "comment" : "\n     * Sets the pending count to the given value.\n     *\n     * @param count the count\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void addToPendingCount(int delta)",
    "returnType" : "void",
    "comment" : "\n     * Adds (atomically) the given value to the pending count.\n     *\n     * @param delta the value to add\n     ",
    "links" : [ ]
  }, {
    "name" : "public final boolean compareAndSetPendingCount(int expected, int count)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets (atomically) the pending count to the given count only if\n     * it currently holds the given expected value.\n     *\n     * @param expected the expected value\n     * @param count the new value\n     * @return {@code true} if successful\n     ",
    "links" : [ ]
  }, {
    "name" : " final boolean weakCompareAndSetPendingCount(int expected, int count)",
    "returnType" : "boolean",
    "comment" : " internal-only weak version",
    "links" : [ ]
  }, {
    "name" : "public final int decrementPendingCountUnlessZero()",
    "returnType" : "int",
    "comment" : "\n     * If the pending count is nonzero, (atomically) decrements it.\n     *\n     * @return the initial (undecremented) pending count holding on entry\n     * to this method\n     ",
    "links" : [ ]
  }, {
    "name" : "public final CountedCompleter<?> getRoot()",
    "returnType" : "CountedCompleter<?>",
    "comment" : "\n     * Returns the root of the current computation; i.e., this\n     * task if it has no completer, else its completer's root.\n     *\n     * @return the root of the current computation\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void tryComplete()",
    "returnType" : "void",
    "comment" : "\n     * If the pending count is nonzero, decrements the count;\n     * otherwise invokes {@link #onCompletion(CountedCompleter)}\n     * and then similarly tries to complete this task's completer,\n     * if one exists, else marks this task as complete.\n     ",
    "links" : [ "#onCompletion(CountedCompleter)" ]
  }, {
    "name" : "public final void propagateCompletion()",
    "returnType" : "void",
    "comment" : "\n     * Equivalent to {@link #tryComplete} but does not invoke {@link\n     * #onCompletion(CountedCompleter)} along the completion path:\n     * If the pending count is nonzero, decrements the count;\n     * otherwise, similarly tries to complete this task's completer, if\n     * one exists, else marks this task as complete. This method may be\n     * useful in cases where {@code onCompletion} should not, or need\n     * not, be invoked for each completer in a computation.\n     ",
    "links" : [ "#tryComplete", "#onCompletion(CountedCompleter)" ]
  }, {
    "name" : "public void complete(T rawResult)",
    "returnType" : "void",
    "comment" : "\n     * Regardless of pending count, invokes\n     * {@link #onCompletion(CountedCompleter)}, marks this task as\n     * complete and further triggers {@link #tryComplete} on this\n     * task's completer, if one exists.  The given rawResult is\n     * used as an argument to {@link #setRawResult} before invoking\n     * {@link #onCompletion(CountedCompleter)} or marking this task\n     * as complete; its value is meaningful only for classes\n     * overriding {@code setRawResult}.  This method does not modify\n     * the pending count.\n     *\n     * <p>This method may be useful when forcing completion as soon as\n     * any one (versus all) of several subtask results are obtained.\n     * However, in the common (and recommended) case in which {@code\n     * setRawResult} is not overridden, this effect can be obtained\n     * more simply using {@link #quietlyCompleteRoot()}.\n     *\n     * @param rawResult the raw result\n     ",
    "links" : [ "#quietlyCompleteRoot()", "#tryComplete", "#setRawResult", "#onCompletion(CountedCompleter)" ]
  }, {
    "name" : "public final CountedCompleter<?> firstComplete()",
    "returnType" : "CountedCompleter<?>",
    "comment" : "\n     * If this task's pending count is zero, returns this task;\n     * otherwise decrements its pending count and returns {@code null}.\n     * This method is designed to be used with {@link #nextComplete} in\n     * completion traversal loops.\n     *\n     * @return this task, if pending count was zero, else {@code null}\n     ",
    "links" : [ "#nextComplete" ]
  }, {
    "name" : "public final CountedCompleter<?> nextComplete()",
    "returnType" : "CountedCompleter<?>",
    "comment" : "\n     * If this task does not have a completer, invokes {@link\n     * ForkJoinTask#quietlyComplete} and returns {@code null}.  Or, if\n     * the completer's pending count is non-zero, decrements that\n     * pending count and returns {@code null}.  Otherwise, returns the\n     * completer.  This method can be used as part of a completion\n     * traversal loop for homogeneous task hierarchies:\n     *\n     * <pre> {@code\n     * for (CountedCompleter<?> c = firstComplete();\n     *      c != null;\n     *      c = c.nextComplete()) {\n     *   // ... process c ...\n     * }}</pre>\n     *\n     * @return the completer, or {@code null} if none\n     ",
    "links" : [ "java.util.concurrent.ForkJoinTask#quietlyComplete" ]
  }, {
    "name" : "public final void quietlyCompleteRoot()",
    "returnType" : "void",
    "comment" : "\n     * Equivalent to {@code getRoot().quietlyComplete()}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void helpComplete(int maxTasks)",
    "returnType" : "void",
    "comment" : "\n     * If this task has not completed, attempts to process at most the\n     * given number of other unprocessed tasks for which this task is\n     * on the completion path, if any are known to exist.\n     *\n     * @param maxTasks the maximum number of tasks to process.  If\n     *                 less than or equal to zero, then no tasks are\n     *                 processed.\n     ",
    "links" : [ ]
  }, {
    "name" : " final int trySetException(Throwable ex)",
    "returnType" : "int",
    "comment" : "\n     * Supports ForkJoinTask exception propagation.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected final boolean exec()",
    "returnType" : "boolean",
    "comment" : "\n     * Implements execution conventions for CountedCompleters.\n     ",
    "links" : [ ]
  }, {
    "name" : "public T getRawResult()",
    "returnType" : "T",
    "comment" : "\n     * Returns the result of the computation.  By default,\n     * returns {@code null}, which is appropriate for {@code Void}\n     * actions, but in other cases should be overridden, almost\n     * always to return a field or function of a field that\n     * holds the result upon completion.\n     *\n     * @return the result of the computation\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void setRawResult(T t)",
    "returnType" : "void",
    "comment" : "\n     * A method that result-bearing CountedCompleters may optionally\n     * use to help maintain result data.  By default, does nothing.\n     * Overrides are not recommended. However, if this method is\n     * overridden to update existing objects or fields, then it must\n     * in general be defined to be thread-safe.\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public abstract void compute()", "public void onCompletion(CountedCompleter<?> caller)", "public boolean onExceptionalCompletion(Throwable ex, CountedCompleter<?> caller)", "public final CountedCompleter<?> getCompleter()", "public final int getPendingCount()", "public final void setPendingCount(int count)", "public final void addToPendingCount(int delta)", "public final boolean compareAndSetPendingCount(int expected, int count)", " final boolean weakCompareAndSetPendingCount(int expected, int count)", "public final int decrementPendingCountUnlessZero()", "public final CountedCompleter<?> getRoot()", "public final void tryComplete()", "public final void propagateCompletion()", "public void complete(T rawResult)", "public final CountedCompleter<?> firstComplete()", "public final CountedCompleter<?> nextComplete()", "public final void quietlyCompleteRoot()", "public final void helpComplete(int maxTasks)", " final int trySetException(Throwable ex)", "protected final boolean exec()", "public T getRawResult()", "protected void setRawResult(T t)" ],
  "variableNames" : [ "serialVersionUID", "completer", "pending", "PENDING" ]
}