{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/security/identity/IdentityCredentialStore.java",
  "packageName" : "android.security.identity",
  "className" : "IdentityCredentialStore",
  "comment" : "\n * An interface to a secure store for user identity documents.\n *\n * <p>This interface is deliberately fairly general and abstract.  To the extent possible,\n * specification of the message formats and semantics of communication with credential\n * verification devices and issuing authorities (IAs) is out of scope. It provides the\n * interface with secure storage but a credential-specific Android application will be\n * required to implement the presentation and verification protocols and processes\n * appropriate for the specific credential type.\n *\n * <p>Multiple credentials can be created.  Each credential comprises:</p>\n * <ul>\n * <li>A document type, which is a string.</li>\n *\n * <li>A set of namespaces, which serve to disambiguate value names. It is recommended\n * that namespaces be structured as reverse domain names so that IANA effectively serves\n * as the namespace registrar.</li>\n *\n * <li>For each namespace, a set of name/value pairs, each with an associated set of\n * access control profile IDs.  Names are strings and values are typed and can be any\n * value supported by <a href=\"http://cbor.io/\">CBOR</a>.</li>\n *\n * <li>A set of access control profiles (up to 32), each with a profile ID and a specification\n * of the conditions which satisfy the profile's requirements.</li>\n *\n * <li>An asymmetric key pair which is used to authenticate the credential to the Issuing\n * Authority, called the <em>CredentialKey</em>.</li>\n *\n * <li>A set of zero or more named reader authentication public keys, which are used to\n * authenticate an authorized reader to the credential.</li>\n *\n * <li>A set of named signing keys, which are used to sign collections of values and session\n * transcripts.</li>\n * </ul>\n *\n * <p>Implementing support for user identity documents in secure storage requires dedicated\n * hardware-backed support and may not always be available.\n *\n * <p>Two different credential stores exist - the <em>default</em> store and the\n * <em>direct access</em> store. Most often credentials will be accessed through the default\n * store but that requires that the Android device be powered up and fully functional.\n * It is desirable to allow identity credential usage when the Android device's battery is too\n * low to boot the Android operating system, so direct access to the secure hardware via NFC\n * may allow data retrieval, if the secure hardware chooses to implement it.\n *\n * <p>Credentials provisioned to the direct access store should <strong>always</strong> use reader\n * authentication to protect data elements. The reason for this is user authentication or user\n * approval of data release is not possible when the device is off.\n *\n * <p>The Identity Credential API is designed to be able to evolve and change over time\n * but still provide 100% backwards compatibility. This is complicated by the fact that\n * there may be a version skew between the API used by the application and the version\n * implemented in secure hardware. To solve this problem, the API provides for a way\n * for the application to query which feature version the hardware implements (if any\n * at all) using\n * {@link android.content.pm#FEATURE_IDENTITY_CREDENTIAL_HARDWARE} and\n * {@link android.content.pm#FEATURE_IDENTITY_CREDENTIAL_HARDWARE_DIRECT_ACCESS}.\n * Methods which only work on certain feature versions are clearly documented as\n * such.\n ",
  "links" : [ "android.content.pm#FEATURE_IDENTITY_CREDENTIAL_HARDWARE", "android.content.pm#FEATURE_IDENTITY_CREDENTIAL_HARDWARE_DIRECT_ACCESS" ],
  "variables" : [ {
    "name" : "CIPHERSUITE_ECDHE_HKDF_ECDSA_WITH_AES_256_GCM_SHA256",
    "type" : "int",
    "comment" : "\n     * Specifies that the cipher suite that will be used to secure communications between the reader\n     * and the prover is using the following primitives\n     *\n     * <ul>\n     * <li>ECKA-DH (Elliptic Curve Key Agreement Algorithm - Diffie-Hellman, see BSI TR-03111).</li>\n     *\n     * <li>HKDF-SHA-256 (see RFC 5869).</li>\n     *\n     * <li>AES-256-GCM (see NIST SP 800-38D).</li>\n     *\n     * <li>HMAC-SHA-256 (see RFC 2104).</li>\n     * </ul>\n     *\n     * <p>The exact way these primitives are combined to derive the session key is specified in\n     * section 9.2.1.4 of ISO/IEC 18013-5 (see description of cipher suite '1').<p>\n     *\n     * <p>\n     * At present this is the only supported cipher suite.\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static IdentityCredentialStore getInstance(@NonNull Context context)",
    "returnType" : "IdentityCredentialStore",
    "comment" : "\n     * Gets the default {@link IdentityCredentialStore}.\n     *\n     * @param context the application context.\n     * @return the {@link IdentityCredentialStore} or {@code null} if the device doesn't\n     *     have hardware-backed support for secure storage of user identity documents.\n     ",
    "links" : [ "android.security.identity.IdentityCredentialStore" ]
  }, {
    "name" : "public static IdentityCredentialStore getDirectAccessInstance(@NonNull Context context)",
    "returnType" : "IdentityCredentialStore",
    "comment" : "\n     * Gets the {@link IdentityCredentialStore} for direct access.\n     *\n     * <p>Direct access requires specialized NFC hardware and may not be supported on all\n     * devices even if default store is available. Credentials provisioned to the direct\n     * access store should <strong>always</strong> use reader authentication to protect\n     * data elements.\n     *\n     * @param context the application context.\n     * @return the {@link IdentityCredentialStore} or {@code null} if direct access is not\n     *     supported on this device.\n     ",
    "links" : [ "android.security.identity.IdentityCredentialStore" ]
  }, {
    "name" : "public abstract String[] getSupportedDocTypes()",
    "returnType" : "String[]",
    "comment" : "\n     * Gets a list of supported document types.\n     *\n     * <p>Only the direct-access store may restrict the kind of document types that can be used for\n     * credentials. The default store always supports any document type.\n     *\n     * @return The supported document types or the empty array if any document type is supported.\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract WritableIdentityCredential createCredential(@NonNull String credentialName, @NonNull String docType) throws AlreadyPersonalizedException, DocTypeNotSupportedException",
    "returnType" : "WritableIdentityCredential",
    "comment" : "\n     * Creates a new credential.\n     *\n     * <p>When a credential is created, a cryptographic key-pair - CredentialKey - is created which\n     * is used to authenticate the store to the Issuing Authority.  The private part of this\n     * key-pair never leaves secure hardware and the public part can be obtained using\n     * {@link WritableIdentityCredential#getCredentialKeyCertificateChain(byte[])} on the\n     * returned object.\n     *\n     * <p>In addition, all of the Credential data content is imported and a certificate for the\n     * CredentialKey and a signature produced with the CredentialKey are created.  These latter\n     * values may be checked by an issuing authority to verify that the data was imported into\n     * secure hardware and that it was imported unmodified.\n     *\n     * @param credentialName The name used to identify the credential.\n     * @param docType        The document type for the credential.\n     * @return A {@link WritableIdentityCredential} that can be used to create a new credential.\n     * @throws AlreadyPersonalizedException if a credential with the given name already exists.\n     * @throws DocTypeNotSupportedException if the given document type isn't supported by the store.\n     ",
    "links" : [ "android.security.identity.WritableIdentityCredential#getCredentialKeyCertificateChain(byte", "android.security.identity.WritableIdentityCredential" ]
  }, {
    "name" : "public abstract IdentityCredential getCredentialByName(@NonNull String credentialName, @Ciphersuite int cipherSuite) throws CipherSuiteNotSupportedException",
    "returnType" : "IdentityCredential",
    "comment" : "\n     * Retrieve a named credential.\n     *\n     * <p>The cipher suite used to communicate with the remote verifier must also be specified.\n     * Currently only a single cipher-suite is supported. Support for other cipher suites may be\n     * added in a future version of this API.\n     *\n     * @param credentialName the name of the credential to retrieve.\n     * @param cipherSuite    the cipher suite to use for communicating with the verifier.\n     * @return The named credential, or null if not found.\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract byte[] deleteCredentialByName(@NonNull String credentialName)",
    "returnType" : "byte[]",
    "comment" : "\n     * Delete a named credential.\n     *\n     * <p>This method returns a COSE_Sign1 data structure signed by the CredentialKey\n     * with payload set to {@code ProofOfDeletion} as defined below:\n     *\n     * <pre>\n     *     ProofOfDeletion = [\n     *          \"ProofOfDeletion\",            ; tstr\n     *          tstr,                         ; DocType\n     *          bool                          ; true if this is a test credential, should\n     *                                        ; always be false.\n     *      ]\n     * </pre>\n     *\n     * @param credentialName the name of the credential to delete.\n     * @return {@code null} if the credential was not found, the COSE_Sign1 data structure above\n     *     if the credential was found and deleted.\n     * @deprecated Use {@link IdentityCredential#delete(byte[])} instead.\n     ",
    "links" : [ "android.security.identity.IdentityCredential#delete(byte" ]
  }, {
    "name" : "public PresentationSession createPresentationSession(@Ciphersuite int cipherSuite) throws CipherSuiteNotSupportedException",
    "returnType" : "PresentationSession",
    "comment" : "\n     * Creates a new presentation session.\n     *\n     * <p>This method gets an object to be used for interaction with a remote verifier for\n     * presentation of one or more credentials.\n     *\n     * <p>This is only implemented in feature version 202201 or later. If not implemented, the call\n     * fails with {@link UnsupportedOperationException}. See\n     * {@link android.content.pm.PackageManager#FEATURE_IDENTITY_CREDENTIAL_HARDWARE} for known\n     * feature versions.\n     *\n     * @param cipherSuite    the cipher suite to use for communicating with the verifier.\n     * @return The presentation session.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_IDENTITY_CREDENTIAL_HARDWARE", "UnsupportedOperationException" ]
  } ],
  "methodNames" : [ "public static IdentityCredentialStore getInstance(@NonNull Context context)", "public static IdentityCredentialStore getDirectAccessInstance(@NonNull Context context)", "public abstract String[] getSupportedDocTypes()", "public abstract WritableIdentityCredential createCredential(@NonNull String credentialName, @NonNull String docType) throws AlreadyPersonalizedException, DocTypeNotSupportedException", "public abstract IdentityCredential getCredentialByName(@NonNull String credentialName, @Ciphersuite int cipherSuite) throws CipherSuiteNotSupportedException", "public abstract byte[] deleteCredentialByName(@NonNull String credentialName)", "public PresentationSession createPresentationSession(@Ciphersuite int cipherSuite) throws CipherSuiteNotSupportedException" ],
  "variableNames" : [ "CIPHERSUITE_ECDHE_HKDF_ECDSA_WITH_AES_256_GCM_SHA256" ]
}