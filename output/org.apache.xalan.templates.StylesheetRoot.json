{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/org/apache/xalan/templates/StylesheetRoot.java",
  "packageName" : "org.apache.xalan.templates",
  "className" : "StylesheetRoot",
  "comment" : "\n * This class represents the root object of the stylesheet tree.\n * @xsl.usage general\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "serialVersionUID",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "m_optimizer",
    "type" : "boolean",
    "comment" : "\n     * The flag for the setting of the optimize feature;\n     ",
    "links" : [ ]
  }, {
    "name" : "m_incremental",
    "type" : "boolean",
    "comment" : "\n     * The flag for the setting of the incremental feature;\n     ",
    "links" : [ ]
  }, {
    "name" : "m_source_location",
    "type" : "boolean",
    "comment" : "\n     * The flag for the setting of the source_location feature;\n     ",
    "links" : [ ]
  }, {
    "name" : "m_isSecureProcessing",
    "type" : "boolean",
    "comment" : "\n     * State of the secure processing feature.\n     ",
    "links" : [ ]
  }, {
    "name" : "m_availElems",
    "type" : "HashMap",
    "comment" : "\n   * The schema used when creating this StylesheetRoot\n   * @serial\n   ",
    "links" : [ ]
  }, {
    "name" : "m_extNsMgr",
    "type" : "ExtensionNamespacesManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "m_globalImportList",
    "type" : "StylesheetComposed[]",
    "comment" : "\n   * The combined list of imports.  The stylesheet with the highest\n   * import precedence will be at element 0.  The one with the lowest\n   * import precedence will be at element length - 1.\n   * @serial\n   ",
    "links" : [ ]
  }, {
    "name" : "m_outputProperties",
    "type" : "OutputProperties",
    "comment" : "\n   * This will be set up with the default values, and then the values\n   * will be set as stylesheets are encountered.\n   * @serial\n   ",
    "links" : [ ]
  }, {
    "name" : "m_outputMethodSet",
    "type" : "boolean",
    "comment" : " Flag indicating whether an output method has been set by the user.\n   *  @serial           ",
    "links" : [ ]
  }, {
    "name" : "m_attrSets",
    "type" : "HashMap",
    "comment" : "\n   * Composed set of all included and imported attribute set properties.\n   * Each entry is a vector of ElemAttributeSet objects.\n   * @serial\n   ",
    "links" : [ ]
  }, {
    "name" : "m_decimalFormatSymbols",
    "type" : "Hashtable",
    "comment" : "\n   * Table of DecimalFormatSymbols, keyed by QName.\n   * @serial\n   ",
    "links" : [ ]
  }, {
    "name" : "m_keyDecls",
    "type" : "Vector",
    "comment" : "\n   * A list of all key declarations visible from this stylesheet and all\n   * lesser stylesheets.\n   * @serial\n   ",
    "links" : [ ]
  }, {
    "name" : "m_namespaceAliasComposed",
    "type" : "Hashtable",
    "comment" : "\n   * Composed set of all namespace aliases.\n   * @serial\n   ",
    "links" : [ ]
  }, {
    "name" : "m_templateList",
    "type" : "TemplateList",
    "comment" : "\n   * The \"xsl:template\" properties.\n   * @serial\n   ",
    "links" : [ ]
  }, {
    "name" : "m_variables",
    "type" : "Vector",
    "comment" : "\n   * Composed set of all variables and params.\n   * @serial\n   ",
    "links" : [ ]
  }, {
    "name" : "m_whiteSpaceInfoList",
    "type" : "TemplateList",
    "comment" : "\n   * A list of properties that specify how to do space\n   * stripping. This uses the same exact mechanism as Templates.\n   * @serial\n   ",
    "links" : [ ]
  }, {
    "name" : "m_defaultTextRule",
    "type" : "ElemTemplate",
    "comment" : "\n   * The default template to use for text nodes if we don't find\n   * anything else.  This is initialized in initDefaultRule().\n   * @serial\n   * @xsl.usage advanced\n   ",
    "links" : [ ]
  }, {
    "name" : "m_defaultRule",
    "type" : "ElemTemplate",
    "comment" : "\n   * The default template to use if we don't find anything\n   * else.  This is initialized in initDefaultRule().\n   * @serial\n   * @xsl.usage advanced\n   ",
    "links" : [ ]
  }, {
    "name" : "m_defaultRootRule",
    "type" : "ElemTemplate",
    "comment" : "\n   * The default template to use for the root if we don't find\n   * anything else.  This is initialized in initDefaultRule().\n   * We kind of need this because the defaultRule isn't good\n   * enough because it doesn't supply a document context.\n   * For now, I default the root document element to \"HTML\".\n   * Don't know if this is really a good idea or not.\n   * I suspect it is not.\n   * @serial\n   * @xsl.usage advanced\n   ",
    "links" : [ ]
  }, {
    "name" : "m_startRule",
    "type" : "ElemTemplate",
    "comment" : "\n   * The start rule to kick off the transformation.\n   * @serial\n   * @xsl.usage advanced\n   ",
    "links" : [ ]
  }, {
    "name" : "m_selectDefault",
    "type" : "XPath",
    "comment" : "\n   * Used for default selection.\n   * @serial\n   ",
    "links" : [ ]
  }, {
    "name" : "m_composeState",
    "type" : "ComposeState",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "m_extensionHandlerClass",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public boolean isRoot()",
    "returnType" : "boolean",
    "comment" : "\n   * Tell if this is the root of the stylesheet tree.\n   *\n   * @return True since this is the root of the stylesheet tree.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void setSecureProcessing(boolean flag)",
    "returnType" : "void",
    "comment" : "\n   * Set the state of the secure processing feature.\n   ",
    "links" : [ ]
  }, {
    "name" : "public boolean isSecureProcessing()",
    "returnType" : "boolean",
    "comment" : "\n   * Return the state of the secure processing feature.\n   ",
    "links" : [ ]
  }, {
    "name" : "public HashMap getAvailableElements()",
    "returnType" : "HashMap",
    "comment" : "\n   * Get the hashtable of available elements.\n   *\n   * @return table of available elements, keyed by qualified names, and with \n   * values of the same qualified names.\n   ",
    "links" : [ ]
  }, {
    "name" : "public ExtensionNamespacesManager getExtensionNamespacesManager()",
    "returnType" : "ExtensionNamespacesManager",
    "comment" : "\n   * Only instantiate an ExtensionNamespacesManager if one is called for\n   * (i.e., if the stylesheet contains  extension functions and/or elements).\n   ",
    "links" : [ ]
  }, {
    "name" : "public Vector getExtensions()",
    "returnType" : "Vector",
    "comment" : "\n   * Get the vector of extension namespaces. Used to provide\n   * the extensions table access to a list of extension\n   * namespaces encountered during composition of a stylesheet.\n   ",
    "links" : [ ]
  }, {
    "name" : "public Transformer newTransformer()",
    "returnType" : "Transformer",
    "comment" : "\n   * Create a new transformation context for this Templates object.\n   *\n   * @return A Transformer instance, never null.\n   ",
    "links" : [ ]
  }, {
    "name" : "public Properties getDefaultOutputProps()",
    "returnType" : "Properties",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Properties getOutputProperties()",
    "returnType" : "Properties",
    "comment" : "\n   * Get the static properties for xsl:output.  The object returned will\n   * be a clone of the internal values, and thus it can be mutated\n   * without mutating the Templates object, and then handed in to\n   * the process method.\n   *\n   * <p>For XSLT, Attribute Value Templates attribute values will\n   * be returned unexpanded (since there is no context at this point).</p>\n   *\n   * @return A Properties object, not null.\n   ",
    "links" : [ ]
  }, {
    "name" : "public void recompose() throws TransformerException",
    "returnType" : "void",
    "comment" : "\n   * Recompose the values of all \"composed\" properties, meaning\n   * properties that need to be combined or calculated from\n   * the combination of imported and included stylesheets.  This\n   * method determines the proper import precedence of all imported\n   * stylesheets.  It then iterates through all of the elements and \n   * properties in the proper order and triggers the individual recompose\n   * methods.\n   *\n   * @throws TransformerException\n   ",
    "links" : [ ]
  }, {
    "name" : " void composeTemplates(ElemTemplateElement templ) throws TransformerException",
    "returnType" : "void",
    "comment" : "\n   * Call the compose function for each ElemTemplateElement.\n   *\n   * @param templ non-null reference to template element that will have \n   * the composed method called on it, and will have it's children's composed \n   * methods called.\n   ",
    "links" : [ ]
  }, {
    "name" : "protected void addImports(Stylesheet stylesheet, boolean addToList, Vector importList)",
    "returnType" : "void",
    "comment" : "\n   * Add the imports in the given sheet to the working importList vector.\n   * The will be added from highest import precedence to\n   * least import precedence.  This is a post-order traversal of the\n   * import tree as described in <a href=\"http://www.w3.org/TR/xslt.html#import\">the\n   * XSLT Recommendation</a>.\n   * <p>For example, suppose</p>\n   * <p>stylesheet A imports stylesheets B and C in that order;</p>\n   * <p>stylesheet B imports stylesheet D;</p>\n   * <p>stylesheet C imports stylesheet E.</p>\n   * <p>Then the order of import precedence (highest first) is\n   * A, C, E, B, D.</p>\n   *\n   * @param stylesheet Stylesheet to examine for imports.\n   * @param addToList  <code>true</code> if this template should be added to the import list\n   * @param importList The working import list.  Templates are added here in the reverse\n   *        order of priority.  When we're all done, we'll reverse this to the correct\n   *        priority in an array.\n   ",
    "links" : [ ]
  }, {
    "name" : "public StylesheetComposed getGlobalImport(int i)",
    "returnType" : "StylesheetComposed",
    "comment" : "\n   * Get a stylesheet from the global import list. \n   * TODO: JKESS PROPOSES SPECIAL-CASE FOR NO IMPORT LIST, TO MATCH COUNT.\n   * \n   * @param i Index of stylesheet to get from global import list \n   *\n   * @return The stylesheet at the given index \n   ",
    "links" : [ ]
  }, {
    "name" : "public int getGlobalImportCount()",
    "returnType" : "int",
    "comment" : "\n   * Get the total number of imports in the global import list.\n   * \n   * @return The total number of imported stylesheets, including\n   * the root stylesheet, thus the number will always be 1 or\n   * greater.\n   * TODO: JKESS PROPOSES SPECIAL-CASE FOR NO IMPORT LIST, TO MATCH DESCRIPTION.\n   ",
    "links" : [ ]
  }, {
    "name" : "public int getImportNumber(StylesheetComposed sheet)",
    "returnType" : "int",
    "comment" : "\n   * Given a stylesheet, return the number of the stylesheet\n   * in the global import list.\n   * @param sheet The stylesheet which will be located in the\n   * global import list.\n   * @return The index into the global import list of the given stylesheet,\n   * or -1 if it is not found (which should never happen).\n   ",
    "links" : [ ]
  }, {
    "name" : " void recomposeOutput(OutputProperties oprops) throws TransformerException",
    "returnType" : "void",
    "comment" : "\n   * Recompose the output format object from the included elements.\n   *\n   * @param oprops non-null reference to xsl:output properties representation.\n   ",
    "links" : [ ]
  }, {
    "name" : "public OutputProperties getOutputComposed()",
    "returnType" : "OutputProperties",
    "comment" : "\n   * Get the combined \"xsl:output\" property with the properties\n   * combined from the included stylesheets.  If a xsl:output\n   * is not declared in this stylesheet or an included stylesheet,\n   * look in the imports.\n   * Please note that this returns a reference to the OutputProperties\n   * object, not a cloned object, like getOutputProperties does.\n   * @see <a href=\"http://www.w3.org/TR/xslt#output\">output in XSLT Specification</a>\n   *\n   * @return non-null reference to composed output properties object.\n   ",
    "links" : [ ]
  }, {
    "name" : "public boolean isOutputMethodSet()",
    "returnType" : "boolean",
    "comment" : "\n   * Find out if an output method has been set by the user.\n   *\n   * @return Value indicating whether an output method has been set by the user\n   * @xsl.usage internal\n   ",
    "links" : [ ]
  }, {
    "name" : " void recomposeAttributeSets(ElemAttributeSet attrSet)",
    "returnType" : "void",
    "comment" : "\n   * Recompose the attribute-set declarations.\n   *\n   * @param attrSet An attribute-set to add to the hashtable of attribute sets.\n   ",
    "links" : [ ]
  }, {
    "name" : "public ArrayList getAttributeSetComposed(QName name) throws ArrayIndexOutOfBoundsException",
    "returnType" : "ArrayList",
    "comment" : "\n   * Get a list \"xsl:attribute-set\" properties that match the qname.\n   * @see <a href=\"http://www.w3.org/TR/xslt#attribute-sets\">attribute-sets in XSLT Specification</a>\n   *\n   * @param name Qualified name of attribute set properties to get\n   *\n   * @return A vector of attribute sets matching the given name\n   *\n   * @throws ArrayIndexOutOfBoundsException\n   ",
    "links" : [ ]
  }, {
    "name" : " void recomposeDecimalFormats(DecimalFormatProperties dfp)",
    "returnType" : "void",
    "comment" : "\n   * Recompose the decimal-format declarations.\n   *\n   * @param dfp A DecimalFormatProperties to add to the hashtable of decimal formats.\n   ",
    "links" : [ ]
  }, {
    "name" : "public DecimalFormatSymbols getDecimalFormatComposed(QName name)",
    "returnType" : "DecimalFormatSymbols",
    "comment" : "\n   * Given a valid element decimal-format name, return the\n   * decimalFormatSymbols with that name.\n   * <p>It is an error to declare either the default decimal-format or\n   * a decimal-format with a given name more than once (even with\n   * different import precedence), unless it is declared every\n   * time with the same value for all attributes (taking into\n   * account any default values).</p>\n   * <p>Which means, as far as I can tell, the decimal-format\n   * properties are not additive.</p>\n   *\n   * @param name Qualified name of the decimal format to find \n   * @return DecimalFormatSymbols object matching the given name or\n   * null if name is not found.\n   ",
    "links" : [ ]
  }, {
    "name" : " void recomposeKeys(KeyDeclaration keyDecl)",
    "returnType" : "void",
    "comment" : "\n   * Recompose the key declarations.\n   *\n   * @param keyDecl A KeyDeclaration to be added to the vector of key declarations.\n   ",
    "links" : [ ]
  }, {
    "name" : "public Vector getKeysComposed()",
    "returnType" : "Vector",
    "comment" : "\n   * Get the composed \"xsl:key\" properties.\n   * @see <a href=\"http://www.w3.org/TR/xslt#key\">key in XSLT Specification</a>\n   *\n   * @return A vector of the composed \"xsl:key\" properties.\n   ",
    "links" : [ ]
  }, {
    "name" : " void recomposeNamespaceAliases(NamespaceAlias nsAlias)",
    "returnType" : "void",
    "comment" : "\n   * Recompose the namespace-alias declarations.\n   *\n   * @param nsAlias A NamespaceAlias object to add to the hashtable of namespace aliases.\n   ",
    "links" : [ ]
  }, {
    "name" : "public NamespaceAlias getNamespaceAliasComposed(String uri)",
    "returnType" : "NamespaceAlias",
    "comment" : "\n   * Get the \"xsl:namespace-alias\" property.\n   * Return the NamespaceAlias for a given namespace uri.\n   * @see <a href=\"http://www.w3.org/TR/xslt#literal-result-element\">literal-result-element in XSLT Specification</a>\n   *\n   * @param uri non-null reference to namespace that is to be aliased.\n   *\n   * @return NamespaceAlias that matches uri, or null if no match.\n   ",
    "links" : [ ]
  }, {
    "name" : " void recomposeTemplates(ElemTemplate template)",
    "returnType" : "void",
    "comment" : "\n   * Recompose the template declarations.\n   *\n   * @param template An ElemTemplate object to add to the template list.\n   ",
    "links" : [ ]
  }, {
    "name" : "public final TemplateList getTemplateListComposed()",
    "returnType" : "TemplateList",
    "comment" : "\n   * Accessor method to retrieve the <code>TemplateList</code> associated with\n   * this StylesheetRoot.\n   * \n   * @return The composed <code>TemplateList</code>.\n   ",
    "links" : [ ]
  }, {
    "name" : "public final void setTemplateListComposed(TemplateList templateList)",
    "returnType" : "void",
    "comment" : "\n   * Mutator method to set the <code>TemplateList</code> associated with this\n   * StylesheetRoot.  This method should only be used by the compiler.  Normally,\n   * the template list is built during the recompose process and should not be\n   * altered by the user.\n   * @param templateList The new <code>TemplateList</code> for this StylesheetRoot.\n   ",
    "links" : [ ]
  }, {
    "name" : "public ElemTemplate getTemplateComposed(XPathContext xctxt, int targetNode, QName mode, boolean quietConflictWarnings, DTM dtm) throws TransformerException",
    "returnType" : "ElemTemplate",
    "comment" : "\n   * Get an \"xsl:template\" property by node match. This looks in the imports as\n   * well as this stylesheet.\n   * @see <a href=\"http://www.w3.org/TR/xslt#section-Defining-Template-Rules\">section-Defining-Template-Rules in XSLT Specification</a>\n   *\n   * @param xctxt non-null reference to XPath runtime execution context.\n   * @param targetNode non-null reference of node that the template must match.\n   * @param mode qualified name of the node, or null.\n   * @param quietConflictWarnings true if conflict warnings should not be reported.\n   *\n   * @return reference to ElemTemplate that is the best match for targetNode, or \n   *         null if no match could be made.\n   *\n   * @throws TransformerException\n   ",
    "links" : [ ]
  }, {
    "name" : "public ElemTemplate getTemplateComposed(XPathContext xctxt, int targetNode, QName mode, int maxImportLevel, int endImportLevel, boolean quietConflictWarnings, DTM dtm) throws TransformerException",
    "returnType" : "ElemTemplate",
    "comment" : "\n   * Get an \"xsl:template\" property by node match. This looks in the imports as\n   * well as this stylesheet.\n   * @see <a href=\"http://www.w3.org/TR/xslt#section-Defining-Template-Rules\">section-Defining-Template-Rules in XSLT Specification</a>\n   *\n   * @param xctxt non-null reference to XPath runtime execution context.\n   * @param targetNode non-null reference of node that the template must match.\n   * @param mode qualified name of the node, or null.\n   * @param maxImportLevel The maximum importCountComposed that we should consider or -1\n   *        if we should consider all import levels.  This is used by apply-imports to\n   *        access templates that have been overridden.\n   * @param endImportLevel The count of composed imports\n   * @param quietConflictWarnings true if conflict warnings should not be reported.\n   *\n   * @return reference to ElemTemplate that is the best match for targetNode, or \n   *         null if no match could be made.\n   *\n   * @throws TransformerException\n   ",
    "links" : [ ]
  }, {
    "name" : "public ElemTemplate getTemplateComposed(QName qname)",
    "returnType" : "ElemTemplate",
    "comment" : "\n   * Get an \"xsl:template\" property. This looks in the imports as\n   * well as this stylesheet.\n   * @see <a href=\"http://www.w3.org/TR/xslt#section-Defining-Template-Rules\">section-Defining-Template-Rules in XSLT Specification</a>\n   *\n   * @param qname non-null reference to qualified name of template.\n   *\n   * @return reference to named template, or null if not found.\n   ",
    "links" : [ ]
  }, {
    "name" : " void recomposeVariables(ElemVariable elemVar)",
    "returnType" : "void",
    "comment" : "\n   * Recompose the top level variable and parameter declarations.\n   *\n   * @param elemVar A top level variable or parameter to be added to the Vector.\n   ",
    "links" : [ ]
  }, {
    "name" : "public ElemVariable getVariableOrParamComposed(QName qname)",
    "returnType" : "ElemVariable",
    "comment" : "\n   * Get an \"xsl:variable\" property.\n   * @see <a href=\"http://www.w3.org/TR/xslt#top-level-variables\">top-level-variables in XSLT Specification</a>\n   *\n   * @param qname Qualified name of variable or param\n   *\n   * @return The ElemVariable with the given qualified name\n   ",
    "links" : [ ]
  }, {
    "name" : "public Vector getVariablesAndParamsComposed()",
    "returnType" : "Vector",
    "comment" : "\n   * Get all global \"xsl:variable\" properties in scope for this stylesheet.\n   * @see <a href=\"http://www.w3.org/TR/xslt#top-level-variables\">top-level-variables in XSLT Specification</a>\n   *\n   * @return Vector of all variables and params in scope\n   ",
    "links" : [ ]
  }, {
    "name" : " void recomposeWhiteSpaceInfo(WhiteSpaceInfo wsi)",
    "returnType" : "void",
    "comment" : "\n   * Recompose the strip-space and preserve-space declarations.\n   *\n   * @param wsi A WhiteSpaceInfo element to add to the list of WhiteSpaceInfo elements.\n   ",
    "links" : [ ]
  }, {
    "name" : "public boolean shouldCheckWhitespace()",
    "returnType" : "boolean",
    "comment" : "\n   * Check to see if the caller should bother with check for\n   * whitespace nodes.\n   *\n   * @return Whether the caller should bother with check for\n   * whitespace nodes.\n   ",
    "links" : [ ]
  }, {
    "name" : "public WhiteSpaceInfo getWhiteSpaceInfo(XPathContext support, int targetElement, DTM dtm) throws TransformerException",
    "returnType" : "WhiteSpaceInfo",
    "comment" : "\n   * Get information about whether or not an element should strip whitespace.\n   * @see <a href=\"http://www.w3.org/TR/xslt#strip\">strip in XSLT Specification</a>\n   *\n   * @param support The XPath runtime state.\n   * @param targetElement Element to check\n   *\n   * @return WhiteSpaceInfo for the given element\n   *\n   * @throws TransformerException\n   ",
    "links" : [ ]
  }, {
    "name" : "public boolean shouldStripWhiteSpace(XPathContext support, int targetElement) throws TransformerException",
    "returnType" : "boolean",
    "comment" : "\n   * Get information about whether or not an element should strip whitespace.\n   * @see <a href=\"http://www.w3.org/TR/xslt#strip\">strip in XSLT Specification</a>\n   *\n   * @param support The XPath runtime state.\n   * @param targetElement Element to check\n   *\n   * @return true if the whitespace should be stripped.\n   *\n   * @throws TransformerException\n   ",
    "links" : [ ]
  }, {
    "name" : "public boolean canStripWhiteSpace()",
    "returnType" : "boolean",
    "comment" : "\n   * Get information about whether or not whitespace can be stripped.\n   * @see <a href=\"http://www.w3.org/TR/xslt#strip\">strip in XSLT Specification</a>\n   *\n   * @return true if the whitespace can be stripped.\n   ",
    "links" : [ ]
  }, {
    "name" : "public final ElemTemplate getDefaultTextRule()",
    "returnType" : "ElemTemplate",
    "comment" : "\n   * Get the default template for text.\n   *\n   * @return the default template for text.\n   * @xsl.usage advanced\n   ",
    "links" : [ ]
  }, {
    "name" : "public final ElemTemplate getDefaultRule()",
    "returnType" : "ElemTemplate",
    "comment" : "\n   * Get the default template for elements.\n   *\n   * @return the default template for elements.\n   * @xsl.usage advanced\n   ",
    "links" : [ ]
  }, {
    "name" : "public final ElemTemplate getDefaultRootRule()",
    "returnType" : "ElemTemplate",
    "comment" : "\n   * Get the default template for a root node.\n   *\n   * @return The default template for a root node.\n   * @xsl.usage advanced\n   ",
    "links" : [ ]
  }, {
    "name" : "public final ElemTemplate getStartRule()",
    "returnType" : "ElemTemplate",
    "comment" : "\n   * Get the default template for a root node.\n   *\n   * @return The default template for a root node.\n   * @xsl.usage advanced\n   ",
    "links" : [ ]
  }, {
    "name" : "private void initDefaultRule(ErrorListener errorListener) throws TransformerException",
    "returnType" : "void",
    "comment" : "\n   * Create the default rule if needed.\n   *\n   * @throws TransformerException\n   ",
    "links" : [ ]
  }, {
    "name" : "private void QuickSort2(Vector v, int lo0, int hi0)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void initComposeState()",
    "returnType" : "void",
    "comment" : "\n     * Initialize a new ComposeState.\n     ",
    "links" : [ ]
  }, {
    "name" : " ComposeState getComposeState()",
    "returnType" : "ComposeState",
    "comment" : "\n     * Return class to track state global state during the compose() operation.\n     * @return ComposeState reference, or null if endCompose has been called.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void clearComposeState()",
    "returnType" : "void",
    "comment" : "\n     * Clear the compose state.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String setExtensionHandlerClass(String handlerClassName)",
    "returnType" : "String",
    "comment" : "\n     * This internal method allows the setting of the java class\n     * to handle the extension function (if other than the default one).\n     * \n     * @xsl.usage internal\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getExtensionHandlerClass()",
    "returnType" : "String",
    "comment" : "\n     * \n     * @xsl.usage internal\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getOptimizer()",
    "returnType" : "boolean",
    "comment" : "\n     * @return Optimization flag\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOptimizer(boolean b)",
    "returnType" : "void",
    "comment" : "\n     * @param b Optimization flag\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getIncremental()",
    "returnType" : "boolean",
    "comment" : "\n     * @return Incremental flag\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getSource_location()",
    "returnType" : "boolean",
    "comment" : "\n     * @return source location flag\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setIncremental(boolean b)",
    "returnType" : "void",
    "comment" : "\n     * @param b Incremental flag\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSource_location(boolean b)",
    "returnType" : "void",
    "comment" : "\n     * @param b Source location flag\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public boolean isRoot()", "public void setSecureProcessing(boolean flag)", "public boolean isSecureProcessing()", "public HashMap getAvailableElements()", "public ExtensionNamespacesManager getExtensionNamespacesManager()", "public Vector getExtensions()", "public Transformer newTransformer()", "public Properties getDefaultOutputProps()", "public Properties getOutputProperties()", "public void recompose() throws TransformerException", " void composeTemplates(ElemTemplateElement templ) throws TransformerException", "protected void addImports(Stylesheet stylesheet, boolean addToList, Vector importList)", "public StylesheetComposed getGlobalImport(int i)", "public int getGlobalImportCount()", "public int getImportNumber(StylesheetComposed sheet)", " void recomposeOutput(OutputProperties oprops) throws TransformerException", "public OutputProperties getOutputComposed()", "public boolean isOutputMethodSet()", " void recomposeAttributeSets(ElemAttributeSet attrSet)", "public ArrayList getAttributeSetComposed(QName name) throws ArrayIndexOutOfBoundsException", " void recomposeDecimalFormats(DecimalFormatProperties dfp)", "public DecimalFormatSymbols getDecimalFormatComposed(QName name)", " void recomposeKeys(KeyDeclaration keyDecl)", "public Vector getKeysComposed()", " void recomposeNamespaceAliases(NamespaceAlias nsAlias)", "public NamespaceAlias getNamespaceAliasComposed(String uri)", " void recomposeTemplates(ElemTemplate template)", "public final TemplateList getTemplateListComposed()", "public final void setTemplateListComposed(TemplateList templateList)", "public ElemTemplate getTemplateComposed(XPathContext xctxt, int targetNode, QName mode, boolean quietConflictWarnings, DTM dtm) throws TransformerException", "public ElemTemplate getTemplateComposed(XPathContext xctxt, int targetNode, QName mode, int maxImportLevel, int endImportLevel, boolean quietConflictWarnings, DTM dtm) throws TransformerException", "public ElemTemplate getTemplateComposed(QName qname)", " void recomposeVariables(ElemVariable elemVar)", "public ElemVariable getVariableOrParamComposed(QName qname)", "public Vector getVariablesAndParamsComposed()", " void recomposeWhiteSpaceInfo(WhiteSpaceInfo wsi)", "public boolean shouldCheckWhitespace()", "public WhiteSpaceInfo getWhiteSpaceInfo(XPathContext support, int targetElement, DTM dtm) throws TransformerException", "public boolean shouldStripWhiteSpace(XPathContext support, int targetElement) throws TransformerException", "public boolean canStripWhiteSpace()", "public final ElemTemplate getDefaultTextRule()", "public final ElemTemplate getDefaultRule()", "public final ElemTemplate getDefaultRootRule()", "public final ElemTemplate getStartRule()", "private void initDefaultRule(ErrorListener errorListener) throws TransformerException", "private void QuickSort2(Vector v, int lo0, int hi0)", " void initComposeState()", " ComposeState getComposeState()", "private void clearComposeState()", "public String setExtensionHandlerClass(String handlerClassName)", "public String getExtensionHandlerClass()", "public boolean getOptimizer()", "public void setOptimizer(boolean b)", "public boolean getIncremental()", "public boolean getSource_location()", "public void setIncremental(boolean b)", "public void setSource_location(boolean b)" ],
  "variableNames" : [ "serialVersionUID", "m_optimizer", "m_incremental", "m_source_location", "m_isSecureProcessing", "m_availElems", "m_extNsMgr", "m_globalImportList", "m_outputProperties", "m_outputMethodSet", "m_attrSets", "m_decimalFormatSymbols", "m_keyDecls", "m_namespaceAliasComposed", "m_templateList", "m_variables", "m_whiteSpaceInfoList", "m_defaultTextRule", "m_defaultRule", "m_defaultRootRule", "m_startRule", "m_selectDefault", "m_composeState", "m_extensionHandlerClass" ]
}