{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/util/Map.java",
  "packageName" : "java.util",
  "className" : "Map",
  "comment" : "\n * An object that maps keys to values.  A map cannot contain duplicate keys;\n * each key can map to at most one value.\n *\n * <p>This interface takes the place of the {@code Dictionary} class, which\n * was a totally abstract class rather than an interface.\n *\n * <p>The {@code Map} interface provides three <i>collection views</i>, which\n * allow a map's contents to be viewed as a set of keys, collection of values,\n * or set of key-value mappings.  The <i>order</i> of a map is defined as\n * the order in which the iterators on the map's collection views return their\n * elements.  Some map implementations, like the {@code TreeMap} class, make\n * specific guarantees as to their order; others, like the {@code HashMap}\n * class, do not.\n *\n * <p>Note: great care must be exercised if mutable objects are used as map\n * keys.  The behavior of a map is not specified if the value of an object is\n * changed in a manner that affects {@code equals} comparisons while the\n * object is a key in the map.  A special case of this prohibition is that it\n * is not permissible for a map to contain itself as a key.  While it is\n * permissible for a map to contain itself as a value, extreme caution is\n * advised: the {@code equals} and {@code hashCode} methods are no longer\n * well defined on such a map.\n *\n * <p>All general-purpose map implementation classes should provide two\n * \"standard\" constructors: a void (no arguments) constructor which creates an\n * empty map, and a constructor with a single argument of type {@code Map},\n * which creates a new map with the same key-value mappings as its argument.\n * In effect, the latter constructor allows the user to copy any map,\n * producing an equivalent map of the desired class.  There is no way to\n * enforce this recommendation (as interfaces cannot contain constructors) but\n * all of the general-purpose map implementations in the JDK comply.\n *\n * <p>The \"destructive\" methods contained in this interface, that is, the\n * methods that modify the map on which they operate, are specified to throw\n * {@code UnsupportedOperationException} if this map does not support the\n * operation.  If this is the case, these methods may, but are not required\n * to, throw an {@code UnsupportedOperationException} if the invocation would\n * have no effect on the map.  For example, invoking the {@link #putAll(Map)}\n * method on an unmodifiable map may, but is not required to, throw the\n * exception if the map whose mappings are to be \"superimposed\" is empty.\n *\n * <p>Some map implementations have restrictions on the keys and values they\n * may contain.  For example, some implementations prohibit null keys and\n * values, and some have restrictions on the types of their keys.  Attempting\n * to insert an ineligible key or value throws an unchecked exception,\n * typically {@code NullPointerException} or {@code ClassCastException}.\n * Attempting to query the presence of an ineligible key or value may throw an\n * exception, or it may simply return false; some implementations will exhibit\n * the former behavior and some will exhibit the latter.  More generally,\n * attempting an operation on an ineligible key or value whose completion\n * would not result in the insertion of an ineligible element into the map may\n * throw an exception or it may succeed, at the option of the implementation.\n * Such exceptions are marked as \"optional\" in the specification for this\n * interface.\n *\n * <p>Many methods in Collections Framework interfaces are defined\n * in terms of the {@link Object#equals(Object) equals} method.  For\n * example, the specification for the {@link #containsKey(Object)\n * containsKey(Object key)} method says: \"returns {@code true} if and\n * only if this map contains a mapping for a key {@code k} such that\n * {@code (key==null ? k==null : key.equals(k))}.\" This specification should\n * <i>not</i> be construed to imply that invoking {@code Map.containsKey}\n * with a non-null argument {@code key} will cause {@code key.equals(k)} to\n * be invoked for any key {@code k}.  Implementations are free to\n * implement optimizations whereby the {@code equals} invocation is avoided,\n * for example, by first comparing the hash codes of the two keys.  (The\n * {@link Object#hashCode()} specification guarantees that two objects with\n * unequal hash codes cannot be equal.)  More generally, implementations of\n * the various Collections Framework interfaces are free to take advantage of\n * the specified behavior of underlying {@link Object} methods wherever the\n * implementor deems it appropriate.\n *\n * <p>Some map operations which perform recursive traversal of the map may fail\n * with an exception for self-referential instances where the map directly or\n * indirectly contains itself. This includes the {@code clone()},\n * {@code equals()}, {@code hashCode()} and {@code toString()} methods.\n * Implementations may optionally handle the self-referential scenario, however\n * most current implementations do not do so.\n *\n * <h2><a id=\"unmodifiable\">Unmodifiable Maps</a></h2>\n * <p>The {@link Map#of() Map.of},\n * {@link Map#ofEntries(Map.Entry...) Map.ofEntries}, and\n * {@link Map#copyOf Map.copyOf}\n * static factory methods provide a convenient way to create unmodifiable maps.\n * The {@code Map}\n * instances created by these methods have the following characteristics:\n *\n * <ul>\n * <li>They are <a href=\"Collection.html#unmodifiable\"><i>unmodifiable</i></a>. Keys and values\n * cannot be added, removed, or updated. Calling any mutator method on the Map\n * will always cause {@code UnsupportedOperationException} to be thrown.\n * However, if the contained keys or values are themselves mutable, this may cause the\n * Map to behave inconsistently or its contents to appear to change.\n * <li>They disallow {@code null} keys and values. Attempts to create them with\n * {@code null} keys or values result in {@code NullPointerException}.\n * <li>They are serializable if all keys and values are serializable.\n * <li>They reject duplicate keys at creation time. Duplicate keys\n * passed to a static factory method result in {@code IllegalArgumentException}.\n * <li>The iteration order of mappings is unspecified and is subject to change.\n * <li>They are <a href=\"../lang/doc-files/ValueBased.html\">value-based</a>.\n * Programmers should treat instances that are {@linkplain #equals(Object) equal}\n * as interchangeable and should not use them for synchronization, or\n * unpredictable behavior may occur. For example, in a future release,\n * synchronization may fail. Callers should make no assumptions\n * about the identity of the returned instances. Factories are free to\n * create new instances or reuse existing ones.\n * <li>They are serialized as specified on the\n * <a href=\"{@docRoot}/serialized-form.html#java.util.CollSer\">Serialized Form</a>\n * page.\n * </ul>\n *\n * <p>This interface is a member of the\n * <a href=\"{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework\">\n * Java Collections Framework</a>.\n *\n * @param <K> the type of keys maintained by this map\n * @param <V> the type of mapped values\n *\n * @author  Josh Bloch\n * @see HashMap\n * @see TreeMap\n * @see Hashtable\n * @see SortedMap\n * @see Collection\n * @see Set\n * @since 1.2\n ",
  "links" : [ "#containsKey(Object)", "java.util.Map#of()", "#equals(Object)", "java.util.Map#copyOf", "#hashCode()", "Object", "#putAll(Map)", "java.util.Map#ofEntries(Map.Entry...)" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " int size()",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of key-value mappings in this map.  If the\n     * map contains more than {@code Integer.MAX_VALUE} elements, returns\n     * {@code Integer.MAX_VALUE}.\n     *\n     * @return the number of key-value mappings in this map\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean isEmpty()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if this map contains no key-value mappings.\n     *\n     * @return {@code true} if this map contains no key-value mappings\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean containsKey(Object key)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if this map contains a mapping for the specified\n     * key.  More formally, returns {@code true} if and only if\n     * this map contains a mapping for a key {@code k} such that\n     * {@code Objects.equals(key, k)}.  (There can be\n     * at most one such mapping.)\n     *\n     * @param key key whose presence in this map is to be tested\n     * @return {@code true} if this map contains a mapping for the specified\n     *         key\n     * @throws ClassCastException if the key is of an inappropriate type for\n     *         this map\n     * (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws NullPointerException if the specified key is null and this map\n     *         does not permit null keys\n     * (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean containsValue(Object value)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if this map maps one or more keys to the\n     * specified value.  More formally, returns {@code true} if and only if\n     * this map contains at least one mapping to a value {@code v} such that\n     * {@code Objects.equals(value, v)}.  This operation\n     * will probably require time linear in the map size for most\n     * implementations of the {@code Map} interface.\n     *\n     * @param value value whose presence in this map is to be tested\n     * @return {@code true} if this map maps one or more keys to the\n     *         specified value\n     * @throws ClassCastException if the value is of an inappropriate type for\n     *         this map\n     * (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws NullPointerException if the specified value is null and this\n     *         map does not permit null values\n     * (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     ",
    "links" : [ ]
  }, {
    "name" : " V get(Object key)",
    "returnType" : "V",
    "comment" : "\n     * Returns the value to which the specified key is mapped,\n     * or {@code null} if this map contains no mapping for the key.\n     *\n     * <p>More formally, if this map contains a mapping from a key\n     * {@code k} to a value {@code v} such that\n     * {@code Objects.equals(key, k)},\n     * then this method returns {@code v}; otherwise\n     * it returns {@code null}.  (There can be at most one such mapping.)\n     *\n     * <p>If this map permits null values, then a return value of\n     * {@code null} does not <i>necessarily</i> indicate that the map\n     * contains no mapping for the key; it's also possible that the map\n     * explicitly maps the key to {@code null}.  The {@link #containsKey\n     * containsKey} operation may be used to distinguish these two cases.\n     *\n     * @param key the key whose associated value is to be returned\n     * @return the value to which the specified key is mapped, or\n     *         {@code null} if this map contains no mapping for the key\n     * @throws ClassCastException if the key is of an inappropriate type for\n     *         this map\n     * (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws NullPointerException if the specified key is null and this map\n     *         does not permit null keys\n     * (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     ",
    "links" : [ "#containsKeycontainsKey" ]
  }, {
    "name" : " V put(K key, V value)",
    "returnType" : "V",
    "comment" : "\n     * Associates the specified value with the specified key in this map\n     * (optional operation).  If the map previously contained a mapping for\n     * the key, the old value is replaced by the specified value.  (A map\n     * {@code m} is said to contain a mapping for a key {@code k} if and only\n     * if {@link #containsKey(Object) m.containsKey(k)} would return\n     * {@code true}.)\n     *\n     * @param key key with which the specified value is to be associated\n     * @param value value to be associated with the specified key\n     * @return the previous value associated with {@code key}, or\n     *         {@code null} if there was no mapping for {@code key}.\n     *         (A {@code null} return can also indicate that the map\n     *         previously associated {@code null} with {@code key},\n     *         if the implementation supports {@code null} values.)\n     * @throws UnsupportedOperationException if the {@code put} operation\n     *         is not supported by this map\n     * @throws ClassCastException if the class of the specified key or value\n     *         prevents it from being stored in this map\n     * @throws NullPointerException if the specified key or value is null\n     *         and this map does not permit null keys or values\n     * @throws IllegalArgumentException if some property of the specified key\n     *         or value prevents it from being stored in this map\n     ",
    "links" : [ "#containsKey(Object)" ]
  }, {
    "name" : " V remove(Object key)",
    "returnType" : "V",
    "comment" : "\n     * Removes the mapping for a key from this map if it is present\n     * (optional operation).   More formally, if this map contains a mapping\n     * from key {@code k} to value {@code v} such that\n     * {@code Objects.equals(key, k)}, that mapping\n     * is removed.  (The map can contain at most one such mapping.)\n     *\n     * <p>Returns the value to which this map previously associated the key,\n     * or {@code null} if the map contained no mapping for the key.\n     *\n     * <p>If this map permits null values, then a return value of\n     * {@code null} does not <i>necessarily</i> indicate that the map\n     * contained no mapping for the key; it's also possible that the map\n     * explicitly mapped the key to {@code null}.\n     *\n     * <p>The map will not contain a mapping for the specified key once the\n     * call returns.\n     *\n     * @param key key whose mapping is to be removed from the map\n     * @return the previous value associated with {@code key}, or\n     *         {@code null} if there was no mapping for {@code key}.\n     * @throws UnsupportedOperationException if the {@code remove} operation\n     *         is not supported by this map\n     * @throws ClassCastException if the key is of an inappropriate type for\n     *         this map\n     * (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws NullPointerException if the specified key is null and this\n     *         map does not permit null keys\n     * (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     ",
    "links" : [ ]
  }, {
    "name" : " void putAll(Map<? extends K, ? extends V> m)",
    "returnType" : "void",
    "comment" : "\n     * Copies all of the mappings from the specified map to this map\n     * (optional operation).  The effect of this call is equivalent to that\n     * of calling {@link #put(Object,Object) put(k, v)} on this map once\n     * for each mapping from key {@code k} to value {@code v} in the\n     * specified map.  The behavior of this operation is undefined if the\n     * specified map is modified while the operation is in progress.\n     *\n     * @param m mappings to be stored in this map\n     * @throws UnsupportedOperationException if the {@code putAll} operation\n     *         is not supported by this map\n     * @throws ClassCastException if the class of a key or value in the\n     *         specified map prevents it from being stored in this map\n     * @throws NullPointerException if the specified map is null, or if\n     *         this map does not permit null keys or values, and the\n     *         specified map contains null keys or values\n     * @throws IllegalArgumentException if some property of a key or value in\n     *         the specified map prevents it from being stored in this map\n     ",
    "links" : [ "#put(Object" ]
  }, {
    "name" : " void clear()",
    "returnType" : "void",
    "comment" : "\n     * Removes all of the mappings from this map (optional operation).\n     * The map will be empty after this call returns.\n     *\n     * @throws UnsupportedOperationException if the {@code clear} operation\n     *         is not supported by this map\n     ",
    "links" : [ ]
  }, {
    "name" : " Set<K> keySet()",
    "returnType" : "Set<K>",
    "comment" : "\n     * Returns a {@link Set} view of the keys contained in this map.\n     * The set is backed by the map, so changes to the map are\n     * reflected in the set, and vice-versa.  If the map is modified\n     * while an iteration over the set is in progress (except through\n     * the iterator's own {@code remove} operation), the results of\n     * the iteration are undefined.  The set supports element removal,\n     * which removes the corresponding mapping from the map, via the\n     * {@code Iterator.remove}, {@code Set.remove},\n     * {@code removeAll}, {@code retainAll}, and {@code clear}\n     * operations.  It does not support the {@code add} or {@code addAll}\n     * operations.\n     *\n     * @return a set view of the keys contained in this map\n     ",
    "links" : [ "java.util.Set" ]
  }, {
    "name" : " Collection<V> values()",
    "returnType" : "Collection<V>",
    "comment" : "\n     * Returns a {@link Collection} view of the values contained in this map.\n     * The collection is backed by the map, so changes to the map are\n     * reflected in the collection, and vice-versa.  If the map is\n     * modified while an iteration over the collection is in progress\n     * (except through the iterator's own {@code remove} operation),\n     * the results of the iteration are undefined.  The collection\n     * supports element removal, which removes the corresponding\n     * mapping from the map, via the {@code Iterator.remove},\n     * {@code Collection.remove}, {@code removeAll},\n     * {@code retainAll} and {@code clear} operations.  It does not\n     * support the {@code add} or {@code addAll} operations.\n     *\n     * @return a collection view of the values contained in this map\n     ",
    "links" : [ "java.util.Collection" ]
  }, {
    "name" : " Set<Map.Entry<K, V>> entrySet()",
    "returnType" : "Set<Map.Entry<K, V>>",
    "comment" : "\n     * Returns a {@link Set} view of the mappings contained in this map.\n     * The set is backed by the map, so changes to the map are\n     * reflected in the set, and vice-versa.  If the map is modified\n     * while an iteration over the set is in progress (except through\n     * the iterator's own {@code remove} operation, or through the\n     * {@code setValue} operation on a map entry returned by the\n     * iterator) the results of the iteration are undefined.  The set\n     * supports element removal, which removes the corresponding\n     * mapping from the map, via the {@code Iterator.remove},\n     * {@code Set.remove}, {@code removeAll}, {@code retainAll} and\n     * {@code clear} operations.  It does not support the\n     * {@code add} or {@code addAll} operations.\n     *\n     * @return a set view of the mappings contained in this map\n     ",
    "links" : [ "java.util.Set" ]
  }, {
    "name" : " boolean equals(Object o)",
    "returnType" : "boolean",
    "comment" : "\n     * Compares the specified object with this map for equality.  Returns\n     * {@code true} if the given object is also a map and the two maps\n     * represent the same mappings.  More formally, two maps {@code m1} and\n     * {@code m2} represent the same mappings if\n     * {@code m1.entrySet().equals(m2.entrySet())}.  This ensures that the\n     * {@code equals} method works properly across different implementations\n     * of the {@code Map} interface.\n     *\n     * @param o object to be compared for equality with this map\n     * @return {@code true} if the specified object is equal to this map\n     ",
    "links" : [ ]
  }, {
    "name" : " int hashCode()",
    "returnType" : "int",
    "comment" : "\n     * Returns the hash code value for this map.  The hash code of a map is\n     * defined to be the sum of the hash codes of each entry in the map's\n     * {@code entrySet()} view.  This ensures that {@code m1.equals(m2)}\n     * implies that {@code m1.hashCode()==m2.hashCode()} for any two maps\n     * {@code m1} and {@code m2}, as required by the general contract of\n     * {@link Object#hashCode}.\n     *\n     * @return the hash code value for this map\n     * @see Map.Entry#hashCode()\n     * @see Object#equals(Object)\n     * @see #equals(Object)\n     ",
    "links" : [ "#hashCode" ]
  }, {
    "name" : " V getOrDefault(Object key, V defaultValue)",
    "returnType" : "V",
    "comment" : "\n     * Returns the value to which the specified key is mapped, or\n     * {@code defaultValue} if this map contains no mapping for the key.\n     *\n     * @implSpec\n     * The default implementation makes no guarantees about synchronization\n     * or atomicity properties of this method. Any implementation providing\n     * atomicity guarantees must override this method and document its\n     * concurrency properties.\n     *\n     * @param key the key whose associated value is to be returned\n     * @param defaultValue the default mapping of the key\n     * @return the value to which the specified key is mapped, or\n     * {@code defaultValue} if this map contains no mapping for the key\n     * @throws ClassCastException if the key is of an inappropriate type for\n     * this map\n     * (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws NullPointerException if the specified key is null and this map\n     * does not permit null keys\n     * (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : " void forEach(BiConsumer<? super K, ? super V> action)",
    "returnType" : "void",
    "comment" : "\n     * Performs the given action for each entry in this map until all entries\n     * have been processed or the action throws an exception.   Unless\n     * otherwise specified by the implementing class, actions are performed in\n     * the order of entry set iteration (if an iteration order is specified.)\n     * Exceptions thrown by the action are relayed to the caller.\n     *\n     * @implSpec\n     * The default implementation is equivalent to, for this {@code map}:\n     * <pre> {@code\n     * for (Map.Entry<K, V> entry : map.entrySet())\n     *     action.accept(entry.getKey(), entry.getValue());\n     * }</pre>\n     *\n     * The default implementation makes no guarantees about synchronization\n     * or atomicity properties of this method. Any implementation providing\n     * atomicity guarantees must override this method and document its\n     * concurrency properties.\n     *\n     * @param action The action to be performed for each entry\n     * @throws NullPointerException if the specified action is null\n     * @throws ConcurrentModificationException if an entry is found to be\n     * removed during iteration\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : " void replaceAll(BiFunction<? super K, ? super V, ? extends V> function)",
    "returnType" : "void",
    "comment" : "\n     * Replaces each entry's value with the result of invoking the given\n     * function on that entry until all entries have been processed or the\n     * function throws an exception.  Exceptions thrown by the function are\n     * relayed to the caller.\n     *\n     * @implSpec\n     * <p>The default implementation is equivalent to, for this {@code map}:\n     * <pre> {@code\n     * for (Map.Entry<K, V> entry : map.entrySet())\n     *     entry.setValue(function.apply(entry.getKey(), entry.getValue()));\n     * }</pre>\n     *\n     * <p>The default implementation makes no guarantees about synchronization\n     * or atomicity properties of this method. Any implementation providing\n     * atomicity guarantees must override this method and document its\n     * concurrency properties.\n     *\n     * @param function the function to apply to each entry\n     * @throws UnsupportedOperationException if the {@code set} operation\n     * is not supported by this map's entry set iterator.\n     * @throws ClassCastException if the class of a replacement value\n     * prevents it from being stored in this map\n     * @throws NullPointerException if the specified function is null, or the\n     * specified replacement value is null, and this map does not permit null\n     * values\n     * @throws ClassCastException if a replacement value is of an inappropriate\n     *         type for this map\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws NullPointerException if function or a replacement value is null,\n     *         and this map does not permit null keys or values\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws IllegalArgumentException if some property of a replacement value\n     *         prevents it from being stored in this map\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws ConcurrentModificationException if an entry is found to be\n     * removed during iteration\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : " V putIfAbsent(K key, V value)",
    "returnType" : "V",
    "comment" : "\n     * If the specified key is not already associated with a value (or is mapped\n     * to {@code null}) associates it with the given value and returns\n     * {@code null}, else returns the current value.\n     *\n     * @implSpec\n     * The default implementation is equivalent to, for this {@code map}:\n     *\n     * <pre> {@code\n     * V v = map.get(key);\n     * if (v == null)\n     *     v = map.put(key, value);\n     *\n     * return v;\n     * }</pre>\n     *\n     * <p>The default implementation makes no guarantees about synchronization\n     * or atomicity properties of this method. Any implementation providing\n     * atomicity guarantees must override this method and document its\n     * concurrency properties.\n     *\n     * @param key key with which the specified value is to be associated\n     * @param value value to be associated with the specified key\n     * @return the previous value associated with the specified key, or\n     *         {@code null} if there was no mapping for the key.\n     *         (A {@code null} return can also indicate that the map\n     *         previously associated {@code null} with the key,\n     *         if the implementation supports null values.)\n     * @throws UnsupportedOperationException if the {@code put} operation\n     *         is not supported by this map\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws ClassCastException if the key or value is of an inappropriate\n     *         type for this map\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws NullPointerException if the specified key or value is null,\n     *         and this map does not permit null keys or values\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws IllegalArgumentException if some property of the specified key\n     *         or value prevents it from being stored in this map\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean remove(Object key, Object value)",
    "returnType" : "boolean",
    "comment" : "\n     * Removes the entry for the specified key only if it is currently\n     * mapped to the specified value.\n     *\n     * @implSpec\n     * The default implementation is equivalent to, for this {@code map}:\n     *\n     * <pre> {@code\n     * if (map.containsKey(key) && Objects.equals(map.get(key), value)) {\n     *     map.remove(key);\n     *     return true;\n     * } else\n     *     return false;\n     * }</pre>\n     *\n     * <p>The default implementation makes no guarantees about synchronization\n     * or atomicity properties of this method. Any implementation providing\n     * atomicity guarantees must override this method and document its\n     * concurrency properties.\n     *\n     * @param key key with which the specified value is associated\n     * @param value value expected to be associated with the specified key\n     * @return {@code true} if the value was removed\n     * @throws UnsupportedOperationException if the {@code remove} operation\n     *         is not supported by this map\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws ClassCastException if the key or value is of an inappropriate\n     *         type for this map\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws NullPointerException if the specified key or value is null,\n     *         and this map does not permit null keys or values\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean replace(K key, V oldValue, V newValue)",
    "returnType" : "boolean",
    "comment" : "\n     * Replaces the entry for the specified key only if currently\n     * mapped to the specified value.\n     *\n     * @implSpec\n     * The default implementation is equivalent to, for this {@code map}:\n     *\n     * <pre> {@code\n     * if (map.containsKey(key) && Objects.equals(map.get(key), oldValue)) {\n     *     map.put(key, newValue);\n     *     return true;\n     * } else\n     *     return false;\n     * }</pre>\n     *\n     * The default implementation does not throw NullPointerException\n     * for maps that do not support null values if oldValue is null unless\n     * newValue is also null.\n     *\n     * <p>The default implementation makes no guarantees about synchronization\n     * or atomicity properties of this method. Any implementation providing\n     * atomicity guarantees must override this method and document its\n     * concurrency properties.\n     *\n     * @param key key with which the specified value is associated\n     * @param oldValue value expected to be associated with the specified key\n     * @param newValue value to be associated with the specified key\n     * @return {@code true} if the value was replaced\n     * @throws UnsupportedOperationException if the {@code put} operation\n     *         is not supported by this map\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws ClassCastException if the class of a specified key or value\n     *         prevents it from being stored in this map\n     * @throws NullPointerException if a specified key or newValue is null,\n     *         and this map does not permit null keys or values\n     * @throws NullPointerException if oldValue is null and this map does not\n     *         permit null values\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws IllegalArgumentException if some property of a specified key\n     *         or value prevents it from being stored in this map\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : " V replace(K key, V value)",
    "returnType" : "V",
    "comment" : "\n     * Replaces the entry for the specified key only if it is\n     * currently mapped to some value.\n     *\n     * @implSpec\n     * The default implementation is equivalent to, for this {@code map}:\n     *\n     * <pre> {@code\n     * if (map.containsKey(key)) {\n     *     return map.put(key, value);\n     * } else\n     *     return null;\n     * }</pre>\n     *\n     * <p>The default implementation makes no guarantees about synchronization\n     * or atomicity properties of this method. Any implementation providing\n     * atomicity guarantees must override this method and document its\n     * concurrency properties.\n     *\n     * @param key key with which the specified value is associated\n     * @param value value to be associated with the specified key\n     * @return the previous value associated with the specified key, or\n     *         {@code null} if there was no mapping for the key.\n     *         (A {@code null} return can also indicate that the map\n     *         previously associated {@code null} with the key,\n     *         if the implementation supports null values.)\n     * @throws UnsupportedOperationException if the {@code put} operation\n     *         is not supported by this map\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws ClassCastException if the class of the specified key or value\n     *         prevents it from being stored in this map\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws NullPointerException if the specified key or value is null,\n     *         and this map does not permit null keys or values\n     * @throws IllegalArgumentException if some property of the specified key\n     *         or value prevents it from being stored in this map\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : " V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction)",
    "returnType" : "V",
    "comment" : "\n     * If the specified key is not already associated with a value (or is mapped\n     * to {@code null}), attempts to compute its value using the given mapping\n     * function and enters it into this map unless {@code null}.\n     *\n     * <p>If the mapping function returns {@code null}, no mapping is recorded.\n     * If the mapping function itself throws an (unchecked) exception, the\n     * exception is rethrown, and no mapping is recorded.  The most\n     * common usage is to construct a new object serving as an initial\n     * mapped value or memoized result, as in:\n     *\n     * <pre> {@code\n     * map.computeIfAbsent(key, k -> new Value(f(k)));\n     * }</pre>\n     *\n     * <p>Or to implement a multi-value map, {@code Map<K,Collection<V>>},\n     * supporting multiple values per key:\n     *\n     * <pre> {@code\n     * map.computeIfAbsent(key, k -> new HashSet<V>()).add(v);\n     * }</pre>\n     *\n     * <p>The mapping function should not modify this map during computation.\n     *\n     * @implSpec\n     * The default implementation is equivalent to the following steps for this\n     * {@code map}, then returning the current value or {@code null} if now\n     * absent:\n     *\n     * <pre> {@code\n     * if (map.get(key) == null) {\n     *     V newValue = mappingFunction.apply(key);\n     *     if (newValue != null)\n     *         map.put(key, newValue);\n     * }\n     * }</pre>\n     *\n     * <p>The default implementation makes no guarantees about detecting if the\n     * mapping function modifies this map during computation and, if\n     * appropriate, reporting an error. Non-concurrent implementations should\n     * override this method and, on a best-effort basis, throw a\n     * {@code ConcurrentModificationException} if it is detected that the\n     * mapping function modifies this map during computation. Concurrent\n     * implementations should override this method and, on a best-effort basis,\n     * throw an {@code IllegalStateException} if it is detected that the\n     * mapping function modifies this map during computation and as a result\n     * computation would never complete.\n     *\n     * <p>The default implementation makes no guarantees about synchronization\n     * or atomicity properties of this method. Any implementation providing\n     * atomicity guarantees must override this method and document its\n     * concurrency properties. In particular, all implementations of\n     * subinterface {@link java.util.concurrent.ConcurrentMap} must document\n     * whether the mapping function is applied once atomically only if the value\n     * is not present.\n     *\n     * @param key key with which the specified value is to be associated\n     * @param mappingFunction the mapping function to compute a value\n     * @return the current (existing or computed) value associated with\n     *         the specified key, or null if the computed value is null\n     * @throws NullPointerException if the specified key is null and\n     *         this map does not support null keys, or the mappingFunction\n     *         is null\n     * @throws UnsupportedOperationException if the {@code put} operation\n     *         is not supported by this map\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws ClassCastException if the class of the specified key or value\n     *         prevents it from being stored in this map\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws IllegalArgumentException if some property of the specified key\n     *         or value prevents it from being stored in this map\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @since 1.8\n     ",
    "links" : [ "java.util.concurrent.ConcurrentMap" ]
  }, {
    "name" : " V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)",
    "returnType" : "V",
    "comment" : "\n     * If the value for the specified key is present and non-null, attempts to\n     * compute a new mapping given the key and its current mapped value.\n     *\n     * <p>If the remapping function returns {@code null}, the mapping is removed.\n     * If the remapping function itself throws an (unchecked) exception, the\n     * exception is rethrown, and the current mapping is left unchanged.\n     *\n     * <p>The remapping function should not modify this map during computation.\n     *\n     * @implSpec\n     * The default implementation is equivalent to performing the following\n     * steps for this {@code map}, then returning the current value or\n     * {@code null} if now absent:\n     *\n     * <pre> {@code\n     * if (map.get(key) != null) {\n     *     V oldValue = map.get(key);\n     *     V newValue = remappingFunction.apply(key, oldValue);\n     *     if (newValue != null)\n     *         map.put(key, newValue);\n     *     else\n     *         map.remove(key);\n     * }\n     * }</pre>\n     *\n     * <p>The default implementation makes no guarantees about detecting if the\n     * remapping function modifies this map during computation and, if\n     * appropriate, reporting an error. Non-concurrent implementations should\n     * override this method and, on a best-effort basis, throw a\n     * {@code ConcurrentModificationException} if it is detected that the\n     * remapping function modifies this map during computation. Concurrent\n     * implementations should override this method and, on a best-effort basis,\n     * throw an {@code IllegalStateException} if it is detected that the\n     * remapping function modifies this map during computation and as a result\n     * computation would never complete.\n     *\n     * <p>The default implementation makes no guarantees about synchronization\n     * or atomicity properties of this method. Any implementation providing\n     * atomicity guarantees must override this method and document its\n     * concurrency properties. In particular, all implementations of\n     * subinterface {@link java.util.concurrent.ConcurrentMap} must document\n     * whether the remapping function is applied once atomically only if the\n     * value is not present.\n     *\n     * @param key key with which the specified value is to be associated\n     * @param remappingFunction the remapping function to compute a value\n     * @return the new value associated with the specified key, or null if none\n     * @throws NullPointerException if the specified key is null and\n     *         this map does not support null keys, or the\n     *         remappingFunction is null\n     * @throws UnsupportedOperationException if the {@code put} operation\n     *         is not supported by this map\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws ClassCastException if the class of the specified key or value\n     *         prevents it from being stored in this map\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws IllegalArgumentException if some property of the specified key\n     *         or value prevents it from being stored in this map\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @since 1.8\n     ",
    "links" : [ "java.util.concurrent.ConcurrentMap" ]
  }, {
    "name" : " V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)",
    "returnType" : "V",
    "comment" : "\n     * Attempts to compute a mapping for the specified key and its current\n     * mapped value (or {@code null} if there is no current mapping). For\n     * example, to either create or append a {@code String} msg to a value\n     * mapping:\n     *\n     * <pre> {@code\n     * map.compute(key, (k, v) -> (v == null) ? msg : v.concat(msg))}</pre>\n     * (Method {@link #merge merge()} is often simpler to use for such purposes.)\n     *\n     * <p>If the remapping function returns {@code null}, the mapping is removed\n     * (or remains absent if initially absent).  If the remapping function\n     * itself throws an (unchecked) exception, the exception is rethrown, and\n     * the current mapping is left unchanged.\n     *\n     * <p>The remapping function should not modify this map during computation.\n     *\n     * @implSpec\n     * The default implementation is equivalent to performing the following\n     * steps for this {@code map}:\n     *\n     * <pre> {@code\n     * V oldValue = map.get(key);\n     * V newValue = remappingFunction.apply(key, oldValue);\n     * if (newValue != null) {\n     *     map.put(key, newValue);\n     * } else if (oldValue != null || map.containsKey(key)) {\n     *     map.remove(key);\n     * }\n     * return newValue;\n     * }</pre>\n     *\n     * <p>The default implementation makes no guarantees about detecting if the\n     * remapping function modifies this map during computation and, if\n     * appropriate, reporting an error. Non-concurrent implementations should\n     * override this method and, on a best-effort basis, throw a\n     * {@code ConcurrentModificationException} if it is detected that the\n     * remapping function modifies this map during computation. Concurrent\n     * implementations should override this method and, on a best-effort basis,\n     * throw an {@code IllegalStateException} if it is detected that the\n     * remapping function modifies this map during computation and as a result\n     * computation would never complete.\n     *\n     * <p>The default implementation makes no guarantees about synchronization\n     * or atomicity properties of this method. Any implementation providing\n     * atomicity guarantees must override this method and document its\n     * concurrency properties. In particular, all implementations of\n     * subinterface {@link java.util.concurrent.ConcurrentMap} must document\n     * whether the remapping function is applied once atomically only if the\n     * value is not present.\n     *\n     * @param key key with which the specified value is to be associated\n     * @param remappingFunction the remapping function to compute a value\n     * @return the new value associated with the specified key, or null if none\n     * @throws NullPointerException if the specified key is null and\n     *         this map does not support null keys, or the\n     *         remappingFunction is null\n     * @throws UnsupportedOperationException if the {@code put} operation\n     *         is not supported by this map\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws ClassCastException if the class of the specified key or value\n     *         prevents it from being stored in this map\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws IllegalArgumentException if some property of the specified key\n     *         or value prevents it from being stored in this map\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @since 1.8\n     ",
    "links" : [ "#merge", "java.util.concurrent.ConcurrentMap" ]
  }, {
    "name" : " V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction)",
    "returnType" : "V",
    "comment" : "\n     * If the specified key is not already associated with a value or is\n     * associated with null, associates it with the given non-null value.\n     * Otherwise, replaces the associated value with the results of the given\n     * remapping function, or removes if the result is {@code null}. This\n     * method may be of use when combining multiple mapped values for a key.\n     * For example, to either create or append a {@code String msg} to a\n     * value mapping:\n     *\n     * <pre> {@code\n     * map.merge(key, msg, String::concat)\n     * }</pre>\n     *\n     * <p>If the remapping function returns {@code null}, the mapping is removed.\n     * If the remapping function itself throws an (unchecked) exception, the\n     * exception is rethrown, and the current mapping is left unchanged.\n     *\n     * <p>The remapping function should not modify this map during computation.\n     *\n     * @implSpec\n     * The default implementation is equivalent to performing the following\n     * steps for this {@code map}, then returning the current value or\n     * {@code null} if absent:\n     *\n     * <pre> {@code\n     * V oldValue = map.get(key);\n     * V newValue = (oldValue == null) ? value :\n     *              remappingFunction.apply(oldValue, value);\n     * if (newValue == null)\n     *     map.remove(key);\n     * else\n     *     map.put(key, newValue);\n     * }</pre>\n     *\n     * <p>The default implementation makes no guarantees about detecting if the\n     * remapping function modifies this map during computation and, if\n     * appropriate, reporting an error. Non-concurrent implementations should\n     * override this method and, on a best-effort basis, throw a\n     * {@code ConcurrentModificationException} if it is detected that the\n     * remapping function modifies this map during computation. Concurrent\n     * implementations should override this method and, on a best-effort basis,\n     * throw an {@code IllegalStateException} if it is detected that the\n     * remapping function modifies this map during computation and as a result\n     * computation would never complete.\n     *\n     * <p>The default implementation makes no guarantees about synchronization\n     * or atomicity properties of this method. Any implementation providing\n     * atomicity guarantees must override this method and document its\n     * concurrency properties. In particular, all implementations of\n     * subinterface {@link java.util.concurrent.ConcurrentMap} must document\n     * whether the remapping function is applied once atomically only if the\n     * value is not present.\n     *\n     * @param key key with which the resulting value is to be associated\n     * @param value the non-null value to be merged with the existing value\n     *        associated with the key or, if no existing value or a null value\n     *        is associated with the key, to be associated with the key\n     * @param remappingFunction the remapping function to recompute a value if\n     *        present\n     * @return the new value associated with the specified key, or null if no\n     *         value is associated with the key\n     * @throws UnsupportedOperationException if the {@code put} operation\n     *         is not supported by this map\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws ClassCastException if the class of the specified key or value\n     *         prevents it from being stored in this map\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws IllegalArgumentException if some property of the specified key\n     *         or value prevents it from being stored in this map\n     *         (<a href=\"{@docRoot}/java.base/java/util/Collection.html#optional-restrictions\">optional</a>)\n     * @throws NullPointerException if the specified key is null and this map\n     *         does not support null keys or the value or remappingFunction is\n     *         null\n     * @since 1.8\n     ",
    "links" : [ "java.util.concurrent.ConcurrentMap" ]
  }, {
    "name" : " static Map<K, V> of()",
    "returnType" : "Map<K, V>",
    "comment" : "\n     * Returns an unmodifiable map containing zero mappings.\n     * See <a href=\"#unmodifiable\">Unmodifiable Maps</a> for details.\n     *\n     * @param <K> the {@code Map}'s key type\n     * @param <V> the {@code Map}'s value type\n     * @return an empty {@code Map}\n     *\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : " static Map<K, V> of(K k1, V v1)",
    "returnType" : "Map<K, V>",
    "comment" : "\n     * Returns an unmodifiable map containing a single mapping.\n     * See <a href=\"#unmodifiable\">Unmodifiable Maps</a> for details.\n     *\n     * @param <K> the {@code Map}'s key type\n     * @param <V> the {@code Map}'s value type\n     * @param k1 the mapping's key\n     * @param v1 the mapping's value\n     * @return a {@code Map} containing the specified mapping\n     * @throws NullPointerException if the key or the value is {@code null}\n     *\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : " static Map<K, V> of(K k1, V v1, K k2, V v2)",
    "returnType" : "Map<K, V>",
    "comment" : "\n     * Returns an unmodifiable map containing two mappings.\n     * See <a href=\"#unmodifiable\">Unmodifiable Maps</a> for details.\n     *\n     * @param <K> the {@code Map}'s key type\n     * @param <V> the {@code Map}'s value type\n     * @param k1 the first mapping's key\n     * @param v1 the first mapping's value\n     * @param k2 the second mapping's key\n     * @param v2 the second mapping's value\n     * @return a {@code Map} containing the specified mappings\n     * @throws IllegalArgumentException if the keys are duplicates\n     * @throws NullPointerException if any key or value is {@code null}\n     *\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : " static Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3)",
    "returnType" : "Map<K, V>",
    "comment" : "\n     * Returns an unmodifiable map containing three mappings.\n     * See <a href=\"#unmodifiable\">Unmodifiable Maps</a> for details.\n     *\n     * @param <K> the {@code Map}'s key type\n     * @param <V> the {@code Map}'s value type\n     * @param k1 the first mapping's key\n     * @param v1 the first mapping's value\n     * @param k2 the second mapping's key\n     * @param v2 the second mapping's value\n     * @param k3 the third mapping's key\n     * @param v3 the third mapping's value\n     * @return a {@code Map} containing the specified mappings\n     * @throws IllegalArgumentException if there are any duplicate keys\n     * @throws NullPointerException if any key or value is {@code null}\n     *\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : " static Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4)",
    "returnType" : "Map<K, V>",
    "comment" : "\n     * Returns an unmodifiable map containing four mappings.\n     * See <a href=\"#unmodifiable\">Unmodifiable Maps</a> for details.\n     *\n     * @param <K> the {@code Map}'s key type\n     * @param <V> the {@code Map}'s value type\n     * @param k1 the first mapping's key\n     * @param v1 the first mapping's value\n     * @param k2 the second mapping's key\n     * @param v2 the second mapping's value\n     * @param k3 the third mapping's key\n     * @param v3 the third mapping's value\n     * @param k4 the fourth mapping's key\n     * @param v4 the fourth mapping's value\n     * @return a {@code Map} containing the specified mappings\n     * @throws IllegalArgumentException if there are any duplicate keys\n     * @throws NullPointerException if any key or value is {@code null}\n     *\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : " static Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5)",
    "returnType" : "Map<K, V>",
    "comment" : "\n     * Returns an unmodifiable map containing five mappings.\n     * See <a href=\"#unmodifiable\">Unmodifiable Maps</a> for details.\n     *\n     * @param <K> the {@code Map}'s key type\n     * @param <V> the {@code Map}'s value type\n     * @param k1 the first mapping's key\n     * @param v1 the first mapping's value\n     * @param k2 the second mapping's key\n     * @param v2 the second mapping's value\n     * @param k3 the third mapping's key\n     * @param v3 the third mapping's value\n     * @param k4 the fourth mapping's key\n     * @param v4 the fourth mapping's value\n     * @param k5 the fifth mapping's key\n     * @param v5 the fifth mapping's value\n     * @return a {@code Map} containing the specified mappings\n     * @throws IllegalArgumentException if there are any duplicate keys\n     * @throws NullPointerException if any key or value is {@code null}\n     *\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : " static Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6)",
    "returnType" : "Map<K, V>",
    "comment" : "\n     * Returns an unmodifiable map containing six mappings.\n     * See <a href=\"#unmodifiable\">Unmodifiable Maps</a> for details.\n     *\n     * @param <K> the {@code Map}'s key type\n     * @param <V> the {@code Map}'s value type\n     * @param k1 the first mapping's key\n     * @param v1 the first mapping's value\n     * @param k2 the second mapping's key\n     * @param v2 the second mapping's value\n     * @param k3 the third mapping's key\n     * @param v3 the third mapping's value\n     * @param k4 the fourth mapping's key\n     * @param v4 the fourth mapping's value\n     * @param k5 the fifth mapping's key\n     * @param v5 the fifth mapping's value\n     * @param k6 the sixth mapping's key\n     * @param v6 the sixth mapping's value\n     * @return a {@code Map} containing the specified mappings\n     * @throws IllegalArgumentException if there are any duplicate keys\n     * @throws NullPointerException if any key or value is {@code null}\n     *\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : " static Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7)",
    "returnType" : "Map<K, V>",
    "comment" : "\n     * Returns an unmodifiable map containing seven mappings.\n     * See <a href=\"#unmodifiable\">Unmodifiable Maps</a> for details.\n     *\n     * @param <K> the {@code Map}'s key type\n     * @param <V> the {@code Map}'s value type\n     * @param k1 the first mapping's key\n     * @param v1 the first mapping's value\n     * @param k2 the second mapping's key\n     * @param v2 the second mapping's value\n     * @param k3 the third mapping's key\n     * @param v3 the third mapping's value\n     * @param k4 the fourth mapping's key\n     * @param v4 the fourth mapping's value\n     * @param k5 the fifth mapping's key\n     * @param v5 the fifth mapping's value\n     * @param k6 the sixth mapping's key\n     * @param v6 the sixth mapping's value\n     * @param k7 the seventh mapping's key\n     * @param v7 the seventh mapping's value\n     * @return a {@code Map} containing the specified mappings\n     * @throws IllegalArgumentException if there are any duplicate keys\n     * @throws NullPointerException if any key or value is {@code null}\n     *\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : " static Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8)",
    "returnType" : "Map<K, V>",
    "comment" : "\n     * Returns an unmodifiable map containing eight mappings.\n     * See <a href=\"#unmodifiable\">Unmodifiable Maps</a> for details.\n     *\n     * @param <K> the {@code Map}'s key type\n     * @param <V> the {@code Map}'s value type\n     * @param k1 the first mapping's key\n     * @param v1 the first mapping's value\n     * @param k2 the second mapping's key\n     * @param v2 the second mapping's value\n     * @param k3 the third mapping's key\n     * @param v3 the third mapping's value\n     * @param k4 the fourth mapping's key\n     * @param v4 the fourth mapping's value\n     * @param k5 the fifth mapping's key\n     * @param v5 the fifth mapping's value\n     * @param k6 the sixth mapping's key\n     * @param v6 the sixth mapping's value\n     * @param k7 the seventh mapping's key\n     * @param v7 the seventh mapping's value\n     * @param k8 the eighth mapping's key\n     * @param v8 the eighth mapping's value\n     * @return a {@code Map} containing the specified mappings\n     * @throws IllegalArgumentException if there are any duplicate keys\n     * @throws NullPointerException if any key or value is {@code null}\n     *\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : " static Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9)",
    "returnType" : "Map<K, V>",
    "comment" : "\n     * Returns an unmodifiable map containing nine mappings.\n     * See <a href=\"#unmodifiable\">Unmodifiable Maps</a> for details.\n     *\n     * @param <K> the {@code Map}'s key type\n     * @param <V> the {@code Map}'s value type\n     * @param k1 the first mapping's key\n     * @param v1 the first mapping's value\n     * @param k2 the second mapping's key\n     * @param v2 the second mapping's value\n     * @param k3 the third mapping's key\n     * @param v3 the third mapping's value\n     * @param k4 the fourth mapping's key\n     * @param v4 the fourth mapping's value\n     * @param k5 the fifth mapping's key\n     * @param v5 the fifth mapping's value\n     * @param k6 the sixth mapping's key\n     * @param v6 the sixth mapping's value\n     * @param k7 the seventh mapping's key\n     * @param v7 the seventh mapping's value\n     * @param k8 the eighth mapping's key\n     * @param v8 the eighth mapping's value\n     * @param k9 the ninth mapping's key\n     * @param v9 the ninth mapping's value\n     * @return a {@code Map} containing the specified mappings\n     * @throws IllegalArgumentException if there are any duplicate keys\n     * @throws NullPointerException if any key or value is {@code null}\n     *\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : " static Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10)",
    "returnType" : "Map<K, V>",
    "comment" : "\n     * Returns an unmodifiable map containing ten mappings.\n     * See <a href=\"#unmodifiable\">Unmodifiable Maps</a> for details.\n     *\n     * @param <K> the {@code Map}'s key type\n     * @param <V> the {@code Map}'s value type\n     * @param k1 the first mapping's key\n     * @param v1 the first mapping's value\n     * @param k2 the second mapping's key\n     * @param v2 the second mapping's value\n     * @param k3 the third mapping's key\n     * @param v3 the third mapping's value\n     * @param k4 the fourth mapping's key\n     * @param v4 the fourth mapping's value\n     * @param k5 the fifth mapping's key\n     * @param v5 the fifth mapping's value\n     * @param k6 the sixth mapping's key\n     * @param v6 the sixth mapping's value\n     * @param k7 the seventh mapping's key\n     * @param v7 the seventh mapping's value\n     * @param k8 the eighth mapping's key\n     * @param v8 the eighth mapping's value\n     * @param k9 the ninth mapping's key\n     * @param v9 the ninth mapping's value\n     * @param k10 the tenth mapping's key\n     * @param v10 the tenth mapping's value\n     * @return a {@code Map} containing the specified mappings\n     * @throws IllegalArgumentException if there are any duplicate keys\n     * @throws NullPointerException if any key or value is {@code null}\n     *\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : " static Map<K, V> ofEntries(Entry<? extends K, ? extends V>... entries)",
    "returnType" : "Map<K, V>",
    "comment" : "\n     * Returns an unmodifiable map containing keys and values extracted from the given entries.\n     * The entries themselves are not stored in the map.\n     * See <a href=\"#unmodifiable\">Unmodifiable Maps</a> for details.\n     *\n     * @apiNote\n     * It is convenient to create the map entries using the {@link Map#entry Map.entry()} method.\n     * For example,\n     *\n     * <pre>{@code\n     *     import static java.util.Map.entry;\n     *\n     *     Map<Integer,String> map = Map.ofEntries(\n     *         entry(1, \"a\"),\n     *         entry(2, \"b\"),\n     *         entry(3, \"c\"),\n     *         ...\n     *         entry(26, \"z\"));\n     * }</pre>\n     *\n     * @param <K> the {@code Map}'s key type\n     * @param <V> the {@code Map}'s value type\n     * @param entries {@code Map.Entry}s containing the keys and values from which the map is populated\n     * @return a {@code Map} containing the specified mappings\n     * @throws IllegalArgumentException if there are any duplicate keys\n     * @throws NullPointerException if any entry, key, or value is {@code null}, or if\n     *         the {@code entries} array is {@code null}\n     *\n     * @see Map#entry Map.entry()\n     * @since 9\n     ",
    "links" : [ "java.util.Map#entry" ]
  }, {
    "name" : " static Entry<K, V> entry(K k, V v)",
    "returnType" : "Entry<K, V>",
    "comment" : "\n     * Returns an unmodifiable {@link Entry} containing the given key and value.\n     * These entries are suitable for populating {@code Map} instances using the\n     * {@link Map#ofEntries Map.ofEntries()} method.\n     * The {@code Entry} instances created by this method have the following characteristics:\n     *\n     * <ul>\n     * <li>They disallow {@code null} keys and values. Attempts to create them using a {@code null}\n     * key or value result in {@code NullPointerException}.\n     * <li>They are unmodifiable. Calls to {@link Entry#setValue Entry.setValue()}\n     * on a returned {@code Entry} result in {@code UnsupportedOperationException}.\n     * <li>They are not serializable.\n     * <li>They are <a href=\"../lang/doc-files/ValueBased.html\">value-based</a>.\n     * Programmers should treat instances that are {@linkplain #equals(Object) equal}\n     * as interchangeable and should not use them for synchronization, or\n     * unpredictable behavior may occur. For example, in a future release,\n     * synchronization may fail. Callers should make no assumptions\n     * about the identity of the returned instances. This method is free to\n     * create new instances or reuse existing ones.\n     * </ul>\n     *\n     * @apiNote\n     * For a serializable {@code Entry}, see {@link AbstractMap.SimpleEntry} or\n     * {@link AbstractMap.SimpleImmutableEntry}.\n     *\n     * @param <K> the key's type\n     * @param <V> the value's type\n     * @param k the key\n     * @param v the value\n     * @return an {@code Entry} containing the specified key and value\n     * @throws NullPointerException if the key or value is {@code null}\n     *\n     * @see Map#ofEntries Map.ofEntries()\n     * @since 9\n     ",
    "links" : [ "#setValue", "Entry", "AbstractMap.SimpleImmutableEntry", "java.util.Map#ofEntries", "AbstractMap.SimpleEntry" ]
  }, {
    "name" : " static Map<K, V> copyOf(Map<? extends K, ? extends V> map)",
    "returnType" : "Map<K, V>",
    "comment" : "\n     * Returns an <a href=\"#unmodifiable\">unmodifiable Map</a> containing the entries\n     * of the given Map. The given Map must not be null, and it must not contain any\n     * null keys or values. If the given Map is subsequently modified, the returned\n     * Map will not reflect such modifications.\n     *\n     * @implNote\n     * If the given Map is an <a href=\"#unmodifiable\">unmodifiable Map</a>,\n     * calling copyOf will generally not create a copy.\n     *\n     * @param <K> the {@code Map}'s key type\n     * @param <V> the {@code Map}'s value type\n     * @param map a {@code Map} from which entries are drawn, must be non-null\n     * @return a {@code Map} containing the entries of the given {@code Map}\n     * @throws NullPointerException if map is null, or if it contains any null keys or values\n     * @since 10\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ " int size()", " boolean isEmpty()", " boolean containsKey(Object key)", " boolean containsValue(Object value)", " V get(Object key)", " V put(K key, V value)", " V remove(Object key)", " void putAll(Map<? extends K, ? extends V> m)", " void clear()", " Set<K> keySet()", " Collection<V> values()", " Set<Map.Entry<K, V>> entrySet()", " boolean equals(Object o)", " int hashCode()", " V getOrDefault(Object key, V defaultValue)", " void forEach(BiConsumer<? super K, ? super V> action)", " void replaceAll(BiFunction<? super K, ? super V, ? extends V> function)", " V putIfAbsent(K key, V value)", " boolean remove(Object key, Object value)", " boolean replace(K key, V oldValue, V newValue)", " V replace(K key, V value)", " V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction)", " V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)", " V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)", " V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction)", " static Map<K, V> of()", " static Map<K, V> of(K k1, V v1)", " static Map<K, V> of(K k1, V v1, K k2, V v2)", " static Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3)", " static Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4)", " static Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5)", " static Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6)", " static Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7)", " static Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8)", " static Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9)", " static Map<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10)", " static Map<K, V> ofEntries(Entry<? extends K, ? extends V>... entries)", " static Entry<K, V> entry(K k, V v)", " static Map<K, V> copyOf(Map<? extends K, ? extends V> map)" ],
  "variableNames" : [ ]
}