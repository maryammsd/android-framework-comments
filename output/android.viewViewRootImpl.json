{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/view/ViewRootImpl.java",
  "packageName" : "android.view",
  "className" : "ViewRootImpl",
  "comment" : "\n * The top of a view hierarchy, implementing the needed protocol between View\n * and the WindowManager.  This is for the most part an internal implementation\n * detail of {@link WindowManagerGlobal}.\n *\n * {@hide}\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DBG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LOCAL_LOGV",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_DRAW",
    "type" : "boolean",
    "comment" : " @noinspection PointlessBooleanExpression",
    "links" : [ ]
  }, {
    "name" : "DEBUG_LAYOUT",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_DIALOG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_INPUT_RESIZE",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_ORIENTATION",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_TRACKBALL",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_IMF",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_CONFIGURATION",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_FPS",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_INPUT_STAGES",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_KEEP_SCREEN_ON",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_CONTENT_CAPTURE",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEBUG_SCROLL_CAPTURE",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MT_RENDERER_AVAILABLE",
    "type" : "boolean",
    "comment" : "\n     * Set to false if we do not want to use the multi threaded renderer even though\n     * threaded renderer (aka hardware renderering) is used. Note that by disabling\n     * this, WindowCallbacks will not fire.\n     ",
    "links" : [ ]
  }, {
    "name" : "USE_NEW_INSETS_PROPERTY",
    "type" : "String",
    "comment" : "\n     * If set to 2, the view system will switch from using rectangles retrieved from window to\n     * dispatch to the view hierarchy to using {@link InsetsController}, that derives the insets\n     * directly from the full configuration, enabling richer information about the insets state, as\n     * well as new APIs to control it frame-by-frame, and synchronize animations with it.\n     * <p>\n     * Only set this to 2 once the new insets system is productionized and the old APIs are\n     * fully migrated over.\n     * <p>\n     * If set to 1, this will switch to a mode where we only use the new approach for IME, but not\n     * for the status/navigation bar.\n     ",
    "links" : [ "InsetsController" ]
  }, {
    "name" : "NEW_INSETS_MODE_NONE",
    "type" : "int",
    "comment" : "\n     * @see #USE_NEW_INSETS_PROPERTY\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NEW_INSETS_MODE_IME",
    "type" : "int",
    "comment" : "\n     * @see #USE_NEW_INSETS_PROPERTY\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NEW_INSETS_MODE_FULL",
    "type" : "int",
    "comment" : "\n     * @see #USE_NEW_INSETS_PROPERTY\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "sNewInsetsMode",
    "type" : "int",
    "comment" : "\n     * @see #USE_NEW_INSETS_PROPERTY\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PROPERTY_PROFILE_RENDERING",
    "type" : "String",
    "comment" : "\n     * Set this system property to true to force the view hierarchy to render\n     * at 60 Hz. This can be used to measure the potential framerate.\n     ",
    "links" : [ ]
  }, {
    "name" : "MAX_TRACKBALL_DELAY",
    "type" : "int",
    "comment" : "\n     * Maximum time we allow the user to roll the trackball enough to generate\n     * a key event, before resetting the counters.\n     ",
    "links" : [ ]
  }, {
    "name" : "CONTENT_CAPTURE_ENABLED_NOT_CHECKED",
    "type" : "int",
    "comment" : "\n     * Initial value for {@link #mContentCaptureEnabled}.\n     ",
    "links" : [ "#mContentCaptureEnabled" ]
  }, {
    "name" : "CONTENT_CAPTURE_ENABLED_TRUE",
    "type" : "int",
    "comment" : "\n     * Value for {@link #mContentCaptureEnabled} when it was checked and set to {@code true}.\n     ",
    "links" : [ "#mContentCaptureEnabled" ]
  }, {
    "name" : "CONTENT_CAPTURE_ENABLED_FALSE",
    "type" : "int",
    "comment" : "\n     * Value for {@link #mContentCaptureEnabled} when it was checked and set to {@code false}.\n     ",
    "links" : [ "#mContentCaptureEnabled" ]
  }, {
    "name" : "sRunQueues",
    "type" : "ThreadLocal<HandlerActionQueue>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sFirstDrawHandlers",
    "type" : "ArrayList<Runnable>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sFirstDrawComplete",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sConfigCallbacks",
    "type" : "ArrayList<ConfigChangedCallback>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mActivityConfigCallback",
    "type" : "ActivityConfigCallback",
    "comment" : "\n     * Callback used to notify corresponding activity about override configuration change and make\n     * sure that all resources are set correctly before updating the ViewRootImpl's internal state.\n     ",
    "links" : [ ]
  }, {
    "name" : "mForceNextConfigUpdate",
    "type" : "boolean",
    "comment" : "\n     * Used when configuration change first updates the config of corresponding activity.\n     * In that case we receive a call back from {@link ActivityThread} and this flag is used to\n     * preserve the initial value.\n     *\n     * @see #performConfigurationChange(Configuration, Configuration, boolean, int)\n     ",
    "links" : [ "ActivityThread" ]
  }, {
    "name" : "mUseBLASTAdapter",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mForceDisableBLAST",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mEnableTripleBuffering",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sCompatibilityDone",
    "type" : "boolean",
    "comment" : "\n     * Signals that compatibility booleans have been initialized according to\n     * target SDK versions.\n     ",
    "links" : [ ]
  }, {
    "name" : "sAlwaysAssignFocus",
    "type" : "boolean",
    "comment" : "\n     * Always assign focus if a focusable View is available.\n     ",
    "links" : [ ]
  }, {
    "name" : "mWindowCallbacks",
    "type" : "ArrayList<WindowCallbacks>",
    "comment" : "\n     * This list must only be modified by the main thread, so a lock is only needed when changing\n     * the list or when accessing the list from a non-main thread.\n     ",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWindowSession",
    "type" : "IWindowSession",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDisplay",
    "type" : "Display",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDisplayManager",
    "type" : "DisplayManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBasePackageName",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTmpLocation",
    "type" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTmpValue",
    "type" : "TypedValue",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mThread",
    "type" : "Thread",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLocation",
    "type" : "WindowLeaked",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWindowAttributes",
    "type" : "WindowManager.LayoutParams",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWindow",
    "type" : "W",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLeashToken",
    "type" : "IBinder",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTargetSdkVersion",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSeq",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mView",
    "type" : "View",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAccessibilityFocusedHost",
    "type" : "View",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAccessibilityFocusedVirtualView",
    "type" : "AccessibilityNodeInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPointerCapture",
    "type" : "boolean",
    "comment" : " True if the window currently has pointer capture enabled.",
    "links" : [ ]
  }, {
    "name" : "mViewVisibility",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAppVisible",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mForceDecorViewVisibility",
    "type" : "boolean",
    "comment" : " stopped and that's when the app will stop drawing further frames.",
    "links" : [ ]
  }, {
    "name" : "mAppVisibilityChanged",
    "type" : "boolean",
    "comment" : " make sure that we always call relayout for the corresponding window.",
    "links" : [ ]
  }, {
    "name" : "mOrigWindowType",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHadWindowFocus",
    "type" : "boolean",
    "comment" : " Whether the window had focus during the most recent traversal. ",
    "links" : [ ]
  }, {
    "name" : "mLostWindowFocus",
    "type" : "boolean",
    "comment" : "\n     * Whether the window lost focus during a previous traversal and has not\n     * yet gained it back. Used to determine whether a WINDOW_STATE_CHANGE\n     * accessibility events should be sent during traversal.\n     ",
    "links" : [ ]
  }, {
    "name" : "mStopped",
    "type" : "boolean",
    "comment" : " so the window should no longer be active.",
    "links" : [ ]
  }, {
    "name" : "mIsAmbientMode",
    "type" : "boolean",
    "comment" : " which means it won't receive input events.",
    "links" : [ ]
  }, {
    "name" : "mPausedForTransition",
    "type" : "boolean",
    "comment" : " Set to true to stop input during an Activity Transition.",
    "links" : [ ]
  }, {
    "name" : "mLastInCompatMode",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurfaceHolderCallback",
    "type" : "SurfaceHolder.Callback2",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurfaceHolder",
    "type" : "BaseSurfaceHolder",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsCreating",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDrawingAllowed",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTransparentRegion",
    "type" : "Region",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPreviousTransparentRegion",
    "type" : "Region",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWidth",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHeight",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDirty",
    "type" : "Rect",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsAnimating",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUseMTRenderer",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDragResizing",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInvalidateRootRequested",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mResizeMode",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCanvasOffsetX",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCanvasOffsetY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mActivityRelaunched",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTranslator",
    "type" : "CompatibilityInfo.Translator",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAttachInfo",
    "type" : "View.AttachInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCompatibleVisibilityInfo",
    "type" : "SystemUiVisibilityInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDispatchedSystemUiVisibility",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInputQueueCallback",
    "type" : "InputQueue.Callback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInputQueue",
    "type" : "InputQueue",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFallbackEventHandler",
    "type" : "FallbackEventHandler",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mChoreographer",
    "type" : "Choreographer",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurfaceSize",
    "type" : "Point",
    "comment" : " for BLAST adapter surface setup",
    "links" : [ ]
  }, {
    "name" : "mTempRect",
    "type" : "Rect",
    "comment" : " used in the transaction to not thrash the heap.",
    "links" : [ ]
  }, {
    "name" : "mVisRect",
    "type" : "Rect",
    "comment" : " used to retrieve visible rect of focused view.",
    "links" : [ ]
  }, {
    "name" : "mTempBoundsRect",
    "type" : "Rect",
    "comment" : " used to set the size of the bounds surface.",
    "links" : [ ]
  }, {
    "name" : "mWindowFocusChanged",
    "type" : "boolean",
    "comment" : " the window manager and input events coming through the input system.",
    "links" : [ ]
  }, {
    "name" : "mUpcomingWindowFocus",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUpcomingInTouchMode",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTraversalScheduled",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTraversalBarrier",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWillDrawSoon",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsInTraversal",
    "type" : "boolean",
    "comment" : " Set to true while in performTraversals for detecting when die(true) is called from internal\n     * callbacks such as onMeasure, onPreDraw, onDraw and deferring doDie() until later. ",
    "links" : [ ]
  }, {
    "name" : "mApplyInsetsRequested",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLayoutRequested",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFirst",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContentCaptureEnabled",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPerformContentCapture",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mReportNextDraw",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFullRedrawNeeded",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mNewSurfaceNeeded",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mForceNextWindowRelayout",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWindowDrawCountDown",
    "type" : "CountDownLatch",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsDrawing",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastSystemUiVisibility",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mClientWindowLayoutFlags",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MAX_QUEUED_INPUT_EVENT_POOL_SIZE",
    "type" : "int",
    "comment" : " Pool of queued input events.",
    "links" : [ ]
  }, {
    "name" : "mQueuedInputEventPool",
    "type" : "QueuedInputEvent",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mQueuedInputEventPoolSize",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPendingInputEventHead",
    "type" : "QueuedInputEvent",
    "comment" : " Input event queue.\n     * Pending input events are input events waiting to be delivered to the input stages\n     * and handled by the application.\n     ",
    "links" : [ ]
  }, {
    "name" : "mPendingInputEventTail",
    "type" : "QueuedInputEvent",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPendingInputEventCount",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mProcessInputEventsScheduled",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUnbufferedInputDispatch",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUnbufferedInputSource",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPendingInputEventQueueLengthCounterName",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFirstInputStage",
    "type" : "InputStage",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFirstPostImeInputStage",
    "type" : "InputStage",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSyntheticInputStage",
    "type" : "InputStage",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUnhandledKeyManager",
    "type" : "UnhandledKeyManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWindowAttributesChanged",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurface",
    "type" : "Surface",
    "comment" : " Surface can never be reassigned or cleared (use Surface.clear()).",
    "links" : [ ]
  }, {
    "name" : "mSurfaceControl",
    "type" : "SurfaceControl",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBlastSurfaceControl",
    "type" : "SurfaceControl",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mBlastBufferQueue",
    "type" : "BLASTBufferQueue",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurfaceChangedTransaction",
    "type" : "Transaction",
    "comment" : "\n     * Transaction object that can be used to synchronize child SurfaceControl changes with\n     * ViewRootImpl SurfaceControl changes by the server. The object is passed along with\n     * the SurfaceChangedCallback.\n     ",
    "links" : [ ]
  }, {
    "name" : "mBoundsLayer",
    "type" : "SurfaceControl",
    "comment" : "\n     * Child container layer of {@code mSurface} with the same bounds as its parent, and cropped to\n     * the surface insets. This surface is created only if a client requests it via {@link\n     * #getBoundsLayer()}. By parenting to this bounds surface, child surfaces can ensure they do\n     * not draw into the surface inset region set by the parent window.\n     ",
    "links" : [ ]
  }, {
    "name" : "mSurfaceSession",
    "type" : "SurfaceSession",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTransaction",
    "type" : "Transaction",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAdded",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAddedTouchMode",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTmpFrame",
    "type" : "Rect",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTmpRect",
    "type" : "Rect",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWinFrame",
    "type" : "Rect",
    "comment" : " frame given by window manager.",
    "links" : [ ]
  }, {
    "name" : "mPendingBackDropFrame",
    "type" : "Rect",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPendingDisplayCutout",
    "type" : "DisplayCutout.ParcelableWrapper",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPendingAlwaysConsumeSystemBars",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTempInsets",
    "type" : "InsetsState",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTempControls",
    "type" : "InsetsSourceControl[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastGivenInsets",
    "type" : "ViewTreeObserver.InternalInsetsInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastWindowInsets",
    "type" : "WindowInsets",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTypesHiddenByFlags",
    "type" : "int",
    "comment" : " Insets types hidden by legacy window flags or system UI flags.",
    "links" : [ ]
  }, {
    "name" : "mLastConfigurationFromResources",
    "type" : "Configuration",
    "comment" : " Last applied configuration obtained from resources. ",
    "links" : [ ]
  }, {
    "name" : "mLastReportedMergedConfiguration",
    "type" : "MergedConfiguration",
    "comment" : " Last configuration reported from WM or via {@link #MSG_UPDATE_CONFIGURATION}. ",
    "links" : [ "#MSG_UPDATE_CONFIGURATION" ]
  }, {
    "name" : "mPendingMergedConfiguration",
    "type" : "MergedConfiguration",
    "comment" : " Configurations waiting to be applied. ",
    "links" : [ ]
  }, {
    "name" : "mScrollMayChange",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSoftInputMode",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastScrolledFocus",
    "type" : "WeakReference<View>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mScrollY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCurScrollY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mScroller",
    "type" : "Scroller",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mResizeInterpolator",
    "type" : "Interpolator",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPendingTransitions",
    "type" : "ArrayList<LayoutTransition>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mViewConfiguration",
    "type" : "ViewConfiguration",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDragDescription",
    "type" : "ClipDescription",
    "comment" : " Drag/drop ",
    "links" : [ ]
  }, {
    "name" : "mCurrentDragView",
    "type" : "View",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLocalDragState",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDragPoint",
    "type" : "PointF",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastTouchPoint",
    "type" : "PointF",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastTouchSource",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mProfileRendering",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRenderProfiler",
    "type" : "Choreographer.FrameCallback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRenderProfilingEnabled",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFpsStartTime",
    "type" : "long",
    "comment" : " Variables to track frames per second, enabled via DEBUG_FPS flag",
    "links" : [ ]
  }, {
    "name" : "mFpsPrevTime",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFpsNumFrames",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPointerIconType",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCustomPointerIcon",
    "type" : "PointerIcon",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAudioManager",
    "type" : "AudioManager",
    "comment" : "\n     * see {@link #playSoundEffect(int)}\n     ",
    "links" : [ "#playSoundEffect" ]
  }, {
    "name" : "mAccessibilityManager",
    "type" : "AccessibilityManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAccessibilityInteractionController",
    "type" : "AccessibilityInteractionController",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAccessibilityInteractionConnectionManager",
    "type" : "AccessibilityInteractionConnectionManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHighContrastTextManager",
    "type" : "HighContrastTextManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSendWindowContentChangedAccessibilityEvent",
    "type" : "SendWindowContentChangedAccessibilityEvent",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTempHashSet",
    "type" : "HashSet<View>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDensity",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mNoncompatDensity",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInLayout",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLayoutRequesters",
    "type" : "ArrayList<View>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHandlingLayoutInLayoutRequest",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mViewLayoutDirectionInitial",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRemoved",
    "type" : "boolean",
    "comment" : " Set to true once doDie() has been called. ",
    "links" : [ ]
  }, {
    "name" : "mNeedsRendererSetup",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInputCompatProcessor",
    "type" : "InputEventCompatProcessor",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInputEventConsistencyVerifier",
    "type" : "InputEventConsistencyVerifier",
    "comment" : "\n     * Consistency verifier for debugging purposes.\n     ",
    "links" : [ ]
  }, {
    "name" : "mInsetsController",
    "type" : "InsetsController",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mImeFocusController",
    "type" : "ImeFocusController",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mScrollCaptureClient",
    "type" : "ScrollCaptureClient",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mGestureExclusionTracker",
    "type" : "GestureExclusionTracker",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAccessibilityEmbeddedConnection",
    "type" : "IAccessibilityEmbeddedConnection",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mNextDrawUseBLASTSyncTransaction",
    "type" : "boolean",
    "comment" : " to redirect the buffers in to transactions.",
    "links" : [ ]
  }, {
    "name" : "mNextReportConsumeBLAST",
    "type" : "boolean",
    "comment" : " performDraw and one consumed from finishBLASTSync()",
    "links" : [ ]
  }, {
    "name" : "mRtBLASTSyncTransaction",
    "type" : "SurfaceControl.Transaction",
    "comment" : " draw returns.",
    "links" : [ ]
  }, {
    "name" : "mSendNextFrameToWm",
    "type" : "boolean",
    "comment" : " (e.g. SurfaceView)",
    "links" : [ ]
  }, {
    "name" : "mRootScrollCaptureCallbacks",
    "type" : "HashSet<ScrollCaptureCallback>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTag",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mProfile",
    "type" : "boolean",
    "comment" : " FIXME for perf testing only",
    "links" : [ ]
  }, {
    "name" : "mDisplayListener",
    "type" : "DisplayListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSurfaceChangedCallbacks",
    "type" : "ArrayList<SurfaceChangedCallback>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHardwareXOffset",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHardwareYOffset",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDrawsNeededToReport",
    "type" : "int",
    "comment" : "\n     * A count of the number of calls to pendingDrawFinished we\n     * require to notify the WM drawing is complete.\n     ",
    "links" : [ ]
  }, {
    "name" : "MSG_INVALIDATE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_INVALIDATE_RECT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DIE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_RESIZED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_RESIZED_REPORT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_WINDOW_FOCUS_CHANGED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DISPATCH_INPUT_EVENT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DISPATCH_APP_VISIBILITY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DISPATCH_GET_NEW_SURFACE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DISPATCH_KEY_FROM_IME",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DISPATCH_KEY_FROM_AUTOFILL",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_CHECK_FOCUS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_CLOSE_SYSTEM_DIALOGS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DISPATCH_DRAG_EVENT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DISPATCH_DRAG_LOCATION_EVENT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DISPATCH_SYSTEM_UI_VISIBILITY",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_UPDATE_CONFIGURATION",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_PROCESS_INPUT_EVENTS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_INVALIDATE_WORLD",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_WINDOW_MOVED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_SYNTHESIZE_INPUT_EVENT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DISPATCH_WINDOW_SHOWN",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_REQUEST_KEYBOARD_SHORTCUTS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_UPDATE_POINTER_ICON",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_POINTER_CAPTURE_CHANGED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DRAW_FINISHED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_INSETS_CHANGED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_INSETS_CONTROL_CHANGED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_LOCATION_IN_PARENT_DISPLAY_CHANGED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_SHOW_INSETS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_HIDE_INSETS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_REQUEST_SCROLL_CAPTURE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHandler",
    "type" : "ViewRootHandler",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTraversalRunnable",
    "type" : "TraversalRunnable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInputEventReceiver",
    "type" : "WindowInputEventReceiver",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mConsumedBatchedInputRunnable",
    "type" : "ConsumeBatchedInputRunnable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mConsumeBatchedInputScheduled",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mConsumeBatchedInputImmediatelyRunnable",
    "type" : "ConsumeBatchedInputImmediatelyRunnable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mConsumeBatchedInputImmediatelyScheduled",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInvalidateOnAnimationRunnable",
    "type" : "InvalidateOnAnimationRunnable",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public ImeFocusController getImeFocusController()",
    "returnType" : "ImeFocusController",
    "comment" : "\n     * @return {@link ImeFocusController} for this instance.\n     ",
    "links" : [ "ImeFocusController" ]
  }, {
    "name" : "public ScrollCaptureClient getScrollCaptureClient()",
    "returnType" : "ScrollCaptureClient",
    "comment" : " @return The current {@link ScrollCaptureClient} for this instance, if any is active. ",
    "links" : [ "ScrollCaptureClient" ]
  }, {
    "name" : "public static void addFirstDrawHandler(Runnable callback)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static void addConfigCallback(ConfigChangedCallback callback)",
    "returnType" : "void",
    "comment" : " Add static config callback to be notified about global config changes. ",
    "links" : [ ]
  }, {
    "name" : "public void setActivityConfigCallback(ActivityConfigCallback callback)",
    "returnType" : "void",
    "comment" : " Add activity config callback to be notified about override config changes. ",
    "links" : [ ]
  }, {
    "name" : "public void setOnContentApplyWindowInsetsListener(OnContentApplyWindowInsetsListener listener)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void addWindowCallbacks(WindowCallbacks callback)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void removeWindowCallbacks(WindowCallbacks callback)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void reportDrawFinish()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void profile()",
    "returnType" : "void",
    "comment" : "\n     * Call this to profile the next traversal call.\n     * FIXME for perf testing only. Remove eventually\n     ",
    "links" : [ ]
  }, {
    "name" : " static boolean isInTouchMode()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates whether we are in touch mode. Calling this method triggers an IPC\n     * call and should be avoided whenever possible.\n     *\n     * @return True, if the device is in touch mode, false otherwise.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void notifyChildRebuilt()",
    "returnType" : "void",
    "comment" : "\n     * Notifies us that our child has been rebuilt, following\n     * a window preservation operation. In these cases we\n     * keep the same DecorView, but the activity controlling it\n     * is a different instance, and we need to update our\n     * callbacks.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView)",
    "returnType" : "void",
    "comment" : "\n     * We have one child\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView, int userId)",
    "returnType" : "void",
    "comment" : "\n     * We have one child\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setTag()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getWindowFlags()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getDisplayId()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public CharSequence getTitle()",
    "returnType" : "CharSequence",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getWidth()",
    "returnType" : "int",
    "comment" : "\n     * @return the width of the root view. Note that this will return {@code -1} until the first\n     *         layout traversal, when the width is set.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getHeight()",
    "returnType" : "int",
    "comment" : "\n     * @return the height of the root view. Note that this will return {@code -1} until the first\n     *         layout traversal, when the height is set.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " void destroyHardwareResources()",
    "returnType" : "void",
    "comment" : "\n     * Destroys hardware rendering resources for this ViewRootImpl\n     *\n     * May be called on any thread\n     ",
    "links" : [ ]
  }, {
    "name" : "public void detachFunctor(long functor)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static void invokeFunctor(long functor, boolean waitForCompletion)",
    "returnType" : "void",
    "comment" : "\n     * Schedules the functor for execution in either kModeProcess or\n     * kModeProcessNoContext, depending on whether or not there is an EGLContext.\n     *\n     * @param functor The native functor to invoke\n     * @param waitForCompletion If true, this will not return until the functor\n     *                          has invoked. If false, the functor may be invoked\n     *                          asynchronously.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerAnimatingRenderNode(RenderNode animator)",
    "returnType" : "void",
    "comment" : "\n     * @param animator animator to register with the hardware renderer\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerVectorDrawableAnimator(NativeVectorDrawableAnimator animator)",
    "returnType" : "void",
    "comment" : "\n     * @param animator animator to register with the hardware renderer\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerRtFrameCallback(@NonNull FrameDrawingCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Registers a callback to be executed when the next frame is being drawn on RenderThread. This\n     * callback will be executed on a RenderThread worker thread, and only used for the next frame\n     * and thus it will only fire once.\n     *\n     * @param callback The callback to register.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void enableHardwareAcceleration(WindowManager.LayoutParams attrs)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getNightMode()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void updateForceDarkMode()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public View getView()",
    "returnType" : "View",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " final WindowLeaked getLocation()",
    "returnType" : "WindowLeaked",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void setLayoutParams(WindowManager.LayoutParams attrs, boolean newView)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void handleAppVisibility(boolean visible)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void handleGetNewSurface()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onMovedToDisplay(int displayId, Configuration config)",
    "returnType" : "void",
    "comment" : "\n     * Notify about move to a different display.\n     * @param displayId The id of the display where this view root is moved to.\n     * @param config Configuration of the resources on new display after move.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void updateInternalDisplay(int displayId, Resources resources)",
    "returnType" : "void",
    "comment" : "\n     * Updates {@link #mDisplay} to the display object corresponding to {@param displayId}.\n     * Uses DEFAULT_DISPLAY if there isn't a display object in the system corresponding\n     * to {@param displayId}.\n     ",
    "links" : [ "#mDisplay" ]
  }, {
    "name" : " void pokeDrawLockIfNeeded()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void requestFitSystemWindows()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void notifyInsetsChanged()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void requestLayout()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isLayoutRequested()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onDescendantInvalidated(@NonNull View child, @NonNull View descendant)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void invalidate()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void invalidateWorld(View view)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void invalidateChild(View child, Rect dirty)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public ViewParent invalidateChildInParent(int[] location, Rect dirty)",
    "returnType" : "ViewParent",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void invalidateRectOnScreen(Rect dirty)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setIsAmbientMode(boolean ambient)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void setWindowStopped(boolean stopped)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void addSurfaceChangedCallback(SurfaceChangedCallback c)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void removeSurfaceChangedCallback(SurfaceChangedCallback c)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void notifySurfaceCreated()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void notifySurfaceReplaced()",
    "returnType" : "void",
    "comment" : "\n     * Notify listeners when the ViewRootImpl surface has been replaced. This callback will not be\n     * called if a new surface is created, only if the valid surface has been replaced with another\n     * valid surface.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void notifySurfaceDestroyed()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public SurfaceControl getBoundsLayer()",
    "returnType" : "SurfaceControl",
    "comment" : "\n     * @return child layer with the same bounds as its parent {@code mSurface} and cropped to the\n     * surface insets. If the layer does not exist, it is created.\n     *\n     * <p>Parenting to this layer will ensure that its children are cropped by the view's surface\n     * insets.\n     ",
    "links" : [ ]
  }, {
    "name" : " Surface getOrCreateBLASTSurface(int width, int height)",
    "returnType" : "Surface",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void setBoundsLayerCrop()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void updateBoundsLayer(boolean shouldReparent)",
    "returnType" : "void",
    "comment" : "\n     * Called after window layout to update the bounds surface. If the surface insets have changed\n     * or the surface has resized, update the bounds surface.\n     *\n     * @param shouldReparent Whether it should reparent the bounds layer to the main SurfaceControl.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void destroySurface()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setPausedForTransition(boolean paused)",
    "returnType" : "void",
    "comment" : "\n     * Block the input events during an Activity Transition. The KEYCODE_BACK event is allowed\n     * through to allow quick reversal of the Activity Transition.\n     *\n     * @param paused true to pause, false to resume.\n     ",
    "links" : [ ]
  }, {
    "name" : "public ViewParent getParent()",
    "returnType" : "ViewParent",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean getChildVisibleRect(View child, Rect r, android.graphics.Point offset)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void bringChildToFront(View child)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " int getHostVisibility()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void requestTransitionStart(LayoutTransition transition)",
    "returnType" : "void",
    "comment" : "\n     * Add LayoutTransition to the list of transitions to be started in the next traversal.\n     * This list will be cleared after the transitions on the list are start()'ed. These\n     * transitionsa re added by LayoutTransition itself when it sets up animations. The setup\n     * happens during the layout phase of traversal, which we want to complete before any of the\n     * animations are started (because those animations may side-effect properties that layout\n     * depends upon, like the bounding rectangles of the affected views). So we add the transition\n     * to the list and it is started just prior to starting the drawing phase of traversal.\n     *\n     * @param transition The LayoutTransition to be started on the next traversal.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " void notifyRendererOfFramePending()",
    "returnType" : "void",
    "comment" : "\n     * Notifies the HardwareRenderer that a new frame will be coming soon.\n     * Currently only {@link ThreadedRenderer} cares about this, and uses\n     * this knowledge to adjust the scheduling of off-thread animations\n     ",
    "links" : [ "ThreadedRenderer" ]
  }, {
    "name" : " void scheduleTraversals()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void unscheduleTraversals()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void doTraversal()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void applyKeepScreenOnFlag(WindowManager.LayoutParams params)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean collectViewAttributes()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getImpliedSystemUiVisibility(WindowManager.LayoutParams params)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void updateCompatSysUiVisibility(@InternalInsetsType int type, boolean visible, boolean hasControl)",
    "returnType" : "void",
    "comment" : "\n     * Update the compatible system UI visibility for dispatching it to the legacy app.\n     *\n     * @param type Indicates which type of the insets source we are handling.\n     * @param visible True if the insets source is visible.\n     * @param hasControl True if we can control the insets source.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void handleDispatchSystemUiVisibilityChanged(SystemUiVisibilityInfo args)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static void adjustLayoutParamsForCompatibility(WindowManager.LayoutParams inOutParams)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void controlInsetsForCompatibility(WindowManager.LayoutParams params)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean measureHierarchy(final View host, final WindowManager.LayoutParams lp, final Resources res, final int desiredWindowWidth, final int desiredWindowHeight)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void transformMatrixToGlobal(Matrix m)",
    "returnType" : "void",
    "comment" : "\n     * Modifies the input matrix such that it maps view-local coordinates to\n     * on-screen coordinates.\n     *\n     * @param m input matrix to modify\n     ",
    "links" : [ ]
  }, {
    "name" : " void transformMatrixToLocal(Matrix m)",
    "returnType" : "void",
    "comment" : "\n     * Modifies the input matrix such that it maps on-screen coordinates to\n     * view-local coordinates.\n     *\n     * @param m input matrix to modify\n     ",
    "links" : [ ]
  }, {
    "name" : " WindowInsets getWindowInsets(boolean forceConstruct)",
    "returnType" : "WindowInsets",
    "comment" : " package ",
    "links" : [ ]
  }, {
    "name" : "public void dispatchApplyInsets(View host)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean updateCaptionInsets()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean shouldDispatchCutout()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public InsetsController getInsetsController()",
    "returnType" : "InsetsController",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean shouldUseDisplaySize(final WindowManager.LayoutParams lp)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " int dipToPx(int dip)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void performTraversals()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void notifyContentCatpureEvents()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void notifyHolderSurfaceDestroyed()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void maybeHandleWindowMove(Rect frame)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void handleWindowFocusChanged()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void fireAccessibilityFocusEventIfHasFocusedNode()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private AccessibilityNodeInfo findFocusedVirtualNode(AccessibilityNodeProvider provider)",
    "returnType" : "AccessibilityNodeInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void handleOutOfResourcesException(Surface.OutOfResourcesException e)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean isInLayout()",
    "returnType" : "boolean",
    "comment" : "\n     * Called by {@link android.view.View#isInLayout()} to determine whether the view hierarchy\n     * is currently undergoing a layout pass.\n     *\n     * @return whether the view hierarchy is currently undergoing a layout pass\n     ",
    "links" : [ "android.view.View#isInLayout" ]
  }, {
    "name" : " boolean requestLayoutDuringLayout(final View view)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by {@link android.view.View#requestLayout()} if the view hierarchy is currently\n     * undergoing a layout pass. requestLayout() should not generally be called during layout,\n     * unless the container hierarchy knows what it is doing (i.e., it is fine as long as\n     * all children in that container hierarchy are measured and laid out at the end of the layout\n     * pass for that container). If requestLayout() is called anyway, we handle it correctly\n     * by registering all requesters during a frame as it proceeds. At the end of the frame,\n     * we check all of those views to see if any still have pending layout requests, which\n     * indicates that they were not correctly handled by their container hierarchy. If that is\n     * the case, we clear all such flags in the tree, to remove the buggy flag state that leads\n     * to blank containers, and force a second request/measure/layout pass in this frame. If\n     * more requestLayout() calls are received during that second layout pass, we post those\n     * requests to the next frame to avoid possible infinite loops.\n     *\n     * <p>The return value from this method indicates whether the request should proceed\n     * (if it is a request during the first layout pass) or should be skipped and posted to the\n     * next frame (if it is a request during the second layout pass).</p>\n     *\n     * @param view the view that requested the layout.\n     *\n     * @return true if request should proceed, false otherwise.\n     ",
    "links" : [ "android.view.View#requestLayout" ]
  }, {
    "name" : "private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private ArrayList<View> getValidLayoutRequesters(ArrayList<View> layoutRequesters, boolean secondLayoutRequests)",
    "returnType" : "ArrayList<View>",
    "comment" : "\n     * This method is called during layout when there have been calls to requestLayout() during\n     * layout. It walks through the list of views that requested layout to determine which ones\n     * still need it, based on visibility in the hierarchy and whether they have already been\n     * handled (as is usually the case with ListView children).\n     *\n     * @param layoutRequesters The list of views that requested layout during layout\n     * @param secondLayoutRequests Whether the requests were issued during the second layout pass.\n     * If so, the FORCE_LAYOUT flag was not set on requesters.\n     * @return A list of the actual views that still need to be laid out.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void requestTransparentRegion(View child)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static int getRootMeasureSpec(int windowSize, int rootDimension)",
    "returnType" : "int",
    "comment" : "\n     * Figures out the measure spec for the root view in a window based on it's\n     * layout params.\n     *\n     * @param windowSize\n     *            The available width or height of the window\n     *\n     * @param rootDimension\n     *            The layout params for one dimension (width or height) of the\n     *            window.\n     *\n     * @return The measure spec to use to measure the root view.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onPreDraw(RecordingCanvas canvas)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onPostDraw(RecordingCanvas canvas)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void outputDisplayList(View view)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void profileRendering(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * @see #PROPERTY_PROFILE_RENDERING\n     ",
    "links" : [ ]
  }, {
    "name" : "private void trackFPS()",
    "returnType" : "void",
    "comment" : "\n     * Called from draw() when DEBUG_FPS is enabled\n     ",
    "links" : [ ]
  }, {
    "name" : " void drawPending()",
    "returnType" : "void",
    "comment" : "\n     * Delay notifying WM of draw finished until\n     * a balanced call to pendingDrawFinished.\n     ",
    "links" : [ ]
  }, {
    "name" : " void pendingDrawFinished()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void postDrawFinished()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void reportDrawFinished()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void performDraw()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean isContentCaptureEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks (and caches) if content capture is enabled for this context.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isContentCaptureReallyEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks (without caching) if content capture is enabled for this context.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void performContentCaptureInitialReport()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void handleContentCaptureFlush()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean draw(boolean fullRedrawNeeded)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty, Rect surfaceInsets)",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if drawing was successful, false if an error occurred\n     ",
    "links" : [ ]
  }, {
    "name" : "private void drawAccessibilityFocusedDrawableIfNeeded(Canvas canvas)",
    "returnType" : "void",
    "comment" : "\n     * We want to draw a highlight around the current accessibility focused.\n     * Since adding a style for all possible view is not a viable option we\n     * have this specialized drawing method.\n     *\n     * Note: We are doing this here to be able to draw the highlight for\n     *       virtual views in addition to real ones.\n     *\n     * @param canvas The canvas on which to draw.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean getAccessibilityFocusedRect(Rect bounds)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private Drawable getAccessibilityFocusedDrawable()",
    "returnType" : "Drawable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void updateSystemGestureExclusionRectsForView(View view)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void systemGestureExclusionChanged()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void updateLocationInParentDisplay(int x, int y)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setRootSystemGestureExclusionRects(@NonNull List<Rect> rects)",
    "returnType" : "void",
    "comment" : "\n     * Set the root-level system gesture exclusion rects. These are added to those provided by\n     * the root's view hierarchy.\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<Rect> getRootSystemGestureExclusionRects()",
    "returnType" : "List<Rect>",
    "comment" : "\n     * Returns the root-level system gesture exclusion rects. These do not include those provided by\n     * the root's view hierarchy.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void requestInvalidateRootRenderNode()",
    "returnType" : "void",
    "comment" : "\n     * Requests that the root render node is invalidated next time we perform a draw, such that\n     * {@link WindowCallbacks#onPostDraw} gets called.\n     ",
    "links" : [ "WindowCallbacks#onPostDraw" ]
  }, {
    "name" : " boolean scrollToRectOrFocus(Rect rectangle, boolean immediate)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public View getAccessibilityFocusedHost()",
    "returnType" : "View",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public AccessibilityNodeInfo getAccessibilityFocusedVirtualView()",
    "returnType" : "AccessibilityNodeInfo",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " void setAccessibilityFocus(View view, AccessibilityNodeInfo node)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean hasPointerCapture()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void requestPointerCapture(boolean enabled)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void handlePointerCaptureChanged(boolean hasCapture)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean hasColorModeChanged(int colorMode)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void requestChildFocus(View child, View focused)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void clearChildFocus(View child)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public ViewParent getParentForAccessibility()",
    "returnType" : "ViewParent",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void focusableViewAvailable(View v)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void recomputeViewAttributes(View child)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void dispatchDetachedFromWindow()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void performConfigurationChange(MergedConfiguration mergedConfiguration, boolean force, int newDisplayId)",
    "returnType" : "void",
    "comment" : "\n     * Notifies all callbacks that configuration and/or display has changed and updates internal\n     * state.\n     * @param mergedConfiguration New global and override config in {@link MergedConfiguration}\n     *                            container.\n     * @param force Flag indicating if we should force apply the config.\n     * @param newDisplayId Id of new display if moved, {@link Display#INVALID_DISPLAY} if not\n     *                     changed.\n     ",
    "links" : [ "MergedConfiguration", "Display#INVALID_DISPLAY" ]
  }, {
    "name" : "public void updateConfiguration(int newDisplayId)",
    "returnType" : "void",
    "comment" : "\n     * Update display and views if last applied merged configuration changed.\n     * @param newDisplayId Id of new display if moved, {@link Display#INVALID_DISPLAY} otherwise.\n     ",
    "links" : [ "Display#INVALID_DISPLAY" ]
  }, {
    "name" : "public static boolean isViewDescendantOf(View child, View parent)",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if child is an ancestor of parent, (or equal to the parent).\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void forceLayout(View view)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean ensureTouchMode(boolean inTouchMode)",
    "returnType" : "boolean",
    "comment" : "\n     * Something in the current window tells us we need to change the touch mode.  For\n     * example, we are not in touch mode, and the user touches the screen.\n     *\n     * If the touch mode has changed, tell the window manager, and handle it locally.\n     *\n     * @param inTouchMode Whether we want to be in touch mode.\n     * @return True if the touch mode changed and focus changed was changed as a result\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean ensureTouchModeLocally(boolean inTouchMode)",
    "returnType" : "boolean",
    "comment" : "\n     * Ensure that the touch mode for this window is set, and if it is changing,\n     * take the appropriate action.\n     * @param inTouchMode Whether we want to be in touch mode.\n     * @return True if the touch mode changed and focus changed was changed as a result\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean enterTouchMode()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static ViewGroup findAncestorToTakeFocusInTouchMode(View focused)",
    "returnType" : "ViewGroup",
    "comment" : "\n     * Find an ancestor of focused that wants focus after its descendants and is\n     * focusable in touch mode.\n     * @param focused The currently focused view.\n     * @return An appropriate view, or null if no such view exists.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean leaveTouchMode()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void resetPointerIcon(MotionEvent event)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean updatePointerIcon(MotionEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void maybeUpdateTooltip(MotionEvent event)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean isNavigationKey(KeyEvent keyEvent)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the key is used for keyboard navigation.\n     * @param keyEvent The key event.\n     * @return True if the key is used for keyboard navigation.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean isTypingKey(KeyEvent keyEvent)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the key is used for typing.\n     * @param keyEvent The key event.\n     * @return True if the key is used for typing.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean checkForLeavingTouchModeAndConsume(KeyEvent event)",
    "returnType" : "boolean",
    "comment" : "\n     * See if the key event means we should leave touch mode (and leave touch mode if so).\n     * @param event The key event.\n     * @return Whether this key event should be consumed (meaning the act of\n     *   leaving touch mode alone is considered the event).\n     ",
    "links" : [ ]
  }, {
    "name" : " void setLocalDragState(Object obj)",
    "returnType" : "void",
    "comment" : " drag/drop ",
    "links" : [ ]
  }, {
    "name" : "private void handleDragEvent(DragEvent event)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onWindowTitleChanged()",
    "returnType" : "void",
    "comment" : "\n     * Notify that the window title changed\n     ",
    "links" : [ ]
  }, {
    "name" : "public void handleDispatchWindowShown()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void handleRequestKeyboardShortcuts(IResultReceiver receiver, int deviceId)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void getLastTouchPoint(Point outLocation)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getLastTouchSource()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setDragFocus(View newDragTarget, DragEvent event)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private AudioManager getAudioManager()",
    "returnType" : "AudioManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private AutofillManager getAutofillManager()",
    "returnType" : "AutofillManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean isAutofillUiShowing()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public AccessibilityInteractionController getAccessibilityInteractionController()",
    "returnType" : "AccessibilityInteractionController",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility, boolean insetsPending) throws RemoteException",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void setFrame(Rect frame)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void playSoundEffect(int effectId)",
    "returnType" : "void",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean performHapticFeedback(int effectId, boolean always)",
    "returnType" : "boolean",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "public View focusSearch(View focused, int direction)",
    "returnType" : "View",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "public View keyboardNavigationClusterSearch(View currentCluster, @FocusDirection int direction)",
    "returnType" : "View",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "public void debug()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dump(String prefix, FileDescriptor fd, PrintWriter writer, String[] args)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void dumpViewHierarchy(String prefix, PrintWriter writer, View view)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " GfxInfo getGfxInfo()",
    "returnType" : "GfxInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void computeRenderNodeUsage(RenderNode node, GfxInfo info)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void appendGfxInfo(View view, GfxInfo info)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean die(boolean immediate)",
    "returnType" : "boolean",
    "comment" : "\n     * @param immediate True, do now if not in traversal. False, put on queue and do later.\n     * @return True, request has been queued. False, request has been completed.\n     ",
    "links" : [ ]
  }, {
    "name" : " void doDie()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void requestUpdateConfiguration(Configuration config)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void loadSystemProperties()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void destroyHardwareRenderer()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void dispatchResized(Rect frame, Rect contentInsets, Rect visibleInsets, Rect stableInsets, boolean reportDraw, MergedConfiguration mergedConfiguration, Rect backDropFrame, boolean forceLayout, boolean alwaysConsumeSystemBars, int displayId, DisplayCutout.ParcelableWrapper displayCutout)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void dispatchInsetsChanged(InsetsState insetsState)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void dispatchInsetsControlChanged(InsetsState insetsState, InsetsSourceControl[] activeControls)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void showInsets(@InsetsType int types, boolean fromIme)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void hideInsets(@InsetsType int types, boolean fromIme)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchMoved(int newX, int newY)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private QueuedInputEvent obtainQueuedInputEvent(InputEvent event, InputEventReceiver receiver, int flags)",
    "returnType" : "QueuedInputEvent",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void recycleQueuedInputEvent(QueuedInputEvent q)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void enqueueInputEvent(InputEvent event)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void enqueueInputEvent(InputEvent event, InputEventReceiver receiver, int flags, boolean processImmediately)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void scheduleProcessInputEvents()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void doProcessInputEvents()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void deliverInputEvent(QueuedInputEvent q)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void finishInputEvent(QueuedInputEvent q)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static boolean isTerminalInputEvent(InputEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void scheduleConsumeBatchedInput()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void unscheduleConsumeBatchedInput()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void scheduleConsumeBatchedInputImmediately()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean doConsumeBatchedInput(long frameTimeNanos)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchInvalidateDelayed(View view, long delayMilliseconds)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchInvalidateRectDelayed(AttachInfo.InvalidateInfo info, long delayMilliseconds)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchInvalidateOnAnimation(View view)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchInvalidateRectOnAnimation(AttachInfo.InvalidateInfo info)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void cancelInvalidate(View view)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchInputEvent(InputEvent event)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchInputEvent(InputEvent event, InputEventReceiver receiver)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void synthesizeInputEvent(InputEvent event)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchKeyFromIme(KeyEvent event)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchKeyFromAutofill(KeyEvent event)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchUnhandledInputEvent(InputEvent event)",
    "returnType" : "void",
    "comment" : "\n     * Reinject unhandled {@link InputEvent}s in order to synthesize fallbacks events.\n     *\n     * Note that it is the responsibility of the caller of this API to recycle the InputEvent it\n     * passes in.\n     ",
    "links" : [ "InputEvent" ]
  }, {
    "name" : "public void dispatchAppVisibility(boolean visible)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchGetNewSurface()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchLocationInParentDisplayChanged(Point offset)",
    "returnType" : "void",
    "comment" : "\n     * Dispatch the offset changed.\n     *\n     * @param offset the offset of this view in the parent window.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void windowFocusChanged(boolean hasFocus, boolean inTouchMode)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchWindowShown()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchCloseSystemDialogs(String reason)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchDragEvent(DragEvent event)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void updatePointerIcon(float x, float y)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchSystemUiVisibilityChanged(int seq, int globalVisibility, int localValue, int localChanges)",
    "returnType" : "void",
    "comment" : " TODO(118118435): Remove this after migration",
    "links" : [ ]
  }, {
    "name" : "public void dispatchCheckFocus()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchRequestKeyboardShortcuts(IResultReceiver receiver, int deviceId)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchPointerCaptureChanged(boolean on)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void postSendWindowContentChangedCallback(View source, int changeType)",
    "returnType" : "void",
    "comment" : "\n     * Post a callback to send a\n     * {@link AccessibilityEvent#TYPE_WINDOW_CONTENT_CHANGED} event.\n     * This event is send at most once every\n     * {@link ViewConfiguration#getSendRecurringAccessibilityEventsInterval()}.\n     ",
    "links" : [ "AccessibilityEvent#TYPE_WINDOW_CONTENT_CHANGED", "ViewConfiguration#getSendRecurringAccessibilityEventsInterval" ]
  }, {
    "name" : "private void removeSendWindowContentChangedCallback()",
    "returnType" : "void",
    "comment" : "\n     * Remove a posted callback to send a\n     * {@link AccessibilityEvent#TYPE_WINDOW_CONTENT_CHANGED} event.\n     ",
    "links" : [ "AccessibilityEvent#TYPE_WINDOW_CONTENT_CHANGED" ]
  }, {
    "name" : "public boolean showContextMenuForChild(View originalView)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean showContextMenuForChild(View originalView, float x, float y)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public ActionMode startActionModeForChild(View originalView, ActionMode.Callback callback)",
    "returnType" : "ActionMode",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public ActionMode startActionModeForChild(View originalView, ActionMode.Callback callback, int type)",
    "returnType" : "ActionMode",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void createContextMenu(ContextMenu menu)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void childDrawableStateChanged(View child)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean requestSendAccessibilityEvent(View child, AccessibilityEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private View getSourceForAccessibilityEvent(AccessibilityEvent event)",
    "returnType" : "View",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void handleWindowContentChangedEvent(AccessibilityEvent event)",
    "returnType" : "void",
    "comment" : "\n     * Updates the focused virtual view, when necessary, in response to a\n     * content changed event.\n     * <p>\n     * This is necessary to get updated bounds after a position change.\n     *\n     * @param event an accessibility event of type\n     *              {@link AccessibilityEvent#TYPE_WINDOW_CONTENT_CHANGED}\n     ",
    "links" : [ "AccessibilityEvent#TYPE_WINDOW_CONTENT_CHANGED" ]
  }, {
    "name" : "public void notifySubtreeAccessibilityStateChanged(View child, View source, int changeType)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean canResolveLayoutDirection()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isLayoutDirectionResolved()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getLayoutDirection()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean canResolveTextDirection()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isTextDirectionResolved()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getTextDirection()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean canResolveTextAlignment()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isTextAlignmentResolved()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getTextAlignment()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private View getCommonPredecessor(View first, View second)",
    "returnType" : "View",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void checkThread()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void requestDisallowInterceptTouchEvent(boolean disallowIntercept)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean requestChildRectangleOnScreen(View child, Rect rectangle, boolean immediate)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void childHasTransientStateChanged(View child, boolean hasTransientState)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onStopNestedScroll(View target)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onNestedScrollAccepted(View child, View target, int nestedScrollAxes)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onNestedPreScroll(View target, int dx, int dy, int[] consumed)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean onNestedPreFling(View target, float velocityX, float velocityY)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean onNestedPrePerformAccessibilityAction(View target, int action, Bundle args)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void addScrollCaptureCallback(ScrollCaptureCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Adds a scroll capture callback to this window.\n     *\n     * @param callback the callback to add\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeScrollCaptureCallback(ScrollCaptureCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Removes a scroll capture callback from this window.\n     *\n     * @param callback the callback to remove\n     ",
    "links" : [ ]
  }, {
    "name" : "public void dispatchScrollCaptureRequest(@NonNull IScrollCaptureController controller)",
    "returnType" : "void",
    "comment" : "\n     * Dispatches a scroll capture request to the view hierarchy on the ui thread.\n     *\n     * @param controller the controller to receive replies\n     ",
    "links" : [ ]
  }, {
    "name" : "private void collectRootScrollCaptureTargets(Queue<ScrollCaptureTarget> targets)",
    "returnType" : "void",
    "comment" : "\n     * Collect and include any ScrollCaptureCallback instances registered with the window.\n     *\n     * @see #addScrollCaptureCallback(ScrollCaptureCallback)\n     * @param targets the search queue for targets\n     ",
    "links" : [ ]
  }, {
    "name" : "private void handleScrollCaptureRequest(@NonNull IScrollCaptureController controller)",
    "returnType" : "void",
    "comment" : "\n     * Handles an inbound request for scroll capture from the system. If a client is not already\n     * active, a search will be dispatched through the view tree to locate scrolling content.\n     * <p>\n     * Either {@link IScrollCaptureController#onClientConnected(IScrollCaptureClient, Rect,\n     * Point)} or {@link IScrollCaptureController#onClientUnavailable()} will be returned\n     * depending on the results of the search.\n     *\n     * @param controller the interface to the system controller\n     * @see ScrollCaptureTargetResolver\n     ",
    "links" : [ "IScrollCaptureController#onClientConnected", "IScrollCaptureController#onClientUnavailable" ]
  }, {
    "name" : "private void dispatchScrollCaptureSearchResult(@NonNull IScrollCaptureController controller, @Nullable ScrollCaptureTarget selectedTarget)",
    "returnType" : "void",
    "comment" : " Called by {@link #handleScrollCaptureRequest} when a result is returned ",
    "links" : [ "#handleScrollCaptureRequest" ]
  }, {
    "name" : "private void reportNextDraw()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setReportNextDraw()",
    "returnType" : "void",
    "comment" : "\n     * Force the window to report its next draw.\n     * <p>\n     * This method is only supposed to be used to speed up the interaction from SystemUI and window\n     * manager when waiting for the first frame to be drawn when turning on the screen. DO NOT USE\n     * unless you fully understand this interaction.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " void changeCanvasOpacity(boolean opaque)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean dispatchUnhandledKeyEvent(KeyEvent event)",
    "returnType" : "boolean",
    "comment" : "\n     * Dispatches a KeyEvent to all registered key fallback handlers.\n     *\n     * @param event\n     * @return {@code true} if the event was handled, {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : " static HandlerActionQueue getRunQueue()",
    "returnType" : "HandlerActionQueue",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void startDragResizing(Rect initialBounds, boolean fullscreen, Rect systemInsets, Rect stableInsets, int resizeMode)",
    "returnType" : "void",
    "comment" : "\n     * Start a drag resizing which will inform all listeners that a window resize is taking place.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void endDragResizing()",
    "returnType" : "void",
    "comment" : "\n     * End a drag resize which will inform all listeners that a window resize has ended.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean updateContentDrawBounds()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void requestDrawWindow()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void reportActivityRelaunched()",
    "returnType" : "void",
    "comment" : "\n     * Tells this instance that its corresponding activity has just relaunched. In this case, we\n     * need to force a relayout of the window to make sure we get the correct bounds from window\n     * manager.\n     ",
    "links" : [ ]
  }, {
    "name" : "public SurfaceControl getSurfaceControl()",
    "returnType" : "SurfaceControl",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public IBinder getInputToken()",
    "returnType" : "IBinder",
    "comment" : "\n     * @return Returns a token used to identify the windows input channel.\n     ",
    "links" : [ ]
  }, {
    "name" : "public IBinder getWindowToken()",
    "returnType" : "IBinder",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public IAccessibilityEmbeddedConnection getAccessibilityEmbeddedConnection()",
    "returnType" : "IAccessibilityEmbeddedConnection",
    "comment" : "\n     * Gets an accessibility embedded connection interface for this ViewRootImpl.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " void setUseBLASTSyncTransaction()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void finishBLASTSync(boolean apply)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " SurfaceControl.Transaction getBLASTSyncTransaction()",
    "returnType" : "SurfaceControl.Transaction",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public SurfaceControl getRenderSurfaceControl()",
    "returnType" : "SurfaceControl",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onDescendantUnbufferedRequested()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void forceDisableBLAST()",
    "returnType" : "void",
    "comment" : "\n     * Force disabling use of the BLAST adapter regardless of the system\n     * flag. Needs to be called before addView.\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean useBLAST()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean isDrawingToBLASTTransaction()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if we are about to or currently processing a draw directed\n     * in to a BLAST transaction.\n     ",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "DBG", "LOCAL_LOGV", "DEBUG_DRAW", "DEBUG_LAYOUT", "DEBUG_DIALOG", "DEBUG_INPUT_RESIZE", "DEBUG_ORIENTATION", "DEBUG_TRACKBALL", "DEBUG_IMF", "DEBUG_CONFIGURATION", "DEBUG_FPS", "DEBUG_INPUT_STAGES", "DEBUG_KEEP_SCREEN_ON", "DEBUG_CONTENT_CAPTURE", "DEBUG_SCROLL_CAPTURE", "MT_RENDERER_AVAILABLE", "USE_NEW_INSETS_PROPERTY", "NEW_INSETS_MODE_NONE", "NEW_INSETS_MODE_IME", "NEW_INSETS_MODE_FULL", "sNewInsetsMode", "PROPERTY_PROFILE_RENDERING", "MAX_TRACKBALL_DELAY", "CONTENT_CAPTURE_ENABLED_NOT_CHECKED", "CONTENT_CAPTURE_ENABLED_TRUE", "CONTENT_CAPTURE_ENABLED_FALSE", "sRunQueues", "sFirstDrawHandlers", "sFirstDrawComplete", "sConfigCallbacks", "mActivityConfigCallback", "mForceNextConfigUpdate", "mUseBLASTAdapter", "mForceDisableBLAST", "mEnableTripleBuffering", "sCompatibilityDone", "sAlwaysAssignFocus", "mWindowCallbacks", "mContext", "mWindowSession", "mDisplay", "mDisplayManager", "mBasePackageName", "mTmpLocation", "mTmpValue", "mThread", "mLocation", "mWindowAttributes", "mWindow", "mLeashToken", "mTargetSdkVersion", "mSeq", "mView", "mAccessibilityFocusedHost", "mAccessibilityFocusedVirtualView", "mPointerCapture", "mViewVisibility", "mAppVisible", "mForceDecorViewVisibility", "mAppVisibilityChanged", "mOrigWindowType", "mHadWindowFocus", "mLostWindowFocus", "mStopped", "mIsAmbientMode", "mPausedForTransition", "mLastInCompatMode", "mSurfaceHolderCallback", "mSurfaceHolder", "mIsCreating", "mDrawingAllowed", "mTransparentRegion", "mPreviousTransparentRegion", "mWidth", "mHeight", "mDirty", "mIsAnimating", "mUseMTRenderer", "mDragResizing", "mInvalidateRootRequested", "mResizeMode", "mCanvasOffsetX", "mCanvasOffsetY", "mActivityRelaunched", "mTranslator", "mAttachInfo", "mCompatibleVisibilityInfo", "mDispatchedSystemUiVisibility", "mInputQueueCallback", "mInputQueue", "mFallbackEventHandler", "mChoreographer", "mSurfaceSize", "mTempRect", "mVisRect", "mTempBoundsRect", "mWindowFocusChanged", "mUpcomingWindowFocus", "mUpcomingInTouchMode", "mTraversalScheduled", "mTraversalBarrier", "mWillDrawSoon", "mIsInTraversal", "mApplyInsetsRequested", "mLayoutRequested", "mFirst", "mContentCaptureEnabled", "mPerformContentCapture", "mReportNextDraw", "mFullRedrawNeeded", "mNewSurfaceNeeded", "mForceNextWindowRelayout", "mWindowDrawCountDown", "mIsDrawing", "mLastSystemUiVisibility", "mClientWindowLayoutFlags", "MAX_QUEUED_INPUT_EVENT_POOL_SIZE", "mQueuedInputEventPool", "mQueuedInputEventPoolSize", "mPendingInputEventHead", "mPendingInputEventTail", "mPendingInputEventCount", "mProcessInputEventsScheduled", "mUnbufferedInputDispatch", "mUnbufferedInputSource", "mPendingInputEventQueueLengthCounterName", "mFirstInputStage", "mFirstPostImeInputStage", "mSyntheticInputStage", "mUnhandledKeyManager", "mWindowAttributesChanged", "mSurface", "mSurfaceControl", "mBlastSurfaceControl", "mBlastBufferQueue", "mSurfaceChangedTransaction", "mBoundsLayer", "mSurfaceSession", "mTransaction", "mAdded", "mAddedTouchMode", "mTmpFrame", "mTmpRect", "mWinFrame", "mPendingBackDropFrame", "mPendingDisplayCutout", "mPendingAlwaysConsumeSystemBars", "mTempInsets", "mTempControls", "mLastGivenInsets", "mLastWindowInsets", "mTypesHiddenByFlags", "mLastConfigurationFromResources", "mLastReportedMergedConfiguration", "mPendingMergedConfiguration", "mScrollMayChange", "mSoftInputMode", "mLastScrolledFocus", "mScrollY", "mCurScrollY", "mScroller", "mResizeInterpolator", "mPendingTransitions", "mViewConfiguration", "mDragDescription", "mCurrentDragView", "mLocalDragState", "mDragPoint", "mLastTouchPoint", "mLastTouchSource", "mProfileRendering", "mRenderProfiler", "mRenderProfilingEnabled", "mFpsStartTime", "mFpsPrevTime", "mFpsNumFrames", "mPointerIconType", "mCustomPointerIcon", "mAudioManager", "mAccessibilityManager", "mAccessibilityInteractionController", "mAccessibilityInteractionConnectionManager", "mHighContrastTextManager", "mSendWindowContentChangedAccessibilityEvent", "mTempHashSet", "mDensity", "mNoncompatDensity", "mInLayout", "mLayoutRequesters", "mHandlingLayoutInLayoutRequest", "mViewLayoutDirectionInitial", "mRemoved", "mNeedsRendererSetup", "mInputCompatProcessor", "mInputEventConsistencyVerifier", "mInsetsController", "mImeFocusController", "mScrollCaptureClient", "mGestureExclusionTracker", "mAccessibilityEmbeddedConnection", "mNextDrawUseBLASTSyncTransaction", "mNextReportConsumeBLAST", "mRtBLASTSyncTransaction", "mSendNextFrameToWm", "mRootScrollCaptureCallbacks", "mTag", "mProfile", "mDisplayListener", "mSurfaceChangedCallbacks", "mHardwareXOffset", "mHardwareYOffset", "mDrawsNeededToReport", "MSG_INVALIDATE", "MSG_INVALIDATE_RECT", "MSG_DIE", "MSG_RESIZED", "MSG_RESIZED_REPORT", "MSG_WINDOW_FOCUS_CHANGED", "MSG_DISPATCH_INPUT_EVENT", "MSG_DISPATCH_APP_VISIBILITY", "MSG_DISPATCH_GET_NEW_SURFACE", "MSG_DISPATCH_KEY_FROM_IME", "MSG_DISPATCH_KEY_FROM_AUTOFILL", "MSG_CHECK_FOCUS", "MSG_CLOSE_SYSTEM_DIALOGS", "MSG_DISPATCH_DRAG_EVENT", "MSG_DISPATCH_DRAG_LOCATION_EVENT", "MSG_DISPATCH_SYSTEM_UI_VISIBILITY", "MSG_UPDATE_CONFIGURATION", "MSG_PROCESS_INPUT_EVENTS", "MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST", "MSG_INVALIDATE_WORLD", "MSG_WINDOW_MOVED", "MSG_SYNTHESIZE_INPUT_EVENT", "MSG_DISPATCH_WINDOW_SHOWN", "MSG_REQUEST_KEYBOARD_SHORTCUTS", "MSG_UPDATE_POINTER_ICON", "MSG_POINTER_CAPTURE_CHANGED", "MSG_DRAW_FINISHED", "MSG_INSETS_CHANGED", "MSG_INSETS_CONTROL_CHANGED", "MSG_SYSTEM_GESTURE_EXCLUSION_CHANGED", "MSG_LOCATION_IN_PARENT_DISPLAY_CHANGED", "MSG_SHOW_INSETS", "MSG_HIDE_INSETS", "MSG_REQUEST_SCROLL_CAPTURE", "mHandler", "mTraversalRunnable", "mInputEventReceiver", "mConsumedBatchedInputRunnable", "mConsumeBatchedInputScheduled", "mConsumeBatchedInputImmediatelyRunnable", "mConsumeBatchedInputImmediatelyScheduled", "mInvalidateOnAnimationRunnable" ],
  "methodNames" : [ "public ImeFocusController getImeFocusController()", "public ScrollCaptureClient getScrollCaptureClient()", "public static void addFirstDrawHandler(Runnable callback)", "public static void addConfigCallback(ConfigChangedCallback callback)", "public void setActivityConfigCallback(ActivityConfigCallback callback)", "public void setOnContentApplyWindowInsetsListener(OnContentApplyWindowInsetsListener listener)", "public void addWindowCallbacks(WindowCallbacks callback)", "public void removeWindowCallbacks(WindowCallbacks callback)", "public void reportDrawFinish()", "public void profile()", " static boolean isInTouchMode()", "public void notifyChildRebuilt()", "public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView)", "public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView, int userId)", "private void setTag()", "public int getWindowFlags()", "public int getDisplayId()", "public CharSequence getTitle()", "public int getWidth()", "public int getHeight()", " void destroyHardwareResources()", "public void detachFunctor(long functor)", "public static void invokeFunctor(long functor, boolean waitForCompletion)", "public void registerAnimatingRenderNode(RenderNode animator)", "public void registerVectorDrawableAnimator(NativeVectorDrawableAnimator animator)", "public void registerRtFrameCallback(@NonNull FrameDrawingCallback callback)", "private void enableHardwareAcceleration(WindowManager.LayoutParams attrs)", "private int getNightMode()", "private void updateForceDarkMode()", "public View getView()", " final WindowLeaked getLocation()", " void setLayoutParams(WindowManager.LayoutParams attrs, boolean newView)", " void handleAppVisibility(boolean visible)", " void handleGetNewSurface()", "public void onMovedToDisplay(int displayId, Configuration config)", "private void updateInternalDisplay(int displayId, Resources resources)", " void pokeDrawLockIfNeeded()", "public void requestFitSystemWindows()", " void notifyInsetsChanged()", "public void requestLayout()", "public boolean isLayoutRequested()", "public void onDescendantInvalidated(@NonNull View child, @NonNull View descendant)", " void invalidate()", " void invalidateWorld(View view)", "public void invalidateChild(View child, Rect dirty)", "public ViewParent invalidateChildInParent(int[] location, Rect dirty)", "private void invalidateRectOnScreen(Rect dirty)", "public void setIsAmbientMode(boolean ambient)", " void setWindowStopped(boolean stopped)", " void addSurfaceChangedCallback(SurfaceChangedCallback c)", " void removeSurfaceChangedCallback(SurfaceChangedCallback c)", "private void notifySurfaceCreated()", "private void notifySurfaceReplaced()", "private void notifySurfaceDestroyed()", "public SurfaceControl getBoundsLayer()", " Surface getOrCreateBLASTSurface(int width, int height)", "private void setBoundsLayerCrop()", "private void updateBoundsLayer(boolean shouldReparent)", "private void destroySurface()", "public void setPausedForTransition(boolean paused)", "public ViewParent getParent()", "public boolean getChildVisibleRect(View child, Rect r, android.graphics.Point offset)", "public void bringChildToFront(View child)", " int getHostVisibility()", "public void requestTransitionStart(LayoutTransition transition)", " void notifyRendererOfFramePending()", " void scheduleTraversals()", " void unscheduleTraversals()", " void doTraversal()", "private void applyKeepScreenOnFlag(WindowManager.LayoutParams params)", "private boolean collectViewAttributes()", "private int getImpliedSystemUiVisibility(WindowManager.LayoutParams params)", " void updateCompatSysUiVisibility(@InternalInsetsType int type, boolean visible, boolean hasControl)", "private void handleDispatchSystemUiVisibilityChanged(SystemUiVisibilityInfo args)", "public static void adjustLayoutParamsForCompatibility(WindowManager.LayoutParams inOutParams)", "private void controlInsetsForCompatibility(WindowManager.LayoutParams params)", "private boolean measureHierarchy(final View host, final WindowManager.LayoutParams lp, final Resources res, final int desiredWindowWidth, final int desiredWindowHeight)", " void transformMatrixToGlobal(Matrix m)", " void transformMatrixToLocal(Matrix m)", " WindowInsets getWindowInsets(boolean forceConstruct)", "public void dispatchApplyInsets(View host)", "private boolean updateCaptionInsets()", "private boolean shouldDispatchCutout()", "public InsetsController getInsetsController()", "private static boolean shouldUseDisplaySize(final WindowManager.LayoutParams lp)", " int dipToPx(int dip)", "private void performTraversals()", "private void notifyContentCatpureEvents()", "private void notifyHolderSurfaceDestroyed()", "private void maybeHandleWindowMove(Rect frame)", "private void handleWindowFocusChanged()", "private void fireAccessibilityFocusEventIfHasFocusedNode()", "private AccessibilityNodeInfo findFocusedVirtualNode(AccessibilityNodeProvider provider)", "private void handleOutOfResourcesException(Surface.OutOfResourcesException e)", "private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec)", " boolean isInLayout()", " boolean requestLayoutDuringLayout(final View view)", "private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight)", "private ArrayList<View> getValidLayoutRequesters(ArrayList<View> layoutRequesters, boolean secondLayoutRequests)", "public void requestTransparentRegion(View child)", "private static int getRootMeasureSpec(int windowSize, int rootDimension)", "public void onPreDraw(RecordingCanvas canvas)", "public void onPostDraw(RecordingCanvas canvas)", " void outputDisplayList(View view)", "private void profileRendering(boolean enabled)", "private void trackFPS()", " void drawPending()", " void pendingDrawFinished()", "private void postDrawFinished()", "private void reportDrawFinished()", "private void performDraw()", "private boolean isContentCaptureEnabled()", "private boolean isContentCaptureReallyEnabled()", "private void performContentCaptureInitialReport()", "private void handleContentCaptureFlush()", "private boolean draw(boolean fullRedrawNeeded)", "private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty, Rect surfaceInsets)", "private void drawAccessibilityFocusedDrawableIfNeeded(Canvas canvas)", "private boolean getAccessibilityFocusedRect(Rect bounds)", "private Drawable getAccessibilityFocusedDrawable()", " void updateSystemGestureExclusionRectsForView(View view)", " void systemGestureExclusionChanged()", " void updateLocationInParentDisplay(int x, int y)", "public void setRootSystemGestureExclusionRects(@NonNull List<Rect> rects)", "public List<Rect> getRootSystemGestureExclusionRects()", "public void requestInvalidateRootRenderNode()", " boolean scrollToRectOrFocus(Rect rectangle, boolean immediate)", "public View getAccessibilityFocusedHost()", "public AccessibilityNodeInfo getAccessibilityFocusedVirtualView()", " void setAccessibilityFocus(View view, AccessibilityNodeInfo node)", " boolean hasPointerCapture()", " void requestPointerCapture(boolean enabled)", "private void handlePointerCaptureChanged(boolean hasCapture)", "private boolean hasColorModeChanged(int colorMode)", "public void requestChildFocus(View child, View focused)", "public void clearChildFocus(View child)", "public ViewParent getParentForAccessibility()", "public void focusableViewAvailable(View v)", "public void recomputeViewAttributes(View child)", " void dispatchDetachedFromWindow()", "private void performConfigurationChange(MergedConfiguration mergedConfiguration, boolean force, int newDisplayId)", "public void updateConfiguration(int newDisplayId)", "public static boolean isViewDescendantOf(View child, View parent)", "private static void forceLayout(View view)", " boolean ensureTouchMode(boolean inTouchMode)", "private boolean ensureTouchModeLocally(boolean inTouchMode)", "private boolean enterTouchMode()", "private static ViewGroup findAncestorToTakeFocusInTouchMode(View focused)", "private boolean leaveTouchMode()", "private void resetPointerIcon(MotionEvent event)", "private boolean updatePointerIcon(MotionEvent event)", "private void maybeUpdateTooltip(MotionEvent event)", "private static boolean isNavigationKey(KeyEvent keyEvent)", "private static boolean isTypingKey(KeyEvent keyEvent)", "private boolean checkForLeavingTouchModeAndConsume(KeyEvent event)", " void setLocalDragState(Object obj)", "private void handleDragEvent(DragEvent event)", "public void onWindowTitleChanged()", "public void handleDispatchWindowShown()", "public void handleRequestKeyboardShortcuts(IResultReceiver receiver, int deviceId)", "public void getLastTouchPoint(Point outLocation)", "public int getLastTouchSource()", "public void setDragFocus(View newDragTarget, DragEvent event)", "private AudioManager getAudioManager()", "private AutofillManager getAutofillManager()", "private boolean isAutofillUiShowing()", "public AccessibilityInteractionController getAccessibilityInteractionController()", "private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility, boolean insetsPending) throws RemoteException", "private void setFrame(Rect frame)", "public void playSoundEffect(int effectId)", "public boolean performHapticFeedback(int effectId, boolean always)", "public View focusSearch(View focused, int direction)", "public View keyboardNavigationClusterSearch(View currentCluster, @FocusDirection int direction)", "public void debug()", "public void dump(String prefix, FileDescriptor fd, PrintWriter writer, String[] args)", "private void dumpViewHierarchy(String prefix, PrintWriter writer, View view)", " GfxInfo getGfxInfo()", "private static void computeRenderNodeUsage(RenderNode node, GfxInfo info)", "private static void appendGfxInfo(View view, GfxInfo info)", " boolean die(boolean immediate)", " void doDie()", "public void requestUpdateConfiguration(Configuration config)", "public void loadSystemProperties()", "private void destroyHardwareRenderer()", "private void dispatchResized(Rect frame, Rect contentInsets, Rect visibleInsets, Rect stableInsets, boolean reportDraw, MergedConfiguration mergedConfiguration, Rect backDropFrame, boolean forceLayout, boolean alwaysConsumeSystemBars, int displayId, DisplayCutout.ParcelableWrapper displayCutout)", "private void dispatchInsetsChanged(InsetsState insetsState)", "private void dispatchInsetsControlChanged(InsetsState insetsState, InsetsSourceControl[] activeControls)", "private void showInsets(@InsetsType int types, boolean fromIme)", "private void hideInsets(@InsetsType int types, boolean fromIme)", "public void dispatchMoved(int newX, int newY)", "private QueuedInputEvent obtainQueuedInputEvent(InputEvent event, InputEventReceiver receiver, int flags)", "private void recycleQueuedInputEvent(QueuedInputEvent q)", " void enqueueInputEvent(InputEvent event)", " void enqueueInputEvent(InputEvent event, InputEventReceiver receiver, int flags, boolean processImmediately)", "private void scheduleProcessInputEvents()", " void doProcessInputEvents()", "private void deliverInputEvent(QueuedInputEvent q)", "private void finishInputEvent(QueuedInputEvent q)", " static boolean isTerminalInputEvent(InputEvent event)", " void scheduleConsumeBatchedInput()", " void unscheduleConsumeBatchedInput()", " void scheduleConsumeBatchedInputImmediately()", " boolean doConsumeBatchedInput(long frameTimeNanos)", "public void dispatchInvalidateDelayed(View view, long delayMilliseconds)", "public void dispatchInvalidateRectDelayed(AttachInfo.InvalidateInfo info, long delayMilliseconds)", "public void dispatchInvalidateOnAnimation(View view)", "public void dispatchInvalidateRectOnAnimation(AttachInfo.InvalidateInfo info)", "public void cancelInvalidate(View view)", "public void dispatchInputEvent(InputEvent event)", "public void dispatchInputEvent(InputEvent event, InputEventReceiver receiver)", "public void synthesizeInputEvent(InputEvent event)", "public void dispatchKeyFromIme(KeyEvent event)", "public void dispatchKeyFromAutofill(KeyEvent event)", "public void dispatchUnhandledInputEvent(InputEvent event)", "public void dispatchAppVisibility(boolean visible)", "public void dispatchGetNewSurface()", "public void dispatchLocationInParentDisplayChanged(Point offset)", "public void windowFocusChanged(boolean hasFocus, boolean inTouchMode)", "public void dispatchWindowShown()", "public void dispatchCloseSystemDialogs(String reason)", "public void dispatchDragEvent(DragEvent event)", "public void updatePointerIcon(float x, float y)", "public void dispatchSystemUiVisibilityChanged(int seq, int globalVisibility, int localValue, int localChanges)", "public void dispatchCheckFocus()", "public void dispatchRequestKeyboardShortcuts(IResultReceiver receiver, int deviceId)", "public void dispatchPointerCaptureChanged(boolean on)", "private void postSendWindowContentChangedCallback(View source, int changeType)", "private void removeSendWindowContentChangedCallback()", "public boolean showContextMenuForChild(View originalView)", "public boolean showContextMenuForChild(View originalView, float x, float y)", "public ActionMode startActionModeForChild(View originalView, ActionMode.Callback callback)", "public ActionMode startActionModeForChild(View originalView, ActionMode.Callback callback, int type)", "public void createContextMenu(ContextMenu menu)", "public void childDrawableStateChanged(View child)", "public boolean requestSendAccessibilityEvent(View child, AccessibilityEvent event)", "private View getSourceForAccessibilityEvent(AccessibilityEvent event)", "private void handleWindowContentChangedEvent(AccessibilityEvent event)", "public void notifySubtreeAccessibilityStateChanged(View child, View source, int changeType)", "public boolean canResolveLayoutDirection()", "public boolean isLayoutDirectionResolved()", "public int getLayoutDirection()", "public boolean canResolveTextDirection()", "public boolean isTextDirectionResolved()", "public int getTextDirection()", "public boolean canResolveTextAlignment()", "public boolean isTextAlignmentResolved()", "public int getTextAlignment()", "private View getCommonPredecessor(View first, View second)", " void checkThread()", "public void requestDisallowInterceptTouchEvent(boolean disallowIntercept)", "public boolean requestChildRectangleOnScreen(View child, Rect rectangle, boolean immediate)", "public void childHasTransientStateChanged(View child, boolean hasTransientState)", "public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes)", "public void onStopNestedScroll(View target)", "public void onNestedScrollAccepted(View child, View target, int nestedScrollAxes)", "public void onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed)", "public void onNestedPreScroll(View target, int dx, int dy, int[] consumed)", "public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed)", "public boolean onNestedPreFling(View target, float velocityX, float velocityY)", "public boolean onNestedPrePerformAccessibilityAction(View target, int action, Bundle args)", "public void addScrollCaptureCallback(ScrollCaptureCallback callback)", "public void removeScrollCaptureCallback(ScrollCaptureCallback callback)", "public void dispatchScrollCaptureRequest(@NonNull IScrollCaptureController controller)", "private void collectRootScrollCaptureTargets(Queue<ScrollCaptureTarget> targets)", "private void handleScrollCaptureRequest(@NonNull IScrollCaptureController controller)", "private void dispatchScrollCaptureSearchResult(@NonNull IScrollCaptureController controller, @Nullable ScrollCaptureTarget selectedTarget)", "private void reportNextDraw()", "public void setReportNextDraw()", " void changeCanvasOpacity(boolean opaque)", "public boolean dispatchUnhandledKeyEvent(KeyEvent event)", " static HandlerActionQueue getRunQueue()", "private void startDragResizing(Rect initialBounds, boolean fullscreen, Rect systemInsets, Rect stableInsets, int resizeMode)", "private void endDragResizing()", "private boolean updateContentDrawBounds()", "private void requestDrawWindow()", "public void reportActivityRelaunched()", "public SurfaceControl getSurfaceControl()", "public IBinder getInputToken()", "public IBinder getWindowToken()", "public IAccessibilityEmbeddedConnection getAccessibilityEmbeddedConnection()", " void setUseBLASTSyncTransaction()", "private void finishBLASTSync(boolean apply)", " SurfaceControl.Transaction getBLASTSyncTransaction()", "public SurfaceControl getRenderSurfaceControl()", "public void onDescendantUnbufferedRequested()", " void forceDisableBLAST()", " boolean useBLAST()", " boolean isDrawingToBLASTTransaction()" ]
}