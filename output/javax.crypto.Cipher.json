{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/javax/crypto/Cipher.java",
  "packageName" : "javax.crypto",
  "className" : "Cipher",
  "comment" : "",
  "links" : [ ],
  "variables" : [ {
    "name" : "ENCRYPT_MODE",
    "type" : "int",
    "comment" : "\n     * Constant used to initialize cipher to encryption mode.\n     ",
    "links" : [ ]
  }, {
    "name" : "DECRYPT_MODE",
    "type" : "int",
    "comment" : "\n     * Constant used to initialize cipher to decryption mode.\n     ",
    "links" : [ ]
  }, {
    "name" : "WRAP_MODE",
    "type" : "int",
    "comment" : "\n     * Constant used to initialize cipher to key-wrapping mode.\n     ",
    "links" : [ ]
  }, {
    "name" : "UNWRAP_MODE",
    "type" : "int",
    "comment" : "\n     * Constant used to initialize cipher to key-unwrapping mode.\n     ",
    "links" : [ ]
  }, {
    "name" : "PUBLIC_KEY",
    "type" : "int",
    "comment" : "\n     * Constant used to indicate the to-be-unwrapped key is a \"public key\".\n     ",
    "links" : [ ]
  }, {
    "name" : "PRIVATE_KEY",
    "type" : "int",
    "comment" : "\n     * Constant used to indicate the to-be-unwrapped key is a \"private key\".\n     ",
    "links" : [ ]
  }, {
    "name" : "SECRET_KEY",
    "type" : "int",
    "comment" : "\n     * Constant used to indicate the to-be-unwrapped key is a \"secret key\".\n     ",
    "links" : [ ]
  }, {
    "name" : "provider",
    "type" : "Provider",
    "comment" : " The provider",
    "links" : [ ]
  }, {
    "name" : "spi",
    "type" : "CipherSpi",
    "comment" : " The provider implementation (delegate)",
    "links" : [ ]
  }, {
    "name" : "transformation",
    "type" : "String",
    "comment" : " Android-changed: Made final.",
    "links" : [ ]
  }, {
    "name" : "tokenizedTransformation",
    "type" : "String[]",
    "comment" : " The tokenized version of transformation",
    "links" : [ ]
  }, {
    "name" : "exmech",
    "type" : "ExemptionMechanism",
    "comment" : " The exemption mechanism that needs to be enforced",
    "links" : [ ]
  }, {
    "name" : "initialized",
    "type" : "boolean",
    "comment" : " Flag which indicates whether or not this cipher has been initialized",
    "links" : [ ]
  }, {
    "name" : "opmode",
    "type" : "int",
    "comment" : " cipher has been initialized.",
    "links" : [ ]
  }, {
    "name" : "KEY_USAGE_EXTENSION_OID",
    "type" : "String",
    "comment" : " The OID for the KeyUsage extension in an X.509 v3 certificate",
    "links" : [ ]
  }, {
    "name" : "spiAndProviderUpdater",
    "type" : "SpiAndProviderUpdater",
    "comment" : " See note at top of class.",
    "links" : [ ]
  }, {
    "name" : "ATTRIBUTE_PADDINGS",
    "type" : "String",
    "comment" : " The attribute used for supported paddings. ",
    "links" : [ ]
  }, {
    "name" : "ATTRIBUTE_MODES",
    "type" : "String",
    "comment" : " The attribute used for supported modes. ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private static String[] tokenizeTransformation(String transformation) throws NoSuchAlgorithmException",
    "returnType" : "String[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static final Cipher getInstance(String transformation) throws NoSuchAlgorithmException, NoSuchPaddingException",
    "returnType" : "Cipher",
    "comment" : "\n     * Returns a <code>Cipher</code> object that implements the specified\n     * transformation.\n     *\n     * <p> This method traverses the list of registered security Providers,\n     * starting with the most preferred Provider.\n     * A new Cipher object encapsulating the\n     * CipherSpi implementation from the first\n     * Provider that supports the specified algorithm is returned.\n     *\n     * <p> Note that the list of registered providers may be retrieved via\n     * the {@link Security#getProviders() Security.getProviders()} method.\n     *\n     * @param transformation the name of the transformation, e.g.,\n     * <i>DES/CBC/PKCS5Padding</i>.\n     * See the Cipher section in the <a href=\n     *   \"{@docRoot}/../technotes/guides/security/StandardNames.html#Cipher\">\n     * Java Cryptography Architecture Standard Algorithm Name Documentation</a>\n     * for information about standard transformation names.\n     *\n     * @return a cipher that implements the requested transformation.\n     *\n     * @exception NoSuchAlgorithmException if <code>transformation</code>\n     *          is null, empty, in an invalid format,\n     *          or if no Provider supports a CipherSpi implementation for the\n     *          specified algorithm.\n     *\n     * @exception NoSuchPaddingException if <code>transformation</code>\n     *          contains a padding scheme that is not available.\n     *\n     * @see java.security.Provider\n     ",
    "links" : [ "#getProviders()" ]
  }, {
    "name" : "public static final Cipher getInstance(String transformation, String provider) throws NoSuchAlgorithmException, NoSuchProviderException, NoSuchPaddingException",
    "returnType" : "Cipher",
    "comment" : "\n     * Returns a <code>Cipher</code> object that implements the specified\n     * transformation.\n     *\n     * <p> A new Cipher object encapsulating the\n     * CipherSpi implementation from the specified provider\n     * is returned.  The specified provider must be registered\n     * in the security provider list.\n     *\n     * <p> Note that the list of registered providers may be retrieved via\n     * the {@link Security#getProviders() Security.getProviders()} method.\n     *\n     * @param transformation the name of the transformation,\n     * e.g., <i>DES/CBC/PKCS5Padding</i>.\n     * See the Cipher section in the <a href=\n     *   \"{@docRoot}/../technotes/guides/security/StandardNames.html#Cipher\">\n     * Java Cryptography Architecture Standard Algorithm Name Documentation</a>\n     * for information about standard transformation names.\n     *\n     * @param provider the name of the provider.\n     *\n     * @return a cipher that implements the requested transformation.\n     *\n     * @exception NoSuchAlgorithmException if <code>transformation</code>\n     *          is null, empty, in an invalid format,\n     *          or if a CipherSpi implementation for the specified algorithm\n     *          is not available from the specified provider.\n     *\n     * @exception NoSuchProviderException if the specified provider is not\n     *          registered in the security provider list.\n     *\n     * @exception NoSuchPaddingException if <code>transformation</code>\n     *          contains a padding scheme that is not available.\n     *\n     * @exception IllegalArgumentException if the <code>provider</code>\n     *          is null or empty.\n     *\n     * @see java.security.Provider\n     ",
    "links" : [ "#getProviders()" ]
  }, {
    "name" : "public static final Cipher getInstance(String transformation, Provider provider) throws NoSuchAlgorithmException, NoSuchPaddingException",
    "returnType" : "Cipher",
    "comment" : "\n     * Returns a <code>Cipher</code> object that implements the specified\n     * transformation.\n     *\n     * <p> A new Cipher object encapsulating the\n     * CipherSpi implementation from the specified Provider\n     * object is returned.  Note that the specified Provider object\n     * does not have to be registered in the provider list.\n     *\n     * @param transformation the name of the transformation,\n     * e.g., <i>DES/CBC/PKCS5Padding</i>.\n     * See the Cipher section in the <a href=\n     *   \"{@docRoot}/../technotes/guides/security/StandardNames.html#Cipher\">\n     * Java Cryptography Architecture Standard Algorithm Name Documentation</a>\n     * for information about standard transformation names.\n     *\n     * @param provider the provider.\n     *\n     * @return a cipher that implements the requested transformation.\n     *\n     * @exception NoSuchAlgorithmException if <code>transformation</code>\n     *          is null, empty, in an invalid format,\n     *          or if a CipherSpi implementation for the specified algorithm\n     *          is not available from the specified Provider object.\n     *\n     * @exception NoSuchPaddingException if <code>transformation</code>\n     *          contains a padding scheme that is not available.\n     *\n     * @exception IllegalArgumentException if the <code>provider</code>\n     *          is null.\n     *\n     * @see java.security.Provider\n     ",
    "links" : [ ]
  }, {
    "name" : " static final Cipher createCipher(String transformation, Provider provider) throws NoSuchAlgorithmException, NoSuchPaddingException",
    "returnType" : "Cipher",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void updateProviderIfNeeded()",
    "returnType" : "void",
    "comment" : "\n     * Choose the Spi from the first provider available. Used if\n     * delayed provider selection is not possible because init()\n     * is not the first method called.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void chooseProvider(InitType initType, int opmode, Key key, AlgorithmParameterSpec paramSpec, AlgorithmParameters params, SecureRandom random) throws InvalidKeyException, InvalidAlgorithmParameterException",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final Provider getProvider()",
    "returnType" : "Provider",
    "comment" : "\n     * Returns the provider of this <code>Cipher</code> object.\n     *\n     * @return the provider of this <code>Cipher</code> object\n     ",
    "links" : [ ]
  }, {
    "name" : "public final String getAlgorithm()",
    "returnType" : "String",
    "comment" : "\n     * Returns the algorithm name of this <code>Cipher</code> object.\n     *\n     * <p>This is the same name that was specified in one of the\n     * <code>getInstance</code> calls that created this <code>Cipher</code>\n     * object..\n     *\n     * @return the algorithm name of this <code>Cipher</code> object.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int getBlockSize()",
    "returnType" : "int",
    "comment" : "\n     * Returns the block size (in bytes).\n     *\n     * @return the block size (in bytes), or 0 if the underlying algorithm is\n     * not a block cipher\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int getOutputSize(int inputLen)",
    "returnType" : "int",
    "comment" : "\n     * Returns the length in bytes that an output buffer would need to be in\n     * order to hold the result of the next <code>update</code> or\n     * <code>doFinal</code> operation, given the input length\n     * <code>inputLen</code> (in bytes).\n     *\n     * <p>This call takes into account any unprocessed (buffered) data from a\n     * previous <code>update</code> call, padding, and AEAD tagging.\n     *\n     * <p>The actual output length of the next <code>update</code> or\n     * <code>doFinal</code> call may be smaller than the length returned by\n     * this method.\n     *\n     * @param inputLen the input length (in bytes)\n     *\n     * @return the required output buffer size (in bytes)\n     *\n     * @exception IllegalStateException if this cipher is in a wrong state\n     * (e.g., has not yet been initialized)\n     ",
    "links" : [ ]
  }, {
    "name" : "public final byte[] getIV()",
    "returnType" : "byte[]",
    "comment" : "\n     * Returns the initialization vector (IV) in a new buffer.\n     *\n     * <p>This is useful in the case where a random IV was created,\n     * or in the context of password-based encryption or\n     * decryption, where the IV is derived from a user-supplied password.\n     *\n     * @return the initialization vector in a new buffer, or null if the\n     * underlying algorithm does not use an IV, or if the IV has not yet\n     * been set.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final AlgorithmParameters getParameters()",
    "returnType" : "AlgorithmParameters",
    "comment" : "\n     * Returns the parameters used with this cipher.\n     *\n     * <p>The returned parameters may be the same that were used to initialize\n     * this cipher, or may contain a combination of default and random\n     * parameter values used by the underlying cipher implementation if this\n     * cipher requires algorithm parameters but was not initialized with any.\n     *\n     * @return the parameters used with this cipher, or null if this cipher\n     * does not use any parameters.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final ExemptionMechanism getExemptionMechanism()",
    "returnType" : "ExemptionMechanism",
    "comment" : "\n     * Returns the exemption mechanism object used with this cipher.\n     *\n     * @return the exemption mechanism object used with this cipher, or\n     * null if this cipher does not use any exemption mechanism.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void checkOpmode(int opmode)",
    "returnType" : "void",
    "comment" : " throw InvalidParameterExeption if not",
    "links" : [ ]
  }, {
    "name" : "private static String getOpmodeString(int opmode)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final void init(int opmode, Key key) throws InvalidKeyException",
    "returnType" : "void",
    "comment" : "\n     * Initializes this cipher with a key.\n     *\n     * <p>The cipher is initialized for one of the following four operations:\n     * encryption, decryption, key wrapping or key unwrapping, depending\n     * on the value of <code>opmode</code>.\n     *\n     * <p>If this cipher requires any algorithm parameters that cannot be\n     * derived from the given <code>key</code>, the underlying cipher\n     * implementation is supposed to generate the required parameters itself\n     * (using provider-specific default or random values) if it is being\n     * initialized for encryption or key wrapping, and raise an\n     * <code>InvalidKeyException</code> if it is being\n     * initialized for decryption or key unwrapping.\n     * The generated parameters can be retrieved using\n     * {@link #getParameters() getParameters} or\n     * {@link #getIV() getIV} (if the parameter is an IV).\n     *\n     * <p>If this cipher requires algorithm parameters that cannot be\n     * derived from the input parameters, and there are no reasonable\n     * provider-specific default values, initialization will\n     * necessarily fail.\n     *\n     * <p>If this cipher (including its underlying feedback or padding scheme)\n     * requires any random bytes (e.g., for parameter generation), it will get\n     * them using the {@link java.security.SecureRandom}\n     * implementation of the highest-priority\n     * installed provider as the source of randomness.\n     * (If none of the installed providers supply an implementation of\n     * SecureRandom, a system-provided source of randomness will be used.)\n     *\n     * <p>Note that when a Cipher object is initialized, it loses all\n     * previously-acquired state. In other words, initializing a Cipher is\n     * equivalent to creating a new instance of that Cipher and initializing\n     * it.\n     *\n     * @param opmode the operation mode of this cipher (this is one of\n     * the following:\n     * <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,\n     * <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)\n     * @param key the key\n     *\n     * @exception InvalidKeyException if the given key is inappropriate for\n     * initializing this cipher, or requires\n     * algorithm parameters that cannot be\n     * determined from the given key, or if the given key has a keysize that\n     * exceeds the maximum allowable keysize (as determined from the\n     * configured jurisdiction policy files).\n     * @throws UnsupportedOperationException if (@code opmode} is\n     * {@code WRAP_MODE} or {@code UNWRAP_MODE} but the mode is not implemented\n     * by the underlying {@code CipherSpi}.\n     ",
    "links" : [ "java.security.SecureRandom", "#getIV()", "#getParameters()" ]
  }, {
    "name" : "public final void init(int opmode, Key key, SecureRandom random) throws InvalidKeyException",
    "returnType" : "void",
    "comment" : "\n     * Initializes this cipher with a key and a source of randomness.\n     *\n     * <p>The cipher is initialized for one of the following four operations:\n     * encryption, decryption, key wrapping or  key unwrapping, depending\n     * on the value of <code>opmode</code>.\n     *\n     * <p>If this cipher requires any algorithm parameters that cannot be\n     * derived from the given <code>key</code>, the underlying cipher\n     * implementation is supposed to generate the required parameters itself\n     * (using provider-specific default or random values) if it is being\n     * initialized for encryption or key wrapping, and raise an\n     * <code>InvalidKeyException</code> if it is being\n     * initialized for decryption or key unwrapping.\n     * The generated parameters can be retrieved using\n     * {@link #getParameters() getParameters} or\n     * {@link #getIV() getIV} (if the parameter is an IV).\n     *\n     * <p>If this cipher requires algorithm parameters that cannot be\n     * derived from the input parameters, and there are no reasonable\n     * provider-specific default values, initialization will\n     * necessarily fail.\n     *\n     * <p>If this cipher (including its underlying feedback or padding scheme)\n     * requires any random bytes (e.g., for parameter generation), it will get\n     * them from <code>random</code>.\n     *\n     * <p>Note that when a Cipher object is initialized, it loses all\n     * previously-acquired state. In other words, initializing a Cipher is\n     * equivalent to creating a new instance of that Cipher and initializing\n     * it.\n     *\n     * @param opmode the operation mode of this cipher (this is one of the\n     * following:\n     * <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,\n     * <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)\n     * @param key the encryption key\n     * @param random the source of randomness\n     *\n     * @exception InvalidKeyException if the given key is inappropriate for\n     * initializing this cipher, or requires\n     * algorithm parameters that cannot be\n     * determined from the given key, or if the given key has a keysize that\n     * exceeds the maximum allowable keysize (as determined from the\n     * configured jurisdiction policy files).\n     * @throws UnsupportedOperationException if (@code opmode} is\n     * {@code WRAP_MODE} or {@code UNWRAP_MODE} but the mode is not implemented\n     * by the underlying {@code CipherSpi}.\n     ",
    "links" : [ "#getIV()", "#getParameters()" ]
  }, {
    "name" : "public final void init(int opmode, Key key, AlgorithmParameterSpec params) throws InvalidKeyException, InvalidAlgorithmParameterException",
    "returnType" : "void",
    "comment" : "\n     * Initializes this cipher with a key and a set of algorithm\n     * parameters.\n     *\n     * <p>The cipher is initialized for one of the following four operations:\n     * encryption, decryption, key wrapping or  key unwrapping, depending\n     * on the value of <code>opmode</code>.\n     *\n     * <p>If this cipher requires any algorithm parameters and\n     * <code>params</code> is null, the underlying cipher implementation is\n     * supposed to generate the required parameters itself (using\n     * provider-specific default or random values) if it is being\n     * initialized for encryption or key wrapping, and raise an\n     * <code>InvalidAlgorithmParameterException</code> if it is being\n     * initialized for decryption or key unwrapping.\n     * The generated parameters can be retrieved using\n     * {@link #getParameters() getParameters} or\n     * {@link #getIV() getIV} (if the parameter is an IV).\n     *\n     * <p>If this cipher requires algorithm parameters that cannot be\n     * derived from the input parameters, and there are no reasonable\n     * provider-specific default values, initialization will\n     * necessarily fail.\n     *\n     * <p>If this cipher (including its underlying feedback or padding scheme)\n     * requires any random bytes (e.g., for parameter generation), it will get\n     * them using the {@link java.security.SecureRandom}\n     * implementation of the highest-priority\n     * installed provider as the source of randomness.\n     * (If none of the installed providers supply an implementation of\n     * SecureRandom, a system-provided source of randomness will be used.)\n     *\n     * <p>Note that when a Cipher object is initialized, it loses all\n     * previously-acquired state. In other words, initializing a Cipher is\n     * equivalent to creating a new instance of that Cipher and initializing\n     * it.\n     *\n     * @param opmode the operation mode of this cipher (this is one of the\n     * following:\n     * <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,\n     * <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)\n     * @param key the encryption key\n     * @param params the algorithm parameters\n     *\n     * @exception InvalidKeyException if the given key is inappropriate for\n     * initializing this cipher, or its keysize exceeds the maximum allowable\n     * keysize (as determined from the configured jurisdiction policy files).\n     * @exception InvalidAlgorithmParameterException if the given algorithm\n     * parameters are inappropriate for this cipher,\n     * or this cipher requires\n     * algorithm parameters and <code>params</code> is null, or the given\n     * algorithm parameters imply a cryptographic strength that would exceed\n     * the legal limits (as determined from the configured jurisdiction\n     * policy files).\n     * @throws UnsupportedOperationException if (@code opmode} is\n     * {@code WRAP_MODE} or {@code UNWRAP_MODE} but the mode is not implemented\n     * by the underlying {@code CipherSpi}.\n     ",
    "links" : [ "java.security.SecureRandom", "#getIV()", "#getParameters()" ]
  }, {
    "name" : "public final void init(int opmode, Key key, AlgorithmParameterSpec params, SecureRandom random) throws InvalidKeyException, InvalidAlgorithmParameterException",
    "returnType" : "void",
    "comment" : "\n     * Initializes this cipher with a key, a set of algorithm\n     * parameters, and a source of randomness.\n     *\n     * <p>The cipher is initialized for one of the following four operations:\n     * encryption, decryption, key wrapping or  key unwrapping, depending\n     * on the value of <code>opmode</code>.\n     *\n     * <p>If this cipher requires any algorithm parameters and\n     * <code>params</code> is null, the underlying cipher implementation is\n     * supposed to generate the required parameters itself (using\n     * provider-specific default or random values) if it is being\n     * initialized for encryption or key wrapping, and raise an\n     * <code>InvalidAlgorithmParameterException</code> if it is being\n     * initialized for decryption or key unwrapping.\n     * The generated parameters can be retrieved using\n     * {@link #getParameters() getParameters} or\n     * {@link #getIV() getIV} (if the parameter is an IV).\n     *\n     * <p>If this cipher requires algorithm parameters that cannot be\n     * derived from the input parameters, and there are no reasonable\n     * provider-specific default values, initialization will\n     * necessarily fail.\n     *\n     * <p>If this cipher (including its underlying feedback or padding scheme)\n     * requires any random bytes (e.g., for parameter generation), it will get\n     * them from <code>random</code>.\n     *\n     * <p>Note that when a Cipher object is initialized, it loses all\n     * previously-acquired state. In other words, initializing a Cipher is\n     * equivalent to creating a new instance of that Cipher and initializing\n     * it.\n     *\n     * @param opmode the operation mode of this cipher (this is one of the\n     * following:\n     * <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,\n     * <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)\n     * @param key the encryption key\n     * @param params the algorithm parameters\n     * @param random the source of randomness\n     *\n     * @exception InvalidKeyException if the given key is inappropriate for\n     * initializing this cipher, or its keysize exceeds the maximum allowable\n     * keysize (as determined from the configured jurisdiction policy files).\n     * @exception InvalidAlgorithmParameterException if the given algorithm\n     * parameters are inappropriate for this cipher,\n     * or this cipher requires\n     * algorithm parameters and <code>params</code> is null, or the given\n     * algorithm parameters imply a cryptographic strength that would exceed\n     * the legal limits (as determined from the configured jurisdiction\n     * policy files).\n     * @throws UnsupportedOperationException if (@code opmode} is\n     * {@code WRAP_MODE} or {@code UNWRAP_MODE} but the mode is not implemented\n     * by the underlying {@code CipherSpi}.\n     ",
    "links" : [ "#getIV()", "#getParameters()" ]
  }, {
    "name" : "public final void init(int opmode, Key key, AlgorithmParameters params) throws InvalidKeyException, InvalidAlgorithmParameterException",
    "returnType" : "void",
    "comment" : "\n     * Initializes this cipher with a key and a set of algorithm\n     * parameters.\n     *\n     * <p>The cipher is initialized for one of the following four operations:\n     * encryption, decryption, key wrapping or  key unwrapping, depending\n     * on the value of <code>opmode</code>.\n     *\n     * <p>If this cipher requires any algorithm parameters and\n     * <code>params</code> is null, the underlying cipher implementation is\n     * supposed to generate the required parameters itself (using\n     * provider-specific default or random values) if it is being\n     * initialized for encryption or key wrapping, and raise an\n     * <code>InvalidAlgorithmParameterException</code> if it is being\n     * initialized for decryption or key unwrapping.\n     * The generated parameters can be retrieved using\n     * {@link #getParameters() getParameters} or\n     * {@link #getIV() getIV} (if the parameter is an IV).\n     *\n     * <p>If this cipher requires algorithm parameters that cannot be\n     * derived from the input parameters, and there are no reasonable\n     * provider-specific default values, initialization will\n     * necessarily fail.\n     *\n     * <p>If this cipher (including its underlying feedback or padding scheme)\n     * requires any random bytes (e.g., for parameter generation), it will get\n     * them using the {@link java.security.SecureRandom}\n     * implementation of the highest-priority\n     * installed provider as the source of randomness.\n     * (If none of the installed providers supply an implementation of\n     * SecureRandom, a system-provided source of randomness will be used.)\n     *\n     * <p>Note that when a Cipher object is initialized, it loses all\n     * previously-acquired state. In other words, initializing a Cipher is\n     * equivalent to creating a new instance of that Cipher and initializing\n     * it.\n     *\n     * @param opmode the operation mode of this cipher (this is one of the\n     * following: <code>ENCRYPT_MODE</code>,\n     * <code>DECRYPT_MODE</code>, <code>WRAP_MODE</code>\n     * or <code>UNWRAP_MODE</code>)\n     * @param key the encryption key\n     * @param params the algorithm parameters\n     *\n     * @exception InvalidKeyException if the given key is inappropriate for\n     * initializing this cipher, or its keysize exceeds the maximum allowable\n     * keysize (as determined from the configured jurisdiction policy files).\n     * @exception InvalidAlgorithmParameterException if the given algorithm\n     * parameters are inappropriate for this cipher,\n     * or this cipher requires\n     * algorithm parameters and <code>params</code> is null, or the given\n     * algorithm parameters imply a cryptographic strength that would exceed\n     * the legal limits (as determined from the configured jurisdiction\n     * policy files).\n     * @throws UnsupportedOperationException if (@code opmode} is\n     * {@code WRAP_MODE} or {@code UNWRAP_MODE} but the mode is not implemented\n     * by the underlying {@code CipherSpi}.\n     ",
    "links" : [ "java.security.SecureRandom", "#getIV()", "#getParameters()" ]
  }, {
    "name" : "public final void init(int opmode, Key key, AlgorithmParameters params, SecureRandom random) throws InvalidKeyException, InvalidAlgorithmParameterException",
    "returnType" : "void",
    "comment" : "\n     * Initializes this cipher with a key, a set of algorithm\n     * parameters, and a source of randomness.\n     *\n     * <p>The cipher is initialized for one of the following four operations:\n     * encryption, decryption, key wrapping or  key unwrapping, depending\n     * on the value of <code>opmode</code>.\n     *\n     * <p>If this cipher requires any algorithm parameters and\n     * <code>params</code> is null, the underlying cipher implementation is\n     * supposed to generate the required parameters itself (using\n     * provider-specific default or random values) if it is being\n     * initialized for encryption or key wrapping, and raise an\n     * <code>InvalidAlgorithmParameterException</code> if it is being\n     * initialized for decryption or key unwrapping.\n     * The generated parameters can be retrieved using\n     * {@link #getParameters() getParameters} or\n     * {@link #getIV() getIV} (if the parameter is an IV).\n     *\n     * <p>If this cipher requires algorithm parameters that cannot be\n     * derived from the input parameters, and there are no reasonable\n     * provider-specific default values, initialization will\n     * necessarily fail.\n     *\n     * <p>If this cipher (including its underlying feedback or padding scheme)\n     * requires any random bytes (e.g., for parameter generation), it will get\n     * them from <code>random</code>.\n     *\n     * <p>Note that when a Cipher object is initialized, it loses all\n     * previously-acquired state. In other words, initializing a Cipher is\n     * equivalent to creating a new instance of that Cipher and initializing\n     * it.\n     *\n     * @param opmode the operation mode of this cipher (this is one of the\n     * following: <code>ENCRYPT_MODE</code>,\n     * <code>DECRYPT_MODE</code>, <code>WRAP_MODE</code>\n     * or <code>UNWRAP_MODE</code>)\n     * @param key the encryption key\n     * @param params the algorithm parameters\n     * @param random the source of randomness\n     *\n     * @exception InvalidKeyException if the given key is inappropriate for\n     * initializing this cipher, or its keysize exceeds the maximum allowable\n     * keysize (as determined from the configured jurisdiction policy files).\n     * @exception InvalidAlgorithmParameterException if the given algorithm\n     * parameters are inappropriate for this cipher,\n     * or this cipher requires\n     * algorithm parameters and <code>params</code> is null, or the given\n     * algorithm parameters imply a cryptographic strength that would exceed\n     * the legal limits (as determined from the configured jurisdiction\n     * policy files).\n     * @throws UnsupportedOperationException if (@code opmode} is\n     * {@code WRAP_MODE} or {@code UNWRAP_MODE} but the mode is not implemented\n     * by the underlying {@code CipherSpi}.\n     ",
    "links" : [ "#getIV()", "#getParameters()" ]
  }, {
    "name" : "public final void init(int opmode, Certificate certificate) throws InvalidKeyException",
    "returnType" : "void",
    "comment" : "\n     * Initializes this cipher with the public key from the given certificate.\n     * <p> The cipher is initialized for one of the following four operations:\n     * encryption, decryption, key wrapping or  key unwrapping, depending\n     * on the value of <code>opmode</code>.\n     *\n     * <p>If the certificate is of type X.509 and has a <i>key usage</i>\n     * extension field marked as critical, and the value of the <i>key usage</i>\n     * extension field implies that the public key in\n     * the certificate and its corresponding private key are not\n     * supposed to be used for the operation represented by the value\n     * of <code>opmode</code>,\n     * an <code>InvalidKeyException</code>\n     * is thrown.\n     *\n     * <p> If this cipher requires any algorithm parameters that cannot be\n     * derived from the public key in the given certificate, the underlying\n     * cipher\n     * implementation is supposed to generate the required parameters itself\n     * (using provider-specific default or random values) if it is being\n     * initialized for encryption or key wrapping, and raise an <code>\n     * InvalidKeyException</code> if it is being initialized for decryption or\n     * key unwrapping.\n     * The generated parameters can be retrieved using\n     * {@link #getParameters() getParameters} or\n     * {@link #getIV() getIV} (if the parameter is an IV).\n     *\n     * <p>If this cipher requires algorithm parameters that cannot be\n     * derived from the input parameters, and there are no reasonable\n     * provider-specific default values, initialization will\n     * necessarily fail.\n     *\n     * <p>If this cipher (including its underlying feedback or padding scheme)\n     * requires any random bytes (e.g., for parameter generation), it will get\n     * them using the\n     * <code>SecureRandom</code>\n     * implementation of the highest-priority\n     * installed provider as the source of randomness.\n     * (If none of the installed providers supply an implementation of\n     * SecureRandom, a system-provided source of randomness will be used.)\n     *\n     * <p>Note that when a Cipher object is initialized, it loses all\n     * previously-acquired state. In other words, initializing a Cipher is\n     * equivalent to creating a new instance of that Cipher and initializing\n     * it.\n     *\n     * @param opmode the operation mode of this cipher (this is one of the\n     * following:\n     * <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,\n     * <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)\n     * @param certificate the certificate\n     *\n     * @exception InvalidKeyException if the public key in the given\n     * certificate is inappropriate for initializing this cipher, or this\n     * cipher requires algorithm parameters that cannot be determined from the\n     * public key in the given certificate, or the keysize of the public key\n     * in the given certificate has a keysize that exceeds the maximum\n     * allowable keysize (as determined by the configured jurisdiction policy\n     * files).\n     * @throws UnsupportedOperationException if (@code opmode} is\n     * {@code WRAP_MODE} or {@code UNWRAP_MODE} but the mode is not implemented\n     * by the underlying {@code CipherSpi}.\n     ",
    "links" : [ "#getIV()", "#getParameters()" ]
  }, {
    "name" : "public final void init(int opmode, Certificate certificate, SecureRandom random) throws InvalidKeyException",
    "returnType" : "void",
    "comment" : "\n     * Initializes this cipher with the public key from the given certificate\n     * and\n     * a source of randomness.\n     *\n     * <p>The cipher is initialized for one of the following four operations:\n     * encryption, decryption, key wrapping\n     * or key unwrapping, depending on\n     * the value of <code>opmode</code>.\n     *\n     * <p>If the certificate is of type X.509 and has a <i>key usage</i>\n     * extension field marked as critical, and the value of the <i>key usage</i>\n     * extension field implies that the public key in\n     * the certificate and its corresponding private key are not\n     * supposed to be used for the operation represented by the value of\n     * <code>opmode</code>,\n     * an <code>InvalidKeyException</code>\n     * is thrown.\n     *\n     * <p>If this cipher requires any algorithm parameters that cannot be\n     * derived from the public key in the given <code>certificate</code>,\n     * the underlying cipher\n     * implementation is supposed to generate the required parameters itself\n     * (using provider-specific default or random values) if it is being\n     * initialized for encryption or key wrapping, and raise an\n     * <code>InvalidKeyException</code> if it is being\n     * initialized for decryption or key unwrapping.\n     * The generated parameters can be retrieved using\n     * {@link #getParameters() getParameters} or\n     * {@link #getIV() getIV} (if the parameter is an IV).\n     *\n     * <p>If this cipher requires algorithm parameters that cannot be\n     * derived from the input parameters, and there are no reasonable\n     * provider-specific default values, initialization will\n     * necessarily fail.\n     *\n     * <p>If this cipher (including its underlying feedback or padding scheme)\n     * requires any random bytes (e.g., for parameter generation), it will get\n     * them from <code>random</code>.\n     *\n     * <p>Note that when a Cipher object is initialized, it loses all\n     * previously-acquired state. In other words, initializing a Cipher is\n     * equivalent to creating a new instance of that Cipher and initializing\n     * it.\n     *\n     * @param opmode the operation mode of this cipher (this is one of the\n     * following:\n     * <code>ENCRYPT_MODE</code>, <code>DECRYPT_MODE</code>,\n     * <code>WRAP_MODE</code> or <code>UNWRAP_MODE</code>)\n     * @param certificate the certificate\n     * @param random the source of randomness\n     *\n     * @exception InvalidKeyException if the public key in the given\n     * certificate is inappropriate for initializing this cipher, or this\n     * cipher\n     * requires algorithm parameters that cannot be determined from the\n     * public key in the given certificate, or the keysize of the public key\n     * in the given certificate has a keysize that exceeds the maximum\n     * allowable keysize (as determined by the configured jurisdiction policy\n     * files).\n     * @throws UnsupportedOperationException if (@code opmode} is\n     * {@code WRAP_MODE} or {@code UNWRAP_MODE} but the mode is not implemented\n     * by the underlying {@code CipherSpi}.\n     ",
    "links" : [ "#getIV()", "#getParameters()" ]
  }, {
    "name" : "private void checkCipherState()",
    "returnType" : "void",
    "comment" : "\n     * Ensures that Cipher is in a valid state for update() and doFinal()\n     * calls - should be initialized and in ENCRYPT_MODE or DECRYPT_MODE.\n     * @throws IllegalStateException if Cipher object is not in valid state.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final byte[] update(byte[] input)",
    "returnType" : "byte[]",
    "comment" : "\n     * Continues a multiple-part encryption or decryption operation\n     * (depending on how this cipher was initialized), processing another data\n     * part.\n     *\n     * <p>The bytes in the <code>input</code> buffer are processed, and the\n     * result is stored in a new buffer.\n     *\n     * <p>If <code>input</code> has a length of zero, this method returns\n     * <code>null</code>.\n     *\n     * @param input the input buffer\n     *\n     * @return the new buffer with the result, or null if the underlying\n     * cipher is a block cipher and the input data is too short to result in a\n     * new block.\n     *\n     * @exception IllegalStateException if this cipher is in a wrong state\n     * (e.g., has not been initialized)\n     ",
    "links" : [ ]
  }, {
    "name" : "public final byte[] update(byte[] input, int inputOffset, int inputLen)",
    "returnType" : "byte[]",
    "comment" : "\n     * Continues a multiple-part encryption or decryption operation\n     * (depending on how this cipher was initialized), processing another data\n     * part.\n     *\n     * <p>The first <code>inputLen</code> bytes in the <code>input</code>\n     * buffer, starting at <code>inputOffset</code> inclusive, are processed,\n     * and the result is stored in a new buffer.\n     *\n     * <p>If <code>inputLen</code> is zero, this method returns\n     * <code>null</code>.\n     *\n     * @param input the input buffer\n     * @param inputOffset the offset in <code>input</code> where the input\n     * starts\n     * @param inputLen the input length\n     *\n     * @return the new buffer with the result, or null if the underlying\n     * cipher is a block cipher and the input data is too short to result in a\n     * new block.\n     *\n     * @exception IllegalStateException if this cipher is in a wrong state\n     * (e.g., has not been initialized)\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int update(byte[] input, int inputOffset, int inputLen, byte[] output) throws ShortBufferException",
    "returnType" : "int",
    "comment" : "\n     * Continues a multiple-part encryption or decryption operation\n     * (depending on how this cipher was initialized), processing another data\n     * part.\n     *\n     * <p>The first <code>inputLen</code> bytes in the <code>input</code>\n     * buffer, starting at <code>inputOffset</code> inclusive, are processed,\n     * and the result is stored in the <code>output</code> buffer.\n     *\n     * <p>If the <code>output</code> buffer is too small to hold the result,\n     * a <code>ShortBufferException</code> is thrown. In this case, repeat this\n     * call with a larger output buffer. Use\n     * {@link #getOutputSize(int) getOutputSize} to determine how big\n     * the output buffer should be.\n     *\n     * <p>If <code>inputLen</code> is zero, this method returns\n     * a length of zero.\n     *\n     * <p>Note: this method should be copy-safe, which means the\n     * <code>input</code> and <code>output</code> buffers can reference\n     * the same byte array and no unprocessed input data is overwritten\n     * when the result is copied into the output buffer.\n     *\n     * @param input the input buffer\n     * @param inputOffset the offset in <code>input</code> where the input\n     * starts\n     * @param inputLen the input length\n     * @param output the buffer for the result\n     *\n     * @return the number of bytes stored in <code>output</code>\n     *\n     * @exception IllegalStateException if this cipher is in a wrong state\n     * (e.g., has not been initialized)\n     * @exception ShortBufferException if the given output buffer is too small\n     * to hold the result\n     ",
    "links" : [ "#getOutputSize(int)" ]
  }, {
    "name" : "public final int update(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) throws ShortBufferException",
    "returnType" : "int",
    "comment" : "\n     * Continues a multiple-part encryption or decryption operation\n     * (depending on how this cipher was initialized), processing another data\n     * part.\n     *\n     * <p>The first <code>inputLen</code> bytes in the <code>input</code>\n     * buffer, starting at <code>inputOffset</code> inclusive, are processed,\n     * and the result is stored in the <code>output</code> buffer, starting at\n     * <code>outputOffset</code> inclusive.\n     *\n     * <p>If the <code>output</code> buffer is too small to hold the result,\n     * a <code>ShortBufferException</code> is thrown. In this case, repeat this\n     * call with a larger output buffer. Use\n     * {@link #getOutputSize(int) getOutputSize} to determine how big\n     * the output buffer should be.\n     *\n     * <p>If <code>inputLen</code> is zero, this method returns\n     * a length of zero.\n     *\n     * <p>Note: this method should be copy-safe, which means the\n     * <code>input</code> and <code>output</code> buffers can reference\n     * the same byte array and no unprocessed input data is overwritten\n     * when the result is copied into the output buffer.\n     *\n     * @param input the input buffer\n     * @param inputOffset the offset in <code>input</code> where the input\n     * starts\n     * @param inputLen the input length\n     * @param output the buffer for the result\n     * @param outputOffset the offset in <code>output</code> where the result\n     * is stored\n     *\n     * @return the number of bytes stored in <code>output</code>\n     *\n     * @exception IllegalStateException if this cipher is in a wrong state\n     * (e.g., has not been initialized)\n     * @exception ShortBufferException if the given output buffer is too small\n     * to hold the result\n     ",
    "links" : [ "#getOutputSize(int)" ]
  }, {
    "name" : "public final int update(ByteBuffer input, ByteBuffer output) throws ShortBufferException",
    "returnType" : "int",
    "comment" : "\n     * Continues a multiple-part encryption or decryption operation\n     * (depending on how this cipher was initialized), processing another data\n     * part.\n     *\n     * <p>All <code>input.remaining()</code> bytes starting at\n     * <code>input.position()</code> are processed. The result is stored\n     * in the output buffer.\n     * Upon return, the input buffer's position will be equal\n     * to its limit; its limit will not have changed. The output buffer's\n     * position will have advanced by n, where n is the value returned\n     * by this method; the output buffer's limit will not have changed.\n     *\n     * <p>If <code>output.remaining()</code> bytes are insufficient to\n     * hold the result, a <code>ShortBufferException</code> is thrown.\n     * In this case, repeat this call with a larger output buffer. Use\n     * {@link #getOutputSize(int) getOutputSize} to determine how big\n     * the output buffer should be.\n     *\n     * <p>Note: this method should be copy-safe, which means the\n     * <code>input</code> and <code>output</code> buffers can reference\n     * the same block of memory and no unprocessed input data is overwritten\n     * when the result is copied into the output buffer.\n     *\n     * @param input the input ByteBuffer\n     * @param output the output ByteByffer\n     *\n     * @return the number of bytes stored in <code>output</code>\n     *\n     * @exception IllegalStateException if this cipher is in a wrong state\n     * (e.g., has not been initialized)\n     * @exception IllegalArgumentException if input and output are the\n     *   same object\n     * @exception ReadOnlyBufferException if the output buffer is read-only\n     * @exception ShortBufferException if there is insufficient space in the\n     * output buffer\n     * @since 1.5\n     ",
    "links" : [ "#getOutputSize(int)" ]
  }, {
    "name" : "public final byte[] doFinal() throws IllegalBlockSizeException, BadPaddingException",
    "returnType" : "byte[]",
    "comment" : "\n     * Finishes a multiple-part encryption or decryption operation, depending\n     * on how this cipher was initialized.\n     *\n     * <p>Input data that may have been buffered during a previous\n     * <code>update</code> operation is processed, with padding (if requested)\n     * being applied.\n     * If an AEAD mode such as GCM/CCM is being used, the authentication\n     * tag is appended in the case of encryption, or verified in the\n     * case of decryption.\n     * The result is stored in a new buffer.\n     *\n     * <p>Upon finishing, this method resets this cipher object to the state\n     * it was in when previously initialized via a call to <code>init</code>.\n     * That is, the object is reset and available to encrypt or decrypt\n     * (depending on the operation mode that was specified in the call to\n     * <code>init</code>) more data.\n     *\n     * <p>Note: if any exception is thrown, this cipher object may need to\n     * be reset before it can be used again.\n     *\n     * @return the new buffer with the result\n     *\n     * @exception IllegalStateException if this cipher is in a wrong state\n     * (e.g., has not been initialized)\n     * @exception IllegalBlockSizeException if this cipher is a block cipher,\n     * no padding has been requested (only in encryption mode), and the total\n     * input length of the data processed by this cipher is not a multiple of\n     * block size; or if this encryption algorithm is unable to\n     * process the input data provided.\n     * @exception BadPaddingException if this cipher is in decryption mode,\n     * and (un)padding has been requested, but the decrypted data is not\n     * bounded by the appropriate padding bytes\n     * @exception AEADBadTagException if this cipher is decrypting in an\n     * AEAD mode (such as GCM/CCM), and the received authentication tag\n     * does not match the calculated value\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int doFinal(byte[] output, int outputOffset) throws IllegalBlockSizeException, ShortBufferException, BadPaddingException",
    "returnType" : "int",
    "comment" : "\n     * Finishes a multiple-part encryption or decryption operation, depending\n     * on how this cipher was initialized.\n     *\n     * <p>Input data that may have been buffered during a previous\n     * <code>update</code> operation is processed, with padding (if requested)\n     * being applied.\n     * If an AEAD mode such as GCM/CCM is being used, the authentication\n     * tag is appended in the case of encryption, or verified in the\n     * case of decryption.\n     * The result is stored in the <code>output</code> buffer, starting at\n     * <code>outputOffset</code> inclusive.\n     *\n     * <p>If the <code>output</code> buffer is too small to hold the result,\n     * a <code>ShortBufferException</code> is thrown. In this case, repeat this\n     * call with a larger output buffer. Use\n     * {@link #getOutputSize(int) getOutputSize} to determine how big\n     * the output buffer should be.\n     *\n     * <p>Upon finishing, this method resets this cipher object to the state\n     * it was in when previously initialized via a call to <code>init</code>.\n     * That is, the object is reset and available to encrypt or decrypt\n     * (depending on the operation mode that was specified in the call to\n     * <code>init</code>) more data.\n     *\n     * <p>Note: if any exception is thrown, this cipher object may need to\n     * be reset before it can be used again.\n     *\n     * @param output the buffer for the result\n     * @param outputOffset the offset in <code>output</code> where the result\n     * is stored\n     *\n     * @return the number of bytes stored in <code>output</code>\n     *\n     * @exception IllegalStateException if this cipher is in a wrong state\n     * (e.g., has not been initialized)\n     * @exception IllegalBlockSizeException if this cipher is a block cipher,\n     * no padding has been requested (only in encryption mode), and the total\n     * input length of the data processed by this cipher is not a multiple of\n     * block size; or if this encryption algorithm is unable to\n     * process the input data provided.\n     * @exception ShortBufferException if the given output buffer is too small\n     * to hold the result\n     * @exception BadPaddingException if this cipher is in decryption mode,\n     * and (un)padding has been requested, but the decrypted data is not\n     * bounded by the appropriate padding bytes\n     * @exception AEADBadTagException if this cipher is decrypting in an\n     * AEAD mode (such as GCM/CCM), and the received authentication tag\n     * does not match the calculated value\n     ",
    "links" : [ "#getOutputSize(int)" ]
  }, {
    "name" : "public final byte[] doFinal(byte[] input) throws IllegalBlockSizeException, BadPaddingException",
    "returnType" : "byte[]",
    "comment" : "\n     * Encrypts or decrypts data in a single-part operation, or finishes a\n     * multiple-part operation. The data is encrypted or decrypted,\n     * depending on how this cipher was initialized.\n     *\n     * <p>The bytes in the <code>input</code> buffer, and any input bytes that\n     * may have been buffered during a previous <code>update</code> operation,\n     * are processed, with padding (if requested) being applied.\n     * If an AEAD mode such as GCM/CCM is being used, the authentication\n     * tag is appended in the case of encryption, or verified in the\n     * case of decryption.\n     * The result is stored in a new buffer.\n     *\n     * <p>Upon finishing, this method resets this cipher object to the state\n     * it was in when previously initialized via a call to <code>init</code>.\n     * That is, the object is reset and available to encrypt or decrypt\n     * (depending on the operation mode that was specified in the call to\n     * <code>init</code>) more data.\n     *\n     * <p>Note: if any exception is thrown, this cipher object may need to\n     * be reset before it can be used again.\n     *\n     * @param input the input buffer\n     *\n     * @return the new buffer with the result\n     *\n     * @exception IllegalStateException if this cipher is in a wrong state\n     * (e.g., has not been initialized)\n     * @exception IllegalBlockSizeException if this cipher is a block cipher,\n     * no padding has been requested (only in encryption mode), and the total\n     * input length of the data processed by this cipher is not a multiple of\n     * block size; or if this encryption algorithm is unable to\n     * process the input data provided.\n     * @exception BadPaddingException if this cipher is in decryption mode,\n     * and (un)padding has been requested, but the decrypted data is not\n     * bounded by the appropriate padding bytes\n     * @exception AEADBadTagException if this cipher is decrypting in an\n     * AEAD mode (such as GCM/CCM), and the received authentication tag\n     * does not match the calculated value\n     ",
    "links" : [ ]
  }, {
    "name" : "public final byte[] doFinal(byte[] input, int inputOffset, int inputLen) throws IllegalBlockSizeException, BadPaddingException",
    "returnType" : "byte[]",
    "comment" : "\n     * Encrypts or decrypts data in a single-part operation, or finishes a\n     * multiple-part operation. The data is encrypted or decrypted,\n     * depending on how this cipher was initialized.\n     *\n     * <p>The first <code>inputLen</code> bytes in the <code>input</code>\n     * buffer, starting at <code>inputOffset</code> inclusive, and any input\n     * bytes that may have been buffered during a previous <code>update</code>\n     * operation, are processed, with padding (if requested) being applied.\n     * If an AEAD mode such as GCM/CCM is being used, the authentication\n     * tag is appended in the case of encryption, or verified in the\n     * case of decryption.\n     * The result is stored in a new buffer.\n     *\n     * <p>Upon finishing, this method resets this cipher object to the state\n     * it was in when previously initialized via a call to <code>init</code>.\n     * That is, the object is reset and available to encrypt or decrypt\n     * (depending on the operation mode that was specified in the call to\n     * <code>init</code>) more data.\n     *\n     * <p>Note: if any exception is thrown, this cipher object may need to\n     * be reset before it can be used again.\n     *\n     * @param input the input buffer\n     * @param inputOffset the offset in <code>input</code> where the input\n     * starts\n     * @param inputLen the input length\n     *\n     * @return the new buffer with the result\n     *\n     * @exception IllegalStateException if this cipher is in a wrong state\n     * (e.g., has not been initialized)\n     * @exception IllegalBlockSizeException if this cipher is a block cipher,\n     * no padding has been requested (only in encryption mode), and the total\n     * input length of the data processed by this cipher is not a multiple of\n     * block size; or if this encryption algorithm is unable to\n     * process the input data provided.\n     * @exception BadPaddingException if this cipher is in decryption mode,\n     * and (un)padding has been requested, but the decrypted data is not\n     * bounded by the appropriate padding bytes\n     * @exception AEADBadTagException if this cipher is decrypting in an\n     * AEAD mode (such as GCM/CCM), and the received authentication tag\n     * does not match the calculated value\n     ",
    "links" : [ ]
  }, {
    "name" : "public final int doFinal(byte[] input, int inputOffset, int inputLen, byte[] output) throws ShortBufferException, IllegalBlockSizeException, BadPaddingException",
    "returnType" : "int",
    "comment" : "\n     * Encrypts or decrypts data in a single-part operation, or finishes a\n     * multiple-part operation. The data is encrypted or decrypted,\n     * depending on how this cipher was initialized.\n     *\n     * <p>The first <code>inputLen</code> bytes in the <code>input</code>\n     * buffer, starting at <code>inputOffset</code> inclusive, and any input\n     * bytes that may have been buffered during a previous <code>update</code>\n     * operation, are processed, with padding (if requested) being applied.\n     * If an AEAD mode such as GCM/CCM is being used, the authentication\n     * tag is appended in the case of encryption, or verified in the\n     * case of decryption.\n     * The result is stored in the <code>output</code> buffer.\n     *\n     * <p>If the <code>output</code> buffer is too small to hold the result,\n     * a <code>ShortBufferException</code> is thrown. In this case, repeat this\n     * call with a larger output buffer. Use\n     * {@link #getOutputSize(int) getOutputSize} to determine how big\n     * the output buffer should be.\n     *\n     * <p>Upon finishing, this method resets this cipher object to the state\n     * it was in when previously initialized via a call to <code>init</code>.\n     * That is, the object is reset and available to encrypt or decrypt\n     * (depending on the operation mode that was specified in the call to\n     * <code>init</code>) more data.\n     *\n     * <p>Note: if any exception is thrown, this cipher object may need to\n     * be reset before it can be used again.\n     *\n     * <p>Note: this method should be copy-safe, which means the\n     * <code>input</code> and <code>output</code> buffers can reference\n     * the same byte array and no unprocessed input data is overwritten\n     * when the result is copied into the output buffer.\n     *\n     * @param input the input buffer\n     * @param inputOffset the offset in <code>input</code> where the input\n     * starts\n     * @param inputLen the input length\n     * @param output the buffer for the result\n     *\n     * @return the number of bytes stored in <code>output</code>\n     *\n     * @exception IllegalStateException if this cipher is in a wrong state\n     * (e.g., has not been initialized)\n     * @exception IllegalBlockSizeException if this cipher is a block cipher,\n     * no padding has been requested (only in encryption mode), and the total\n     * input length of the data processed by this cipher is not a multiple of\n     * block size; or if this encryption algorithm is unable to\n     * process the input data provided.\n     * @exception ShortBufferException if the given output buffer is too small\n     * to hold the result\n     * @exception BadPaddingException if this cipher is in decryption mode,\n     * and (un)padding has been requested, but the decrypted data is not\n     * bounded by the appropriate padding bytes\n     * @exception AEADBadTagException if this cipher is decrypting in an\n     * AEAD mode (such as GCM/CCM), and the received authentication tag\n     * does not match the calculated value\n     ",
    "links" : [ "#getOutputSize(int)" ]
  }, {
    "name" : "public final int doFinal(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) throws ShortBufferException, IllegalBlockSizeException, BadPaddingException",
    "returnType" : "int",
    "comment" : "\n     * Encrypts or decrypts data in a single-part operation, or finishes a\n     * multiple-part operation. The data is encrypted or decrypted,\n     * depending on how this cipher was initialized.\n     *\n     * <p>The first <code>inputLen</code> bytes in the <code>input</code>\n     * buffer, starting at <code>inputOffset</code> inclusive, and any input\n     * bytes that may have been buffered during a previous\n     * <code>update</code> operation, are processed, with padding\n     * (if requested) being applied.\n     * If an AEAD mode such as GCM/CCM is being used, the authentication\n     * tag is appended in the case of encryption, or verified in the\n     * case of decryption.\n     * The result is stored in the <code>output</code> buffer, starting at\n     * <code>outputOffset</code> inclusive.\n     *\n     * <p>If the <code>output</code> buffer is too small to hold the result,\n     * a <code>ShortBufferException</code> is thrown. In this case, repeat this\n     * call with a larger output buffer. Use\n     * {@link #getOutputSize(int) getOutputSize} to determine how big\n     * the output buffer should be.\n     *\n     * <p>Upon finishing, this method resets this cipher object to the state\n     * it was in when previously initialized via a call to <code>init</code>.\n     * That is, the object is reset and available to encrypt or decrypt\n     * (depending on the operation mode that was specified in the call to\n     * <code>init</code>) more data.\n     *\n     * <p>Note: if any exception is thrown, this cipher object may need to\n     * be reset before it can be used again.\n     *\n     * <p>Note: this method should be copy-safe, which means the\n     * <code>input</code> and <code>output</code> buffers can reference\n     * the same byte array and no unprocessed input data is overwritten\n     * when the result is copied into the output buffer.\n     *\n     * @param input the input buffer\n     * @param inputOffset the offset in <code>input</code> where the input\n     * starts\n     * @param inputLen the input length\n     * @param output the buffer for the result\n     * @param outputOffset the offset in <code>output</code> where the result\n     * is stored\n     *\n     * @return the number of bytes stored in <code>output</code>\n     *\n     * @exception IllegalStateException if this cipher is in a wrong state\n     * (e.g., has not been initialized)\n     * @exception IllegalBlockSizeException if this cipher is a block cipher,\n     * no padding has been requested (only in encryption mode), and the total\n     * input length of the data processed by this cipher is not a multiple of\n     * block size; or if this encryption algorithm is unable to\n     * process the input data provided.\n     * @exception ShortBufferException if the given output buffer is too small\n     * to hold the result\n     * @exception BadPaddingException if this cipher is in decryption mode,\n     * and (un)padding has been requested, but the decrypted data is not\n     * bounded by the appropriate padding bytes\n     * @exception AEADBadTagException if this cipher is decrypting in an\n     * AEAD mode (such as GCM/CCM), and the received authentication tag\n     * does not match the calculated value\n     ",
    "links" : [ "#getOutputSize(int)" ]
  }, {
    "name" : "public final int doFinal(ByteBuffer input, ByteBuffer output) throws ShortBufferException, IllegalBlockSizeException, BadPaddingException",
    "returnType" : "int",
    "comment" : "\n     * Encrypts or decrypts data in a single-part operation, or finishes a\n     * multiple-part operation. The data is encrypted or decrypted,\n     * depending on how this cipher was initialized.\n     *\n     * <p>All <code>input.remaining()</code> bytes starting at\n     * <code>input.position()</code> are processed.\n     * If an AEAD mode such as GCM/CCM is being used, the authentication\n     * tag is appended in the case of encryption, or verified in the\n     * case of decryption.\n     * The result is stored in the output buffer.\n     * Upon return, the input buffer's position will be equal\n     * to its limit; its limit will not have changed. The output buffer's\n     * position will have advanced by n, where n is the value returned\n     * by this method; the output buffer's limit will not have changed.\n     *\n     * <p>If <code>output.remaining()</code> bytes are insufficient to\n     * hold the result, a <code>ShortBufferException</code> is thrown.\n     * In this case, repeat this call with a larger output buffer. Use\n     * {@link #getOutputSize(int) getOutputSize} to determine how big\n     * the output buffer should be.\n     *\n     * <p>Upon finishing, this method resets this cipher object to the state\n     * it was in when previously initialized via a call to <code>init</code>.\n     * That is, the object is reset and available to encrypt or decrypt\n     * (depending on the operation mode that was specified in the call to\n     * <code>init</code>) more data.\n     *\n     * <p>Note: if any exception is thrown, this cipher object may need to\n     * be reset before it can be used again.\n     *\n     * <p>Note: this method should be copy-safe, which means the\n     * <code>input</code> and <code>output</code> buffers can reference\n     * the same byte array and no unprocessed input data is overwritten\n     * when the result is copied into the output buffer.\n     *\n     * @param input the input ByteBuffer\n     * @param output the output ByteBuffer\n     *\n     * @return the number of bytes stored in <code>output</code>\n     *\n     * @exception IllegalStateException if this cipher is in a wrong state\n     * (e.g., has not been initialized)\n     * @exception IllegalArgumentException if input and output are the\n     *   same object\n     * @exception ReadOnlyBufferException if the output buffer is read-only\n     * @exception IllegalBlockSizeException if this cipher is a block cipher,\n     * no padding has been requested (only in encryption mode), and the total\n     * input length of the data processed by this cipher is not a multiple of\n     * block size; or if this encryption algorithm is unable to\n     * process the input data provided.\n     * @exception ShortBufferException if there is insufficient space in the\n     * output buffer\n     * @exception BadPaddingException if this cipher is in decryption mode,\n     * and (un)padding has been requested, but the decrypted data is not\n     * bounded by the appropriate padding bytes\n     * @exception AEADBadTagException if this cipher is decrypting in an\n     * AEAD mode (such as GCM/CCM), and the received authentication tag\n     * does not match the calculated value\n     *\n     * @since 1.5\n     ",
    "links" : [ "#getOutputSize(int)" ]
  }, {
    "name" : "public final byte[] wrap(Key key) throws IllegalBlockSizeException, InvalidKeyException",
    "returnType" : "byte[]",
    "comment" : "\n     * Wrap a key.\n     *\n     * @param key the key to be wrapped.\n     *\n     * @return the wrapped key.\n     *\n     * @exception IllegalStateException if this cipher is in a wrong\n     * state (e.g., has not been initialized).\n     *\n     * @exception IllegalBlockSizeException if this cipher is a block\n     * cipher, no padding has been requested, and the length of the\n     * encoding of the key to be wrapped is not a\n     * multiple of the block size.\n     *\n     * @exception InvalidKeyException if it is impossible or unsafe to\n     * wrap the key with this cipher (e.g., a hardware protected key is\n     * being passed to a software-only cipher).\n     *\n     * @throws UnsupportedOperationException if the corresponding method in the\n     * {@code CipherSpi} is not supported.\n     ",
    "links" : [ ]
  }, {
    "name" : "public final Key unwrap(byte[] wrappedKey, String wrappedKeyAlgorithm, int wrappedKeyType) throws InvalidKeyException, NoSuchAlgorithmException",
    "returnType" : "Key",
    "comment" : "\n     * Unwrap a previously wrapped key.\n     *\n     * @param wrappedKey the key to be unwrapped.\n     *\n     * @param wrappedKeyAlgorithm the algorithm associated with the wrapped\n     * key.\n     *\n     * @param wrappedKeyType the type of the wrapped key. This must be one of\n     * <code>SECRET_KEY</code>, <code>PRIVATE_KEY</code>, or\n     * <code>PUBLIC_KEY</code>.\n     *\n     * @return the unwrapped key.\n     *\n     * @exception IllegalStateException if this cipher is in a wrong state\n     * (e.g., has not been initialized).\n     *\n     * @exception NoSuchAlgorithmException if no installed providers\n     * can create keys of type <code>wrappedKeyType</code> for the\n     * <code>wrappedKeyAlgorithm</code>.\n     *\n     * @exception InvalidKeyException if <code>wrappedKey</code> does not\n     * represent a wrapped key of type <code>wrappedKeyType</code> for\n     * the <code>wrappedKeyAlgorithm</code>.\n     *\n     * @throws UnsupportedOperationException if the corresponding method in the\n     * {@code CipherSpi} is not supported.\n     ",
    "links" : [ ]
  }, {
    "name" : "private AlgorithmParameterSpec getAlgorithmParameterSpec(AlgorithmParameters params) throws InvalidParameterSpecException",
    "returnType" : "AlgorithmParameterSpec",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static final int getMaxAllowedKeyLength(String transformation) throws NoSuchAlgorithmException",
    "returnType" : "int",
    "comment" : "\n     * Returns the maximum key length for the specified transformation\n     * according to the installed JCE jurisdiction policy files. If\n     * JCE unlimited strength jurisdiction policy files are installed,\n     * Integer.MAX_VALUE will be returned.\n     * For more information on default key size in JCE jurisdiction\n     * policy files, please see Appendix E in the\n     * <a href=\n     *   \"{@docRoot}/../technotes/guides/security/crypto/CryptoSpec.html#AppC\">\n     * Java Cryptography Architecture Reference Guide</a>.\n     *\n     * @param transformation the cipher transformation.\n     * @return the maximum key length in bits or Integer.MAX_VALUE.\n     * @exception NullPointerException if <code>transformation</code> is null.\n     * @exception NoSuchAlgorithmException if <code>transformation</code>\n     * is not a valid transformation, i.e. in the form of \"algorithm\" or\n     * \"algorithm/mode/padding\".\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final AlgorithmParameterSpec getMaxAllowedParameterSpec(String transformation) throws NoSuchAlgorithmException",
    "returnType" : "AlgorithmParameterSpec",
    "comment" : "\n     * Returns an AlgorithmParameterSpec object which contains\n     * the maximum cipher parameter value according to the\n     * jurisdiction policy file. If JCE unlimited strength jurisdiction\n     * policy files are installed or there is no maximum limit on the\n     * parameters for the specified transformation in the policy file,\n     * null will be returned.\n     *\n     * @param transformation the cipher transformation.\n     * @return an AlgorithmParameterSpec which holds the maximum\n     * value or null.\n     * @exception NullPointerException if <code>transformation</code>\n     * is null.\n     * @exception NoSuchAlgorithmException if <code>transformation</code>\n     * is not a valid transformation, i.e. in the form of \"algorithm\" or\n     * \"algorithm/mode/padding\".\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void updateAAD(byte[] src)",
    "returnType" : "void",
    "comment" : "\n     * Continues a multi-part update of the Additional Authentication\n     * Data (AAD).\n     * <p>\n     * Calls to this method provide AAD to the cipher when operating in\n     * modes such as AEAD (GCM/CCM).  If this cipher is operating in\n     * either GCM or CCM mode, all AAD must be supplied before beginning\n     * operations on the ciphertext (via the {@code update} and {@code\n     * doFinal} methods).\n     *\n     * @param src the buffer containing the Additional Authentication Data\n     *\n     * @throws IllegalArgumentException if the {@code src}\n     * byte array is null\n     * @throws IllegalStateException if this cipher is in a wrong state\n     * (e.g., has not been initialized), does not accept AAD, or if\n     * operating in either GCM or CCM mode and one of the {@code update}\n     * methods has already been called for the active\n     * encryption/decryption operation\n     * @throws UnsupportedOperationException if the corresponding method\n     * in the {@code CipherSpi} has not been overridden by an\n     * implementation\n     *\n     * @since 1.7\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void updateAAD(byte[] src, int offset, int len)",
    "returnType" : "void",
    "comment" : "\n     * Continues a multi-part update of the Additional Authentication\n     * Data (AAD), using a subset of the provided buffer.\n     * <p>\n     * Calls to this method provide AAD to the cipher when operating in\n     * modes such as AEAD (GCM/CCM).  If this cipher is operating in\n     * either GCM or CCM mode, all AAD must be supplied before beginning\n     * operations on the ciphertext (via the {@code update} and {@code\n     * doFinal} methods).\n     *\n     * @param src the buffer containing the AAD\n     * @param offset the offset in {@code src} where the AAD input starts\n     * @param len the number of AAD bytes\n     *\n     * @throws IllegalArgumentException if the {@code src}\n     * byte array is null, or the {@code offset} or {@code length}\n     * is less than 0, or the sum of the {@code offset} and\n     * {@code len} is greater than the length of the\n     * {@code src} byte array\n     * @throws IllegalStateException if this cipher is in a wrong state\n     * (e.g., has not been initialized), does not accept AAD, or if\n     * operating in either GCM or CCM mode and one of the {@code update}\n     * methods has already been called for the active\n     * encryption/decryption operation\n     * @throws UnsupportedOperationException if the corresponding method\n     * in the {@code CipherSpi} has not been overridden by an\n     * implementation\n     *\n     * @since 1.7\n     ",
    "links" : [ ]
  }, {
    "name" : "public final void updateAAD(ByteBuffer src)",
    "returnType" : "void",
    "comment" : "\n     * Continues a multi-part update of the Additional Authentication\n     * Data (AAD).\n     * <p>\n     * Calls to this method provide AAD to the cipher when operating in\n     * modes such as AEAD (GCM/CCM).  If this cipher is operating in\n     * either GCM or CCM mode, all AAD must be supplied before beginning\n     * operations on the ciphertext (via the {@code update} and {@code\n     * doFinal} methods).\n     * <p>\n     * All {@code src.remaining()} bytes starting at\n     * {@code src.position()} are processed.\n     * Upon return, the input buffer's position will be equal\n     * to its limit; its limit will not have changed.\n     *\n     * @param src the buffer containing the AAD\n     *\n     * @throws IllegalArgumentException if the {@code src ByteBuffer}\n     * is null\n     * @throws IllegalStateException if this cipher is in a wrong state\n     * (e.g., has not been initialized), does not accept AAD, or if\n     * operating in either GCM or CCM mode and one of the {@code update}\n     * methods has already been called for the active\n     * encryption/decryption operation\n     * @throws UnsupportedOperationException if the corresponding method\n     * in the {@code CipherSpi} has not been overridden by an\n     * implementation\n     *\n     * @since 1.7\n     ",
    "links" : [ ]
  }, {
    "name" : "public CipherSpi getCurrentSpi()",
    "returnType" : "CipherSpi",
    "comment" : "\n     * Returns the {@code CipherSpi} backing this {@code Cipher} or {@code null} if no\n     * {@code CipherSpi} is backing this {@code Cipher}.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " static boolean matchAttribute(Provider.Service service, String attr, String value)",
    "returnType" : "boolean",
    "comment" : "\n     * If the attribute listed exists, check that it matches the regular\n     * expression.\n     ",
    "links" : [ ]
  }, {
    "name" : " static CipherSpiAndProvider tryCombinations(InitParams initParams, Provider provider, String[] tokenizedTransformation) throws InvalidKeyException, InvalidAlgorithmParameterException",
    "returnType" : "CipherSpiAndProvider",
    "comment" : "\n     * Tries to find the correct {@code Cipher} transform to use. Returns a\n     * {@link org.apache.harmony.security.fortress.Engine.SpiAndProvider}, throws the first exception that was\n     * encountered during attempted initialization, or {@code null} if there are\n     * no providers that support the {@code initParams}.\n     * <p>\n     * {@code tokenizedTransformation} must be in the format returned by\n     * {@link Cipher#checkTransformation(String)}. The combinations of mode strings\n     * tried are as follows:\n     * <ul>\n     * <li><code>[cipher]/[mode]/[padding]</code>\n     * <li><code>[cipher]/[mode]</code>\n     * <li><code>[cipher]//[padding]</code>\n     * <li><code>[cipher]</code>\n     * </ul>\n     * {@code services} is a list of cipher services. Needs to be non-null only if\n     * {@code provider != null}\n     ",
    "links" : [ "org.apache.harmony.security.fortress.Engine.SpiAndProvider", "javax.crypto.Cipher#checkTransformation(String)" ]
  }, {
    "name" : " static CipherSpiAndProvider tryTransformWithProvider(InitParams initParams, String[] tokenizedTransformation, NeedToSet type, Provider.Service service) throws InvalidKeyException, InvalidAlgorithmParameterException",
    "returnType" : "CipherSpiAndProvider",
    "comment" : "\n     * Tries to initialize the {@code Cipher} from a given {@code service}. If\n     * initialization is successful, the initialized {@code spi} is returned. If\n     * the {@code service} cannot be initialized with the specified\n     * {@code initParams}, then it's expected to throw\n     * {@code InvalidKeyException} or {@code InvalidAlgorithmParameterException}\n     * as a hint to the caller that it should continue searching for a\n     * {@code Service} that will work.\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "private static String[] tokenizeTransformation(String transformation) throws NoSuchAlgorithmException", "public static final Cipher getInstance(String transformation) throws NoSuchAlgorithmException, NoSuchPaddingException", "public static final Cipher getInstance(String transformation, String provider) throws NoSuchAlgorithmException, NoSuchProviderException, NoSuchPaddingException", "public static final Cipher getInstance(String transformation, Provider provider) throws NoSuchAlgorithmException, NoSuchPaddingException", " static final Cipher createCipher(String transformation, Provider provider) throws NoSuchAlgorithmException, NoSuchPaddingException", " void updateProviderIfNeeded()", "private void chooseProvider(InitType initType, int opmode, Key key, AlgorithmParameterSpec paramSpec, AlgorithmParameters params, SecureRandom random) throws InvalidKeyException, InvalidAlgorithmParameterException", "public final Provider getProvider()", "public final String getAlgorithm()", "public final int getBlockSize()", "public final int getOutputSize(int inputLen)", "public final byte[] getIV()", "public final AlgorithmParameters getParameters()", "public final ExemptionMechanism getExemptionMechanism()", "private static void checkOpmode(int opmode)", "private static String getOpmodeString(int opmode)", "public final void init(int opmode, Key key) throws InvalidKeyException", "public final void init(int opmode, Key key, SecureRandom random) throws InvalidKeyException", "public final void init(int opmode, Key key, AlgorithmParameterSpec params) throws InvalidKeyException, InvalidAlgorithmParameterException", "public final void init(int opmode, Key key, AlgorithmParameterSpec params, SecureRandom random) throws InvalidKeyException, InvalidAlgorithmParameterException", "public final void init(int opmode, Key key, AlgorithmParameters params) throws InvalidKeyException, InvalidAlgorithmParameterException", "public final void init(int opmode, Key key, AlgorithmParameters params, SecureRandom random) throws InvalidKeyException, InvalidAlgorithmParameterException", "public final void init(int opmode, Certificate certificate) throws InvalidKeyException", "public final void init(int opmode, Certificate certificate, SecureRandom random) throws InvalidKeyException", "private void checkCipherState()", "public final byte[] update(byte[] input)", "public final byte[] update(byte[] input, int inputOffset, int inputLen)", "public final int update(byte[] input, int inputOffset, int inputLen, byte[] output) throws ShortBufferException", "public final int update(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) throws ShortBufferException", "public final int update(ByteBuffer input, ByteBuffer output) throws ShortBufferException", "public final byte[] doFinal() throws IllegalBlockSizeException, BadPaddingException", "public final int doFinal(byte[] output, int outputOffset) throws IllegalBlockSizeException, ShortBufferException, BadPaddingException", "public final byte[] doFinal(byte[] input) throws IllegalBlockSizeException, BadPaddingException", "public final byte[] doFinal(byte[] input, int inputOffset, int inputLen) throws IllegalBlockSizeException, BadPaddingException", "public final int doFinal(byte[] input, int inputOffset, int inputLen, byte[] output) throws ShortBufferException, IllegalBlockSizeException, BadPaddingException", "public final int doFinal(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) throws ShortBufferException, IllegalBlockSizeException, BadPaddingException", "public final int doFinal(ByteBuffer input, ByteBuffer output) throws ShortBufferException, IllegalBlockSizeException, BadPaddingException", "public final byte[] wrap(Key key) throws IllegalBlockSizeException, InvalidKeyException", "public final Key unwrap(byte[] wrappedKey, String wrappedKeyAlgorithm, int wrappedKeyType) throws InvalidKeyException, NoSuchAlgorithmException", "private AlgorithmParameterSpec getAlgorithmParameterSpec(AlgorithmParameters params) throws InvalidParameterSpecException", "public static final int getMaxAllowedKeyLength(String transformation) throws NoSuchAlgorithmException", "public static final AlgorithmParameterSpec getMaxAllowedParameterSpec(String transformation) throws NoSuchAlgorithmException", "public final void updateAAD(byte[] src)", "public final void updateAAD(byte[] src, int offset, int len)", "public final void updateAAD(ByteBuffer src)", "public CipherSpi getCurrentSpi()", " static boolean matchAttribute(Provider.Service service, String attr, String value)", " static CipherSpiAndProvider tryCombinations(InitParams initParams, Provider provider, String[] tokenizedTransformation) throws InvalidKeyException, InvalidAlgorithmParameterException", " static CipherSpiAndProvider tryTransformWithProvider(InitParams initParams, String[] tokenizedTransformation, NeedToSet type, Provider.Service service) throws InvalidKeyException, InvalidAlgorithmParameterException" ],
  "variableNames" : [ "ENCRYPT_MODE", "DECRYPT_MODE", "WRAP_MODE", "UNWRAP_MODE", "PUBLIC_KEY", "PRIVATE_KEY", "SECRET_KEY", "provider", "spi", "transformation", "tokenizedTransformation", "exmech", "initialized", "opmode", "KEY_USAGE_EXTENSION_OID", "spiAndProviderUpdater", "ATTRIBUTE_PADDINGS", "ATTRIBUTE_MODES" ]
}