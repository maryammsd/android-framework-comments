{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/app/AlarmManager.java",
  "packageName" : "android.app",
  "className" : "AlarmManager",
  "comment" : "\n * This class provides access to the system alarm services.  These allow you\n * to schedule your application to be run at some point in the future.  When\n * an alarm goes off, the {@link Intent} that had been registered for it\n * is broadcast by the system, automatically starting the target application\n * if it is not already running.  Registered alarms are retained while the\n * device is asleep (and can optionally wake the device up if they go off\n * during that time), but will be cleared if it is turned off and rebooted.\n *\n * <p>The Alarm Manager holds a CPU wake lock as long as the alarm receiver's\n * onReceive() method is executing. This guarantees that the phone will not sleep\n * until you have finished handling the broadcast. Once onReceive() returns, the\n * Alarm Manager releases this wake lock. This means that the phone will in some\n * cases sleep as soon as your onReceive() method completes.  If your alarm receiver\n * called {@link android.content.Context#startService Context.startService()}, it\n * is possible that the phone will sleep before the requested service is launched.\n * To prevent this, your BroadcastReceiver and Service will need to implement a\n * separate wake lock policy to ensure that the phone continues running until the\n * service becomes available.\n *\n * <p><b>Note: The Alarm Manager is intended for cases where you want to have\n * your application code run at a specific time, even if your application is\n * not currently running.  For normal timing operations (ticks, timeouts,\n * etc) it is easier and much more efficient to use\n * {@link android.os.Handler}.</b>\n *\n * <p class=\"caution\"><strong>Note:</strong> Beginning with API 19\n * ({@link android.os.Build.VERSION_CODES#KITKAT}) alarm delivery is inexact:\n * the OS will shift alarms in order to minimize wakeups and battery use.  There are\n * new APIs to support applications which need strict delivery guarantees; see\n * {@link #setWindow(int, long, long, PendingIntent)} and\n * {@link #setExact(int, long, PendingIntent)}.  Applications whose {@code targetSdkVersion}\n * is earlier than API 19 will continue to see the previous behavior in which all\n * alarms are delivered exactly when requested.\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RTC_WAKEUP",
    "type" : "int",
    "comment" : "\n     * Alarm time in {@link System#currentTimeMillis System.currentTimeMillis()}\n     * (wall clock time in UTC), which will wake up the device when\n     * it goes off.\n     ",
    "links" : [ "#currentTimeMillis" ]
  }, {
    "name" : "RTC",
    "type" : "int",
    "comment" : "\n     * Alarm time in {@link System#currentTimeMillis System.currentTimeMillis()}\n     * (wall clock time in UTC).  This alarm does not wake the\n     * device up; if it goes off while the device is asleep, it will not be\n     * delivered until the next time the device wakes up.\n     ",
    "links" : [ "#currentTimeMillis" ]
  }, {
    "name" : "ELAPSED_REALTIME_WAKEUP",
    "type" : "int",
    "comment" : "\n     * Alarm time in {@link android.os.SystemClock#elapsedRealtime\n     * SystemClock.elapsedRealtime()} (time since boot, including sleep),\n     * which will wake up the device when it goes off.\n     ",
    "links" : [ "android.os.SystemClock#elapsedRealtimeSystemClock.elapsedRealtime()" ]
  }, {
    "name" : "ELAPSED_REALTIME",
    "type" : "int",
    "comment" : "\n     * Alarm time in {@link android.os.SystemClock#elapsedRealtime\n     * SystemClock.elapsedRealtime()} (time since boot, including sleep).\n     * This alarm does not wake the device up; if it goes off while the device\n     * is asleep, it will not be delivered until the next time the device\n     * wakes up.\n     ",
    "links" : [ "android.os.SystemClock#elapsedRealtimeSystemClock.elapsedRealtime()" ]
  }, {
    "name" : "ACTION_NEXT_ALARM_CLOCK_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Sent after the value returned by\n     * {@link #getNextAlarmClock()} has changed.\n     *\n     * <p class=\"note\">This is a protected intent that can only be sent by the system.\n     * It is only sent to registered receivers.</p>\n     ",
    "links" : [ "#getNextAlarmClock()" ]
  }, {
    "name" : "WINDOW_EXACT",
    "type" : "long",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "WINDOW_HEURISTIC",
    "type" : "long",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "FLAG_STANDALONE",
    "type" : "int",
    "comment" : "\n     * Flag for alarms: this is to be a stand-alone alarm, that should not be batched with\n     * other alarms.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_WAKE_FROM_IDLE",
    "type" : "int",
    "comment" : "\n     * Flag for alarms: this alarm would like to wake the device even if it is idle.  This\n     * is, for example, an alarm for an alarm clock.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_ALLOW_WHILE_IDLE",
    "type" : "int",
    "comment" : "\n     * Flag for alarms: this alarm would like to still execute even if the device is\n     * idle.  This won't bring the device out of idle, just allow this specific alarm to\n     * run.  Note that this means the actual time this alarm goes off can be inconsistent\n     * with the time of non-allow-while-idle alarms (it could go earlier than the time\n     * requested by another alarm).\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED",
    "type" : "int",
    "comment" : "\n     * Flag for alarms: same as {@link #FLAG_ALLOW_WHILE_IDLE}, but doesn't have restrictions\n     * on how frequently it can be scheduled.  Only available (and automatically applied) to\n     * system alarms.\n     *\n     * @hide\n     ",
    "links" : [ "#FLAG_ALLOW_WHILE_IDLE" ]
  }, {
    "name" : "FLAG_IDLE_UNTIL",
    "type" : "int",
    "comment" : "\n     * Flag for alarms: this alarm marks the point where we would like to come out of idle\n     * mode.  It may be moved by the alarm manager to match the first wake-from-idle alarm.\n     * Scheduling an alarm with this flag puts the alarm manager in to idle mode, where it\n     * avoids scheduling any further alarms until the marker alarm is executed.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "mService",
    "type" : "IAlarmManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPackageName",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAlwaysExact",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTargetSdkVersion",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMainThreadHandler",
    "type" : "Handler",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sWrappers",
    "type" : "WeakHashMap<OnAlarmListener, WeakReference<ListenerWrapper>>",
    "comment" : "\n     * Tracking of the OnAlarmListener -> ListenerWrapper mapping, for cancel() support.\n     * An entry is guaranteed to stay in this map as long as its ListenerWrapper is held by the\n     * server.\n     *\n     * <p>Access is synchronized on the AlarmManager class object.\n     ",
    "links" : [ ]
  }, {
    "name" : "INTERVAL_FIFTEEN_MINUTES",
    "type" : "long",
    "comment" : "\n     * Available inexact recurrence interval recognized by\n     * {@link #setInexactRepeating(int, long, long, PendingIntent)}\n     * when running on Android prior to API 19.\n     ",
    "links" : [ "#setInexactRepeating(int" ]
  }, {
    "name" : "INTERVAL_HALF_HOUR",
    "type" : "long",
    "comment" : "\n     * Available inexact recurrence interval recognized by\n     * {@link #setInexactRepeating(int, long, long, PendingIntent)}\n     * when running on Android prior to API 19.\n     ",
    "links" : [ "#setInexactRepeating(int" ]
  }, {
    "name" : "INTERVAL_HOUR",
    "type" : "long",
    "comment" : "\n     * Available inexact recurrence interval recognized by\n     * {@link #setInexactRepeating(int, long, long, PendingIntent)}\n     * when running on Android prior to API 19.\n     ",
    "links" : [ "#setInexactRepeating(int" ]
  }, {
    "name" : "INTERVAL_HALF_DAY",
    "type" : "long",
    "comment" : "\n     * Available inexact recurrence interval recognized by\n     * {@link #setInexactRepeating(int, long, long, PendingIntent)}\n     * when running on Android prior to API 19.\n     ",
    "links" : [ "#setInexactRepeating(int" ]
  }, {
    "name" : "INTERVAL_DAY",
    "type" : "long",
    "comment" : "\n     * Available inexact recurrence interval recognized by\n     * {@link #setInexactRepeating(int, long, long, PendingIntent)}\n     * when running on Android prior to API 19.\n     ",
    "links" : [ "#setInexactRepeating(int" ]
  } ],
  "methods" : [ {
    "name" : "private long legacyExactLength()",
    "returnType" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void set(@AlarmType int type, long triggerAtMillis, PendingIntent operation)",
    "returnType" : "void",
    "comment" : "\n     * <p>Schedule an alarm.  <b>Note: for timing operations (ticks, timeouts,\n     * etc) it is easier and much more efficient to use {@link android.os.Handler}.</b>\n     * If there is already an alarm scheduled for the same IntentSender, that previous\n     * alarm will first be canceled.\n     *\n     * <p>If the stated trigger time is in the past, the alarm will be triggered\n     * immediately.  If there is already an alarm for this Intent\n     * scheduled (with the equality of two intents being defined by\n     * {@link Intent#filterEquals}), then it will be removed and replaced by\n     * this one.\n     *\n     * <p>\n     * The alarm is an Intent broadcast that goes to a broadcast receiver that\n     * you registered with {@link android.content.Context#registerReceiver}\n     * or through the &lt;receiver&gt; tag in an AndroidManifest.xml file.\n     *\n     * <p>\n     * Alarm intents are delivered with a data extra of type int called\n     * {@link Intent#EXTRA_ALARM_COUNT Intent.EXTRA_ALARM_COUNT} that indicates\n     * how many past alarm events have been accumulated into this intent\n     * broadcast.  Recurring alarms that have gone undelivered because the\n     * phone was asleep may have a count greater than one when delivered.\n     *\n     * <div class=\"note\">\n     * <p>\n     * <b>Note:</b> Beginning in API 19, the trigger time passed to this method\n     * is treated as inexact: the alarm will not be delivered before this time, but\n     * may be deferred and delivered some time later.  The OS will use\n     * this policy in order to \"batch\" alarms together across the entire system,\n     * minimizing the number of times the device needs to \"wake up\" and minimizing\n     * battery use.  In general, alarms scheduled in the near future will not\n     * be deferred as long as alarms scheduled far in the future.\n     *\n     * <p>\n     * With the new batching policy, delivery ordering guarantees are not as\n     * strong as they were previously.  If the application sets multiple alarms,\n     * it is possible that these alarms' <em>actual</em> delivery ordering may not match\n     * the order of their <em>requested</em> delivery times.  If your application has\n     * strong ordering requirements there are other APIs that you can use to get\n     * the necessary behavior; see {@link #setWindow(int, long, long, PendingIntent)}\n     * and {@link #setExact(int, long, PendingIntent)}.\n     *\n     * <p>\n     * Applications whose {@code targetSdkVersion} is before API 19 will\n     * continue to get the previous alarm behavior: all of their scheduled alarms\n     * will be treated as exact.\n     * </div>\n     *\n     * @param type type of alarm.\n     * @param triggerAtMillis time in milliseconds that the alarm should go\n     * off, using the appropriate clock (depending on the alarm type).\n     * @param operation Action to perform when the alarm goes off;\n     * typically comes from {@link PendingIntent#getBroadcast\n     * IntentSender.getBroadcast()}.\n     *\n     * @see android.os.Handler\n     * @see #setExact\n     * @see #setRepeating\n     * @see #setWindow\n     * @see #cancel\n     * @see android.content.Context#sendBroadcast\n     * @see android.content.Context#registerReceiver\n     * @see android.content.Intent#filterEquals\n     * @see #ELAPSED_REALTIME\n     * @see #ELAPSED_REALTIME_WAKEUP\n     * @see #RTC\n     * @see #RTC_WAKEUP\n     ",
    "links" : [ "android.app.PendingIntent#getBroadcastIntentSender.getBroadcast()", "#setWindow(int", "android.content.Intent#EXTRA_ALARM_COUNT", "android.os.Handler", "android.content.Intent#filterEquals", "android.content.Context#registerReceiver", "#setExact(int" ]
  }, {
    "name" : "public void set(@AlarmType int type, long triggerAtMillis, String tag, OnAlarmListener listener, Handler targetHandler)",
    "returnType" : "void",
    "comment" : "\n     * Direct callback version of {@link #set(int, long, PendingIntent)}.  Rather than\n     * supplying a PendingIntent to be sent when the alarm time is reached, this variant\n     * supplies an {@link OnAlarmListener} instance that will be invoked at that time.\n     * <p>\n     * The OnAlarmListener's {@link OnAlarmListener#onAlarm() onAlarm()} method will be\n     * invoked via the specified target Handler, or on the application's main looper\n     * if {@code null} is passed as the {@code targetHandler} parameter.\n     *\n     * @param type type of alarm.\n     * @param triggerAtMillis time in milliseconds that the alarm should go\n     *         off, using the appropriate clock (depending on the alarm type).\n     * @param tag string describing the alarm, used for logging and battery-use\n     *         attribution\n     * @param listener {@link OnAlarmListener} instance whose\n     *         {@link OnAlarmListener#onAlarm() onAlarm()} method will be\n     *         called when the alarm time is reached.  A given OnAlarmListener instance can\n     *         only be the target of a single pending alarm, just as a given PendingIntent\n     *         can only be used with one alarm at a time.\n     * @param targetHandler {@link Handler} on which to execute the listener's onAlarm()\n     *         callback, or {@code null} to run that callback on the main looper.\n     ",
    "links" : [ "#set(int", "#onAlarm()", "android.os.Handler", "OnAlarmListener" ]
  }, {
    "name" : "public void setRepeating(@AlarmType int type, long triggerAtMillis, long intervalMillis, PendingIntent operation)",
    "returnType" : "void",
    "comment" : "\n     * Schedule a repeating alarm.  <b>Note: for timing operations (ticks,\n     * timeouts, etc) it is easier and much more efficient to use\n     * {@link android.os.Handler}.</b>  If there is already an alarm scheduled\n     * for the same IntentSender, it will first be canceled.\n     *\n     * <p>Like {@link #set}, except you can also supply a period at which\n     * the alarm will automatically repeat.  This alarm continues\n     * repeating until explicitly removed with {@link #cancel}.  If the stated\n     * trigger time is in the past, the alarm will be triggered immediately, with an\n     * alarm count depending on how far in the past the trigger time is relative\n     * to the repeat interval.\n     *\n     * <p>If an alarm is delayed (by system sleep, for example, for non\n     * _WAKEUP alarm types), a skipped repeat will be delivered as soon as\n     * possible.  After that, future alarms will be delivered according to the\n     * original schedule; they do not drift over time.  For example, if you have\n     * set a recurring alarm for the top of every hour but the phone was asleep\n     * from 7:45 until 8:45, an alarm will be sent as soon as the phone awakens,\n     * then the next alarm will be sent at 9:00.\n     *\n     * <p>If your application wants to allow the delivery times to drift in\n     * order to guarantee that at least a certain time interval always elapses\n     * between alarms, then the approach to take is to use one-time alarms,\n     * scheduling the next one yourself when handling each alarm delivery.\n     *\n     * <p class=\"note\">\n     * <b>Note:</b> as of API 19, all repeating alarms are inexact.  If your\n     * application needs precise delivery times then it must use one-time\n     * exact alarms, rescheduling each time as described above. Legacy applications\n     * whose {@code targetSdkVersion} is earlier than API 19 will continue to have all\n     * of their alarms, including repeating alarms, treated as exact.\n     *\n     * @param type type of alarm.\n     * @param triggerAtMillis time in milliseconds that the alarm should first\n     * go off, using the appropriate clock (depending on the alarm type).\n     * @param intervalMillis interval in milliseconds between subsequent repeats\n     * of the alarm.\n     * @param operation Action to perform when the alarm goes off;\n     * typically comes from {@link PendingIntent#getBroadcast\n     * IntentSender.getBroadcast()}.\n     *\n     * @see android.os.Handler\n     * @see #set\n     * @see #setExact\n     * @see #setWindow\n     * @see #cancel\n     * @see android.content.Context#sendBroadcast\n     * @see android.content.Context#registerReceiver\n     * @see android.content.Intent#filterEquals\n     * @see #ELAPSED_REALTIME\n     * @see #ELAPSED_REALTIME_WAKEUP\n     * @see #RTC\n     * @see #RTC_WAKEUP\n     ",
    "links" : [ "android.app.PendingIntent#getBroadcastIntentSender.getBroadcast()", "android.os.Handler", "#cancel", "#set" ]
  }, {
    "name" : "public void setWindow(@AlarmType int type, long windowStartMillis, long windowLengthMillis, PendingIntent operation)",
    "returnType" : "void",
    "comment" : "\n     * Schedule an alarm to be delivered within a given window of time.  This method\n     * is similar to {@link #set(int, long, PendingIntent)}, but allows the\n     * application to precisely control the degree to which its delivery might be\n     * adjusted by the OS. This method allows an application to take advantage of the\n     * battery optimizations that arise from delivery batching even when it has\n     * modest timeliness requirements for its alarms.\n     *\n     * <p>\n     * This method can also be used to achieve strict ordering guarantees among\n     * multiple alarms by ensuring that the windows requested for each alarm do\n     * not intersect.\n     *\n     * <p>\n     * When precise delivery is not required, applications should use the standard\n     * {@link #set(int, long, PendingIntent)} method.  This will give the OS the most\n     * flexibility to minimize wakeups and battery use.  For alarms that must be delivered\n     * at precisely-specified times with no acceptable variation, applications can use\n     * {@link #setExact(int, long, PendingIntent)}.\n     *\n     * @param type type of alarm.\n     * @param windowStartMillis The earliest time, in milliseconds, that the alarm should\n     *        be delivered, expressed in the appropriate clock's units (depending on the alarm\n     *        type).\n     * @param windowLengthMillis The length of the requested delivery window,\n     *        in milliseconds.  The alarm will be delivered no later than this many\n     *        milliseconds after {@code windowStartMillis}.  Note that this parameter\n     *        is a <i>duration,</i> not the timestamp of the end of the window.\n     * @param operation Action to perform when the alarm goes off;\n     *        typically comes from {@link PendingIntent#getBroadcast\n     *        IntentSender.getBroadcast()}.\n     *\n     * @see #set\n     * @see #setExact\n     * @see #setRepeating\n     * @see #cancel\n     * @see android.content.Context#sendBroadcast\n     * @see android.content.Context#registerReceiver\n     * @see android.content.Intent#filterEquals\n     * @see #ELAPSED_REALTIME\n     * @see #ELAPSED_REALTIME_WAKEUP\n     * @see #RTC\n     * @see #RTC_WAKEUP\n     ",
    "links" : [ "android.app.PendingIntent#getBroadcastIntentSender.getBroadcast()", "#set(int", "#setExact(int" ]
  }, {
    "name" : "public void setWindow(@AlarmType int type, long windowStartMillis, long windowLengthMillis, String tag, OnAlarmListener listener, Handler targetHandler)",
    "returnType" : "void",
    "comment" : "\n     * Direct callback version of {@link #setWindow(int, long, long, PendingIntent)}.  Rather\n     * than supplying a PendingIntent to be sent when the alarm time is reached, this variant\n     * supplies an {@link OnAlarmListener} instance that will be invoked at that time.\n     * <p>\n     * The OnAlarmListener {@link OnAlarmListener#onAlarm() onAlarm()} method will be\n     * invoked via the specified target Handler, or on the application's main looper\n     * if {@code null} is passed as the {@code targetHandler} parameter.\n     ",
    "links" : [ "#setWindow(int", "#onAlarm()", "OnAlarmListener" ]
  }, {
    "name" : "public void setExact(@AlarmType int type, long triggerAtMillis, PendingIntent operation)",
    "returnType" : "void",
    "comment" : "\n     * Schedule an alarm to be delivered precisely at the stated time.\n     *\n     * <p>\n     * This method is like {@link #set(int, long, PendingIntent)}, but does not permit\n     * the OS to adjust the delivery time.  The alarm will be delivered as nearly as\n     * possible to the requested trigger time.\n     *\n     * <p>\n     * <b>Note:</b> only alarms for which there is a strong demand for exact-time\n     * delivery (such as an alarm clock ringing at the requested time) should be\n     * scheduled as exact.  Applications are strongly discouraged from using exact\n     * alarms unnecessarily as they reduce the OS's ability to minimize battery use.\n     *\n     * @param type type of alarm.\n     * @param triggerAtMillis time in milliseconds that the alarm should go\n     *        off, using the appropriate clock (depending on the alarm type).\n     * @param operation Action to perform when the alarm goes off;\n     *        typically comes from {@link PendingIntent#getBroadcast\n     *        IntentSender.getBroadcast()}.\n     *\n     * @see #set\n     * @see #setRepeating\n     * @see #setWindow\n     * @see #cancel\n     * @see android.content.Context#sendBroadcast\n     * @see android.content.Context#registerReceiver\n     * @see android.content.Intent#filterEquals\n     * @see #ELAPSED_REALTIME\n     * @see #ELAPSED_REALTIME_WAKEUP\n     * @see #RTC\n     * @see #RTC_WAKEUP\n     ",
    "links" : [ "android.app.PendingIntent#getBroadcastIntentSender.getBroadcast()", "#set(int" ]
  }, {
    "name" : "public void setExact(@AlarmType int type, long triggerAtMillis, String tag, OnAlarmListener listener, Handler targetHandler)",
    "returnType" : "void",
    "comment" : "\n     * Direct callback version of {@link #setExact(int, long, PendingIntent)}.  Rather\n     * than supplying a PendingIntent to be sent when the alarm time is reached, this variant\n     * supplies an {@link OnAlarmListener} instance that will be invoked at that time.\n     * <p>\n     * The OnAlarmListener's {@link OnAlarmListener#onAlarm() onAlarm()} method will be\n     * invoked via the specified target Handler, or on the application's main looper\n     * if {@code null} is passed as the {@code targetHandler} parameter.\n     ",
    "links" : [ "#onAlarm()", "OnAlarmListener", "#setExact(int" ]
  }, {
    "name" : "public void setIdleUntil(@AlarmType int type, long triggerAtMillis, String tag, OnAlarmListener listener, Handler targetHandler)",
    "returnType" : "void",
    "comment" : "\n     * Schedule an idle-until alarm, which will keep the alarm manager idle until\n     * the given time.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAlarmClock(AlarmClockInfo info, PendingIntent operation)",
    "returnType" : "void",
    "comment" : "\n     * Schedule an alarm that represents an alarm clock, which will be used to notify the user\n     * when it goes off.  The expectation is that when this alarm triggers, the application will\n     * further wake up the device to tell the user about the alarm -- turning on the screen,\n     * playing a sound, vibrating, etc.  As such, the system will typically also use the\n     * information supplied here to tell the user about this upcoming alarm if appropriate.\n     *\n     * <p>Due to the nature of this kind of alarm, similar to {@link #setExactAndAllowWhileIdle},\n     * these alarms will be allowed to trigger even if the system is in a low-power idle\n     * (a.k.a. doze) mode.  The system may also do some prep-work when it sees that such an\n     * alarm coming up, to reduce the amount of background work that could happen if this\n     * causes the device to fully wake up -- this is to avoid situations such as a large number\n     * of devices having an alarm set at the same time in the morning, all waking up at that\n     * time and suddenly swamping the network with pending background work.  As such, these\n     * types of alarms can be extremely expensive on battery use and should only be used for\n     * their intended purpose.</p>\n     *\n     * <p>\n     * This method is like {@link #setExact(int, long, PendingIntent)}, but implies\n     * {@link #RTC_WAKEUP}.\n     *\n     * @param info\n     * @param operation Action to perform when the alarm goes off;\n     *        typically comes from {@link PendingIntent#getBroadcast\n     *        IntentSender.getBroadcast()}.\n     *\n     * @see #set\n     * @see #setRepeating\n     * @see #setWindow\n     * @see #setExact\n     * @see #cancel\n     * @see #getNextAlarmClock()\n     * @see android.content.Context#sendBroadcast\n     * @see android.content.Context#registerReceiver\n     * @see android.content.Intent#filterEquals\n     ",
    "links" : [ "android.app.PendingIntent#getBroadcastIntentSender.getBroadcast()", "#setExactAndAllowWhileIdle", "#RTC_WAKEUP", "#setExact(int" ]
  }, {
    "name" : "public void set(@AlarmType int type, long triggerAtMillis, long windowMillis, long intervalMillis, PendingIntent operation, WorkSource workSource)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void set(@AlarmType int type, long triggerAtMillis, long windowMillis, long intervalMillis, String tag, OnAlarmListener listener, Handler targetHandler, WorkSource workSource)",
    "returnType" : "void",
    "comment" : "\n     * Direct callback version of {@link #set(int, long, long, long, PendingIntent, WorkSource)}.\n     * Note that repeating alarms must use the PendingIntent variant, not an OnAlarmListener.\n     * <p>\n     * The OnAlarmListener's {@link OnAlarmListener#onAlarm() onAlarm()} method will be\n     * invoked via the specified target Handler, or on the application's main looper\n     * if {@code null} is passed as the {@code targetHandler} parameter.\n     *\n     * @hide\n     ",
    "links" : [ "#set(int", "#onAlarm()" ]
  }, {
    "name" : "public void set(@AlarmType int type, long triggerAtMillis, long windowMillis, long intervalMillis, OnAlarmListener listener, Handler targetHandler, WorkSource workSource)",
    "returnType" : "void",
    "comment" : "\n     * Direct callback version of {@link #set(int, long, long, long, PendingIntent, WorkSource)}.\n     * Note that repeating alarms must use the PendingIntent variant, not an OnAlarmListener.\n     * <p>\n     * The OnAlarmListener's {@link OnAlarmListener#onAlarm() onAlarm()} method will be\n     * invoked via the specified target Handler, or on the application's main looper\n     * if {@code null} is passed as the {@code targetHandler} parameter.\n     *\n     * @hide\n     ",
    "links" : [ "#set(int", "#onAlarm()" ]
  }, {
    "name" : "private void setImpl(@AlarmType int type, long triggerAtMillis, long windowMillis, long intervalMillis, int flags, PendingIntent operation, final OnAlarmListener listener, String listenerTag, Handler targetHandler, WorkSource workSource, AlarmClockInfo alarmClock)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setInexactRepeating(@AlarmType int type, long triggerAtMillis, long intervalMillis, PendingIntent operation)",
    "returnType" : "void",
    "comment" : "\n     * Schedule a repeating alarm that has inexact trigger time requirements;\n     * for example, an alarm that repeats every hour, but not necessarily at\n     * the top of every hour.  These alarms are more power-efficient than\n     * the strict recurrences traditionally supplied by {@link #setRepeating}, since the\n     * system can adjust alarms' delivery times to cause them to fire simultaneously,\n     * avoiding waking the device from sleep more than necessary.\n     *\n     * <p>Your alarm's first trigger will not be before the requested time,\n     * but it might not occur for almost a full interval after that time.  In\n     * addition, while the overall period of the repeating alarm will be as\n     * requested, the time between any two successive firings of the alarm\n     * may vary.  If your application demands very low jitter, use\n     * one-shot alarms with an appropriate window instead; see {@link\n     * #setWindow(int, long, long, PendingIntent)} and\n     * {@link #setExact(int, long, PendingIntent)}.\n     *\n     * <p class=\"note\">\n     * As of API 19, all repeating alarms are inexact.  Because this method has\n     * been available since API 3, your application can safely call it and be\n     * assured that it will get similar behavior on both current and older versions\n     * of Android.\n     *\n     * @param type type of alarm.\n     * @param triggerAtMillis time in milliseconds that the alarm should first\n     * go off, using the appropriate clock (depending on the alarm type).  This\n     * is inexact: the alarm will not fire before this time, but there may be a\n     * delay of almost an entire alarm interval before the first invocation of\n     * the alarm.\n     * @param intervalMillis interval in milliseconds between subsequent repeats\n     * of the alarm.  Prior to API 19, if this is one of INTERVAL_FIFTEEN_MINUTES,\n     * INTERVAL_HALF_HOUR, INTERVAL_HOUR, INTERVAL_HALF_DAY, or INTERVAL_DAY\n     * then the alarm will be phase-aligned with other alarms to reduce the\n     * number of wakeups.  Otherwise, the alarm will be set as though the\n     * application had called {@link #setRepeating}.  As of API 19, all repeating\n     * alarms will be inexact and subject to batching with other alarms regardless\n     * of their stated repeat interval.\n     * @param operation Action to perform when the alarm goes off;\n     * typically comes from {@link PendingIntent#getBroadcast\n     * IntentSender.getBroadcast()}.\n     *\n     * @see android.os.Handler\n     * @see #set\n     * @see #cancel\n     * @see android.content.Context#sendBroadcast\n     * @see android.content.Context#registerReceiver\n     * @see android.content.Intent#filterEquals\n     * @see #ELAPSED_REALTIME\n     * @see #ELAPSED_REALTIME_WAKEUP\n     * @see #RTC\n     * @see #RTC_WAKEUP\n     * @see #INTERVAL_FIFTEEN_MINUTES\n     * @see #INTERVAL_HALF_HOUR\n     * @see #INTERVAL_HOUR\n     * @see #INTERVAL_HALF_DAY\n     * @see #INTERVAL_DAY\n     ",
    "links" : [ "android.app.PendingIntent#getBroadcastIntentSender.getBroadcast()", "#setWindow(int", "#setRepeating", "#setExact(int" ]
  }, {
    "name" : "public void setAndAllowWhileIdle(@AlarmType int type, long triggerAtMillis, PendingIntent operation)",
    "returnType" : "void",
    "comment" : "\n     * Like {@link #set(int, long, PendingIntent)}, but this alarm will be allowed to execute\n     * even when the system is in low-power idle (a.k.a. doze) modes.  This type of alarm must\n     * <b>only</b> be used for situations where it is actually required that the alarm go off while\n     * in idle -- a reasonable example would be for a calendar notification that should make a\n     * sound so the user is aware of it.  When the alarm is dispatched, the app will also be\n     * added to the system's temporary whitelist for approximately 10 seconds to allow that\n     * application to acquire further wake locks in which to complete its work.</p>\n     *\n     * <p>These alarms can significantly impact the power use\n     * of the device when idle (and thus cause significant battery blame to the app scheduling\n     * them), so they should be used with care.  To reduce abuse, there are restrictions on how\n     * frequently these alarms will go off for a particular application.\n     * Under normal system operation, it will not dispatch these\n     * alarms more than about every minute (at which point every such pending alarm is\n     * dispatched); when in low-power idle modes this duration may be significantly longer,\n     * such as 15 minutes.</p>\n     *\n     * <p>Unlike other alarms, the system is free to reschedule this type of alarm to happen\n     * out of order with any other alarms, even those from the same app.  This will clearly happen\n     * when the device is idle (since this alarm can go off while idle, when any other alarms\n     * from the app will be held until later), but may also happen even when not idle.</p>\n     *\n     * <p>Regardless of the app's target SDK version, this call always allows batching of the\n     * alarm.</p>\n     *\n     * @param type type of alarm.\n     * @param triggerAtMillis time in milliseconds that the alarm should go\n     * off, using the appropriate clock (depending on the alarm type).\n     * @param operation Action to perform when the alarm goes off;\n     * typically comes from {@link PendingIntent#getBroadcast\n     * IntentSender.getBroadcast()}.\n     *\n     * @see #set(int, long, PendingIntent)\n     * @see #setExactAndAllowWhileIdle\n     * @see #cancel\n     * @see android.content.Context#sendBroadcast\n     * @see android.content.Context#registerReceiver\n     * @see android.content.Intent#filterEquals\n     * @see #ELAPSED_REALTIME\n     * @see #ELAPSED_REALTIME_WAKEUP\n     * @see #RTC\n     * @see #RTC_WAKEUP\n     ",
    "links" : [ "android.app.PendingIntent#getBroadcastIntentSender.getBroadcast()", "#set(int" ]
  }, {
    "name" : "public void setExactAndAllowWhileIdle(@AlarmType int type, long triggerAtMillis, PendingIntent operation)",
    "returnType" : "void",
    "comment" : "\n     * Like {@link #setExact(int, long, PendingIntent)}, but this alarm will be allowed to execute\n     * even when the system is in low-power idle modes.  If you don't need exact scheduling of\n     * the alarm but still need to execute while idle, consider using\n     * {@link #setAndAllowWhileIdle}.  This type of alarm must <b>only</b>\n     * be used for situations where it is actually required that the alarm go off while in\n     * idle -- a reasonable example would be for a calendar notification that should make a\n     * sound so the user is aware of it.  When the alarm is dispatched, the app will also be\n     * added to the system's temporary whitelist for approximately 10 seconds to allow that\n     * application to acquire further wake locks in which to complete its work.</p>\n     *\n     * <p>These alarms can significantly impact the power use\n     * of the device when idle (and thus cause significant battery blame to the app scheduling\n     * them), so they should be used with care.  To reduce abuse, there are restrictions on how\n     * frequently these alarms will go off for a particular application.\n     * Under normal system operation, it will not dispatch these\n     * alarms more than about every minute (at which point every such pending alarm is\n     * dispatched); when in low-power idle modes this duration may be significantly longer,\n     * such as 15 minutes.</p>\n     *\n     * <p>Unlike other alarms, the system is free to reschedule this type of alarm to happen\n     * out of order with any other alarms, even those from the same app.  This will clearly happen\n     * when the device is idle (since this alarm can go off while idle, when any other alarms\n     * from the app will be held until later), but may also happen even when not idle.\n     * Note that the OS will allow itself more flexibility for scheduling these alarms than\n     * regular exact alarms, since the application has opted into this behavior.  When the\n     * device is idle it may take even more liberties with scheduling in order to optimize\n     * for battery life.</p>\n     *\n     * @param type type of alarm.\n     * @param triggerAtMillis time in milliseconds that the alarm should go\n     *        off, using the appropriate clock (depending on the alarm type).\n     * @param operation Action to perform when the alarm goes off;\n     *        typically comes from {@link PendingIntent#getBroadcast\n     *        IntentSender.getBroadcast()}.\n     *\n     * @see #set\n     * @see #setRepeating\n     * @see #setWindow\n     * @see #cancel\n     * @see android.content.Context#sendBroadcast\n     * @see android.content.Context#registerReceiver\n     * @see android.content.Intent#filterEquals\n     * @see #ELAPSED_REALTIME\n     * @see #ELAPSED_REALTIME_WAKEUP\n     * @see #RTC\n     * @see #RTC_WAKEUP\n     ",
    "links" : [ "android.app.PendingIntent#getBroadcastIntentSender.getBroadcast()", "#setAndAllowWhileIdle", "#setExact(int" ]
  }, {
    "name" : "public void cancel(PendingIntent operation)",
    "returnType" : "void",
    "comment" : "\n     * Remove any alarms with a matching {@link Intent}.\n     * Any alarm, of any type, whose Intent matches this one (as defined by\n     * {@link Intent#filterEquals}), will be canceled.\n     *\n     * @param operation IntentSender which matches a previously added\n     * IntentSender. This parameter must not be {@code null}.\n     *\n     * @see #set\n     ",
    "links" : [ "android.content.Intent#filterEquals", "android.content.Intent" ]
  }, {
    "name" : "public void cancel(OnAlarmListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Remove any alarm scheduled to be delivered to the given {@link OnAlarmListener}.\n     *\n     * @param listener OnAlarmListener instance that is the target of a currently-set alarm.\n     ",
    "links" : [ "OnAlarmListener" ]
  }, {
    "name" : "public void setTime(long millis)",
    "returnType" : "void",
    "comment" : "\n     * Set the system wall clock time.\n     * Requires the permission android.permission.SET_TIME.\n     *\n     * @param millis time in milliseconds since the Epoch\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTimeZone(String timeZone)",
    "returnType" : "void",
    "comment" : "\n     * Sets the system's persistent default time zone. This is the time zone for all apps, even\n     * after a reboot. Use {@link java.util.TimeZone#setDefault} if you just want to change the\n     * time zone within your app, and even then prefer to pass an explicit\n     * {@link java.util.TimeZone} to APIs that require it rather than changing the time zone for\n     * all threads.\n     *\n     * <p> On android M and above, it is an error to pass in a non-Olson timezone to this\n     * function. Note that this is a bad idea on all Android releases because POSIX and\n     * the {@code TimeZone} class have opposite interpretations of {@code '+'} and {@code '-'}\n     * in the same non-Olson ID.\n     *\n     * @param timeZone one of the Olson ids from the list returned by\n     *     {@link java.util.TimeZone#getAvailableIDs}\n     ",
    "links" : [ "java.util.TimeZone", "java.util.TimeZone#getAvailableIDs", "java.util.TimeZone#setDefault" ]
  }, {
    "name" : "public long getNextWakeFromIdleTime()",
    "returnType" : "long",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public AlarmClockInfo getNextAlarmClock()",
    "returnType" : "AlarmClockInfo",
    "comment" : "\n     * Gets information about the next alarm clock currently scheduled.\n     *\n     * The alarm clocks considered are those scheduled by any application\n     * using the {@link #setAlarmClock} method.\n     *\n     * @return An {@link AlarmClockInfo} object describing the next upcoming alarm\n     *   clock event that will occur.  If there are no alarm clock events currently\n     *   scheduled, this method will return {@code null}.\n     *\n     * @see #setAlarmClock\n     * @see AlarmClockInfo\n     * @see #ACTION_NEXT_ALARM_CLOCK_CHANGED\n     ",
    "links" : [ "#setAlarmClock", "AlarmClockInfo" ]
  }, {
    "name" : "public AlarmClockInfo getNextAlarmClock(int userId)",
    "returnType" : "AlarmClockInfo",
    "comment" : "\n     * Gets information about the next alarm clock currently scheduled.\n     *\n     * The alarm clocks considered are those scheduled by any application\n     * using the {@link #setAlarmClock} method within the given user.\n     *\n     * @return An {@link AlarmClockInfo} object describing the next upcoming alarm\n     *   clock event that will occur within the given user.  If there are no alarm clock\n     *   events currently scheduled in that user, this method will return {@code null}.\n     *\n     * @see #setAlarmClock\n     * @see AlarmClockInfo\n     * @see #ACTION_NEXT_ALARM_CLOCK_CHANGED\n     *\n     * @hide\n     ",
    "links" : [ "#setAlarmClock", "AlarmClockInfo" ]
  } ],
  "variableNames" : [ "TAG", "RTC_WAKEUP", "RTC", "ELAPSED_REALTIME_WAKEUP", "ELAPSED_REALTIME", "ACTION_NEXT_ALARM_CLOCK_CHANGED", "WINDOW_EXACT", "WINDOW_HEURISTIC", "FLAG_STANDALONE", "FLAG_WAKE_FROM_IDLE", "FLAG_ALLOW_WHILE_IDLE", "FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED", "FLAG_IDLE_UNTIL", "mService", "mContext", "mPackageName", "mAlwaysExact", "mTargetSdkVersion", "mMainThreadHandler", "sWrappers", "INTERVAL_FIFTEEN_MINUTES", "INTERVAL_HALF_HOUR", "INTERVAL_HOUR", "INTERVAL_HALF_DAY", "INTERVAL_DAY" ],
  "methodNames" : [ "private long legacyExactLength()", "public void set(@AlarmType int type, long triggerAtMillis, PendingIntent operation)", "public void set(@AlarmType int type, long triggerAtMillis, String tag, OnAlarmListener listener, Handler targetHandler)", "public void setRepeating(@AlarmType int type, long triggerAtMillis, long intervalMillis, PendingIntent operation)", "public void setWindow(@AlarmType int type, long windowStartMillis, long windowLengthMillis, PendingIntent operation)", "public void setWindow(@AlarmType int type, long windowStartMillis, long windowLengthMillis, String tag, OnAlarmListener listener, Handler targetHandler)", "public void setExact(@AlarmType int type, long triggerAtMillis, PendingIntent operation)", "public void setExact(@AlarmType int type, long triggerAtMillis, String tag, OnAlarmListener listener, Handler targetHandler)", "public void setIdleUntil(@AlarmType int type, long triggerAtMillis, String tag, OnAlarmListener listener, Handler targetHandler)", "public void setAlarmClock(AlarmClockInfo info, PendingIntent operation)", "public void set(@AlarmType int type, long triggerAtMillis, long windowMillis, long intervalMillis, PendingIntent operation, WorkSource workSource)", "public void set(@AlarmType int type, long triggerAtMillis, long windowMillis, long intervalMillis, String tag, OnAlarmListener listener, Handler targetHandler, WorkSource workSource)", "public void set(@AlarmType int type, long triggerAtMillis, long windowMillis, long intervalMillis, OnAlarmListener listener, Handler targetHandler, WorkSource workSource)", "private void setImpl(@AlarmType int type, long triggerAtMillis, long windowMillis, long intervalMillis, int flags, PendingIntent operation, final OnAlarmListener listener, String listenerTag, Handler targetHandler, WorkSource workSource, AlarmClockInfo alarmClock)", "public void setInexactRepeating(@AlarmType int type, long triggerAtMillis, long intervalMillis, PendingIntent operation)", "public void setAndAllowWhileIdle(@AlarmType int type, long triggerAtMillis, PendingIntent operation)", "public void setExactAndAllowWhileIdle(@AlarmType int type, long triggerAtMillis, PendingIntent operation)", "public void cancel(PendingIntent operation)", "public void cancel(OnAlarmListener listener)", "public void setTime(long millis)", "public void setTimeZone(String timeZone)", "public long getNextWakeFromIdleTime()", "public AlarmClockInfo getNextAlarmClock()", "public AlarmClockInfo getNextAlarmClock(int userId)" ]
}