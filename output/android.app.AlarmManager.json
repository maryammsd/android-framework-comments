{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/app/AlarmManager.java",
  "packageName" : "android.app",
  "className" : "AlarmManager",
  "comment" : "\n * This class provides access to the system alarm services.  These allow you\n * to schedule your application to be run at some point in the future.  When\n * an alarm goes off, the {@link Intent} that had been registered for it\n * is broadcast by the system, automatically starting the target application\n * if it is not already running.  Registered alarms are retained while the\n * device is asleep (and can optionally wake the device up if they go off\n * during that time), but will be cleared if it is turned off and rebooted.\n *\n * <p>The Alarm Manager holds a CPU wake lock as long as the alarm receiver's\n * onReceive() method is executing. This guarantees that the phone will not sleep\n * until you have finished handling the broadcast. Once onReceive() returns, the\n * Alarm Manager releases this wake lock. This means that the phone will in some\n * cases sleep as soon as your onReceive() method completes.  If your alarm receiver\n * called {@link android.content.Context#startService Context.startService()}, it\n * is possible that the phone will sleep before the requested service is launched.\n * To prevent this, your BroadcastReceiver and Service will need to implement a\n * separate wake lock policy to ensure that the phone continues running until the\n * service becomes available.\n *\n * <p><b>Note: The Alarm Manager is intended for cases where you want to have\n * your application code run at a specific time, even if your application is\n * not currently running.  For normal timing operations (ticks, timeouts,\n * etc) it is easier and much more efficient to use\n * {@link android.os.Handler}.</b>\n *\n * <p class=\"caution\"><strong>Note:</strong> Beginning with API 19\n * ({@link android.os.Build.VERSION_CODES#KITKAT}) alarm delivery is inexact:\n * the OS will shift alarms in order to minimize wakeups and battery use.  There are\n * new APIs to support applications which need strict delivery guarantees; see\n * {@link #setWindow(int, long, long, PendingIntent)} and\n * {@link #setExact(int, long, PendingIntent)}.  Applications whose {@code targetSdkVersion}\n * is earlier than API 19 will continue to see the previous behavior in which all\n * alarms are delivered exactly when requested.\n ",
  "links" : [ "android.content.Context#startService", "#setWindow(int", "android.os.Handler", "android.content.Intent", "android.os.Build.VERSION_CODES#KITKAT", "#setExact(int" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "GENERATED_TAG_PREFIX",
    "type" : "String",
    "comment" : "\n     * Prefix used by {{@link #makeTag(long, WorkSource)}} to make a tag on behalf of the caller\n     * when the {@link #set(int, long, long, long, OnAlarmListener, Handler, WorkSource)} API is\n     * used. This prefix is a unique sequence of characters to differentiate with other tags that\n     * apps may provide to other APIs that accept a listener callback.\n     ",
    "links" : [ "#set(int", "#makeTag(long" ]
  }, {
    "name" : "RTC_WAKEUP",
    "type" : "int",
    "comment" : "\n     * Alarm time in {@link System#currentTimeMillis System.currentTimeMillis()}\n     * (wall clock time in UTC), which will wake up the device when\n     * it goes off.\n     ",
    "links" : [ "#currentTimeMillis" ]
  }, {
    "name" : "RTC",
    "type" : "int",
    "comment" : "\n     * Alarm time in {@link System#currentTimeMillis System.currentTimeMillis()}\n     * (wall clock time in UTC).  This alarm does not wake the\n     * device up; if it goes off while the device is asleep, it will not be\n     * delivered until the next time the device wakes up.\n     ",
    "links" : [ "#currentTimeMillis" ]
  }, {
    "name" : "ELAPSED_REALTIME_WAKEUP",
    "type" : "int",
    "comment" : "\n     * Alarm time in {@link android.os.SystemClock#elapsedRealtime\n     * SystemClock.elapsedRealtime()} (time since boot, including sleep),\n     * which will wake up the device when it goes off.\n     ",
    "links" : [ "android.os.SystemClock#elapsedRealtimeSystemClock.elapsedRealtime()" ]
  }, {
    "name" : "ELAPSED_REALTIME",
    "type" : "int",
    "comment" : "\n     * Alarm time in {@link android.os.SystemClock#elapsedRealtime\n     * SystemClock.elapsedRealtime()} (time since boot, including sleep).\n     * This alarm does not wake the device up; if it goes off while the device\n     * is asleep, it will not be delivered until the next time the device\n     * wakes up.\n     ",
    "links" : [ "android.os.SystemClock#elapsedRealtimeSystemClock.elapsedRealtime()" ]
  }, {
    "name" : "ACTION_NEXT_ALARM_CLOCK_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Sent after the value returned by\n     * {@link #getNextAlarmClock()} has changed.\n     *\n     * <p class=\"note\">This is a protected intent that can only be sent by the system.\n     * It is only sent to registered receivers.</p>\n     ",
    "links" : [ "#getNextAlarmClock()" ]
  }, {
    "name" : "ACTION_SCHEDULE_EXACT_ALARM_PERMISSION_STATE_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: An app is granted the\n     * {@link android.Manifest.permission#SCHEDULE_EXACT_ALARM} permission.\n     *\n     * <p>When the user revokes the {@link android.Manifest.permission#SCHEDULE_EXACT_ALARM}\n     * permission, all alarms scheduled with\n     * {@link #setExact}, {@link #setExactAndAllowWhileIdle} and\n     * {@link #setAlarmClock(AlarmClockInfo, PendingIntent)} will be deleted.\n     *\n     * <p>When the user grants the {@link android.Manifest.permission#SCHEDULE_EXACT_ALARM},\n     * this broadcast will be sent. Applications can reschedule all the necessary alarms when\n     * receiving it.\n     *\n     * <p>This broadcast will <em>not</em> be sent when the user revokes the permission.\n     *\n     * <p><em>Note:</em>\n     * Applications are still required to check {@link #canScheduleExactAlarms()}\n     * before using the above APIs after receiving this broadcast,\n     * because it's possible that the permission is already revoked again by the time\n     * applications receive this broadcast.\n     *\n     * <p>This broadcast will be sent to both runtime receivers and manifest receivers.\n     *\n     * <p>This broadcast is sent as a foreground broadcast.\n     * See {@link android.content.Intent#FLAG_RECEIVER_FOREGROUND}.\n     *\n     * <p>When an application receives this broadcast, it's allowed to start a foreground service.\n     ",
    "links" : [ "#setExactAndAllowWhileIdle", "#setAlarmClock(AlarmClockInfo", "#canScheduleExactAlarms()", "android.Manifest.permission#SCHEDULE_EXACT_ALARM", "#setExact", "android.content.Intent#FLAG_RECEIVER_FOREGROUND" ]
  }, {
    "name" : "WINDOW_EXACT",
    "type" : "long",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "WINDOW_HEURISTIC",
    "type" : "long",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "FLAG_STANDALONE",
    "type" : "int",
    "comment" : "\n     * Flag for alarms: this is to be a stand-alone alarm, that should not be batched with\n     * other alarms.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_WAKE_FROM_IDLE",
    "type" : "int",
    "comment" : "\n     * Flag for alarms: this alarm would like to wake the device even if it is idle.  This\n     * is, for example, an alarm for an alarm clock.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_ALLOW_WHILE_IDLE",
    "type" : "int",
    "comment" : "\n     * Flag for alarms: this alarm would like to still execute even if the device is\n     * idle.  This won't bring the device out of idle, just allow this specific alarm to\n     * run.  Note that this means the actual time this alarm goes off can be inconsistent\n     * with the time of non-allow-while-idle alarms (it could go earlier than the time\n     * requested by another alarm).\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED",
    "type" : "int",
    "comment" : "\n     * Flag for alarms: same as {@link #FLAG_ALLOW_WHILE_IDLE}, but doesn't have restrictions\n     * on how frequently it can be scheduled.  Only available (and automatically applied) to\n     * system alarms.\n     *\n     * <p>Note that alarms set with a {@link WorkSource} <b>do not</b> get this flag.\n     *\n     * @hide\n     ",
    "links" : [ "#FLAG_ALLOW_WHILE_IDLE", "android.os.WorkSource" ]
  }, {
    "name" : "FLAG_IDLE_UNTIL",
    "type" : "int",
    "comment" : "\n     * Flag for alarms: this alarm marks the point where we would like to come out of idle\n     * mode.  It may be moved by the alarm manager to match the first wake-from-idle alarm.\n     * Scheduling an alarm with this flag puts the alarm manager in to idle mode, where it\n     * avoids scheduling any further alarms until the marker alarm is executed.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_ALLOW_WHILE_IDLE_COMPAT",
    "type" : "int",
    "comment" : "\n     * Flag for alarms: Used to provide backwards compatibility for apps with targetSdkVersion less\n     * than {@link Build.VERSION_CODES#S}\n     * @hide\n     ",
    "links" : [ "Build.VERSION_CODES#S" ]
  }, {
    "name" : "FLAG_PRIORITIZE",
    "type" : "int",
    "comment" : "\n     * Flag for alarms: Used to mark prioritized alarms. These alarms will get to execute while idle\n     * and can be sent separately from other alarms that may be already due at the time.\n     * These alarms can be set via\n     * {@link #setPrioritized(int, long, long, String, Executor, OnAlarmListener)}\n     * @hide\n     ",
    "links" : [ "#setPrioritized(int" ]
  }, {
    "name" : "REQUIRE_EXACT_ALARM_PERMISSION",
    "type" : "long",
    "comment" : "\n     * For apps targeting {@link Build.VERSION_CODES#S} or above, any APIs setting exact alarms,\n     * e.g. {@link #setExact(int, long, PendingIntent)},\n     * {@link #setAlarmClock(AlarmClockInfo, PendingIntent)} and others will require holding a new\n     * permission {@link Manifest.permission#SCHEDULE_EXACT_ALARM}\n     *\n     * @hide\n     ",
    "links" : [ "Manifest.permission#SCHEDULE_EXACT_ALARM", "Build.VERSION_CODES#S", "#setAlarmClock(AlarmClockInfo", "#setExact(int" ]
  }, {
    "name" : "ENFORCE_MINIMUM_WINDOW_ON_INEXACT_ALARMS",
    "type" : "long",
    "comment" : "\n     * For apps targeting {@link Build.VERSION_CODES#S} or above, all inexact alarms will require\n     * to have a minimum window size, expected to be on the order of a few minutes.\n     *\n     * Practically, any alarms requiring smaller windows are the same as exact alarms and should use\n     * the corresponding APIs provided, like {@link #setExact(int, long, PendingIntent)}, et al.\n     *\n     * Inexact alarm with shorter windows specified will have their windows elongated by the system.\n     *\n     * @hide\n     ",
    "links" : [ "Build.VERSION_CODES#S", "#setExact(int" ]
  }, {
    "name" : "ENABLE_USE_EXACT_ALARM",
    "type" : "long",
    "comment" : "\n     * For apps targeting {@link Build.VERSION_CODES#TIRAMISU} or above, certain kinds of apps can\n     * use {@link Manifest.permission#USE_EXACT_ALARM} to schedule exact alarms.\n     *\n     * @hide\n     ",
    "links" : [ "Build.VERSION_CODES#TIRAMISU", "Manifest.permission#USE_EXACT_ALARM" ]
  }, {
    "name" : "SCHEDULE_EXACT_ALARM_DENIED_BY_DEFAULT",
    "type" : "long",
    "comment" : "\n     * The permission {@link Manifest.permission#SCHEDULE_EXACT_ALARM} will be denied, unless the\n     * user explicitly allows it from Settings.\n     *\n     * @hide\n     ",
    "links" : [ "Manifest.permission#SCHEDULE_EXACT_ALARM" ]
  }, {
    "name" : "SCHEDULE_EXACT_ALARM_DOES_NOT_ELEVATE_BUCKET",
    "type" : "long",
    "comment" : "\n     * Holding the permission {@link Manifest.permission#SCHEDULE_EXACT_ALARM} will no longer pin\n     * the standby-bucket of the app to\n     * {@link android.app.usage.UsageStatsManager#STANDBY_BUCKET_WORKING_SET} or better.\n     *\n     * @hide\n     ",
    "links" : [ "android.app.usage.UsageStatsManager#STANDBY_BUCKET_WORKING_SET", "Manifest.permission#SCHEDULE_EXACT_ALARM" ]
  }, {
    "name" : "EXACT_LISTENER_ALARMS_DROPPED_ON_CACHED",
    "type" : "long",
    "comment" : "\n     * Exact alarms expecting a {@link OnAlarmListener} callback will be dropped when the calling\n     * app goes into cached state.\n     *\n     * @hide\n     ",
    "links" : [ "OnAlarmListener" ]
  }, {
    "name" : "mService",
    "type" : "IAlarmManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPackageName",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAlwaysExact",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTargetSdkVersion",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMainThreadHandler",
    "type" : "Handler",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sWrappers",
    "type" : "WeakHashMap<OnAlarmListener, WeakReference<ListenerWrapper>>",
    "comment" : "\n     * Tracking of the OnAlarmListener -> ListenerWrapper mapping, for cancel() support.\n     * An entry is guaranteed to stay in this map as long as its ListenerWrapper is held by the\n     * server.\n     *\n     * <p>Access is synchronized on the AlarmManager class object.\n     ",
    "links" : [ ]
  }, {
    "name" : "INTERVAL_FIFTEEN_MINUTES",
    "type" : "long",
    "comment" : "\n     * Available inexact recurrence interval recognized by\n     * {@link #setInexactRepeating(int, long, long, PendingIntent)}\n     * when running on Android prior to API 19.\n     ",
    "links" : [ "#setInexactRepeating(int" ]
  }, {
    "name" : "INTERVAL_HALF_HOUR",
    "type" : "long",
    "comment" : "\n     * Available inexact recurrence interval recognized by\n     * {@link #setInexactRepeating(int, long, long, PendingIntent)}\n     * when running on Android prior to API 19.\n     ",
    "links" : [ "#setInexactRepeating(int" ]
  }, {
    "name" : "INTERVAL_HOUR",
    "type" : "long",
    "comment" : "\n     * Available inexact recurrence interval recognized by\n     * {@link #setInexactRepeating(int, long, long, PendingIntent)}\n     * when running on Android prior to API 19.\n     ",
    "links" : [ "#setInexactRepeating(int" ]
  }, {
    "name" : "INTERVAL_HALF_DAY",
    "type" : "long",
    "comment" : "\n     * Available inexact recurrence interval recognized by\n     * {@link #setInexactRepeating(int, long, long, PendingIntent)}\n     * when running on Android prior to API 19.\n     ",
    "links" : [ "#setInexactRepeating(int" ]
  }, {
    "name" : "INTERVAL_DAY",
    "type" : "long",
    "comment" : "\n     * Available inexact recurrence interval recognized by\n     * {@link #setInexactRepeating(int, long, long, PendingIntent)}\n     * when running on Android prior to API 19.\n     ",
    "links" : [ "#setInexactRepeating(int" ]
  } ],
  "methods" : [ {
    "name" : "private long legacyExactLength()",
    "returnType" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void set(@AlarmType int type, long triggerAtMillis, @NonNull PendingIntent operation)",
    "returnType" : "void",
    "comment" : "\n     * <p>Schedule an alarm.  <b>Note: for timing operations (ticks, timeouts,\n     * etc) it is easier and much more efficient to use {@link android.os.Handler}.</b>\n     * If there is already an alarm scheduled for the same IntentSender, that previous\n     * alarm will first be canceled.\n     *\n     * <p>If the stated trigger time is in the past, the alarm will be triggered\n     * immediately.  If there is already an alarm for this Intent\n     * scheduled (with the equality of two intents being defined by\n     * {@link Intent#filterEquals}), then it will be removed and replaced by\n     * this one.\n     *\n     * <p>\n     * The alarm is an Intent broadcast that goes to a broadcast receiver that\n     * you registered with {@link android.content.Context#registerReceiver}\n     * or through the &lt;receiver&gt; tag in an AndroidManifest.xml file.\n     *\n     * <p>\n     * Alarm intents are delivered with a data extra of type int called\n     * {@link Intent#EXTRA_ALARM_COUNT Intent.EXTRA_ALARM_COUNT} that indicates\n     * how many past alarm events have been accumulated into this intent\n     * broadcast.  Recurring alarms that have gone undelivered because the\n     * phone was asleep may have a count greater than one when delivered.\n     *\n     * <div class=\"note\">\n     * <p>\n     * <b>Note:</b> Beginning in API 19, the trigger time passed to this method\n     * is treated as inexact: the alarm will not be delivered before this time, but\n     * may be deferred and delivered some time later.  The OS will use\n     * this policy in order to \"batch\" alarms together across the entire system,\n     * minimizing the number of times the device needs to \"wake up\" and minimizing\n     * battery use.  In general, alarms scheduled in the near future will not\n     * be deferred as long as alarms scheduled far in the future.\n     *\n     * <p>\n     * With the new batching policy, delivery ordering guarantees are not as\n     * strong as they were previously.  If the application sets multiple alarms,\n     * it is possible that these alarms' <em>actual</em> delivery ordering may not match\n     * the order of their <em>requested</em> delivery times.  If your application has\n     * strong ordering requirements there are other APIs that you can use to get\n     * the necessary behavior; see {@link #setWindow(int, long, long, PendingIntent)}\n     * and {@link #setExact(int, long, PendingIntent)}.\n     *\n     * <p>\n     * Applications whose {@code targetSdkVersion} is before API 19 will\n     * continue to get the previous alarm behavior: all of their scheduled alarms\n     * will be treated as exact.\n     * </div>\n     *\n     * @param type type of alarm.\n     * @param triggerAtMillis time in milliseconds that the alarm should go\n     * off, using the appropriate clock (depending on the alarm type).\n     * @param operation Action to perform when the alarm goes off;\n     * typically comes from {@link PendingIntent#getBroadcast\n     * IntentSender.getBroadcast()}.\n     *\n     * @see android.os.Handler\n     * @see #setExact\n     * @see #setRepeating\n     * @see #setWindow\n     * @see #cancel\n     * @see android.content.Context#sendBroadcast\n     * @see android.content.Context#registerReceiver\n     * @see android.content.Intent#filterEquals\n     * @see #ELAPSED_REALTIME\n     * @see #ELAPSED_REALTIME_WAKEUP\n     * @see #RTC\n     * @see #RTC_WAKEUP\n     ",
    "links" : [ "android.app.PendingIntent#getBroadcastIntentSender.getBroadcast()", "#setWindow(int", "android.content.Intent#EXTRA_ALARM_COUNT", "android.os.Handler", "android.content.Intent#filterEquals", "android.content.Context#registerReceiver", "#setExact(int" ]
  }, {
    "name" : "public void set(@AlarmType int type, long triggerAtMillis, @Nullable String tag, @NonNull OnAlarmListener listener, @Nullable Handler targetHandler)",
    "returnType" : "void",
    "comment" : "\n     * Direct callback version of {@link #set(int, long, PendingIntent)}.  Rather than\n     * supplying a PendingIntent to be sent when the alarm time is reached, this variant\n     * supplies an {@link OnAlarmListener} instance that will be invoked at that time.\n     * <p>\n     * The OnAlarmListener's {@link OnAlarmListener#onAlarm() onAlarm()} method will be\n     * invoked via the specified target Handler, or on the application's main looper\n     * if {@code null} is passed as the {@code targetHandler} parameter.\n     *\n     * @param type type of alarm.\n     * @param triggerAtMillis time in milliseconds that the alarm should go\n     *         off, using the appropriate clock (depending on the alarm type).\n     * @param tag string describing the alarm, used for logging and battery-use\n     *         attribution\n     * @param listener {@link OnAlarmListener} instance whose\n     *         {@link OnAlarmListener#onAlarm() onAlarm()} method will be\n     *         called when the alarm time is reached.  A given OnAlarmListener instance can\n     *         only be the target of a single pending alarm, just as a given PendingIntent\n     *         can only be used with one alarm at a time.\n     * @param targetHandler {@link Handler} on which to execute the listener's onAlarm()\n     *         callback, or {@code null} to run that callback on the main looper.\n     ",
    "links" : [ "#set(int", "#onAlarm()", "android.os.Handler", "OnAlarmListener" ]
  }, {
    "name" : "public void setRepeating(@AlarmType int type, long triggerAtMillis, long intervalMillis, @NonNull PendingIntent operation)",
    "returnType" : "void",
    "comment" : "\n     * Schedule a repeating alarm.  <b>Note: for timing operations (ticks,\n     * timeouts, etc) it is easier and much more efficient to use\n     * {@link android.os.Handler}.</b>  If there is already an alarm scheduled\n     * for the same IntentSender, it will first be canceled.\n     *\n     * <p>Like {@link #set}, except you can also supply a period at which\n     * the alarm will automatically repeat.  This alarm continues\n     * repeating until explicitly removed with {@link #cancel}.  If the stated\n     * trigger time is in the past, the alarm will be triggered immediately, with an\n     * alarm count depending on how far in the past the trigger time is relative\n     * to the repeat interval.\n     *\n     * <p>If an alarm is delayed (by system sleep, for example, for non\n     * _WAKEUP alarm types), a skipped repeat will be delivered as soon as\n     * possible.  After that, future alarms will be delivered according to the\n     * original schedule; they do not drift over time.  For example, if you have\n     * set a recurring alarm for the top of every hour but the phone was asleep\n     * from 7:45 until 8:45, an alarm will be sent as soon as the phone awakens,\n     * then the next alarm will be sent at 9:00.\n     *\n     * <p>If your application wants to allow the delivery times to drift in\n     * order to guarantee that at least a certain time interval always elapses\n     * between alarms, then the approach to take is to use one-time alarms,\n     * scheduling the next one yourself when handling each alarm delivery.\n     *\n     * <p class=\"note\">\n     * <b>Note:</b> as of API 19, all repeating alarms are inexact.  If your\n     * application needs precise delivery times then it must use one-time\n     * exact alarms, rescheduling each time as described above. Legacy applications\n     * whose {@code targetSdkVersion} is earlier than API 19 will continue to have all\n     * of their alarms, including repeating alarms, treated as exact.\n     * <p>Apps targeting {@link Build.VERSION_CODES#S} will need to set the flag\n     * {@link PendingIntent#FLAG_MUTABLE} on the {@link PendingIntent} being used to set this alarm,\n     * if they want the alarm count to be supplied with the key {@link Intent#EXTRA_ALARM_COUNT}.\n     *\n     * @param type type of alarm.\n     * @param triggerAtMillis time in milliseconds that the alarm should first\n     * go off, using the appropriate clock (depending on the alarm type).\n     * @param intervalMillis interval in milliseconds between subsequent repeats\n     * of the alarm.\n     * @param operation Action to perform when the alarm goes off;\n     * typically comes from {@link PendingIntent#getBroadcast\n     * IntentSender.getBroadcast()}.\n     *\n     * @see android.os.Handler\n     * @see #set\n     * @see #setExact\n     * @see #setWindow\n     * @see #cancel\n     * @see android.content.Context#sendBroadcast\n     * @see android.content.Context#registerReceiver\n     * @see android.content.Intent#filterEquals\n     * @see #ELAPSED_REALTIME\n     * @see #ELAPSED_REALTIME_WAKEUP\n     * @see #RTC\n     * @see #RTC_WAKEUP\n     * @see Intent#EXTRA_ALARM_COUNT\n     ",
    "links" : [ "android.app.PendingIntent#getBroadcastIntentSender.getBroadcast()", "android.content.Intent#EXTRA_ALARM_COUNT", "Build.VERSION_CODES#S", "android.os.Handler", "android.app.PendingIntent#FLAG_MUTABLE", "#cancel", "android.app.PendingIntent", "#set" ]
  }, {
    "name" : "public void setWindow(@AlarmType int type, long windowStartMillis, long windowLengthMillis, @NonNull PendingIntent operation)",
    "returnType" : "void",
    "comment" : "\n     * Schedule an alarm to be delivered within a given window of time.  This method\n     * is similar to {@link #set(int, long, PendingIntent)}, but allows the\n     * application to precisely control the degree to which its delivery might be\n     * adjusted by the OS. This method allows an application to take advantage of the\n     * battery optimizations that arise from delivery batching even when it has\n     * modest timeliness requirements for its alarms.\n     *\n     * <p>\n     * Note: Starting with API {@link Build.VERSION_CODES#S}, apps should not pass in a window of\n     * less than 10 minutes. The system will try its best to accommodate smaller windows if the\n     * alarm is supposed to fire in the near future, but there are no guarantees and the app should\n     * expect any window smaller than 10 minutes to get elongated to 10 minutes.\n     *\n     * <p>\n     * This method can also be used to achieve strict ordering guarantees among\n     * multiple alarms by ensuring that the windows requested for each alarm do\n     * not intersect.\n     *\n     * <p>\n     * When precise delivery is not required, applications should use the standard\n     * {@link #set(int, long, PendingIntent)} method.  This will give the OS the most\n     * flexibility to minimize wakeups and battery use.  For alarms that must be delivered\n     * at precisely-specified times with no acceptable variation, applications can use\n     * {@link #setExact(int, long, PendingIntent)}.\n     *\n     * @param type type of alarm.\n     * @param windowStartMillis The earliest time, in milliseconds, that the alarm should\n     *        be delivered, expressed in the appropriate clock's units (depending on the alarm\n     *        type).\n     * @param windowLengthMillis The length of the requested delivery window,\n     *        in milliseconds.  The alarm will be delivered no later than this many\n     *        milliseconds after {@code windowStartMillis}.  Note that this parameter\n     *        is a <i>duration,</i> not the timestamp of the end of the window.\n     * @param operation Action to perform when the alarm goes off;\n     *        typically comes from {@link PendingIntent#getBroadcast\n     *        IntentSender.getBroadcast()}.\n     *\n     * @see #set\n     * @see #setExact\n     * @see #setRepeating\n     * @see #cancel\n     * @see android.content.Context#sendBroadcast\n     * @see android.content.Context#registerReceiver\n     * @see android.content.Intent#filterEquals\n     * @see #ELAPSED_REALTIME\n     * @see #ELAPSED_REALTIME_WAKEUP\n     * @see #RTC\n     * @see #RTC_WAKEUP\n     ",
    "links" : [ "android.app.PendingIntent#getBroadcastIntentSender.getBroadcast()", "#set(int", "Build.VERSION_CODES#S", "#setExact(int" ]
  }, {
    "name" : "public void setWindow(@AlarmType int type, long windowStartMillis, long windowLengthMillis, @Nullable String tag, @NonNull OnAlarmListener listener, @Nullable Handler targetHandler)",
    "returnType" : "void",
    "comment" : "\n     * Direct callback version of {@link #setWindow(int, long, long, PendingIntent)}.  Rather\n     * than supplying a PendingIntent to be sent when the alarm time is reached, this variant\n     * supplies an {@link OnAlarmListener} instance that will be invoked at that time.\n     * <p>\n     * The OnAlarmListener {@link OnAlarmListener#onAlarm() onAlarm()} method will be\n     * invoked via the specified target Handler, or on the application's main looper\n     * if {@code null} is passed as the {@code targetHandler} parameter.\n     *\n     * <p>\n     * Note: Starting with API {@link Build.VERSION_CODES#S}, apps should not pass in a window of\n     * less than 10 minutes. The system will try its best to accommodate smaller windows if the\n     * alarm is supposed to fire in the near future, but there are no guarantees and the app should\n     * expect any window smaller than 10 minutes to get elongated to 10 minutes.\n     *\n     * @see #setWindow(int, long, long, PendingIntent)\n     ",
    "links" : [ "#setWindow(int", "#onAlarm()", "Build.VERSION_CODES#S", "OnAlarmListener" ]
  }, {
    "name" : "public void setWindow(@AlarmType int type, long windowStartMillis, long windowLengthMillis, @Nullable String tag, @NonNull Executor executor, @NonNull OnAlarmListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Direct callback version of {@link #setWindow(int, long, long, PendingIntent)}.  Rather\n     * than supplying a PendingIntent to be sent when the alarm time is reached, this variant\n     * supplies an {@link OnAlarmListener} instance that will be invoked at that time.\n     * <p>\n     * The OnAlarmListener {@link OnAlarmListener#onAlarm() onAlarm()} method will be\n     * invoked via the specified target Executor.\n     *\n     * <p>\n     * Note: Starting with API {@link Build.VERSION_CODES#S}, apps should not pass in a window of\n     * less than 10 minutes. The system will try its best to accommodate smaller windows if the\n     * alarm is supposed to fire in the near future, but there are no guarantees and the app should\n     * expect any window smaller than 10 minutes to get elongated to 10 minutes.\n     *\n     * @see #setWindow(int, long, long, PendingIntent)\n     ",
    "links" : [ "#setWindow(int", "#onAlarm()", "Build.VERSION_CODES#S", "OnAlarmListener" ]
  }, {
    "name" : "public void setWindow(@AlarmType int type, long windowStartMillis, long windowLengthMillis, @Nullable String tag, @NonNull Executor executor, @Nullable WorkSource workSource, @NonNull OnAlarmListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Direct callback version of {@link #setWindow(int, long, long, PendingIntent)}.  Rather\n     * than supplying a PendingIntent to be sent when the alarm time is reached, this variant\n     * supplies an {@link OnAlarmListener} instance that will be invoked at that time.\n     * <p>\n     * The OnAlarmListener's {@link OnAlarmListener#onAlarm() onAlarm()} method will be\n     * invoked via the specified target Executor.\n     *\n     * <p>\n     * Note: Starting with API {@link Build.VERSION_CODES#S}, apps should not pass in a window of\n     * less than 10 minutes. The system will try its best to accommodate smaller windows if the\n     * alarm is supposed to fire in the near future, but there are no guarantees and the app should\n     * expect any window smaller than 10 minutes to get elongated to 10 minutes.\n     *\n     * @see #setWindow(int, long, long, PendingIntent)\n     *\n     * @hide\n     ",
    "links" : [ "#setWindow(int", "#onAlarm()", "Build.VERSION_CODES#S", "OnAlarmListener" ]
  }, {
    "name" : "public void setPrioritized(@AlarmType int type, long windowStartMillis, long windowLengthMillis, @Nullable String tag, @NonNull Executor executor, @NonNull OnAlarmListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Schedule an alarm that is prioritized by the system while the device is in power saving modes\n     * such as battery saver and device idle (doze).\n     *\n     * <p>\n     * Apps that use this are not guaranteed to get all alarms as requested during power saving\n     * modes, i.e. the system may still impose restrictions on how frequently these alarms will go\n     * off for a particular application, like requiring a certain minimum duration be elapsed\n     * between consecutive alarms. This duration will be normally be in the order of a few minutes.\n     *\n     * <p>\n     * When the system wakes up to deliver these alarms, it may not deliver any of the other pending\n     * alarms set earlier by the calling app, even the special ones set via\n     * {@link #setAndAllowWhileIdle(int, long, PendingIntent)} or\n     * {@link #setExactAndAllowWhileIdle(int, long, PendingIntent)}. So the caller should not\n     * expect these to arrive in any relative order to its other alarms.\n     *\n     * @param type type of alarm\n     * @param windowStartMillis The earliest time, in milliseconds, that the alarm should\n     *        be delivered, expressed in the appropriate clock's units (depending on the alarm\n     *        type).\n     * @param windowLengthMillis The length of the requested delivery window,\n     *        in milliseconds.  The alarm will be delivered no later than this many\n     *        milliseconds after {@code windowStartMillis}.  Note that this parameter\n     *        is a <i>duration,</i> not the timestamp of the end of the window.\n     * @param tag Optional. A string describing the alarm, used for logging and battery-use\n     *         attribution.\n     * @param listener {@link OnAlarmListener} instance whose\n     *         {@link OnAlarmListener#onAlarm() onAlarm()} method will be\n     *         called when the alarm time is reached.  A given OnAlarmListener instance can\n     *         only be the target of a single pending alarm, just as a given PendingIntent\n     *         can only be used with one alarm at a time.\n     * @param executor {@link Executor} on which to execute the listener's onAlarm()\n     *         callback.\n     * @hide\n     ",
    "links" : [ "#setExactAndAllowWhileIdle(int", "#onAlarm()", "#setAndAllowWhileIdle(int", "OnAlarmListener", "android.os.HandlerExecutor" ]
  }, {
    "name" : "public void setExact(@AlarmType int type, long triggerAtMillis, @NonNull PendingIntent operation)",
    "returnType" : "void",
    "comment" : "\n     * Schedule an alarm to be delivered precisely at the stated time.\n     *\n     * <p>\n     * This method is like {@link #set(int, long, PendingIntent)}, but does not permit\n     * the OS to adjust the delivery time.  The alarm will be delivered as nearly as\n     * possible to the requested trigger time.\n     *\n     * <p>\n     * <b>Note:</b> only alarms for which there is a strong demand for exact-time\n     * delivery (such as an alarm clock ringing at the requested time) should be\n     * scheduled as exact.  Applications are strongly discouraged from using exact\n     * alarms unnecessarily as they reduce the OS's ability to minimize battery use.\n     *\n     * <p class=\"note\"><strong>Note:</strong>\n     * Starting with {@link Build.VERSION_CODES#S}, apps targeting SDK level 31 or higher\n     * need to request the\n     * {@link Manifest.permission#SCHEDULE_EXACT_ALARM SCHEDULE_EXACT_ALARM} permission to use this\n     * API, unless the app is exempt from battery restrictions.\n     * The user and the system can revoke this permission via the special app access screen in\n     * Settings.\n     *\n     * <p class=\"note\"><strong>Note:</strong>\n     * Exact alarms should only be used for user-facing features.\n     * For more details, see <a\n     * href=\"{@docRoot}about/versions/12/behavior-changes-12#exact-alarm-permission\">\n     * Exact alarm permission</a>.\n     *\n     * @param type type of alarm.\n     * @param triggerAtMillis time in milliseconds that the alarm should go\n     *        off, using the appropriate clock (depending on the alarm type).\n     * @param operation Action to perform when the alarm goes off;\n     *        typically comes from {@link PendingIntent#getBroadcast\n     *        IntentSender.getBroadcast()}.\n     *\n     * @see #set\n     * @see #setRepeating\n     * @see #setWindow\n     * @see #cancel\n     * @see android.content.Context#sendBroadcast\n     * @see android.content.Context#registerReceiver\n     * @see android.content.Intent#filterEquals\n     * @see #ELAPSED_REALTIME\n     * @see #ELAPSED_REALTIME_WAKEUP\n     * @see #RTC\n     * @see #RTC_WAKEUP\n     * @see Manifest.permission#SCHEDULE_EXACT_ALARM SCHEDULE_EXACT_ALARM\n     ",
    "links" : [ "android.app.PendingIntent#getBroadcastIntentSender.getBroadcast()", "Manifest.permission#SCHEDULE_EXACT_ALARM", "#set(int", "Build.VERSION_CODES#S" ]
  }, {
    "name" : "public void setExact(@AlarmType int type, long triggerAtMillis, @Nullable String tag, @NonNull OnAlarmListener listener, @Nullable Handler targetHandler)",
    "returnType" : "void",
    "comment" : "\n     * Direct callback version of {@link #setExact(int, long, PendingIntent)}.  Rather\n     * than supplying a PendingIntent to be sent when the alarm time is reached, this variant\n     * supplies an {@link OnAlarmListener} instance that will be invoked at that time.\n     * <p>\n     * The OnAlarmListener's {@link OnAlarmListener#onAlarm() onAlarm()} method will be\n     * invoked via the specified target Handler, or on the application's main looper\n     * if {@code null} is passed as the {@code targetHandler} parameter.\n     * <p>\n     * This API should only be used to set alarms that are relevant in the context of the app's\n     * current lifecycle, as the {@link OnAlarmListener} instance supplied is only valid as long as\n     * the process is alive, and the system can clean up the app process as soon as it is out of\n     * lifecycle. To schedule alarms that fire reliably even after the current lifecycle completes,\n     * and wakes up the app if required, use any of the other scheduling APIs that accept a\n     * {@link PendingIntent} instance.\n     *\n     * <p>\n     * On previous android versions {@link Build.VERSION_CODES#S} and\n     * {@link Build.VERSION_CODES#TIRAMISU}, apps targeting SDK level 31 or higher needed to hold\n     * the {@link Manifest.permission#SCHEDULE_EXACT_ALARM SCHEDULE_EXACT_ALARM} permission to use\n     * this API, unless the app was exempt from battery restrictions.\n     *\n     * <p class=\"note\"><strong>Note:</strong>\n     * Starting with android version {@link Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, the system will\n     * explicitly drop any alarms set via this API when the calling app goes out of lifecycle.\n     *\n     ",
    "links" : [ "Manifest.permission#SCHEDULE_EXACT_ALARM", "#onAlarm()", "Build.VERSION_CODES#S", "Build.VERSION_CODES#TIRAMISU", "OnAlarmListener", "Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.app.PendingIntent", "#setExact(int" ]
  }, {
    "name" : "public void setIdleUntil(@AlarmType int type, long triggerAtMillis, @Nullable String tag, @NonNull OnAlarmListener listener, @Nullable Handler targetHandler)",
    "returnType" : "void",
    "comment" : "\n     * Schedule an idle-until alarm, which will keep the alarm manager idle until\n     * the given time.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAlarmClock(@NonNull AlarmClockInfo info, @NonNull PendingIntent operation)",
    "returnType" : "void",
    "comment" : "\n     * Schedule an alarm that represents an alarm clock, which will be used to notify the user\n     * when it goes off.  The expectation is that when this alarm triggers, the application will\n     * further wake up the device to tell the user about the alarm -- turning on the screen,\n     * playing a sound, vibrating, etc.  As such, the system will typically also use the\n     * information supplied here to tell the user about this upcoming alarm if appropriate.\n     *\n     * <p>Due to the nature of this kind of alarm, similar to {@link #setExactAndAllowWhileIdle},\n     * these alarms will be allowed to trigger even if the system is in a low-power idle\n     * (a.k.a. doze) mode.  The system may also do some prep-work when it sees that such an\n     * alarm coming up, to reduce the amount of background work that could happen if this\n     * causes the device to fully wake up -- this is to avoid situations such as a large number\n     * of devices having an alarm set at the same time in the morning, all waking up at that\n     * time and suddenly swamping the network with pending background work.  As such, these\n     * types of alarms can be extremely expensive on battery use and should only be used for\n     * their intended purpose.</p>\n     *\n     * <p>\n     * This method is like {@link #setExact(int, long, PendingIntent)}, but implies\n     * {@link #RTC_WAKEUP}.\n     *\n     * <p class=\"note\"><strong>Note:</strong>\n     * Starting with {@link Build.VERSION_CODES#S}, apps targeting SDK level 31 or higher\n     * need to request the\n     * {@link Manifest.permission#SCHEDULE_EXACT_ALARM SCHEDULE_EXACT_ALARM} permission to use this\n     * API.\n     * The user and the system can revoke this permission via the special app access screen in\n     * Settings.\n     *\n     * <p class=\"note\"><strong>Note:</strong>\n     * Exact alarms should only be used for user-facing features.\n     * For more details, see <a\n     * href=\"{@docRoot}about/versions/12/behavior-changes-12#exact-alarm-permission\">\n     * Exact alarm permission</a>.\n     *\n     * <p>Alarms scheduled via this API\n     * will be allowed to start a foreground service even if the app is in the background.\n     *\n     * @param info\n     * @param operation Action to perform when the alarm goes off;\n     *        typically comes from {@link PendingIntent#getBroadcast\n     *        IntentSender.getBroadcast()}.\n     *\n     * @see #set\n     * @see #setRepeating\n     * @see #setWindow\n     * @see #setExact\n     * @see #cancel\n     * @see #getNextAlarmClock()\n     * @see android.content.Context#sendBroadcast\n     * @see android.content.Context#registerReceiver\n     * @see android.content.Intent#filterEquals\n     * @see Manifest.permission#SCHEDULE_EXACT_ALARM SCHEDULE_EXACT_ALARM\n     ",
    "links" : [ "android.app.PendingIntent#getBroadcastIntentSender.getBroadcast()", "Manifest.permission#SCHEDULE_EXACT_ALARM", "#setExactAndAllowWhileIdle", "Build.VERSION_CODES#S", "#RTC_WAKEUP", "#setExact(int" ]
  }, {
    "name" : "public void set(@AlarmType int type, long triggerAtMillis, long windowMillis, long intervalMillis, @NonNull PendingIntent operation, @Nullable WorkSource workSource)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void set(@AlarmType int type, long triggerAtMillis, long windowMillis, long intervalMillis, @Nullable String tag, @NonNull OnAlarmListener listener, @Nullable Handler targetHandler, @Nullable WorkSource workSource)",
    "returnType" : "void",
    "comment" : "\n     * Direct callback version of {@link #set(int, long, long, long, PendingIntent, WorkSource)}.\n     * Note that repeating alarms must use the PendingIntent variant, not an OnAlarmListener.\n     * <p>\n     * The OnAlarmListener's {@link OnAlarmListener#onAlarm() onAlarm()} method will be\n     * invoked via the specified target Handler, or on the application's main looper\n     * if {@code null} is passed as the {@code targetHandler} parameter.\n     *\n     * @hide\n     ",
    "links" : [ "#set(int", "#onAlarm()" ]
  }, {
    "name" : "private static String makeTag(long triggerMillis, WorkSource ws)",
    "returnType" : "String",
    "comment" : "\n     * This is only used to make an identifying tag for the deprecated\n     * {@link #set(int, long, long, long, OnAlarmListener, Handler, WorkSource)} API which doesn't\n     * accept a tag. For all other APIs, the tag provided by the app is used, even if it is\n     * {@code null}.\n     ",
    "links" : [ "#set(int" ]
  }, {
    "name" : "public void set(@AlarmType int type, long triggerAtMillis, long windowMillis, long intervalMillis, @NonNull OnAlarmListener listener, @Nullable Handler targetHandler, @Nullable WorkSource workSource)",
    "returnType" : "void",
    "comment" : "\n     * Direct callback version of {@link #set(int, long, long, long, PendingIntent, WorkSource)}.\n     * Note that repeating alarms must use the PendingIntent variant, not an OnAlarmListener.\n     * <p>\n     * The OnAlarmListener's {@link OnAlarmListener#onAlarm() onAlarm()} method will be\n     * invoked via the specified target Handler, or on the application's main looper\n     * if {@code null} is passed as the {@code targetHandler} parameter.\n     *\n     * <p>The behavior of this API when {@code windowMillis < 0} is undefined.\n     *\n     * @deprecated Better alternative APIs exist for setting an alarm with this method:\n     * <ul>\n     *     <li>For alarms with {@code windowMillis > 0}, use\n     *     {@link #setWindow(int, long, long, String, Executor, WorkSource, OnAlarmListener)}</li>\n     *     <li>For alarms with {@code windowMillis = 0}, use\n     *     {@link #setExact(int, long, String, Executor, WorkSource, OnAlarmListener)}</li>\n     * </ul>\n     *\n     * @hide\n     ",
    "links" : [ "#setWindow(int", "#set(int", "#onAlarm()", "#setExact(int" ]
  }, {
    "name" : "public void setExact(@AlarmType int type, long triggerAtMillis, @Nullable String tag, @NonNull Executor executor, @NonNull WorkSource workSource, @NonNull OnAlarmListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Exact version of {@link #set(int, long, long, long, OnAlarmListener, Handler, WorkSource)}.\n     * This equivalent to calling the aforementioned API with {@code windowMillis} and\n     * {@code intervalMillis} set to 0.\n     * One subtle difference is that this API requires {@code workSource} to be non-null. If you\n     * don't want to attribute this alarm to another app for battery consumption, you should use\n     * {@link #setExact(int, long, String, OnAlarmListener, Handler)} instead.\n     *\n     * <p>\n     * Note that on previous Android versions {@link Build.VERSION_CODES#S} and\n     * {@link Build.VERSION_CODES#TIRAMISU}, using this API required you to hold\n     * {@link Manifest.permission#SCHEDULE_EXACT_ALARM}, unless you are on the system's power\n     * allowlist. This can be set, for example, by marking the app as {@code <allow-in-power-save>}\n     * within the system config.\n     *\n     * <p class=\"note\"><strong>Note:</strong>\n     * Starting with android version {@link Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, the system will\n     * explicitly drop any alarms set via this API when the calling app goes out of lifecycle.\n     *\n     * @param type            type of alarm\n     * @param triggerAtMillis The exact time in milliseconds, that the alarm should be delivered,\n     *                        expressed in the appropriate clock's units (depending on the alarm\n     *                        type).\n     * @param listener        {@link OnAlarmListener} instance whose\n     *                        {@link OnAlarmListener#onAlarm() onAlarm()} method will be called when\n     *                        the alarm time is reached.\n     * @param executor        The {@link Executor} on which to execute the listener's onAlarm()\n     *                        callback.\n     * @param tag             Optional. A string tag used to identify this alarm in logs and\n     *                        battery-attribution.\n     * @param workSource      A {@link WorkSource} object to attribute this alarm to the app that\n     *                        requested this work.\n     * @hide\n     ",
    "links" : [ "Manifest.permission#SCHEDULE_EXACT_ALARM", "#set(int", "Build.VERSION_CODES#S", "#onAlarm()", "Build.VERSION_CODES#TIRAMISU", "OnAlarmListener", "Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.os.HandlerExecutor", "android.os.WorkSource", "#setExact(int" ]
  }, {
    "name" : "private void setImpl(@AlarmType int type, long triggerAtMillis, long windowMillis, long intervalMillis, int flags, PendingIntent operation, final OnAlarmListener listener, String listenerTag, Handler targetHandler, WorkSource workSource, AlarmClockInfo alarmClock)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void setImpl(@AlarmType int type, long triggerAtMillis, long windowMillis, long intervalMillis, int flags, PendingIntent operation, final OnAlarmListener listener, String listenerTag, Executor targetExecutor, WorkSource workSource, AlarmClockInfo alarmClock)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setInexactRepeating(@AlarmType int type, long triggerAtMillis, long intervalMillis, @NonNull PendingIntent operation)",
    "returnType" : "void",
    "comment" : "\n     * Schedule a repeating alarm that has inexact trigger time requirements;\n     * for example, an alarm that repeats every hour, but not necessarily at\n     * the top of every hour.  These alarms are more power-efficient than\n     * the strict recurrences traditionally supplied by {@link #setRepeating}, since the\n     * system can adjust alarms' delivery times to cause them to fire simultaneously,\n     * avoiding waking the device from sleep more than necessary.\n     *\n     * <p>Your alarm's first trigger will not be before the requested time,\n     * but it might not occur for almost a full interval after that time.  In\n     * addition, while the overall period of the repeating alarm will be as\n     * requested, the time between any two successive firings of the alarm\n     * may vary.  If your application demands very low jitter, use\n     * one-shot alarms with an appropriate window instead; see {@link\n     * #setWindow(int, long, long, PendingIntent)} and\n     * {@link #setExact(int, long, PendingIntent)}.\n     *\n     * <p class=\"note\">\n     * As of API 19, all repeating alarms are inexact.  Because this method has\n     * been available since API 3, your application can safely call it and be\n     * assured that it will get similar behavior on both current and older versions\n     * of Android.\n     * <p>Apps targeting {@link Build.VERSION_CODES#S} will need to set the flag\n     * {@link PendingIntent#FLAG_MUTABLE} on the {@link PendingIntent} being used to set this alarm,\n     * if they want the alarm count to be supplied with the key {@link Intent#EXTRA_ALARM_COUNT}.\n     *\n     * @param type type of alarm.\n     * @param triggerAtMillis time in milliseconds that the alarm should first\n     * go off, using the appropriate clock (depending on the alarm type).  This\n     * is inexact: the alarm will not fire before this time, but there may be a\n     * delay of almost an entire alarm interval before the first invocation of\n     * the alarm.\n     * @param intervalMillis interval in milliseconds between subsequent repeats\n     * of the alarm.  Prior to API 19, if this is one of INTERVAL_FIFTEEN_MINUTES,\n     * INTERVAL_HALF_HOUR, INTERVAL_HOUR, INTERVAL_HALF_DAY, or INTERVAL_DAY\n     * then the alarm will be phase-aligned with other alarms to reduce the\n     * number of wakeups.  Otherwise, the alarm will be set as though the\n     * application had called {@link #setRepeating}.  As of API 19, all repeating\n     * alarms will be inexact and subject to batching with other alarms regardless\n     * of their stated repeat interval.\n     * @param operation Action to perform when the alarm goes off;\n     * typically comes from {@link PendingIntent#getBroadcast\n     * IntentSender.getBroadcast()}.\n     *\n     * @see android.os.Handler\n     * @see #set\n     * @see #cancel\n     * @see android.content.Context#sendBroadcast\n     * @see android.content.Context#registerReceiver\n     * @see android.content.Intent#filterEquals\n     * @see #ELAPSED_REALTIME\n     * @see #ELAPSED_REALTIME_WAKEUP\n     * @see #RTC\n     * @see #RTC_WAKEUP\n     * @see #INTERVAL_FIFTEEN_MINUTES\n     * @see #INTERVAL_HALF_HOUR\n     * @see #INTERVAL_HOUR\n     * @see #INTERVAL_HALF_DAY\n     * @see #INTERVAL_DAY\n     * @see Intent#EXTRA_ALARM_COUNT\n     ",
    "links" : [ "android.app.PendingIntent#getBroadcastIntentSender.getBroadcast()", "#setWindow(int", "android.content.Intent#EXTRA_ALARM_COUNT", "#setRepeating", "Build.VERSION_CODES#S", "android.app.PendingIntent#FLAG_MUTABLE", "android.app.PendingIntent", "#setExact(int" ]
  }, {
    "name" : "public void setAndAllowWhileIdle(@AlarmType int type, long triggerAtMillis, @NonNull PendingIntent operation)",
    "returnType" : "void",
    "comment" : "\n     * Like {@link #set(int, long, PendingIntent)}, but this alarm will be allowed to execute\n     * even when the system is in low-power idle (a.k.a. doze) modes.  This type of alarm must\n     * <b>only</b> be used for situations where it is actually required that the alarm go off while\n     * in idle -- a reasonable example would be for a calendar notification that should make a\n     * sound so the user is aware of it.  When the alarm is dispatched, the app will also be\n     * added to the system's temporary power exemption list for approximately 10 seconds to allow\n     * that application to acquire further wake locks in which to complete its work.</p>\n     *\n     * <p>These alarms can significantly impact the power use\n     * of the device when idle (and thus cause significant battery blame to the app scheduling\n     * them), so they should be used with care.  To reduce abuse, there are restrictions on how\n     * frequently these alarms will go off for a particular application.\n     * Under normal system operation, it will not dispatch these\n     * alarms more than about every minute (at which point every such pending alarm is\n     * dispatched); when in low-power idle modes this duration may be significantly longer,\n     * such as 15 minutes.</p>\n     *\n     * <p>Unlike other alarms, the system is free to reschedule this type of alarm to happen\n     * out of order with any other alarms, even those from the same app.  This will clearly happen\n     * when the device is idle (since this alarm can go off while idle, when any other alarms\n     * from the app will be held until later), but may also happen even when not idle.</p>\n     *\n     * <p>Regardless of the app's target SDK version, this call always allows batching of the\n     * alarm.</p>\n     *\n     * @param type type of alarm.\n     * @param triggerAtMillis time in milliseconds that the alarm should go\n     * off, using the appropriate clock (depending on the alarm type).\n     * @param operation Action to perform when the alarm goes off;\n     * typically comes from {@link PendingIntent#getBroadcast\n     * IntentSender.getBroadcast()}.\n     *\n     * @see #set(int, long, PendingIntent)\n     * @see #setExactAndAllowWhileIdle\n     * @see #cancel\n     * @see android.content.Context#sendBroadcast\n     * @see android.content.Context#registerReceiver\n     * @see android.content.Intent#filterEquals\n     * @see #ELAPSED_REALTIME\n     * @see #ELAPSED_REALTIME_WAKEUP\n     * @see #RTC\n     * @see #RTC_WAKEUP\n     ",
    "links" : [ "android.app.PendingIntent#getBroadcastIntentSender.getBroadcast()", "#set(int" ]
  }, {
    "name" : "public void setExactAndAllowWhileIdle(@AlarmType int type, long triggerAtMillis, @NonNull PendingIntent operation)",
    "returnType" : "void",
    "comment" : "\n     * Like {@link #setExact(int, long, PendingIntent)}, but this alarm will be allowed to execute\n     * even when the system is in low-power idle modes.  If you don't need exact scheduling of\n     * the alarm but still need to execute while idle, consider using\n     * {@link #setAndAllowWhileIdle}.  This type of alarm must <b>only</b>\n     * be used for situations where it is actually required that the alarm go off while in\n     * idle -- a reasonable example would be for a calendar notification that should make a\n     * sound so the user is aware of it.  When the alarm is dispatched, the app will also be\n     * added to the system's temporary power exemption list for approximately 10 seconds to allow\n     * that application to acquire further wake locks in which to complete its work.</p>\n     *\n     * <p>These alarms can significantly impact the power use\n     * of the device when idle (and thus cause significant battery blame to the app scheduling\n     * them), so they should be used with care.  To reduce abuse, there are restrictions on how\n     * frequently these alarms will go off for a particular application.\n     * Under normal system operation, it will not dispatch these\n     * alarms more than about every minute (at which point every such pending alarm is\n     * dispatched); when in low-power idle modes this duration may be significantly longer,\n     * such as 15 minutes.</p>\n     *\n     * <p>Unlike other alarms, the system is free to reschedule this type of alarm to happen\n     * out of order with any other alarms, even those from the same app.  This will clearly happen\n     * when the device is idle (since this alarm can go off while idle, when any other alarms\n     * from the app will be held until later), but may also happen even when not idle.\n     * Note that the OS will allow itself more flexibility for scheduling these alarms than\n     * regular exact alarms, since the application has opted into this behavior.  When the\n     * device is idle it may take even more liberties with scheduling in order to optimize\n     * for battery life.</p>\n     *\n     * <p class=\"note\"><strong>Note:</strong>\n     * Starting with {@link Build.VERSION_CODES#S}, apps targeting SDK level 31 or higher\n     * need to request the\n     * {@link Manifest.permission#SCHEDULE_EXACT_ALARM SCHEDULE_EXACT_ALARM} permission to use this\n     * API, unless the app is exempt from battery restrictions.\n     * The user and the system can revoke this permission via the special app access screen in\n     * Settings.\n     *\n     * <p class=\"note\"><strong>Note:</strong>\n     * Exact alarms should only be used for user-facing features.\n     * For more details, see <a\n     * href=\"{@docRoot}about/versions/12/behavior-changes-12#exact-alarm-permission\">\n     * Exact alarm permission</a>.\n     *\n     * <p>Alarms scheduled via this API\n     * will be allowed to start a foreground service even if the app is in the background.\n     *\n     * @param type type of alarm.\n     * @param triggerAtMillis time in milliseconds that the alarm should go\n     *        off, using the appropriate clock (depending on the alarm type).\n     * @param operation Action to perform when the alarm goes off;\n     *        typically comes from {@link PendingIntent#getBroadcast\n     *        IntentSender.getBroadcast()}.\n     *\n     * @see #set\n     * @see #setRepeating\n     * @see #setWindow\n     * @see #cancel\n     * @see android.content.Context#sendBroadcast\n     * @see android.content.Context#registerReceiver\n     * @see android.content.Intent#filterEquals\n     * @see #ELAPSED_REALTIME\n     * @see #ELAPSED_REALTIME_WAKEUP\n     * @see #RTC\n     * @see #RTC_WAKEUP\n     * @see Manifest.permission#SCHEDULE_EXACT_ALARM SCHEDULE_EXACT_ALARM\n     ",
    "links" : [ "android.app.PendingIntent#getBroadcastIntentSender.getBroadcast()", "Manifest.permission#SCHEDULE_EXACT_ALARM", "Build.VERSION_CODES#S", "#setAndAllowWhileIdle", "#setExact(int" ]
  }, {
    "name" : "public void setExactAndAllowWhileIdle(@AlarmType int type, long triggerAtMillis, @Nullable String tag, @NonNull Executor executor, @Nullable WorkSource workSource, @NonNull OnAlarmListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Like {@link #setExact(int, long, String, Executor, WorkSource, OnAlarmListener)}, but this\n     * alarm will be allowed to execute even when the system is in low-power idle modes.\n     *\n     * <p> See {@link #setExactAndAllowWhileIdle(int, long, PendingIntent)} for more details.\n     *\n     * <p class=\"note\"><strong>Note:</strong>\n     * Starting with android version {@link Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, the system will\n     * explicitly drop any alarms set via this API when the calling app goes out of lifecycle.\n     *\n     * @param type            type of alarm\n     * @param triggerAtMillis The exact time in milliseconds, that the alarm should be delivered,\n     *                        expressed in the appropriate clock's units (depending on the alarm\n     *                        type).\n     * @param listener        {@link OnAlarmListener} instance whose\n     *                        {@link OnAlarmListener#onAlarm() onAlarm()} method will be called when\n     *                        the alarm time is reached.\n     * @param executor        The {@link Executor} on which to execute the listener's onAlarm()\n     *                        callback.\n     * @param tag             Optional. A string tag used to identify this alarm in logs and\n     *                        battery-attribution.\n     * @param workSource      A {@link WorkSource} object to attribute this alarm to the app that\n     *                        requested this work.\n     * @hide\n     ",
    "links" : [ "#setExactAndAllowWhileIdle(int", "#onAlarm()", "OnAlarmListener", "Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.os.HandlerExecutor", "android.os.WorkSource", "#setExact(int" ]
  }, {
    "name" : "public void cancel(@NonNull PendingIntent operation)",
    "returnType" : "void",
    "comment" : "\n     * Remove any alarms with a matching {@link Intent}.\n     * Any alarm, of any type, whose Intent matches this one (as defined by\n     * {@link Intent#filterEquals}), will be canceled.\n     *\n     * @param operation IntentSender which matches a previously added\n     * IntentSender. This parameter must not be {@code null}.\n     *\n     * @see #set\n     ",
    "links" : [ "android.content.Intent#filterEquals", "android.content.Intent" ]
  }, {
    "name" : "public void cancel(@NonNull OnAlarmListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Remove any alarm scheduled to be delivered to the given {@link OnAlarmListener}.\n     *\n     * @param listener OnAlarmListener instance that is the target of a currently-set alarm.\n     ",
    "links" : [ "OnAlarmListener" ]
  }, {
    "name" : "public void cancelAll()",
    "returnType" : "void",
    "comment" : "\n     * Remove all alarms previously set by the caller, if any.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTime(long millis)",
    "returnType" : "void",
    "comment" : "\n     * Set the system wall clock time.\n     * Requires the permission android.permission.SET_TIME.\n     *\n     * @param millis time in milliseconds since the Epoch\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTimeZone(String timeZone)",
    "returnType" : "void",
    "comment" : "\n     * Sets the system's persistent default time zone. This is the time zone for all apps, even\n     * after a reboot. Use {@link java.util.TimeZone#setDefault} if you just want to change the\n     * time zone within your app, and even then prefer to pass an explicit\n     * {@link java.util.TimeZone} to APIs that require it rather than changing the time zone for\n     * all threads.\n     *\n     * <p> On android M and above, it is an error to pass in a non-Olson timezone to this\n     * function. Note that this is a bad idea on all Android releases because POSIX and\n     * the {@code TimeZone} class have opposite interpretations of {@code '+'} and {@code '-'}\n     * in the same non-Olson ID.\n     *\n     * @param timeZone one of the Olson ids from the list returned by\n     *     {@link java.util.TimeZone#getAvailableIDs}\n     ",
    "links" : [ "java.util.TimeZone", "java.util.TimeZone#getAvailableIDs", "java.util.TimeZone#setDefault" ]
  }, {
    "name" : "public long getNextWakeFromIdleTime()",
    "returnType" : "long",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean canScheduleExactAlarms()",
    "returnType" : "boolean",
    "comment" : "\n     * Called to check if the caller can schedule exact alarms.\n     * Your app schedules exact alarms when it calls any of the {@code setExact...} or\n     * {@link #setAlarmClock(AlarmClockInfo, PendingIntent) setAlarmClock} API methods.\n     * <p>\n     * Apps targeting {@link Build.VERSION_CODES#S} or higher can schedule exact alarms only if they\n     * have the {@link Manifest.permission#SCHEDULE_EXACT_ALARM} permission or they are on the\n     * device's power-save exemption list.\n     * These apps can also\n     * start {@link android.provider.Settings#ACTION_REQUEST_SCHEDULE_EXACT_ALARM} to\n     * request this permission from the user.\n     * <p>\n     * Apps targeting lower sdk versions, can always schedule exact alarms.\n     *\n     * @return {@code true} if the caller can schedule exact alarms, {@code false} otherwise.\n     * @see android.provider.Settings#ACTION_REQUEST_SCHEDULE_EXACT_ALARM\n     * @see #setExact(int, long, PendingIntent)\n     * @see #setExactAndAllowWhileIdle(int, long, PendingIntent)\n     * @see #setAlarmClock(AlarmClockInfo, PendingIntent)\n     * @see android.os.PowerManager#isIgnoringBatteryOptimizations(String)\n     ",
    "links" : [ "Manifest.permission#SCHEDULE_EXACT_ALARM", "Build.VERSION_CODES#S", "#setAlarmClock(AlarmClockInfo", "android.provider.Settings#ACTION_REQUEST_SCHEDULE_EXACT_ALARM" ]
  }, {
    "name" : "public boolean hasScheduleExactAlarm(@NonNull String packageName, int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Called to check if the given package in the given user has the permission\n     * {@link Manifest.permission#SCHEDULE_EXACT_ALARM}.\n     *\n     * <p><em>Note: This is only for use by system components.</em>\n     *\n     * @hide\n     ",
    "links" : [ "Manifest.permission#SCHEDULE_EXACT_ALARM" ]
  }, {
    "name" : "public AlarmClockInfo getNextAlarmClock()",
    "returnType" : "AlarmClockInfo",
    "comment" : "\n     * Gets information about the next alarm clock currently scheduled.\n     *\n     * The alarm clocks considered are those scheduled by any application\n     * using the {@link #setAlarmClock} method.\n     *\n     * @return An {@link AlarmClockInfo} object describing the next upcoming alarm\n     *   clock event that will occur.  If there are no alarm clock events currently\n     *   scheduled, this method will return {@code null}.\n     *\n     * @see #setAlarmClock\n     * @see AlarmClockInfo\n     * @see #ACTION_NEXT_ALARM_CLOCK_CHANGED\n     ",
    "links" : [ "#setAlarmClock", "AlarmClockInfo" ]
  }, {
    "name" : "public AlarmClockInfo getNextAlarmClock(int userId)",
    "returnType" : "AlarmClockInfo",
    "comment" : "\n     * Gets information about the next alarm clock currently scheduled.\n     *\n     * The alarm clocks considered are those scheduled by any application\n     * using the {@link #setAlarmClock} method within the given user.\n     *\n     * @return An {@link AlarmClockInfo} object describing the next upcoming alarm\n     *   clock event that will occur within the given user.  If there are no alarm clock\n     *   events currently scheduled in that user, this method will return {@code null}.\n     *\n     * @see #setAlarmClock\n     * @see AlarmClockInfo\n     * @see #ACTION_NEXT_ALARM_CLOCK_CHANGED\n     *\n     * @hide\n     ",
    "links" : [ "#setAlarmClock", "AlarmClockInfo" ]
  } ],
  "methodNames" : [ "private long legacyExactLength()", "public void set(@AlarmType int type, long triggerAtMillis, @NonNull PendingIntent operation)", "public void set(@AlarmType int type, long triggerAtMillis, @Nullable String tag, @NonNull OnAlarmListener listener, @Nullable Handler targetHandler)", "public void setRepeating(@AlarmType int type, long triggerAtMillis, long intervalMillis, @NonNull PendingIntent operation)", "public void setWindow(@AlarmType int type, long windowStartMillis, long windowLengthMillis, @NonNull PendingIntent operation)", "public void setWindow(@AlarmType int type, long windowStartMillis, long windowLengthMillis, @Nullable String tag, @NonNull OnAlarmListener listener, @Nullable Handler targetHandler)", "public void setWindow(@AlarmType int type, long windowStartMillis, long windowLengthMillis, @Nullable String tag, @NonNull Executor executor, @NonNull OnAlarmListener listener)", "public void setWindow(@AlarmType int type, long windowStartMillis, long windowLengthMillis, @Nullable String tag, @NonNull Executor executor, @Nullable WorkSource workSource, @NonNull OnAlarmListener listener)", "public void setPrioritized(@AlarmType int type, long windowStartMillis, long windowLengthMillis, @Nullable String tag, @NonNull Executor executor, @NonNull OnAlarmListener listener)", "public void setExact(@AlarmType int type, long triggerAtMillis, @NonNull PendingIntent operation)", "public void setExact(@AlarmType int type, long triggerAtMillis, @Nullable String tag, @NonNull OnAlarmListener listener, @Nullable Handler targetHandler)", "public void setIdleUntil(@AlarmType int type, long triggerAtMillis, @Nullable String tag, @NonNull OnAlarmListener listener, @Nullable Handler targetHandler)", "public void setAlarmClock(@NonNull AlarmClockInfo info, @NonNull PendingIntent operation)", "public void set(@AlarmType int type, long triggerAtMillis, long windowMillis, long intervalMillis, @NonNull PendingIntent operation, @Nullable WorkSource workSource)", "public void set(@AlarmType int type, long triggerAtMillis, long windowMillis, long intervalMillis, @Nullable String tag, @NonNull OnAlarmListener listener, @Nullable Handler targetHandler, @Nullable WorkSource workSource)", "private static String makeTag(long triggerMillis, WorkSource ws)", "public void set(@AlarmType int type, long triggerAtMillis, long windowMillis, long intervalMillis, @NonNull OnAlarmListener listener, @Nullable Handler targetHandler, @Nullable WorkSource workSource)", "public void setExact(@AlarmType int type, long triggerAtMillis, @Nullable String tag, @NonNull Executor executor, @NonNull WorkSource workSource, @NonNull OnAlarmListener listener)", "private void setImpl(@AlarmType int type, long triggerAtMillis, long windowMillis, long intervalMillis, int flags, PendingIntent operation, final OnAlarmListener listener, String listenerTag, Handler targetHandler, WorkSource workSource, AlarmClockInfo alarmClock)", "private void setImpl(@AlarmType int type, long triggerAtMillis, long windowMillis, long intervalMillis, int flags, PendingIntent operation, final OnAlarmListener listener, String listenerTag, Executor targetExecutor, WorkSource workSource, AlarmClockInfo alarmClock)", "public void setInexactRepeating(@AlarmType int type, long triggerAtMillis, long intervalMillis, @NonNull PendingIntent operation)", "public void setAndAllowWhileIdle(@AlarmType int type, long triggerAtMillis, @NonNull PendingIntent operation)", "public void setExactAndAllowWhileIdle(@AlarmType int type, long triggerAtMillis, @NonNull PendingIntent operation)", "public void setExactAndAllowWhileIdle(@AlarmType int type, long triggerAtMillis, @Nullable String tag, @NonNull Executor executor, @Nullable WorkSource workSource, @NonNull OnAlarmListener listener)", "public void cancel(@NonNull PendingIntent operation)", "public void cancel(@NonNull OnAlarmListener listener)", "public void cancelAll()", "public void setTime(long millis)", "public void setTimeZone(String timeZone)", "public long getNextWakeFromIdleTime()", "public boolean canScheduleExactAlarms()", "public boolean hasScheduleExactAlarm(@NonNull String packageName, int userId)", "public AlarmClockInfo getNextAlarmClock()", "public AlarmClockInfo getNextAlarmClock(int userId)" ],
  "variableNames" : [ "TAG", "GENERATED_TAG_PREFIX", "RTC_WAKEUP", "RTC", "ELAPSED_REALTIME_WAKEUP", "ELAPSED_REALTIME", "ACTION_NEXT_ALARM_CLOCK_CHANGED", "ACTION_SCHEDULE_EXACT_ALARM_PERMISSION_STATE_CHANGED", "WINDOW_EXACT", "WINDOW_HEURISTIC", "FLAG_STANDALONE", "FLAG_WAKE_FROM_IDLE", "FLAG_ALLOW_WHILE_IDLE", "FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED", "FLAG_IDLE_UNTIL", "FLAG_ALLOW_WHILE_IDLE_COMPAT", "FLAG_PRIORITIZE", "REQUIRE_EXACT_ALARM_PERMISSION", "ENFORCE_MINIMUM_WINDOW_ON_INEXACT_ALARMS", "ENABLE_USE_EXACT_ALARM", "SCHEDULE_EXACT_ALARM_DENIED_BY_DEFAULT", "SCHEDULE_EXACT_ALARM_DOES_NOT_ELEVATE_BUCKET", "EXACT_LISTENER_ALARMS_DROPPED_ON_CACHED", "mService", "mContext", "mPackageName", "mAlwaysExact", "mTargetSdkVersion", "mMainThreadHandler", "sWrappers", "INTERVAL_FIFTEEN_MINUTES", "INTERVAL_HALF_HOUR", "INTERVAL_HOUR", "INTERVAL_HALF_DAY", "INTERVAL_DAY" ]
}