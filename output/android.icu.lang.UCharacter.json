{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/icu/lang/UCharacter.java",
  "packageName" : "android.icu.lang",
  "className" : "UCharacter",
  "comment" : "",
  "links" : [ ],
  "variables" : [ {
    "name" : "LEAD_SURROGATE_BITMASK",
    "type" : "int",
    "comment" : "\n     * Lead surrogate bitmask\n     ",
    "links" : [ ]
  }, {
    "name" : "TRAIL_SURROGATE_BITMASK",
    "type" : "int",
    "comment" : "\n     * Trail surrogate bitmask\n     ",
    "links" : [ ]
  }, {
    "name" : "LEAD_SURROGATE_BITS",
    "type" : "int",
    "comment" : "\n     * Lead surrogate bits\n     ",
    "links" : [ ]
  }, {
    "name" : "TRAIL_SURROGATE_BITS",
    "type" : "int",
    "comment" : "\n     * Trail surrogate bits\n     ",
    "links" : [ ]
  }, {
    "name" : "U16_SURROGATE_OFFSET",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIN_VALUE",
    "type" : "int",
    "comment" : "\n     * The lowest Unicode code point value, constant 0.\n     * Same as {@link Character#MIN_CODE_POINT}, same integer value as {@link Character#MIN_VALUE}.\n     ",
    "links" : [ "#MIN_CODE_POINT", "#MIN_VALUE" ]
  }, {
    "name" : "MAX_VALUE",
    "type" : "int",
    "comment" : "\n     * The highest Unicode code point value (scalar value), constant U+10FFFF (uses 21 bits).\n     * Same as {@link Character#MAX_CODE_POINT}.\n     *\n     * <p>Up-to-date Unicode implementation of {@link Character#MAX_VALUE}\n     * which is still a char with the value U+FFFF.\n     ",
    "links" : [ "#MAX_VALUE", "#MAX_CODE_POINT" ]
  }, {
    "name" : "SUPPLEMENTARY_MIN_VALUE",
    "type" : "int",
    "comment" : "\n     * The minimum value for Supplementary code points, constant U+10000.\n     * Same as {@link Character#MIN_SUPPLEMENTARY_CODE_POINT}.\n     ",
    "links" : [ "#MIN_SUPPLEMENTARY_CODE_POINT" ]
  }, {
    "name" : "REPLACEMENT_CHAR",
    "type" : "int",
    "comment" : "\n     * Unicode value used when translating into Unicode encoding form and there\n     * is no existing character.\n     ",
    "links" : [ ]
  }, {
    "name" : "NO_NUMERIC_VALUE",
    "type" : "double",
    "comment" : "\n     * Special value that is returned by getUnicodeNumericValue(int) when no\n     * numeric value is defined for a code point.\n     * @see #getUnicodeNumericValue\n     ",
    "links" : [ ]
  }, {
    "name" : "MIN_RADIX",
    "type" : "int",
    "comment" : "\n     * Compatibility constant for Java Character's MIN_RADIX.\n     ",
    "links" : [ ]
  }, {
    "name" : "MAX_RADIX",
    "type" : "int",
    "comment" : "\n     * Compatibility constant for Java Character's MAX_RADIX.\n     ",
    "links" : [ ]
  }, {
    "name" : "TITLECASE_NO_LOWERCASE",
    "type" : "int",
    "comment" : "\n     * Do not lowercase non-initial parts of words when titlecasing.\n     * Option bit for titlecasing APIs that take an options bit set.\n     *\n     * By default, titlecasing will titlecase the first cased character\n     * of a word and lowercase all other characters.\n     * With this option, the other characters will not be modified.\n     *\n     * @see #toTitleCase\n     ",
    "links" : [ ]
  }, {
    "name" : "TITLECASE_NO_BREAK_ADJUSTMENT",
    "type" : "int",
    "comment" : "\n     * Do not adjust the titlecasing indexes from BreakIterator::next() indexes;\n     * titlecase exactly the characters at breaks from the iterator.\n     * Option bit for titlecasing APIs that take an options bit set.\n     *\n     * By default, titlecasing will take each break iterator index,\n     * adjust it by looking for the next cased character, and titlecase that one.\n     * Other characters are lowercased.\n     *\n     * This follows Unicode 4 &amp; 5 section 3.13 Default Case Operations:\n     *\n     * R3  toTitlecase(X): Find the word boundaries based on Unicode Standard Annex\n     * #29, \"Text Boundaries.\" Between each pair of word boundaries, find the first\n     * cased character F. If F exists, map F to default_title(F); then map each\n     * subsequent character C to default_lower(C).\n     *\n     * @see #toTitleCase\n     * @see #TITLECASE_NO_LOWERCASE\n     ",
    "links" : [ ]
  }, {
    "name" : "FOLD_CASE_DEFAULT",
    "type" : "int",
    "comment" : "\n     * <strong>[icu]</strong> Option value for case folding: use default mappings defined in\n     * CaseFolding.txt.\n     ",
    "links" : [ ]
  }, {
    "name" : "FOLD_CASE_EXCLUDE_SPECIAL_I",
    "type" : "int",
    "comment" : "\n     * <strong>[icu]</strong> Option value for case folding:\n     * Use the modified set of mappings provided in CaseFolding.txt to handle dotted I\n     * and dotless i appropriately for Turkic languages (tr, az).\n     *\n     * <p>Before Unicode 3.2, CaseFolding.txt contains mappings marked with 'I' that\n     * are to be included for default mappings and\n     * excluded for the Turkic-specific mappings.\n     *\n     * <p>Unicode 3.2 CaseFolding.txt instead contains mappings marked with 'T' that\n     * are to be excluded for default mappings and\n     * included for the Turkic-specific mappings.\n     ",
    "links" : [ ]
  }, {
    "name" : "MIN_HIGH_SURROGATE",
    "type" : "char",
    "comment" : "\n     * Constant U+D800, same as {@link Character#MIN_HIGH_SURROGATE}.\n     ",
    "links" : [ "#MIN_HIGH_SURROGATE" ]
  }, {
    "name" : "MAX_HIGH_SURROGATE",
    "type" : "char",
    "comment" : "\n     * Constant U+DBFF, same as {@link Character#MAX_HIGH_SURROGATE}.\n     ",
    "links" : [ "#MAX_HIGH_SURROGATE" ]
  }, {
    "name" : "MIN_LOW_SURROGATE",
    "type" : "char",
    "comment" : "\n     * Constant U+DC00, same as {@link Character#MIN_LOW_SURROGATE}.\n     ",
    "links" : [ "#MIN_LOW_SURROGATE" ]
  }, {
    "name" : "MAX_LOW_SURROGATE",
    "type" : "char",
    "comment" : "\n     * Constant U+DFFF, same as {@link Character#MAX_LOW_SURROGATE}.\n     ",
    "links" : [ "#MAX_LOW_SURROGATE" ]
  }, {
    "name" : "MIN_SURROGATE",
    "type" : "char",
    "comment" : "\n     * Constant U+D800, same as {@link Character#MIN_SURROGATE}.\n     ",
    "links" : [ "#MIN_SURROGATE" ]
  }, {
    "name" : "MAX_SURROGATE",
    "type" : "char",
    "comment" : "\n     * Constant U+DFFF, same as {@link Character#MAX_SURROGATE}.\n     ",
    "links" : [ "#MAX_SURROGATE" ]
  }, {
    "name" : "MIN_SUPPLEMENTARY_CODE_POINT",
    "type" : "int",
    "comment" : "\n     * Constant U+10000, same as {@link Character#MIN_SUPPLEMENTARY_CODE_POINT}.\n     ",
    "links" : [ "#MIN_SUPPLEMENTARY_CODE_POINT" ]
  }, {
    "name" : "MAX_CODE_POINT",
    "type" : "int",
    "comment" : "\n     * Constant U+10FFFF, same as {@link Character#MAX_CODE_POINT}.\n     ",
    "links" : [ "#MAX_CODE_POINT" ]
  }, {
    "name" : "MIN_CODE_POINT",
    "type" : "int",
    "comment" : "\n     * Constant U+0000, same as {@link Character#MIN_CODE_POINT}.\n     ",
    "links" : [ "#MIN_CODE_POINT" ]
  }, {
    "name" : "LAST_CHAR_MASK_",
    "type" : "int",
    "comment" : "\n     * To get the last character out from a data type\n     ",
    "links" : [ ]
  }, {
    "name" : "NO_BREAK_SPACE_",
    "type" : "int",
    "comment" : "\n     * No break space code point\n     ",
    "links" : [ ]
  }, {
    "name" : "FIGURE_SPACE_",
    "type" : "int",
    "comment" : "\n     * Figure space code point\n     ",
    "links" : [ ]
  }, {
    "name" : "NARROW_NO_BREAK_SPACE_",
    "type" : "int",
    "comment" : "\n     * Narrow no break space code point\n     ",
    "links" : [ ]
  }, {
    "name" : "IDEOGRAPHIC_NUMBER_ZERO_",
    "type" : "int",
    "comment" : "\n     * Ideographic number zero code point\n     ",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_FIRST_",
    "type" : "int",
    "comment" : "\n     * CJK Ideograph, First code point\n     ",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_SECOND_",
    "type" : "int",
    "comment" : "\n     * CJK Ideograph, Second code point\n     ",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_THIRD_",
    "type" : "int",
    "comment" : "\n     * CJK Ideograph, Third code point\n     ",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_FOURTH_",
    "type" : "int",
    "comment" : "\n     * CJK Ideograph, Fourth code point\n     ",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_FIFTH_",
    "type" : "int",
    "comment" : "\n     * CJK Ideograph, FIFTH code point\n     ",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_SIXTH_",
    "type" : "int",
    "comment" : "\n     * CJK Ideograph, Sixth code point\n     ",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_SEVENTH_",
    "type" : "int",
    "comment" : "\n     * CJK Ideograph, Seventh code point\n     ",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_EIGHTH_",
    "type" : "int",
    "comment" : "\n     * CJK Ideograph, Eighth code point\n     ",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_NINETH_",
    "type" : "int",
    "comment" : "\n     * CJK Ideograph, Nineth code point\n     ",
    "links" : [ ]
  }, {
    "name" : "APPLICATION_PROGRAM_COMMAND_",
    "type" : "int",
    "comment" : "\n     * Application Program command code point\n     ",
    "links" : [ ]
  }, {
    "name" : "UNIT_SEPARATOR_",
    "type" : "int",
    "comment" : "\n     * Unit separator code point\n     ",
    "links" : [ ]
  }, {
    "name" : "DELETE_",
    "type" : "int",
    "comment" : "\n     * Delete code point\n     ",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_COMPLEX_ZERO_",
    "type" : "int",
    "comment" : "\n     * Han digit characters\n     ",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_COMPLEX_ONE_",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_COMPLEX_TWO_",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_COMPLEX_THREE_",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_COMPLEX_FOUR_",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_COMPLEX_FIVE_",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_COMPLEX_SIX_",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_COMPLEX_SEVEN_",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_COMPLEX_EIGHT_",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_COMPLEX_NINE_",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_TEN_",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_COMPLEX_TEN_",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_HUNDRED_",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_COMPLEX_HUNDRED_",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_THOUSAND_",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_COMPLEX_THOUSAND_",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_TEN_THOUSAND_",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CJK_IDEOGRAPH_HUNDRED_MILLION_",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static int digit(int ch, int radix)",
    "returnType" : "int",
    "comment" : "\n     * Returnss the numeric value of a decimal digit code point.\n     * <br>This method observes the semantics of\n     * <code>java.lang.Character.digit()</code>.  Note that this\n     * will return positive values for code points for which isDigit\n     * returns false, just like java.lang.Character.\n     * <br><em>Semantic Change:</em> In release 1.3.1 and\n     * prior, this did not treat the European letters as having a\n     * digit value, and also treated numeric letters and other numbers as\n     * digits.\n     * This has been changed to conform to the java semantics.\n     * <br>A code point is a valid digit if and only if:\n     * <ul>\n     *   <li>ch is a decimal digit or one of the european letters, and\n     *   <li>the value of ch is less than the specified radix.\n     * </ul>\n     * @param ch the code point to query\n     * @param radix the radix\n     * @return the numeric value represented by the code point in the\n     * specified radix, or -1 if the code point is not a decimal digit\n     * or if its value is too large for the radix\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int digit(int ch)",
    "returnType" : "int",
    "comment" : "\n     * Returnss the numeric value of a decimal digit code point.\n     * <br>This is a convenience overload of <code>digit(int, int)</code>\n     * that provides a decimal radix.\n     * <br><em>Semantic Change:</em> In release 1.3.1 and prior, this\n     * treated numeric letters and other numbers as digits.  This has\n     * been changed to conform to the java semantics.\n     * @param ch the code point to query\n     * @return the numeric value represented by the code point,\n     * or -1 if the code point is not a decimal digit or if its\n     * value is too large for a decimal radix\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getNumericValue(int ch)",
    "returnType" : "int",
    "comment" : "\n     * Returns the numeric value of the code point as a nonnegative\n     * integer.\n     * <br>If the code point does not have a numeric value, then -1 is returned.\n     * <br>\n     * If the code point has a numeric value that cannot be represented as a\n     * nonnegative integer (for example, a fractional value), then -2 is\n     * returned.\n     * @param ch the code point to query\n     * @return the numeric value of the code point, or -1 if it has no numeric\n     * value, or -2 if it has a numeric value that cannot be represented as a\n     * nonnegative integer\n     ",
    "links" : [ ]
  }, {
    "name" : "public static double getUnicodeNumericValue(int ch)",
    "returnType" : "double",
    "comment" : "\n     * <strong>[icu]</strong> Returns the numeric value for a Unicode code point as defined in the\n     * Unicode Character Database.\n     * <p>A \"double\" return type is necessary because some numeric values are\n     * fractions, negative, or too large for int.\n     * <p>For characters without any numeric values in the Unicode Character\n     * Database, this function will return NO_NUMERIC_VALUE.\n     * Note: This is different from the Unicode Standard which specifies NaN as the default value.\n     * <p><em>API Change:</em> In release 2.2 and prior, this API has a\n     * return type int and returns -1 when the argument ch does not have a\n     * corresponding numeric value. This has been changed to synch with ICU4C\n     *\n     * This corresponds to the ICU4C function u_getNumericValue.\n     * @param ch Code point to get the numeric value for.\n     * @return numeric value of ch, or NO_NUMERIC_VALUE if none is defined.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isSpace(int ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Compatibility override of Java deprecated method.  This\n     * method will always remain deprecated.\n     * Same as java.lang.Character.isSpace().\n     * @param ch the code point\n     * @return true if the code point is a space character as\n     * defined by java.lang.Character.isSpace.\n     * @deprecated ICU 3.4 (Java)\n     * @hide original deprecated declaration\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getType(int ch)",
    "returnType" : "int",
    "comment" : "\n     * Returns a value indicating a code point's Unicode category.\n     * Up-to-date Unicode implementation of java.lang.Character.getType()\n     * except for the above mentioned code points that had their category\n     * changed.<br>\n     * Return results are constants from the interface\n     * <a href=UCharacterCategory.html>UCharacterCategory</a><br>\n     * <em>NOTE:</em> the UCharacterCategory values are <em>not</em> compatible with\n     * those returned by java.lang.Character.getType.  UCharacterCategory values\n     * match the ones used in ICU4C, while java.lang.Character type\n     * values, though similar, skip the value 17.\n     * @param ch code point whose type is to be determined\n     * @return category which is a value of UCharacterCategory\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isDefined(int ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if a code point has a defined meaning in the up-to-date\n     * Unicode standard.\n     * E.g. supplementary code points though allocated space are not defined in\n     * Unicode yet.<br>\n     * Up-to-date Unicode implementation of java.lang.Character.isDefined()\n     * @param ch code point to be determined if it is defined in the most\n     *        current version of Unicode\n     * @return true if this code point is defined in unicode\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isDigit(int ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if a code point is a Java digit.\n     * <br>This method observes the semantics of\n     * <code>java.lang.Character.isDigit()</code>. It returns true for decimal\n     * digits only.\n     * <br><em>Semantic Change:</em> In release 1.3.1 and prior, this treated\n     * numeric letters and other numbers as digits.\n     * This has been changed to conform to the java semantics.\n     * @param ch code point to query\n     * @return true if this code point is a digit\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isISOControl(int ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified code point is an ISO control character.\n     * A code point is considered to be an ISO control character if it is in\n     * the range &#92;u0000 through &#92;u001F or in the range &#92;u007F through\n     * &#92;u009F.<br>\n     * Up-to-date Unicode implementation of java.lang.Character.isISOControl()\n     * @param ch code point to determine if it is an ISO control character\n     * @return true if code point is a ISO control character\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isLetter(int ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified code point is a letter.\n     * Up-to-date Unicode implementation of java.lang.Character.isLetter()\n     * @param ch code point to determine if it is a letter\n     * @return true if code point is a letter\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isLetterOrDigit(int ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified code point is a letter or digit.\n     * <strong>[icu] Note:</strong> This method, unlike java.lang.Character does not regard the ascii\n     * characters 'A' - 'Z' and 'a' - 'z' as digits.\n     * @param ch code point to determine if it is a letter or a digit\n     * @return true if code point is a letter or a digit\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isJavaLetter(int cp)",
    "returnType" : "boolean",
    "comment" : "\n     * Compatibility override of Java deprecated method.  This\n     * method will always remain deprecated.  Delegates to\n     * java.lang.Character.isJavaIdentifierStart.\n     * @param cp the code point\n     * @return true if the code point can start a java identifier.\n     * @deprecated ICU 3.4 (Java)\n     * @hide original deprecated declaration\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isJavaLetterOrDigit(int cp)",
    "returnType" : "boolean",
    "comment" : "\n     * Compatibility override of Java deprecated method.  This\n     * method will always remain deprecated.  Delegates to\n     * java.lang.Character.isJavaIdentifierPart.\n     * @param cp the code point\n     * @return true if the code point can continue a java identifier.\n     * @deprecated ICU 3.4 (Java)\n     * @hide original deprecated declaration\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isJavaIdentifierStart(int cp)",
    "returnType" : "boolean",
    "comment" : "\n     * Compatibility override of Java method, delegates to\n     * java.lang.Character.isJavaIdentifierStart.\n     * @param cp the code point\n     * @return true if the code point can start a java identifier.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isJavaIdentifierPart(int cp)",
    "returnType" : "boolean",
    "comment" : "\n     * Compatibility override of Java method, delegates to\n     * java.lang.Character.isJavaIdentifierPart.\n     * @param cp the code point\n     * @return true if the code point can continue a java identifier.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isLowerCase(int ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified code point is a lowercase character.\n     * UnicodeData only contains case mappings for code points where they are\n     * one-to-one mappings; it also omits information about context-sensitive\n     * case mappings.<br> For more information about Unicode case mapping\n     * please refer to the\n     * <a href=https://www.unicode.org/reports/tr21/>Technical report\n     * #21</a>.<br>\n     * Up-to-date Unicode implementation of java.lang.Character.isLowerCase()\n     * @param ch code point to determine if it is in lowercase\n     * @return true if code point is a lowercase character\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isWhitespace(int ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified code point is a white space character.\n     * A code point is considered to be an whitespace character if and only\n     * if it satisfies one of the following criteria:\n     * <ul>\n     * <li> It is a Unicode Separator character (categories \"Z\" = \"Zs\" or \"Zl\" or \"Zp\"), but is not\n     *      also a non-breaking space (&#92;u00A0 or &#92;u2007 or &#92;u202F).\n     * <li> It is &#92;u0009, HORIZONTAL TABULATION.\n     * <li> It is &#92;u000A, LINE FEED.\n     * <li> It is &#92;u000B, VERTICAL TABULATION.\n     * <li> It is &#92;u000C, FORM FEED.\n     * <li> It is &#92;u000D, CARRIAGE RETURN.\n     * <li> It is &#92;u001C, FILE SEPARATOR.\n     * <li> It is &#92;u001D, GROUP SEPARATOR.\n     * <li> It is &#92;u001E, RECORD SEPARATOR.\n     * <li> It is &#92;u001F, UNIT SEPARATOR.\n     * </ul>\n     *\n     * This API tries to sync with the semantics of Java's\n     * java.lang.Character.isWhitespace(), but it may not return\n     * the exact same results because of the Unicode version\n     * difference.\n     * <p>Note: Unicode 4.0.1 changed U+200B ZERO WIDTH SPACE from a Space Separator (Zs)\n     * to a Format Control (Cf). Since then, isWhitespace(0x200b) returns false.\n     * See http://www.unicode.org/versions/Unicode4.0.1/\n     * @param ch code point to determine if it is a white space\n     * @return true if the specified code point is a white space character\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isSpaceChar(int ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified code point is a Unicode specified space\n     * character, i.e. if code point is in the category Zs, Zl and Zp.\n     * Up-to-date Unicode implementation of java.lang.Character.isSpaceChar().\n     * @param ch code point to determine if it is a space\n     * @return true if the specified code point is a space character\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isTitleCase(int ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified code point is a titlecase character.\n     * UnicodeData only contains case mappings for code points where they are\n     * one-to-one mappings; it also omits information about context-sensitive\n     * case mappings.<br>\n     * For more information about Unicode case mapping please refer to the\n     * <a href=https://www.unicode.org/reports/tr21/>\n     * Technical report #21</a>.<br>\n     * Up-to-date Unicode implementation of java.lang.Character.isTitleCase().\n     * @param ch code point to determine if it is in title case\n     * @return true if the specified code point is a titlecase character\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isUnicodeIdentifierPart(int ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified character is permissible as a\n     * non-initial character of an identifier\n     * according to UAX #31 Unicode Identifier and Pattern Syntax.\n     *\n     * <p>Same as Unicode ID_Continue ({@link UProperty#ID_CONTINUE}).\n     *\n     * <p>Note that this differs from {@link java.lang.Character#isUnicodeIdentifierPart(char)}\n     * which implements a different identifier profile.\n     *\n     * @param ch the code point to be tested\n     * @return true if the code point may occur as a non-initial character of an identifier\n     ",
    "links" : [ "android.icu.lang.UProperty#ID_CONTINUE", "java.lang.Character#isUnicodeIdentifierPart(char)" ]
  }, {
    "name" : "public static boolean isUnicodeIdentifierStart(int ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified character is permissible as the first character in an identifier\n     * according to UAX #31 Unicode Identifier and Pattern Syntax.\n     *\n     * <p>Same as Unicode ID_Start ({@link UProperty#ID_START}).\n     *\n     * <p>Note that this differs from {@link java.lang.Character#isUnicodeIdentifierStart(char)}\n     * which implements a different identifier profile.\n     *\n     * @param ch the code point to be tested\n     * @return true if the code point may start an identifier\n     ",
    "links" : [ "java.lang.Character#isUnicodeIdentifierStart(char)", "android.icu.lang.UProperty#ID_START" ]
  }, {
    "name" : "public static final boolean hasIdentifierType(int c, IdentifierType type)",
    "returnType" : "boolean",
    "comment" : "\n     * Does the set of Identifier_Type values code point c contain the given type?\n     *\n     * <p>Used for UTS #39 General Security Profile for Identifiers\n     * (https://www.unicode.org/reports/tr39/#General_Security_Profile).\n     *\n     * <p>Each code point maps to a <i>set</i> of UIdentifierType values.\n     *\n     * @param c code point\n     * @param type Identifier_Type to check\n     * @return true if type is in Identifier_Type(c)\n     * @hide draft / provisional / internal are hidden on Android\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final int getIdentifierTypes(int c, EnumSet<IdentifierType> types)",
    "returnType" : "int",
    "comment" : "\n     * Writes code point c's Identifier_Type as a set of IdentifierType values and\n     * returns the number of types.\n     * The set is cleared before c's types are added.\n     *\n     * <p>Used for UTS #39 General Security Profile for Identifiers\n     * (https://www.unicode.org/reports/tr39/#General_Security_Profile).\n     *\n     * <p>Each code point maps to a <i>set</i> of IdentifierType values.\n     * There is always at least one type.\n     * Only some of the types can be combined with others,\n     * and usually only a small number of types occur together.\n     * Future versions might add additional types.\n     * See UTS #39 and its data files for details.\n     *\n     * @param c code point\n     * @param types output set\n     * @return number of values in c's Identifier_Type\n     * @hide draft / provisional / internal are hidden on Android\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isIdentifierIgnorable(int ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified code point should be regarded as an\n     * ignorable character in a Java identifier.\n     * A character is Java-identifier-ignorable if it has the general category\n     * Cf Formatting Control, or it is a non-Java-whitespace ISO control:\n     * U+0000..U+0008, U+000E..U+001B, U+007F..U+009F.<br>\n     * Up-to-date Unicode implementation of\n     * java.lang.Character.isIdentifierIgnorable().<br>\n     * See <a href=https://www.unicode.org/reports/tr8/>UTR #8</a>.\n     * <p>Note that Unicode just recommends to ignore Cf (format controls).\n     * @param ch code point to be determined if it can be ignored in a Unicode\n     *        identifier.\n     * @return true if the code point is ignorable\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isUpperCase(int ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines if the specified code point is an uppercase character.\n     * UnicodeData only contains case mappings for code point where they are\n     * one-to-one mappings; it also omits information about context-sensitive\n     * case mappings.<br>\n     * For language specific case conversion behavior, use\n     * toUpperCase(locale, str). <br>\n     * For example, the case conversion for dot-less i and dotted I in Turkish,\n     * or for final sigma in Greek.\n     * For more information about Unicode case mapping please refer to the\n     * <a href=https://www.unicode.org/reports/tr21/>\n     * Technical report #21</a>.<br>\n     * Up-to-date Unicode implementation of java.lang.Character.isUpperCase().\n     * @param ch code point to determine if it is in uppercase\n     * @return true if the code point is an uppercase character\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int toLowerCase(int ch)",
    "returnType" : "int",
    "comment" : "\n     * The given code point is mapped to its lowercase equivalent; if the code\n     * point has no lowercase equivalent, the code point itself is returned.\n     * Up-to-date Unicode implementation of java.lang.Character.toLowerCase()\n     *\n     * <p>This function only returns the simple, single-code point case mapping.\n     * Full case mappings should be used whenever possible because they produce\n     * better results by working on whole strings.\n     * They take into account the string context and the language and can map\n     * to a result string with a different length as appropriate.\n     * Full case mappings are applied by the case mapping functions\n     * that take String parameters rather than code points (int).\n     * See also the User Guide chapter on C/POSIX migration:\n     * https://unicode-org.github.io/icu/userguide/icu/posix#case-mappings\n     *\n     * @param ch code point whose lowercase equivalent is to be retrieved\n     * @return the lowercase equivalent code point\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String toString(int ch)",
    "returnType" : "String",
    "comment" : "\n     * Converts argument code point and returns a String object representing\n     * the code point's value in UTF-16 format.\n     * The result is a string whose length is 1 for BMP code points, 2 for supplementary ones.\n     *\n     * <p>Up-to-date Unicode implementation of java.lang.Character.toString().\n     *\n     * @param ch code point\n     * @return string representation of the code point, null if code point is not\n     *         defined in unicode\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int toTitleCase(int ch)",
    "returnType" : "int",
    "comment" : "\n     * Converts the code point argument to titlecase.\n     * If no titlecase is available, the uppercase is returned. If no uppercase\n     * is available, the code point itself is returned.\n     * Up-to-date Unicode implementation of java.lang.Character.toTitleCase()\n     *\n     * <p>This function only returns the simple, single-code point case mapping.\n     * Full case mappings should be used whenever possible because they produce\n     * better results by working on whole strings.\n     * They take into account the string context and the language and can map\n     * to a result string with a different length as appropriate.\n     * Full case mappings are applied by the case mapping functions\n     * that take String parameters rather than code points (int).\n     * See also the User Guide chapter on C/POSIX migration:\n     * https://unicode-org.github.io/icu/userguide/icu/posix#case-mappings\n     *\n     * @param ch code point  whose title case is to be retrieved\n     * @return titlecase code point\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int toUpperCase(int ch)",
    "returnType" : "int",
    "comment" : "\n     * Converts the character argument to uppercase.\n     * If no uppercase is available, the character itself is returned.\n     * Up-to-date Unicode implementation of java.lang.Character.toUpperCase()\n     *\n     * <p>This function only returns the simple, single-code point case mapping.\n     * Full case mappings should be used whenever possible because they produce\n     * better results by working on whole strings.\n     * They take into account the string context and the language and can map\n     * to a result string with a different length as appropriate.\n     * Full case mappings are applied by the case mapping functions\n     * that take String parameters rather than code points (int).\n     * See also the User Guide chapter on C/POSIX migration:\n     * https://unicode-org.github.io/icu/userguide/icu/posix#case-mappings\n     *\n     * @param ch code point whose uppercase is to be retrieved\n     * @return uppercase code point\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isSupplementary(int ch)",
    "returnType" : "boolean",
    "comment" : "\n     * <strong>[icu]</strong> Determines if the code point is a supplementary character.\n     * A code point is a supplementary character if and only if it is greater\n     * than <a href=#SUPPLEMENTARY_MIN_VALUE>SUPPLEMENTARY_MIN_VALUE</a>\n     * @param ch code point to be determined if it is in the supplementary\n     *        plane\n     * @return true if code point is a supplementary character\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isBMP(int ch)",
    "returnType" : "boolean",
    "comment" : "\n     * <strong>[icu]</strong> Determines if the code point is in the BMP plane.\n     * @param ch code point to be determined if it is not a supplementary\n     *        character\n     * @return true if code point is not a supplementary character\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isPrintable(int ch)",
    "returnType" : "boolean",
    "comment" : "\n     * <strong>[icu]</strong> Determines whether the specified code point is a printable character\n     * according to the Unicode standard.\n     * @param ch code point to be determined if it is printable\n     * @return true if the code point is a printable character\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isBaseForm(int ch)",
    "returnType" : "boolean",
    "comment" : "\n     * <strong>[icu]</strong> Determines whether the specified code point is of base form.\n     * A code point of base form does not graphically combine with preceding\n     * characters, and is neither a control nor a format character.\n     * @param ch code point to be determined if it is of base form\n     * @return true if the code point is of base form\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getDirection(int ch)",
    "returnType" : "int",
    "comment" : "\n     * <strong>[icu]</strong> Returns the Bidirection property of a code point.\n     * For example, 0x0041 (letter A) has the LEFT_TO_RIGHT directional\n     * property.<br>\n     * Result returned belongs to the interface\n     * <a href=UCharacterDirection.html>UCharacterDirection</a>\n     * @param ch the code point to be determined its direction\n     * @return direction constant from UCharacterDirection.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isMirrored(int ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines whether the code point has the \"mirrored\" property.\n     * This property is set for characters that are commonly used in\n     * Right-To-Left contexts and need to be displayed with a \"mirrored\"\n     * glyph.\n     * @param ch code point whose mirror is to be determined\n     * @return true if the code point has the \"mirrored\" property\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getMirror(int ch)",
    "returnType" : "int",
    "comment" : "\n     * <strong>[icu]</strong> Maps the specified code point to a \"mirror-image\" code point.\n     * For code points with the \"mirrored\" property, implementations sometimes\n     * need a \"poor man's\" mapping to another code point such that the default\n     * glyph may serve as the mirror-image of the default glyph of the\n     * specified code point.<br>\n     * This is useful for text conversion to and from codepages with visual\n     * order, and for displays without glyph selection capabilities.\n     * @param ch code point whose mirror is to be retrieved\n     * @return another code point that may serve as a mirror-image substitute,\n     *         or ch itself if there is no such mapping or ch does not have the\n     *         \"mirrored\" property\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getBidiPairedBracket(int c)",
    "returnType" : "int",
    "comment" : "\n     * <strong>[icu]</strong> Maps the specified character to its paired bracket character.\n     * For Bidi_Paired_Bracket_Type!=None, this is the same as getMirror(int).\n     * Otherwise c itself is returned.\n     * See http://www.unicode.org/reports/tr9/\n     *\n     * @param c the code point to be mapped\n     * @return the paired bracket code point,\n     *         or c itself if there is no such mapping\n     *         (Bidi_Paired_Bracket_Type=None)\n     *\n     * @see UProperty#BIDI_PAIRED_BRACKET\n     * @see UProperty#BIDI_PAIRED_BRACKET_TYPE\n     * @see #getMirror(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getCombiningClass(int ch)",
    "returnType" : "int",
    "comment" : "\n     * <strong>[icu]</strong> Returns the combining class of the argument codepoint\n     * @param ch code point whose combining is to be retrieved\n     * @return the combining class of the codepoint\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isLegal(int ch)",
    "returnType" : "boolean",
    "comment" : "\n     * <strong>[icu]</strong> A code point is illegal if and only if\n     * <ul>\n     * <li> Out of bounds, less than 0 or greater than UCharacter.MAX_VALUE\n     * <li> A surrogate value, 0xD800 to 0xDFFF\n     * <li> Not-a-character, having the form 0x xxFFFF or 0x xxFFFE\n     * </ul>\n     * Note: legal does not mean that it is assigned in this version of Unicode.\n     * @param ch code point to determine if it is a legal code point by itself\n     * @return true if and only if legal.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isLegal(String str)",
    "returnType" : "boolean",
    "comment" : "\n     * <strong>[icu]</strong> A string is legal iff all its code points are legal.\n     * A code point is illegal if and only if\n     * <ul>\n     * <li> Out of bounds, less than 0 or greater than UCharacter.MAX_VALUE\n     * <li> A surrogate value, 0xD800 to 0xDFFF\n     * <li> Not-a-character, having the form 0x xxFFFF or 0x xxFFFE\n     * </ul>\n     * Note: legal does not mean that it is assigned in this version of Unicode.\n     * @param str containing code points to examin\n     * @return true if and only if legal.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static VersionInfo getUnicodeVersion()",
    "returnType" : "VersionInfo",
    "comment" : "\n     * <strong>[icu]</strong> Returns the version of Unicode data used.\n     * @return the unicode version number used\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getName(int ch)",
    "returnType" : "String",
    "comment" : "\n     * <strong>[icu]</strong> Returns the most current Unicode name of the argument code point, or\n     * null if the character is unassigned or outside the range\n     * {@code UCharacter.MIN_VALUE} and {@code UCharacter.MAX_VALUE} or does not\n     * have a name.\n     * <br>\n     * Note calling any methods related to code point names, e.g. {@code getName()}\n     * incurs a one-time initialization cost to construct the name tables.\n     * @param ch the code point for which to get the name\n     * @return most current Unicode name\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getName(String s, String separator)",
    "returnType" : "String",
    "comment" : "\n     * <strong>[icu]</strong> Returns the names for each of the characters in a string\n     * @param s string to format\n     * @param separator string to go between names\n     * @return string of names\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getName1_0(int ch)",
    "returnType" : "String",
    "comment" : "\n     * <strong>[icu]</strong> Returns null.\n     * Used to return the Unicode_1_Name property value which was of little practical value.\n     * @param ch the code point for which to get the name\n     * @return null\n     * @deprecated ICU 49\n     * @hide original deprecated declaration\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getExtendedName(int ch)",
    "returnType" : "String",
    "comment" : "\n     * <strong>[icu]</strong> Returns a name for a valid codepoint. Unlike, getName(int) and\n     * getName1_0(int), this method will return a name even for codepoints that\n     * are not assigned a name in UnicodeData.txt.\n     *\n     * <p>The names are returned in the following order.\n     * <ul>\n     * <li> Most current Unicode name if there is any\n     * <li> Unicode 1.0 name if there is any\n     * <li> Extended name in the form of\n     *      \"&lt;codepoint_type-codepoint_hex_digits&gt;\". E.g., &lt;noncharacter-fffe&gt;\n     * </ul>\n     * Note calling any methods related to code point names, e.g. {@code getName()}\n     * incurs a one-time initialization cost to construct the name tables.\n     * @param ch the code point for which to get the name\n     * @return a name for the argument codepoint\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getNameAlias(int ch)",
    "returnType" : "String",
    "comment" : "\n     * <strong>[icu]</strong> Returns the corrected name from NameAliases.txt if there is one.\n     * Returns null if the character is unassigned or outside the range\n     * UCharacter.MIN_VALUE and UCharacter.MAX_VALUE or does not have a name.\n     * <br>\n     * Note calling any methods related to code point names, e.g. {@code getName()}\n     * incurs a one-time initialization cost to construct the name tables.\n     * @param ch the code point for which to get the name alias\n     * @return Unicode name alias, or null\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getISOComment(int ch)",
    "returnType" : "String",
    "comment" : "\n     * <strong>[icu]</strong> Returns null.\n     * Used to return the ISO 10646 comment for a character.\n     * The Unicode ISO_Comment property is deprecated and has no values.\n     *\n     * @param ch The code point for which to get the ISO comment.\n     *           It must be the case that {@code 0 <= ch <= 0x10ffff}.\n     * @return null\n     * @deprecated ICU 49\n     * @hide original deprecated declaration\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getCharFromName(String name)",
    "returnType" : "int",
    "comment" : "\n     * <strong>[icu]</strong> <p>Finds a Unicode code point by its most current Unicode name and\n     * return its code point value. All Unicode names are in uppercase.\n     * Note calling any methods related to code point names, e.g. {@code getName()}\n     * incurs a one-time initialization cost to construct the name tables.\n     * @param name most current Unicode character name whose code point is to\n     *        be returned\n     * @return code point or -1 if name is not found\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getCharFromName1_0(String name)",
    "returnType" : "int",
    "comment" : "\n     * <strong>[icu]</strong> Returns -1.\n     * <p>Used to find a Unicode character by its version 1.0 Unicode name and return\n     * its code point value.\n     * @param name Unicode 1.0 code point name whose code point is to be\n     *             returned\n     * @return -1\n     * @deprecated ICU 49\n     * @see #getName1_0(int)\n     * @hide original deprecated declaration\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getCharFromExtendedName(String name)",
    "returnType" : "int",
    "comment" : "\n     * <strong>[icu]</strong> <p>Find a Unicode character by either its name and return its code\n     * point value. All Unicode names are in uppercase.\n     * Extended names are all lowercase except for numbers and are contained\n     * within angle brackets.\n     * The names are searched in the following order\n     * <ul>\n     * <li> Most current Unicode name if there is any\n     * <li> Unicode 1.0 name if there is any\n     * <li> Extended name in the form of\n     *      \"&lt;codepoint_type-codepoint_hex_digits&gt;\". E.g. &lt;noncharacter-FFFE&gt;\n     * </ul>\n     * Note calling any methods related to code point names, e.g. {@code getName()}\n     * incurs a one-time initialization cost to construct the name tables.\n     * @param name codepoint name\n     * @return code point associated with the name or -1 if the name is not\n     *         found.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getCharFromNameAlias(String name)",
    "returnType" : "int",
    "comment" : "\n     * <strong>[icu]</strong> <p>Find a Unicode character by its corrected name alias and return\n     * its code point value. All Unicode names are in uppercase.\n     * Note calling any methods related to code point names, e.g. {@code getName()}\n     * incurs a one-time initialization cost to construct the name tables.\n     * @param name Unicode name alias whose code point is to be returned\n     * @return code point or -1 if name is not found\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getPropertyName(int property, int nameChoice)",
    "returnType" : "String",
    "comment" : "\n     * <strong>[icu]</strong> Return the Unicode name for a given property, as given in the\n     * Unicode database file PropertyAliases.txt.  Most properties\n     * have more than one name.  The nameChoice determines which one\n     * is returned.\n     *\n     * In addition, this function maps the property\n     * UProperty.GENERAL_CATEGORY_MASK to the synthetic names \"gcm\" /\n     * \"General_Category_Mask\".  These names are not in\n     * PropertyAliases.txt.\n     *\n     * @param property UProperty selector.\n     *\n     * @param nameChoice UProperty.NameChoice selector for which name\n     * to get.  All properties have a long name.  Most have a short\n     * name, but some do not.  Unicode allows for additional names; if\n     * present these will be returned by UProperty.NameChoice.LONG + i,\n     * where i=1, 2,...\n     *\n     * @return a name, or null if Unicode explicitly defines no name\n     * (\"n/a\") for a given property/nameChoice.  If a given nameChoice\n     * throws an exception, then all larger values of nameChoice will\n     * throw an exception.  If null is returned for a given\n     * nameChoice, then other nameChoice values may return non-null\n     * results.\n     *\n     * @exception IllegalArgumentException thrown if property or\n     * nameChoice are invalid.\n     *\n     * @see UProperty\n     * @see UProperty.NameChoice\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getPropertyEnum(CharSequence propertyAlias)",
    "returnType" : "int",
    "comment" : "\n     * <strong>[icu]</strong> Return the UProperty selector for a given property name, as\n     * specified in the Unicode database file PropertyAliases.txt.\n     * Short, long, and any other variants are recognized.\n     *\n     * In addition, this function maps the synthetic names \"gcm\" /\n     * \"General_Category_Mask\" to the property\n     * UProperty.GENERAL_CATEGORY_MASK.  These names are not in\n     * PropertyAliases.txt.\n     *\n     * @param propertyAlias the property name to be matched.  The name\n     * is compared using \"loose matching\" as described in\n     * PropertyAliases.txt.\n     *\n     * @return a UProperty enum.\n     *\n     * @exception IllegalArgumentException thrown if propertyAlias\n     * is not recognized.\n     *\n     * @see UProperty\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String getPropertyValueName(int property, int value, int nameChoice)",
    "returnType" : "String",
    "comment" : "\n     * <strong>[icu]</strong> Return the Unicode name for a given property value, as given in\n     * the Unicode database file PropertyValueAliases.txt.  Most\n     * values have more than one name.  The nameChoice determines\n     * which one is returned.\n     *\n     * Note: Some of the names in PropertyValueAliases.txt can only be\n     * retrieved using UProperty.GENERAL_CATEGORY_MASK, not\n     * UProperty.GENERAL_CATEGORY.  These include: \"C\" / \"Other\", \"L\" /\n     * \"Letter\", \"LC\" / \"Cased_Letter\", \"M\" / \"Mark\", \"N\" / \"Number\", \"P\"\n     * / \"Punctuation\", \"S\" / \"Symbol\", and \"Z\" / \"Separator\".\n     *\n     * @param property UProperty selector constant.\n     * UProperty.INT_START &lt;= property &lt; UProperty.INT_LIMIT or\n     * UProperty.BINARY_START &lt;= property &lt; UProperty.BINARY_LIMIT or\n     * UProperty.MASK_START &lt; = property &lt; UProperty.MASK_LIMIT.\n     * If out of range, null is returned.\n     *\n     * @param value selector for a value for the given property.  In\n     * general, valid values range from 0 up to some maximum.  There\n     * are a few exceptions: (1.) UProperty.BLOCK values begin at the\n     * non-zero value BASIC_LATIN.getID().  (2.)\n     * UProperty.CANONICAL_COMBINING_CLASS values are not contiguous\n     * and range from 0..240.  (3.)  UProperty.GENERAL_CATEGORY_MASK values\n     * are mask values produced by left-shifting 1 by\n     * UCharacter.getType().  This allows grouped categories such as\n     * [:L:] to be represented.  Mask values are non-contiguous.\n     *\n     * @param nameChoice UProperty.NameChoice selector for which name\n     * to get.  All values have a long name.  Most have a short name,\n     * but some do not.  Unicode allows for additional names; if\n     * present these will be returned by UProperty.NameChoice.LONG + i,\n     * where i=1, 2,...\n     *\n     * @return a name, or null if Unicode explicitly defines no name\n     * (\"n/a\") for a given property/value/nameChoice.  If a given\n     * nameChoice throws an exception, then all larger values of\n     * nameChoice will throw an exception.  If null is returned for a\n     * given nameChoice, then other nameChoice values may return\n     * non-null results.\n     *\n     * @exception IllegalArgumentException thrown if property, value,\n     * or nameChoice are invalid.\n     *\n     * @see UProperty\n     * @see UProperty.NameChoice\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getPropertyValueEnum(int property, CharSequence valueAlias)",
    "returnType" : "int",
    "comment" : "\n     * <strong>[icu]</strong> Return the property value integer for a given value name, as\n     * specified in the Unicode database file PropertyValueAliases.txt.\n     * Short, long, and any other variants are recognized.\n     *\n     * Note: Some of the names in PropertyValueAliases.txt will only be\n     * recognized with UProperty.GENERAL_CATEGORY_MASK, not\n     * UProperty.GENERAL_CATEGORY.  These include: \"C\" / \"Other\", \"L\" /\n     * \"Letter\", \"LC\" / \"Cased_Letter\", \"M\" / \"Mark\", \"N\" / \"Number\", \"P\"\n     * / \"Punctuation\", \"S\" / \"Symbol\", and \"Z\" / \"Separator\".\n     *\n     * @param property UProperty selector constant.\n     * UProperty.INT_START &lt;= property &lt; UProperty.INT_LIMIT or\n     * UProperty.BINARY_START &lt;= property &lt; UProperty.BINARY_LIMIT or\n     * UProperty.MASK_START &lt; = property &lt; UProperty.MASK_LIMIT.\n     * Only these properties can be enumerated.\n     *\n     * @param valueAlias the value name to be matched.  The name is\n     * compared using \"loose matching\" as described in\n     * PropertyValueAliases.txt.\n     *\n     * @return a value integer.  Note: UProperty.GENERAL_CATEGORY\n     * values are mask values produced by left-shifting 1 by\n     * UCharacter.getType().  This allows grouped categories such as\n     * [:L:] to be represented.\n     *\n     * @see UProperty\n     * @throws IllegalArgumentException if property is not a valid UProperty\n     *         selector or valueAlias is not a value of this property\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getPropertyValueEnumNoThrow(int property, CharSequence valueAlias)",
    "returnType" : "int",
    "comment" : "\n     * Same as {@link #getPropertyValueEnum(int, CharSequence)}, except doesn't throw exception. Instead, returns UProperty.UNDEFINED.\n     * @param property  Same as {@link #getPropertyValueEnum(int, CharSequence)}\n     * @param valueAlias    Same as {@link #getPropertyValueEnum(int, CharSequence)}\n     * @return returns UProperty.UNDEFINED if the value is not valid, otherwise the value.\n     * @deprecated This API is ICU internal only.\n     * @hide original deprecated declaration\n     * @hide draft / provisional / internal are hidden on Android\n     ",
    "links" : [ "#getPropertyValueEnum(int" ]
  }, {
    "name" : "public static int getCodePoint(int lead, int trail)",
    "returnType" : "int",
    "comment" : "\n     * <strong>[icu]</strong> Returns a code point corresponding to the two surrogate code units.\n     *\n     * @param lead the lead unit\n     *        (In ICU 2.1-69 the type of both parameters was <code>char</code>.)\n     * @param trail the trail unit\n     * @return code point if lead and trail form a valid surrogate pair.\n     * @exception IllegalArgumentException thrown when the code units do\n     *            not form a valid surrogate pair\n     * @see #toCodePoint(int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getCodePoint(char lead, char trail)",
    "returnType" : "int",
    "comment" : "\n     * <strong>[icu]</strong> Returns a code point corresponding to the two surrogate code units.\n     *\n     * @param lead the lead char\n     * @param trail the trail char\n     * @return code point if surrogate characters are valid.\n     * @exception IllegalArgumentException thrown when the code units do\n     *            not form a valid code point\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getCodePoint(char char16)",
    "returnType" : "int",
    "comment" : "\n     * <strong>[icu]</strong> Returns the code point corresponding to the BMP code point.\n     *\n     * @param char16 the BMP code point\n     * @return code point if argument is a valid character.\n     * @exception IllegalArgumentException thrown when char16 is not a valid\n     *            code point\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String toUpperCase(String str)",
    "returnType" : "String",
    "comment" : "\n     * Returns the uppercase version of the argument string.\n     * Casing is dependent on the default locale and context-sensitive.\n     * @param str source string to be performed on\n     * @return uppercase version of the argument string\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String toLowerCase(String str)",
    "returnType" : "String",
    "comment" : "\n     * Returns the lowercase version of the argument string.\n     * Casing is dependent on the default locale and context-sensitive\n     * @param str source string to be performed on\n     * @return lowercase version of the argument string\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String toTitleCase(String str, BreakIterator breakiter)",
    "returnType" : "String",
    "comment" : "\n     * <p>Returns the titlecase version of the argument string.\n     * <p>Position for titlecasing is determined by the argument break\n     * iterator, hence the user can customize his break iterator for\n     * a specialized titlecasing. In this case only the forward iteration\n     * needs to be implemented.\n     * If the break iterator passed in is null, the default Unicode algorithm\n     * will be used to determine the titlecase positions.\n     *\n     * <p>Only positions returned by the break iterator will be title cased,\n     * character in between the positions will all be in lower case.\n     * <p>Casing is dependent on the default locale and context-sensitive\n     * @param str source string to be performed on\n     * @param breakiter break iterator to determine the positions in which\n     *        the character should be title cased.\n     * @return titlecase version of the argument string\n     ",
    "links" : [ ]
  }, {
    "name" : "private static int getDefaultCaseLocale()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static int getCaseLocale(Locale locale)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static int getCaseLocale(ULocale locale)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static String toUpperCase(Locale locale, String str)",
    "returnType" : "String",
    "comment" : "\n     * Returns the uppercase version of the argument string.\n     * Casing is dependent on the argument locale and context-sensitive.\n     * @param locale which string is to be converted in\n     * @param str source string to be performed on\n     * @return uppercase version of the argument string\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String toUpperCase(ULocale locale, String str)",
    "returnType" : "String",
    "comment" : "\n     * Returns the uppercase version of the argument string.\n     * Casing is dependent on the argument locale and context-sensitive.\n     * @param locale which string is to be converted in\n     * @param str source string to be performed on\n     * @return uppercase version of the argument string\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String toLowerCase(Locale locale, String str)",
    "returnType" : "String",
    "comment" : "\n     * Returns the lowercase version of the argument string.\n     * Casing is dependent on the argument locale and context-sensitive\n     * @param locale which string is to be converted in\n     * @param str source string to be performed on\n     * @return lowercase version of the argument string\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String toLowerCase(ULocale locale, String str)",
    "returnType" : "String",
    "comment" : "\n     * Returns the lowercase version of the argument string.\n     * Casing is dependent on the argument locale and context-sensitive\n     * @param locale which string is to be converted in\n     * @param str source string to be performed on\n     * @return lowercase version of the argument string\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String toTitleCase(Locale locale, String str, BreakIterator breakiter)",
    "returnType" : "String",
    "comment" : "\n     * <p>Returns the titlecase version of the argument string.\n     * <p>Position for titlecasing is determined by the argument break\n     * iterator, hence the user can customize his break iterator for\n     * a specialized titlecasing. In this case only the forward iteration\n     * needs to be implemented.\n     * If the break iterator passed in is null, the default Unicode algorithm\n     * will be used to determine the titlecase positions.\n     *\n     * <p>Only positions returned by the break iterator will be title cased,\n     * character in between the positions will all be in lower case.\n     * <p>Casing is dependent on the argument locale and context-sensitive\n     * @param locale which string is to be converted in\n     * @param str source string to be performed on\n     * @param breakiter break iterator to determine the positions in which\n     *        the character should be title cased.\n     * @return titlecase version of the argument string\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String toTitleCase(ULocale locale, String str, BreakIterator titleIter)",
    "returnType" : "String",
    "comment" : "\n     * <p>Returns the titlecase version of the argument string.\n     * <p>Position for titlecasing is determined by the argument break\n     * iterator, hence the user can customize his break iterator for\n     * a specialized titlecasing. In this case only the forward iteration\n     * needs to be implemented.\n     * If the break iterator passed in is null, the default Unicode algorithm\n     * will be used to determine the titlecase positions.\n     *\n     * <p>Only positions returned by the break iterator will be title cased,\n     * character in between the positions will all be in lower case.\n     * <p>Casing is dependent on the argument locale and context-sensitive\n     * @param locale which string is to be converted in\n     * @param str source string to be performed on\n     * @param titleIter break iterator to determine the positions in which\n     *        the character should be title cased.\n     * @return titlecase version of the argument string\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String toTitleCase(ULocale locale, String str, BreakIterator titleIter, int options)",
    "returnType" : "String",
    "comment" : "\n     * <p>Returns the titlecase version of the argument string.\n     * <p>Position for titlecasing is determined by the argument break\n     * iterator, hence the user can customize his break iterator for\n     * a specialized titlecasing. In this case only the forward iteration\n     * needs to be implemented.\n     * If the break iterator passed in is null, the default Unicode algorithm\n     * will be used to determine the titlecase positions.\n     *\n     * <p>Only positions returned by the break iterator will be title cased,\n     * character in between the positions will all be in lower case.\n     * <p>Casing is dependent on the argument locale and context-sensitive\n     * @param locale which string is to be converted in\n     * @param str source string to be performed on\n     * @param titleIter break iterator to determine the positions in which\n     *        the character should be title cased.\n     * @param options bit set to modify the titlecasing operation\n     * @return titlecase version of the argument string\n     * @see #TITLECASE_NO_LOWERCASE\n     * @see #TITLECASE_NO_BREAK_ADJUSTMENT\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String toTitleCase(Locale locale, String str, BreakIterator titleIter, int options)",
    "returnType" : "String",
    "comment" : "\n     * <strong>[icu]</strong> <p>Returns the titlecase version of the argument string.\n     * <p>Position for titlecasing is determined by the argument break\n     * iterator, hence the user can customize his break iterator for\n     * a specialized titlecasing. In this case only the forward iteration\n     * needs to be implemented.\n     * If the break iterator passed in is null, the default Unicode algorithm\n     * will be used to determine the titlecase positions.\n     *\n     * <p>Only positions returned by the break iterator will be title cased,\n     * character in between the positions will all be in lower case.\n     * <p>Casing is dependent on the argument locale and context-sensitive\n     * @param locale which string is to be converted in\n     * @param str source string to be performed on\n     * @param titleIter break iterator to determine the positions in which\n     *        the character should be title cased.\n     * @param options bit set to modify the titlecasing operation\n     * @return titlecase version of the argument string\n     * @see #TITLECASE_NO_LOWERCASE\n     * @see #TITLECASE_NO_BREAK_ADJUSTMENT\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int foldCase(int ch, boolean defaultmapping)",
    "returnType" : "int",
    "comment" : "\n     * <strong>[icu]</strong> The given character is mapped to its case folding equivalent according\n     * to UnicodeData.txt and CaseFolding.txt; if the character has no case\n     * folding equivalent, the character itself is returned.\n     *\n     * <p>This function only returns the simple, single-code point case mapping.\n     * Full case mappings should be used whenever possible because they produce\n     * better results by working on whole strings.\n     * They can map to a result string with a different length as appropriate.\n     * Full case mappings are applied by the case mapping functions\n     * that take String parameters rather than code points (int).\n     * See also the User Guide chapter on C/POSIX migration:\n     * https://unicode-org.github.io/icu/userguide/icu/posix#case-mappings\n     *\n     * @param ch             the character to be converted\n     * @param defaultmapping Indicates whether the default mappings defined in\n     *                       CaseFolding.txt are to be used, otherwise the\n     *                       mappings for dotted I and dotless i marked with\n     *                       'T' in CaseFolding.txt are included.\n     * @return               the case folding equivalent of the character, if\n     *                       any; otherwise the character itself.\n     * @see                  #foldCase(String, boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String foldCase(String str, boolean defaultmapping)",
    "returnType" : "String",
    "comment" : "\n     * <strong>[icu]</strong> The given string is mapped to its case folding equivalent according to\n     * UnicodeData.txt and CaseFolding.txt; if any character has no case\n     * folding equivalent, the character itself is returned.\n     * \"Full\", multiple-code point case folding mappings are returned here.\n     * For \"simple\" single-code point mappings use the API\n     * foldCase(int ch, boolean defaultmapping).\n     * @param str            the String to be converted\n     * @param defaultmapping Indicates whether the default mappings defined in\n     *                       CaseFolding.txt are to be used, otherwise the\n     *                       mappings for dotted I and dotless i marked with\n     *                       'T' in CaseFolding.txt are included.\n     * @return               the case folding equivalent of the character, if\n     *                       any; otherwise the character itself.\n     * @see                  #foldCase(int, boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int foldCase(int ch, int options)",
    "returnType" : "int",
    "comment" : "\n     * <strong>[icu]</strong> The given character is mapped to its case folding equivalent according\n     * to UnicodeData.txt and CaseFolding.txt; if the character has no case\n     * folding equivalent, the character itself is returned.\n     *\n     * <p>This function only returns the simple, single-code point case mapping.\n     * Full case mappings should be used whenever possible because they produce\n     * better results by working on whole strings.\n     * They can map to a result string with a different length as appropriate.\n     * Full case mappings are applied by the case mapping functions\n     * that take String parameters rather than code points (int).\n     * See also the User Guide chapter on C/POSIX migration:\n     * https://unicode-org.github.io/icu/userguide/icu/posix#case-mappings\n     *\n     * @param ch the character to be converted\n     * @param options A bit set for special processing. Currently the recognised options\n     * are FOLD_CASE_EXCLUDE_SPECIAL_I and FOLD_CASE_DEFAULT\n     * @return the case folding equivalent of the character, if any; otherwise the\n     * character itself.\n     * @see #foldCase(String, boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final String foldCase(String str, int options)",
    "returnType" : "String",
    "comment" : "\n     * <strong>[icu]</strong> The given string is mapped to its case folding equivalent according to\n     * UnicodeData.txt and CaseFolding.txt; if any character has no case\n     * folding equivalent, the character itself is returned.\n     * \"Full\", multiple-code point case folding mappings are returned here.\n     * For \"simple\" single-code point mappings use the API\n     * foldCase(int ch, boolean defaultmapping).\n     * @param str the String to be converted\n     * @param options A bit set for special processing. Currently the recognised options\n     *                are FOLD_CASE_EXCLUDE_SPECIAL_I and FOLD_CASE_DEFAULT\n     * @return the case folding equivalent of the character, if any; otherwise the\n     *         character itself.\n     * @see #foldCase(int, boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getHanNumericValue(int ch)",
    "returnType" : "int",
    "comment" : "\n     * <strong>[icu]</strong> Returns the numeric value of a Han character.\n     *\n     * <p>This returns the value of Han 'numeric' code points,\n     * including those for zero, ten, hundred, thousand, ten thousand,\n     * and hundred million.\n     * This includes both the standard and 'checkwriting'\n     * characters, the 'big circle' zero character, and the standard\n     * zero character.\n     *\n     * <p>Note: The Unicode Standard has numeric values for more\n     * Han characters recognized by this method\n     * (see {@link #getNumericValue(int)} and the UCD file DerivedNumericValues.txt),\n     * and a {@link android.icu.text.NumberFormat} can be used with\n     * a Chinese {@link android.icu.text.NumberingSystem}.\n     *\n     * @param ch code point to query\n     * @return value if it is a Han 'numeric character,' otherwise return -1.\n     ",
    "links" : [ "#getNumericValue(int)", "android.icu.text.NumberingSystem", "android.icu.text.NumberFormat" ]
  }, {
    "name" : "public static RangeValueIterator getTypeIterator()",
    "returnType" : "RangeValueIterator",
    "comment" : "\n     * <strong>[icu]</strong> <p>Returns an iterator for character types, iterating over codepoints.\n     * <p>Example of use:<br>\n     * <pre>\n     * RangeValueIterator iterator = UCharacter.getTypeIterator();\n     * RangeValueIterator.Element element = new RangeValueIterator.Element();\n     * while (iterator.next(element)) {\n     *     System.out.println(\"Codepoint \\\\u\" +\n     *                        Integer.toHexString(element.start) +\n     *                        \" to codepoint \\\\u\" +\n     *                        Integer.toHexString(element.limit - 1) +\n     *                        \" has the character type \" +\n     *                        element.value);\n     * }\n     * </pre>\n     * @return an iterator\n     ",
    "links" : [ ]
  }, {
    "name" : "public static ValueIterator getNameIterator()",
    "returnType" : "ValueIterator",
    "comment" : "\n     * <strong>[icu]</strong> <p>Returns an iterator for character names, iterating over codepoints.\n     * <p>This API only gets the iterator for the modern, most up-to-date\n     * Unicode names. For older 1.0 Unicode names use get1_0NameIterator() or\n     * for extended names use getExtendedNameIterator().\n     * <p>Example of use:<br>\n     * <pre>\n     * ValueIterator iterator = UCharacter.getNameIterator();\n     * ValueIterator.Element element = new ValueIterator.Element();\n     * while (iterator.next(element)) {\n     *     System.out.println(\"Codepoint \\\\u\" +\n     *                        Integer.toHexString(element.codepoint) +\n     *                        \" has the name \" + (String)element.value);\n     * }\n     * </pre>\n     * <p>The maximal range which the name iterator iterates is from\n     * UCharacter.MIN_VALUE to UCharacter.MAX_VALUE.\n     * @return an iterator\n     ",
    "links" : [ ]
  }, {
    "name" : "public static ValueIterator getName1_0Iterator()",
    "returnType" : "ValueIterator",
    "comment" : "\n     * <strong>[icu]</strong> Returns an empty iterator.\n     * <p>Used to return an iterator for the older 1.0 Unicode character names, iterating over codepoints.\n     * @return an empty iterator\n     * @deprecated ICU 49\n     * @see #getName1_0(int)\n     * @hide original deprecated declaration\n     ",
    "links" : [ ]
  }, {
    "name" : "public static ValueIterator getExtendedNameIterator()",
    "returnType" : "ValueIterator",
    "comment" : "\n     * <strong>[icu]</strong> <p>Returns an iterator for character names, iterating over codepoints.\n     * <p>This API only gets the iterator for the extended names.\n     * For modern, most up-to-date Unicode names use getNameIterator() or\n     * for older 1.0 Unicode names use get1_0NameIterator().\n     * <p>Example of use:<br>\n     * <pre>\n     * ValueIterator iterator = UCharacter.getExtendedNameIterator();\n     * ValueIterator.Element element = new ValueIterator.Element();\n     * while (iterator.next(element)) {\n     *     System.out.println(\"Codepoint \\\\u\" +\n     *                        Integer.toHexString(element.codepoint) +\n     *                        \" has the name \" + (String)element.value);\n     * }\n     * </pre>\n     * <p>The maximal range which the name iterator iterates is from\n     * @return an iterator\n     ",
    "links" : [ ]
  }, {
    "name" : "public static VersionInfo getAge(int ch)",
    "returnType" : "VersionInfo",
    "comment" : "\n     * <strong>[icu]</strong> Returns the \"age\" of the code point.\n     * <p>The \"age\" is the Unicode version when the code point was first\n     * designated (as a non-character or for Private Use) or assigned a\n     * character.\n     * <p>This can be useful to avoid emitting code points to receiving\n     * processes that do not accept newer characters.\n     * <p>The data is from the UCD file DerivedAge.txt.\n     * @param ch The code point.\n     * @return the Unicode version number\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean hasBinaryProperty(int ch, int property)",
    "returnType" : "boolean",
    "comment" : "\n     * <strong>[icu]</strong> Check a binary Unicode property for a code point.\n     * <p>Unicode, especially in version 3.2, defines many more properties\n     * than the original set in UnicodeData.txt.\n     * <p>This API is intended to reflect Unicode properties as defined in\n     * the Unicode Character Database (UCD) and Unicode Technical Reports\n     * (UTR).\n     * <p>For details about the properties see\n     * <a href=http://www.unicode.org/>http://www.unicode.org/</a>.\n     * <p>For names of Unicode properties see the UCD file\n     * PropertyAliases.txt.\n     * <p>This API does not check the validity of the codepoint.\n     * <p>Important: If ICU is built with UCD files from Unicode versions\n     * below 3.2, then properties marked with \"new\" are not or\n     * not fully available.\n     * @param ch code point to test.\n     * @param property selector constant from android.icu.lang.UProperty,\n     *        identifies which binary property to check.\n     * @return true or false according to the binary Unicode property value\n     *         for ch. Also false if property is out of bounds or if the\n     *         Unicode version does not have data for the property at all, or\n     *         not for this code point.\n     * @see android.icu.lang.UProperty\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean hasBinaryProperty(CharSequence s, int property)",
    "returnType" : "boolean",
    "comment" : "\n     * <strong>[icu]</strong> Returns true if the property is true for the string.\n     * Same as {@link #hasBinaryProperty(int, int)}\n     * if the string contains exactly one code point.\n     *\n     * <p>Most properties apply only to single code points.\n     * <a href=\"https://www.unicode.org/reports/tr51/#Emoji_Sets\">UTS #51 Unicode Emoji</a>\n     * defines several properties of strings.\n     *\n     * @param s String to test.\n     * @param property UProperty selector constant, identifies which binary property to check.\n     *        Must be BINARY_START&lt;=which&lt;BINARY_LIMIT.\n     * @return true or false according to the binary Unicode property value for the string.\n     *         Also false if <code>property</code> is out of bounds or if the Unicode version\n     *         does not have data for the property at all.\n     *\n     * @see android.icu.lang.UProperty\n     ",
    "links" : [ "#hasBinaryProperty(int" ]
  }, {
    "name" : "public static boolean isUAlphabetic(int ch)",
    "returnType" : "boolean",
    "comment" : "\n     * <strong>[icu]</strong> <p>Check if a code point has the Alphabetic Unicode property.\n     * <p>Same as UCharacter.hasBinaryProperty(ch, UProperty.ALPHABETIC).\n     * <p>Different from UCharacter.isLetter(ch)!\n     * @param ch codepoint to be tested\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isULowercase(int ch)",
    "returnType" : "boolean",
    "comment" : "\n     * <strong>[icu]</strong> <p>Check if a code point has the Lowercase Unicode property.\n     * <p>Same as UCharacter.hasBinaryProperty(ch, UProperty.LOWERCASE).\n     * <p>This is different from UCharacter.isLowerCase(ch)!\n     * @param ch codepoint to be tested\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isUUppercase(int ch)",
    "returnType" : "boolean",
    "comment" : "\n     * <strong>[icu]</strong> <p>Check if a code point has the Uppercase Unicode property.\n     * <p>Same as UCharacter.hasBinaryProperty(ch, UProperty.UPPERCASE).\n     * <p>This is different from UCharacter.isUpperCase(ch)!\n     * @param ch codepoint to be tested\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isUWhiteSpace(int ch)",
    "returnType" : "boolean",
    "comment" : "\n     * <strong>[icu]</strong> <p>Check if a code point has the White_Space Unicode property.\n     * <p>Same as UCharacter.hasBinaryProperty(ch, UProperty.WHITE_SPACE).\n     * <p>This is different from both UCharacter.isSpace(ch) and\n     * UCharacter.isWhitespace(ch)!\n     * @param ch codepoint to be tested\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getIntPropertyValue(int ch, int type)",
    "returnType" : "int",
    "comment" : "\n     * <strong>[icu]</strong> Returns the property value for a Unicode property type of a code point.\n     * Also returns binary and mask property values.\n     * <p>Unicode, especially in version 3.2, defines many more properties than\n     * the original set in UnicodeData.txt.\n     * <p>The properties APIs are intended to reflect Unicode properties as\n     * defined in the Unicode Character Database (UCD) and Unicode Technical\n     * Reports (UTR). For details about the properties see\n     * http://www.unicode.org/.\n     * <p>For names of Unicode properties see the UCD file PropertyAliases.txt.\n     *\n     * <pre>\n     * Sample usage:\n     * int ea = UCharacter.getIntPropertyValue(c, UProperty.EAST_ASIAN_WIDTH);\n     * int ideo = UCharacter.getIntPropertyValue(c, UProperty.IDEOGRAPHIC);\n     * boolean b = (ideo == 1) ? true : false;\n     * </pre>\n     * @param ch code point to test.\n     * @param type UProperty selector constant, identifies which binary\n     *        property to check. Must be\n     *        UProperty.BINARY_START &lt;= type &lt; UProperty.BINARY_LIMIT or\n     *        UProperty.INT_START &lt;= type &lt; UProperty.INT_LIMIT or\n     *        UProperty.MASK_START &lt;= type &lt; UProperty.MASK_LIMIT.\n     * @return numeric value that is directly the property value or,\n     *         for enumerated properties, corresponds to the numeric value of\n     *         the enumerated constant of the respective property value type\n     *         ({@link ECharacterCategory}, {@link ECharacterDirection},\n     *         {@link DecompositionType}, etc.).\n     *         Returns 0 or 1 (for false / true) for binary Unicode properties.\n     *         Returns a bit-mask for mask properties.\n     *         Returns 0 if 'type' is out of bounds or if the Unicode version\n     *         does not have data for the property at all, or not for this code\n     *         point.\n     * @see UProperty\n     * @see #hasBinaryProperty\n     * @see #getIntPropertyMinValue\n     * @see #getIntPropertyMaxValue\n     * @see #getUnicodeVersion\n     ",
    "links" : [ "android.icu.lang.UCharacterEnums.ECharacterDirection", "android.icu.lang.UCharacterEnums.ECharacterCategory", "DecompositionType" ]
  }, {
    "name" : "public static String getStringPropertyValue(int propertyEnum, int codepoint, int nameChoice)",
    "returnType" : "String",
    "comment" : "\n     * <strong>[icu]</strong> Returns a string version of the property value.\n     * @param propertyEnum The property enum value.\n     * @param codepoint The codepoint value.\n     * @param nameChoice The choice of the name.\n     * @return value as string\n     * @deprecated This API is ICU internal only.\n     * @hide original deprecated declaration\n     * @hide draft / provisional / internal are hidden on Android\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getIntPropertyMinValue(int type)",
    "returnType" : "int",
    "comment" : "\n     * <strong>[icu]</strong> Returns the minimum value for an integer/binary Unicode property type.\n     * Can be used together with UCharacter.getIntPropertyMaxValue(int)\n     * to allocate arrays of android.icu.text.UnicodeSet or similar.\n     * @param type UProperty selector constant, identifies which binary\n     *        property to check. Must be\n     *        UProperty.BINARY_START &lt;= type &lt; UProperty.BINARY_LIMIT or\n     *        UProperty.INT_START &lt;= type &lt; UProperty.INT_LIMIT.\n     * @return Minimum value returned by UCharacter.getIntPropertyValue(int)\n     *         for a Unicode property. 0 if the property\n     *         selector 'type' is out of range.\n     * @see UProperty\n     * @see #hasBinaryProperty\n     * @see #getUnicodeVersion\n     * @see #getIntPropertyMaxValue\n     * @see #getIntPropertyValue\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getIntPropertyMaxValue(int type)",
    "returnType" : "int",
    "comment" : "\n     * <strong>[icu]</strong> Returns the maximum value for an integer/binary Unicode property.\n     * Can be used together with UCharacter.getIntPropertyMinValue(int)\n     * to allocate arrays of android.icu.text.UnicodeSet or similar.\n     * Examples for min/max values (for Unicode 3.2):\n     * <ul>\n     * <li> UProperty.BIDI_CLASS:    0/18\n     * (UCharacterDirection.LEFT_TO_RIGHT/UCharacterDirection.BOUNDARY_NEUTRAL)\n     * <li> UProperty.SCRIPT:        0/45 (UScript.COMMON/UScript.TAGBANWA)\n     * <li> UProperty.IDEOGRAPHIC:   0/1  (false/true)\n     * </ul>\n     * For undefined UProperty constant values, min/max values will be 0/-1.\n     * @param type UProperty selector constant, identifies which binary\n     *        property to check. Must be\n     *        UProperty.BINARY_START &lt;= type &lt; UProperty.BINARY_LIMIT or\n     *        UProperty.INT_START &lt;= type &lt; UProperty.INT_LIMIT.\n     * @return Maximum value returned by u_getIntPropertyValue for a Unicode\n     *         property. &lt;= 0 if the property selector 'type' is out of range.\n     * @see UProperty\n     * @see #hasBinaryProperty\n     * @see #getUnicodeVersion\n     * @see #getIntPropertyMaxValue\n     * @see #getIntPropertyValue\n     ",
    "links" : [ ]
  }, {
    "name" : "public static char forDigit(int digit, int radix)",
    "returnType" : "char",
    "comment" : "\n     * Provide the java.lang.Character forDigit API, for convenience.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final boolean isValidCodePoint(int cp)",
    "returnType" : "boolean",
    "comment" : "\n     * Equivalent to {@link Character#isValidCodePoint}.\n     *\n     * @param cp the code point to check\n     * @return true if cp is a valid code point\n     ",
    "links" : [ "#isValidCodePoint" ]
  }, {
    "name" : "public static final boolean isSupplementaryCodePoint(int cp)",
    "returnType" : "boolean",
    "comment" : "\n     * Same as {@link Character#isSupplementaryCodePoint}.\n     *\n     * @param cp the code point to check\n     * @return true if cp is a supplementary code point\n     ",
    "links" : [ "#isSupplementaryCodePoint" ]
  }, {
    "name" : "public static boolean isHighSurrogate(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n     * Same as {@link Character#isHighSurrogate},\n     * except that the ICU version accepts <code>int</code> for code points.\n     *\n     * @param codePoint the code point to check\n     *        (In ICU 3.0-69 the type of this parameter was <code>char</code>.)\n     * @return true if codePoint is a high (lead) surrogate\n     ",
    "links" : [ "#isHighSurrogate" ]
  }, {
    "name" : "public static boolean isHighSurrogate(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Same as {@link Character#isHighSurrogate},\n     *\n     * @param ch the char to check\n     * @return true if ch is a high (lead) surrogate\n     ",
    "links" : [ "#isHighSurrogate" ]
  }, {
    "name" : "public static boolean isLowSurrogate(int codePoint)",
    "returnType" : "boolean",
    "comment" : "\n     * Same as {@link Character#isLowSurrogate},\n     * except that the ICU version accepts <code>int</code> for code points.\n     *\n     * @param codePoint the code point to check\n     *        (In ICU 3.0-69 the type of this parameter was <code>char</code>.)\n     * @return true if codePoint is a low (trail) surrogate\n     ",
    "links" : [ "#isLowSurrogate" ]
  }, {
    "name" : "public static boolean isLowSurrogate(char ch)",
    "returnType" : "boolean",
    "comment" : "\n     * Same as {@link Character#isLowSurrogate},\n     *\n     * @param ch the char to check\n     * @return true if ch is a low (trail) surrogate\n     ",
    "links" : [ "#isLowSurrogate" ]
  }, {
    "name" : "public static final boolean isSurrogatePair(int high, int low)",
    "returnType" : "boolean",
    "comment" : "\n     * Same as {@link Character#isSurrogatePair},\n     * except that the ICU version accepts <code>int</code> for code points.\n     *\n     * @param high the high (lead) unit\n     *        (In ICU 3.0-69 the type of both parameters was <code>char</code>.)\n     * @param low the low (trail) unit\n     * @return true if high, low form a surrogate pair\n     ",
    "links" : [ "#isSurrogatePair" ]
  }, {
    "name" : "public static final boolean isSurrogatePair(char high, char low)",
    "returnType" : "boolean",
    "comment" : "\n     * Same as {@link Character#isSurrogatePair}.\n     *\n     * @param high the high (lead) char\n     * @param low the low (trail) char\n     * @return true if high, low form a surrogate pair\n     ",
    "links" : [ "#isSurrogatePair" ]
  }, {
    "name" : "public static int charCount(int cp)",
    "returnType" : "int",
    "comment" : "\n     * Same as {@link Character#charCount}.\n     * Returns the number of chars needed to represent the code point (1 or 2).\n     * This does not check the code point for validity.\n     *\n     * @param cp the code point to check\n     * @return the number of chars needed to represent the code point\n     ",
    "links" : [ "#charCount" ]
  }, {
    "name" : "public static final int toCodePoint(int high, int low)",
    "returnType" : "int",
    "comment" : "\n     * Same as {@link Character#toCodePoint},\n     * except that the ICU version accepts <code>int</code> for code points.\n     * Returns the code point represented by the two surrogate code units.\n     * This does not check the surrogate pair for validity.\n     *\n     * @param high the high (lead) surrogate\n     *        (In ICU 3.0-69 the type of both parameters was <code>char</code>.)\n     * @param low the low (trail) surrogate\n     * @return the code point formed by the surrogate pair\n     * @see #getCodePoint(int, int)\n     ",
    "links" : [ "#toCodePoint" ]
  }, {
    "name" : "public static final int toCodePoint(char high, char low)",
    "returnType" : "int",
    "comment" : "\n     * Same as {@link Character#toCodePoint}.\n     * Returns the code point represented by the two surrogate code units.\n     * This does not check the surrogate pair for validity.\n     *\n     * @param high the high (lead) surrogate\n     * @param low the low (trail) surrogate\n     * @return the code point formed by the surrogate pair\n     ",
    "links" : [ "#toCodePoint" ]
  }, {
    "name" : "public static final int codePointAt(CharSequence seq, int index)",
    "returnType" : "int",
    "comment" : "\n     * Same as {@link Character#codePointAt(CharSequence, int)}.\n     * Returns the code point at index.\n     * This examines only the characters at index and index+1.\n     *\n     * @param seq the characters to check\n     * @param index the index of the first or only char forming the code point\n     * @return the code point at the index\n     ",
    "links" : [ "#codePointAt(CharSequence" ]
  }, {
    "name" : "public static final int codePointAt(char[] text, int index)",
    "returnType" : "int",
    "comment" : "\n     * Same as {@link Character#codePointAt(char[], int)}.\n     * Returns the code point at index.\n     * This examines only the characters at index and index+1.\n     *\n     * @param text the characters to check\n     * @param index the index of the first or only char forming the code point\n     * @return the code point at the index\n     ",
    "links" : [ "#codePointAt(char" ]
  }, {
    "name" : "public static final int codePointAt(char[] text, int index, int limit)",
    "returnType" : "int",
    "comment" : "\n     * Same as {@link Character#codePointAt(char[], int, int)}.\n     * Returns the code point at index.\n     * This examines only the characters at index and index+1.\n     *\n     * @param text the characters to check\n     * @param index the index of the first or only char forming the code point\n     * @param limit the limit of the valid text\n     * @return the code point at the index\n     ",
    "links" : [ "#codePointAt(char" ]
  }, {
    "name" : "public static final int codePointBefore(CharSequence seq, int index)",
    "returnType" : "int",
    "comment" : "\n     * Same as {@link Character#codePointBefore(CharSequence, int)}.\n     * Return the code point before index.\n     * This examines only the characters at index-1 and index-2.\n     *\n     * @param seq the characters to check\n     * @param index the index after the last or only char forming the code point\n     * @return the code point before the index\n     ",
    "links" : [ "#codePointBefore(CharSequence" ]
  }, {
    "name" : "public static final int codePointBefore(char[] text, int index)",
    "returnType" : "int",
    "comment" : "\n     * Same as {@link Character#codePointBefore(char[], int)}.\n     * Returns the code point before index.\n     * This examines only the characters at index-1 and index-2.\n     *\n     * @param text the characters to check\n     * @param index the index after the last or only char forming the code point\n     * @return the code point before the index\n     ",
    "links" : [ "#codePointBefore(char" ]
  }, {
    "name" : "public static final int codePointBefore(char[] text, int index, int limit)",
    "returnType" : "int",
    "comment" : "\n     * Same as {@link Character#codePointBefore(char[], int, int)}.\n     * Return the code point before index.\n     * This examines only the characters at index-1 and index-2.\n     *\n     * @param text the characters to check\n     * @param index the index after the last or only char forming the code point\n     * @param limit the start of the valid text\n     * @return the code point before the index\n     ",
    "links" : [ "#codePointBefore(char" ]
  }, {
    "name" : "public static final int toChars(int cp, char[] dst, int dstIndex)",
    "returnType" : "int",
    "comment" : "\n     * Same as {@link Character#toChars(int, char[], int)}.\n     * Writes the chars representing the\n     * code point into the destination at the given index.\n     *\n     * @param cp the code point to convert\n     * @param dst the destination array into which to put the char(s) representing the code point\n     * @param dstIndex the index at which to put the first (or only) char\n     * @return the count of the number of chars written (1 or 2)\n     * @throws IllegalArgumentException if cp is not a valid code point\n     ",
    "links" : [ "#toChars(int" ]
  }, {
    "name" : "public static final char[] toChars(int cp)",
    "returnType" : "char[]",
    "comment" : "\n     * Same as {@link Character#toChars(int)}.\n     * Returns a char array representing the code point.\n     *\n     * @param cp the code point to convert\n     * @return an array containing the char(s) representing the code point\n     * @throws IllegalArgumentException if cp is not a valid code point\n     ",
    "links" : [ "#toChars(int)" ]
  }, {
    "name" : "public static byte getDirectionality(int cp)",
    "returnType" : "byte",
    "comment" : "\n     * Equivalent to the {@link Character#getDirectionality(char)} method, for\n     * convenience. Returns a byte representing the directionality of the\n     * character.\n     *\n     * <strong>[icu] Note:</strong> Unlike {@link Character#getDirectionality(char)}, this returns\n     * DIRECTIONALITY_LEFT_TO_RIGHT for undefined or out-of-bounds characters.\n     *\n     * <strong>[icu] Note:</strong> The return value must be tested using the constants defined in {@link\n     * UCharacterDirection} and its interface {@link\n     * UCharacterEnums.ECharacterDirection} since the values are different from the ones\n     * defined by <code>java.lang.Character</code>.\n     * @param cp the code point to check\n     * @return the directionality of the code point\n     * @see #getDirection\n     ",
    "links" : [ "UCharacterEnums.ECharacterDirection", "android.icu.lang.UCharacterDirection", "#getDirectionality(char)" ]
  }, {
    "name" : "public static int codePointCount(CharSequence text, int start, int limit)",
    "returnType" : "int",
    "comment" : "\n     * Equivalent to the {@link Character#codePointCount(CharSequence, int, int)}\n     * method, for convenience.  Counts the number of code points in the range\n     * of text.\n     * @param text the characters to check\n     * @param start the start of the range\n     * @param limit the limit of the range\n     * @return the number of code points in the range\n     ",
    "links" : [ "#codePointCount(CharSequence" ]
  }, {
    "name" : "public static int codePointCount(char[] text, int start, int limit)",
    "returnType" : "int",
    "comment" : "\n     * Equivalent to the {@link Character#codePointCount(char[], int, int)} method, for\n     * convenience. Counts the number of code points in the range of text.\n     * @param text the characters to check\n     * @param start the start of the range\n     * @param limit the limit of the range\n     * @return the number of code points in the range\n     ",
    "links" : [ "#codePointCount(char" ]
  }, {
    "name" : "public static int offsetByCodePoints(CharSequence text, int index, int codePointOffset)",
    "returnType" : "int",
    "comment" : "\n     * Equivalent to the {@link Character#offsetByCodePoints(CharSequence, int, int)}\n     * method, for convenience.  Adjusts the char index by a code point offset.\n     * @param text the characters to check\n     * @param index the index to adjust\n     * @param codePointOffset the number of code points by which to offset the index\n     * @return the adjusted index\n     ",
    "links" : [ "#offsetByCodePoints(CharSequence" ]
  }, {
    "name" : "public static int offsetByCodePoints(char[] text, int start, int count, int index, int codePointOffset)",
    "returnType" : "int",
    "comment" : "\n     * Equivalent to the\n     * {@link Character#offsetByCodePoints(char[], int, int, int, int)}\n     * method, for convenience.  Adjusts the char index by a code point offset.\n     * @param text the characters to check\n     * @param start the start of the range to check\n     * @param count the length of the range to check\n     * @param index the index to adjust\n     * @param codePointOffset the number of code points by which to offset the index\n     * @return the adjusted index\n     ",
    "links" : [ "#offsetByCodePoints(char" ]
  } ],
  "methodNames" : [ "public static int digit(int ch, int radix)", "public static int digit(int ch)", "public static int getNumericValue(int ch)", "public static double getUnicodeNumericValue(int ch)", "public static boolean isSpace(int ch)", "public static int getType(int ch)", "public static boolean isDefined(int ch)", "public static boolean isDigit(int ch)", "public static boolean isISOControl(int ch)", "public static boolean isLetter(int ch)", "public static boolean isLetterOrDigit(int ch)", "public static boolean isJavaLetter(int cp)", "public static boolean isJavaLetterOrDigit(int cp)", "public static boolean isJavaIdentifierStart(int cp)", "public static boolean isJavaIdentifierPart(int cp)", "public static boolean isLowerCase(int ch)", "public static boolean isWhitespace(int ch)", "public static boolean isSpaceChar(int ch)", "public static boolean isTitleCase(int ch)", "public static boolean isUnicodeIdentifierPart(int ch)", "public static boolean isUnicodeIdentifierStart(int ch)", "public static final boolean hasIdentifierType(int c, IdentifierType type)", "public static final int getIdentifierTypes(int c, EnumSet<IdentifierType> types)", "public static boolean isIdentifierIgnorable(int ch)", "public static boolean isUpperCase(int ch)", "public static int toLowerCase(int ch)", "public static String toString(int ch)", "public static int toTitleCase(int ch)", "public static int toUpperCase(int ch)", "public static boolean isSupplementary(int ch)", "public static boolean isBMP(int ch)", "public static boolean isPrintable(int ch)", "public static boolean isBaseForm(int ch)", "public static int getDirection(int ch)", "public static boolean isMirrored(int ch)", "public static int getMirror(int ch)", "public static int getBidiPairedBracket(int c)", "public static int getCombiningClass(int ch)", "public static boolean isLegal(int ch)", "public static boolean isLegal(String str)", "public static VersionInfo getUnicodeVersion()", "public static String getName(int ch)", "public static String getName(String s, String separator)", "public static String getName1_0(int ch)", "public static String getExtendedName(int ch)", "public static String getNameAlias(int ch)", "public static String getISOComment(int ch)", "public static int getCharFromName(String name)", "public static int getCharFromName1_0(String name)", "public static int getCharFromExtendedName(String name)", "public static int getCharFromNameAlias(String name)", "public static String getPropertyName(int property, int nameChoice)", "public static int getPropertyEnum(CharSequence propertyAlias)", "public static String getPropertyValueName(int property, int value, int nameChoice)", "public static int getPropertyValueEnum(int property, CharSequence valueAlias)", "public static int getPropertyValueEnumNoThrow(int property, CharSequence valueAlias)", "public static int getCodePoint(int lead, int trail)", "public static int getCodePoint(char lead, char trail)", "public static int getCodePoint(char char16)", "public static String toUpperCase(String str)", "public static String toLowerCase(String str)", "public static String toTitleCase(String str, BreakIterator breakiter)", "private static int getDefaultCaseLocale()", "private static int getCaseLocale(Locale locale)", "private static int getCaseLocale(ULocale locale)", "public static String toUpperCase(Locale locale, String str)", "public static String toUpperCase(ULocale locale, String str)", "public static String toLowerCase(Locale locale, String str)", "public static String toLowerCase(ULocale locale, String str)", "public static String toTitleCase(Locale locale, String str, BreakIterator breakiter)", "public static String toTitleCase(ULocale locale, String str, BreakIterator titleIter)", "public static String toTitleCase(ULocale locale, String str, BreakIterator titleIter, int options)", "public static String toTitleCase(Locale locale, String str, BreakIterator titleIter, int options)", "public static int foldCase(int ch, boolean defaultmapping)", "public static String foldCase(String str, boolean defaultmapping)", "public static int foldCase(int ch, int options)", "public static final String foldCase(String str, int options)", "public static int getHanNumericValue(int ch)", "public static RangeValueIterator getTypeIterator()", "public static ValueIterator getNameIterator()", "public static ValueIterator getName1_0Iterator()", "public static ValueIterator getExtendedNameIterator()", "public static VersionInfo getAge(int ch)", "public static boolean hasBinaryProperty(int ch, int property)", "public static boolean hasBinaryProperty(CharSequence s, int property)", "public static boolean isUAlphabetic(int ch)", "public static boolean isULowercase(int ch)", "public static boolean isUUppercase(int ch)", "public static boolean isUWhiteSpace(int ch)", "public static int getIntPropertyValue(int ch, int type)", "public static String getStringPropertyValue(int propertyEnum, int codepoint, int nameChoice)", "public static int getIntPropertyMinValue(int type)", "public static int getIntPropertyMaxValue(int type)", "public static char forDigit(int digit, int radix)", "public static final boolean isValidCodePoint(int cp)", "public static final boolean isSupplementaryCodePoint(int cp)", "public static boolean isHighSurrogate(int codePoint)", "public static boolean isHighSurrogate(char ch)", "public static boolean isLowSurrogate(int codePoint)", "public static boolean isLowSurrogate(char ch)", "public static final boolean isSurrogatePair(int high, int low)", "public static final boolean isSurrogatePair(char high, char low)", "public static int charCount(int cp)", "public static final int toCodePoint(int high, int low)", "public static final int toCodePoint(char high, char low)", "public static final int codePointAt(CharSequence seq, int index)", "public static final int codePointAt(char[] text, int index)", "public static final int codePointAt(char[] text, int index, int limit)", "public static final int codePointBefore(CharSequence seq, int index)", "public static final int codePointBefore(char[] text, int index)", "public static final int codePointBefore(char[] text, int index, int limit)", "public static final int toChars(int cp, char[] dst, int dstIndex)", "public static final char[] toChars(int cp)", "public static byte getDirectionality(int cp)", "public static int codePointCount(CharSequence text, int start, int limit)", "public static int codePointCount(char[] text, int start, int limit)", "public static int offsetByCodePoints(CharSequence text, int index, int codePointOffset)", "public static int offsetByCodePoints(char[] text, int start, int count, int index, int codePointOffset)" ],
  "variableNames" : [ "LEAD_SURROGATE_BITMASK", "TRAIL_SURROGATE_BITMASK", "LEAD_SURROGATE_BITS", "TRAIL_SURROGATE_BITS", "U16_SURROGATE_OFFSET", "MIN_VALUE", "MAX_VALUE", "SUPPLEMENTARY_MIN_VALUE", "REPLACEMENT_CHAR", "NO_NUMERIC_VALUE", "MIN_RADIX", "MAX_RADIX", "TITLECASE_NO_LOWERCASE", "TITLECASE_NO_BREAK_ADJUSTMENT", "FOLD_CASE_DEFAULT", "FOLD_CASE_EXCLUDE_SPECIAL_I", "MIN_HIGH_SURROGATE", "MAX_HIGH_SURROGATE", "MIN_LOW_SURROGATE", "MAX_LOW_SURROGATE", "MIN_SURROGATE", "MAX_SURROGATE", "MIN_SUPPLEMENTARY_CODE_POINT", "MAX_CODE_POINT", "MIN_CODE_POINT", "LAST_CHAR_MASK_", "NO_BREAK_SPACE_", "FIGURE_SPACE_", "NARROW_NO_BREAK_SPACE_", "IDEOGRAPHIC_NUMBER_ZERO_", "CJK_IDEOGRAPH_FIRST_", "CJK_IDEOGRAPH_SECOND_", "CJK_IDEOGRAPH_THIRD_", "CJK_IDEOGRAPH_FOURTH_", "CJK_IDEOGRAPH_FIFTH_", "CJK_IDEOGRAPH_SIXTH_", "CJK_IDEOGRAPH_SEVENTH_", "CJK_IDEOGRAPH_EIGHTH_", "CJK_IDEOGRAPH_NINETH_", "APPLICATION_PROGRAM_COMMAND_", "UNIT_SEPARATOR_", "DELETE_", "CJK_IDEOGRAPH_COMPLEX_ZERO_", "CJK_IDEOGRAPH_COMPLEX_ONE_", "CJK_IDEOGRAPH_COMPLEX_TWO_", "CJK_IDEOGRAPH_COMPLEX_THREE_", "CJK_IDEOGRAPH_COMPLEX_FOUR_", "CJK_IDEOGRAPH_COMPLEX_FIVE_", "CJK_IDEOGRAPH_COMPLEX_SIX_", "CJK_IDEOGRAPH_COMPLEX_SEVEN_", "CJK_IDEOGRAPH_COMPLEX_EIGHT_", "CJK_IDEOGRAPH_COMPLEX_NINE_", "CJK_IDEOGRAPH_TEN_", "CJK_IDEOGRAPH_COMPLEX_TEN_", "CJK_IDEOGRAPH_HUNDRED_", "CJK_IDEOGRAPH_COMPLEX_HUNDRED_", "CJK_IDEOGRAPH_THOUSAND_", "CJK_IDEOGRAPH_COMPLEX_THOUSAND_", "CJK_IDEOGRAPH_TEN_THOUSAND_", "CJK_IDEOGRAPH_HUNDRED_MILLION_" ]
}