{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/os/CancellationSignalBeamer.java",
  "packageName" : "android.os",
  "className" : "CancellationSignalBeamer",
  "comment" : "\n * A transport for {@link CancellationSignal}, but unlike\n * {@link CancellationSignal#createTransport()} doesn't require pre-creating the transport in the\n * target process. Instead, cancellation is forwarded over the same IPC surface as the cancellable\n * request.\n *\n * <p><strong>Important:</strong> For this to work, the following invariants must be held up:\n * <ul>\n *     <li>A call to beam() <strong>MUST</strong> result in a call to close() on the result\n *     (otherwise, the token will be leaked and cancellation isn't propagated), and that call\n *     must happen after the call using the\n *     token is sent (otherwise, any concurrent cancellation may be lost). It is strongly\n *     recommended to use try-with-resources on the token.\n *     <li>The cancel(), forget() and cancellable operations transporting the token must either\n *     all be oneway on the same binder, or all be non-oneway to guarantee proper ordering.\n *     <li>A {@link CancellationSignal} <strong>SHOULD</strong> be used only once, as there\n *     can only be a single {@link android.os.CancellationSignal.OnCancelListener OnCancelListener}.\n *\n * </ul>\n * <p>Caveats:\n * <ul>\n *     <li>Cancellation is only ever dispatched after the token is closed, and thus after the\n *     call performing the cancellable operation (if the invariants are followed). The operation\n *     must therefore not block the incoming binder thread, or cancellation won't be possible.\n *     <li>Consequently, in the unlikely event that the sender dies right after beaming an already\n *     cancelled {@link CancellationSignal}, the cancellation may be lost (unlike with\n *     {@link CancellationSignal#createTransport()}).\n *     <li>The forwarding OnCancelListener is set in the implied finally phase of try-with-resources\n *         / when closing the token. If the receiver is in the same process, and the signal is\n *         already cancelled, this may invoke the target's OnCancelListener during that phase.\n * </ul>\n *\n *\n * <p>Usage:\n * <pre>\n *  // Sender:\n *\n *  class FooManager {\n *    var mCancellationSignalSender = new CancellationSignalBeamer.Sender() {\n *      &#064;Override\n *      public void onCancel(IBinder token) { remoteIFooService.onCancelToken(token); }\n *\n *      &#064;Override\n *      public void onForget(IBinder token) { remoteIFooService.onForgetToken(token); }\n *    };\n *\n *    public void doCancellableOperation(..., CancellationSignal cs) {\n *      try (var csToken = mCancellationSignalSender.beam(cs)) {\n *          remoteIFooService.doCancellableOperation(..., csToken);\n *      }\n *    }\n *  }\n *\n *  // Receiver:\n *\n *  class FooManagerService extends IFooService.Stub {\n *    var mCancellationSignalReceiver = new CancellationSignalBeamer.Receiver();\n *\n *    &#064;Override\n *    public void doCancellableOperation(..., IBinder csToken) {\n *      CancellationSignal cs = mCancellationSignalReceiver.unbeam(csToken))\n *      // ...\n *    }\n *\n *    &#064;Override\n *    public void onCancelToken(..., IBinder csToken) {\n *      mCancellationSignalReceiver.cancelToken(csToken))\n *    }\n *\n *    &#064;Override\n *    public void onForgetToken(..., IBinder csToken) {\n *      mCancellationSignalReceiver.forgetToken(csToken))\n *    }\n *  }\n *\n * </pre>\n *\n * @hide\n ",
  "links" : [ "android.os.CancellationSignal#createTransport()", "android.os.CancellationSignal", "android.os.CancellationSignal.OnCancelListener" ],
  "variables" : [ {
    "name" : "sCleaner",
    "type" : "Cleaner",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ ],
  "methodNames" : [ ],
  "variableNames" : [ "sCleaner" ]
}