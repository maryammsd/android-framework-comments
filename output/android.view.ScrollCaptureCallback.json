{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/view/ScrollCaptureCallback.java",
  "packageName" : "android.view",
  "className" : "ScrollCaptureCallback",
  "comment" : "\n * A ScrollCaptureCallback is responsible for providing rendered snapshots of scrolling content for\n * the scroll capture system. A single callback is responsible for providing support to a single\n * scrolling UI element. At request time, the system will select the best candidate from among all\n * callbacks registered within the window.\n * <p>\n * A callback is assigned to a View using {@link View#setScrollCaptureCallback}, or to the window as\n * {@link Window#registerScrollCaptureCallback}. The point where the callback is registered defines\n * the frame of reference for the bounds measurements used.\n * <p>\n * <b>Terminology</b>\n * <dl>\n * <dt>Containing View</dt>\n * <dd>The view on which this callback is attached, or the root view of the window if the callback\n * is assigned  directly to a window.</dd>\n *\n * <dt>Scroll Bounds</dt>\n * <dd>A rectangle which describes an area within the containing view where scrolling content\n * appears. This may be the entire view or any rectangle within. This defines a frame of reference\n * for requests as well as the width and maximum height of a single request.</dd>\n *\n * <dt>Scroll Delta</dt>\n * <dd>The distance the scroll position has moved since capture started. Implementations are\n * responsible for tracking changes in vertical scroll position during capture. This is required to\n * map the capture area to the correct location, given the current scroll position.\n *\n * <dt>Capture Area</dt>\n * <dd>A rectangle which describes the area to capture, relative to scroll bounds. The vertical\n * position remains relative to the starting scroll position and any movement since (\"Scroll Delta\")\n * should be subtracted to locate the correct local position, and scrolled into view as necessary.\n * </dd>\n * </dl>\n *\n * @see View#setScrollCaptureHint(int)\n * @see View#setScrollCaptureCallback(ScrollCaptureCallback)\n * @see Window#registerScrollCaptureCallback(ScrollCaptureCallback)\n ",
  "links" : [ "android.view.View#setScrollCaptureCallback", "android.view.Window#registerScrollCaptureCallback" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " void onScrollCaptureSearch(@NonNull CancellationSignal signal, @NonNull Consumer<Rect> onReady)",
    "returnType" : "void",
    "comment" : "\n     * The system is searching for the appropriate scrolling container to capture and would like to\n     * know the size and position of scrolling content handled by this callback.\n     * <p>\n     * To determine scroll bounds, an implementation should inset the visible bounds of the\n     * containing view to cover only the area where scrolling content may be positioned. This\n     * should cover only the content which tracks with scrolling movement.\n     * <p>\n     * Return the updated rectangle to {@link Consumer#accept onReady.accept}. If for any reason the\n     * scrolling content is not available to capture, a empty rectangle may be returned which will\n     * exclude this view from consideration.\n     * <p>\n     * This request may be cancelled via the provided {@link CancellationSignal}. When this happens,\n     * any future call to {@link Consumer#accept onReady.accept} will have no effect and this\n     * content will be omitted from the search results.\n     *\n     * @param signal  signal to cancel the operation in progress\n     * @param onReady consumer for the updated rectangle\n     ",
    "links" : [ "java.util.function.Consumer#accept", "android.os.CancellationSignal" ]
  }, {
    "name" : " void onScrollCaptureStart(@NonNull ScrollCaptureSession session, @NonNull CancellationSignal signal, @NonNull Runnable onReady)",
    "returnType" : "void",
    "comment" : "\n     * Scroll Capture has selected this callback to provide the scrolling image content.\n     * <p>\n     * {@link Runnable#run onReady.run} should be called when ready to begin handling image\n     * requests.\n     * <p>\n     * This request may be cancelled via the provided {@link CancellationSignal}. When this happens,\n     * any future call to {@link Runnable#run onReady.run} will have no effect and provided session\n     * will not be activated.\n     *\n     * @param session the current session, resources provided by it are valid for use until the\n     *                {@link #onScrollCaptureEnd(Runnable) session ends}\n     * @param signal  signal to cancel the operation in progress\n     * @param onReady signal used to report completion of the request\n     ",
    "links" : [ "android.os.CancellationSignal", "#run", "#onScrollCaptureEnd(Runnable)" ]
  }, {
    "name" : " void onScrollCaptureImageRequest(@NonNull ScrollCaptureSession session, @NonNull CancellationSignal signal, @NonNull Rect captureArea, @NonNull Consumer<Rect> onComplete)",
    "returnType" : "void",
    "comment" : "\n     * An image capture has been requested from the scrolling content.\n     * <p>\n     * The requested rectangle describes an area inside the target view, relative to\n     * <code>scrollBounds</code>. The content may be offscreen, above or below the current visible\n     * portion of the target view. To handle the request, render the available portion of this\n     * rectangle to a buffer and return it via the Surface available from {@link\n     * ScrollCaptureSession#getSurface()}.\n     * <p>\n     * Note: Implementations are only required to render the requested content, and may do so into\n     * off-screen buffers without scrolling if they are able.\n     * <p>\n     * The resulting available portion of the request must be computed as a portion of {@code\n     * captureArea}, and sent to signal the operation is complete, using  {@link Consumer#accept\n     * onComplete.accept}. If the requested rectangle is  partially or fully out of bounds the\n     * resulting portion should be returned. If no portion is available (outside of available\n     * content), then skip sending any buffer and report an empty Rect as result.\n     * <p>\n     * This request may be cancelled via the provided {@link CancellationSignal}. When this happens,\n     * any future call to {@link Consumer#accept onComplete.accept} will be ignored until the next\n     * request.\n     *\n     * @param session the current session, resources provided by it are valid for use until the\n     *                {@link #onScrollCaptureEnd(Runnable) session ends}\n     * @param signal      signal to cancel the operation in progress\n     * @param captureArea the area to capture, a rectangle within {@code scrollBounds}\n     * @param onComplete  a consumer for the captured area\n     ",
    "links" : [ "java.util.function.Consumer#accept", "android.view.ScrollCaptureSession#getSurface()", "android.os.CancellationSignal", "java.util.function.Consumer#acceptonComplete.accept", "#onScrollCaptureEnd(Runnable)" ]
  }, {
    "name" : " void onScrollCaptureEnd(@NonNull Runnable onReady)",
    "returnType" : "void",
    "comment" : "\n     * Signals that capture has ended. Implementations should release any temporary resources or\n     * references to objects in use during the capture. Any resources obtained from the session are\n     * now invalid and attempts to use them after this point may throw an exception.\n     * <p>\n     * The window should be returned to its original state when capture started. At a minimum, the\n     * content should be scrolled to its original position.\n     * <p>\n     * {@link Runnable#run onReady.run} should be called as soon as possible after the window is\n     * ready for normal interactive use. After the callback (or after a timeout, if not called) the\n     * screenshot tool will be dismissed and the window may become visible to the user at any time.\n     *\n     * @param onReady a callback to inform the system that the application has completed any\n     *                cleanup and is ready to become visible\n     ",
    "links" : [ "#run" ]
  } ],
  "methodNames" : [ " void onScrollCaptureSearch(@NonNull CancellationSignal signal, @NonNull Consumer<Rect> onReady)", " void onScrollCaptureStart(@NonNull ScrollCaptureSession session, @NonNull CancellationSignal signal, @NonNull Runnable onReady)", " void onScrollCaptureImageRequest(@NonNull ScrollCaptureSession session, @NonNull CancellationSignal signal, @NonNull Rect captureArea, @NonNull Consumer<Rect> onComplete)", " void onScrollCaptureEnd(@NonNull Runnable onReady)" ],
  "variableNames" : [ ]
}