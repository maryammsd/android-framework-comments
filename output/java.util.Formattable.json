{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/util/Formattable.java",
  "packageName" : "java.util",
  "className" : "Formattable",
  "comment" : "\n * The {@code Formattable} interface must be implemented by any class that\n * needs to perform custom formatting using the {@code 's'} conversion\n * specifier of {@link java.util.Formatter}.  This interface allows basic\n * control for formatting arbitrary objects.\n *\n * For example, the following class prints out different representations of a\n * stock's name depending on the flags and length constraints:\n *\n * <pre> {@code\n *   import java.nio.CharBuffer;\n *   import java.util.Formatter;\n *   import java.util.Formattable;\n *   import java.util.Locale;\n *   import static java.util.FormattableFlags.*;\n *\n *   ...\n *\n *   public class StockName implements Formattable {\n *       private String symbol, companyName, frenchCompanyName;\n *       public StockName(String symbol, String companyName,\n *                        String frenchCompanyName) {\n *           ...\n *       }\n *\n *       ...\n *\n *       public void formatTo(Formatter fmt, int f, int width, int precision) {\n *           StringBuilder sb = new StringBuilder();\n *\n *           // decide form of name\n *           String name = companyName;\n *           if (fmt.locale().equals(Locale.FRANCE))\n *               name = frenchCompanyName;\n *           boolean alternate = (f & ALTERNATE) == ALTERNATE;\n *           boolean usesymbol = alternate || (precision != -1 && precision < 10);\n *           String out = (usesymbol ? symbol : name);\n *\n *           // apply precision\n *           if (precision == -1 || out.length() < precision) {\n *               // write it all\n *               sb.append(out);\n *           } else {\n *               sb.append(out.substring(0, precision - 1)).append('*');\n *           }\n *\n *           // apply width and justification\n *           int len = sb.length();\n *           if (len < width)\n *               for (int i = 0; i < width - len; i++)\n *                   if ((f & LEFT_JUSTIFY) == LEFT_JUSTIFY)\n *                       sb.append(' ');\n *                   else\n *                       sb.insert(0, ' ');\n *\n *           fmt.format(sb.toString());\n *       }\n *\n *       public String toString() {\n *           return String.format(\"%s - %s\", symbol, companyName);\n *       }\n *   }\n * }</pre>\n *\n * <p> When used in conjunction with the {@link java.util.Formatter}, the above\n * class produces the following output for various format strings.\n *\n * <pre> {@code\n *   Formatter fmt = new Formatter();\n *   StockName sn = new StockName(\"HUGE\", \"Huge Fruit, Inc.\",\n *                                \"Fruit Titanesque, Inc.\");\n *   fmt.format(\"%s\", sn);                   //   -> \"Huge Fruit, Inc.\"\n *   fmt.format(\"%s\", sn.toString());        //   -> \"HUGE - Huge Fruit, Inc.\"\n *   fmt.format(\"%#s\", sn);                  //   -> \"HUGE\"\n *   fmt.format(\"%-10.8s\", sn);              //   -> \"HUGE      \"\n *   fmt.format(\"%.12s\", sn);                //   -> \"Huge Fruit,*\"\n *   fmt.format(Locale.FRANCE, \"%25s\", sn);  //   -> \"   Fruit Titanesque, Inc.\"\n * }</pre>\n *\n * <p> Formattables are not necessarily safe for multithreaded access.  Thread\n * safety is optional and may be enforced by classes that extend and implement\n * this interface.\n *\n * <p> Unless otherwise specified, passing a {@code null} argument to\n * any method in this interface will cause a {@link\n * NullPointerException} to be thrown.\n *\n * @since  1.5\n ",
  "links" : [ "NullPointerException", "java.util.Formatter" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " void formatTo(Formatter formatter, int flags, int width, int precision)",
    "returnType" : "void",
    "comment" : "\n     * Formats the object using the provided {@link Formatter formatter}.\n     *\n     * @param  formatter\n     *         The {@link Formatter formatter}.  Implementing classes may call\n     *         {@link Formatter#out() formatter.out()} or {@link\n     *         Formatter#locale() formatter.locale()} to obtain the {@link\n     *         Appendable} or {@link Locale} used by this\n     *         {@code formatter} respectively.\n     *\n     * @param  flags\n     *         The flags modify the output format.  The value is interpreted as\n     *         a bitmask.  Any combination of the following flags may be set:\n     *         {@link FormattableFlags#LEFT_JUSTIFY}, {@link\n     *         FormattableFlags#UPPERCASE}, and {@link\n     *         FormattableFlags#ALTERNATE}.  If no flags are set, the default\n     *         formatting of the implementing class will apply.\n     *\n     * @param  width\n     *         The minimum number of characters to be written to the output.\n     *         If the length of the converted value is less than the\n     *         {@code width} then the output will be padded by\n     *         <code>'&nbsp;&nbsp;'</code> until the total number of characters\n     *         equals width.  The padding is at the beginning by default.  If\n     *         the {@link FormattableFlags#LEFT_JUSTIFY} flag is set then the\n     *         padding will be at the end.  If {@code width} is {@code -1}\n     *         then there is no minimum.\n     *\n     * @param  precision\n     *         The maximum number of characters to be written to the output.\n     *         The precision is applied before the width, thus the output will\n     *         be truncated to {@code precision} characters even if the\n     *         {@code width} is greater than the {@code precision}.  If\n     *         {@code precision} is {@code -1} then there is no explicit\n     *         limit on the number of characters.\n     *\n     * @throws  IllegalFormatException\n     *          If any of the parameters are invalid.  For specification of all\n     *          possible formatting errors, see the <a\n     *          href=\"../util/Formatter.html#detail\">Details</a> section of the\n     *          formatter class specification.\n     ",
    "links" : [ "java.util.FormattableFlags#UPPERCASE", "java.util.Locale", "java.util.Formatter#locale()", "Appendable", "java.util.FormattableFlags#LEFT_JUSTIFY", "java.util.FormattableFlags#ALTERNATE", "java.util.Formatter#out()", "java.util.Formatter" ]
  } ],
  "methodNames" : [ " void formatTo(Formatter formatter, int flags, int width, int precision)" ],
  "variableNames" : [ ]
}