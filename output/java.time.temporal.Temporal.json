{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/time/temporal/Temporal.java",
  "packageName" : "java.time.temporal",
  "className" : "Temporal",
  "comment" : "\n * Framework-level interface defining read-write access to a temporal object,\n * such as a date, time, offset or some combination of these.\n * <p>\n * This is the base interface type for date, time and offset objects that\n * are complete enough to be manipulated using plus and minus.\n * It is implemented by those classes that can provide and manipulate information\n * as {@linkplain TemporalField fields} or {@linkplain TemporalQuery queries}.\n * See {@link TemporalAccessor} for the read-only version of this interface.\n * <p>\n * Most date and time information can be represented as a number.\n * These are modeled using {@code TemporalField} with the number held using\n * a {@code long} to handle large values. Year, month and day-of-month are\n * simple examples of fields, but they also include instant and offsets.\n * See {@link ChronoField} for the standard set of fields.\n * <p>\n * Two pieces of date/time information cannot be represented by numbers,\n * the {@linkplain java.time.chrono.Chronology chronology} and the\n * {@linkplain java.time.ZoneId time-zone}.\n * These can be accessed via {@link #query(TemporalQuery) queries} using\n * the static methods defined on {@link TemporalQuery}.\n * <p>\n * This interface is a framework-level interface that should not be widely\n * used in application code. Instead, applications should create and pass\n * around instances of concrete types, such as {@code LocalDate}.\n * There are many reasons for this, part of which is that implementations\n * of this interface may be in calendar systems other than ISO.\n * See {@link java.time.chrono.ChronoLocalDate} for a fuller discussion of the issues.\n *\n * <h2>When to implement</h2>\n * <p>\n * A class should implement this interface if it meets three criteria:\n * <ul>\n * <li>it provides access to date/time/offset information, as per {@code TemporalAccessor}\n * <li>the set of fields are contiguous from the largest to the smallest\n * <li>the set of fields are complete, such that no other field is needed to define the\n *  valid range of values for the fields that are represented\n * </ul>\n * <p>\n * Four examples make this clear:\n * <ul>\n * <li>{@code LocalDate} implements this interface as it represents a set of fields\n *  that are contiguous from days to forever and require no external information to determine\n *  the validity of each date. It is therefore able to implement plus/minus correctly.\n * <li>{@code LocalTime} implements this interface as it represents a set of fields\n *  that are contiguous from nanos to within days and require no external information to determine\n *  validity. It is able to implement plus/minus correctly, by wrapping around the day.\n * <li>{@code MonthDay}, the combination of month-of-year and day-of-month, does not implement\n *  this interface.  While the combination is contiguous, from days to months within years,\n *  the combination does not have sufficient information to define the valid range of values\n *  for day-of-month.  As such, it is unable to implement plus/minus correctly.\n * <li>The combination day-of-week and day-of-month (\"Friday the 13th\") should not implement\n *  this interface. It does not represent a contiguous set of fields, as days to weeks overlaps\n *  days to months.\n * </ul>\n *\n * @implSpec\n * This interface places no restrictions on the mutability of implementations,\n * however immutability is strongly recommended.\n * All implementations must be {@link Comparable}.\n *\n * @since 1.8\n ",
  "links" : [ "java.time.temporal.ChronoField", "java.time.chrono.ChronoLocalDate", "Comparable", "java.time.temporal.TemporalQuery", "#query(TemporalQuery)", "java.time.temporal.TemporalAccessor" ],
  "variables" : [ ],
  "methods" : [ {
    "name" : " boolean isSupported(TemporalUnit unit)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the specified unit is supported.\n     * <p>\n     * This checks if the specified unit can be added to, or subtracted from, this date-time.\n     * If false, then calling the {@link #plus(long, TemporalUnit)} and\n     * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.\n     *\n     * @implSpec\n     * Implementations must check and handle all units defined in {@link ChronoUnit}.\n     * If the unit is supported, then true must be returned, otherwise false must be returned.\n     * <p>\n     * If the field is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}\n     * passing {@code this} as the argument.\n     * <p>\n     * Implementations must ensure that no observable state is altered when this\n     * read-only method is invoked.\n     *\n     * @param unit  the unit to check, null returns false\n     * @return true if the unit can be added/subtracted, false if not\n     ",
    "links" : [ "#plus(long", "java.time.temporal.ChronoUnit", "#minus(long" ]
  }, {
    "name" : " Temporal with(TemporalAdjuster adjuster)",
    "returnType" : "Temporal",
    "comment" : "\n     * Returns an adjusted object of the same type as this object with the adjustment made.\n     * <p>\n     * This adjusts this date-time according to the rules of the specified adjuster.\n     * A simple adjuster might simply set the one of the fields, such as the year field.\n     * A more complex adjuster might set the date to the last day of the month.\n     * A selection of common adjustments is provided in\n     * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.\n     * These include finding the \"last day of the month\" and \"next Wednesday\".\n     * The adjuster is responsible for handling special cases, such as the varying\n     * lengths of month and leap years.\n     * <p>\n     * Some example code indicating how and why this method is used:\n     * <pre>\n     *  date = date.with(Month.JULY);        // most key classes implement TemporalAdjuster\n     *  date = date.with(lastDayOfMonth());  // static import from Adjusters\n     *  date = date.with(next(WEDNESDAY));   // static import from Adjusters and DayOfWeek\n     * </pre>\n     *\n     * @implSpec\n     * <p>\n     * Implementations must not alter either this object or the specified temporal object.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable implementations.\n     * <p>\n     * The default implementation must behave equivalent to this code:\n     * <pre>\n     *  return adjuster.adjustInto(this);\n     * </pre>\n     *\n     * @param adjuster  the adjuster to use, not null\n     * @return an object of the same type with the specified adjustment made, not null\n     * @throws DateTimeException if unable to make the adjustment\n     * @throws ArithmeticException if numeric overflow occurs\n     ",
    "links" : [ "java.time.temporal.TemporalAdjusters" ]
  }, {
    "name" : " Temporal with(TemporalField field, long newValue)",
    "returnType" : "Temporal",
    "comment" : "\n     * Returns an object of the same type as this object with the specified field altered.\n     * <p>\n     * This returns a new object based on this one with the value for the specified field changed.\n     * For example, on a {@code LocalDate}, this could be used to set the year, month or day-of-month.\n     * The returned object will have the same observable type as this object.\n     * <p>\n     * In some cases, changing a field is not fully defined. For example, if the target object is\n     * a date representing the 31st January, then changing the month to February would be unclear.\n     * In cases like this, the field is responsible for resolving the result. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     *\n     * @implSpec\n     * Implementations must check and handle all fields defined in {@link ChronoField}.\n     * If the field is supported, then the adjustment must be performed.\n     * If unsupported, then an {@code UnsupportedTemporalTypeException} must be thrown.\n     * <p>\n     * If the field is not a {@code ChronoField}, then the result of this method\n     * is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}\n     * passing {@code this} as the first argument.\n     * <p>\n     * Implementations must not alter this object.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable implementations.\n     *\n     * @param field  the field to set in the result, not null\n     * @param newValue  the new value of the field in the result\n     * @return an object of the same type with the specified field set, not null\n     * @throws DateTimeException if the field cannot be set\n     * @throws UnsupportedTemporalTypeException if the field is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     ",
    "links" : [ "java.time.temporal.ChronoField" ]
  }, {
    "name" : " Temporal plus(TemporalAmount amount)",
    "returnType" : "Temporal",
    "comment" : "\n     * Returns an object of the same type as this object with an amount added.\n     * <p>\n     * This adjusts this temporal, adding according to the rules of the specified amount.\n     * The amount is typically a {@link java.time.Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface, such as {@link java.time.Duration}.\n     * <p>\n     * Some example code indicating how and why this method is used:\n     * <pre>\n     *  date = date.plus(period);                // add a Period instance\n     *  date = date.plus(duration);              // add a Duration instance\n     *  date = date.plus(workingDays(6));        // example user-written workingDays method\n     * </pre>\n     * <p>\n     * Note that calling {@code plus} followed by {@code minus} is not guaranteed to\n     * return the same date-time.\n     *\n     * @implSpec\n     * <p>\n     * Implementations must not alter either this object or the specified temporal object.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable implementations.\n     * <p>\n     * The default implementation must behave equivalent to this code:\n     * <pre>\n     *  return amount.addTo(this);\n     * </pre>\n     *\n     * @param amount  the amount to add, not null\n     * @return an object of the same type with the specified adjustment made, not null\n     * @throws DateTimeException if the addition cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     ",
    "links" : [ "java.time.Period", "java.time.Duration", "java.time.temporal.TemporalAmount" ]
  }, {
    "name" : " Temporal plus(long amountToAdd, TemporalUnit unit)",
    "returnType" : "Temporal",
    "comment" : "\n     * Returns an object of the same type as this object with the specified period added.\n     * <p>\n     * This method returns a new object based on this one with the specified period added.\n     * For example, on a {@code LocalDate}, this could be used to add a number of years, months or days.\n     * The returned object will have the same observable type as this object.\n     * <p>\n     * In some cases, changing a field is not fully defined. For example, if the target object is\n     * a date representing the 31st January, then adding one month would be unclear.\n     * In cases like this, the field is responsible for resolving the result. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     *\n     * @implSpec\n     * Implementations must check and handle all units defined in {@link ChronoUnit}.\n     * If the unit is supported, then the addition must be performed.\n     * If unsupported, then an {@code UnsupportedTemporalTypeException} must be thrown.\n     * <p>\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}\n     * passing {@code this} as the first argument.\n     * <p>\n     * Implementations must not alter this object.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable implementations.\n     *\n     * @param amountToAdd  the amount of the specified unit to add, may be negative\n     * @param unit  the unit of the amount to add, not null\n     * @return an object of the same type with the specified period added, not null\n     * @throws DateTimeException if the unit cannot be added\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     ",
    "links" : [ "java.time.temporal.ChronoUnit" ]
  }, {
    "name" : " Temporal minus(TemporalAmount amount)",
    "returnType" : "Temporal",
    "comment" : "\n     * Returns an object of the same type as this object with an amount subtracted.\n     * <p>\n     * This adjusts this temporal, subtracting according to the rules of the specified amount.\n     * The amount is typically a {@link java.time.Period} but may be any other type implementing\n     * the {@link TemporalAmount} interface, such as {@link java.time.Duration}.\n     * <p>\n     * Some example code indicating how and why this method is used:\n     * <pre>\n     *  date = date.minus(period);               // subtract a Period instance\n     *  date = date.minus(duration);             // subtract a Duration instance\n     *  date = date.minus(workingDays(6));       // example user-written workingDays method\n     * </pre>\n     * <p>\n     * Note that calling {@code plus} followed by {@code minus} is not guaranteed to\n     * return the same date-time.\n     *\n     * @implSpec\n     * <p>\n     * Implementations must not alter either this object or the specified temporal object.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable implementations.\n     * <p>\n     * The default implementation must behave equivalent to this code:\n     * <pre>\n     *  return amount.subtractFrom(this);\n     * </pre>\n     *\n     * @param amount  the amount to subtract, not null\n     * @return an object of the same type with the specified adjustment made, not null\n     * @throws DateTimeException if the subtraction cannot be made\n     * @throws ArithmeticException if numeric overflow occurs\n     ",
    "links" : [ "java.time.Period", "java.time.Duration", "java.time.temporal.TemporalAmount" ]
  }, {
    "name" : " Temporal minus(long amountToSubtract, TemporalUnit unit)",
    "returnType" : "Temporal",
    "comment" : "\n     * Returns an object of the same type as this object with the specified period subtracted.\n     * <p>\n     * This method returns a new object based on this one with the specified period subtracted.\n     * For example, on a {@code LocalDate}, this could be used to subtract a number of years, months or days.\n     * The returned object will have the same observable type as this object.\n     * <p>\n     * In some cases, changing a field is not fully defined. For example, if the target object is\n     * a date representing the 31st March, then subtracting one month would be unclear.\n     * In cases like this, the field is responsible for resolving the result. Typically it will choose\n     * the previous valid date, which would be the last valid day of February in this example.\n     *\n     * @implSpec\n     * Implementations must behave in a manor equivalent to the default method behavior.\n     * <p>\n     * Implementations must not alter this object.\n     * Instead, an adjusted copy of the original must be returned.\n     * This provides equivalent, safe behavior for immutable and mutable implementations.\n     * <p>\n     * The default implementation must behave equivalent to this code:\n     * <pre>\n     *  return (amountToSubtract == Long.MIN_VALUE ?\n     *      plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));\n     * </pre>\n     *\n     * @param amountToSubtract  the amount of the specified unit to subtract, may be negative\n     * @param unit  the unit of the amount to subtract, not null\n     * @return an object of the same type with the specified period subtracted, not null\n     * @throws DateTimeException if the unit cannot be subtracted\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     ",
    "links" : [ ]
  }, {
    "name" : " long until(Temporal endExclusive, TemporalUnit unit)",
    "returnType" : "long",
    "comment" : "\n     * Calculates the amount of time until another temporal in terms of the specified unit.\n     * <p>\n     * This calculates the amount of time between two temporal objects\n     * in terms of a single {@code TemporalUnit}.\n     * The start and end points are {@code this} and the specified temporal.\n     * The end point is converted to be of the same type as the start point if different.\n     * The result will be negative if the end is before the start.\n     * For example, the amount in hours between two temporal objects can be\n     * calculated using {@code startTime.until(endTime, HOURS)}.\n     * <p>\n     * The calculation returns a whole number, representing the number of\n     * complete units between the two temporals.\n     * For example, the amount in hours between the times 11:30 and 13:29\n     * will only be one hour as it is one minute short of two hours.\n     * <p>\n     * There are two equivalent ways of using this method.\n     * The first is to invoke this method directly.\n     * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:\n     * <pre>\n     *   // these two lines are equivalent\n     *   temporal = start.until(end, unit);\n     *   temporal = unit.between(start, end);\n     * </pre>\n     * The choice should be made based on which makes the code more readable.\n     * <p>\n     * For example, this method allows the number of days between two dates to\n     * be calculated:\n     * <pre>\n     *  long daysBetween = start.until(end, DAYS);\n     *  // or alternatively\n     *  long daysBetween = DAYS.between(start, end);\n     * </pre>\n     *\n     * @implSpec\n     * Implementations must begin by checking to ensure that the input temporal\n     * object is of the same observable type as the implementation.\n     * They must then perform the calculation for all instances of {@link ChronoUnit}.\n     * An {@code UnsupportedTemporalTypeException} must be thrown for {@code ChronoUnit}\n     * instances that are unsupported.\n     * <p>\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the converted input temporal as\n     * the second argument.\n     * <p>\n     * In summary, implementations must behave in a manner equivalent to this pseudo-code:\n     * <pre>\n     *  // convert the end temporal to the same type as this class\n     *  if (unit instanceof ChronoUnit) {\n     *    // if unit is supported, then calculate and return result\n     *    // else throw UnsupportedTemporalTypeException for unsupported units\n     *  }\n     *  return unit.between(this, convertedEndTemporal);\n     * </pre>\n     * <p>\n     * Note that the unit's {@code between} method must only be invoked if the\n     * two temporal objects have exactly the same type evaluated by {@code getClass()}.\n     * <p>\n     * Implementations must ensure that no observable state is altered when this\n     * read-only method is invoked.\n     *\n     * @param endExclusive  the end temporal, exclusive, converted to be of the\n     *  same type as this object, not null\n     * @param unit  the unit to measure the amount in, not null\n     * @return the amount of time between this temporal object and the specified one\n     *  in terms of the unit; positive if the specified object is later than this one,\n     *  negative if it is earlier than this one\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to the same type as this temporal\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     ",
    "links" : [ "java.time.temporal.ChronoUnit", "java.time.temporal.TemporalUnit#between(Temporal" ]
  } ],
  "methodNames" : [ " boolean isSupported(TemporalUnit unit)", " Temporal with(TemporalAdjuster adjuster)", " Temporal with(TemporalField field, long newValue)", " Temporal plus(TemporalAmount amount)", " Temporal plus(long amountToAdd, TemporalUnit unit)", " Temporal minus(TemporalAmount amount)", " Temporal minus(long amountToSubtract, TemporalUnit unit)", " long until(Temporal endExclusive, TemporalUnit unit)" ],
  "variableNames" : [ ]
}