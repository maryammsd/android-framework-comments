{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/net/wifi/WifiManager.java",
  "packageName" : "android.net.wifi",
  "className" : "WifiManager",
  "comment" : "\n * This class provides the primary API for managing all aspects of Wi-Fi\n * connectivity.\n * <p>\n * On releases before {@link android.os.Build.VERSION_CODES#N}, this object\n * should only be obtained from an {@linkplain Context#getApplicationContext()\n * application context}, and not from any other derived context to avoid memory\n * leaks within the calling process.\n * <p>\n * It deals with several categories of items:\n * </p>\n * <ul>\n * <li>The list of configured networks. The list can be viewed and updated, and\n * attributes of individual entries can be modified.</li>\n * <li>The currently active Wi-Fi network, if any. Connectivity can be\n * established or torn down, and dynamic information about the state of the\n * network can be queried.</li>\n * <li>Results of access point scans, containing enough information to make\n * decisions about what access point to connect to.</li>\n * <li>It defines the names of various Intent actions that are broadcast upon\n * any sort of change in Wi-Fi state.\n * </ul>\n * <p>\n * This is the API to use when performing Wi-Fi specific operations. To perform\n * operations that pertain to network connectivity at an abstract level, use\n * {@link android.net.ConnectivityManager}.\n * </p>\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ERROR_AUTHENTICATING",
    "type" : "int",
    "comment" : "\n     * The error code if there was a problem authenticating.\n     * @deprecated This is no longer supported.\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_AUTH_FAILURE_NONE",
    "type" : "int",
    "comment" : "\n     * The reason code if there is no error during authentication.\n     * It could also imply that there no authentication in progress,\n     * this reason code also serves as a reset value.\n     * @deprecated This is no longer supported.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_AUTH_FAILURE_TIMEOUT",
    "type" : "int",
    "comment" : "\n     * The reason code if there was a timeout authenticating.\n     * @deprecated This is no longer supported.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_AUTH_FAILURE_WRONG_PSWD",
    "type" : "int",
    "comment" : "\n     * The reason code if there was a wrong password while\n     * authenticating.\n     * @deprecated This is no longer supported.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_AUTH_FAILURE_EAP_FAILURE",
    "type" : "int",
    "comment" : "\n     * The reason code if there was EAP failure while\n     * authenticating.\n     * @deprecated This is no longer supported.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_SUGGESTIONS_MAX_PER_APP_LOW_RAM",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_SUGGESTIONS_MAX_PER_APP_HIGH_RAM",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "STATUS_NETWORK_SUGGESTIONS_SUCCESS",
    "type" : "int",
    "comment" : "\n     * Reason code if all of the network suggestions were successfully added or removed.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_NETWORK_SUGGESTIONS_ERROR_INTERNAL",
    "type" : "int",
    "comment" : "\n     * Reason code if there was an internal error in the platform while processing the addition or\n     * removal of suggestions.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_NETWORK_SUGGESTIONS_ERROR_APP_DISALLOWED",
    "type" : "int",
    "comment" : "\n     * Reason code if the user has disallowed \"android:change_wifi_state\" app-ops from the app.\n     * @see android.app.AppOpsManager#unsafeCheckOp(String, int, String).\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_NETWORK_SUGGESTIONS_ERROR_ADD_DUPLICATE",
    "type" : "int",
    "comment" : "\n     * Reason code if one or more of the network suggestions added already exists in platform's\n     * database.\n     * Note: this code will not be returned with Android 11 as in-place modification is allowed,\n     * please check {@link #addNetworkSuggestions(List)}.\n     * @see WifiNetworkSuggestion#equals(Object)\n     ",
    "links" : [ "#addNetworkSuggestions" ]
  }, {
    "name" : "STATUS_NETWORK_SUGGESTIONS_ERROR_ADD_EXCEEDS_MAX_PER_APP",
    "type" : "int",
    "comment" : "\n     * Reason code if the number of network suggestions provided by the app crosses the max\n     * threshold set per app.\n     * The framework will reject all suggestions provided by {@link #addNetworkSuggestions(List)} if\n     * the total size exceeds the limit.\n     * @see #getMaxNumberOfNetworkSuggestionsPerApp()\n     ",
    "links" : [ "#addNetworkSuggestions" ]
  }, {
    "name" : "STATUS_NETWORK_SUGGESTIONS_ERROR_REMOVE_INVALID",
    "type" : "int",
    "comment" : "\n     * Reason code if one or more of the network suggestions removed does not exist in platform's\n     * database.\n     * The framework won't remove any suggestions if one or more of suggestions provided\n     * by {@link #removeNetworkSuggestions(List)} does not exist in database.\n     * @see WifiNetworkSuggestion#equals(Object)\n     ",
    "links" : [ "#removeNetworkSuggestions" ]
  }, {
    "name" : "STATUS_NETWORK_SUGGESTIONS_ERROR_ADD_NOT_ALLOWED",
    "type" : "int",
    "comment" : "\n     * Reason code if one or more of the network suggestions added is not allowed.\n     * The framework will reject all suggestions provided by {@link #addNetworkSuggestions(List)}\n     * if one or more of them is not allowed.\n     * This error may be caused by suggestion is using SIM-based encryption method, but calling app\n     * is not carrier privileged.\n     ",
    "links" : [ "#addNetworkSuggestions" ]
  }, {
    "name" : "STATUS_NETWORK_SUGGESTIONS_ERROR_ADD_INVALID",
    "type" : "int",
    "comment" : "\n     * Reason code if one or more of the network suggestions added is invalid. Framework will reject\n     * all the suggestions in the list.\n     * The framework will reject all suggestions provided by {@link #addNetworkSuggestions(List)}\n     * if one or more of them is invalid.\n     * Please use {@link WifiNetworkSuggestion.Builder} to create network suggestions.\n     ",
    "links" : [ "#addNetworkSuggestions", "WifiNetworkSuggestion.Builder" ]
  }, {
    "name" : "STATUS_SUGGESTION_CONNECTION_FAILURE_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Reason code if suggested network connection attempt failed with an unknown failure.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_SUGGESTION_CONNECTION_FAILURE_ASSOCIATION",
    "type" : "int",
    "comment" : "\n     * Reason code if suggested network connection attempt failed with association failure.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_SUGGESTION_CONNECTION_FAILURE_AUTHENTICATION",
    "type" : "int",
    "comment" : "\n     * Reason code if suggested network connection attempt failed with an authentication failure.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_SUGGESTION_CONNECTION_FAILURE_IP_PROVISIONING",
    "type" : "int",
    "comment" : "\n     * Reason code if suggested network connection attempt failed with an IP provision failure.\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_WIFI_SCAN_AVAILABILITY_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating whether Wi-Fi scanning is currently available.\n     * Available extras:\n     * - {@link #EXTRA_SCAN_AVAILABLE}\n     ",
    "links" : [ "#EXTRA_SCAN_AVAILABLE" ]
  }, {
    "name" : "EXTRA_SCAN_AVAILABLE",
    "type" : "String",
    "comment" : "\n     * A boolean extra indicating whether scanning is currently available.\n     * Sent in the broadcast {@link #ACTION_WIFI_SCAN_AVAILABILITY_CHANGED}.\n     * Its value is true if scanning is currently available, false otherwise.\n     ",
    "links" : [ "#ACTION_WIFI_SCAN_AVAILABILITY_CHANGED" ]
  }, {
    "name" : "WIFI_CREDENTIAL_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that the credential of a Wi-Fi network\n     * has been changed. One extra provides the ssid of the network. Another\n     * extra provides the event type, whether the credential is saved or forgot.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_WIFI_CREDENTIAL_EVENT_TYPE",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_WIFI_CREDENTIAL_SSID",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "WIFI_CREDENTIAL_SAVED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "WIFI_CREDENTIAL_FORGOT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "PASSPOINT_HOME_NETWORK",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "PASSPOINT_ROAMING_NETWORK",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ACTION_PASSPOINT_ICON",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that a Passpoint provider icon has been received.\n     *\n     * Included extras:\n     * {@link #EXTRA_BSSID_LONG}\n     * {@link #EXTRA_FILENAME}\n     * {@link #EXTRA_ICON}\n     *\n     * Receiver Required Permission: android.Manifest.permission.ACCESS_WIFI_STATE\n     *\n     * <p>Note: The broadcast is only delivered to registered receivers - no manifest registered\n     * components will be launched.\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_BSSID_LONG", "#EXTRA_FILENAME", "#EXTRA_ICON" ]
  }, {
    "name" : "EXTRA_BSSID_LONG",
    "type" : "String",
    "comment" : "\n     * BSSID of an AP in long representation.  The {@link #EXTRA_BSSID} contains BSSID in\n     * String representation.\n     *\n     * Retrieve with {@link android.content.Intent#getLongExtra(String, long)}.\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_BSSID", "android.content.Intent#getLongExtra" ]
  }, {
    "name" : "EXTRA_ICON",
    "type" : "String",
    "comment" : "\n     * Icon data.\n     *\n     * Retrieve with {@link android.content.Intent#getParcelableExtra(String)} and cast into\n     * {@link android.graphics.drawable.Icon}.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Intent#getParcelableExtra", "android.graphics.drawable.Icon" ]
  }, {
    "name" : "EXTRA_FILENAME",
    "type" : "String",
    "comment" : "\n     * Name of a file.\n     *\n     * Retrieve with {@link android.content.Intent#getStringExtra(String)}.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Intent#getStringExtra" ]
  }, {
    "name" : "ACTION_PASSPOINT_OSU_PROVIDERS_LIST",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating a Passpoint OSU Providers List element has been received.\n     *\n     * Included extras:\n     * {@link #EXTRA_BSSID_LONG}\n     * {@link #EXTRA_ANQP_ELEMENT_DATA}\n     *\n     * Receiver Required Permission: android.Manifest.permission.ACCESS_WIFI_STATE\n     *\n     * <p>Note: The broadcast is only delivered to registered receivers - no manifest registered\n     * components will be launched.\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_BSSID_LONG", "#EXTRA_ANQP_ELEMENT_DATA" ]
  }, {
    "name" : "EXTRA_ANQP_ELEMENT_DATA",
    "type" : "String",
    "comment" : "\n     * Raw binary data of an ANQP (Access Network Query Protocol) element.\n     *\n     * Retrieve with {@link android.content.Intent#getByteArrayExtra(String)}.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Intent#getByteArrayExtra" ]
  }, {
    "name" : "ACTION_PASSPOINT_DEAUTH_IMMINENT",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that a Passpoint Deauth Imminent frame has been received.\n     *\n     * Included extras:\n     * {@link #EXTRA_BSSID_LONG}\n     * {@link #EXTRA_ESS}\n     * {@link #EXTRA_DELAY}\n     * {@link #EXTRA_URL}\n     *\n     * Receiver Required Permission: android.Manifest.permission.ACCESS_WIFI_STATE\n     *\n     * <p>Note: The broadcast is only delivered to registered receivers - no manifest registered\n     * components will be launched.\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_BSSID_LONG", "#EXTRA_ESS", "#EXTRA_DELAY", "#EXTRA_URL" ]
  }, {
    "name" : "EXTRA_ESS",
    "type" : "String",
    "comment" : "\n     * Flag indicating BSS (Basic Service Set) or ESS (Extended Service Set). This will be set to\n     * {@code true} for ESS.\n     *\n     * Retrieve with {@link android.content.Intent#getBooleanExtra(String, boolean)}.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Intent#getBooleanExtra" ]
  }, {
    "name" : "EXTRA_DELAY",
    "type" : "String",
    "comment" : "\n     * Delay in seconds.\n     *\n     * Retrieve with {@link android.content.Intent#getIntExtra(String, int)}.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Intent#getIntExtra" ]
  }, {
    "name" : "ACTION_PASSPOINT_SUBSCRIPTION_REMEDIATION",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating a Passpoint subscription remediation frame has been\n     * received.\n     *\n     * Included extras:\n     * {@link #EXTRA_BSSID_LONG}\n     * {@link #EXTRA_SUBSCRIPTION_REMEDIATION_METHOD}\n     * {@link #EXTRA_URL}\n     *\n     * Receiver Required Permission: android.Manifest.permission.ACCESS_WIFI_STATE\n     *\n     * <p>Note: The broadcast is only delivered to registered receivers - no manifest registered\n     * components will be launched.\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_BSSID_LONG", "#EXTRA_SUBSCRIPTION_REMEDIATION_METHOD", "#EXTRA_URL" ]
  }, {
    "name" : "EXTRA_SUBSCRIPTION_REMEDIATION_METHOD",
    "type" : "String",
    "comment" : "\n     * The protocol supported by the subscription remediation server. The possible values are:\n     * 0 - OMA DM\n     * 1 - SOAP XML SPP\n     *\n     * Retrieve with {@link android.content.Intent#getIntExtra(String, int)}.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Intent#getIntExtra" ]
  }, {
    "name" : "ACTION_PASSPOINT_LAUNCH_OSU_VIEW",
    "type" : "String",
    "comment" : "\n     * Activity Action: Receiver should launch Passpoint OSU (Online Sign Up) view.\n     * Included extras:\n     *\n     * {@link #EXTRA_OSU_NETWORK}: {@link Network} instance associated with OSU AP.\n     * {@link #EXTRA_URL}: String representation of a server URL used for OSU process.\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_OSU_NETWORK", "Network", "#EXTRA_URL" ]
  }, {
    "name" : "EXTRA_OSU_NETWORK",
    "type" : "String",
    "comment" : "\n     * The lookup key for a {@link android.net.Network} associated with a Passpoint OSU server.\n     * Included in the {@link #ACTION_PASSPOINT_LAUNCH_OSU_VIEW} broadcast.\n     *\n     * Retrieve with {@link android.content.Intent#getParcelableExtra(String)}.\n     *\n     * @hide\n     ",
    "links" : [ "android.net.Network", "#ACTION_PASSPOINT_LAUNCH_OSU_VIEW", "android.content.Intent#getParcelableExtra" ]
  }, {
    "name" : "EXTRA_URL",
    "type" : "String",
    "comment" : "\n     * String representation of an URL for Passpoint OSU.\n     * Included in the {@link #ACTION_PASSPOINT_LAUNCH_OSU_VIEW} broadcast.\n     *\n     * Retrieve with {@link android.content.Intent#getStringExtra(String)}.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_PASSPOINT_LAUNCH_OSU_VIEW", "android.content.Intent#getStringExtra" ]
  }, {
    "name" : "WIFI_STATE_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that Wi-Fi has been enabled, disabled,\n     * enabling, disabling, or unknown. One extra provides this state as an int.\n     * Another extra provides the previous state, if available.  No network-related\n     * permissions are required to subscribe to this broadcast.\n     *\n     * <p class=\"note\">This broadcast is not delivered to manifest receivers in\n     * applications that target API version 26 or later.\n     *\n     * @see #EXTRA_WIFI_STATE\n     * @see #EXTRA_PREVIOUS_WIFI_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_WIFI_STATE",
    "type" : "String",
    "comment" : "\n     * The lookup key for an int that indicates whether Wi-Fi is enabled,\n     * disabled, enabling, disabling, or unknown.  Retrieve it with\n     * {@link android.content.Intent#getIntExtra(String,int)}.\n     *\n     * @see #WIFI_STATE_DISABLED\n     * @see #WIFI_STATE_DISABLING\n     * @see #WIFI_STATE_ENABLED\n     * @see #WIFI_STATE_ENABLING\n     * @see #WIFI_STATE_UNKNOWN\n     ",
    "links" : [ "android.content.Intent#getIntExtra" ]
  }, {
    "name" : "EXTRA_PREVIOUS_WIFI_STATE",
    "type" : "String",
    "comment" : "\n     * The previous Wi-Fi state.\n     *\n     * @see #EXTRA_WIFI_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_STATE_DISABLING",
    "type" : "int",
    "comment" : "\n     * Wi-Fi is currently being disabled. The state will change to {@link #WIFI_STATE_DISABLED} if\n     * it finishes successfully.\n     *\n     * @see #WIFI_STATE_CHANGED_ACTION\n     * @see #getWifiState()\n     ",
    "links" : [ "#WIFI_STATE_DISABLED" ]
  }, {
    "name" : "WIFI_STATE_DISABLED",
    "type" : "int",
    "comment" : "\n     * Wi-Fi is disabled.\n     *\n     * @see #WIFI_STATE_CHANGED_ACTION\n     * @see #getWifiState()\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_STATE_ENABLING",
    "type" : "int",
    "comment" : "\n     * Wi-Fi is currently being enabled. The state will change to {@link #WIFI_STATE_ENABLED} if\n     * it finishes successfully.\n     *\n     * @see #WIFI_STATE_CHANGED_ACTION\n     * @see #getWifiState()\n     ",
    "links" : [ "#WIFI_STATE_ENABLED" ]
  }, {
    "name" : "WIFI_STATE_ENABLED",
    "type" : "int",
    "comment" : "\n     * Wi-Fi is enabled.\n     *\n     * @see #WIFI_STATE_CHANGED_ACTION\n     * @see #getWifiState()\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_STATE_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Wi-Fi is in an unknown state. This state will occur when an error happens while enabling\n     * or disabling.\n     *\n     * @see #WIFI_STATE_CHANGED_ACTION\n     * @see #getWifiState()\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_AP_STATE_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that Wi-Fi AP has been enabled, disabled,\n     * enabling, disabling, or failed.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_WIFI_AP_STATE",
    "type" : "String",
    "comment" : "\n     * The lookup key for an int that indicates whether Wi-Fi AP is enabled,\n     * disabled, enabling, disabling, or failed.  Retrieve it with\n     * {@link android.content.Intent#getIntExtra(String,int)}.\n     *\n     * @see #WIFI_AP_STATE_DISABLED\n     * @see #WIFI_AP_STATE_DISABLING\n     * @see #WIFI_AP_STATE_ENABLED\n     * @see #WIFI_AP_STATE_ENABLING\n     * @see #WIFI_AP_STATE_FAILED\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Intent#getIntExtra" ]
  }, {
    "name" : "EXTRA_WIFI_AP_FAILURE_REASON",
    "type" : "String",
    "comment" : "\n     * An extra containing the int error code for Soft AP start failure.\n     * Can be obtained from the {@link #WIFI_AP_STATE_CHANGED_ACTION} using\n     * {@link android.content.Intent#getIntExtra}.\n     * This extra will only be attached if {@link #EXTRA_WIFI_AP_STATE} is\n     * attached and is equal to {@link #WIFI_AP_STATE_FAILED}.\n     *\n     * The error code will be one of:\n     * {@link #SAP_START_FAILURE_GENERAL},\n     * {@link #SAP_START_FAILURE_NO_CHANNEL},\n     * {@link #SAP_START_FAILURE_UNSUPPORTED_CONFIGURATION}\n     *\n     * @hide\n     ",
    "links" : [ "#WIFI_AP_STATE_CHANGED_ACTION", "android.content.Intent#getIntExtra", "#EXTRA_WIFI_AP_STATE", "#WIFI_AP_STATE_FAILED", "#SAP_START_FAILURE_GENERAL", "#SAP_START_FAILURE_NO_CHANNEL", "#SAP_START_FAILURE_UNSUPPORTED_CONFIGURATION" ]
  }, {
    "name" : "EXTRA_PREVIOUS_WIFI_AP_STATE",
    "type" : "String",
    "comment" : "\n     * The previous Wi-Fi state.\n     *\n     * @see #EXTRA_WIFI_AP_STATE\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_WIFI_AP_INTERFACE_NAME",
    "type" : "String",
    "comment" : "\n     * The lookup key for a String extra that stores the interface name used for the Soft AP.\n     * This extra is included in the broadcast {@link #WIFI_AP_STATE_CHANGED_ACTION}.\n     * Retrieve its value with {@link android.content.Intent#getStringExtra(String)}.\n     *\n     * @hide\n     ",
    "links" : [ "#WIFI_AP_STATE_CHANGED_ACTION", "android.content.Intent#getStringExtra" ]
  }, {
    "name" : "EXTRA_WIFI_AP_MODE",
    "type" : "String",
    "comment" : "\n     * The lookup key for an int extra that stores the intended IP mode for this Soft AP.\n     * One of {@link #IFACE_IP_MODE_TETHERED} or {@link #IFACE_IP_MODE_LOCAL_ONLY}.\n     * This extra is included in the broadcast {@link #WIFI_AP_STATE_CHANGED_ACTION}.\n     * Retrieve its value with {@link android.content.Intent#getIntExtra(String, int)}.\n     *\n     * @hide\n     ",
    "links" : [ "#IFACE_IP_MODE_TETHERED", "#IFACE_IP_MODE_LOCAL_ONLY", "#WIFI_AP_STATE_CHANGED_ACTION", "android.content.Intent#getIntExtra" ]
  }, {
    "name" : "WIFI_AP_STATE_DISABLING",
    "type" : "int",
    "comment" : "\n     * Wi-Fi AP is currently being disabled. The state will change to\n     * {@link #WIFI_AP_STATE_DISABLED} if it finishes successfully.\n     *\n     * @see #WIFI_AP_STATE_CHANGED_ACTION\n     * @see #getWifiApState()\n     *\n     * @hide\n     ",
    "links" : [ "#WIFI_AP_STATE_DISABLED" ]
  }, {
    "name" : "WIFI_AP_STATE_DISABLED",
    "type" : "int",
    "comment" : "\n     * Wi-Fi AP is disabled.\n     *\n     * @see #WIFI_AP_STATE_CHANGED_ACTION\n     * @see #getWifiState()\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_AP_STATE_ENABLING",
    "type" : "int",
    "comment" : "\n     * Wi-Fi AP is currently being enabled. The state will change to\n     * {@link #WIFI_AP_STATE_ENABLED} if it finishes successfully.\n     *\n     * @see #WIFI_AP_STATE_CHANGED_ACTION\n     * @see #getWifiApState()\n     *\n     * @hide\n     ",
    "links" : [ "#WIFI_AP_STATE_ENABLED" ]
  }, {
    "name" : "WIFI_AP_STATE_ENABLED",
    "type" : "int",
    "comment" : "\n     * Wi-Fi AP is enabled.\n     *\n     * @see #WIFI_AP_STATE_CHANGED_ACTION\n     * @see #getWifiApState()\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_AP_STATE_FAILED",
    "type" : "int",
    "comment" : "\n     * Wi-Fi AP is in a failed state. This state will occur when an error occurs during\n     * enabling or disabling\n     *\n     * @see #WIFI_AP_STATE_CHANGED_ACTION\n     * @see #getWifiApState()\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SAP_START_FAILURE_GENERAL",
    "type" : "int",
    "comment" : "\n     *  All other reasons for AP start failure besides {@link #SAP_START_FAILURE_NO_CHANNEL} and\n     *  {@link #SAP_START_FAILURE_UNSUPPORTED_CONFIGURATION}.\n     *\n     *  @hide\n     ",
    "links" : [ "#SAP_START_FAILURE_NO_CHANNEL", "#SAP_START_FAILURE_UNSUPPORTED_CONFIGURATION" ]
  }, {
    "name" : "SAP_START_FAILURE_NO_CHANNEL",
    "type" : "int",
    "comment" : "\n     *  If Wi-Fi AP start failed, this reason code means that no legal channel exists on user\n     *  selected band due to regulatory constraints.\n     *\n     *  @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SAP_START_FAILURE_UNSUPPORTED_CONFIGURATION",
    "type" : "int",
    "comment" : "\n     *  If Wi-Fi AP start failed, this reason code means that the specified configuration\n     *  is not supported by the current HAL version.\n     *\n     *  @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SAP_CLIENT_BLOCK_REASON_CODE_BLOCKED_BY_USER",
    "type" : "int",
    "comment" : "\n     *  If Soft Ap client is blocked, this reason code means that client doesn't exist in the\n     *  specified configuration {@link SoftApConfiguration.Builder#setBlockedClientList(List)}\n     *  and {@link SoftApConfiguration.Builder#setAllowedClientList(List)}\n     *  and the {@link SoftApConfiguration.Builder#setClientControlByUserEnabled(boolean)}\n     *  is configured as well.\n     *  @hide\n     ",
    "links" : [ "SoftApConfiguration.Builder#setBlockedClientList", "SoftApConfiguration.Builder#setAllowedClientList", "SoftApConfiguration.Builder#setClientControlByUserEnabled" ]
  }, {
    "name" : "SAP_CLIENT_BLOCK_REASON_CODE_NO_MORE_STAS",
    "type" : "int",
    "comment" : "\n     *  If Soft Ap client is blocked, this reason code means that no more clients can be\n     *  associated to this AP since it reached maximum capacity. The maximum capacity is\n     *  the minimum of {@link SoftApConfiguration.Builder#setMaxNumberOfClients(int)} and\n     *  {@link SoftApCapability#getMaxSupportedClients} which get from\n     *  {@link WifiManager.SoftApCallback#onCapabilityChanged(SoftApCapability)}.\n     *\n     *  @hide\n     ",
    "links" : [ "SoftApConfiguration.Builder#setMaxNumberOfClients", "SoftApCapability#getMaxSupportedClients", "WifiManager.SoftApCallback#onCapabilityChanged" ]
  }, {
    "name" : "SAP_CLIENT_DISCONNECT_REASON_CODE_UNSPECIFIED",
    "type" : "int",
    "comment" : "\n     * Client disconnected for unspecified reason. This could for example be because the AP is being\n     * shut down.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "IFACE_IP_MODE_UNSPECIFIED",
    "type" : "int",
    "comment" : "\n     * Interface IP mode unspecified.\n     *\n     * @see #updateInterfaceIpState(String, int)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "IFACE_IP_MODE_CONFIGURATION_ERROR",
    "type" : "int",
    "comment" : "\n     * Interface IP mode for configuration error.\n     *\n     * @see #updateInterfaceIpState(String, int)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "IFACE_IP_MODE_TETHERED",
    "type" : "int",
    "comment" : "\n     * Interface IP mode for tethering.\n     *\n     * @see #updateInterfaceIpState(String, int)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "IFACE_IP_MODE_LOCAL_ONLY",
    "type" : "int",
    "comment" : "\n     * Interface IP mode for Local Only Hotspot.\n     *\n     * @see #updateInterfaceIpState(String, int)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_NETWORK_SETTINGS_RESET",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that the wifi network settings\n     * had been reset.\n     *\n     * Note: This intent is sent as a directed broadcast to each manifest registered receiver.\n     * Intent will not be received by dynamically registered receivers.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SUPPLICANT_CONNECTION_CHANGE_ACTION",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that a connection to the supplicant has\n     * been established (and it is now possible\n     * to perform Wi-Fi operations) or the connection to the supplicant has been\n     * lost. One extra provides the connection state as a boolean, where {@code true}\n     * means CONNECTED.\n     * @deprecated This is no longer supported.\n     * @see #EXTRA_SUPPLICANT_CONNECTED\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_SUPPLICANT_CONNECTED",
    "type" : "String",
    "comment" : "\n     * The lookup key for a boolean that indicates whether a connection to\n     * the supplicant daemon has been gained or lost. {@code true} means\n     * a connection now exists.\n     * Retrieve it with {@link android.content.Intent#getBooleanExtra(String,boolean)}.\n     * @deprecated This is no longer supported.\n     ",
    "links" : [ "android.content.Intent#getBooleanExtra" ]
  }, {
    "name" : "NETWORK_STATE_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that the state of Wi-Fi connectivity\n     * has changed. An extra provides the new state\n     * in the form of a {@link android.net.NetworkInfo} object.  No network-related\n     * permissions are required to subscribe to this broadcast.\n     *\n     * <p class=\"note\">This broadcast is not delivered to manifest receivers in\n     * applications that target API version 26 or later.\n     * @see #EXTRA_NETWORK_INFO\n     ",
    "links" : [ "android.net.NetworkInfo" ]
  }, {
    "name" : "EXTRA_NETWORK_INFO",
    "type" : "String",
    "comment" : "\n     * The lookup key for a {@link android.net.NetworkInfo} object associated with the\n     * Wi-Fi network. Retrieve with\n     * {@link android.content.Intent#getParcelableExtra(String)}.\n     ",
    "links" : [ "android.net.NetworkInfo", "android.content.Intent#getParcelableExtra" ]
  }, {
    "name" : "EXTRA_BSSID",
    "type" : "String",
    "comment" : "\n     * The lookup key for a String giving the BSSID of the access point to which\n     * we are connected. No longer used.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_WIFI_INFO",
    "type" : "String",
    "comment" : "\n     * The lookup key for a {@link android.net.wifi.WifiInfo} object giving the\n     * information about the access point to which we are connected.\n     * No longer used.\n     ",
    "links" : [ "android.net.wifi.WifiInfo" ]
  }, {
    "name" : "SUPPLICANT_STATE_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that the state of establishing a connection to\n     * an access point has changed.One extra provides the new\n     * {@link SupplicantState}. Note that the supplicant state is Wi-Fi specific, and\n     * is not generally the most useful thing to look at if you are just interested in\n     * the overall state of connectivity.\n     * @see #EXTRA_NEW_STATE\n     * @see #EXTRA_SUPPLICANT_ERROR\n     * @deprecated This is no longer supported.\n     ",
    "links" : [ "SupplicantState" ]
  }, {
    "name" : "EXTRA_NEW_STATE",
    "type" : "String",
    "comment" : "\n     * The lookup key for a {@link SupplicantState} describing the new state\n     * Retrieve with\n     * {@link android.content.Intent#getParcelableExtra(String)}.\n     * @deprecated This is no longer supported.\n     ",
    "links" : [ "SupplicantState", "android.content.Intent#getParcelableExtra" ]
  }, {
    "name" : "EXTRA_SUPPLICANT_ERROR",
    "type" : "String",
    "comment" : "\n     * The lookup key for a {@link SupplicantState} describing the supplicant\n     * error code if any\n     * Retrieve with\n     * {@link android.content.Intent#getIntExtra(String, int)}.\n     * @see #ERROR_AUTHENTICATING\n     * @deprecated This is no longer supported.\n     ",
    "links" : [ "SupplicantState", "android.content.Intent#getIntExtra" ]
  }, {
    "name" : "EXTRA_SUPPLICANT_ERROR_REASON",
    "type" : "String",
    "comment" : "\n     * The lookup key for a {@link SupplicantState} describing the supplicant\n     * error reason if any\n     * Retrieve with\n     * {@link android.content.Intent#getIntExtra(String, int)}.\n     * @see #ERROR_AUTH_FAILURE_#REASON_CODE\n     * @deprecated This is no longer supported.\n     * @hide\n     ",
    "links" : [ "SupplicantState", "android.content.Intent#getIntExtra" ]
  }, {
    "name" : "CONFIGURED_NETWORKS_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that the configured networks changed.\n     * This can be as a result of adding/updating/deleting a network.\n     * <br />\n     * {@link #EXTRA_CHANGE_REASON} contains whether the configuration was added/changed/removed.\n     * {@link #EXTRA_WIFI_CONFIGURATION} is never set starting in Android 11.\n     * {@link #EXTRA_MULTIPLE_NETWORKS_CHANGED} is set for backwards compatibility reasons, but\n     * its value is always true, even if only a single network changed.\n     * <br />\n     * The {@link android.Manifest.permission#ACCESS_WIFI_STATE ACCESS_WIFI_STATE} permission is\n     * required to receive this broadcast.\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_CHANGE_REASON", "#EXTRA_WIFI_CONFIGURATION", "#EXTRA_MULTIPLE_NETWORKS_CHANGED", "android.Manifest.permission#ACCESS_WIFI_STATE" ]
  }, {
    "name" : "EXTRA_WIFI_CONFIGURATION",
    "type" : "String",
    "comment" : "\n     * The lookup key for a {@link android.net.wifi.WifiConfiguration} object representing\n     * the changed Wi-Fi configuration when the {@link #CONFIGURED_NETWORKS_CHANGED_ACTION}\n     * broadcast is sent.\n     * Note: this extra is never set starting in Android 11.\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiConfiguration", "#CONFIGURED_NETWORKS_CHANGED_ACTION" ]
  }, {
    "name" : "EXTRA_MULTIPLE_NETWORKS_CHANGED",
    "type" : "String",
    "comment" : "\n     * Multiple network configurations have changed.\n     * @see #CONFIGURED_NETWORKS_CHANGED_ACTION\n     * Note: this extra is always true starting in Android 11.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_CHANGE_REASON",
    "type" : "String",
    "comment" : "\n     * The lookup key for an integer indicating the reason a Wi-Fi network configuration\n     * has changed. One of {@link #CHANGE_REASON_ADDED}, {@link #CHANGE_REASON_REMOVED},\n     * {@link #CHANGE_REASON_CONFIG_CHANGE}.\n     *\n     * @see #CONFIGURED_NETWORKS_CHANGED_ACTION\n     * @hide\n     ",
    "links" : [ "#CHANGE_REASON_ADDED", "#CHANGE_REASON_REMOVED", "#CHANGE_REASON_CONFIG_CHANGE" ]
  }, {
    "name" : "CHANGE_REASON_ADDED",
    "type" : "int",
    "comment" : "\n     * The configuration is new and was added.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CHANGE_REASON_REMOVED",
    "type" : "int",
    "comment" : "\n     * The configuration was removed and is no longer present in the system's list of\n     * configured networks.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CHANGE_REASON_CONFIG_CHANGE",
    "type" : "int",
    "comment" : "\n     * The configuration has changed as a result of explicit action or because the system\n     * took an automated action such as disabling a malfunctioning configuration.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SCAN_RESULTS_AVAILABLE_ACTION",
    "type" : "String",
    "comment" : "\n     * An access point scan has completed, and results are available.\n     * Call {@link #getScanResults()} to obtain the results.\n     * The broadcast intent may contain an extra field with the key {@link #EXTRA_RESULTS_UPDATED}\n     * and a {@code boolean} value indicating if the scan was successful.\n     ",
    "links" : [ "#getScanResults", "#EXTRA_RESULTS_UPDATED" ]
  }, {
    "name" : "EXTRA_RESULTS_UPDATED",
    "type" : "String",
    "comment" : "\n     * Lookup key for a {@code boolean} extra in intent {@link #SCAN_RESULTS_AVAILABLE_ACTION}\n     * representing if the scan was successful or not.\n     * Scans may fail for multiple reasons, these may include:\n     * <ol>\n     * <li>An app requested too many scans in a certain period of time.\n     * This may lead to additional scan request rejections via \"scan throttling\" for both\n     * foreground and background apps.\n     * Note: Apps holding android.Manifest.permission.NETWORK_SETTINGS permission are\n     * exempted from scan throttling.\n     * </li>\n     * <li>The device is idle and scanning is disabled.</li>\n     * <li>Wifi hardware reported a scan failure.</li>\n     * </ol>\n     * @return true scan was successful, results are updated\n     * @return false scan was not successful, results haven't been updated since previous scan\n     ",
    "links" : [ "#SCAN_RESULTS_AVAILABLE_ACTION" ]
  }, {
    "name" : "BATCHED_SCAN_RESULTS_AVAILABLE_ACTION",
    "type" : "String",
    "comment" : "\n     * A batch of access point scans has been completed and the results areavailable.\n     * Call {@link #getBatchedScanResults()} to obtain the results.\n     * @deprecated This API is nolonger supported.\n     * Use {@link android.net.wifi.WifiScanner} API\n     * @hide\n     ",
    "links" : [ "#getBatchedScanResults", "android.net.wifi.WifiScanner" ]
  }, {
    "name" : "RSSI_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * The RSSI (signal strength) has changed.\n     *\n     * Receiver Required Permission: android.Manifest.permission.ACCESS_WIFI_STATE\n     * @see #EXTRA_NEW_RSSI\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_NEW_RSSI",
    "type" : "String",
    "comment" : "\n     * The lookup key for an {@code int} giving the new RSSI in dBm.\n     ",
    "links" : [ ]
  }, {
    "name" : "LINK_CONFIGURATION_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * @see #ACTION_LINK_CONFIGURATION_CHANGED\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_LINK_CONFIGURATION_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that the link configuration changed on wifi.\n     * <br />Included Extras:\n     * <br />{@link #EXTRA_LINK_PROPERTIES}: {@link android.net.LinkProperties} object associated\n     * with the Wi-Fi network.\n     * <br /> No permissions are required to listen to this broadcast.\n     * @hide\n     ",
    "links" : [ "#EXTRA_LINK_PROPERTIES", "android.net.LinkProperties" ]
  }, {
    "name" : "EXTRA_LINK_PROPERTIES",
    "type" : "String",
    "comment" : "\n     * The lookup key for a {@link android.net.LinkProperties} object associated with the\n     * Wi-Fi network.\n     * Included in the {@link #ACTION_LINK_CONFIGURATION_CHANGED} broadcast.\n     *\n     * Retrieve with {@link android.content.Intent#getParcelableExtra(String)}.\n     * @hide\n     ",
    "links" : [ "android.net.LinkProperties", "#ACTION_LINK_CONFIGURATION_CHANGED", "android.content.Intent#getParcelableExtra" ]
  }, {
    "name" : "EXTRA_NETWORK_CAPABILITIES",
    "type" : "String",
    "comment" : "\n     * The lookup key for a {@link android.net.NetworkCapabilities} object associated with the\n     * Wi-Fi network. Retrieve with\n     * {@link android.content.Intent#getParcelableExtra(String)}.\n     * @hide\n     ",
    "links" : [ "android.net.NetworkCapabilities", "android.content.Intent#getParcelableExtra" ]
  }, {
    "name" : "NETWORK_IDS_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * The network IDs of the configured networks could have changed.\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_REQUEST_SCAN_ALWAYS_AVAILABLE",
    "type" : "String",
    "comment" : "\n     * Activity Action: Show a system activity that allows the user to enable\n     * scans to be available even with Wi-Fi turned off.\n     *\n     * <p>Notification of the result of this activity is posted using the\n     * {@link android.app.Activity#onActivityResult} callback. The\n     * <code>resultCode</code>\n     * will be {@link android.app.Activity#RESULT_OK} if scan always mode has\n     * been turned on or {@link android.app.Activity#RESULT_CANCELED} if the user\n     * has rejected the request or an error has occurred.\n     ",
    "links" : [ "android.app.Activity#onActivityResult", "android.app.Activity#RESULT_OK", "android.app.Activity#RESULT_CANCELED" ]
  }, {
    "name" : "ACTION_PICK_WIFI_NETWORK",
    "type" : "String",
    "comment" : "\n     * Activity Action: Pick a Wi-Fi network to connect to.\n     * <p>Input: Nothing.\n     * <p>Output: Nothing.\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_REQUEST_ENABLE",
    "type" : "String",
    "comment" : "\n     * Activity Action: Receiver should show UI to get user approval to enable WiFi.\n     * <p>Input: {@link android.content.Intent#EXTRA_PACKAGE_NAME} string extra with\n     *           the name of the app requesting the action.\n     * <p>Output: Nothing.\n     * <p>No permissions are required to send this action.\n     * @hide\n     ",
    "links" : [ "android.content.Intent#EXTRA_PACKAGE_NAME" ]
  }, {
    "name" : "ACTION_REQUEST_DISABLE",
    "type" : "String",
    "comment" : "\n     * Activity Action: Receiver should show UI to get user approval to disable WiFi.\n     * <p>Input: {@link android.content.Intent#EXTRA_PACKAGE_NAME} string extra with\n     *           the name of the app requesting the action.\n     * <p>Output: Nothing.\n     * <p>No permissions are required to send this action.\n     * @hide\n     ",
    "links" : [ "android.content.Intent#EXTRA_PACKAGE_NAME" ]
  }, {
    "name" : "ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION",
    "type" : "String",
    "comment" : "\n     * Directed broadcast intent action indicating that the device has connected to one of the\n     * network suggestions provided by the app. This will be sent post connection to a network\n     * which was created with {@link WifiNetworkSuggestion.Builder#setIsAppInteractionRequired(\n     * boolean)}\n     * flag set.\n     * <p>\n     * Note: The broadcast is sent to the app only if it holds\n     * {@link android.Manifest.permission#ACCESS_FINE_LOCATION ACCESS_FINE_LOCATION} permission.\n     *\n     * @see #EXTRA_NETWORK_SUGGESTION\n     ",
    "links" : [ "WifiNetworkSuggestion.Builder#setIsAppInteractionRequired", "android.Manifest.permission#ACCESS_FINE_LOCATION" ]
  }, {
    "name" : "EXTRA_NETWORK_SUGGESTION",
    "type" : "String",
    "comment" : "\n     * Sent as as a part of {@link #ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION} that holds\n     * an instance of {@link WifiNetworkSuggestion} corresponding to the connected network.\n     ",
    "links" : [ "#ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION", "WifiNetworkSuggestion" ]
  }, {
    "name" : "WIFI_MODE_NO_LOCKS_HELD",
    "type" : "int",
    "comment" : "\n     * Internally used Wi-Fi lock mode representing the case were no locks are held.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_MODE_FULL",
    "type" : "int",
    "comment" : "\n     * In this Wi-Fi lock mode, Wi-Fi will be kept active,\n     * and will behave normally, i.e., it will attempt to automatically\n     * establish a connection to a remembered access point that is\n     * within range, and will do periodic scans if there are remembered\n     * access points but none are in range.\n     *\n     * @deprecated This API is non-functional and will have no impact.\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_MODE_SCAN_ONLY",
    "type" : "int",
    "comment" : "\n     * In this Wi-Fi lock mode, Wi-Fi will be kept active,\n     * but the only operation that will be supported is initiation of\n     * scans, and the subsequent reporting of scan results. No attempts\n     * will be made to automatically connect to remembered access points,\n     * nor will periodic scans be automatically performed looking for\n     * remembered access points. Scans must be explicitly requested by\n     * an application in this mode.\n     *\n     * @deprecated This API is non-functional and will have no impact.\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_MODE_FULL_HIGH_PERF",
    "type" : "int",
    "comment" : "\n     * In this Wi-Fi lock mode, Wi-Fi will not go to power save.\n     * This results in operating with low packet latency.\n     * The lock is only active when the device is connected to an access point.\n     * The lock is active even when the device screen is off or the acquiring application is\n     * running in the background.\n     * This mode will consume more power and hence should be used only\n     * when there is a need for this tradeoff.\n     * <p>\n     * An example use case is when a voice connection needs to be\n     * kept active even after the device screen goes off.\n     * Holding a {@link #WIFI_MODE_FULL_HIGH_PERF} lock for the\n     * duration of the voice call may improve the call quality.\n     * <p>\n     * When there is no support from the hardware, the {@link #WIFI_MODE_FULL_HIGH_PERF}\n     * lock will have no impact.\n     ",
    "links" : [ "#WIFI_MODE_FULL_HIGH_PERF", "#WIFI_MODE_FULL_HIGH_PERF" ]
  }, {
    "name" : "WIFI_MODE_FULL_LOW_LATENCY",
    "type" : "int",
    "comment" : "\n     * In this Wi-Fi lock mode, Wi-Fi will operate with a priority to achieve low latency.\n     * {@link #WIFI_MODE_FULL_LOW_LATENCY} lock has the following limitations:\n     * <ol>\n     * <li>The lock is only active when the device is connected to an access point.</li>\n     * <li>The lock is only active when the screen is on.</li>\n     * <li>The lock is only active when the acquiring app is running in the foreground.</li>\n     * </ol>\n     * Low latency mode optimizes for reduced packet latency,\n     * and as a result other performance measures may suffer when there are trade-offs to make:\n     * <ol>\n     * <li>Battery life may be reduced.</li>\n     * <li>Throughput may be reduced.</li>\n     * <li>Frequency of Wi-Fi scanning may be reduced. This may result in: </li>\n     * <ul>\n     * <li>The device may not roam or switch to the AP with highest signal quality.</li>\n     * <li>Location accuracy may be reduced.</li>\n     * </ul>\n     * </ol>\n     * <p>\n     * Example use cases are real time gaming or virtual reality applications where\n     * low latency is a key factor for user experience.\n     * <p>\n     * Note: For an app which acquires both {@link #WIFI_MODE_FULL_LOW_LATENCY} and\n     * {@link #WIFI_MODE_FULL_HIGH_PERF} locks, {@link #WIFI_MODE_FULL_LOW_LATENCY}\n     * lock will be effective when app is running in foreground and screen is on,\n     * while the {@link #WIFI_MODE_FULL_HIGH_PERF} lock will take effect otherwise.\n     ",
    "links" : [ "#WIFI_MODE_FULL_LOW_LATENCY", "#WIFI_MODE_FULL_LOW_LATENCY", "#WIFI_MODE_FULL_HIGH_PERF", "#WIFI_MODE_FULL_LOW_LATENCY", "#WIFI_MODE_FULL_HIGH_PERF" ]
  }, {
    "name" : "MIN_RSSI",
    "type" : "int",
    "comment" : " Anything worse than or equal to this will show 0 bars. ",
    "links" : [ ]
  }, {
    "name" : "MAX_RSSI",
    "type" : "int",
    "comment" : " Anything better than or equal to this will show the max bars. ",
    "links" : [ ]
  }, {
    "name" : "RSSI_LEVELS",
    "type" : "int",
    "comment" : "\n     * Number of RSSI levels used in the framework to initiate {@link #RSSI_CHANGED_ACTION}\n     * broadcast, where each level corresponds to a range of RSSI values.\n     * The {@link #RSSI_CHANGED_ACTION} broadcast will only fire if the RSSI\n     * change is significant enough to change the RSSI signal level.\n     * @hide\n     ",
    "links" : [ "#RSSI_CHANGED_ACTION", "#RSSI_CHANGED_ACTION" ]
  }, {
    "name" : "WIFI_FREQUENCY_BAND_AUTO",
    "type" : "int",
    "comment" : "\n     * Auto settings in the driver. The driver could choose to operate on both\n     * 2.4 GHz and 5 GHz or make a dynamic decision on selecting the band.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_FREQUENCY_BAND_5GHZ",
    "type" : "int",
    "comment" : "\n     * Operation on 5 GHz alone\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_FREQUENCY_BAND_2GHZ",
    "type" : "int",
    "comment" : "\n     * Operation on 2.4 GHz alone\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_POOR_NETWORK_AVOIDANCE_ENABLED",
    "type" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MAX_ACTIVE_LOCKS",
    "type" : "int",
    "comment" : "\n     * Maximum number of active locks we allow.\n     * This limit was added to prevent apps from creating a ridiculous number\n     * of locks and crashing the system by overflowing the global ref table.\n     ",
    "links" : [ ]
  }, {
    "name" : "UNKNOWN_SSID",
    "type" : "String",
    "comment" : " Indicates an invalid SSID. ",
    "links" : [ ]
  }, {
    "name" : "ALL_ZEROS_MAC_ADDRESS",
    "type" : "MacAddress",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "mActiveLockCount",
    "type" : "int",
    "comment" : " Number of currently active WifiLocks and MulticastLocks ",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mService",
    "type" : "IWifiManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTargetSdkVersion",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLooper",
    "type" : "Looper",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mVerboseLoggingEnabled",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLock",
    "type" : "Object",
    "comment" : " lock guarding access to the following vars",
    "links" : [ ]
  }, {
    "name" : "mLOHSCallbackProxy",
    "type" : "LocalOnlyHotspotCallbackProxy",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLOHSObserverProxy",
    "type" : "LocalOnlyHotspotObserverProxy",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_INFRA",
    "type" : "long",
    "comment" : " Basic infrastructure mode",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_PASSPOINT",
    "type" : "long",
    "comment" : " Support for GAS/ANQP",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_P2P",
    "type" : "long",
    "comment" : " Wifi-Direct",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_MOBILE_HOTSPOT",
    "type" : "long",
    "comment" : " Soft AP",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_SCANNER",
    "type" : "long",
    "comment" : " WifiScanner APIs",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_AWARE",
    "type" : "long",
    "comment" : " Wi-Fi AWare networking",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_D2D_RTT",
    "type" : "long",
    "comment" : " Device-to-device RTT",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_D2AP_RTT",
    "type" : "long",
    "comment" : " Device-to-AP RTT",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_BATCH_SCAN",
    "type" : "long",
    "comment" : " Batched Scan (deprecated)",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_PNO",
    "type" : "long",
    "comment" : " Preferred network offload",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_ADDITIONAL_STA",
    "type" : "long",
    "comment" : " Support for two STAs",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_TDLS",
    "type" : "long",
    "comment" : " Tunnel directed link setup",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_TDLS_OFFCHANNEL",
    "type" : "long",
    "comment" : " TDLS off channel",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_EPR",
    "type" : "long",
    "comment" : " Enhanced power reporting",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_AP_STA",
    "type" : "long",
    "comment" : " AP STA Concurrency",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_LINK_LAYER_STATS",
    "type" : "long",
    "comment" : " Link layer stats",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_LOGGER",
    "type" : "long",
    "comment" : " WiFi Logger",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_HAL_EPNO",
    "type" : "long",
    "comment" : " Enhanced PNO",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_RSSI_MONITOR",
    "type" : "long",
    "comment" : " RSSI Monitor",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_MKEEP_ALIVE",
    "type" : "long",
    "comment" : " mkeep_alive",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_CONFIG_NDO",
    "type" : "long",
    "comment" : " ND offload",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_TRANSMIT_POWER",
    "type" : "long",
    "comment" : " Capture transmit power",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_CONTROL_ROAMING",
    "type" : "long",
    "comment" : " Control firmware roaming",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_IE_WHITELIST",
    "type" : "long",
    "comment" : " Probe IE white listing",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_SCAN_RAND",
    "type" : "long",
    "comment" : " Random MAC & Probe seq",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_TX_POWER_LIMIT",
    "type" : "long",
    "comment" : " Set Tx power limit",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_WPA3_SAE",
    "type" : "long",
    "comment" : " WPA3-Personal SAE",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_WPA3_SUITE_B",
    "type" : "long",
    "comment" : " WPA3-Enterprise Suite-B",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_OWE",
    "type" : "long",
    "comment" : " Enhanced Open",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_LOW_LATENCY",
    "type" : "long",
    "comment" : " Low Latency modes",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_DPP",
    "type" : "long",
    "comment" : " DPP (Easy-Connect)",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_P2P_RAND_MAC",
    "type" : "long",
    "comment" : " Random P2P MAC",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_CONNECTED_RAND_MAC",
    "type" : "long",
    "comment" : " Random STA MAC",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_AP_RAND_MAC",
    "type" : "long",
    "comment" : " Random AP MAC",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_MBO",
    "type" : "long",
    "comment" : " MBO Support",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_OCE",
    "type" : "long",
    "comment" : " OCE Support",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_WAPI",
    "type" : "long",
    "comment" : " WAPI",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_FILS_SHA256",
    "type" : "long",
    "comment" : " FILS-SHA256",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_FILS_SHA384",
    "type" : "long",
    "comment" : " FILS-SHA384",
    "links" : [ ]
  }, {
    "name" : "ERROR",
    "type" : "int",
    "comment" : "\n     * Passed with {@link ActionListener#onFailure}.\n     * Indicates that the operation failed due to an internal error.\n     * @hide\n     ",
    "links" : [ "ActionListener#onFailure" ]
  }, {
    "name" : "IN_PROGRESS",
    "type" : "int",
    "comment" : "\n     * Passed with {@link ActionListener#onFailure}.\n     * Indicates that the operation is already in progress\n     * @hide\n     ",
    "links" : [ "ActionListener#onFailure" ]
  }, {
    "name" : "BUSY",
    "type" : "int",
    "comment" : "\n     * Passed with {@link ActionListener#onFailure}.\n     * Indicates that the operation failed because the framework is busy and\n     * unable to service the request\n     * @hide\n     ",
    "links" : [ "ActionListener#onFailure" ]
  }, {
    "name" : "WPS_OVERLAP_ERROR",
    "type" : "int",
    "comment" : " WPS overlap detected\n     * @deprecated This is deprecated\n     ",
    "links" : [ ]
  }, {
    "name" : "WPS_WEP_PROHIBITED",
    "type" : "int",
    "comment" : " WEP on WPS is prohibited\n     * @deprecated This is deprecated\n     ",
    "links" : [ ]
  }, {
    "name" : "WPS_TKIP_ONLY_PROHIBITED",
    "type" : "int",
    "comment" : " TKIP only prohibited\n     * @deprecated This is deprecated\n     ",
    "links" : [ ]
  }, {
    "name" : "WPS_AUTH_FAILURE",
    "type" : "int",
    "comment" : " Authentication failure on WPS\n     * @deprecated This is deprecated\n     ",
    "links" : [ ]
  }, {
    "name" : "WPS_TIMED_OUT",
    "type" : "int",
    "comment" : " WPS timed out\n     * @deprecated This is deprecated\n     ",
    "links" : [ ]
  }, {
    "name" : "INVALID_ARGS",
    "type" : "int",
    "comment" : "\n     * Passed with {@link ActionListener#onFailure}.\n     * Indicates that the operation failed due to invalid inputs\n     * @hide\n     ",
    "links" : [ "ActionListener#onFailure" ]
  }, {
    "name" : "NOT_AUTHORIZED",
    "type" : "int",
    "comment" : "\n     * Passed with {@link ActionListener#onFailure}.\n     * Indicates that the operation failed due to user permissions.\n     * @hide\n     ",
    "links" : [ "ActionListener#onFailure" ]
  }, {
    "name" : "DEVICE_MOBILITY_STATE_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Unknown device mobility state\n     *\n     * @see #setDeviceMobilityState(int)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_MOBILITY_STATE_HIGH_MVMT",
    "type" : "int",
    "comment" : "\n     * High movement device mobility state.\n     * e.g. on a bike, in a motor vehicle\n     *\n     * @see #setDeviceMobilityState(int)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_MOBILITY_STATE_LOW_MVMT",
    "type" : "int",
    "comment" : "\n     * Low movement device mobility state.\n     * e.g. walking, running\n     *\n     * @see #setDeviceMobilityState(int)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_MOBILITY_STATE_STATIONARY",
    "type" : "int",
    "comment" : "\n     * Stationary device mobility state\n     *\n     * @see #setDeviceMobilityState(int)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EASY_CONNECT_NETWORK_ROLE_STA",
    "type" : "int",
    "comment" : "\n     * Easy Connect Network role: Station.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EASY_CONNECT_NETWORK_ROLE_AP",
    "type" : "int",
    "comment" : "\n     * Easy Connect Network role: Access Point.\n     *\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public List<WifiConfiguration> getConfiguredNetworks()",
    "returnType" : "List<WifiConfiguration>",
    "comment" : "\n     * Return a list of all the networks configured for the current foreground\n     * user.\n     *\n     * Not all fields of WifiConfiguration are returned. Only the following\n     * fields are filled in:\n     * <ul>\n     * <li>networkId</li>\n     * <li>SSID</li>\n     * <li>BSSID</li>\n     * <li>priority</li>\n     * <li>allowedProtocols</li>\n     * <li>allowedKeyManagement</li>\n     * <li>allowedAuthAlgorithms</li>\n     * <li>allowedPairwiseCiphers</li>\n     * <li>allowedGroupCiphers</li>\n     * <li>status</li>\n     * </ul>\n     * @return a list of network configurations in the form of a list\n     * of {@link WifiConfiguration} objects.\n     *\n     * @deprecated\n     * a) See {@link WifiNetworkSpecifier.Builder#build()} for new\n     * mechanism to trigger connection to a Wi-Fi network.\n     * b) See {@link #addNetworkSuggestions(List)},\n     * {@link #removeNetworkSuggestions(List)} for new API to add Wi-Fi networks for consideration\n     * when auto-connecting to wifi.\n     * <b>Compatibility Note:</b> For applications targeting\n     * {@link android.os.Build.VERSION_CODES#Q} or above, this API will always fail and return an\n     * empty list.\n     * <p>\n     * Deprecation Exemptions:\n     * <ul>\n     * <li>Device Owner (DO), Profile Owner (PO) and system apps will have access to the full list.\n     * <li>Callers with Carrier privilege will receive a restricted list only containing\n     * configurations which they created.\n     * </ul>\n     ",
    "links" : [ "WifiConfiguration", "WifiNetworkSpecifier.Builder#build", "#addNetworkSuggestions", "#removeNetworkSuggestions", "android.os.Build.VERSION_CODES#Q" ]
  }, {
    "name" : "public List<WifiConfiguration> getPrivilegedConfiguredNetworks()",
    "returnType" : "List<WifiConfiguration>",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public List<Pair<WifiConfiguration, Map<Integer, List<ScanResult>>>> getAllMatchingWifiConfigs(@NonNull List<ScanResult> scanResults)",
    "returnType" : "List<Pair<WifiConfiguration, Map<Integer, List<ScanResult>>>>",
    "comment" : "\n     * Returns a list of all matching WifiConfigurations for a given list of ScanResult.\n     *\n     * An empty list will be returned when no configurations are installed or if no configurations\n     * match the ScanResult.\n     *\n     * @param scanResults a list of scanResult that represents the BSSID\n     * @return List that consists of {@link WifiConfiguration} and corresponding scanResults per\n     * network type({@link #PASSPOINT_HOME_NETWORK} and {@link #PASSPOINT_ROAMING_NETWORK}).\n     * @hide\n     ",
    "links" : [ "WifiConfiguration", "#PASSPOINT_HOME_NETWORK", "#PASSPOINT_ROAMING_NETWORK" ]
  }, {
    "name" : "public List<WifiConfiguration> getWifiConfigForMatchedNetworkSuggestionsSharedWithUser(@NonNull List<ScanResult> scanResults)",
    "returnType" : "List<WifiConfiguration>",
    "comment" : "\n     * Retrieve a list of {@link WifiConfiguration} for available {@link WifiNetworkSuggestion}\n     * matching the given list of {@link ScanResult}.\n     *\n     * An available {@link WifiNetworkSuggestion} must satisfy:\n     * <ul>\n     * <li> Matching one of the {@link ScanResult} from the given list.\n     * <li> and {@link WifiNetworkSuggestion.Builder#setIsUserAllowedToManuallyConnect(boolean)} set\n     * to true.\n     * </ul>\n     *\n     * @param scanResults a list of scanResult.\n     * @return a list of @link WifiConfiguration} for available {@link WifiNetworkSuggestion}\n     * @hide\n     ",
    "links" : [ "WifiConfiguration", "WifiNetworkSuggestion", "ScanResult", "WifiNetworkSuggestion", "ScanResult", "WifiNetworkSuggestion.Builder#setIsUserAllowedToManuallyConnect", "WifiConfiguration", "WifiNetworkSuggestion" ]
  }, {
    "name" : "public Map<OsuProvider, List<ScanResult>> getMatchingOsuProviders(@Nullable List<ScanResult> scanResults)",
    "returnType" : "Map<OsuProvider, List<ScanResult>>",
    "comment" : "\n     * Returns a list of unique Hotspot 2.0 OSU (Online Sign-Up) providers associated with a given\n     * list of ScanResult.\n     *\n     * An empty list will be returned if no match is found.\n     *\n     * @param scanResults a list of ScanResult\n     * @return Map that consists {@link OsuProvider} and a list of matching {@link ScanResult}\n     * @hide\n     ",
    "links" : [ "OsuProvider", "ScanResult" ]
  }, {
    "name" : "public Map<OsuProvider, PasspointConfiguration> getMatchingPasspointConfigsForOsuProviders(@NonNull Set<OsuProvider> osuProviders)",
    "returnType" : "Map<OsuProvider, PasspointConfiguration>",
    "comment" : "\n     * Returns the matching Passpoint R2 configurations for given OSU (Online Sign-Up) providers.\n     *\n     * Given a list of OSU providers, this only returns OSU providers that already have Passpoint R2\n     * configurations in the device.\n     * An empty map will be returned when there is no matching Passpoint R2 configuration for the\n     * given OsuProviders.\n     *\n     * @param osuProviders a set of {@link OsuProvider}\n     * @return Map that consists of {@link OsuProvider} and matching {@link PasspointConfiguration}.\n     * @hide\n     ",
    "links" : [ "OsuProvider", "OsuProvider", "PasspointConfiguration" ]
  }, {
    "name" : "public int addNetwork(WifiConfiguration config)",
    "returnType" : "int",
    "comment" : "\n     * Add a new network description to the set of configured networks.\n     * The {@code networkId} field of the supplied configuration object\n     * is ignored.\n     * <p/>\n     * The new network will be marked DISABLED by default. To enable it,\n     * called {@link #enableNetwork}.\n     *\n     * @param config the set of variables that describe the configuration,\n     *            contained in a {@link WifiConfiguration} object.\n     *            If the {@link WifiConfiguration} has an Http Proxy set\n     *            the calling app must be System, or be provisioned as the Profile or Device Owner.\n     * @return the ID of the newly created network description. This is used in\n     *         other operations to specified the network to be acted upon.\n     *         Returns {@code -1} on failure.\n     *\n     * @deprecated\n     * a) See {@link WifiNetworkSpecifier.Builder#build()} for new\n     * mechanism to trigger connection to a Wi-Fi network.\n     * b) See {@link #addNetworkSuggestions(List)},\n     * {@link #removeNetworkSuggestions(List)} for new API to add Wi-Fi networks for consideration\n     * when auto-connecting to wifi.\n     * <b>Compatibility Note:</b> For applications targeting\n     * {@link android.os.Build.VERSION_CODES#Q} or above, this API will always fail and return\n     * {@code -1}.\n     * <p>\n     * Deprecation Exemptions:\n     * <ul>\n     * <li>Device Owner (DO), Profile Owner (PO) and system apps.\n     * </ul>\n     ",
    "links" : [ "#enableNetwork", "WifiConfiguration", "WifiConfiguration", "WifiNetworkSpecifier.Builder#build", "#addNetworkSuggestions", "#removeNetworkSuggestions", "android.os.Build.VERSION_CODES#Q" ]
  }, {
    "name" : "public int updateNetwork(WifiConfiguration config)",
    "returnType" : "int",
    "comment" : "\n     * Update the network description of an existing configured network.\n     *\n     * @param config the set of variables that describe the configuration,\n     *            contained in a {@link WifiConfiguration} object. It may\n     *            be sparse, so that only the items that are being changed\n     *            are non-<code>null</code>. The {@code networkId} field\n     *            must be set to the ID of the existing network being updated.\n     *            If the {@link WifiConfiguration} has an Http Proxy set\n     *            the calling app must be System, or be provisioned as the Profile or Device Owner.\n     * @return Returns the {@code networkId} of the supplied\n     *         {@code WifiConfiguration} on success.\n     *         <br/>\n     *         Returns {@code -1} on failure, including when the {@code networkId}\n     *         field of the {@code WifiConfiguration} does not refer to an\n     *         existing network.\n     *\n     * @deprecated\n     * a) See {@link WifiNetworkSpecifier.Builder#build()} for new\n     * mechanism to trigger connection to a Wi-Fi network.\n     * b) See {@link #addNetworkSuggestions(List)},\n     * {@link #removeNetworkSuggestions(List)} for new API to add Wi-Fi networks for consideration\n     * when auto-connecting to wifi.\n     * <b>Compatibility Note:</b> For applications targeting\n     * {@link android.os.Build.VERSION_CODES#Q} or above, this API will always fail and return\n     * {@code -1}.\n     * <p>\n     * Deprecation Exemptions:\n     * <ul>\n     * <li>Device Owner (DO), Profile Owner (PO) and system apps.\n     * </ul>\n     ",
    "links" : [ "WifiConfiguration", "WifiConfiguration", "WifiNetworkSpecifier.Builder#build", "#addNetworkSuggestions", "#removeNetworkSuggestions", "android.os.Build.VERSION_CODES#Q" ]
  }, {
    "name" : "private int addOrUpdateNetwork(WifiConfiguration config)",
    "returnType" : "int",
    "comment" : "\n     * Internal method for doing the RPC that creates a new network description\n     * or updates an existing one.\n     *\n     * @param config The possibly sparse object containing the variables that\n     *         are to set or updated in the network description.\n     * @return the ID of the network on success, {@code -1} on failure.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerNetworkRequestMatchCallback(@NonNull @CallbackExecutor Executor executor, @NonNull NetworkRequestMatchCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Registers a callback for NetworkRequest matches. See {@link NetworkRequestMatchCallback}.\n     * Caller can unregister a previously registered callback using\n     * {@link #unregisterNetworkRequestMatchCallback(NetworkRequestMatchCallback)}\n     * <p>\n     * Applications should have the\n     * {@link android.Manifest.permission#NETWORK_SETTINGS} permission. Callers\n     * without the permission will trigger a {@link java.lang.SecurityException}.\n     * <p>\n     *\n     * @param executor The Executor on whose thread to execute the callbacks of the {@code callback}\n     *                 object.\n     * @param callback Callback for network match events to register.\n     * @hide\n     ",
    "links" : [ "NetworkRequestMatchCallback", "#unregisterNetworkRequestMatchCallback", "android.Manifest.permission#NETWORK_SETTINGS", "java.lang.SecurityException" ]
  }, {
    "name" : "public void unregisterNetworkRequestMatchCallback(@NonNull NetworkRequestMatchCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters a callback for NetworkRequest matches. See {@link NetworkRequestMatchCallback}.\n     * <p>\n     * Applications should have the\n     * {@link android.Manifest.permission#NETWORK_SETTINGS} permission. Callers\n     * without the permission will trigger a {@link java.lang.SecurityException}.\n     * <p>\n     *\n     * @param callback Callback for network match events to unregister.\n     * @hide\n     ",
    "links" : [ "NetworkRequestMatchCallback", "android.Manifest.permission#NETWORK_SETTINGS", "java.lang.SecurityException" ]
  }, {
    "name" : "public int addNetworkSuggestions(@NonNull List<WifiNetworkSuggestion> networkSuggestions)",
    "returnType" : "int",
    "comment" : "\n     * Provide a list of network suggestions to the device. See {@link WifiNetworkSuggestion}\n     * for a detailed explanation of the parameters.\n     * When the device decides to connect to one of the provided network suggestions, platform sends\n     * a directed broadcast {@link #ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION} to the app if\n     * the network was created with\n     * {@link WifiNetworkSuggestion.Builder#setIsAppInteractionRequired(boolean)} flag set and the\n     * app holds {@link android.Manifest.permission#ACCESS_FINE_LOCATION ACCESS_FINE_LOCATION}\n     * permission.\n     *<p>\n     * NOTE:\n     * <li> These networks are just a suggestion to the platform. The platform will ultimately\n     * decide on which network the device connects to. </li>\n     * <li> When an app is uninstalled or disabled, all its suggested networks are discarded.\n     * If the device is currently connected to a suggested network which is being removed then the\n     * device will disconnect from that network.</li>\n     * <li> If user reset network settings, all added suggestions will be discarded. Apps can use\n     * {@link #getNetworkSuggestions()} to check if their suggestions are in the device.</li>\n     * <li> In-place modification of existing suggestions are allowed.\n     * <li> If the provided suggestions include any previously provided suggestions by the app,\n     * previous suggestions will be updated.</li>\n     * <li>If one of the provided suggestions marks a previously unmetered suggestion as metered and\n     * the device is currently connected to that suggested network, then the device will disconnect\n     * from that network. The system will immediately re-evaluate all the network candidates\n     * and possibly reconnect back to the same suggestion. This disconnect is to make sure that any\n     * traffic flowing over unmetered networks isn't accidentally continued over a metered network.\n     * </li>\n     * </li>\n     *\n     * @param networkSuggestions List of network suggestions provided by the app.\n     * @return Status code for the operation. One of the STATUS_NETWORK_SUGGESTIONS_ values.\n     * @throws {@link SecurityException} if the caller is missing required permissions.\n     * @see WifiNetworkSuggestion#equals(Object)\n     ",
    "links" : [ "WifiNetworkSuggestion", "#ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION", "WifiNetworkSuggestion.Builder#setIsAppInteractionRequired", "android.Manifest.permission#ACCESS_FINE_LOCATION", "#getNetworkSuggestions", "SecurityException" ]
  }, {
    "name" : "public int removeNetworkSuggestions(@NonNull List<WifiNetworkSuggestion> networkSuggestions)",
    "returnType" : "int",
    "comment" : "\n     * Remove some or all of the network suggestions that were previously provided by the app.\n     * If one of the suggestions being removed was used to establish connection to the current\n     * network, then the device will immediately disconnect from that network.\n     *\n     * See {@link WifiNetworkSuggestion} for a detailed explanation of the parameters.\n     * See {@link WifiNetworkSuggestion#equals(Object)} for the equivalence evaluation used.\n     *\n     * @param networkSuggestions List of network suggestions to be removed. Pass an empty list\n     *                           to remove all the previous suggestions provided by the app.\n     * @return Status code for the operation. One of the STATUS_NETWORK_SUGGESTIONS_ values.\n     * Any matching suggestions are removed from the device and will not be considered for any\n     * further connection attempts.\n     ",
    "links" : [ "WifiNetworkSuggestion", "WifiNetworkSuggestion#equals" ]
  }, {
    "name" : "public List<WifiNetworkSuggestion> getNetworkSuggestions()",
    "returnType" : "List<WifiNetworkSuggestion>",
    "comment" : "\n     * Get all network suggestions provided by the calling app.\n     * See {@link #addNetworkSuggestions(List)}\n     * See {@link #removeNetworkSuggestions(List)}\n     * @return a list of {@link WifiNetworkSuggestion}\n     ",
    "links" : [ "#addNetworkSuggestions", "#removeNetworkSuggestions", "WifiNetworkSuggestion" ]
  }, {
    "name" : "public int getMaxNumberOfNetworkSuggestionsPerApp()",
    "returnType" : "int",
    "comment" : "\n     * Returns the max number of network suggestions that are allowed per app on the device.\n     * @see #addNetworkSuggestions(List)\n     * @see #removeNetworkSuggestions(List)\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getMaxNumberOfNetworkSuggestionsPerApp(boolean isLowRamDevice)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void addOrUpdatePasspointConfiguration(PasspointConfiguration config)",
    "returnType" : "void",
    "comment" : "\n     * Add or update a Passpoint configuration.  The configuration provides a credential\n     * for connecting to Passpoint networks that are operated by the Passpoint\n     * service provider specified in the configuration.\n     *\n     * Each configuration is uniquely identified by a unique key which depends on the contents of\n     * the configuration. This allows the caller to install multiple profiles with the same FQDN\n     * (Fully qualified domain name). Therefore, in order to update an existing profile, it is\n     * first required to remove it using {@link WifiManager#removePasspointConfiguration(String)}.\n     * Otherwise, a new profile will be added with both configuration.\n     *\n     * @param config The Passpoint configuration to be added\n     * @throws IllegalArgumentException if configuration is invalid or Passpoint is not enabled on\n     *                                  the device.\n     *\n     * Deprecated for general app usage - except DO/PO apps.\n     * See {@link WifiNetworkSuggestion.Builder#setPasspointConfig(PasspointConfiguration)} to\n     * create a passpoint suggestion.\n     * See {@link #addNetworkSuggestions(List)}, {@link #removeNetworkSuggestions(List)} for new\n     * API to add Wi-Fi networks for consideration when auto-connecting to wifi.\n     * <b>Compatibility Note:</b> For applications targeting\n     * {@link android.os.Build.VERSION_CODES#R} or above, this API will always fail and throw\n     * {@link IllegalArgumentException}.\n     * <p>\n     * Deprecation Exemptions:\n     * <ul>\n     * <li>Device Owner (DO), Profile Owner (PO) and system apps.\n     * </ul>\n     ",
    "links" : [ "WifiManager#removePasspointConfiguration", "WifiNetworkSuggestion.Builder#setPasspointConfig", "#addNetworkSuggestions", "#removeNetworkSuggestions", "android.os.Build.VERSION_CODES#R", "IllegalArgumentException" ]
  }, {
    "name" : "public void removePasspointConfiguration(String fqdn)",
    "returnType" : "void",
    "comment" : "\n     * Remove the Passpoint configuration identified by its FQDN (Fully Qualified Domain Name) added\n     * by the caller.\n     *\n     * @param fqdn The FQDN of the Passpoint configuration added by the caller to be removed\n     * @throws IllegalArgumentException if no configuration is associated with the given FQDN or\n     *                                  Passpoint is not enabled on the device.\n     * @deprecated This will be non-functional in a future release.\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<PasspointConfiguration> getPasspointConfigurations()",
    "returnType" : "List<PasspointConfiguration>",
    "comment" : "\n     * Return the list of installed Passpoint configurations added by the caller.\n     *\n     * An empty list will be returned when no configurations are installed.\n     *\n     * @return A list of {@link PasspointConfiguration} added by the caller\n     * @deprecated This will be non-functional in a future release.\n     ",
    "links" : [ "PasspointConfiguration" ]
  }, {
    "name" : "public void queryPasspointIcon(long bssid, String fileName)",
    "returnType" : "void",
    "comment" : "\n     * Query for a Hotspot 2.0 release 2 OSU icon file. An {@link #ACTION_PASSPOINT_ICON} intent\n     * will be broadcasted once the request is completed.  The presence of the intent extra\n     * {@link #EXTRA_ICON} will indicate the result of the request.\n     * A missing intent extra {@link #EXTRA_ICON} will indicate a failure.\n     *\n     * @param bssid The BSSID of the AP\n     * @param fileName Name of the icon file (remote file) to query from the AP\n     *\n     * @throws UnsupportedOperationException if Passpoint is not enabled on the device.\n     * @hide\n     ",
    "links" : [ "#ACTION_PASSPOINT_ICON", "#EXTRA_ICON", "#EXTRA_ICON" ]
  }, {
    "name" : "public int matchProviderWithCurrentNetwork(String fqdn)",
    "returnType" : "int",
    "comment" : "\n     * Match the currently associated network against the SP matching the given FQDN\n     * @param fqdn FQDN of the SP\n     * @return ordinal [HomeProvider, RoamingProvider, Incomplete, None, Declined]\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void deauthenticateNetwork(long holdoff, boolean ess)",
    "returnType" : "void",
    "comment" : "\n     * Deauthenticate and set the re-authentication hold off time for the current network\n     * @param holdoff hold off time in milliseconds\n     * @param ess set if the hold off pertains to an ESS rather than a BSS\n     * @hide\n     *\n     * TODO (140167680): This needs to be removed, the implementation is empty!\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean removeNetwork(int netId)",
    "returnType" : "boolean",
    "comment" : "\n     * Remove the specified network from the list of configured networks.\n     * This may result in the asynchronous delivery of state change\n     * events.\n     *\n     * Applications are not allowed to remove networks created by other\n     * applications.\n     *\n     * @param netId the ID of the network as returned by {@link #addNetwork} or {@link\n     *        #getConfiguredNetworks}.\n     * @return {@code true} if the operation succeeded\n     *\n     * @deprecated\n     * a) See {@link WifiNetworkSpecifier.Builder#build()} for new\n     * mechanism to trigger connection to a Wi-Fi network.\n     * b) See {@link #addNetworkSuggestions(List)},\n     * {@link #removeNetworkSuggestions(List)} for new API to add Wi-Fi networks for consideration\n     * when auto-connecting to wifi.\n     * <b>Compatibility Note:</b> For applications targeting\n     * {@link android.os.Build.VERSION_CODES#Q} or above, this API will always fail and return\n     * {@code false}.\n     * <p>\n     * Deprecation Exemptions:\n     * <ul>\n     * <li>Device Owner (DO), Profile Owner (PO) and system apps.\n     * </ul>\n     ",
    "links" : [ "#addNetwork", "WifiNetworkSpecifier.Builder#build", "#addNetworkSuggestions", "#removeNetworkSuggestions", "android.os.Build.VERSION_CODES#Q" ]
  }, {
    "name" : "public boolean enableNetwork(int netId, boolean attemptConnect)",
    "returnType" : "boolean",
    "comment" : "\n     * Allow a previously configured network to be associated with. If\n     * <code>attemptConnect</code> is true, an attempt to connect to the selected\n     * network is initiated. This may result in the asynchronous delivery\n     * of state change events.\n     * <p>\n     * <b>Note:</b> Network communication may not use Wi-Fi even if Wi-Fi is connected;\n     * traffic may instead be sent through another network, such as cellular data,\n     * Bluetooth tethering, or Ethernet. For example, traffic will never use a\n     * Wi-Fi network that does not provide Internet access (e.g. a wireless\n     * printer), if another network that does offer Internet access (e.g.\n     * cellular data) is available. Applications that need to ensure that their\n     * network traffic uses Wi-Fi should use APIs such as\n     * {@link Network#bindSocket(java.net.Socket)},\n     * {@link Network#openConnection(java.net.URL)}, or\n     * {@link ConnectivityManager#bindProcessToNetwork} to do so.\n     *\n     * Applications are not allowed to enable networks created by other\n     * applications.\n     *\n     * @param netId the ID of the network as returned by {@link #addNetwork} or {@link\n     *        #getConfiguredNetworks}.\n     * @param attemptConnect The way to select a particular network to connect to is specify\n     *        {@code true} for this parameter.\n     * @return {@code true} if the operation succeeded\n     *\n     * @deprecated\n     * a) See {@link WifiNetworkSpecifier.Builder#build()} for new\n     * mechanism to trigger connection to a Wi-Fi network.\n     * b) See {@link #addNetworkSuggestions(List)},\n     * {@link #removeNetworkSuggestions(List)} for new API to add Wi-Fi networks for consideration\n     * when auto-connecting to wifi.\n     * <b>Compatibility Note:</b> For applications targeting\n     * {@link android.os.Build.VERSION_CODES#Q} or above, this API will always fail and return\n     * {@code false}.\n     * Deprecation Exemptions:\n     * <ul>\n     * <li>Device Owner (DO), Profile Owner (PO) and system apps.\n     * </ul>\n     ",
    "links" : [ "Network#bindSocket", "Network#openConnection", "ConnectivityManager#bindProcessToNetwork", "#addNetwork", "WifiNetworkSpecifier.Builder#build", "#addNetworkSuggestions", "#removeNetworkSuggestions", "android.os.Build.VERSION_CODES#Q" ]
  }, {
    "name" : "public boolean disableNetwork(int netId)",
    "returnType" : "boolean",
    "comment" : "\n     * Disable a configured network. The specified network will not be\n     * a candidate for associating. This may result in the asynchronous\n     * delivery of state change events.\n     *\n     * Applications are not allowed to disable networks created by other\n     * applications.\n     *\n     * @param netId the ID of the network as returned by {@link #addNetwork} or {@link\n     *        #getConfiguredNetworks}.\n     * @return {@code true} if the operation succeeded\n     *\n     * @deprecated\n     * a) See {@link WifiNetworkSpecifier.Builder#build()} for new\n     * mechanism to trigger connection to a Wi-Fi network.\n     * b) See {@link #addNetworkSuggestions(List)},\n     * {@link #removeNetworkSuggestions(List)} for new API to add Wi-Fi networks for consideration\n     * when auto-connecting to wifi.\n     * <b>Compatibility Note:</b> For applications targeting\n     * {@link android.os.Build.VERSION_CODES#Q} or above, this API will always fail and return\n     * {@code false}.\n     * <p>\n     * Deprecation Exemptions:\n     * <ul>\n     * <li>Device Owner (DO), Profile Owner (PO) and system apps.\n     * </ul>\n     ",
    "links" : [ "#addNetwork", "WifiNetworkSpecifier.Builder#build", "#addNetworkSuggestions", "#removeNetworkSuggestions", "android.os.Build.VERSION_CODES#Q" ]
  }, {
    "name" : "public boolean disconnect()",
    "returnType" : "boolean",
    "comment" : "\n     * Disassociate from the currently active access point. This may result\n     * in the asynchronous delivery of state change events.\n     * @return {@code true} if the operation succeeded\n     *\n     * @deprecated\n     * a) See {@link WifiNetworkSpecifier.Builder#build()} for new\n     * mechanism to trigger connection to a Wi-Fi network.\n     * b) See {@link #addNetworkSuggestions(List)},\n     * {@link #removeNetworkSuggestions(List)} for new API to add Wi-Fi networks for consideration\n     * when auto-connecting to wifi.\n     * <b>Compatibility Note:</b> For applications targeting\n     * {@link android.os.Build.VERSION_CODES#Q} or above, this API will always fail and return\n     * {@code false}.\n     * <p>\n     * Deprecation Exemptions:\n     * <ul>\n     * <li>Device Owner (DO), Profile Owner (PO) and system apps.\n     * </ul>\n     ",
    "links" : [ "WifiNetworkSpecifier.Builder#build", "#addNetworkSuggestions", "#removeNetworkSuggestions", "android.os.Build.VERSION_CODES#Q" ]
  }, {
    "name" : "public boolean reconnect()",
    "returnType" : "boolean",
    "comment" : "\n     * Reconnect to the currently active access point, if we are currently\n     * disconnected. This may result in the asynchronous delivery of state\n     * change events.\n     * @return {@code true} if the operation succeeded\n     *\n     * @deprecated\n     * a) See {@link WifiNetworkSpecifier.Builder#build()} for new\n     * mechanism to trigger connection to a Wi-Fi network.\n     * b) See {@link #addNetworkSuggestions(List)},\n     * {@link #removeNetworkSuggestions(List)} for new API to add Wi-Fi networks for consideration\n     * when auto-connecting to wifi.\n     * <b>Compatibility Note:</b> For applications targeting\n     * {@link android.os.Build.VERSION_CODES#Q} or above, this API will always fail and return\n     * {@code false}.\n     * <p>\n     * Deprecation Exemptions:\n     * <ul>\n     * <li>Device Owner (DO), Profile Owner (PO) and system apps.\n     * </ul>\n     ",
    "links" : [ "WifiNetworkSpecifier.Builder#build", "#addNetworkSuggestions", "#removeNetworkSuggestions", "android.os.Build.VERSION_CODES#Q" ]
  }, {
    "name" : "public boolean reassociate()",
    "returnType" : "boolean",
    "comment" : "\n     * Reconnect to the currently active access point, even if we are already\n     * connected. This may result in the asynchronous delivery of state\n     * change events.\n     * @return {@code true} if the operation succeeded\n     *\n     * @deprecated\n     * a) See {@link WifiNetworkSpecifier.Builder#build()} for new\n     * mechanism to trigger connection to a Wi-Fi network.\n     * b) See {@link #addNetworkSuggestions(List)},\n     * {@link #removeNetworkSuggestions(List)} for new API to add Wi-Fi networks for consideration\n     * when auto-connecting to wifi.\n     * <b>Compatibility Note:</b> For applications targeting\n     * {@link android.os.Build.VERSION_CODES#Q} or above, this API will always return false.\n     ",
    "links" : [ "WifiNetworkSpecifier.Builder#build", "#addNetworkSuggestions", "#removeNetworkSuggestions", "android.os.Build.VERSION_CODES#Q" ]
  }, {
    "name" : "public boolean pingSupplicant()",
    "returnType" : "boolean",
    "comment" : "\n     * Check that the supplicant daemon is responding to requests.\n     * @return {@code true} if we were able to communicate with the supplicant and\n     * it returned the expected response to the PING message.\n     * @deprecated Will return the output of {@link #isWifiEnabled()} instead.\n     ",
    "links" : [ "#isWifiEnabled" ]
  }, {
    "name" : "private long getSupportedFeatures()",
    "returnType" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean isFeatureSupported(long feature)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isPasspointSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this adapter supports Passpoint\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isP2pSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this adapter supports WifiP2pManager (Wi-Fi Direct)\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isPortableHotspotSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this adapter supports portable Wi-Fi hotspot\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isWifiScannerSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this adapter supports WifiScanner APIs\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isWifiAwareSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this adapter supports Neighbour Awareness Network APIs\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isStaApConcurrencySupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Query whether the device supports Station (STA) + Access point (AP) concurrency or not.\n     *\n     * @return true if this device supports STA + AP concurrency, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isDeviceToDeviceRttSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @deprecated Please use {@link android.content.pm.PackageManager#hasSystemFeature(String)}\n     * with {@link android.content.pm.PackageManager#FEATURE_WIFI_RTT} and\n     * {@link android.content.pm.PackageManager#FEATURE_WIFI_AWARE}.\n     *\n     * @return true if this adapter supports Device-to-device RTT\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#hasSystemFeature", "android.content.pm.PackageManager#FEATURE_WIFI_RTT", "android.content.pm.PackageManager#FEATURE_WIFI_AWARE" ]
  }, {
    "name" : "public boolean isDeviceToApRttSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @deprecated Please use {@link android.content.pm.PackageManager#hasSystemFeature(String)}\n     * with {@link android.content.pm.PackageManager#FEATURE_WIFI_RTT}.\n     *\n     * @return true if this adapter supports Device-to-AP RTT\n     ",
    "links" : [ "android.content.pm.PackageManager#hasSystemFeature", "android.content.pm.PackageManager#FEATURE_WIFI_RTT" ]
  }, {
    "name" : "public boolean isPreferredNetworkOffloadSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this adapter supports offloaded connectivity scan\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAdditionalStaSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this adapter supports multiple simultaneous connections\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isTdlsSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this adapter supports Tunnel Directed Link Setup\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isOffChannelTdlsSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this adapter supports Off Channel Tunnel Directed Link Setup\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isEnhancedPowerReportingSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this adapter supports advanced power/performance counters\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isConnectedMacRandomizationSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this device supports connected MAC randomization.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isApMacRandomizationSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this device supports connected MAC randomization.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean is5GHzBandSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the chipset supports 5GHz band.\n     * @return {@code true} if supported, {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean is6GHzBandSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the chipset supports 6GHz band.\n     * @return {@code true} if supported, {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isWifiStandardSupported(@WifiAnnotations.WifiStandard int standard)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the chipset supports a certain Wi-Fi standard.\n     * @param standard the IEEE 802.11 standard to check on.\n     *        valid values from {@link ScanResult}'s {@code WIFI_STANDARD_}\n     * @return {@code true} if supported, {@code false} otherwise.\n     ",
    "links" : [ "ScanResult" ]
  }, {
    "name" : "public void getWifiActivityEnergyInfoAsync(@NonNull @CallbackExecutor Executor executor, @NonNull OnWifiActivityEnergyInfoListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Request to get the current {@link WifiActivityEnergyInfo} asynchronously.\n     * Note: This method will return null if {@link #isEnhancedPowerReportingSupported()} returns\n     * false.\n     *\n     * @param executor the executor that the listener will be invoked on\n     * @param listener the listener that will receive the {@link WifiActivityEnergyInfo} object\n     *                 when it becomes available. The listener will be triggered at most once for\n     *                 each call to this method.\n     *\n     * @hide\n     ",
    "links" : [ "WifiActivityEnergyInfo", "#isEnhancedPowerReportingSupported", "WifiActivityEnergyInfo" ]
  }, {
    "name" : "public boolean startScan()",
    "returnType" : "boolean",
    "comment" : "\n     * Request a scan for access points. Returns immediately. The availability\n     * of the results is made known later by means of an asynchronous event sent\n     * on completion of the scan.\n     * <p>\n     * To initiate a Wi-Fi scan, declare the\n     * {@link android.Manifest.permission#CHANGE_WIFI_STATE}\n     * permission in the manifest, and perform these steps:\n     * </p>\n     * <ol style=\"1\">\n     * <li>Invoke the following method:\n     * {@code ((WifiManager) getSystemService(WIFI_SERVICE)).startScan()}</li>\n     * <li>\n     * Register a BroadcastReceiver to listen to\n     * {@code SCAN_RESULTS_AVAILABLE_ACTION}.</li>\n     * <li>When a broadcast is received, call:\n     * {@code ((WifiManager) getSystemService(WIFI_SERVICE)).getScanResults()}</li>\n     * </ol>\n     * @return {@code true} if the operation succeeded, i.e., the scan was initiated.\n     * @deprecated The ability for apps to trigger scan requests will be removed in a future\n     * release.\n     ",
    "links" : [ "android.Manifest.permission#CHANGE_WIFI_STATE" ]
  }, {
    "name" : "public boolean startScan(WorkSource workSource)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public String getCurrentNetworkWpsNfcConfigurationToken()",
    "returnType" : "String",
    "comment" : "\n     * WPS has been deprecated from Client mode operation.\n     *\n     * @return null\n     * @hide\n     * @deprecated This API is deprecated\n     ",
    "links" : [ ]
  }, {
    "name" : "public WifiInfo getConnectionInfo()",
    "returnType" : "WifiInfo",
    "comment" : "\n     * Return dynamic information about the current Wi-Fi connection, if any is active.\n     * <p>\n     * In the connected state, access to the SSID and BSSID requires\n     * the same permissions as {@link #getScanResults}. If such access is not allowed,\n     * {@link WifiInfo#getSSID} will return {@link #UNKNOWN_SSID} and\n     * {@link WifiInfo#getBSSID} will return {@code \"02:00:00:00:00:00\"}.\n     * {@link WifiInfo#getPasspointFqdn()} will return null.\n     * {@link WifiInfo#getPasspointProviderFriendlyName()} will return null.\n     *\n     * @return the Wi-Fi information, contained in {@link WifiInfo}.\n     ",
    "links" : [ "#getScanResults", "WifiInfo#getSSID", "#UNKNOWN_SSID", "WifiInfo#getBSSID", "WifiInfo#getPasspointFqdn", "WifiInfo#getPasspointProviderFriendlyName", "WifiInfo" ]
  }, {
    "name" : "public List<ScanResult> getScanResults()",
    "returnType" : "List<ScanResult>",
    "comment" : "\n     * Return the results of the latest access point scan.\n     * @return the list of access points found in the most recent scan. An app must hold\n     * {@link android.Manifest.permission#ACCESS_FINE_LOCATION ACCESS_FINE_LOCATION} permission\n     * in order to get valid results.\n     ",
    "links" : [ "android.Manifest.permission#ACCESS_FINE_LOCATION" ]
  }, {
    "name" : "public Map<WifiNetworkSuggestion, List<ScanResult>> getMatchingScanResults(@NonNull List<WifiNetworkSuggestion> networkSuggestionsToMatch, @Nullable List<ScanResult> scanResults)",
    "returnType" : "Map<WifiNetworkSuggestion, List<ScanResult>>",
    "comment" : "\n     * Get the filtered ScanResults which match the network configurations specified by the\n     * {@code networkSuggestionsToMatch}. Suggestions which use {@link WifiConfiguration} use\n     * SSID and the security type to match. Suggestions which use {@link PasspointConfigration}\n     * use the matching rules of Hotspot 2.0.\n     * @param networkSuggestionsToMatch The list of {@link WifiNetworkSuggestion} to match against.\n     * These may or may not be suggestions which are installed on the device.\n     * @param scanResults The scan results to be filtered. Optional - if not provided(empty list),\n     * the Wi-Fi service will use the most recent scan results which the system has.\n     * @return The map of {@link WifiNetworkSuggestion} to the list of {@link ScanResult}\n     * corresponding to networks which match them.\n     * @hide\n     ",
    "links" : [ "WifiConfiguration", "PasspointConfigration", "WifiNetworkSuggestion", "WifiNetworkSuggestion", "ScanResult" ]
  }, {
    "name" : "public void setScanAlwaysAvailable(boolean isAvailable)",
    "returnType" : "void",
    "comment" : "\n     * Set if scanning is always available.\n     *\n     * If set to {@code true}, apps can issue {@link #startScan} and fetch scan results\n     * even when Wi-Fi is turned off.\n     *\n     * @param isAvailable true to enable, false to disable.\n     * @hide\n     * @see #isScanAlwaysAvailable()\n     ",
    "links" : [ "#startScan" ]
  }, {
    "name" : "public boolean isScanAlwaysAvailable()",
    "returnType" : "boolean",
    "comment" : "\n     * Check if scanning is always available.\n     *\n     * If this return {@code true}, apps can issue {@link #startScan} and fetch scan results\n     * even when Wi-Fi is turned off.\n     *\n     * To change this setting, see {@link #ACTION_REQUEST_SCAN_ALWAYS_AVAILABLE}.\n     * @deprecated The ability for apps to trigger scan requests will be removed in a future\n     * release.\n     ",
    "links" : [ "#startScan", "#ACTION_REQUEST_SCAN_ALWAYS_AVAILABLE" ]
  }, {
    "name" : "public boolean saveConfiguration()",
    "returnType" : "boolean",
    "comment" : "\n     * Tell the device to persist the current list of configured networks.\n     * <p>\n     * Note: It is possible for this method to change the network IDs of\n     * existing networks. You should assume the network IDs can be different\n     * after calling this method.\n     *\n     * @return {@code false}.\n     * @deprecated There is no need to call this method -\n     * {@link #addNetwork(WifiConfiguration)}, {@link #updateNetwork(WifiConfiguration)}\n     * and {@link #removeNetwork(int)} already persist the configurations automatically.\n     ",
    "links" : [ "#addNetwork", "#updateNetwork", "#removeNetwork" ]
  }, {
    "name" : "public String getCountryCode()",
    "returnType" : "String",
    "comment" : "\n     * Get the country code.\n     * @return the country code in ISO 3166 alpha-2 (2-letter) uppercase format, or null if\n     * there is no country code configured.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public DhcpInfo getDhcpInfo()",
    "returnType" : "DhcpInfo",
    "comment" : "\n     * Return the DHCP-assigned addresses from the last successful DHCP request,\n     * if any.\n     * @return the DHCP information\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setWifiEnabled(boolean enabled)",
    "returnType" : "boolean",
    "comment" : "\n     * Enable or disable Wi-Fi.\n     * <p>\n     * Applications must have the {@link android.Manifest.permission#CHANGE_WIFI_STATE}\n     * permission to toggle wifi.\n     *\n     * @param enabled {@code true} to enable, {@code false} to disable.\n     * @return {@code false} if the request cannot be satisfied; {@code true} indicates that wifi is\n     *         either already in the requested state, or in progress toward the requested state.\n     * @throws  {@link java.lang.SecurityException} if the caller is missing required permissions.\n     *\n     * @deprecated Starting with Build.VERSION_CODES#Q, applications are not allowed to\n     * enable/disable Wi-Fi.\n     * <b>Compatibility Note:</b> For applications targeting\n     * {@link android.os.Build.VERSION_CODES#Q} or above, this API will always fail and return\n     * {@code false}. If apps are targeting an older SDK ({@link android.os.Build.VERSION_CODES#P}\n     * or below), they can continue to use this API.\n     * <p>\n     * Deprecation Exemptions:\n     * <ul>\n     * <li>Device Owner (DO), Profile Owner (PO) and system apps.\n     * </ul>\n     ",
    "links" : [ "android.Manifest.permission#CHANGE_WIFI_STATE", "java.lang.SecurityException", "android.os.Build.VERSION_CODES#Q", "android.os.Build.VERSION_CODES#P" ]
  }, {
    "name" : "public int getWifiState()",
    "returnType" : "int",
    "comment" : "\n     * Gets the Wi-Fi enabled state.\n     * @return One of {@link #WIFI_STATE_DISABLED},\n     *         {@link #WIFI_STATE_DISABLING}, {@link #WIFI_STATE_ENABLED},\n     *         {@link #WIFI_STATE_ENABLING}, {@link #WIFI_STATE_UNKNOWN}\n     * @see #isWifiEnabled()\n     ",
    "links" : [ "#WIFI_STATE_DISABLED", "#WIFI_STATE_DISABLING", "#WIFI_STATE_ENABLED", "#WIFI_STATE_ENABLING", "#WIFI_STATE_UNKNOWN" ]
  }, {
    "name" : "public boolean isWifiEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether Wi-Fi is enabled or disabled.\n     * @return {@code true} if Wi-Fi is enabled\n     * @see #getWifiState()\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int calculateSignalLevel(int rssi, int numLevels)",
    "returnType" : "int",
    "comment" : "\n     * Calculates the level of the signal. This should be used any time a signal\n     * is being shown.\n     *\n     * @param rssi The power of the signal measured in RSSI.\n     * @param numLevels The number of levels to consider in the calculated level.\n     * @return A level of the signal, given in the range of 0 to numLevels-1 (both inclusive).\n     * @deprecated Callers should use {@link #calculateSignalLevel(int)} instead to get the\n     * signal level using the system default RSSI thresholds, or otherwise compute the RSSI level\n     * themselves using their own formula.\n     ",
    "links" : [ "#calculateSignalLevel" ]
  }, {
    "name" : "public int calculateSignalLevel(int rssi)",
    "returnType" : "int",
    "comment" : "\n     * Given a raw RSSI, return the RSSI signal quality rating using the system default RSSI\n     * quality rating thresholds.\n     * @param rssi a raw RSSI value, in dBm, usually between -55 and -90\n     * @return the RSSI signal quality rating, in the range\n     * [0, {@link #getMaxSignalLevel()}], where 0 is the lowest (worst signal) RSSI\n     * rating and {@link #getMaxSignalLevel()} is the highest (best signal) RSSI rating.\n     ",
    "links" : [ "#getMaxSignalLevel", "#getMaxSignalLevel" ]
  }, {
    "name" : "public int getMaxSignalLevel()",
    "returnType" : "int",
    "comment" : "\n     * Get the system default maximum signal level.\n     * This is the maximum RSSI level returned by {@link #calculateSignalLevel(int)}.\n     ",
    "links" : [ "#calculateSignalLevel" ]
  }, {
    "name" : "public static int compareSignalLevel(int rssiA, int rssiB)",
    "returnType" : "int",
    "comment" : "\n     * Compares two signal strengths.\n     *\n     * @param rssiA The power of the first signal measured in RSSI.\n     * @param rssiB The power of the second signal measured in RSSI.\n     * @return Returns <0 if the first signal is weaker than the second signal,\n     *         0 if the two signals have the same strength, and >0 if the first\n     *         signal is stronger than the second signal.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void updateInterfaceIpState(@Nullable String ifaceName, @IfaceIpMode int mode)",
    "returnType" : "void",
    "comment" : "\n     * Call allowing ConnectivityService to update WifiService with interface mode changes.\n     *\n     * @param ifaceName String name of the updated interface, or null to represent all interfaces\n     * @param mode int representing the new mode, one of:\n     *             {@link #IFACE_IP_MODE_TETHERED},\n     *             {@link #IFACE_IP_MODE_LOCAL_ONLY},\n     *             {@link #IFACE_IP_MODE_CONFIGURATION_ERROR},\n     *             {@link #IFACE_IP_MODE_UNSPECIFIED}\n     *\n     * @hide\n     ",
    "links" : [ "#IFACE_IP_MODE_TETHERED", "#IFACE_IP_MODE_LOCAL_ONLY", "#IFACE_IP_MODE_CONFIGURATION_ERROR", "#IFACE_IP_MODE_UNSPECIFIED" ]
  }, {
    "name" : "public boolean startSoftAp(@Nullable WifiConfiguration wifiConfig)",
    "returnType" : "boolean",
    "comment" : "\n     * Start Soft AP (hotspot) mode for tethering purposes with the specified configuration.\n     * Note that starting Soft AP mode may disable station mode operation if the device does not\n     * support concurrency.\n     * @param wifiConfig SSID, security and channel details as part of WifiConfiguration, or null to\n     *                   use the persisted Soft AP configuration that was previously set using\n     *                   {@link #setWifiApConfiguration(WifiConfiguration)}.\n     * @return {@code true} if the operation succeeded, {@code false} otherwise\n     *\n     * @hide\n     ",
    "links" : [ "#setWifiApConfiguration" ]
  }, {
    "name" : "public boolean startTetheredHotspot(@Nullable SoftApConfiguration softApConfig)",
    "returnType" : "boolean",
    "comment" : "\n     * Start Soft AP (hotspot) mode for tethering purposes with the specified configuration.\n     * Note that starting Soft AP mode may disable station mode operation if the device does not\n     * support concurrency.\n     * @param softApConfig A valid SoftApConfiguration specifying the configuration of the SAP,\n     *                     or null to use the persisted Soft AP configuration that was previously\n     *                     set using {@link #setSoftApConfiguration(softApConfiguration)}.\n     * @return {@code true} if the operation succeeded, {@code false} otherwise\n     *\n     * @hide\n     ",
    "links" : [ "#setSoftApConfiguration" ]
  }, {
    "name" : "public boolean stopSoftAp()",
    "returnType" : "boolean",
    "comment" : "\n     * Stop SoftAp mode.\n     * Note that stopping softap mode will restore the previous wifi mode.\n     * @return {@code true} if the operation succeeds, {@code false} otherwise\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startLocalOnlyHotspot(LocalOnlyHotspotCallback callback, @Nullable Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Request a local only hotspot that an application can use to communicate between co-located\n     * devices connected to the created WiFi hotspot.  The network created by this method will not\n     * have Internet access.  Each application can make a single request for the hotspot, but\n     * multiple applications could be requesting the hotspot at the same time.  When multiple\n     * applications have successfully registered concurrently, they will be sharing the underlying\n     * hotspot. {@link LocalOnlyHotspotCallback#onStarted(LocalOnlyHotspotReservation)} is called\n     * when the hotspot is ready for use by the application.\n     * <p>\n     * Each application can make a single active call to this method. The {@link\n     * LocalOnlyHotspotCallback#onStarted(LocalOnlyHotspotReservation)} callback supplies the\n     * requestor with a {@link LocalOnlyHotspotReservation} that contains a\n     * {@link SoftApConfiguration} with the SSID, security type and credentials needed to connect\n     * to the hotspot.  Communicating this information is up to the application.\n     * <p>\n     * If the LocalOnlyHotspot cannot be created, the {@link LocalOnlyHotspotCallback#onFailed(int)}\n     * method will be called. Example failures include errors bringing up the network or if\n     * there is an incompatible operating mode.  For example, if the user is currently using Wifi\n     * Tethering to provide an upstream to another device, LocalOnlyHotspot will not start due to\n     * an incompatible mode. The possible error codes include:\n     * {@link LocalOnlyHotspotCallback#ERROR_NO_CHANNEL},\n     * {@link LocalOnlyHotspotCallback#ERROR_GENERIC},\n     * {@link LocalOnlyHotspotCallback#ERROR_INCOMPATIBLE_MODE} and\n     * {@link LocalOnlyHotspotCallback#ERROR_TETHERING_DISALLOWED}.\n     * <p>\n     * Internally, requests will be tracked to prevent the hotspot from being torn down while apps\n     * are still using it.  The {@link LocalOnlyHotspotReservation} object passed in the  {@link\n     * LocalOnlyHotspotCallback#onStarted(LocalOnlyHotspotReservation)} call should be closed when\n     * the LocalOnlyHotspot is no longer needed using {@link LocalOnlyHotspotReservation#close()}.\n     * Since the hotspot may be shared among multiple applications, removing the final registered\n     * application request will trigger the hotspot teardown.  This means that applications should\n     * not listen to broadcasts containing wifi state to determine if the hotspot was stopped after\n     * they are done using it. Additionally, once {@link LocalOnlyHotspotReservation#close()} is\n     * called, applications will not receive callbacks of any kind.\n     * <p>\n     * Applications should be aware that the user may also stop the LocalOnlyHotspot through the\n     * Settings UI; it is not guaranteed to stay up as long as there is a requesting application.\n     * The requestors will be notified of this case via\n     * {@link LocalOnlyHotspotCallback#onStopped()}.  Other cases may arise where the hotspot is\n     * torn down (Emergency mode, etc).  Application developers should be aware that it can stop\n     * unexpectedly, but they will receive a notification if they have properly registered.\n     * <p>\n     * Applications should also be aware that this network will be shared with other applications.\n     * Applications are responsible for protecting their data on this network (e.g., TLS).\n     * <p>\n     * Applications need to have the following permissions to start LocalOnlyHotspot: {@link\n     * android.Manifest.permission#CHANGE_WIFI_STATE} and {@link\n     * android.Manifest.permission#ACCESS_FINE_LOCATION ACCESS_FINE_LOCATION}.  Callers without\n     * the permissions will trigger a {@link java.lang.SecurityException}.\n     * <p>\n     * @param callback LocalOnlyHotspotCallback for the application to receive updates about\n     * operating status.\n     * @param handler Handler to be used for callbacks.  If the caller passes a null Handler, the\n     * main thread will be used.\n     ",
    "links" : [ "LocalOnlyHotspotCallback#onStarted", "LocalOnlyHotspotReservation", "SoftApConfiguration", "LocalOnlyHotspotCallback#onFailed", "LocalOnlyHotspotCallback#ERROR_NO_CHANNEL", "LocalOnlyHotspotCallback#ERROR_GENERIC", "LocalOnlyHotspotCallback#ERROR_INCOMPATIBLE_MODE", "LocalOnlyHotspotCallback#ERROR_TETHERING_DISALLOWED", "LocalOnlyHotspotReservation", "LocalOnlyHotspotReservation#close", "LocalOnlyHotspotReservation#close", "LocalOnlyHotspotCallback#onStopped", "java.lang.SecurityException" ]
  }, {
    "name" : "public void startLocalOnlyHotspot(@NonNull SoftApConfiguration config, @Nullable Executor executor, @Nullable LocalOnlyHotspotCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Starts a local-only hotspot with a specific configuration applied. See\n     * {@link #startLocalOnlyHotspot(LocalOnlyHotspotCallback, Handler)}.\n     *\n     * Applications need either {@link android.Manifest.permission#NETWORK_SETUP_WIZARD} or\n     * {@link android.Manifest.permission#NETWORK_SETTINGS} to call this method.\n     *\n     * Since custom configuration settings may be incompatible with each other, the hotspot started\n     * through this method cannot coexist with another hotspot created through\n     * startLocalOnlyHotspot. If this is attempted, the first hotspot request wins and others\n     * receive {@link LocalOnlyHotspotCallback#ERROR_GENERIC} through\n     * {@link LocalOnlyHotspotCallback#onFailed}.\n     *\n     * @param config Custom configuration for the hotspot. See {@link SoftApConfiguration}.\n     * @param executor Executor to run callback methods on, or null to use the main thread.\n     * @param callback Callback object for updates about hotspot status, or null for no updates.\n     * @hide\n     ",
    "links" : [ "#startLocalOnlyHotspot", "android.Manifest.permission#NETWORK_SETUP_WIZARD", "android.Manifest.permission#NETWORK_SETTINGS", "LocalOnlyHotspotCallback#ERROR_GENERIC", "LocalOnlyHotspotCallback#onFailed", "SoftApConfiguration" ]
  }, {
    "name" : "private void startLocalOnlyHotspotInternal(@Nullable SoftApConfiguration config, @Nullable Executor executor, @Nullable LocalOnlyHotspotCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Common implementation of both configurable and non-configurable LOHS.\n     *\n     * @param config App-specified configuration, or null. When present, additional privileges are\n     *               required, and the hotspot cannot be shared with other clients.\n     * @param executor Executor to run callback methods on, or null to use the main thread.\n     * @param callback Callback object for updates about hotspot status, or null for no updates.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void cancelLocalOnlyHotspotRequest()",
    "returnType" : "void",
    "comment" : "\n     * Cancels a pending local only hotspot request.  This can be used by the calling application to\n     * cancel the existing request if the provided callback has not been triggered.  Calling this\n     * method will be equivalent to closing the returned LocalOnlyHotspotReservation, but it is not\n     * explicitly required.\n     * <p>\n     * When cancelling this request, application developers should be aware that there may still be\n     * outstanding local only hotspot requests and the hotspot may still start, or continue running.\n     * Additionally, if a callback was registered, it will no longer be triggered after calling\n     * cancel.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void stopLocalOnlyHotspot()",
    "returnType" : "void",
    "comment" : "\n     *  Method used to inform WifiService that the LocalOnlyHotspot is no longer needed.  This\n     *  method is used by WifiManager to release LocalOnlyHotspotReservations held by calling\n     *  applications and removes the internal tracking for the hotspot request.  When all requesting\n     *  applications are finished using the hotspot, it will be stopped and WiFi will return to the\n     *  previous operational mode.\n     *\n     *  This method should not be called by applications.  Instead, they should call the close()\n     *  method on their LocalOnlyHotspotReservation.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void watchLocalOnlyHotspot(LocalOnlyHotspotObserver observer, @Nullable Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Allow callers (Settings UI) to watch LocalOnlyHotspot state changes.  Callers will\n     * receive a {@link LocalOnlyHotspotSubscription} object as a parameter of the\n     * {@link LocalOnlyHotspotObserver#onRegistered(LocalOnlyHotspotSubscription)}. The registered\n     * callers will receive the {@link LocalOnlyHotspotObserver#onStarted(SoftApConfiguration)} and\n     * {@link LocalOnlyHotspotObserver#onStopped()} callbacks.\n     * <p>\n     * Applications should have the\n     * {@link android.Manifest.permission#ACCESS_FINE_LOCATION ACCESS_FINE_LOCATION}\n     * permission.  Callers without the permission will trigger a\n     * {@link java.lang.SecurityException}.\n     * <p>\n     * @param observer LocalOnlyHotspotObserver callback.\n     * @param handler Handler to use for callbacks\n     *\n     * @hide\n     ",
    "links" : [ "LocalOnlyHotspotSubscription", "LocalOnlyHotspotObserver#onRegistered", "LocalOnlyHotspotObserver#onStarted", "LocalOnlyHotspotObserver#onStopped", "android.Manifest.permission#ACCESS_FINE_LOCATION", "java.lang.SecurityException" ]
  }, {
    "name" : "public void unregisterLocalOnlyHotspotObserver()",
    "returnType" : "void",
    "comment" : "\n     * Allow callers to stop watching LocalOnlyHotspot state changes.  After calling this method,\n     * applications will no longer receive callbacks.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getWifiApState()",
    "returnType" : "int",
    "comment" : "\n     * Gets the tethered Wi-Fi hotspot enabled state.\n     * @return One of {@link #WIFI_AP_STATE_DISABLED},\n     *         {@link #WIFI_AP_STATE_DISABLING}, {@link #WIFI_AP_STATE_ENABLED},\n     *         {@link #WIFI_AP_STATE_ENABLING}, {@link #WIFI_AP_STATE_FAILED}\n     * @see #isWifiApEnabled()\n     *\n     * @hide\n     ",
    "links" : [ "#WIFI_AP_STATE_DISABLED", "#WIFI_AP_STATE_DISABLING", "#WIFI_AP_STATE_ENABLED", "#WIFI_AP_STATE_ENABLING", "#WIFI_AP_STATE_FAILED" ]
  }, {
    "name" : "public boolean isWifiApEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether tethered Wi-Fi AP is enabled or disabled.\n     * @return {@code true} if tethered  Wi-Fi AP is enabled\n     * @see #getWifiApState()\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public WifiConfiguration getWifiApConfiguration()",
    "returnType" : "WifiConfiguration",
    "comment" : "\n     * Gets the tethered Wi-Fi AP Configuration.\n     * @return AP details in WifiConfiguration\n     *\n     * Note that AP detail may contain configuration which is cannot be represented\n     * by the legacy WifiConfiguration, in such cases a null will be returned.\n     *\n     * @deprecated This API is deprecated. Use {@link #getSoftApConfiguration()} instead.\n     * @hide\n     ",
    "links" : [ "#getSoftApConfiguration" ]
  }, {
    "name" : "public SoftApConfiguration getSoftApConfiguration()",
    "returnType" : "SoftApConfiguration",
    "comment" : "\n     * Gets the Wi-Fi tethered AP Configuration.\n     * @return AP details in {@link SoftApConfiguration}\n     *\n     * @hide\n     ",
    "links" : [ "SoftApConfiguration" ]
  }, {
    "name" : "public boolean setWifiApConfiguration(WifiConfiguration wifiConfig)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets the tethered Wi-Fi AP Configuration.\n     * @return {@code true} if the operation succeeded, {@code false} otherwise\n     *\n     * @deprecated This API is deprecated. Use {@link #setSoftApConfiguration(SoftApConfiguration)}\n     * instead.\n     * @hide\n     ",
    "links" : [ "#setSoftApConfiguration" ]
  }, {
    "name" : "public boolean setSoftApConfiguration(@NonNull SoftApConfiguration softApConfig)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets the tethered Wi-Fi AP Configuration.\n     *\n     * If the API is called while the tethered soft AP is enabled, the configuration will apply to\n     * the current soft AP if the new configuration only includes\n     * {@link SoftApConfiguration.Builder#setMaxNumberOfClients(int)}\n     * or {@link SoftApConfiguration.Builder#setShutdownTimeoutMillis(long)}\n     * or {@link SoftApConfiguration.Builder#setClientControlByUserEnabled(boolean)}\n     * or {@link SoftApConfiguration.Builder#setBlockedClientList(List)}\n     * or {@link SoftApConfiguration.Builder#setAllowedClientList(List)}\n     *\n     * Otherwise, the configuration changes will be applied when the Soft AP is next started\n     * (the framework will not stop/start the AP).\n     *\n     * @param softApConfig  A valid SoftApConfiguration specifying the configuration of the SAP.\n     * @return {@code true} if the operation succeeded, {@code false} otherwise\n     *\n     * @hide\n     ",
    "links" : [ "SoftApConfiguration.Builder#setMaxNumberOfClients", "SoftApConfiguration.Builder#setShutdownTimeoutMillis", "SoftApConfiguration.Builder#setClientControlByUserEnabled", "SoftApConfiguration.Builder#setBlockedClientList", "SoftApConfiguration.Builder#setAllowedClientList" ]
  }, {
    "name" : "public void setTdlsEnabled(InetAddress remoteIPAddress, boolean enable)",
    "returnType" : "void",
    "comment" : "\n     * Enable/Disable TDLS on a specific local route.\n     *\n     * <p>\n     * TDLS enables two wireless endpoints to talk to each other directly\n     * without going through the access point that is managing the local\n     * network. It saves bandwidth and improves quality of the link.\n     * </p>\n     * <p>\n     * This API enables/disables the option of using TDLS. If enabled, the\n     * underlying hardware is free to use TDLS or a hop through the access\n     * point. If disabled, existing TDLS session is torn down and\n     * hardware is restricted to use access point for transferring wireless\n     * packets. Default value for all routes is 'disabled', meaning restricted\n     * to use access point for transferring packets.\n     * </p>\n     *\n     * @param remoteIPAddress IP address of the endpoint to setup TDLS with\n     * @param enable true = setup and false = tear down TDLS\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTdlsEnabledWithMacAddress(String remoteMacAddress, boolean enable)",
    "returnType" : "void",
    "comment" : "\n     * Similar to {@link #setTdlsEnabled(InetAddress, boolean) }, except\n     * this version allows you to specify remote endpoint with a MAC address.\n     * @param remoteMacAddress MAC address of the remote endpoint such as 00:00:0c:9f:f2:ab\n     * @param enable true = setup and false = tear down TDLS\n     ",
    "links" : [ "#setTdlsEnabled" ]
  }, {
    "name" : "public void registerSoftApCallback(@NonNull @CallbackExecutor Executor executor, @NonNull SoftApCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Registers a callback for Soft AP. See {@link SoftApCallback}. Caller will receive the\n     * following callbacks on registration:\n     * <ul>\n     * <li> {@link SoftApCallback#onStateChanged(int, int)}</li>\n     * <li> {@link SoftApCallback#onConnectedClientsChanged(List<WifiClient>)}</li>\n     * <li> {@link SoftApCallback#onInfoChanged(SoftApInfo)}</li>\n     * <li> {@link SoftApCallback#onCapabilityChanged(SoftApCapability)}</li>\n     * </ul>\n     * These will be dispatched on registration to provide the caller with the current state\n     * (and are not an indication of any current change). Note that receiving an immediate\n     * WIFI_AP_STATE_FAILED value for soft AP state indicates that the latest attempt to start\n     * soft AP has failed. Caller can unregister a previously registered callback using\n     * {@link #unregisterSoftApCallback}\n     * <p>\n     * Applications should have the\n     * {@link android.Manifest.permission#NETWORK_SETTINGS NETWORK_SETTINGS} permission. Callers\n     * without the permission will trigger a {@link java.lang.SecurityException}.\n     * <p>\n     *\n     * @param executor The Executor on whose thread to execute the callbacks of the {@code callback}\n     *                 object.\n     * @param callback Callback for soft AP events\n     * @hide\n     ",
    "links" : [ "SoftApCallback", "SoftApCallback#onStateChanged", "SoftApCallback#onConnectedClientsChanged", "SoftApCallback#onInfoChanged", "SoftApCallback#onCapabilityChanged", "#unregisterSoftApCallback", "android.Manifest.permission#NETWORK_SETTINGS", "java.lang.SecurityException" ]
  }, {
    "name" : "public void unregisterSoftApCallback(@NonNull SoftApCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Allow callers to unregister a previously registered callback. After calling this method,\n     * applications will no longer receive soft AP events.\n     *\n     * @param callback Callback to unregister for soft AP events\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void connectInternal(@Nullable WifiConfiguration config, int networkId, @Nullable ActionListener listener)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void connect(@NonNull WifiConfiguration config, @Nullable ActionListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Connect to a network with the given configuration. The network also\n     * gets added to the list of configured networks for the foreground user.\n     *\n     * For a new network, this function is used instead of a\n     * sequence of addNetwork(), enableNetwork(), and reconnect()\n     *\n     * @param config the set of variables that describe the configuration,\n     *            contained in a {@link WifiConfiguration} object.\n     * @param listener for callbacks on success or failure. Can be null.\n     * @throws IllegalStateException if the WifiManager instance needs to be\n     * initialized again\n     *\n     * @hide\n     ",
    "links" : [ "WifiConfiguration" ]
  }, {
    "name" : "public void connect(int networkId, @Nullable ActionListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Connect to a network with the given networkId.\n     *\n     * This function is used instead of a enableNetwork() and reconnect()\n     *\n     * <li> This API will cause reconnect if the credentials of the current active\n     * connection has been changed.</li>\n     * <li> This API will cause reconnect if the current active connection is marked metered.</li>\n     *\n     * @param networkId the ID of the network as returned by {@link #addNetwork} or {@link\n     *        getConfiguredNetworks}.\n     * @param listener for callbacks on success or failure. Can be null.\n     * @throws IllegalStateException if the WifiManager instance needs to be\n     * initialized again\n     * @hide\n     ",
    "links" : [ "#addNetwork" ]
  }, {
    "name" : "public void save(@NonNull WifiConfiguration config, @Nullable ActionListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Save the given network to the list of configured networks for the\n     * foreground user. If the network already exists, the configuration\n     * is updated. Any new network is enabled by default.\n     *\n     * For a new network, this function is used instead of a\n     * sequence of addNetwork() and enableNetwork().\n     *\n     * For an existing network, it accomplishes the task of updateNetwork()\n     *\n     * <li> This API will cause reconnect if the credentials of the current active\n     * connection has been changed.</li>\n     * <li> This API will cause disconnect if the current active connection is marked metered.</li>\n     *\n     * @param config the set of variables that describe the configuration,\n     *            contained in a {@link WifiConfiguration} object.\n     * @param listener for callbacks on success or failure. Can be null.\n     * @throws IllegalStateException if the WifiManager instance needs to be\n     * initialized again\n     * @hide\n     ",
    "links" : [ "WifiConfiguration" ]
  }, {
    "name" : "public void forget(int netId, @Nullable ActionListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Delete the network from the list of configured networks for the\n     * foreground user.\n     *\n     * This function is used instead of a sequence of removeNetwork()\n     *\n     * @param config the set of variables that describe the configuration,\n     *            contained in a {@link WifiConfiguration} object.\n     * @param listener for callbacks on success or failure. Can be null.\n     * @throws IllegalStateException if the WifiManager instance needs to be\n     * initialized again\n     * @hide\n     ",
    "links" : [ "WifiConfiguration" ]
  }, {
    "name" : "public void disable(int netId, @Nullable ActionListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Disable network\n     *\n     * @param netId is the network Id\n     * @param listener for callbacks on success or failure. Can be null.\n     * @throws IllegalStateException if the WifiManager instance needs to be\n     * initialized again\n     * @deprecated This API is deprecated. Use {@link #disableNetwork(int)} instead.\n     * @hide\n     ",
    "links" : [ "#disableNetwork" ]
  }, {
    "name" : "public void allowAutojoinGlobal(boolean allowAutojoin)",
    "returnType" : "void",
    "comment" : "\n     * Enable/disable auto-join globally.\n     *\n     * @param allowAutojoin true to allow auto-join, false to disallow auto-join\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void allowAutojoin(int netId, boolean allowAutojoin)",
    "returnType" : "void",
    "comment" : "\n     * Sets the user choice for allowing auto-join to a network.\n     * The updated choice will be made available through the updated config supplied by the\n     * CONFIGURED_NETWORKS_CHANGED broadcast.\n     *\n     * @param netId the id of the network to allow/disallow auto-join for.\n     * @param allowAutojoin true to allow auto-join, false to disallow auto-join\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void allowAutojoinPasspoint(@NonNull String fqdn, boolean allowAutojoin)",
    "returnType" : "void",
    "comment" : "\n     * Configure auto-join settings for a Passpoint profile.\n     *\n     * @param fqdn the FQDN (fully qualified domain name) of the passpoint profile.\n     * @param allowAutojoin true to enable auto-join, false to disable auto-join.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setMacRandomizationSettingPasspointEnabled(@NonNull String fqdn, boolean enable)",
    "returnType" : "void",
    "comment" : "\n     * Configure MAC randomization setting for a Passpoint profile.\n     * MAC randomization is enabled by default.\n     *\n     * @param fqdn the FQDN (fully qualified domain name) of the passpoint profile.\n     * @param enable true to enable MAC randomization, false to disable MAC randomization.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setPasspointMeteredOverride(@NonNull String fqdn, @WifiConfiguration.MeteredOverride int meteredOverride)",
    "returnType" : "void",
    "comment" : "\n     * Sets the user's choice of metered override for a Passpoint profile.\n     *\n     * @param fqdn the FQDN (fully qualified domain name) of the passpoint profile.\n     * @param meteredOverride One of three values: {@link WifiConfiguration#METERED_OVERRIDE_NONE},\n     *                        {@link WifiConfiguration#METERED_OVERRIDE_METERED},\n     *                        {@link WifiConfiguration#METERED_OVERRIDE_NOT_METERED}\n     * @hide\n     ",
    "links" : [ "WifiConfiguration#METERED_OVERRIDE_NONE", "WifiConfiguration#METERED_OVERRIDE_METERED", "WifiConfiguration#METERED_OVERRIDE_NOT_METERED" ]
  }, {
    "name" : "public void disableEphemeralNetwork(@NonNull String network)",
    "returnType" : "void",
    "comment" : "\n     * Temporarily disable a network. Should always trigger with user disconnect network.\n     *\n     * @param network Input can be SSID or FQDN. And caller must ensure that the SSID passed thru\n     *                this API matched the WifiConfiguration.SSID rules, and thus be surrounded by\n     *                quotes.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startWps(WpsInfo config, WpsCallback listener)",
    "returnType" : "void",
    "comment" : "\n     * WPS suport has been deprecated from Client mode and this method will immediately trigger\n     * {@link WpsCallback#onFailed(int)} with a generic error.\n     *\n     * @param config WPS configuration (does not support {@link WpsInfo#LABEL})\n     * @param listener for callbacks on success or failure. Can be null.\n     * @throws IllegalStateException if the WifiManager instance needs to be initialized again\n     * @deprecated This API is deprecated\n     ",
    "links" : [ "WpsCallback#onFailed", "WpsInfo#LABEL" ]
  }, {
    "name" : "public void cancelWps(WpsCallback listener)",
    "returnType" : "void",
    "comment" : "\n     * WPS support has been deprecated from Client mode and this method will immediately trigger\n     * {@link WpsCallback#onFailed(int)} with a generic error.\n     *\n     * @param listener for callbacks on success or failure. Can be null.\n     * @throws IllegalStateException if the WifiManager instance needs to be initialized again\n     * @deprecated This API is deprecated\n     ",
    "links" : [ "WpsCallback#onFailed" ]
  }, {
    "name" : "public WifiLock createWifiLock(int lockType, String tag)",
    "returnType" : "WifiLock",
    "comment" : "\n     * Creates a new WifiLock.\n     *\n     * @param lockType the type of lock to create. See {@link #WIFI_MODE_FULL_HIGH_PERF}\n     * and {@link #WIFI_MODE_FULL_LOW_LATENCY} for descriptions of the types of Wi-Fi locks.\n     * @param tag a tag for the WifiLock to identify it in debugging messages.  This string is\n     *            never shown to the user under normal conditions, but should be descriptive\n     *            enough to identify your application and the specific WifiLock within it, if it\n     *            holds multiple WifiLocks.\n     *\n     * @return a new, unacquired WifiLock with the given tag.\n     *\n     * @see WifiLock\n     ",
    "links" : [ "#WIFI_MODE_FULL_HIGH_PERF", "#WIFI_MODE_FULL_LOW_LATENCY" ]
  }, {
    "name" : "public WifiLock createWifiLock(String tag)",
    "returnType" : "WifiLock",
    "comment" : "\n     * Creates a new WifiLock.\n     *\n     * @param tag a tag for the WifiLock to identify it in debugging messages.  This string is\n     *            never shown to the user under normal conditions, but should be descriptive\n     *            enough to identify your application and the specific WifiLock within it, if it\n     *            holds multiple WifiLocks.\n     *\n     * @return a new, unacquired WifiLock with the given tag.\n     *\n     * @see WifiLock\n     *\n     * @deprecated This API is non-functional.\n     ",
    "links" : [ ]
  }, {
    "name" : "public MulticastLock createMulticastLock(String tag)",
    "returnType" : "MulticastLock",
    "comment" : "\n     * Create a new MulticastLock\n     *\n     * @param tag a tag for the MulticastLock to identify it in debugging\n     *            messages.  This string is never shown to the user under\n     *            normal conditions, but should be descriptive enough to\n     *            identify your application and the specific MulticastLock\n     *            within it, if it holds multiple MulticastLocks.\n     *\n     * @return a new, unacquired MulticastLock with the given tag.\n     *\n     * @see MulticastLock\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isMulticastEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Check multicast filter status.\n     *\n     * @return true if multicast packets are allowed.\n     *\n     * @hide pending API council approval\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean initializeMulticastFiltering()",
    "returnType" : "boolean",
    "comment" : "\n     * Initialize the multicast filtering to 'on'\n     * @hide no intent to publish\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setVerboseLoggingEnabled(boolean enable)",
    "returnType" : "void",
    "comment" : "\n     * Set Wi-Fi verbose logging level from developer settings.\n     *\n     * @param enable true to enable verbose logging, false to disable.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void enableVerboseLogging(int verbose)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean isVerboseLoggingEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Get the persisted Wi-Fi verbose logging level, set by\n     * {@link #setVerboseLoggingEnabled(boolean)}.\n     * No permissions are required to call this method.\n     *\n     * @return true to indicate that verbose logging is enabled, false to indicate that verbose\n     * logging is disabled.\n     *\n     * @hide\n     ",
    "links" : [ "#setVerboseLoggingEnabled" ]
  }, {
    "name" : "public int getVerboseLoggingLevel()",
    "returnType" : "int",
    "comment" : " TODO(b/145484145): remove once SUW stops calling this via reflection",
    "links" : [ ]
  }, {
    "name" : "public void factoryReset()",
    "returnType" : "void",
    "comment" : "\n     * Removes all saved Wi-Fi networks, Passpoint configurations, ephemeral networks, Network\n     * Requests, and Network Suggestions.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Network getCurrentNetwork()",
    "returnType" : "Network",
    "comment" : "\n     * Get {@link Network} object of current wifi network, or null if not connected.\n     * @hide\n     ",
    "links" : [ "Network" ]
  }, {
    "name" : "public boolean setEnableAutoJoinWhenAssociated(boolean enabled)",
    "returnType" : "boolean",
    "comment" : "\n     * Deprecated\n     * returns false\n     * @hide\n     * @deprecated\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getEnableAutoJoinWhenAssociated()",
    "returnType" : "boolean",
    "comment" : "\n     * Deprecated\n     * returns false\n     * @hide\n     * @deprecated\n     ",
    "links" : [ ]
  }, {
    "name" : "public byte[] retrieveBackupData()",
    "returnType" : "byte[]",
    "comment" : "\n     * Returns a byte stream representing the data that needs to be backed up to save the\n     * current Wifi state.\n     * This Wifi state can be restored by calling {@link #restoreBackupData(byte[])}.\n     * @hide\n     ",
    "links" : [ "#restoreBackupData" ]
  }, {
    "name" : "public void restoreBackupData(@NonNull byte[] data)",
    "returnType" : "void",
    "comment" : "\n     * Restore state from the backed up data.\n     * @param data byte stream in the same format produced by {@link #retrieveBackupData()}\n     * @hide\n     ",
    "links" : [ "#retrieveBackupData" ]
  }, {
    "name" : "public byte[] retrieveSoftApBackupData()",
    "returnType" : "byte[]",
    "comment" : "\n     * Returns a byte stream representing the data that needs to be backed up to save the\n     * current soft ap config data.\n     *\n     * This soft ap config can be restored by calling {@link #restoreSoftApBackupData(byte[])}\n     * @hide\n     ",
    "links" : [ "#restoreSoftApBackupData" ]
  }, {
    "name" : "public SoftApConfiguration restoreSoftApBackupData(@NonNull byte[] data)",
    "returnType" : "SoftApConfiguration",
    "comment" : "\n     * Returns soft ap config from the backed up data or null if data is invalid.\n     * @param data byte stream in the same format produced by {@link #retrieveSoftApBackupData()}\n     *\n     * @hide\n     ",
    "links" : [ "#retrieveSoftApBackupData" ]
  }, {
    "name" : "public void restoreSupplicantBackupData(@NonNull byte[] supplicantData, @NonNull byte[] ipConfigData)",
    "returnType" : "void",
    "comment" : "\n     * Restore state from the older version of back up data.\n     * The old backup data was essentially a backup of wpa_supplicant.conf\n     * and ipconfig.txt file.\n     * @param supplicantData bytes representing wpa_supplicant.conf\n     * @param ipConfigData bytes representing ipconfig.txt\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startSubscriptionProvisioning(@NonNull OsuProvider provider, @NonNull @CallbackExecutor Executor executor, @NonNull ProvisioningCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Start subscription provisioning flow\n     *\n     * @param provider {@link OsuProvider} to provision with\n     * @param executor the Executor on which to run the callback.\n     * @param callback {@link ProvisioningCallback} for updates regarding provisioning flow\n     * @hide\n     ",
    "links" : [ "OsuProvider", "ProvisioningCallback" ]
  }, {
    "name" : "public void registerTrafficStateCallback(@NonNull @CallbackExecutor Executor executor, @NonNull TrafficStateCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Registers a callback for monitoring traffic state. See {@link TrafficStateCallback}. These\n     * callbacks will be invoked periodically by platform to inform clients about the current\n     * traffic state. Caller can unregister a previously registered callback using\n     * {@link #unregisterTrafficStateCallback(TrafficStateCallback)}\n     * <p>\n     * Applications should have the\n     * {@link android.Manifest.permission#NETWORK_SETTINGS NETWORK_SETTINGS} permission. Callers\n     * without the permission will trigger a {@link java.lang.SecurityException}.\n     * <p>\n     *\n     * @param executor The Executor on whose thread to execute the callbacks of the {@code callback}\n     *                 object.\n     * @param callback Callback for traffic state events\n     * @hide\n     ",
    "links" : [ "TrafficStateCallback", "#unregisterTrafficStateCallback", "android.Manifest.permission#NETWORK_SETTINGS", "java.lang.SecurityException" ]
  }, {
    "name" : "public void unregisterTrafficStateCallback(@NonNull TrafficStateCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Allow callers to unregister a previously registered callback. After calling this method,\n     * applications will no longer receive traffic state notifications.\n     *\n     * @param callback Callback to unregister for traffic state events\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void updateVerboseLoggingEnabledFromService()",
    "returnType" : "void",
    "comment" : "\n     * Helper method to update the local verbose logging flag based on the verbose logging\n     * level from wifi service.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isWpa3SaeSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this device supports WPA3-Personal SAE\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isWpa3SuiteBSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this device supports WPA3-Enterprise Suite-B-192\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isEnhancedOpenSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this device supports Wi-Fi Enhanced Open (OWE)\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isEasyConnectSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Wi-Fi Easy Connect (DPP) introduces standardized mechanisms to simplify the provisioning and\n     * configuration of Wi-Fi devices.\n     * For more details, visit <a href=\"https://www.wi-fi.org/\">https://www.wi-fi.org/</a> and\n     * search for \"Easy Connect\" or \"Device Provisioning Protocol specification\".\n     *\n     * @return true if this device supports Wi-Fi Easy-connect (Device Provisioning Protocol)\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isWapiSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this device supports WAPI.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String[] getFactoryMacAddresses()",
    "returnType" : "String[]",
    "comment" : "\n     * Gets the factory Wi-Fi MAC addresses.\n     * @return Array of String representing Wi-Fi MAC addresses sorted lexically or an empty Array\n     * if failed.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDeviceMobilityState(@DeviceMobilityState int state)",
    "returnType" : "void",
    "comment" : "\n     * Updates the device mobility state. Wifi uses this information to adjust the interval between\n     * Wifi scans in order to balance power consumption with scan accuracy.\n     * The default mobility state when the device boots is {@link #DEVICE_MOBILITY_STATE_UNKNOWN}.\n     * This API should be called whenever there is a change in the mobility state.\n     * @param state the updated device mobility state\n     * @hide\n     ",
    "links" : [ "#DEVICE_MOBILITY_STATE_UNKNOWN" ]
  }, {
    "name" : "public void startEasyConnectAsConfiguratorInitiator(@NonNull String enrolleeUri, int selectedNetworkId, @EasyConnectNetworkRole int enrolleeNetworkRole, @NonNull @CallbackExecutor Executor executor, @NonNull EasyConnectStatusCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Start Easy Connect (DPP) in Configurator-Initiator role. The current device will initiate\n     * Easy Connect bootstrapping with a peer, and configure the peer with the SSID and password of\n     * the specified network using the Easy Connect protocol on an encrypted link.\n     *\n     * @param enrolleeUri         URI of the Enrollee obtained separately (e.g. QR code scanning)\n     * @param selectedNetworkId   Selected network ID to be sent to the peer\n     * @param enrolleeNetworkRole The network role of the enrollee\n     * @param callback            Callback for status updates\n     * @param executor            The Executor on which to run the callback.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startEasyConnectAsEnrolleeInitiator(@NonNull String configuratorUri, @NonNull @CallbackExecutor Executor executor, @NonNull EasyConnectStatusCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Start Easy Connect (DPP) in Enrollee-Initiator role. The current device will initiate Easy\n     * Connect bootstrapping with a peer, and receive the SSID and password from the peer\n     * configurator.\n     *\n     * @param configuratorUri URI of the Configurator obtained separately (e.g. QR code scanning)\n     * @param callback        Callback for status updates\n     * @param executor        The Executor on which to run the callback.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void stopEasyConnectSession()",
    "returnType" : "void",
    "comment" : "\n     * Stop or abort a current Easy Connect (DPP) session. This call, once processed, will\n     * terminate any ongoing transaction, and clean up all associated resources. Caller should not\n     * expect any callbacks once this call is made. However, due to the asynchronous nature of\n     * this call, a callback may be fired if it was already pending in the queue.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addOnWifiUsabilityStatsListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnWifiUsabilityStatsListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Adds a listener for Wi-Fi usability statistics. See {@link OnWifiUsabilityStatsListener}.\n     * Multiple listeners can be added. Callers will be invoked periodically by framework to\n     * inform clients about the current Wi-Fi usability statistics. Callers can remove a previously\n     * added listener using {@link removeOnWifiUsabilityStatsListener}.\n     *\n     * @param executor The executor on which callback will be invoked.\n     * @param listener Listener for Wifi usability statistics.\n     *\n     * @hide\n     ",
    "links" : [ "OnWifiUsabilityStatsListener", "removeOnWifiUsabilityStatsListener" ]
  }, {
    "name" : "public void removeOnWifiUsabilityStatsListener(@NonNull OnWifiUsabilityStatsListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Allow callers to remove a previously registered listener. After calling this method,\n     * applications will no longer receive Wi-Fi usability statistics.\n     *\n     * @param listener Listener to remove the Wi-Fi usability statistics.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void updateWifiUsabilityScore(int seqNum, int score, int predictionHorizonSec)",
    "returnType" : "void",
    "comment" : "\n     * Provide a Wi-Fi usability score information to be recorded (but not acted upon) by the\n     * framework. The Wi-Fi usability score is derived from {@link OnWifiUsabilityStatsListener}\n     * where a score is matched to Wi-Fi usability statistics using the sequence number. The score\n     * is used to quantify whether Wi-Fi is usable in a future time.\n     *\n     * @param seqNum Sequence number of the Wi-Fi usability score.\n     * @param score The Wi-Fi usability score, expected range: [0, 100].\n     * @param predictionHorizonSec Prediction horizon of the Wi-Fi usability score in second,\n     *                             expected range: [0, 30].\n     *\n     * @hide\n     ",
    "links" : [ "OnWifiUsabilityStatsListener" ]
  }, {
    "name" : "public void registerScanResultsCallback(@NonNull @CallbackExecutor Executor executor, @NonNull ScanResultsCallback callback)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void unregisterScanResultsCallback(@NonNull ScanResultsCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Allow callers to unregister a previously registered callback. After calling this method,\n     * applications will no longer receive Scan Results events.\n     *\n     * @param callback callback to unregister for Scan Results events\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addSuggestionConnectionStatusListener(@NonNull @CallbackExecutor Executor executor, @NonNull SuggestionConnectionStatusListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Add a listener for suggestion networks. See {@link SuggestionConnectionStatusListener}.\n     * Caller will receive the event when suggested network have connection failure.\n     * Caller can remove a previously registered listener using\n     * {@link WifiManager#removeSuggestionConnectionStatusListener(\n     * SuggestionConnectionStatusListener)}\n     * Same caller can add multiple listeners to monitor the event.\n     * <p>\n     * Applications should have the\n     * {@link android.Manifest.permission#ACCESS_FINE_LOCATION} and\n     * {@link android.Manifest.permission#ACCESS_WIFI_STATE} permissions.\n     * Callers without the permission will trigger a {@link java.lang.SecurityException}.\n     * <p>\n     *\n     * @param executor The executor to execute the listener of the {@code listener} object.\n     * @param listener listener for suggestion network connection failure.\n     ",
    "links" : [ "SuggestionConnectionStatusListener", "WifiManager#removeSuggestionConnectionStatusListener", "android.Manifest.permission#ACCESS_FINE_LOCATION", "android.Manifest.permission#ACCESS_WIFI_STATE", "java.lang.SecurityException" ]
  }, {
    "name" : "public void removeSuggestionConnectionStatusListener(@NonNull SuggestionConnectionStatusListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Allow callers to remove a previously registered listener. After calling this method,\n     * applications will no longer receive suggestion connection events through that listener.\n     *\n     * @param listener listener to remove.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static SparseArray<int[]> parseDppChannelList(String channelList)",
    "returnType" : "SparseArray<int[]>",
    "comment" : "\n     * Parse the list of channels the DPP enrollee reports when it fails to find an AP.\n     *\n     * @param channelList List of channels in the format defined in the DPP specification.\n     * @return A parsed sparse array, where the operating class is the key.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setWifiConnectedNetworkScorer(@NonNull @CallbackExecutor Executor executor, @NonNull WifiConnectedNetworkScorer scorer)",
    "returnType" : "boolean",
    "comment" : "\n     * Set a callback for Wi-Fi connected network scorer.  See {@link WifiConnectedNetworkScorer}.\n     * Only a single scorer can be set. Caller will be invoked periodically by framework to inform\n     * client about start and stop of Wi-Fi connection. Caller can clear a previously set scorer\n     * using {@link clearWifiConnectedNetworkScorer()}.\n     *\n     * @param executor The executor on which callback will be invoked.\n     * @param scorer Scorer for Wi-Fi network implemented by application.\n     * @return true Scorer is set successfully.\n     *\n     * @hide\n     ",
    "links" : [ "WifiConnectedNetworkScorer", "clearWifiConnectedNetworkScorer" ]
  }, {
    "name" : "public void clearWifiConnectedNetworkScorer()",
    "returnType" : "void",
    "comment" : "\n     * Allow caller to clear a previously set scorer. After calling this method,\n     * client will no longer receive information about start and stop of Wi-Fi connection.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setScanThrottleEnabled(boolean enable)",
    "returnType" : "void",
    "comment" : "\n     * Enable/disable wifi scan throttling from 3rd party apps.\n     *\n     * <p>\n     * The throttling limits for apps are described in\n     * <a href=\"Wi-Fi Scan Throttling\">\n     * https://developer.android.com/guide/topics/connectivity/wifi-scan#wifi-scan-throttling</a>\n     * </p>\n     *\n     * @param enable true to allow scan throttling, false to disallow scan throttling.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isScanThrottleEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Get the persisted Wi-Fi scan throttle state. Defaults to true, unless changed by the user via\n     * Developer options.\n     *\n     * <p>\n     * The throttling limits for apps are described in\n     * <a href=\"Wi-Fi Scan Throttling\">\n     * https://developer.android.com/guide/topics/connectivity/wifi-scan#wifi-scan-throttling</a>\n     * </p>\n     *\n     * @return true to indicate that scan throttling is enabled, false to indicate that scan\n     * throttling is disabled.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAutoWakeupEnabled(boolean enable)",
    "returnType" : "void",
    "comment" : "\n     * Enable/disable wifi auto wakeup feature.\n     *\n     * <p>\n     * The feature is described in\n     * <a href=\"Wi-Fi Turn on automatically\">\n     * https://source.android.com/devices/tech/connect/wifi-infrastructure\n     * #turn_on_wi-fi_automatically\n     * </a>\n     *\n     * @param enable true to enable, false to disable.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAutoWakeupEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Get the persisted Wi-Fi auto wakeup feature state. Defaults to false, unless changed by the\n     * user via Settings.\n     *\n     * <p>\n     * The feature is described in\n     * <a href=\"Wi-Fi Turn on automatically\">\n     * https://source.android.com/devices/tech/connect/wifi-infrastructure\n     * #turn_on_wi-fi_automatically\n     * </a>\n     *\n     * @return true to indicate that wakeup feature is enabled, false to indicate that wakeup\n     * feature is disabled.\n     ",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "ERROR_AUTHENTICATING", "ERROR_AUTH_FAILURE_NONE", "ERROR_AUTH_FAILURE_TIMEOUT", "ERROR_AUTH_FAILURE_WRONG_PSWD", "ERROR_AUTH_FAILURE_EAP_FAILURE", "NETWORK_SUGGESTIONS_MAX_PER_APP_LOW_RAM", "NETWORK_SUGGESTIONS_MAX_PER_APP_HIGH_RAM", "STATUS_NETWORK_SUGGESTIONS_SUCCESS", "STATUS_NETWORK_SUGGESTIONS_ERROR_INTERNAL", "STATUS_NETWORK_SUGGESTIONS_ERROR_APP_DISALLOWED", "STATUS_NETWORK_SUGGESTIONS_ERROR_ADD_DUPLICATE", "STATUS_NETWORK_SUGGESTIONS_ERROR_ADD_EXCEEDS_MAX_PER_APP", "STATUS_NETWORK_SUGGESTIONS_ERROR_REMOVE_INVALID", "STATUS_NETWORK_SUGGESTIONS_ERROR_ADD_NOT_ALLOWED", "STATUS_NETWORK_SUGGESTIONS_ERROR_ADD_INVALID", "STATUS_SUGGESTION_CONNECTION_FAILURE_UNKNOWN", "STATUS_SUGGESTION_CONNECTION_FAILURE_ASSOCIATION", "STATUS_SUGGESTION_CONNECTION_FAILURE_AUTHENTICATION", "STATUS_SUGGESTION_CONNECTION_FAILURE_IP_PROVISIONING", "ACTION_WIFI_SCAN_AVAILABILITY_CHANGED", "EXTRA_SCAN_AVAILABLE", "WIFI_CREDENTIAL_CHANGED_ACTION", "EXTRA_WIFI_CREDENTIAL_EVENT_TYPE", "EXTRA_WIFI_CREDENTIAL_SSID", "WIFI_CREDENTIAL_SAVED", "WIFI_CREDENTIAL_FORGOT", "PASSPOINT_HOME_NETWORK", "PASSPOINT_ROAMING_NETWORK", "ACTION_PASSPOINT_ICON", "EXTRA_BSSID_LONG", "EXTRA_ICON", "EXTRA_FILENAME", "ACTION_PASSPOINT_OSU_PROVIDERS_LIST", "EXTRA_ANQP_ELEMENT_DATA", "ACTION_PASSPOINT_DEAUTH_IMMINENT", "EXTRA_ESS", "EXTRA_DELAY", "ACTION_PASSPOINT_SUBSCRIPTION_REMEDIATION", "EXTRA_SUBSCRIPTION_REMEDIATION_METHOD", "ACTION_PASSPOINT_LAUNCH_OSU_VIEW", "EXTRA_OSU_NETWORK", "EXTRA_URL", "WIFI_STATE_CHANGED_ACTION", "EXTRA_WIFI_STATE", "EXTRA_PREVIOUS_WIFI_STATE", "WIFI_STATE_DISABLING", "WIFI_STATE_DISABLED", "WIFI_STATE_ENABLING", "WIFI_STATE_ENABLED", "WIFI_STATE_UNKNOWN", "WIFI_AP_STATE_CHANGED_ACTION", "EXTRA_WIFI_AP_STATE", "EXTRA_WIFI_AP_FAILURE_REASON", "EXTRA_PREVIOUS_WIFI_AP_STATE", "EXTRA_WIFI_AP_INTERFACE_NAME", "EXTRA_WIFI_AP_MODE", "WIFI_AP_STATE_DISABLING", "WIFI_AP_STATE_DISABLED", "WIFI_AP_STATE_ENABLING", "WIFI_AP_STATE_ENABLED", "WIFI_AP_STATE_FAILED", "SAP_START_FAILURE_GENERAL", "SAP_START_FAILURE_NO_CHANNEL", "SAP_START_FAILURE_UNSUPPORTED_CONFIGURATION", "SAP_CLIENT_BLOCK_REASON_CODE_BLOCKED_BY_USER", "SAP_CLIENT_BLOCK_REASON_CODE_NO_MORE_STAS", "SAP_CLIENT_DISCONNECT_REASON_CODE_UNSPECIFIED", "IFACE_IP_MODE_UNSPECIFIED", "IFACE_IP_MODE_CONFIGURATION_ERROR", "IFACE_IP_MODE_TETHERED", "IFACE_IP_MODE_LOCAL_ONLY", "ACTION_NETWORK_SETTINGS_RESET", "SUPPLICANT_CONNECTION_CHANGE_ACTION", "EXTRA_SUPPLICANT_CONNECTED", "NETWORK_STATE_CHANGED_ACTION", "EXTRA_NETWORK_INFO", "EXTRA_BSSID", "EXTRA_WIFI_INFO", "SUPPLICANT_STATE_CHANGED_ACTION", "EXTRA_NEW_STATE", "EXTRA_SUPPLICANT_ERROR", "EXTRA_SUPPLICANT_ERROR_REASON", "CONFIGURED_NETWORKS_CHANGED_ACTION", "EXTRA_WIFI_CONFIGURATION", "EXTRA_MULTIPLE_NETWORKS_CHANGED", "EXTRA_CHANGE_REASON", "CHANGE_REASON_ADDED", "CHANGE_REASON_REMOVED", "CHANGE_REASON_CONFIG_CHANGE", "SCAN_RESULTS_AVAILABLE_ACTION", "EXTRA_RESULTS_UPDATED", "BATCHED_SCAN_RESULTS_AVAILABLE_ACTION", "RSSI_CHANGED_ACTION", "EXTRA_NEW_RSSI", "LINK_CONFIGURATION_CHANGED_ACTION", "ACTION_LINK_CONFIGURATION_CHANGED", "EXTRA_LINK_PROPERTIES", "EXTRA_NETWORK_CAPABILITIES", "NETWORK_IDS_CHANGED_ACTION", "ACTION_REQUEST_SCAN_ALWAYS_AVAILABLE", "ACTION_PICK_WIFI_NETWORK", "ACTION_REQUEST_ENABLE", "ACTION_REQUEST_DISABLE", "ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION", "EXTRA_NETWORK_SUGGESTION", "WIFI_MODE_NO_LOCKS_HELD", "WIFI_MODE_FULL", "WIFI_MODE_SCAN_ONLY", "WIFI_MODE_FULL_HIGH_PERF", "WIFI_MODE_FULL_LOW_LATENCY", "MIN_RSSI", "MAX_RSSI", "RSSI_LEVELS", "WIFI_FREQUENCY_BAND_AUTO", "WIFI_FREQUENCY_BAND_5GHZ", "WIFI_FREQUENCY_BAND_2GHZ", "DEFAULT_POOR_NETWORK_AVOIDANCE_ENABLED", "MAX_ACTIVE_LOCKS", "UNKNOWN_SSID", "ALL_ZEROS_MAC_ADDRESS", "mActiveLockCount", "mContext", "mService", "mTargetSdkVersion", "mLooper", "mVerboseLoggingEnabled", "mLock", "mLOHSCallbackProxy", "mLOHSObserverProxy", "WIFI_FEATURE_INFRA", "WIFI_FEATURE_PASSPOINT", "WIFI_FEATURE_P2P", "WIFI_FEATURE_MOBILE_HOTSPOT", "WIFI_FEATURE_SCANNER", "WIFI_FEATURE_AWARE", "WIFI_FEATURE_D2D_RTT", "WIFI_FEATURE_D2AP_RTT", "WIFI_FEATURE_BATCH_SCAN", "WIFI_FEATURE_PNO", "WIFI_FEATURE_ADDITIONAL_STA", "WIFI_FEATURE_TDLS", "WIFI_FEATURE_TDLS_OFFCHANNEL", "WIFI_FEATURE_EPR", "WIFI_FEATURE_AP_STA", "WIFI_FEATURE_LINK_LAYER_STATS", "WIFI_FEATURE_LOGGER", "WIFI_FEATURE_HAL_EPNO", "WIFI_FEATURE_RSSI_MONITOR", "WIFI_FEATURE_MKEEP_ALIVE", "WIFI_FEATURE_CONFIG_NDO", "WIFI_FEATURE_TRANSMIT_POWER", "WIFI_FEATURE_CONTROL_ROAMING", "WIFI_FEATURE_IE_WHITELIST", "WIFI_FEATURE_SCAN_RAND", "WIFI_FEATURE_TX_POWER_LIMIT", "WIFI_FEATURE_WPA3_SAE", "WIFI_FEATURE_WPA3_SUITE_B", "WIFI_FEATURE_OWE", "WIFI_FEATURE_LOW_LATENCY", "WIFI_FEATURE_DPP", "WIFI_FEATURE_P2P_RAND_MAC", "WIFI_FEATURE_CONNECTED_RAND_MAC", "WIFI_FEATURE_AP_RAND_MAC", "WIFI_FEATURE_MBO", "WIFI_FEATURE_OCE", "WIFI_FEATURE_WAPI", "WIFI_FEATURE_FILS_SHA256", "WIFI_FEATURE_FILS_SHA384", "ERROR", "IN_PROGRESS", "BUSY", "WPS_OVERLAP_ERROR", "WPS_WEP_PROHIBITED", "WPS_TKIP_ONLY_PROHIBITED", "WPS_AUTH_FAILURE", "WPS_TIMED_OUT", "INVALID_ARGS", "NOT_AUTHORIZED", "DEVICE_MOBILITY_STATE_UNKNOWN", "DEVICE_MOBILITY_STATE_HIGH_MVMT", "DEVICE_MOBILITY_STATE_LOW_MVMT", "DEVICE_MOBILITY_STATE_STATIONARY", "EASY_CONNECT_NETWORK_ROLE_STA", "EASY_CONNECT_NETWORK_ROLE_AP" ],
  "methodNames" : [ "public List<WifiConfiguration> getConfiguredNetworks()", "public List<WifiConfiguration> getPrivilegedConfiguredNetworks()", "public List<Pair<WifiConfiguration, Map<Integer, List<ScanResult>>>> getAllMatchingWifiConfigs(@NonNull List<ScanResult> scanResults)", "public List<WifiConfiguration> getWifiConfigForMatchedNetworkSuggestionsSharedWithUser(@NonNull List<ScanResult> scanResults)", "public Map<OsuProvider, List<ScanResult>> getMatchingOsuProviders(@Nullable List<ScanResult> scanResults)", "public Map<OsuProvider, PasspointConfiguration> getMatchingPasspointConfigsForOsuProviders(@NonNull Set<OsuProvider> osuProviders)", "public int addNetwork(WifiConfiguration config)", "public int updateNetwork(WifiConfiguration config)", "private int addOrUpdateNetwork(WifiConfiguration config)", "public void registerNetworkRequestMatchCallback(@NonNull @CallbackExecutor Executor executor, @NonNull NetworkRequestMatchCallback callback)", "public void unregisterNetworkRequestMatchCallback(@NonNull NetworkRequestMatchCallback callback)", "public int addNetworkSuggestions(@NonNull List<WifiNetworkSuggestion> networkSuggestions)", "public int removeNetworkSuggestions(@NonNull List<WifiNetworkSuggestion> networkSuggestions)", "public List<WifiNetworkSuggestion> getNetworkSuggestions()", "public int getMaxNumberOfNetworkSuggestionsPerApp()", "public static int getMaxNumberOfNetworkSuggestionsPerApp(boolean isLowRamDevice)", "public void addOrUpdatePasspointConfiguration(PasspointConfiguration config)", "public void removePasspointConfiguration(String fqdn)", "public List<PasspointConfiguration> getPasspointConfigurations()", "public void queryPasspointIcon(long bssid, String fileName)", "public int matchProviderWithCurrentNetwork(String fqdn)", "public void deauthenticateNetwork(long holdoff, boolean ess)", "public boolean removeNetwork(int netId)", "public boolean enableNetwork(int netId, boolean attemptConnect)", "public boolean disableNetwork(int netId)", "public boolean disconnect()", "public boolean reconnect()", "public boolean reassociate()", "public boolean pingSupplicant()", "private long getSupportedFeatures()", "private boolean isFeatureSupported(long feature)", "public boolean isPasspointSupported()", "public boolean isP2pSupported()", "public boolean isPortableHotspotSupported()", "public boolean isWifiScannerSupported()", "public boolean isWifiAwareSupported()", "public boolean isStaApConcurrencySupported()", "public boolean isDeviceToDeviceRttSupported()", "public boolean isDeviceToApRttSupported()", "public boolean isPreferredNetworkOffloadSupported()", "public boolean isAdditionalStaSupported()", "public boolean isTdlsSupported()", "public boolean isOffChannelTdlsSupported()", "public boolean isEnhancedPowerReportingSupported()", "public boolean isConnectedMacRandomizationSupported()", "public boolean isApMacRandomizationSupported()", "public boolean is5GHzBandSupported()", "public boolean is6GHzBandSupported()", "public boolean isWifiStandardSupported(@WifiAnnotations.WifiStandard int standard)", "public void getWifiActivityEnergyInfoAsync(@NonNull @CallbackExecutor Executor executor, @NonNull OnWifiActivityEnergyInfoListener listener)", "public boolean startScan()", "public boolean startScan(WorkSource workSource)", "public String getCurrentNetworkWpsNfcConfigurationToken()", "public WifiInfo getConnectionInfo()", "public List<ScanResult> getScanResults()", "public Map<WifiNetworkSuggestion, List<ScanResult>> getMatchingScanResults(@NonNull List<WifiNetworkSuggestion> networkSuggestionsToMatch, @Nullable List<ScanResult> scanResults)", "public void setScanAlwaysAvailable(boolean isAvailable)", "public boolean isScanAlwaysAvailable()", "public boolean saveConfiguration()", "public String getCountryCode()", "public DhcpInfo getDhcpInfo()", "public boolean setWifiEnabled(boolean enabled)", "public int getWifiState()", "public boolean isWifiEnabled()", "public static int calculateSignalLevel(int rssi, int numLevels)", "public int calculateSignalLevel(int rssi)", "public int getMaxSignalLevel()", "public static int compareSignalLevel(int rssiA, int rssiB)", "public void updateInterfaceIpState(@Nullable String ifaceName, @IfaceIpMode int mode)", "public boolean startSoftAp(@Nullable WifiConfiguration wifiConfig)", "public boolean startTetheredHotspot(@Nullable SoftApConfiguration softApConfig)", "public boolean stopSoftAp()", "public void startLocalOnlyHotspot(LocalOnlyHotspotCallback callback, @Nullable Handler handler)", "public void startLocalOnlyHotspot(@NonNull SoftApConfiguration config, @Nullable Executor executor, @Nullable LocalOnlyHotspotCallback callback)", "private void startLocalOnlyHotspotInternal(@Nullable SoftApConfiguration config, @Nullable Executor executor, @Nullable LocalOnlyHotspotCallback callback)", "public void cancelLocalOnlyHotspotRequest()", "private void stopLocalOnlyHotspot()", "public void watchLocalOnlyHotspot(LocalOnlyHotspotObserver observer, @Nullable Handler handler)", "public void unregisterLocalOnlyHotspotObserver()", "public int getWifiApState()", "public boolean isWifiApEnabled()", "public WifiConfiguration getWifiApConfiguration()", "public SoftApConfiguration getSoftApConfiguration()", "public boolean setWifiApConfiguration(WifiConfiguration wifiConfig)", "public boolean setSoftApConfiguration(@NonNull SoftApConfiguration softApConfig)", "public void setTdlsEnabled(InetAddress remoteIPAddress, boolean enable)", "public void setTdlsEnabledWithMacAddress(String remoteMacAddress, boolean enable)", "public void registerSoftApCallback(@NonNull @CallbackExecutor Executor executor, @NonNull SoftApCallback callback)", "public void unregisterSoftApCallback(@NonNull SoftApCallback callback)", "private void connectInternal(@Nullable WifiConfiguration config, int networkId, @Nullable ActionListener listener)", "public void connect(@NonNull WifiConfiguration config, @Nullable ActionListener listener)", "public void connect(int networkId, @Nullable ActionListener listener)", "public void save(@NonNull WifiConfiguration config, @Nullable ActionListener listener)", "public void forget(int netId, @Nullable ActionListener listener)", "public void disable(int netId, @Nullable ActionListener listener)", "public void allowAutojoinGlobal(boolean allowAutojoin)", "public void allowAutojoin(int netId, boolean allowAutojoin)", "public void allowAutojoinPasspoint(@NonNull String fqdn, boolean allowAutojoin)", "public void setMacRandomizationSettingPasspointEnabled(@NonNull String fqdn, boolean enable)", "public void setPasspointMeteredOverride(@NonNull String fqdn, @WifiConfiguration.MeteredOverride int meteredOverride)", "public void disableEphemeralNetwork(@NonNull String network)", "public void startWps(WpsInfo config, WpsCallback listener)", "public void cancelWps(WpsCallback listener)", "public WifiLock createWifiLock(int lockType, String tag)", "public WifiLock createWifiLock(String tag)", "public MulticastLock createMulticastLock(String tag)", "public boolean isMulticastEnabled()", "public boolean initializeMulticastFiltering()", "public void setVerboseLoggingEnabled(boolean enable)", "public void enableVerboseLogging(int verbose)", "public boolean isVerboseLoggingEnabled()", "public int getVerboseLoggingLevel()", "public void factoryReset()", "public Network getCurrentNetwork()", "public boolean setEnableAutoJoinWhenAssociated(boolean enabled)", "public boolean getEnableAutoJoinWhenAssociated()", "public byte[] retrieveBackupData()", "public void restoreBackupData(@NonNull byte[] data)", "public byte[] retrieveSoftApBackupData()", "public SoftApConfiguration restoreSoftApBackupData(@NonNull byte[] data)", "public void restoreSupplicantBackupData(@NonNull byte[] supplicantData, @NonNull byte[] ipConfigData)", "public void startSubscriptionProvisioning(@NonNull OsuProvider provider, @NonNull @CallbackExecutor Executor executor, @NonNull ProvisioningCallback callback)", "public void registerTrafficStateCallback(@NonNull @CallbackExecutor Executor executor, @NonNull TrafficStateCallback callback)", "public void unregisterTrafficStateCallback(@NonNull TrafficStateCallback callback)", "private void updateVerboseLoggingEnabledFromService()", "public boolean isWpa3SaeSupported()", "public boolean isWpa3SuiteBSupported()", "public boolean isEnhancedOpenSupported()", "public boolean isEasyConnectSupported()", "public boolean isWapiSupported()", "public String[] getFactoryMacAddresses()", "public void setDeviceMobilityState(@DeviceMobilityState int state)", "public void startEasyConnectAsConfiguratorInitiator(@NonNull String enrolleeUri, int selectedNetworkId, @EasyConnectNetworkRole int enrolleeNetworkRole, @NonNull @CallbackExecutor Executor executor, @NonNull EasyConnectStatusCallback callback)", "public void startEasyConnectAsEnrolleeInitiator(@NonNull String configuratorUri, @NonNull @CallbackExecutor Executor executor, @NonNull EasyConnectStatusCallback callback)", "public void stopEasyConnectSession()", "public void addOnWifiUsabilityStatsListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnWifiUsabilityStatsListener listener)", "public void removeOnWifiUsabilityStatsListener(@NonNull OnWifiUsabilityStatsListener listener)", "public void updateWifiUsabilityScore(int seqNum, int score, int predictionHorizonSec)", "public void registerScanResultsCallback(@NonNull @CallbackExecutor Executor executor, @NonNull ScanResultsCallback callback)", "public void unregisterScanResultsCallback(@NonNull ScanResultsCallback callback)", "public void addSuggestionConnectionStatusListener(@NonNull @CallbackExecutor Executor executor, @NonNull SuggestionConnectionStatusListener listener)", "public void removeSuggestionConnectionStatusListener(@NonNull SuggestionConnectionStatusListener listener)", "public static SparseArray<int[]> parseDppChannelList(String channelList)", "public boolean setWifiConnectedNetworkScorer(@NonNull @CallbackExecutor Executor executor, @NonNull WifiConnectedNetworkScorer scorer)", "public void clearWifiConnectedNetworkScorer()", "public void setScanThrottleEnabled(boolean enable)", "public boolean isScanThrottleEnabled()", "public void setAutoWakeupEnabled(boolean enable)", "public boolean isAutoWakeupEnabled()" ]
}