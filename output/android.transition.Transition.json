{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/transition/Transition.java",
  "packageName" : "android.transition",
  "className" : "Transition",
  "comment" : "\n * A Transition holds information about animations that will be run on its\n * targets during a scene change. Subclasses of this abstract class may\n * choreograph several child transitions ({@link TransitionSet} or they may\n * perform custom animations themselves. Any Transition has two main jobs:\n * (1) capture property values, and (2) play animations based on changes to\n * captured property values. A custom transition knows what property values\n * on View objects are of interest to it, and also knows how to animate\n * changes to those values. For example, the {@link Fade} transition tracks\n * changes to visibility-related properties and is able to construct and run\n * animations that fade items in or out based on changes to those properties.\n *\n * <p>Note: Transitions may not work correctly with either {@link SurfaceView}\n * or {@link TextureView}, due to the way that these views are displayed\n * on the screen. For SurfaceView, the problem is that the view is updated from\n * a non-UI thread, so changes to the view due to transitions (such as moving\n * and resizing the view) may be out of sync with the display inside those bounds.\n * TextureView is more compatible with transitions in general, but some\n * specific transitions (such as {@link Fade}) may not be compatible\n * with TextureView because they rely on {@link ViewOverlay} functionality,\n * which does not currently work with TextureView.</p>\n *\n * <p>Transitions can be declared in XML resource files inside the <code>res/transition</code>\n * directory. Transition resources consist of a tag name for one of the Transition\n * subclasses along with attributes to define some of the attributes of that transition.\n * For example, here is a minimal resource file that declares a {@link ChangeBounds} transition:\n *\n * {@sample development/samples/ApiDemos/res/transition/changebounds.xml ChangeBounds}\n *\n * <p>This TransitionSet contains {@link android.transition.Explode} for visibility,\n * {@link android.transition.ChangeBounds}, {@link android.transition.ChangeTransform},\n * and {@link android.transition.ChangeClipBounds} and\n * {@link android.transition.ChangeImageTransform}:</p>\n *\n * {@sample development/samples/ApiDemos/res/transition/explode_move_together.xml MultipleTransform}\n *\n * <p>Custom transition classes may be instantiated with a <code>transition</code> tag:</p>\n * <pre>&lt;transition class=\"my.app.transition.CustomTransition\"/></pre>\n * <p>Custom transition classes loaded from XML should have a public constructor taking\n * a {@link android.content.Context} and {@link android.util.AttributeSet}.</p>\n *\n * <p>Note that attributes for the transition are not required, just as they are\n * optional when declared in code; Transitions created from XML resources will use\n * the same defaults as their code-created equivalents. Here is a slightly more\n * elaborate example which declares a {@link TransitionSet} transition with\n * {@link ChangeBounds} and {@link Fade} child transitions:</p>\n *\n * {@sample\n * development/samples/ApiDemos/res/transition/changebounds_fadeout_sequential.xml TransitionSet}\n *\n * <p>In this example, the transitionOrdering attribute is used on the TransitionSet\n * object to change from the default {@link TransitionSet#ORDERING_TOGETHER} behavior\n * to be {@link TransitionSet#ORDERING_SEQUENTIAL} instead. Also, the {@link Fade}\n * transition uses a fadingMode of {@link Fade#OUT} instead of the default\n * out-in behavior. Finally, note the use of the <code>targets</code> sub-tag, which\n * takes a set of {@link android.R.styleable#TransitionTarget target} tags, each\n * of which lists a specific <code>targetId</code>, <code>targetClass</code>,\n * <code>targetName</code>, <code>excludeId</code>, <code>excludeClass</code>, or\n * <code>excludeName</code>, which this transition acts upon.\n * Use of targets is optional, but can be used to either limit the time spent checking\n * attributes on unchanging views, or limiting the types of animations run on specific views.\n * In this case, we know that only the <code>grayscaleContainer</code> will be\n * disappearing, so we choose to limit the {@link Fade} transition to only that view.</p>\n *\n * Further information on XML resource descriptions for transitions can be found for\n * {@link android.R.styleable#Transition}, {@link android.R.styleable#TransitionSet},\n * {@link android.R.styleable#TransitionTarget}, {@link android.R.styleable#Fade},\n * {@link android.R.styleable#Slide}, and {@link android.R.styleable#ChangeTransform}.\n *\n ",
  "links" : [ "android.content.Context", "android.R.styleable#Fade", "android.R.styleable#Slide", "android.R.styleable#ChangeTransform", "android.R.styleable#TransitionTarget", "android.view.SurfaceView", "android.transition.ChangeTransform", "android.transition.ChangeClipBounds", "android.R.styleable#Transition", "android.transition.Fade#OUT", "android.view.TextureView", "android.view.ViewOverlay", "android.transition.TransitionSet#ORDERING_TOGETHER", "android.transition.ChangeBounds", "android.transition.Explode", "android.util.AttributeSet", "android.R.styleable#TransitionSet", "android.transition.Fade", "android.transition.ChangeImageTransform", "android.transition.TransitionSet#ORDERING_SEQUENTIAL", "android.transition.TransitionSet" ],
  "variables" : [ {
    "name" : "LOG_TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DBG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MATCH_INSTANCE",
    "type" : "int",
    "comment" : "\n     * With {@link #setMatchOrder(int...)}, chooses to match by View instance.\n     ",
    "links" : [ "#setMatchOrder(int...)" ]
  }, {
    "name" : "MATCH_FIRST",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MATCH_NAME",
    "type" : "int",
    "comment" : "\n     * With {@link #setMatchOrder(int...)}, chooses to match by\n     * {@link android.view.View#getTransitionName()}. Null names will not be matched.\n     ",
    "links" : [ "android.view.View#getTransitionName()", "#setMatchOrder(int...)" ]
  }, {
    "name" : "MATCH_ID",
    "type" : "int",
    "comment" : "\n     * With {@link #setMatchOrder(int...)}, chooses to match by\n     * {@link android.view.View#getId()}. Negative IDs will not be matched.\n     ",
    "links" : [ "android.view.View#getId()", "#setMatchOrder(int...)" ]
  }, {
    "name" : "MATCH_ITEM_ID",
    "type" : "int",
    "comment" : "\n     * With {@link #setMatchOrder(int...)}, chooses to match by the {@link android.widget.Adapter}\n     * item id. When {@link android.widget.Adapter#hasStableIds()} returns false, no match\n     * will be made for items.\n     ",
    "links" : [ "android.widget.Adapter", "android.widget.Adapter#hasStableIds()", "#setMatchOrder(int...)" ]
  }, {
    "name" : "MATCH_LAST",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MATCH_INSTANCE_STR",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MATCH_NAME_STR",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MATCH_VIEW_NAME_STR",
    "type" : "String",
    "comment" : " To be removed before L release ",
    "links" : [ ]
  }, {
    "name" : "MATCH_ID_STR",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MATCH_ITEM_ID_STR",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_MATCH_ORDER",
    "type" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "STRAIGHT_PATH_MOTION",
    "type" : "PathMotion",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mName",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mStartDelay",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDuration",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInterpolator",
    "type" : "TimeInterpolator",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTargetIds",
    "type" : "ArrayList<Integer>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTargets",
    "type" : "ArrayList<View>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTargetNames",
    "type" : "ArrayList<String>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTargetTypes",
    "type" : "ArrayList<Class>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTargetIdExcludes",
    "type" : "ArrayList<Integer>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTargetExcludes",
    "type" : "ArrayList<View>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTargetTypeExcludes",
    "type" : "ArrayList<Class>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTargetNameExcludes",
    "type" : "ArrayList<String>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTargetIdChildExcludes",
    "type" : "ArrayList<Integer>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTargetChildExcludes",
    "type" : "ArrayList<View>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTargetTypeChildExcludes",
    "type" : "ArrayList<Class>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mStartValues",
    "type" : "TransitionValuesMaps",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mEndValues",
    "type" : "TransitionValuesMaps",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mParent",
    "type" : "TransitionSet",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMatchOrder",
    "type" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mStartValuesList",
    "type" : "ArrayList<TransitionValues>",
    "comment" : " only valid after playTransition starts",
    "links" : [ ]
  }, {
    "name" : "mEndValuesList",
    "type" : "ArrayList<TransitionValues>",
    "comment" : " only valid after playTransitions starts",
    "links" : [ ]
  }, {
    "name" : "sRunningAnimators",
    "type" : "ThreadLocal<ArrayMap<Animator, AnimationInfo>>",
    "comment" : " Per-animator information used for later canceling when future transitions overlap",
    "links" : [ ]
  }, {
    "name" : "mSceneRoot",
    "type" : "ViewGroup",
    "comment" : " Scene Root is set at createAnimator() time in the cloned Transition",
    "links" : [ ]
  }, {
    "name" : "mCanRemoveViews",
    "type" : "boolean",
    "comment" : " removing them from parents to add them to overlays.",
    "links" : [ ]
  }, {
    "name" : "mCurrentAnimators",
    "type" : "ArrayList<Animator>",
    "comment" : " cancel running animators",
    "links" : [ ]
  }, {
    "name" : "mNumInstances",
    "type" : "int",
    "comment" : " determined by calls to start() and end()",
    "links" : [ ]
  }, {
    "name" : "mPaused",
    "type" : "boolean",
    "comment" : " Whether this transition is currently paused, due to a call to pause()",
    "links" : [ ]
  }, {
    "name" : "mEnded",
    "type" : "boolean",
    "comment" : " that have completed",
    "links" : [ ]
  }, {
    "name" : "mListeners",
    "type" : "ArrayList<TransitionListener>",
    "comment" : " The set of listeners to be sent transition lifecycle events.",
    "links" : [ ]
  }, {
    "name" : "mAnimators",
    "type" : "ArrayList<Animator>",
    "comment" : " to be run in runAnimators()",
    "links" : [ ]
  }, {
    "name" : "mPropagation",
    "type" : "TransitionPropagation",
    "comment" : " The function for calculating the Animation start delay.",
    "links" : [ ]
  }, {
    "name" : "mEpicenterCallback",
    "type" : "EpicenterCallback",
    "comment" : " like CircularPropagation",
    "links" : [ ]
  }, {
    "name" : "mNameOverrides",
    "type" : "ArrayMap<String, String>",
    "comment" : " transitionNames.",
    "links" : [ ]
  }, {
    "name" : "mPathMotion",
    "type" : "PathMotion",
    "comment" : " for adding curves to x/y View motion.",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private static int[] parseMatchOrder(String matchOrderString)",
    "returnType" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Transition setDuration(long duration)",
    "returnType" : "Transition",
    "comment" : "\n     * Sets the duration of this transition. By default, there is no duration\n     * (indicated by a negative number), which means that the Animator created by\n     * the transition will have its own specified duration. If the duration of a\n     * Transition is set, that duration will override the Animator duration.\n     *\n     * @param duration The length of the animation, in milliseconds.\n     * @return This transition object.\n     * @attr ref android.R.styleable#Transition_duration\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getDuration()",
    "returnType" : "long",
    "comment" : "\n     * Returns the duration set on this transition. If no duration has been set,\n     * the returned value will be negative, indicating that resulting animators will\n     * retain their own durations.\n     *\n     * @return The duration set on this transition, in milliseconds, if one has been\n     * set, otherwise returns a negative number.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Transition setStartDelay(long startDelay)",
    "returnType" : "Transition",
    "comment" : "\n     * Sets the startDelay of this transition. By default, there is no delay\n     * (indicated by a negative number), which means that the Animator created by\n     * the transition will have its own specified startDelay. If the delay of a\n     * Transition is set, that delay will override the Animator delay.\n     *\n     * @param startDelay The length of the delay, in milliseconds.\n     * @return This transition object.\n     * @attr ref android.R.styleable#Transition_startDelay\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getStartDelay()",
    "returnType" : "long",
    "comment" : "\n     * Returns the startDelay set on this transition. If no startDelay has been set,\n     * the returned value will be negative, indicating that resulting animators will\n     * retain their own startDelays.\n     *\n     * @return The startDelay set on this transition, in milliseconds, if one has\n     * been set, otherwise returns a negative number.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Transition setInterpolator(TimeInterpolator interpolator)",
    "returnType" : "Transition",
    "comment" : "\n     * Sets the interpolator of this transition. By default, the interpolator\n     * is null, which means that the Animator created by the transition\n     * will have its own specified interpolator. If the interpolator of a\n     * Transition is set, that interpolator will override the Animator interpolator.\n     *\n     * @param interpolator The time interpolator used by the transition\n     * @return This transition object.\n     * @attr ref android.R.styleable#Transition_interpolator\n     ",
    "links" : [ ]
  }, {
    "name" : "public TimeInterpolator getInterpolator()",
    "returnType" : "TimeInterpolator",
    "comment" : "\n     * Returns the interpolator set on this transition. If no interpolator has been set,\n     * the returned value will be null, indicating that resulting animators will\n     * retain their own interpolators.\n     *\n     * @return The interpolator set on this transition, if one has been set, otherwise\n     * returns null.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String[] getTransitionProperties()",
    "returnType" : "String[]",
    "comment" : "\n     * Returns the set of property names used stored in the {@link TransitionValues}\n     * object passed into {@link #captureStartValues(TransitionValues)} that\n     * this transition cares about for the purposes of canceling overlapping animations.\n     * When any transition is started on a given scene root, all transitions\n     * currently running on that same scene root are checked to see whether the\n     * properties on which they based their animations agree with the end values of\n     * the same properties in the new transition. If the end values are not equal,\n     * then the old animation is canceled since the new transition will start a new\n     * animation to these new values. If the values are equal, the old animation is\n     * allowed to continue and no new animation is started for that transition.\n     *\n     * <p>A transition does not need to override this method. However, not doing so\n     * will mean that the cancellation logic outlined in the previous paragraph\n     * will be skipped for that transition, possibly leading to artifacts as\n     * old transitions and new transitions on the same targets run in parallel,\n     * animating views toward potentially different end values.</p>\n     *\n     * @return An array of property names as described in the class documentation for\n     * {@link TransitionValues}. The default implementation returns <code>null</code>.\n     ",
    "links" : [ "android.transition.TransitionValues", "#captureStartValues(TransitionValues)" ]
  }, {
    "name" : "public Animator createAnimator(@NonNull ViewGroup sceneRoot, @Nullable TransitionValues startValues, @Nullable TransitionValues endValues)",
    "returnType" : "Animator",
    "comment" : "\n     * This method creates an animation that will be run for this transition\n     * given the information in the startValues and endValues structures captured\n     * earlier for the start and end scenes. Subclasses of Transition should override\n     * this method. The method should only be called by the transition system; it is\n     * not intended to be called from external classes.\n     *\n     * <p>This method is called by the transition's parent (all the way up to the\n     * topmost Transition in the hierarchy) with the sceneRoot and start/end\n     * values that the transition may need to set up initial target values\n     * and construct an appropriate animation. For example, if an overall\n     * Transition is a {@link TransitionSet} consisting of several\n     * child transitions in sequence, then some of the child transitions may\n     * want to set initial values on target views prior to the overall\n     * Transition commencing, to put them in an appropriate state for the\n     * delay between that start and the child Transition start time. For\n     * example, a transition that fades an item in may wish to set the starting\n     * alpha value to 0, to avoid it blinking in prior to the transition\n     * actually starting the animation. This is necessary because the scene\n     * change that triggers the Transition will automatically set the end-scene\n     * on all target views, so a Transition that wants to animate from a\n     * different value should set that value prior to returning from this method.</p>\n     *\n     * <p>Additionally, a Transition can perform logic to determine whether\n     * the transition needs to run on the given target and start/end values.\n     * For example, a transition that resizes objects on the screen may wish\n     * to avoid running for views which are not present in either the start\n     * or end scenes.</p>\n     *\n     * <p>If there is an animator created and returned from this method, the\n     * transition mechanism will apply any applicable duration, startDelay,\n     * and interpolator to that animation and start it. A return value of\n     * <code>null</code> indicates that no animation should run. The default\n     * implementation returns null.</p>\n     *\n     * <p>The method is called for every applicable target object, which is\n     * stored in the {@link TransitionValues#view} field.</p>\n     *\n     *\n     * @param sceneRoot The root of the transition hierarchy.\n     * @param startValues The values for a specific target in the start scene, or {@code null} if\n     *                   the target doesn't exist in the start scene.\n     * @param endValues The values for the target in the end scene, or {@code null} if the target\n     *                 doesn't exist in the end scene.\n     * @return an {@link Animator} to be started at the appropriate time in the overall transition\n     * for this scene change. A {@code null} value means no animation should be run.\n     ",
    "links" : [ "android.transition.TransitionValues#view", "android.animation.Animator", "android.transition.TransitionSet" ]
  }, {
    "name" : "public void setMatchOrder(int... matches)",
    "returnType" : "void",
    "comment" : "\n     * Sets the order in which Transition matches View start and end values.\n     * <p>\n     * The default behavior is to match first by {@link android.view.View#getTransitionName()},\n     * then by View instance, then by {@link android.view.View#getId()} and finally\n     * by its item ID if it is in a direct child of ListView. The caller can\n     * choose to have only some or all of the values of {@link #MATCH_INSTANCE},\n     * {@link #MATCH_NAME}, {@link #MATCH_ITEM_ID}, and {@link #MATCH_ID}. Only\n     * the match algorithms supplied will be used to determine whether Views are the\n     * the same in both the start and end Scene. Views that do not match will be considered\n     * as entering or leaving the Scene.\n     * </p>\n     * @param matches A list of zero or more of {@link #MATCH_INSTANCE},\n     *                {@link #MATCH_NAME}, {@link #MATCH_ITEM_ID}, and {@link #MATCH_ID}.\n     *                If none are provided, then the default match order will be set.\n     ",
    "links" : [ "#MATCH_NAME", "#MATCH_INSTANCE", "android.view.View#getTransitionName()", "#MATCH_ID", "#MATCH_ITEM_ID", "android.view.View#getId()" ]
  }, {
    "name" : "private static boolean isValidMatch(int match)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean alreadyContains(int[] array, int searchIndex)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void matchInstances(ArrayMap<View, TransitionValues> unmatchedStart, ArrayMap<View, TransitionValues> unmatchedEnd)",
    "returnType" : "void",
    "comment" : "\n     * Match start/end values by View instance. Adds matched values to mStartValuesList\n     * and mEndValuesList and removes them from unmatchedStart and unmatchedEnd.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void matchItemIds(ArrayMap<View, TransitionValues> unmatchedStart, ArrayMap<View, TransitionValues> unmatchedEnd, LongSparseArray<View> startItemIds, LongSparseArray<View> endItemIds)",
    "returnType" : "void",
    "comment" : "\n     * Match start/end values by Adapter item ID. Adds matched values to mStartValuesList\n     * and mEndValuesList and removes them from unmatchedStart and unmatchedEnd, using\n     * startItemIds and endItemIds as a guide for which Views have unique item IDs.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void matchIds(ArrayMap<View, TransitionValues> unmatchedStart, ArrayMap<View, TransitionValues> unmatchedEnd, SparseArray<View> startIds, SparseArray<View> endIds)",
    "returnType" : "void",
    "comment" : "\n     * Match start/end values by Adapter view ID. Adds matched values to mStartValuesList\n     * and mEndValuesList and removes them from unmatchedStart and unmatchedEnd, using\n     * startIds and endIds as a guide for which Views have unique IDs.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void matchNames(ArrayMap<View, TransitionValues> unmatchedStart, ArrayMap<View, TransitionValues> unmatchedEnd, ArrayMap<String, View> startNames, ArrayMap<String, View> endNames)",
    "returnType" : "void",
    "comment" : "\n     * Match start/end values by Adapter transitionName. Adds matched values to mStartValuesList\n     * and mEndValuesList and removes them from unmatchedStart and unmatchedEnd, using\n     * startNames and endNames as a guide for which Views have unique transitionNames.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void addUnmatched(ArrayMap<View, TransitionValues> unmatchedStart, ArrayMap<View, TransitionValues> unmatchedEnd)",
    "returnType" : "void",
    "comment" : "\n     * Adds all values from unmatchedStart and unmatchedEnd to mStartValuesList and mEndValuesList,\n     * assuming that there is no match between values in the list.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void matchStartAndEnd(TransitionValuesMaps startValues, TransitionValuesMaps endValues)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void createAnimators(ViewGroup sceneRoot, TransitionValuesMaps startValues, TransitionValuesMaps endValues, ArrayList<TransitionValues> startValuesList, ArrayList<TransitionValues> endValuesList)",
    "returnType" : "void",
    "comment" : "\n     * This method, essentially a wrapper around all calls to createAnimator for all\n     * possible target views, is called with the entire set of start/end\n     * values. The implementation in Transition iterates through these lists\n     * and calls {@link #createAnimator(ViewGroup, TransitionValues, TransitionValues)}\n     * with each set of start/end values on this transition. The\n     * TransitionSet subclass overrides this method and delegates it to\n     * each of its children in succession.\n     *\n     * @hide\n     ",
    "links" : [ "#createAnimator(ViewGroup" ]
  }, {
    "name" : "public boolean isValidTarget(View target)",
    "returnType" : "boolean",
    "comment" : "\n     * Internal utility method for checking whether a given view/id\n     * is valid for this transition, where \"valid\" means that either\n     * the Transition has no target/targetId list (the default, in which\n     * cause the transition should act on all views in the hiearchy), or\n     * the given view is in the target list or the view id is in the\n     * targetId list. If the target parameter is null, then the target list\n     * is not checked (this is in the case of ListView items, where the\n     * views are ignored and only the ids are used).\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static ArrayMap<Animator, AnimationInfo> getRunningAnimators()",
    "returnType" : "ArrayMap<Animator, AnimationInfo>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void runAnimators()",
    "returnType" : "void",
    "comment" : "\n     * This is called internally once all animations have been set up by the\n     * transition hierarchy.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void runAnimator(Animator animator, final ArrayMap<Animator, AnimationInfo> runningAnimators)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public abstract void captureStartValues(TransitionValues transitionValues)",
    "returnType" : "void",
    "comment" : "\n     * Captures the values in the start scene for the properties that this\n     * transition monitors. These values are then passed as the startValues\n     * structure in a later call to\n     * {@link #createAnimator(ViewGroup, TransitionValues, TransitionValues)}.\n     * The main concern for an implementation is what the\n     * properties are that the transition cares about and what the values are\n     * for all of those properties. The start and end values will be compared\n     * later during the\n     * {@link #createAnimator(android.view.ViewGroup, TransitionValues, TransitionValues)}\n     * method to determine what, if any, animations, should be run.\n     *\n     * <p>Subclasses must implement this method. The method should only be called by the\n     * transition system; it is not intended to be called from external classes.</p>\n     *\n     * @param transitionValues The holder for any values that the Transition\n     * wishes to store. Values are stored in the <code>values</code> field\n     * of this TransitionValues object and are keyed from\n     * a String value. For example, to store a view's rotation value,\n     * a transition might call\n     * <code>transitionValues.values.put(\"appname:transitionname:rotation\",\n     * view.getRotation())</code>. The target view will already be stored in\n     * the transitionValues structure when this method is called.\n     *\n     * @see #captureEndValues(TransitionValues)\n     * @see #createAnimator(ViewGroup, TransitionValues, TransitionValues)\n     ",
    "links" : [ "#createAnimator(android.view.ViewGroup", "#createAnimator(ViewGroup" ]
  }, {
    "name" : "public abstract void captureEndValues(TransitionValues transitionValues)",
    "returnType" : "void",
    "comment" : "\n     * Captures the values in the end scene for the properties that this\n     * transition monitors. These values are then passed as the endValues\n     * structure in a later call to\n     * {@link #createAnimator(ViewGroup, TransitionValues, TransitionValues)}.\n     * The main concern for an implementation is what the\n     * properties are that the transition cares about and what the values are\n     * for all of those properties. The start and end values will be compared\n     * later during the\n     * {@link #createAnimator(android.view.ViewGroup, TransitionValues, TransitionValues)}\n     * method to determine what, if any, animations, should be run.\n     *\n     * <p>Subclasses must implement this method. The method should only be called by the\n     * transition system; it is not intended to be called from external classes.</p>\n     *\n     * @param transitionValues The holder for any values that the Transition\n     * wishes to store. Values are stored in the <code>values</code> field\n     * of this TransitionValues object and are keyed from\n     * a String value. For example, to store a view's rotation value,\n     * a transition might call\n     * <code>transitionValues.values.put(\"appname:transitionname:rotation\",\n     * view.getRotation())</code>. The target view will already be stored in\n     * the transitionValues structure when this method is called.\n     *\n     * @see #captureStartValues(TransitionValues)\n     * @see #createAnimator(ViewGroup, TransitionValues, TransitionValues)\n     ",
    "links" : [ "#createAnimator(android.view.ViewGroup", "#createAnimator(ViewGroup" ]
  }, {
    "name" : "public Transition addTarget(int targetId)",
    "returnType" : "Transition",
    "comment" : "\n     * Adds the id of a target view that this Transition is interested in\n     * animating. By default, there are no targetIds, and a Transition will\n     * listen for changes on every view in the hierarchy below the sceneRoot\n     * of the Scene being transitioned into. Setting targetIds constrains\n     * the Transition to only listen for, and act on, views with these IDs.\n     * Views with different IDs, or no IDs whatsoever, will be ignored.\n     *\n     * <p>Note that using ids to specify targets implies that ids should be unique\n     * within the view hierarchy underneath the scene root.</p>\n     *\n     * @see View#getId()\n     * @param targetId The id of a target view, must be a positive number.\n     * @return The Transition to which the targetId is added.\n     * Returning the same object makes it easier to chain calls during\n     * construction, such as\n     * <code>transitionSet.addTransitions(new Fade()).addTarget(someId);</code>\n     ",
    "links" : [ ]
  }, {
    "name" : "public Transition addTarget(String targetName)",
    "returnType" : "Transition",
    "comment" : "\n     * Adds the transitionName of a target view that this Transition is interested in\n     * animating. By default, there are no targetNames, and a Transition will\n     * listen for changes on every view in the hierarchy below the sceneRoot\n     * of the Scene being transitioned into. Setting targetNames constrains\n     * the Transition to only listen for, and act on, views with these transitionNames.\n     * Views with different transitionNames, or no transitionName whatsoever, will be ignored.\n     *\n     * <p>Note that transitionNames should be unique within the view hierarchy.</p>\n     *\n     * @see android.view.View#getTransitionName()\n     * @param targetName The transitionName of a target view, must be non-null.\n     * @return The Transition to which the target transitionName is added.\n     * Returning the same object makes it easier to chain calls during\n     * construction, such as\n     * <code>transitionSet.addTransitions(new Fade()).addTarget(someName);</code>\n     ",
    "links" : [ ]
  }, {
    "name" : "public Transition addTarget(Class targetType)",
    "returnType" : "Transition",
    "comment" : "\n     * Adds the Class of a target view that this Transition is interested in\n     * animating. By default, there are no targetTypes, and a Transition will\n     * listen for changes on every view in the hierarchy below the sceneRoot\n     * of the Scene being transitioned into. Setting targetTypes constrains\n     * the Transition to only listen for, and act on, views with these classes.\n     * Views with different classes will be ignored.\n     *\n     * <p>Note that any View that can be cast to targetType will be included, so\n     * if targetType is <code>View.class</code>, all Views will be included.</p>\n     *\n     * @see #addTarget(int)\n     * @see #addTarget(android.view.View)\n     * @see #excludeTarget(Class, boolean)\n     * @see #excludeChildren(Class, boolean)\n     *\n     * @param targetType The type to include when running this transition.\n     * @return The Transition to which the target class was added.\n     * Returning the same object makes it easier to chain calls during\n     * construction, such as\n     * <code>transitionSet.addTransitions(new Fade()).addTarget(ImageView.class);</code>\n     ",
    "links" : [ ]
  }, {
    "name" : "public Transition removeTarget(int targetId)",
    "returnType" : "Transition",
    "comment" : "\n     * Removes the given targetId from the list of ids that this Transition\n     * is interested in animating.\n     *\n     * @param targetId The id of a target view, must be a positive number.\n     * @return The Transition from which the targetId is removed.\n     * Returning the same object makes it easier to chain calls during\n     * construction, such as\n     * <code>transitionSet.addTransitions(new Fade()).removeTargetId(someId);</code>\n     ",
    "links" : [ ]
  }, {
    "name" : "public Transition removeTarget(String targetName)",
    "returnType" : "Transition",
    "comment" : "\n     * Removes the given targetName from the list of transitionNames that this Transition\n     * is interested in animating.\n     *\n     * @param targetName The transitionName of a target view, must not be null.\n     * @return The Transition from which the targetName is removed.\n     * Returning the same object makes it easier to chain calls during\n     * construction, such as\n     * <code>transitionSet.addTransitions(new Fade()).removeTargetName(someName);</code>\n     ",
    "links" : [ ]
  }, {
    "name" : "public Transition excludeTarget(int targetId, boolean exclude)",
    "returnType" : "Transition",
    "comment" : "\n     * Whether to add the given id to the list of target ids to exclude from this\n     * transition. The <code>exclude</code> parameter specifies whether the target\n     * should be added to or removed from the excluded list.\n     *\n     * <p>Excluding targets is a general mechanism for allowing transitions to run on\n     * a view hierarchy while skipping target views that should not be part of\n     * the transition. For example, you may want to avoid animating children\n     * of a specific ListView or Spinner. Views can be excluded either by their\n     * id, or by their instance reference, or by the Class of that view\n     * (eg, {@link Spinner}).</p>\n     *\n     * @see #excludeChildren(int, boolean)\n     * @see #excludeTarget(View, boolean)\n     * @see #excludeTarget(Class, boolean)\n     *\n     * @param targetId The id of a target to ignore when running this transition.\n     * @param exclude Whether to add the target to or remove the target from the\n     * current list of excluded targets.\n     * @return This transition object.\n     ",
    "links" : [ "android.widget.Spinner" ]
  }, {
    "name" : "public Transition excludeTarget(String targetName, boolean exclude)",
    "returnType" : "Transition",
    "comment" : "\n     * Whether to add the given transitionName to the list of target transitionNames to exclude\n     * from this transition. The <code>exclude</code> parameter specifies whether the target\n     * should be added to or removed from the excluded list.\n     *\n     * <p>Excluding targets is a general mechanism for allowing transitions to run on\n     * a view hierarchy while skipping target views that should not be part of\n     * the transition. For example, you may want to avoid animating children\n     * of a specific ListView or Spinner. Views can be excluded by their\n     * id, their instance reference, their transitionName, or by the Class of that view\n     * (eg, {@link Spinner}).</p>\n     *\n     * @see #excludeTarget(View, boolean)\n     * @see #excludeTarget(int, boolean)\n     * @see #excludeTarget(Class, boolean)\n     *\n     * @param targetName The name of a target to ignore when running this transition.\n     * @param exclude Whether to add the target to or remove the target from the\n     * current list of excluded targets.\n     * @return This transition object.\n     ",
    "links" : [ "android.widget.Spinner" ]
  }, {
    "name" : "public Transition excludeChildren(int targetId, boolean exclude)",
    "returnType" : "Transition",
    "comment" : "\n     * Whether to add the children of the given id to the list of targets to exclude\n     * from this transition. The <code>exclude</code> parameter specifies whether\n     * the children of the target should be added to or removed from the excluded list.\n     * Excluding children in this way provides a simple mechanism for excluding all\n     * children of specific targets, rather than individually excluding each\n     * child individually.\n     *\n     * <p>Excluding targets is a general mechanism for allowing transitions to run on\n     * a view hierarchy while skipping target views that should not be part of\n     * the transition. For example, you may want to avoid animating children\n     * of a specific ListView or Spinner. Views can be excluded either by their\n     * id, or by their instance reference, or by the Class of that view\n     * (eg, {@link Spinner}).</p>\n     *\n     * @see #excludeTarget(int, boolean)\n     * @see #excludeChildren(View, boolean)\n     * @see #excludeChildren(Class, boolean)\n     *\n     * @param targetId The id of a target whose children should be ignored when running\n     * this transition.\n     * @param exclude Whether to add the target to or remove the target from the\n     * current list of excluded-child targets.\n     * @return This transition object.\n     ",
    "links" : [ "android.widget.Spinner" ]
  }, {
    "name" : "public Transition excludeTarget(View target, boolean exclude)",
    "returnType" : "Transition",
    "comment" : "\n     * Whether to add the given target to the list of targets to exclude from this\n     * transition. The <code>exclude</code> parameter specifies whether the target\n     * should be added to or removed from the excluded list.\n     *\n     * <p>Excluding targets is a general mechanism for allowing transitions to run on\n     * a view hierarchy while skipping target views that should not be part of\n     * the transition. For example, you may want to avoid animating children\n     * of a specific ListView or Spinner. Views can be excluded either by their\n     * id, or by their instance reference, or by the Class of that view\n     * (eg, {@link Spinner}).</p>\n     *\n     * @see #excludeChildren(View, boolean)\n     * @see #excludeTarget(int, boolean)\n     * @see #excludeTarget(Class, boolean)\n     *\n     * @param target The target to ignore when running this transition.\n     * @param exclude Whether to add the target to or remove the target from the\n     * current list of excluded targets.\n     * @return This transition object.\n     ",
    "links" : [ "android.widget.Spinner" ]
  }, {
    "name" : "public Transition excludeChildren(View target, boolean exclude)",
    "returnType" : "Transition",
    "comment" : "\n     * Whether to add the children of given target to the list of target children\n     * to exclude from this transition. The <code>exclude</code> parameter specifies\n     * whether the target should be added to or removed from the excluded list.\n     *\n     * <p>Excluding targets is a general mechanism for allowing transitions to run on\n     * a view hierarchy while skipping target views that should not be part of\n     * the transition. For example, you may want to avoid animating children\n     * of a specific ListView or Spinner. Views can be excluded either by their\n     * id, or by their instance reference, or by the Class of that view\n     * (eg, {@link Spinner}).</p>\n     *\n     * @see #excludeTarget(View, boolean)\n     * @see #excludeChildren(int, boolean)\n     * @see #excludeChildren(Class, boolean)\n     *\n     * @param target The target to ignore when running this transition.\n     * @param exclude Whether to add the target to or remove the target from the\n     * current list of excluded targets.\n     * @return This transition object.\n     ",
    "links" : [ "android.widget.Spinner" ]
  }, {
    "name" : "private static ArrayList<T> excludeObject(ArrayList<T> list, T target, boolean exclude)",
    "returnType" : "ArrayList<T>",
    "comment" : "\n     * Utility method to manage the boilerplate code that is the same whether we\n     * are excluding targets or their children.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Transition excludeTarget(Class type, boolean exclude)",
    "returnType" : "Transition",
    "comment" : "\n     * Whether to add the given type to the list of types to exclude from this\n     * transition. The <code>exclude</code> parameter specifies whether the target\n     * type should be added to or removed from the excluded list.\n     *\n     * <p>Excluding targets is a general mechanism for allowing transitions to run on\n     * a view hierarchy while skipping target views that should not be part of\n     * the transition. For example, you may want to avoid animating children\n     * of a specific ListView or Spinner. Views can be excluded either by their\n     * id, or by their instance reference, or by the Class of that view\n     * (eg, {@link Spinner}).</p>\n     *\n     * @see #excludeChildren(Class, boolean)\n     * @see #excludeTarget(int, boolean)\n     * @see #excludeTarget(View, boolean)\n     *\n     * @param type The type to ignore when running this transition.\n     * @param exclude Whether to add the target type to or remove it from the\n     * current list of excluded target types.\n     * @return This transition object.\n     ",
    "links" : [ "android.widget.Spinner" ]
  }, {
    "name" : "public Transition excludeChildren(Class type, boolean exclude)",
    "returnType" : "Transition",
    "comment" : "\n     * Whether to add the given type to the list of types whose children should\n     * be excluded from this transition. The <code>exclude</code> parameter\n     * specifies whether the target type should be added to or removed from\n     * the excluded list.\n     *\n     * <p>Excluding targets is a general mechanism for allowing transitions to run on\n     * a view hierarchy while skipping target views that should not be part of\n     * the transition. For example, you may want to avoid animating children\n     * of a specific ListView or Spinner. Views can be excluded either by their\n     * id, or by their instance reference, or by the Class of that view\n     * (eg, {@link Spinner}).</p>\n     *\n     * @see #excludeTarget(Class, boolean)\n     * @see #excludeChildren(int, boolean)\n     * @see #excludeChildren(View, boolean)\n     *\n     * @param type The type to ignore when running this transition.\n     * @param exclude Whether to add the target type to or remove it from the\n     * current list of excluded target types.\n     * @return This transition object.\n     ",
    "links" : [ "android.widget.Spinner" ]
  }, {
    "name" : "public Transition addTarget(View target)",
    "returnType" : "Transition",
    "comment" : "\n     * Sets the target view instances that this Transition is interested in\n     * animating. By default, there are no targets, and a Transition will\n     * listen for changes on every view in the hierarchy below the sceneRoot\n     * of the Scene being transitioned into. Setting targets constrains\n     * the Transition to only listen for, and act on, these views.\n     * All other views will be ignored.\n     *\n     * <p>The target list is like the {@link #addTarget(int) targetId}\n     * list except this list specifies the actual View instances, not the ids\n     * of the views. This is an important distinction when scene changes involve\n     * view hierarchies which have been inflated separately; different views may\n     * share the same id but not actually be the same instance. If the transition\n     * should treat those views as the same, then {@link #addTarget(int)} should be used\n     * instead of {@link #addTarget(View)}. If, on the other hand, scene changes involve\n     * changes all within the same view hierarchy, among views which do not\n     * necessarily have ids set on them, then the target list of views may be more\n     * convenient.</p>\n     *\n     * @see #addTarget(int)\n     * @param target A View on which the Transition will act, must be non-null.\n     * @return The Transition to which the target is added.\n     * Returning the same object makes it easier to chain calls during\n     * construction, such as\n     * <code>transitionSet.addTransitions(new Fade()).addTarget(someView);</code>\n     ",
    "links" : [ "#addTarget(View)", "#addTarget(int)" ]
  }, {
    "name" : "public Transition removeTarget(View target)",
    "returnType" : "Transition",
    "comment" : "\n     * Removes the given target from the list of targets that this Transition\n     * is interested in animating.\n     *\n     * @param target The target view, must be non-null.\n     * @return Transition The Transition from which the target is removed.\n     * Returning the same object makes it easier to chain calls during\n     * construction, such as\n     * <code>transitionSet.addTransitions(new Fade()).removeTarget(someView);</code>\n     ",
    "links" : [ ]
  }, {
    "name" : "public Transition removeTarget(Class target)",
    "returnType" : "Transition",
    "comment" : "\n     * Removes the given target from the list of targets that this Transition\n     * is interested in animating.\n     *\n     * @param target The type of the target view, must be non-null.\n     * @return Transition The Transition from which the target is removed.\n     * Returning the same object makes it easier to chain calls during\n     * construction, such as\n     * <code>transitionSet.addTransitions(new Fade()).removeTarget(someType);</code>\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<Integer> getTargetIds()",
    "returnType" : "List<Integer>",
    "comment" : "\n     * Returns the list of target IDs that this transition limits itself to\n     * tracking and animating. If the list is null or empty for\n     * {@link #getTargetIds()}, {@link #getTargets()}, {@link #getTargetNames()}, and\n     * {@link #getTargetTypes()} then this transition is\n     * not limited to specific views, and will handle changes to any views\n     * in the hierarchy of a scene change.\n     *\n     * @return the list of target IDs\n     ",
    "links" : [ "#getTargetTypes()", "#getTargets()", "#getTargetNames()", "#getTargetIds()" ]
  }, {
    "name" : "public List<View> getTargets()",
    "returnType" : "List<View>",
    "comment" : "\n     * Returns the list of target views that this transition limits itself to\n     * tracking and animating. If the list is null or empty for\n     * {@link #getTargetIds()}, {@link #getTargets()}, {@link #getTargetNames()}, and\n     * {@link #getTargetTypes()} then this transition is\n     * not limited to specific views, and will handle changes to any views\n     * in the hierarchy of a scene change.\n     *\n     * @return the list of target views\n     ",
    "links" : [ "#getTargetTypes()", "#getTargets()", "#getTargetNames()", "#getTargetIds()" ]
  }, {
    "name" : "public List<String> getTargetNames()",
    "returnType" : "List<String>",
    "comment" : "\n     * Returns the list of target transitionNames that this transition limits itself to\n     * tracking and animating. If the list is null or empty for\n     * {@link #getTargetIds()}, {@link #getTargets()}, {@link #getTargetNames()}, and\n     * {@link #getTargetTypes()} then this transition is\n     * not limited to specific views, and will handle changes to any views\n     * in the hierarchy of a scene change.\n     *\n     * @return the list of target transitionNames\n     ",
    "links" : [ "#getTargetTypes()", "#getTargets()", "#getTargetNames()", "#getTargetIds()" ]
  }, {
    "name" : "public List<String> getTargetViewNames()",
    "returnType" : "List<String>",
    "comment" : "\n     * To be removed before L release.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<Class> getTargetTypes()",
    "returnType" : "List<Class>",
    "comment" : "\n     * Returns the list of target transitionNames that this transition limits itself to\n     * tracking and animating. If the list is null or empty for\n     * {@link #getTargetIds()}, {@link #getTargets()}, {@link #getTargetNames()}, and\n     * {@link #getTargetTypes()} then this transition is\n     * not limited to specific views, and will handle changes to any views\n     * in the hierarchy of a scene change.\n     *\n     * @return the list of target Types\n     ",
    "links" : [ "#getTargetTypes()", "#getTargets()", "#getTargetNames()", "#getTargetIds()" ]
  }, {
    "name" : " void captureValues(ViewGroup sceneRoot, boolean start)",
    "returnType" : "void",
    "comment" : "\n     * Recursive method that captures values for the given view and the\n     * hierarchy underneath it.\n     * @param sceneRoot The root of the view hierarchy being captured\n     * @param start true if this capture is happening before the scene change,\n     * false otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : " static void addViewValues(TransitionValuesMaps transitionValuesMaps, View view, TransitionValues transitionValues)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void clearValues(boolean start)",
    "returnType" : "void",
    "comment" : "\n     * Clear valuesMaps for specified start/end state\n     *\n     * @param start true if the start values should be cleared, false otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "private void captureHierarchy(View view, boolean start)",
    "returnType" : "void",
    "comment" : "\n     * Recursive method which captures values for an entire view hierarchy,\n     * starting at some root view. Transitions without targetIDs will use this\n     * method to capture values for all possible views.\n     *\n     * @param view The view for which to capture values. Children of this View\n     * will also be captured, recursively down to the leaf nodes.\n     * @param start true if values are being captured in the start scene, false\n     * otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public TransitionValues getTransitionValues(View view, boolean start)",
    "returnType" : "TransitionValues",
    "comment" : "\n     * This method can be called by transitions to get the TransitionValues for\n     * any particular view during the transition-playing process. This might be\n     * necessary, for example, to query the before/after state of related views\n     * for a given transition.\n     ",
    "links" : [ ]
  }, {
    "name" : " TransitionValues getMatchedTransitionValues(View view, boolean viewInStart)",
    "returnType" : "TransitionValues",
    "comment" : "\n     * Find the matched start or end value for a given View. This is only valid\n     * after playTransition starts. For example, it will be valid in\n     * {@link #createAnimator(android.view.ViewGroup, TransitionValues, TransitionValues)}, but not\n     * in {@link #captureStartValues(TransitionValues)}.\n     *\n     * @param view The view to find the match for.\n     * @param viewInStart Is View from the start values or end values.\n     * @return The matching TransitionValues for view in either start or end values, depending\n     * on viewInStart or null if there is no match for the given view.\n     ",
    "links" : [ "#createAnimator(android.view.ViewGroup", "#captureStartValues(TransitionValues)" ]
  }, {
    "name" : "public void pause(View sceneRoot)",
    "returnType" : "void",
    "comment" : "\n     * Pauses this transition, sending out calls to {@link\n     * TransitionListener#onTransitionPause(Transition)} to all listeners\n     * and pausing all running animators started by this transition.\n     *\n     * @hide\n     ",
    "links" : [ "#onTransitionPause(Transition)" ]
  }, {
    "name" : "public void resume(View sceneRoot)",
    "returnType" : "void",
    "comment" : "\n     * Resumes this transition, sending out calls to {@link\n     * TransitionListener#onTransitionPause(Transition)} to all listeners\n     * and pausing all running animators started by this transition.\n     *\n     * @hide\n     ",
    "links" : [ "#onTransitionPause(Transition)" ]
  }, {
    "name" : " void playTransition(ViewGroup sceneRoot)",
    "returnType" : "void",
    "comment" : "\n     * Called by TransitionManager to play the transition. This calls\n     * createAnimators() to set things up and create all of the animations and then\n     * runAnimations() to actually start the animations.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isTransitionRequired(@Nullable TransitionValues startValues, @Nullable TransitionValues endValues)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether or not the transition should create an Animator, based on the values\n     * captured during {@link #captureStartValues(TransitionValues)} and\n     * {@link #captureEndValues(TransitionValues)}. The default implementation compares the\n     * property values returned from {@link #getTransitionProperties()}, or all property values if\n     * {@code getTransitionProperties()} returns null. Subclasses may override this method to\n     * provide logic more specific to the transition implementation.\n     *\n     * @param startValues the values from captureStartValues, This may be {@code null} if the\n     *                    View did not exist in the start state.\n     * @param endValues the values from captureEndValues. This may be {@code null} if the View\n     *                  did not exist in the end state.\n     ",
    "links" : [ "#captureEndValues(TransitionValues)", "#captureStartValues(TransitionValues)", "#getTransitionProperties()" ]
  }, {
    "name" : "private static boolean isValueChanged(TransitionValues oldValues, TransitionValues newValues, String key)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void animate(Animator animator)",
    "returnType" : "void",
    "comment" : "\n     * This is a utility method used by subclasses to handle standard parts of\n     * setting up and running an Animator: it sets the {@link #getDuration()\n     * duration} and the {@link #getStartDelay() startDelay}, starts the\n     * animation, and, when the animator ends, calls {@link #end()}.\n     *\n     * @param animator The Animator to be run during this transition.\n     *\n     * @hide\n     ",
    "links" : [ "#getDuration()", "#end()", "#getStartDelay()" ]
  }, {
    "name" : "protected void start()",
    "returnType" : "void",
    "comment" : "\n     * This method is called automatically by the transition and\n     * TransitionSet classes prior to a Transition subclass starting;\n     * subclasses should not need to call it directly.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void end()",
    "returnType" : "void",
    "comment" : "\n     * This method is called automatically by the Transition and\n     * TransitionSet classes when a transition finishes, either because\n     * a transition did nothing (returned a null Animator from\n     * {@link Transition#createAnimator(ViewGroup, TransitionValues,\n     * TransitionValues)}) or because the transition returned a valid\n     * Animator and end() was called in the onAnimationEnd()\n     * callback of the AnimatorListener.\n     *\n     * @hide\n     ",
    "links" : [ "android.transition.Transition#createAnimator(ViewGroup" ]
  }, {
    "name" : " void forceToEnd(ViewGroup sceneRoot)",
    "returnType" : "void",
    "comment" : "\n     * Force the transition to move to its end state, ending all the animators.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void cancel()",
    "returnType" : "void",
    "comment" : "\n     * This method cancels a transition that is currently running.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Transition addListener(TransitionListener listener)",
    "returnType" : "Transition",
    "comment" : "\n     * Adds a listener to the set of listeners that are sent events through the\n     * life of an animation, such as start, repeat, and end.\n     *\n     * @param listener the listener to be added to the current set of listeners\n     * for this animation.\n     * @return This transition object.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Transition removeListener(TransitionListener listener)",
    "returnType" : "Transition",
    "comment" : "\n     * Removes a listener from the set listening to this animation.\n     *\n     * @param listener the listener to be removed from the current set of\n     * listeners for this transition.\n     * @return This transition object.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setEpicenterCallback(EpicenterCallback epicenterCallback)",
    "returnType" : "void",
    "comment" : "\n     * Sets the callback to use to find the epicenter of a Transition. A null value indicates\n     * that there is no epicenter in the Transition and onGetEpicenter() will return null.\n     * Transitions like {@link android.transition.Explode} use a point or Rect to orient\n     * the direction of travel. This is called the epicenter of the Transition and is\n     * typically centered on a touched View. The\n     * {@link android.transition.Transition.EpicenterCallback} allows a Transition to\n     * dynamically retrieve the epicenter during a Transition.\n     * @param epicenterCallback The callback to use to find the epicenter of the Transition.\n     ",
    "links" : [ "android.transition.Explode", "android.transition.Transition.EpicenterCallback" ]
  }, {
    "name" : "public EpicenterCallback getEpicenterCallback()",
    "returnType" : "EpicenterCallback",
    "comment" : "\n     * Returns the callback used to find the epicenter of the Transition.\n     * Transitions like {@link android.transition.Explode} use a point or Rect to orient\n     * the direction of travel. This is called the epicenter of the Transition and is\n     * typically centered on a touched View. The\n     * {@link android.transition.Transition.EpicenterCallback} allows a Transition to\n     * dynamically retrieve the epicenter during a Transition.\n     * @return the callback used to find the epicenter of the Transition.\n     ",
    "links" : [ "android.transition.Explode", "android.transition.Transition.EpicenterCallback" ]
  }, {
    "name" : "public Rect getEpicenter()",
    "returnType" : "Rect",
    "comment" : "\n     * Returns the epicenter as specified by the\n     * {@link android.transition.Transition.EpicenterCallback} or null if no callback exists.\n     * @return the epicenter as specified by the\n     * {@link android.transition.Transition.EpicenterCallback} or null if no callback exists.\n     * @see #setEpicenterCallback(android.transition.Transition.EpicenterCallback)\n     ",
    "links" : [ "android.transition.Transition.EpicenterCallback" ]
  }, {
    "name" : "public void setPathMotion(PathMotion pathMotion)",
    "returnType" : "void",
    "comment" : "\n     * Sets the algorithm used to calculate two-dimensional interpolation.\n     * <p>\n     *     Transitions such as {@link android.transition.ChangeBounds} move Views, typically\n     *     in a straight path between the start and end positions. Applications that desire to\n     *     have these motions move in a curve can change how Views interpolate in two dimensions\n     *     by extending PathMotion and implementing\n     *     {@link android.transition.PathMotion#getPath(float, float, float, float)}.\n     * </p>\n     * <p>\n     *     When describing in XML, use a nested XML tag for the path motion. It can be one of\n     *     the built-in tags <code>arcMotion</code> or <code>patternPathMotion</code> or it can\n     *     be a custom PathMotion using <code>pathMotion</code> with the <code>class</code>\n     *     attributed with the fully-described class name. For example:</p>\n     * <pre>\n     * {@code\n     * <changeBounds>\n     *     <pathMotion class=\"my.app.transition.MyPathMotion\"/>\n     * </changeBounds>\n     * }\n     * </pre>\n     * <p>or</p>\n     * <pre>\n     * {@code\n     * <changeBounds>\n     *   <arcMotion android:minimumHorizontalAngle=\"15\"\n     *     android:minimumVerticalAngle=\"0\" android:maximumAngle=\"90\"/>\n     * </changeBounds>\n     * }\n     * </pre>\n     *\n     * @param pathMotion Algorithm object to use for determining how to interpolate in two\n     *                   dimensions. If null, a straight-path algorithm will be used.\n     * @see android.transition.ArcMotion\n     * @see PatternPathMotion\n     * @see android.transition.PathMotion\n     ",
    "links" : [ "android.transition.ChangeBounds", "android.transition.PathMotion#getPath(float" ]
  }, {
    "name" : "public PathMotion getPathMotion()",
    "returnType" : "PathMotion",
    "comment" : "\n     * Returns the algorithm object used to interpolate along two dimensions. This is typically\n     * used to determine the View motion between two points.\n     *\n     * <p>\n     *     When describing in XML, use a nested XML tag for the path motion. It can be one of\n     *     the built-in tags <code>arcMotion</code> or <code>patternPathMotion</code> or it can\n     *     be a custom PathMotion using <code>pathMotion</code> with the <code>class</code>\n     *     attributed with the fully-described class name. For example:</p>\n     * <pre>{@code\n     * <changeBounds>\n     *     <pathMotion class=\"my.app.transition.MyPathMotion\"/>\n     * </changeBounds>}\n     * </pre>\n     * <p>or</p>\n     * <pre>{@code\n     * <changeBounds>\n     *   <arcMotion android:minimumHorizontalAngle=\"15\"\n     *              android:minimumVerticalAngle=\"0\"\n     *              android:maximumAngle=\"90\"/>\n     * </changeBounds>}\n     * </pre>\n     *\n     * @return The algorithm object used to interpolate along two dimensions.\n     * @see android.transition.ArcMotion\n     * @see PatternPathMotion\n     * @see android.transition.PathMotion\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setPropagation(TransitionPropagation transitionPropagation)",
    "returnType" : "void",
    "comment" : "\n     * Sets the method for determining Animator start delays.\n     * When a Transition affects several Views like {@link android.transition.Explode} or\n     * {@link android.transition.Slide}, there may be a desire to have a \"wave-front\" effect\n     * such that the Animator start delay depends on position of the View. The\n     * TransitionPropagation specifies how the start delays are calculated.\n     * @param transitionPropagation The class used to determine the start delay of\n     *                              Animators created by this Transition. A null value\n     *                              indicates that no delay should be used.\n     ",
    "links" : [ "android.transition.Explode", "android.transition.Slide" ]
  }, {
    "name" : "public TransitionPropagation getPropagation()",
    "returnType" : "TransitionPropagation",
    "comment" : "\n     * Returns the {@link android.transition.TransitionPropagation} used to calculate Animator start\n     * delays.\n     * When a Transition affects several Views like {@link android.transition.Explode} or\n     * {@link android.transition.Slide}, there may be a desire to have a \"wave-front\" effect\n     * such that the Animator start delay depends on position of the View. The\n     * TransitionPropagation specifies how the start delays are calculated.\n     * @return the {@link android.transition.TransitionPropagation} used to calculate Animator start\n     * delays. This is null by default.\n     ",
    "links" : [ "android.transition.Explode", "android.transition.TransitionPropagation", "android.transition.Slide" ]
  }, {
    "name" : " void capturePropagationValues(TransitionValues transitionValues)",
    "returnType" : "void",
    "comment" : "\n     * Captures TransitionPropagation values for the given view and the\n     * hierarchy underneath it.\n     ",
    "links" : [ ]
  }, {
    "name" : " Transition setSceneRoot(ViewGroup sceneRoot)",
    "returnType" : "Transition",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void setCanRemoveViews(boolean canRemoveViews)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean canRemoveViews()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setNameOverrides(ArrayMap<String, String> overrides)",
    "returnType" : "void",
    "comment" : "\n     * Sets the shared element names -- a mapping from a name at the start state to\n     * a different name at the end state.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public ArrayMap<String, String> getNameOverrides()",
    "returnType" : "ArrayMap<String, String>",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Transition clone()",
    "returnType" : "Transition",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public String getName()",
    "returnType" : "String",
    "comment" : "\n     * Returns the name of this Transition. This name is used internally to distinguish\n     * between different transitions to determine when interrupting transitions overlap.\n     * For example, a ChangeBounds running on the same target view as another ChangeBounds\n     * should determine whether the old transition is animating to different end values\n     * and should be canceled in favor of the new transition.\n     *\n     * <p>By default, a Transition's name is simply the value of {@link Class#getName()},\n     * but subclasses are free to override and return something different.</p>\n     *\n     * @return The name of this transition.\n     ",
    "links" : [ "#getName()" ]
  }, {
    "name" : " String toString(String indent)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ "private static int[] parseMatchOrder(String matchOrderString)", "public Transition setDuration(long duration)", "public long getDuration()", "public Transition setStartDelay(long startDelay)", "public long getStartDelay()", "public Transition setInterpolator(TimeInterpolator interpolator)", "public TimeInterpolator getInterpolator()", "public String[] getTransitionProperties()", "public Animator createAnimator(@NonNull ViewGroup sceneRoot, @Nullable TransitionValues startValues, @Nullable TransitionValues endValues)", "public void setMatchOrder(int... matches)", "private static boolean isValidMatch(int match)", "private static boolean alreadyContains(int[] array, int searchIndex)", "private void matchInstances(ArrayMap<View, TransitionValues> unmatchedStart, ArrayMap<View, TransitionValues> unmatchedEnd)", "private void matchItemIds(ArrayMap<View, TransitionValues> unmatchedStart, ArrayMap<View, TransitionValues> unmatchedEnd, LongSparseArray<View> startItemIds, LongSparseArray<View> endItemIds)", "private void matchIds(ArrayMap<View, TransitionValues> unmatchedStart, ArrayMap<View, TransitionValues> unmatchedEnd, SparseArray<View> startIds, SparseArray<View> endIds)", "private void matchNames(ArrayMap<View, TransitionValues> unmatchedStart, ArrayMap<View, TransitionValues> unmatchedEnd, ArrayMap<String, View> startNames, ArrayMap<String, View> endNames)", "private void addUnmatched(ArrayMap<View, TransitionValues> unmatchedStart, ArrayMap<View, TransitionValues> unmatchedEnd)", "private void matchStartAndEnd(TransitionValuesMaps startValues, TransitionValuesMaps endValues)", "protected void createAnimators(ViewGroup sceneRoot, TransitionValuesMaps startValues, TransitionValuesMaps endValues, ArrayList<TransitionValues> startValuesList, ArrayList<TransitionValues> endValuesList)", "public boolean isValidTarget(View target)", "private static ArrayMap<Animator, AnimationInfo> getRunningAnimators()", "protected void runAnimators()", "private void runAnimator(Animator animator, final ArrayMap<Animator, AnimationInfo> runningAnimators)", "public abstract void captureStartValues(TransitionValues transitionValues)", "public abstract void captureEndValues(TransitionValues transitionValues)", "public Transition addTarget(int targetId)", "public Transition addTarget(String targetName)", "public Transition addTarget(Class targetType)", "public Transition removeTarget(int targetId)", "public Transition removeTarget(String targetName)", "public Transition excludeTarget(int targetId, boolean exclude)", "public Transition excludeTarget(String targetName, boolean exclude)", "public Transition excludeChildren(int targetId, boolean exclude)", "public Transition excludeTarget(View target, boolean exclude)", "public Transition excludeChildren(View target, boolean exclude)", "private static ArrayList<T> excludeObject(ArrayList<T> list, T target, boolean exclude)", "public Transition excludeTarget(Class type, boolean exclude)", "public Transition excludeChildren(Class type, boolean exclude)", "public Transition addTarget(View target)", "public Transition removeTarget(View target)", "public Transition removeTarget(Class target)", "public List<Integer> getTargetIds()", "public List<View> getTargets()", "public List<String> getTargetNames()", "public List<String> getTargetViewNames()", "public List<Class> getTargetTypes()", " void captureValues(ViewGroup sceneRoot, boolean start)", " static void addViewValues(TransitionValuesMaps transitionValuesMaps, View view, TransitionValues transitionValues)", " void clearValues(boolean start)", "private void captureHierarchy(View view, boolean start)", "public TransitionValues getTransitionValues(View view, boolean start)", " TransitionValues getMatchedTransitionValues(View view, boolean viewInStart)", "public void pause(View sceneRoot)", "public void resume(View sceneRoot)", " void playTransition(ViewGroup sceneRoot)", "public boolean isTransitionRequired(@Nullable TransitionValues startValues, @Nullable TransitionValues endValues)", "private static boolean isValueChanged(TransitionValues oldValues, TransitionValues newValues, String key)", "protected void animate(Animator animator)", "protected void start()", "protected void end()", " void forceToEnd(ViewGroup sceneRoot)", "protected void cancel()", "public Transition addListener(TransitionListener listener)", "public Transition removeListener(TransitionListener listener)", "public void setEpicenterCallback(EpicenterCallback epicenterCallback)", "public EpicenterCallback getEpicenterCallback()", "public Rect getEpicenter()", "public void setPathMotion(PathMotion pathMotion)", "public PathMotion getPathMotion()", "public void setPropagation(TransitionPropagation transitionPropagation)", "public TransitionPropagation getPropagation()", " void capturePropagationValues(TransitionValues transitionValues)", " Transition setSceneRoot(ViewGroup sceneRoot)", " void setCanRemoveViews(boolean canRemoveViews)", "public boolean canRemoveViews()", "public void setNameOverrides(ArrayMap<String, String> overrides)", "public ArrayMap<String, String> getNameOverrides()", "public String toString()", "public Transition clone()", "public String getName()", " String toString(String indent)" ],
  "variableNames" : [ "LOG_TAG", "DBG", "MATCH_INSTANCE", "MATCH_FIRST", "MATCH_NAME", "MATCH_ID", "MATCH_ITEM_ID", "MATCH_LAST", "MATCH_INSTANCE_STR", "MATCH_NAME_STR", "MATCH_VIEW_NAME_STR", "MATCH_ID_STR", "MATCH_ITEM_ID_STR", "DEFAULT_MATCH_ORDER", "STRAIGHT_PATH_MOTION", "mName", "mStartDelay", "mDuration", "mInterpolator", "mTargetIds", "mTargets", "mTargetNames", "mTargetTypes", "mTargetIdExcludes", "mTargetExcludes", "mTargetTypeExcludes", "mTargetNameExcludes", "mTargetIdChildExcludes", "mTargetChildExcludes", "mTargetTypeChildExcludes", "mStartValues", "mEndValues", "mParent", "mMatchOrder", "mStartValuesList", "mEndValuesList", "sRunningAnimators", "mSceneRoot", "mCanRemoveViews", "mCurrentAnimators", "mNumInstances", "mPaused", "mEnded", "mListeners", "mAnimators", "mPropagation", "mEpicenterCallback", "mNameOverrides", "mPathMotion" ]
}