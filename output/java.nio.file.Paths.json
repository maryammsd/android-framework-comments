{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/nio/file/Paths.java",
  "packageName" : "java.nio.file",
  "className" : "Paths",
  "comment" : "",
  "links" : [ ],
  "variables" : [ ],
  "methods" : [ {
    "name" : "public static Path get(String first, String... more)",
    "returnType" : "Path",
    "comment" : "\n     * Converts a path string, or a sequence of strings that when joined form\n     * a path string, to a {@code Path}. If {@code more} does not specify any\n     * elements then the value of the {@code first} parameter is the path string\n     * to convert. If {@code more} specifies one or more elements then each\n     * non-empty string, including {@code first}, is considered to be a sequence\n     * of name elements (see {@link Path}) and is joined to form a path string.\n     * The details as to how the Strings are joined is provider specific but\n     * typically they will be joined using the {@link FileSystem#getSeparator\n     * name-separator} as the separator. For example, if the name separator is\n     * \"{@code /}\" and {@code getPath(\"/foo\",\"bar\",\"gus\")} is invoked, then the\n     * path string {@code \"/foo/bar/gus\"} is converted to a {@code Path}.\n     * A {@code Path} representing an empty path is returned if {@code first}\n     * is the empty string and {@code more} does not contain any non-empty\n     * strings.\n     *\n     * <p> The {@code Path} is obtained by invoking the {@link FileSystem#getPath\n     * getPath} method of the {@link FileSystems#getDefault default} {@link\n     * FileSystem}.\n     *\n     * <p> Note that while this method is very convenient, using it will imply\n     * an assumed reference to the default {@code FileSystem} and limit the\n     * utility of the calling code. Hence it should not be used in library code\n     * intended for flexible reuse. A more flexible alternative is to use an\n     * existing {@code Path} instance as an anchor, such as:\n     * <pre>\n     *     Path dir = ...\n     *     Path path = dir.resolve(\"file\");\n     * </pre>\n     *\n     * @param   first\n     *          the path string or initial part of the path string\n     * @param   more\n     *          additional strings to be joined to form the path string\n     *\n     * @return  the resulting {@code Path}\n     *\n     * @throws  InvalidPathException\n     *          if the path string cannot be converted to a {@code Path}\n     *\n     * @see FileSystem#getPath\n     ",
    "links" : [ "java.nio.file.FileSystems#getDefault", "java.nio.file.FileSystem#getSeparatorname", "java.nio.file.FileSystem#getPathgetPath", "java.nio.file.FileSystem", "java.nio.file.Path" ]
  }, {
    "name" : "public static Path get(URI uri)",
    "returnType" : "Path",
    "comment" : "\n     * Converts the given URI to a {@link Path} object.\n     *\n     * <p> This method iterates over the {@link FileSystemProvider#installedProviders()\n     * installed} providers to locate the provider that is identified by the\n     * URI {@link URI#getScheme scheme} of the given URI. URI schemes are\n     * compared without regard to case. If the provider is found then its {@link\n     * FileSystemProvider#getPath getPath} method is invoked to convert the\n     * URI.\n     *\n     * <p> In the case of the default provider, identified by the URI scheme\n     * \"file\", the given URI has a non-empty path component, and undefined query\n     * and fragment components. Whether the authority component may be present\n     * is platform specific. The returned {@code Path} is associated with the\n     * {@link FileSystems#getDefault default} file system.\n     *\n     * <p> The default provider provides a similar <em>round-trip</em> guarantee\n     * to the {@link java.io.File} class. For a given {@code Path} <i>p</i> it\n     * is guaranteed that\n     * <blockquote><tt>\n     * Paths.get(</tt><i>p</i><tt>.{@link Path#toUri() toUri}()).equals(</tt>\n     * <i>p</i><tt>.{@link Path#toAbsolutePath() toAbsolutePath}())</tt>\n     * </blockquote>\n     * so long as the original {@code Path}, the {@code URI}, and the new {@code\n     * Path} are all created in (possibly different invocations of) the same\n     * Java virtual machine. Whether other providers make any guarantees is\n     * provider specific and therefore unspecified.\n     *\n     * @param   uri\n     *          the URI to convert\n     *\n     * @return  the resulting {@code Path}\n     *\n     * @throws  IllegalArgumentException\n     *          if preconditions on the {@code uri} parameter do not hold. The\n     *          format of the URI is provider specific.\n     * @throws  FileSystemNotFoundException\n     *          The file system, identified by the URI, does not exist and\n     *          cannot be created automatically, or the provider identified by\n     *          the URI's scheme component is not installed\n     * @throws  SecurityException\n     *          if a security manager is installed and it denies an unspecified\n     *          permission to access the file system\n     ",
    "links" : [ "java.nio.file.FileSystems#getDefault", "java.nio.file.spi.FileSystemProvider#installedProviders()", "java.net.URI#getScheme", "java.nio.file.Path#toAbsolutePath()", "java.nio.file.spi.FileSystemProvider#getPath", "java.nio.file.Path", "java.nio.file.Path#toUri()", "java.io.File" ]
  } ],
  "methodNames" : [ "public static Path get(String first, String... more)", "public static Path get(URI uri)" ],
  "variableNames" : [ ]
}