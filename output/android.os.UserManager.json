{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/os/UserManager.java",
  "packageName" : "android.os",
  "className" : "UserManager",
  "comment" : "\n * Manages users and user details on a multi-user system. There are two major categories of\n * users: fully customizable users with their own login, and profiles that share a workspace\n * with a related user.\n * <p>\n * Users are different from accounts, which are managed by\n * {@link AccountManager}. Each user can have their own set of accounts.\n * <p>\n * See {@link DevicePolicyManager#ACTION_PROVISION_MANAGED_PROFILE} for more on managed profiles.\n ",
  "links" : [ "android.accounts.AccountManager", "android.app.admin.DevicePolicyManager#ACTION_PROVISION_MANAGED_PROFILE" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mService",
    "type" : "IUserManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : " Holding the Application context (not constructor param context). ",
    "links" : [ ]
  }, {
    "name" : "mUserId",
    "type" : "int",
    "comment" : " The userId of the constructor param context. To be used instead of mContext.getUserId(). ",
    "links" : [ ]
  }, {
    "name" : "mProfileTypeOfProcessUser",
    "type" : "String",
    "comment" : " The userType of UserHandle.myUserId(); empty string if not a profile; null until cached. ",
    "links" : [ ]
  }, {
    "name" : "sIsHeadlessSystemUser",
    "type" : "Boolean",
    "comment" : " Whether the device is in headless system user mode; null until cached. ",
    "links" : [ ]
  }, {
    "name" : "MAX_USER_NAME_LENGTH",
    "type" : "int",
    "comment" : " Maximum length of username.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "MAX_ACCOUNT_STRING_LENGTH",
    "type" : "int",
    "comment" : " Maximum length of user property String value.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "MAX_ACCOUNT_OPTIONS_LENGTH",
    "type" : "int",
    "comment" : " Maximum length of account options String values.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_TYPE_FULL_SYSTEM",
    "type" : "String",
    "comment" : "\n     * User type representing a {@link UserHandle#USER_SYSTEM system} user that is a human user.\n     * This type of user cannot be created; it can only pre-exist on first boot.\n     * @hide\n     ",
    "links" : [ "android.os.UserHandle#USER_SYSTEM" ]
  }, {
    "name" : "USER_TYPE_FULL_SECONDARY",
    "type" : "String",
    "comment" : "\n     * User type representing a regular non-profile non-{@link UserHandle#USER_SYSTEM system} human\n     * user.\n     * This is sometimes called an ordinary 'secondary user'.\n     * @hide\n     ",
    "links" : [ "android.os.UserHandle#USER_SYSTEM" ]
  }, {
    "name" : "USER_TYPE_FULL_GUEST",
    "type" : "String",
    "comment" : "\n     * User type representing a guest user that may be transient.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_TYPE_FULL_DEMO",
    "type" : "String",
    "comment" : "\n     * User type representing a user for demo purposes only, which can be removed at any time.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_TYPE_FULL_RESTRICTED",
    "type" : "String",
    "comment" : "\n     * User type representing a \"restricted profile\" user, which is a full user that is subject to\n     * certain restrictions from a parent user. Note, however, that it is NOT technically a profile.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_TYPE_PROFILE_MANAGED",
    "type" : "String",
    "comment" : "\n     * User type representing a managed profile, which is a profile that is to be managed by a\n     * device policy controller (DPC).\n     * The intended purpose is for work profiles, which are managed by a corporate entity.\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_TYPE_PROFILE_CLONE",
    "type" : "String",
    "comment" : "\n     * User type representing a clone profile. Clone profile is a user profile type used to run\n     * second instance of an otherwise single user App (eg, messengers). Currently only the\n     * {@link android.content.pm.UserInfo#isMain()} user can have a clone profile.\n     ",
    "links" : [ "android.content.pm.UserInfo#isMain()" ]
  }, {
    "name" : "USER_TYPE_PROFILE_PRIVATE",
    "type" : "String",
    "comment" : "\n     * User type representing a private profile. Private profile is a user profile that can be used\n     * as an alternative user-space to install and use sensitive apps.\n     * UI surfaces can adopt an alternative strategy to show apps belonging to this profile, in line\n     * with their sensitive nature.\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_TYPE_PROFILE_TEST",
    "type" : "String",
    "comment" : "\n     * User type representing a generic profile for testing purposes. Only on debuggable builds.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_TYPE_PROFILE_COMMUNAL",
    "type" : "String",
    "comment" : "\n     * User type representing a communal profile, which is shared by all users of the device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_TYPE_SYSTEM_HEADLESS",
    "type" : "String",
    "comment" : "\n     * User type representing a {@link UserHandle#USER_SYSTEM system} user that is <b>not</b> a\n     * human user.\n     * This type of user cannot be created; it can only pre-exist on first boot.\n     * @hide\n     ",
    "links" : [ "android.os.UserHandle#USER_SYSTEM" ]
  }, {
    "name" : "QUIET_MODE_DISABLE_ONLY_IF_CREDENTIAL_NOT_REQUIRED",
    "type" : "int",
    "comment" : "\n     * Flag passed to {@link #requestQuietModeEnabled} to request disabling quiet mode only if\n     * there is no need to confirm the user credentials. If credentials are required to disable\n     * quiet mode, {@link #requestQuietModeEnabled} will do nothing and return {@code false}.\n     ",
    "links" : [ "#requestQuietModeEnabled" ]
  }, {
    "name" : "QUIET_MODE_DISABLE_DONT_ASK_CREDENTIAL",
    "type" : "int",
    "comment" : "\n     * Flag passed to {@link #requestQuietModeEnabled} to request disabling quiet mode without\n     * asking for credentials. This is used when managed profile password is forgotten. It starts\n     * the user in locked state so that a direct boot aware DPC could reset the password.\n     * Should not be used together with\n     * {@link #QUIET_MODE_DISABLE_ONLY_IF_CREDENTIAL_NOT_REQUIRED} or an exception will be thrown.\n     * This flag is currently only allowed for {@link #isManagedProfile() managed profiles};\n     * usage on other profiles may result in an Exception.\n     * @hide\n     ",
    "links" : [ "#requestQuietModeEnabled", "#isManagedProfile()", "#QUIET_MODE_DISABLE_ONLY_IF_CREDENTIAL_NOT_REQUIRED" ]
  }, {
    "name" : "RESTRICTION_NOT_SET",
    "type" : "int",
    "comment" : "\n     * @hide\n     * No user restriction.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESTRICTION_SOURCE_SYSTEM",
    "type" : "int",
    "comment" : "\n     * @hide\n     * User restriction set by system/user.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESTRICTION_SOURCE_DEVICE_OWNER",
    "type" : "int",
    "comment" : "\n     * @hide\n     * User restriction set by a device owner.\n     ",
    "links" : [ ]
  }, {
    "name" : "RESTRICTION_SOURCE_PROFILE_OWNER",
    "type" : "int",
    "comment" : "\n     * @hide\n     * User restriction set by a profile owner.\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_MODIFY_ACCOUNTS",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from adding and removing accounts, unless they are\n     * {@link android.accounts.AccountManager#addAccountExplicitly programmatically} added by\n     * Authenticator.\n     * The default value is <code>false</code>.\n     *\n     * <p>From {@link android.os.Build.VERSION_CODES#N} a profile or device owner app can still\n     * use {@link android.accounts.AccountManager} APIs to add or remove accounts when account\n     * management is disallowed.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.accounts.AccountManager", "android.accounts.AccountManager#addAccountExplicitly", "android.Manifest.permission#MANAGE_DEVICE_POLICY_ACCOUNT_MANAGEMENT", "android.os.Build.VERSION_CODES#N" ]
  }, {
    "name" : "DISALLOW_CONFIG_WIFI",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from changing Wi-Fi access points via Settings. This\n     * restriction does not affect Wi-Fi tethering settings.\n     *\n     * <p>A device owner and a profile owner can set this restriction, although the restriction has\n     * no effect in a managed profile. When it is set by a device owner, a profile owner on the\n     * primary user or by a profile owner of an organization-owned managed profile on the parent\n     * profile, it disallows the primary user from changing Wi-Fi access points.\n     *\n     * <p>Holders of the permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_WIFI}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_WIFI" ]
  }, {
    "name" : "DISALLOW_CHANGE_WIFI_STATE",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from enabling/disabling Wi-Fi.\n     *\n     * <p>This restriction can only be set by a device owner,\n     * a profile owner of an organization-owned managed profile on the parent profile.\n     * When it is set by any of these owners, it applies globally - i.e., it disables airplane mode\n     * from changing Wi-Fi state.\n     *\n     * <p>Holders of the permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_WIFI}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_WIFI" ]
  }, {
    "name" : "DISALLOW_WIFI_TETHERING",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from using Wi-Fi tethering.\n     *\n     * <p>This restriction does not limit the user's ability to modify or connect to regular\n     * Wi-Fi networks, which is separately controlled by {@link #DISALLOW_CONFIG_WIFI}.\n     *\n     * <p>This restriction can only be set by a device owner,\n     * a profile owner of an organization-owned managed profile on the parent profile.\n     * When it is set by any of these owners, it prevents all users from using\n     * Wi-Fi tethering. Other forms of tethering are not affected.\n     *\n     * <p>Holders of the permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_WIFI}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * This user restriction disables only Wi-Fi tethering.\n     * Use {@link #DISALLOW_CONFIG_TETHERING} to limit all forms of tethering.\n     * When {@link #DISALLOW_CONFIG_TETHERING} is set, this user restriction becomes obsolete.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "#DISALLOW_CONFIG_WIFI", "#DISALLOW_CONFIG_TETHERING", "android.Manifest.permission#MANAGE_DEVICE_POLICY_WIFI" ]
  }, {
    "name" : "DISALLOW_GRANT_ADMIN",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from being granted admin privileges.\n     *\n     * <p>This restriction limits ability of other admin users to grant admin\n     * privileges to selected user.\n     *\n     * <p>This restriction has no effect in a mode that does not allow multiple admins.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_SHARING_ADMIN_CONFIGURED_WIFI",
    "type" : "String",
    "comment" : "\n     * Specifies if users are disallowed from sharing Wi-Fi for admin configured networks.\n     *\n     * <p>Device owner and profile owner can set this restriction.\n     * When it is set by any of these owners, it prevents all users from\n     * sharing Wi-Fi for networks configured by these owners.\n     * Other networks not configured by these owners are not affected.\n     *\n     * <p>Holders of the permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_WIFI}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_WIFI" ]
  }, {
    "name" : "DISALLOW_WIFI_DIRECT",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from using Wi-Fi Direct.\n     *\n     * <p>This restriction can only be set by a device owner,\n     * a profile owner of an organization-owned managed profile on the parent profile.\n     * When it is set by any of these owners, it prevents all users from using\n     * Wi-Fi Direct.\n     *\n     * <p>Holders of the permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_WIFI}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_WIFI" ]
  }, {
    "name" : "DISALLOW_ADD_WIFI_CONFIG",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from adding a new Wi-Fi configuration.\n     *\n     * <p>This restriction can only be set by a device owner,\n     * a profile owner of an organization-owned managed profile on the parent profile.\n     * When it is set by any of these owners, it prevents all users from adding\n     * a new Wi-Fi configuration. This does not limit the owner and carrier's ability\n     * to add a new configuration.\n     *\n     * <p>Holders of the permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_WIFI}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_WIFI" ]
  }, {
    "name" : "DISALLOW_CONFIG_LOCALE",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from changing the device\n     * language. The default value is <code>false</code>.\n     *\n     * <p>Holders of the permission {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCALE}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCALE" ]
  }, {
    "name" : "DISALLOW_INSTALL_APPS",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from installing applications. This user restriction also\n     * prevents device owners and profile owners installing apps. The default value is\n     * {@code false}.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_APPS_CONTROL}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_APPS_CONTROL" ]
  }, {
    "name" : "DISALLOW_UNINSTALL_APPS",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from uninstalling applications.\n     * The default value is <code>false</code>.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_APPS_CONTROL}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_APPS_CONTROL" ]
  }, {
    "name" : "DISALLOW_SHARE_LOCATION",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from turning on location sharing.\n     *\n     * <p>In a managed profile, location sharing by default reflects the primary user's setting, but\n     * can be overridden and forced off by setting this restriction to true in the managed profile.\n     *\n     * <p>A device owner and a profile owner can set this restriction. When it is set by a device\n     * owner, a profile owner on the primary user or by a profile owner of an organization-owned\n     * managed profile on the parent profile, it prevents the primary user from turning on\n     * location sharing.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCATION}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCATION" ]
  }, {
    "name" : "DISALLOW_AIRPLANE_MODE",
    "type" : "String",
    "comment" : "\n     * Specifies if airplane mode is disallowed on the device.\n     *\n     * <p>This restriction can only be set by a device owner, a profile owner on the primary\n     * user or a profile owner of an organization-owned managed profile on the parent profile.\n     * When it is set by any of these owners, it applies globally - i.e., it disables airplane mode\n     * on the entire device.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_AIRPLANE_MODE}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_AIRPLANE_MODE" ]
  }, {
    "name" : "DISALLOW_CONFIG_BRIGHTNESS",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from configuring brightness. When device owner sets it,\n     * it'll only be applied on the target(system) user.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_DISPLAY}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>This user restriction has no effect on managed profiles.\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_DISPLAY" ]
  }, {
    "name" : "DISALLOW_AMBIENT_DISPLAY",
    "type" : "String",
    "comment" : "\n     * Specifies if ambient display is disallowed for the user.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_DISPLAY}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>This user restriction has no effect on managed profiles.\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_DISPLAY" ]
  }, {
    "name" : "DISALLOW_CONFIG_SCREEN_TIMEOUT",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from changing screen off timeout.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_DISPLAY}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>This user restriction has no effect on managed profiles.\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_DISPLAY" ]
  }, {
    "name" : "DISALLOW_INSTALL_UNKNOWN_SOURCES",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from enabling the\n     * \"Unknown Sources\" setting, that allows installation of apps from unknown sources.\n     * Unknown sources exclude adb and special apps such as trusted app stores.\n     * The default value is <code>false</code>.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES" ]
  }, {
    "name" : "DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY",
    "type" : "String",
    "comment" : "\n     * This restriction is a device-wide version of {@link #DISALLOW_INSTALL_UNKNOWN_SOURCES}.\n     *\n     * Specifies if all users on the device are disallowed from enabling the\n     * \"Unknown Sources\" setting, that allows installation of apps from unknown sources.\n     *\n     * This restriction can be enabled by the profile owner, in which case all accounts and\n     * profiles will be affected.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "#DISALLOW_INSTALL_UNKNOWN_SOURCES", "android.Manifest.permission#MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES" ]
  }, {
    "name" : "DISALLOW_CONFIG_BLUETOOTH",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from configuring bluetooth via Settings. This does\n     * <em>not</em> restrict the user from turning bluetooth on or off.\n     *\n     * <p>This restriction doesn't prevent the user from using bluetooth. For disallowing usage of\n     * bluetooth completely on the device, use {@link #DISALLOW_BLUETOOTH}.\n     *\n     * <p>A device owner and a profile owner can set this restriction, although the restriction has\n     * no effect in a managed profile. When it is set by a device owner, a profile owner on the\n     * primary user or by a profile owner of an organization-owned managed profile on the parent\n     * profile, it disallows the primary user from configuring bluetooth.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_BLUETOOTH}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "#DISALLOW_BLUETOOTH", "android.Manifest.permission#MANAGE_DEVICE_POLICY_BLUETOOTH" ]
  }, {
    "name" : "DISALLOW_BLUETOOTH",
    "type" : "String",
    "comment" : "\n     * Specifies if bluetooth is disallowed on the device. If bluetooth is disallowed on the device,\n     * bluetooth cannot be turned on or configured via Settings.\n     *\n     * <p>This restriction can only be set by a device owner, a profile owner on the primary\n     * user or a profile owner of an organization-owned managed profile on the parent profile.\n     * When it is set by a device owner, it applies globally - i.e., it disables bluetooth on\n     * the entire device and all users will be affected. When it is set by a profile owner on the\n     * primary user or by a profile owner of an organization-owned managed profile on the parent\n     * profile, it disables the primary user from using bluetooth and configuring bluetooth\n     * in Settings.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_BLUETOOTH}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_BLUETOOTH" ]
  }, {
    "name" : "DISALLOW_BLUETOOTH_SHARING",
    "type" : "String",
    "comment" : "\n     * Specifies if outgoing bluetooth sharing is disallowed.\n     *\n     * <p>A device owner and a profile owner can set this restriction. When it is set by a device\n     * owner, it applies globally. When it is set by a profile owner on the primary user or by a\n     * profile owner of an organization-owned managed profile on the parent profile, it disables\n     * the primary user from any outgoing bluetooth sharing.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_BLUETOOTH}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Default is <code>true</code> for managed and private profiles, false otherwise.\n     *\n     * <p>When a device upgrades to {@link android.os.Build.VERSION_CODES#O}, the system sets it\n     * for all existing managed profiles.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#O", "android.Manifest.permission#MANAGE_DEVICE_POLICY_BLUETOOTH" ]
  }, {
    "name" : "DISALLOW_USB_FILE_TRANSFER",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from transferring files over USB.\n     *\n     * <p>This restriction can only be set by a <a href=\"https://developers.google.com/android/work/terminology#device_owner_do\">\n     * device owner</a> or a <a href=\"https://developers.google.com/android/work/terminology#profile_owner_po\">\n     * profile owner</a> on the primary user's profile or a profile owner of an organization-owned\n     * <a href=\"https://developers.google.com/android/work/terminology#managed_profile\">\n     * managed profile</a> on the parent profile.\n     * When it is set by a device owner, it applies globally. When it is set by a profile owner\n     * on the primary user or by a profile owner of an organization-owned managed profile on\n     * the parent profile, it disables the primary user from transferring files over USB. No other\n     * user on the device is able to use file transfer over USB because the UI for file transfer\n     * is always associated with the primary user.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER" ]
  }, {
    "name" : "DISALLOW_CONFIG_CREDENTIALS",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from configuring user\n     * credentials. The default value is <code>false</code>.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS" ]
  }, {
    "name" : "DISALLOW_REMOVE_USER",
    "type" : "String",
    "comment" : "\n     * When set on the admin user this specifies if the user can remove users.\n     * When set on a non-admin secondary user, this specifies if the user can remove itself.\n     * This restriction has no effect on managed profiles.\n     * The default value is <code>false</code>.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_MODIFY_USERS}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_MODIFY_USERS" ]
  }, {
    "name" : "DISALLOW_REMOVE_MANAGED_PROFILE",
    "type" : "String",
    "comment" : "\n     * Specifies if managed profiles of this user can be removed, other than by its profile owner.\n     * The default value is <code>false</code>.\n     * <p>\n     * This restriction has no effect on managed profiles.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     * @deprecated As the ability to have a managed profile on a fully-managed device has been\n     * removed from the platform, this restriction will be silently ignored when applied by the\n     * device owner.\n     * When the device is provisioned with a managed profile on an organization-owned device,\n     * the managed profile could not be removed anyway.\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_DEBUGGING_FEATURES",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from enabling or accessing debugging features.\n     *\n     * <p>A device owner and a profile owner can set this restriction. When it is set by a device\n     * owner, a profile owner on the primary user or by a profile owner of an organization-owned\n     * managed profile on the parent profile, it disables debugging features altogether, including\n     * USB debugging. When set on a managed profile or a secondary user, it blocks debugging for\n     * that user only, including starting activities, making service calls, accessing content\n     * providers, sending broadcasts, installing/uninstalling packages, clearing user data, etc.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES" ]
  }, {
    "name" : "DISALLOW_CONFIG_VPN",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from configuring a VPN. The default value is\n     * <code>false</code>. This restriction has an effect when set by device owners and, in Android\n     * 6.0 ({@linkplain android.os.Build.VERSION_CODES#M API level 23}) or higher, profile owners.\n     * <p>This restriction also prevents VPNs from starting. However, in Android 7.0\n     * ({@linkplain android.os.Build.VERSION_CODES#N API level 24}) or higher, the system does\n     * start always-on VPNs created by the device or profile owner.\n     * <p>From Android 12 ({@linkplain android.os.Build.VERSION_CODES#S API level 31}) enforcing\n     * this restriction clears currently active VPN if it was configured by the user.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_VPN}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_VPN" ]
  }, {
    "name" : "DISALLOW_CONFIG_LOCATION",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from enabling or disabling location providers. As a\n     * result, user is disallowed from turning on or off location via Settings.\n     *\n     * <p>A device owner and a profile owner can set this restriction. When it is set by a device\n     * owner, a profile owner on the primary user or by a profile owner of an organization-owned\n     * managed profile on the parent profile, it disallows the primary user from turning location\n     * on or off.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCATION}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>This user restriction is different from {@link #DISALLOW_SHARE_LOCATION},\n     * as a device owner or a profile owner can still enable or disable location mode via\n     * {@link DevicePolicyManager#setLocationEnabled} when this restriction is on.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see LocationManager#isLocationEnabled()\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "#DISALLOW_SHARE_LOCATION", "android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCATION", "android.app.admin.DevicePolicyManager#setLocationEnabled" ]
  }, {
    "name" : "DISALLOW_CONFIG_DATE_TIME",
    "type" : "String",
    "comment" : "\n     * Specifies configuring date, time and timezone is disallowed via Settings.\n     *\n     * <p>A device owner and a profile owner can set this restriction, although the restriction has\n     * no effect in a managed profile. When it is set by a device owner or by a profile owner of an\n     * organization-owned managed profile on the parent profile, it applies globally - i.e.,\n     * it disables date, time and timezone setting on the entire device and all users are affected.\n     * When it is set by a profile owner on the primary user, it disables the primary user\n     * from configuring date, time and timezone and disables all configuring of date, time and\n     * timezone in Settings.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_TIME}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_TIME" ]
  }, {
    "name" : "DISALLOW_CONFIG_TETHERING",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from using and configuring Tethering and portable hotspots\n     * via Settings.\n     *\n     * <p>This restriction can only be set by a device owner, a profile owner on the primary\n     * user or a profile owner of an organization-owned managed profile on the parent profile.\n     * When it is set by a device owner, it applies globally. When it is set by a profile owner\n     * on the primary user or by a profile owner of an organization-owned managed profile on\n     * the parent profile, it disables the primary user from using Tethering and hotspots and\n     * disables all configuring of Tethering and hotspots in Settings.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_MOBILE_NETWORK}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>In Android 9.0 or higher, if tethering is enabled when this restriction is set,\n     * tethering will be automatically turned off.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_MOBILE_NETWORK" ]
  }, {
    "name" : "DISALLOW_NETWORK_RESET",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from resetting network settings\n     * from Settings. This can only be set by device owners and profile owners on the primary user.\n     * The default value is <code>false</code>.\n     * <p>This restriction has no effect on secondary users and managed profiles since only the\n     * primary user can reset the network settings of the device.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_MOBILE_NETWORK}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_MOBILE_NETWORK" ]
  }, {
    "name" : "DISALLOW_FACTORY_RESET",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from factory resetting from Settings.\n     * This can only be set by device owners and profile owners on an admin user.\n     * The default value is <code>false</code>.\n     * <p>This restriction has no effect on non-admin users since they cannot factory reset the\n     * device.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_FACTORY_RESET}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_FACTORY_RESET" ]
  }, {
    "name" : "DISALLOW_ADD_USER",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from adding new users. This can only be set by device\n     * owners or profile owners on the primary user. The default value is <code>false</code>.\n     * <p>This restriction has no effect on secondary users and managed profiles since only the\n     * primary user can add other users.\n     * <p> When the device is an organization-owned device provisioned with a managed profile,\n     * this restriction will be set as a base restriction which cannot be removed by any admin.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_MODIFY_USERS}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_MODIFY_USERS" ]
  }, {
    "name" : "DISALLOW_ADD_MANAGED_PROFILE",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from adding managed profiles.\n     * <p>The default value for an unmanaged user is <code>false</code>.\n     * For users with a device owner set, the default is <code>true</code>.\n     * <p>This restriction has no effect on managed profiles.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     * @deprecated As the ability to have a managed profile on a fully-managed device has been\n     * removed from the platform, this restriction will be silently ignored when applied by the\n     * device owner.\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_ADD_CLONE_PROFILE",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from creating clone profile.\n     * <p>The default value for an unmanaged user is <code>false</code>.\n     * For users with a device owner set, the default is <code>true</code>.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_PROFILES}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_PROFILES" ]
  }, {
    "name" : "DISALLOW_ADD_PRIVATE_PROFILE",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from creating a private profile.\n     * <p>The default value for an unmanaged user is <code>false</code>.\n     * For users with a device owner set, the default value is <code>true</code> and the\n     * device owner currently cannot change it to <code>false</code>.\n     * On organization-owned managed profile devices, the default value is <code>false</code> but\n     * the profile owner can change it to <code>true</code> via the parent profile to block creating\n     * of private profiles on the personal user.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_PROFILES}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#getParentProfileInstance(ComponentName)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_PROFILES" ]
  }, {
    "name" : "ENSURE_VERIFY_APPS",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from disabling application verification. The default\n     * value is <code>false</code>.\n     *\n     * <p>In Android 8.0 ({@linkplain android.os.Build.VERSION_CODES#O API level 26}) and higher,\n     * this is a global user restriction. If a device owner or profile owner sets this restriction,\n     * the system enforces app verification across all users on the device. Running in earlier\n     * Android versions, this restriction affects only the profile that sets it.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES" ]
  }, {
    "name" : "DISALLOW_CONFIG_CELL_BROADCASTS",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from configuring cell broadcasts.\n     *\n     * <p>This restriction can only be set by a device owner, a profile owner on the primary\n     * user or a profile owner of an organization-owned managed profile on the parent profile.\n     * When it is set by a device owner, it applies globally. When it is set by a profile owner\n     * on the primary user or by a profile owner of an organization-owned managed profile on\n     * the parent profile, it disables the primary user from configuring cell broadcasts.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_MOBILE_NETWORK}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>This restriction has no effect on secondary users and managed profiles since only the\n     * primary user can configure cell broadcasts.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_MOBILE_NETWORK" ]
  }, {
    "name" : "DISALLOW_CONFIG_MOBILE_NETWORKS",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from configuring mobile networks.\n     *\n     * <p>This restriction can only be set by a device owner, a profile owner on the primary\n     * user or a profile owner of an organization-owned managed profile on the parent profile.\n     * When it is set by a device owner, it applies globally. When it is set by a profile owner\n     * on the primary user or by a profile owner of an organization-owned managed profile on\n     * the parent profile, it disables the primary user from configuring mobile networks.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_MOBILE_NETWORK}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>This restriction has no effect on secondary users and managed profiles since only the\n     * primary user can configure mobile networks.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_MOBILE_NETWORK" ]
  }, {
    "name" : "DISALLOW_APPS_CONTROL",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from modifying\n     * applications in Settings or launchers. The following actions will not be allowed when this\n     * restriction is enabled:\n     * <li>uninstalling apps</li>\n     * <li>disabling apps</li>\n     * <li>clearing app caches</li>\n     * <li>clearing app data</li>\n     * <li>force stopping apps</li>\n     * <li>clearing app defaults</li>\n     * <p>\n     * The default value is <code>false</code>.\n     *\n     * <p><strong>Note:</strong> The user will still be able to perform those actions via other\n     * means (such as adb). Third party apps will also be able to uninstall apps via the\n     * {@link android.content.pm.PackageInstaller}. {@link #DISALLOW_UNINSTALL_APPS} or\n     * {@link DevicePolicyManager#setUninstallBlocked(ComponentName, String, boolean)} should be\n     * used to prevent the user from uninstalling apps completely, and\n     * {@link DevicePolicyManager#addPersistentPreferredActivity(ComponentName, IntentFilter, ComponentName)}\n     * to add a default intent handler for a given intent filter.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_APPS_CONTROL}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.content.pm.PackageInstaller", "android.app.admin.DevicePolicyManager#addPersistentPreferredActivity(ComponentName", "android.app.admin.DevicePolicyManager#setUninstallBlocked(ComponentName", "android.Manifest.permission#MANAGE_DEVICE_POLICY_APPS_CONTROL", "#DISALLOW_UNINSTALL_APPS" ]
  }, {
    "name" : "DISALLOW_MOUNT_PHYSICAL_MEDIA",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from mounting physical external media.\n     *\n     * <p>This restriction can only be set by a device owner, a profile owner on the primary\n     * user or a profile owner of an organization-owned managed profile on the parent profile.\n     * When it is set by a device owner, it applies globally. When it is set by a profile owner\n     * on the primary user or by a profile owner of an organization-owned managed profile on\n     * the parent profile, it disables the primary user from mounting physical external media.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA" ]
  }, {
    "name" : "DISALLOW_UNMUTE_MICROPHONE",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from adjusting microphone volume. If set, the microphone\n     * will be muted.\n     *\n     * <p>A device owner and a profile owner can set this restriction, although the restriction has\n     * no effect in a managed profile. When it is set by a device owner, it applies globally. When\n     * it is set by a profile owner on the primary user or by a profile owner of an\n     * organization-owned managed profile on the parent profile, it will disallow the primary user\n     * from adjusting the microphone volume.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_MICROPHONE}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_MICROPHONE" ]
  }, {
    "name" : "DISALLOW_ADJUST_VOLUME",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is disallowed from adjusting the global volume. If set, the global volume\n     * will be muted. This can be set by device owners from API 21 and profile owners from API 24.\n     * The default value is <code>false</code>.\n     *\n     * <p>When the restriction is set by profile owners, then it only applies to relevant\n     * profiles.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_AUDIO_OUTPUT}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>This restriction has no effect on managed profiles.\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_AUDIO_OUTPUT" ]
  }, {
    "name" : "DISALLOW_OUTGOING_CALLS",
    "type" : "String",
    "comment" : "\n     * Specifies that the user is not allowed to make outgoing phone calls. Emergency calls are\n     * still permitted.\n     *\n     * <p>A device owner and a profile owner can set this restriction, although the restriction has\n     * no effect in a managed profile. When it is set by a device owner, a profile owner on the\n     * primary user or by a profile owner of an organization-owned managed profile on the parent\n     * profile, it disallows the primary user from making outgoing phone calls.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_CALLS}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_CALLS" ]
  }, {
    "name" : "DISALLOW_SMS",
    "type" : "String",
    "comment" : "\n     * Specifies that the user is not allowed to send or receive SMS messages.\n     *\n     * <p>This restriction can only be set by a device owner, a profile owner on the primary\n     * user or a profile owner of an organization-owned managed profile on the parent profile.\n     * When it is set by a device owner, it applies globally. When it is set by a profile owner\n     * on the primary user or by a profile owner of an organization-owned managed profile on\n     * the parent profile, it disables the primary user from sending or receiving SMS messages.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_SMS}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_SMS" ]
  }, {
    "name" : "DISALLOW_FUN",
    "type" : "String",
    "comment" : "\n     * Specifies if the user is not allowed to have fun. In some cases, the\n     * device owner may wish to prevent the user from experiencing amusement or\n     * joy while using the device. The default value is <code>false</code>.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_FUN}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_FUN" ]
  }, {
    "name" : "DISALLOW_CREATE_WINDOWS",
    "type" : "String",
    "comment" : "\n     * Specifies that windows besides app windows should not be\n     * created. This will block the creation of the following types of windows.\n     * <li>{@link LayoutParams#TYPE_TOAST}</li>\n     * <li>{@link LayoutParams#TYPE_APPLICATION_OVERLAY}</li>\n     *\n     * <p>This can only be set by device owners and profile owners on the primary user.\n     * The default value is <code>false</code>.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_WINDOWS}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.view.WindowManager.LayoutParams#TYPE_APPLICATION_OVERLAY", "android.view.WindowManager.LayoutParams#TYPE_TOAST", "android.Manifest.permission#MANAGE_DEVICE_POLICY_WINDOWS" ]
  }, {
    "name" : "DISALLOW_SYSTEM_ERROR_DIALOGS",
    "type" : "String",
    "comment" : "\n     * Specifies that system error dialogs for crashed or unresponsive apps should not be shown.\n     * In this case, the system will force-stop the app as if the user chooses the \"close app\"\n     * option on the UI. A feedback report isn't collected as there is no way for the user to\n     * provide explicit consent. The default value is <code>false</code>.\n     *\n     * <p>When this user restriction is set by device owners, it's applied to all users. When set by\n     * the profile owner of the primary user or a secondary user, the restriction affects only the\n     * calling user. This user restriction has no effect on managed profiles.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS" ]
  }, {
    "name" : "DISALLOW_CROSS_PROFILE_COPY_PASTE",
    "type" : "String",
    "comment" : "\n     * Specifies if the clipboard contents can be exported by pasting the data into other users or\n     * profiles. This restriction doesn't prevent import, such as someone pasting clipboard data\n     * from other profiles or users. The default value is {@code false}.\n     *\n     * <p><strong>Note</strong>: Because it's possible to extract data from screenshots using\n     * optical character recognition (OCR), we strongly recommend combining this user restriction\n     * with {@link DevicePolicyManager#setScreenCaptureDisabled(ComponentName, boolean)}.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_PROFILE_INTERACTION}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.app.admin.DevicePolicyManager#setScreenCaptureDisabled(ComponentName", "android.Manifest.permission#MANAGE_DEVICE_POLICY_PROFILE_INTERACTION" ]
  }, {
    "name" : "DISALLOW_OUTGOING_BEAM",
    "type" : "String",
    "comment" : "\n     * Specifies if the user is not allowed to use NFC to beam out data from apps.\n     * The default value is <code>false</code>.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION" ]
  }, {
    "name" : "DISALLOW_WALLPAPER",
    "type" : "String",
    "comment" : "\n     * Hidden user restriction to disallow access to wallpaper manager APIs. This restriction\n     * generally means that wallpapers are not supported for the particular user. This user\n     * restriction is always set for managed profiles, because such profiles don't have wallpapers.\n     * @hide\n     * @see #DISALLOW_SET_WALLPAPER\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_SET_WALLPAPER",
    "type" : "String",
    "comment" : "\n     * User restriction to disallow setting a wallpaper. Profile owner and device owner\n     * are able to set wallpaper regardless of this restriction.\n     * The default value is <code>false</code>.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_WALLPAPER}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_WALLPAPER" ]
  }, {
    "name" : "DISALLOW_SAFE_BOOT",
    "type" : "String",
    "comment" : "\n     * Specifies if the user is not allowed to reboot the device into safe boot mode.\n     *\n     * <p>This restriction can only be set by a device owner, a profile owner on the primary\n     * user or a profile owner of an organization-owned managed profile on the parent profile.\n     * When it is set by a device owner, it applies globally. When it is set by a profile owner\n     * on the primary user or by a profile owner of an organization-owned managed profile on\n     * the parent profile, it disables the primary user from rebooting the device into safe\n     * boot mode.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_SAFE_BOOT}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_SAFE_BOOT" ]
  }, {
    "name" : "DISALLOW_RECORD_AUDIO",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is not allowed to record audio. This restriction is always enabled for\n     * background users. The default value is <code>false</code>.\n     *\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_RUN_IN_BACKGROUND",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is not allowed to run in the background and should be stopped and locked\n     * during user switch. The default value is <code>false</code>.\n     *\n     * <p>This restriction can be set by device owners and profile owners.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_RUN_IN_BACKGROUND}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_RUN_IN_BACKGROUND" ]
  }, {
    "name" : "DISALLOW_CAMERA",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is not allowed to use the camera.\n     *\n     * <p>A device owner and a profile owner can set this restriction. When it is set by a\n     * device owner, it applies globally - i.e., it disables the use of camera on the entire device\n     * and all users are affected. When it is set by a profile owner on the primary user or by a\n     * profile owner of an organization-owned managed profile on the parent profile, it disables\n     * the primary user from using camera.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_CAMERA}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_CAMERA" ]
  }, {
    "name" : "DISALLOW_UNMUTE_DEVICE",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is not allowed to unmute the device's global volume.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_AUDIO_OUTPUT}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * @see DevicePolicyManager#setMasterVolumeMuted(ComponentName, boolean)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_AUDIO_OUTPUT" ]
  }, {
    "name" : "DISALLOW_DATA_ROAMING",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is not allowed to use cellular data when roaming.\n     *\n     * <p>This restriction can only be set by a device owner, a profile owner on the primary\n     * user or a profile owner of an organization-owned managed profile on the parent profile.\n     * When it is set by a device owner, it applies globally. When it is set by a profile owner\n     * on the primary user or by a profile owner of an organization-owned managed profile on\n     * the parent profile, it disables the primary user from using cellular data when roaming.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_MOBILE_NETWORK}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_MOBILE_NETWORK" ]
  }, {
    "name" : "DISALLOW_SET_USER_ICON",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is not allowed to change their icon. Device owner and profile owner\n     * can set this restriction. When it is set by device owner, only the target user will be\n     * affected. The default value is <code>false</code>.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_MODIFY_USERS}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_MODIFY_USERS" ]
  }, {
    "name" : "DISALLOW_OEM_UNLOCK",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is not allowed to enable the oem unlock setting. The default value is\n     * <code>false</code>. Setting this restriction has no effect if the bootloader is already\n     * unlocked.\n     *\n     * <p>Not for use by third-party applications.\n     *\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     * @deprecated use {@link OemLockManager#setOemUnlockAllowedByCarrier(boolean, byte[])} instead.\n     * @hide\n     ",
    "links" : [ "#setOemUnlockAllowedByCarrier(boolean" ]
  }, {
    "name" : "DISALLOW_UNIFIED_PASSWORD",
    "type" : "String",
    "comment" : "\n     * Specifies that the managed profile is not allowed to have unified lock screen challenge with\n     * the primary user.\n     *\n     * <p><strong>Note:</strong> Setting this restriction alone doesn't automatically set a\n     * separate challenge. Profile owner can ask the user to set a new password using\n     * {@link DevicePolicyManager#ACTION_SET_NEW_PASSWORD} and verify it using\n     * {@link DevicePolicyManager#isUsingUnifiedPassword(ComponentName)}.\n     *\n     * <p>Can be set by profile owners. It only has effect on managed profiles when set by managed\n     * profile owner. Has no effect on non-managed profiles or users.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.app.admin.DevicePolicyManager#ACTION_SET_NEW_PASSWORD", "android.Manifest.permission#MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS", "android.app.admin.DevicePolicyManager#isUsingUnifiedPassword(ComponentName)" ]
  }, {
    "name" : "ALLOW_PARENT_PROFILE_APP_LINKING",
    "type" : "String",
    "comment" : "\n     * Allows apps in the parent profile to handle web links from the managed profile.\n     *\n     * This user restriction has an effect only in a managed profile.\n     * If set:\n     * Intent filters of activities in the parent profile with action\n     * {@link android.content.Intent#ACTION_VIEW},\n     * category {@link android.content.Intent#CATEGORY_BROWSABLE}, scheme http or https, and which\n     * define a host can handle intents from the managed profile.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_PROFILES}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.content.Intent#CATEGORY_BROWSABLE", "android.content.Intent#ACTION_VIEW", "android.Manifest.permission#MANAGE_DEVICE_POLICY_PROFILES" ]
  }, {
    "name" : "DISALLOW_AUTOFILL",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is not allowed to use Autofill Services.\n     *\n     * <p>Device owner and profile owner can set this restriction. When it is set by device owner,\n     * only the target user will be affected.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_AUTOFILL}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_AUTOFILL" ]
  }, {
    "name" : "DISALLOW_CONTENT_CAPTURE",
    "type" : "String",
    "comment" : "\n     * Specifies if the contents of a user's screen is not allowed to be captured for artificial\n     * intelligence purposes.\n     *\n     * <p>A device owner and a profile owner can set this restriction. When it is set by a device\n     * owner, a profile owner on the primary user or by a profile owner of an organization-owned\n     * managed profile on the parent profile, it disables the primary user's screen from being\n     * captured for artificial intelligence purposes.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_SCREEN_CONTENT}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_SCREEN_CONTENT" ]
  }, {
    "name" : "DISALLOW_CONTENT_SUGGESTIONS",
    "type" : "String",
    "comment" : "\n     * Specifies if the current user is able to receive content suggestions for selections based on\n     * the contents of their screen.\n     *\n     * <p>A device owner and a profile owner can set this restriction. When it is set by a device\n     * owner, a profile owner on the primary user or by a profile owner of an organization-owned\n     * managed profile on the parent profile, it disables the primary user from receiving content\n     * suggestions for selections based on the contents of their screen.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_SCREEN_CONTENT}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_SCREEN_CONTENT" ]
  }, {
    "name" : "DISALLOW_USER_SWITCH",
    "type" : "String",
    "comment" : "\n     * Specifies if user switching is blocked on the current user.\n     *\n     * <p> This restriction can only be set by the device owner, it will be applied to all users.\n     * Device owner can still switch user via\n     * {@link DevicePolicyManager#switchUser(ComponentName, UserHandle)} when this restriction is\n     * set.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_MODIFY_USERS}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.app.admin.DevicePolicyManager#switchUser(ComponentName", "android.Manifest.permission#MANAGE_DEVICE_POLICY_MODIFY_USERS" ]
  }, {
    "name" : "DISALLOW_SHARE_INTO_MANAGED_PROFILE",
    "type" : "String",
    "comment" : "\n     * Specifies whether the user can share file / picture / data from the primary user into the\n     * managed profile, either by sending them from the primary side, or by picking up data within\n     * an app in the managed profile.\n     * <p>\n     * When a managed profile is created, the system allows the user to send data from the primary\n     * side to the profile by setting up certain default cross profile intent filters. If\n     * this is undesired, this restriction can be set to disallow it. Note that this restriction\n     * will not block any sharing allowed by explicit\n     * {@link DevicePolicyManager#addCrossProfileIntentFilter} calls by the profile owner.\n     * <p>\n     * This restriction is only meaningful when set by profile owner. When it is set by device\n     * owner, it does not have any effect.\n     * <p>\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_PROFILE_INTERACTION}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.app.admin.DevicePolicyManager#addCrossProfileIntentFilter", "android.Manifest.permission#MANAGE_DEVICE_POLICY_PROFILE_INTERACTION" ]
  }, {
    "name" : "DISALLOW_PRINTING",
    "type" : "String",
    "comment" : "\n     * Specifies whether the user is allowed to print.\n     *\n     * This restriction can be set by device or profile owner.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_PRINTING}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * The default value is {@code false}.\n     *\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_PRINTING" ]
  }, {
    "name" : "DISALLOW_CONFIG_PRIVATE_DNS",
    "type" : "String",
    "comment" : "\n     * Specifies whether the user is allowed to modify private DNS settings.\n     *\n     * <p>This restriction can only be set by a device owner or a profile owner of an\n     * organization-owned managed profile on the parent profile. When it is set by either of these\n     * owners, it applies globally.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS" ]
  }, {
    "name" : "DISALLOW_MICROPHONE_TOGGLE",
    "type" : "String",
    "comment" : "\n     * Specifies whether the microphone toggle is available to the user. If this restriction is set,\n     * the user will not be able to block microphone access via the system toggle. If microphone\n     * access is blocked when the restriction is added, it will be automatically re-enabled.\n     *\n     * This restriction can only be set by a device owner.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * @see android.hardware.SensorPrivacyManager\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_CAMERA_TOGGLE",
    "type" : "String",
    "comment" : "\n     * Specifies whether the camera toggle is available to the user. If this restriction is set,\n     * the user will not be able to block camera access via the system toggle. If camera\n     * access is blocked when the restriction is added, it will be automatically re-enabled.\n     *\n     * This restriction can only be set by a device owner.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * @see android.hardware.SensorPrivacyManager\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_BIOMETRIC",
    "type" : "String",
    "comment" : "\n     * This is really not a user restriction in the normal sense. This can't be set to a user,\n     * via UserManager nor via DevicePolicyManager. This is not even set in UserSettingsUtils.\n     * This is defined here purely for convenience within the settings app.\n     *\n     * TODO(b/191306258): Refactor the Settings app to remove the need for this field, and delete it\n     *\n     * Specifies whether biometrics are available to the user. This is used internally only,\n     * as a means of communications between biometric settings and\n     * {@link com.android.settingslib.enterprise.ActionDisabledByAdminControllerFactory}.\n     *\n     * @see {@link android.hardware.biometrics.ParentalControlsUtilsInternal}\n     * @see {@link com.android.settings.biometrics.ParentalControlsUtils}\n     *\n     * @hide\n     ",
    "links" : [ "android.hardware.biometrics.ParentalControlsUtilsInternal", "com.android.settings.biometrics.ParentalControlsUtils", "com.android.settingslib.enterprise.ActionDisabledByAdminControllerFactory" ]
  }, {
    "name" : "DISALLOW_CONFIG_DEFAULT_APPS",
    "type" : "String",
    "comment" : "\n     * Specifies whether the user is allowed to modify default apps in settings.\n     *\n     * <p>A device owner and a profile owner can set this restriction. When it is set by a\n     * device owner, it applies globally - i.e., modifying of default apps in Settings for all\n     * users is disallowed. When it is set by a profile owner on the primary user or by a profile\n     * owner of an organization-owned managed profile on the parent profile, modifying of\n     * default apps in Settings for the primary user is disallowed.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_RESTRICTIONS_PENDING",
    "type" : "String",
    "comment" : "\n     * Application restriction key that is used to indicate the pending arrival\n     * of real restrictions for the app.\n     *\n     * <p>\n     * Applications that support restrictions should check for the presence of this key.\n     * A <code>true</code> value indicates that restrictions may be applied in the near\n     * future but are not available yet. It is the responsibility of any\n     * management application that sets this flag to update it when the final\n     * restrictions are enforced.\n     *\n     * <p>Key for application restrictions.\n     * <p>Type: Boolean\n     * @see android.app.admin.DevicePolicyManager#setApplicationRestrictions(\n     *      android.content.ComponentName, String, Bundle)\n     * @see android.app.admin.DevicePolicyManager#getApplicationRestrictions(\n     *      android.content.ComponentName, String)\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_CELLULAR_2G",
    "type" : "String",
    "comment" : "\n     * Specifies if a user is not allowed to use 2g networks.\n     *\n     * <p> This is a security feature. 2g has no mutual authentication between a device and\n     * cellular base station and downgrading a device's connection to 2g is a common tactic for\n     * several types of privacy and security compromising attacks that could allow an adversary\n     * to intercept, inject, or modify cellular communications.\n     *\n     * <p>This restriction can only be set by a device owner or a profile owner of an\n     * organization-owned managed profile on the parent profile.\n     * In all cases, the setting applies globally on the device.\n     *\n     * <p> Cellular connectivity loss (where a device would have otherwise successfully\n     * connected to a 2g network) occurs if the device is in an area where only 2g networks are\n     * available. Emergency calls are an exception and are never impacted. The device will still\n     * scan for and connect to a 2g network for emergency calls.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_MOBILE_NETWORK}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>The default value is <code>false</code>.\n     *\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_MOBILE_NETWORK" ]
  }, {
    "name" : "DISALLOW_ULTRA_WIDEBAND_RADIO",
    "type" : "String",
    "comment" : "\n     * This user restriction specifies if Ultra-wideband is disallowed on the device. If\n     * Ultra-wideband is disallowed it cannot be turned on via Settings.\n     *\n     * <p>\n     * Ultra-wideband (UWB) is a radio technology that can use a very low energy level\n     * for short-range, high-bandwidth communications over a large portion of the radio spectrum.\n     *\n     * <p>This restriction can only be set by a device owner or a profile owner of an\n     * organization-owned managed profile on the parent profile.\n     * In both cases, the restriction applies globally on the device and will turn off the\n     * ultra-wideband radio if it's currently on and prevent the radio from being turned on in\n     * the future.\n     *\n     * <p>Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Default is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION" ]
  }, {
    "name" : "DISALLOW_NEAR_FIELD_COMMUNICATION_RADIO",
    "type" : "String",
    "comment" : "\n     * This user restriction specifies if Near-field communication is disallowed on the device. If\n     * Near-field communication is disallowed it cannot be turned on via Settings.\n     *\n     * <p>This restriction can only be set by a device owner or a profile owner of an\n     * organization-owned managed profile on the parent profile.\n     * In both cases, the restriction applies globally on the device and will turn off the\n     * Near-field communication radio if it's currently on and prevent the radio from being turned\n     * on in the future.\n     *\n     * <p>\n     * Near-field communication (NFC) is a radio technology that allows two devices (like your phone\n     * and a payments terminal) to communicate with each other when they're close together.\n     *\n     * <p>Default is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_THREAD_NETWORK",
    "type" : "String",
    "comment" : "\n     * This user restriction specifies if Thread network is disallowed on the device. If Thread\n     * network is disallowed it cannot be turned on via Settings.\n     *\n     * <p>This restriction can only be set by a device owner or a profile owner of an\n     * organization-owned managed profile on the parent profile.\n     * In both cases, the restriction applies globally on the device and will turn off the\n     * Thread network radio if it's currently on and prevent the radio from being turned\n     * on in the future.\n     *\n     * <p> <a href=\"https://www.threadgroup.org\">Thread</a> is a low-power and low-latency wireless\n     * mesh networking protocol built on IPv6.\n     *\n     * <p>Default is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "DISALLOW_SIM_GLOBALLY",
    "type" : "String",
    "comment" : "\n     * This user restriction specifies if the user is able to add embedded SIMs to the device.\n     *\n     * <p>\n     * This restriction blocks the download of embedded SIMs.\n     *\n     * <p>\n     * This restriction can only be set by a device owner or a profile owner of an\n     * organization-owned managed profile.\n     * In both cases, the restriction applies globally on the device.\n     *\n     * <p>\n     * Holders of the permission\n     * {@link android.Manifest.permission#MANAGE_DEVICE_POLICY_MOBILE_NETWORK}\n     * can set this restriction using the DevicePolicyManager APIs mentioned below.\n     *\n     * <p>Default is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     *\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_DEVICE_POLICY_MOBILE_NETWORK" ]
  }, {
    "name" : "DISALLOW_ASSIST_CONTENT",
    "type" : "String",
    "comment" : "\n     * This user restriction specifies if assist content is disallowed from being sent to\n     * a privileged app such as the Assistant app. Assist content includes screenshots and\n     * information about an app, such as package name.\n     *\n     * <p>This restriction can only be set by a device owner or a profile owner. When it is set\n     * by a device owner, it disables the assist contextual data on the entire device. When it is\n     * set by a profile owner, it disables assist content on the profile.\n     *\n     * <p>Default is <code>false</code>.\n     *\n     * <p>Key for user restrictions.\n     * <p>Type: Boolean\n     * @see DevicePolicyManager#addUserRestriction(ComponentName, String)\n     * @see DevicePolicyManager#clearUserRestriction(ComponentName, String)\n     * @see #getUserRestrictions()\n     ",
    "links" : [ ]
  }, {
    "name" : "SYSTEM_USER_MODE_EMULATION_PROPERTY",
    "type" : "String",
    "comment" : "\n     * Property used to override whether the device uses headless system user mode.\n     *\n     * <p>Only used on non-user builds.\n     *\n     * <p><b>NOTE: </b>setting this variable directly won't properly change the headless system user\n     * mode behavior and might put the device in a bad state; the system user mode should be changed\n     * using {@code cmd user set-system-user-mode-emulation} instead.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SYSTEM_USER_MODE_EMULATION_DEFAULT",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SYSTEM_USER_MODE_EMULATION_FULL",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SYSTEM_USER_MODE_EMULATION_HEADLESS",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DEV_CREATE_OVERRIDE_PROPERTY",
    "type" : "String",
    "comment" : "\n     * System Property used to override whether users can be created even if their type is disabled\n     * or their limit is reached. Set value to 1 to enable.\n     *\n     * <p>Only used on non-user builds.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_CREATE_USER",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_CREATE_SUPERVISED_USER",
    "type" : "String",
    "comment" : "\n     * Action to start an activity to create a supervised user.\n     * Only devices with non-empty config_supervisedUserCreationPackage support this.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_USER_NAME",
    "type" : "String",
    "comment" : "\n     * Extra containing a name for the user being created. Optional parameter passed to\n     * ACTION_CREATE_USER activity.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_USER_ACCOUNT_NAME",
    "type" : "String",
    "comment" : "\n     * Extra containing account name for the user being created. Optional parameter passed to\n     * ACTION_CREATE_USER activity.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_USER_ACCOUNT_TYPE",
    "type" : "String",
    "comment" : "\n     * Extra containing account type for the user being created. Optional parameter passed to\n     * ACTION_CREATE_USER activity.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_USER_ACCOUNT_OPTIONS",
    "type" : "String",
    "comment" : "\n     * Extra containing account-specific data for the user being created. Optional parameter passed\n     * to ACTION_CREATE_USER activity.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PIN_VERIFICATION_FAILED_INCORRECT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "PIN_VERIFICATION_FAILED_NOT_SET",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "PIN_VERIFICATION_SUCCESS",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ACTION_USER_RESTRICTIONS_CHANGED",
    "type" : "String",
    "comment" : "\n     * Sent when user restrictions have changed.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_CREATION_FAILED_NOT_PERMITTED",
    "type" : "int",
    "comment" : "\n     * Error result indicating that this user is not allowed to add other users on this device.\n     * This is a result code returned from the activity created by the intent\n     * {@link #createUserCreationIntent(String, String, String, PersistableBundle)}.\n     ",
    "links" : [ "#createUserCreationIntent(String" ]
  }, {
    "name" : "USER_CREATION_FAILED_NO_MORE_USERS",
    "type" : "int",
    "comment" : "\n     * Error result indicating that no more users can be created on this device.\n     * This is a result code returned from the activity created by the intent\n     * {@link #createUserCreationIntent(String, String, String, PersistableBundle)}.\n     ",
    "links" : [ "#createUserCreationIntent(String" ]
  }, {
    "name" : "SWITCHABILITY_STATUS_OK",
    "type" : "int",
    "comment" : "\n     * Indicates that users are switchable.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SWITCHABILITY_STATUS_USER_IN_CALL",
    "type" : "int",
    "comment" : "\n     * Indicated that the user is in a phone call.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SWITCHABILITY_STATUS_USER_SWITCH_DISALLOWED",
    "type" : "int",
    "comment" : "\n     * Indicates that user switching is disallowed ({@link #DISALLOW_USER_SWITCH} is set).\n     * @hide\n     ",
    "links" : [ "#DISALLOW_USER_SWITCH" ]
  }, {
    "name" : "SWITCHABILITY_STATUS_SYSTEM_USER_LOCKED",
    "type" : "int",
    "comment" : "\n     * Indicates that the system user is locked and user switching is not allowed.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REMOVE_RESULT_REMOVED",
    "type" : "int",
    "comment" : "\n     * A response code from {@link #removeUserWhenPossible(UserHandle, boolean)} indicating that\n     * the specified user has been successfully removed.\n     *\n     * @hide\n     ",
    "links" : [ "#removeUserWhenPossible(UserHandle" ]
  }, {
    "name" : "REMOVE_RESULT_DEFERRED",
    "type" : "int",
    "comment" : "\n     * A response code from {@link #removeUserWhenPossible(UserHandle, boolean)} indicating that\n     * the specified user is marked so that it will be removed when the user is stopped or on boot.\n     *\n     * @hide\n     ",
    "links" : [ "#removeUserWhenPossible(UserHandle" ]
  }, {
    "name" : "REMOVE_RESULT_ALREADY_BEING_REMOVED",
    "type" : "int",
    "comment" : "\n     * A response code from {@link #removeUserWhenPossible(UserHandle, boolean)} indicating that\n     * the specified user is already in the process of being removed.\n     *\n     * @hide\n     ",
    "links" : [ "#removeUserWhenPossible(UserHandle" ]
  }, {
    "name" : "REMOVE_RESULT_USER_IS_REMOVABLE",
    "type" : "int",
    "comment" : "\n     * A response code indicating that the specified user is removable.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "REMOVE_RESULT_ERROR_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * A response code from {@link #removeUserWhenPossible(UserHandle, boolean)} indicating that\n     * an unknown error occurred that prevented the user from being removed or set as ephemeral.\n     *\n     * @hide\n     ",
    "links" : [ "#removeUserWhenPossible(UserHandle" ]
  }, {
    "name" : "REMOVE_RESULT_ERROR_USER_RESTRICTION",
    "type" : "int",
    "comment" : "\n     * A response code from {@link #removeUserWhenPossible(UserHandle, boolean)} indicating that\n     * the user could not be removed due to a {@link #DISALLOW_REMOVE_MANAGED_PROFILE} or\n     * {@link #DISALLOW_REMOVE_USER} user restriction.\n     *\n     * @hide\n     ",
    "links" : [ "#removeUserWhenPossible(UserHandle", "#DISALLOW_REMOVE_MANAGED_PROFILE", "#DISALLOW_REMOVE_USER" ]
  }, {
    "name" : "REMOVE_RESULT_ERROR_USER_NOT_FOUND",
    "type" : "int",
    "comment" : "\n     * A response code from {@link #removeUserWhenPossible(UserHandle, boolean)} indicating that\n     * user being removed does not exist.\n     *\n     * @hide\n     ",
    "links" : [ "#removeUserWhenPossible(UserHandle" ]
  }, {
    "name" : "REMOVE_RESULT_ERROR_SYSTEM_USER",
    "type" : "int",
    "comment" : "\n     * A response code from {@link #removeUserWhenPossible(UserHandle, boolean)} indicating that\n     * user being removed is a {@link UserHandle#SYSTEM} user which can't be removed.\n     *\n     * @hide\n     ",
    "links" : [ "#removeUserWhenPossible(UserHandle", "android.os.UserHandle#SYSTEM" ]
  }, {
    "name" : "REMOVE_RESULT_ERROR_MAIN_USER_PERMANENT_ADMIN",
    "type" : "int",
    "comment" : "\n     * A response code from {@link #removeUserWhenPossible(UserHandle, boolean)} indicating that\n     * user being removed is a  {@link UserInfo#FLAG_MAIN}  user and can't be removed because\n     * system property {@link com.android.internal.R.bool.isMainUserPermanentAdmin} is true.\n     * @hide\n     ",
    "links" : [ "#removeUserWhenPossible(UserHandle", "com.android.internal.R.bool.isMainUserPermanentAdmin", "android.content.pm.UserInfo#FLAG_MAIN" ]
  }, {
    "name" : "USER_OPERATION_SUCCESS",
    "type" : "int",
    "comment" : "\n     * Indicates user operation is successful.\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_OPERATION_ERROR_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Indicates user operation failed for unknown reason.\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_OPERATION_ERROR_MANAGED_PROFILE",
    "type" : "int",
    "comment" : "\n     * Indicates user operation failed because target user is a managed profile.\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_OPERATION_ERROR_MAX_RUNNING_USERS",
    "type" : "int",
    "comment" : "\n     * Indicates user operation failed because maximum running user limit has been reached.\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_OPERATION_ERROR_CURRENT_USER",
    "type" : "int",
    "comment" : "\n     * Indicates user operation failed because the target user is in the foreground.\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_OPERATION_ERROR_LOW_STORAGE",
    "type" : "int",
    "comment" : "\n     * Indicates user operation failed because device has low data storage.\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_OPERATION_ERROR_MAX_USERS",
    "type" : "int",
    "comment" : "\n     * Indicates user operation failed because maximum user limit has been reached.\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_OPERATION_ERROR_USER_ACCOUNT_ALREADY_EXISTS",
    "type" : "int",
    "comment" : "\n     * Indicates user operation failed because a user with that account already exists.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_OPERATION_ERROR_DISABLED_USER",
    "type" : "int",
    "comment" : "\n     * Indicates user operation failed because user is disabled on the device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_OPERATION_ERROR_PRIVATE_PROFILE",
    "type" : "int",
    "comment" : "\n     * Indicates user operation failed because user is disabled on the device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ALWAYS_USE_CONTEXT_USER",
    "type" : "long",
    "comment" : "\n     * For apps targeting {@link Build.VERSION_CODES#TIRAMISU} and above, any UserManager API marked\n     * as {@link  android.annotation.UserHandleAware @UserHandleAware} will use the context user\n     * (rather than the calling user).\n     * For apps targeting an SDK version <em>below</em> this, the behaviour\n     * depends on the particular method and when it was first introduced:\n     * <ul>\n     *     <li>\n     *         if the {@literal @}UserHandleAware specifies a\n     *         {@link  android.annotation.UserHandleAware#enabledSinceTargetSdkVersion} of\n     *         {@link Build.VERSION_CODES#TIRAMISU} the <em>calling</em> user is used.\n     *     </li>\n     *     <li>\n     *         if the {@literal @}UserHandleAware doesn't specify a\n     *         {@link  android.annotation.UserHandleAware#enabledSinceTargetSdkVersion}, the\n     *         <em>context</em> user is used.\n     *     </li>\n     *     <li>there should currently be no other values used by UserManager for\n     *         {@link  android.annotation.UserHandleAware#enabledSinceTargetSdkVersion}, since all\n     *         old implicitly user-dependant APIs were updated in that version and anything\n     *         introduced more recently should already be {@literal @}UserHandleAware.\n     *     </li>\n     * </ul>\n     *\n     * Note that when an API marked with\n     * {@link  android.annotation.UserHandleAware#enabledSinceTargetSdkVersion} is run\n     * on a device whose OS predates that version, the calling user will be used, since on such a\n     * device, the API is not {@literal @}UserHandleAware yet.\n     *\n     * @hide\n     ",
    "links" : [ "android.annotation.UserHandleAware", "Build.VERSION_CODES#TIRAMISU", "android.annotation.UserHandleAware#enabledSinceTargetSdkVersion" ]
  }, {
    "name" : "CACHE_KEY_IS_USER_UNLOCKED_PROPERTY",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsUserUnlockedCache",
    "type" : "PropertyInvalidatedCache<Integer, Boolean>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsUserUnlockingOrUnlockedCache",
    "type" : "PropertyInvalidatedCache<Integer, Boolean>",
    "comment" : " Uses IS_USER_UNLOCKED_PROPERTY for invalidation as the APIs have the same dependencies.",
    "links" : [ ]
  }, {
    "name" : "CACHE_KEY_STATIC_USER_PROPERTIES",
    "type" : "String",
    "comment" : " Cache key for anything that assumes that userIds cannot be re-used without rebooting. ",
    "links" : [ ]
  }, {
    "name" : "mProfileTypeCache",
    "type" : "PropertyInvalidatedCache<Integer, String>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CACHE_KEY_USER_PROPERTIES",
    "type" : "String",
    "comment" : " Cache key for UserProperties object. ",
    "links" : [ ]
  }, {
    "name" : "mUserPropertiesCache",
    "type" : "PropertyInvalidatedCache<Integer, UserProperties>",
    "comment" : " TODO: It would be better to somehow have this as static, so that it can work cross-context.",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private T returnNullOrThrowUserOperationException(ServiceSpecificException exception, boolean throwInsteadOfNull) throws UserOperationException",
    "returnType" : "T",
    "comment" : "\n     * Converts the ServiceSpecificException into a UserOperationException or throws null;\n     *\n     * @param exception exception to convert.\n     * @param throwInsteadOfNull if an exception should be thrown or null returned.\n     * @return null if chosen not to throw exception.\n     * @throws UserOperationException\n     ",
    "links" : [ ]
  }, {
    "name" : "private int getContextUserIfAppropriate()",
    "returnType" : "int",
    "comment" : "\n     * Returns the context user or the calling user, depending on the target SDK.\n     * New APIs do not require such gating and therefore should always use mUserId instead.\n     * @see #ALWAYS_USE_CONTEXT_USER\n     ",
    "links" : [ ]
  }, {
    "name" : "public static UserManager get(Context context)",
    "returnType" : "UserManager",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static boolean supportsMultipleUsers()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether this device supports multiple users with their own login and customizable\n     * space.\n     * @return whether the device supports multiple users.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isGuestUserAlwaysEphemeral()",
    "returnType" : "boolean",
    "comment" : "\n     * @return Whether guest user is always ephemeral\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isGuestUserAllowEphemeralStateChange()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true, when we want to enable user manager API and UX to allow\n     *           guest user ephemeral state change based on user input\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isCommunalProfileEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the device is configured to support a Communal Profile.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isPrivateProfileEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the device supports Private Profile\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isMultipleAdminEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether multiple admins are enabled on the device\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isHeadlessSystemUserMode()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether the device is running in a headless system user mode.\n     *\n     * <p>Headless system user mode means the {@link #isSystemUser() system user} runs system\n     * services and some system UI, but it is not associated with any real person and additional\n     * users must be created to be associated with real persons.\n     *\n     * @return whether the device is running in a headless system user mode.\n     ",
    "links" : [ "#isSystemUser()" ]
  }, {
    "name" : "public boolean canSwitchUsers()",
    "returnType" : "boolean",
    "comment" : "\n     * @deprecated use {@link #getUserSwitchability()} instead.\n     *\n     * @removed\n     * @hide\n     ",
    "links" : [ "#getUserSwitchability()" ]
  }, {
    "name" : "public int getUserSwitchability()",
    "returnType" : "int",
    "comment" : "\n     * Returns whether switching users is currently allowed for the context user.\n     * <p>\n     * Switching users is not allowed in the following cases:\n     * <li>the user is in a phone call</li>\n     * <li>{@link #DISALLOW_USER_SWITCH} is set</li>\n     * <li>system user hasn't been unlocked yet</li>\n     *\n     * @return A {@link UserSwitchabilityResult} flag indicating if the user is switchable.\n     * @hide\n     ",
    "links" : [ "UserSwitchabilityResult", "#DISALLOW_USER_SWITCH" ]
  }, {
    "name" : "public int getUserSwitchability(UserHandle userHandle)",
    "returnType" : "int",
    "comment" : "\n     * Returns whether switching users is currently allowed for the provided user.\n     * <p>\n     * Switching users is not allowed in the following cases:\n     * <li>the user is in a phone call</li>\n     * <li>{@link #DISALLOW_USER_SWITCH} is set</li>\n     * <li>system user hasn't been unlocked yet</li>\n     *\n     * @return A {@link UserSwitchabilityResult} flag indicating if the user is switchable.\n     * @hide\n     ",
    "links" : [ "UserSwitchabilityResult", "#DISALLOW_USER_SWITCH" ]
  }, {
    "name" : "public int getUserHandle()",
    "returnType" : "int",
    "comment" : "\n     * Returns the userId for the context user.\n     *\n     * @return the userId of the context user.\n     *\n     * @deprecated To get the <em>calling</em> user, use {@link UserHandle#myUserId()}.\n     *             To get the <em>context</em> user, get it directly from the context.\n     *\n     * @hide\n     ",
    "links" : [ "android.os.UserHandle#myUserId()" ]
  }, {
    "name" : "public int getProcessUserId()",
    "returnType" : "int",
    "comment" : "\n     * Returns the userId for the user that this process is running under\n     * (<em>not</em> the context user).\n     *\n     * @return the userId of <em>this process</em>.\n     *\n     * @deprecated Use {@link UserHandle#myUserId()}\n     * @hide\n     ",
    "links" : [ "android.os.UserHandle#myUserId()" ]
  }, {
    "name" : "public String getUserType()",
    "returnType" : "String",
    "comment" : "\n     * @return the user type of the context user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getUserName()",
    "returnType" : "String",
    "comment" : "\n     * Returns the user name of the context user. This call is only available to applications on\n     * the system image.\n     *\n     * @return the user name\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUserNameSet()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether user name has been set.\n     * <p>This method can be used to check that the value returned by {@link #getUserName()} was\n     * set by the user and is not a placeholder string provided by the system.\n     * @hide\n     ",
    "links" : [ "#getUserName()" ]
  }, {
    "name" : "public boolean isUserAGoat()",
    "returnType" : "boolean",
    "comment" : "\n     * Used to determine whether the user making this call is subject to\n     * teleportations.\n     *\n     * <p>As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method can\n     * now automatically identify goats using advanced goat recognition technology.</p>\n     *\n     * <p>As of {@link android.os.Build.VERSION_CODES#R}, this method always returns\n     * {@code false} in order to protect goat privacy.</p>\n     *\n     * @return Returns whether the user making this call is a goat.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#R", "android.os.Build.VERSION_CODES#LOLLIPOP" ]
  }, {
    "name" : "public boolean isPrimaryUser()",
    "returnType" : "boolean",
    "comment" : "\n     * Used to check if the context user is the primary user. The primary user is the first human\n     * user on a device. This is not supported in headless system user mode.\n     *\n     * @return whether the context user is the primary user.\n     *\n     * @deprecated This method always returns true for the system user, who may not be a full user\n     * if {@link #isHeadlessSystemUserMode} is true. Use {@link #isSystemUser}, {@link #isAdminUser}\n     * or {@link #isMainUser} instead.\n     *\n     * @hide\n     ",
    "links" : [ "#isSystemUser", "#isAdminUser", "#isHeadlessSystemUserMode", "#isMainUser" ]
  }, {
    "name" : "public boolean isSystemUser()",
    "returnType" : "boolean",
    "comment" : "\n     * Used to check if the context user is the system user. The system user\n     * is the initial user that is implicitly created on first boot and hosts most of the\n     * system services.\n     *\n     * @return whether the context user is the system user.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isMainUser()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the context user is the designated \"main user\" of the device. This\n     * user may have access to certain features which are limited to at most one user. There will\n     * never be more than one main user on a device.\n     *\n     * <p>Currently, on most form factors the first human user on the device will be the main user;\n     * in the future, the concept may be transferable, so a different user (or even no user at all)\n     * may be designated the main user instead. On other form factors there might not be a main\n     * user.\n     *\n     * <p>Note that this will not be the system user on devices for which\n     * {@link #isHeadlessSystemUserMode()} returns true.\n     * @hide\n     ",
    "links" : [ "#isHeadlessSystemUserMode()" ]
  }, {
    "name" : "public UserHandle getMainUser()",
    "returnType" : "UserHandle",
    "comment" : "\n     * Returns the designated \"main user\" of the device, or {@code null} if there is no main user.\n     *\n     * @see #isMainUser()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public UserHandle getCommunalProfile()",
    "returnType" : "UserHandle",
    "comment" : "\n     * Returns the designated \"communal profile\" of the device, or {@code null} if there is none.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isCommunalProfile()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the context user is running in a communal profile.\n     *\n     * A communal profile is a {@link #isProfile() profile}, but instead of being associated with a\n     * particular parent user, it is communal to the device.\n     *\n     * @return whether the context user is a communal profile.\n     ",
    "links" : [ "#isProfile()" ]
  }, {
    "name" : "private boolean isCommunalProfile(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the given user is the designated \"communal profile\" of the device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAdminUser()",
    "returnType" : "boolean",
    "comment" : "\n     * Used to check if the context user is an admin user. An admin user may be allowed to\n     * modify or configure certain settings that aren't available to non-admin users,\n     * create and delete additional users, etc. There can be more than one admin users.\n     *\n     * @return whether the context user is an admin user.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUserAdmin(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Returns whether the provided user is an admin user. There can be more than one admin\n     * user.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isForegroundUserAdmin()",
    "returnType" : "boolean",
    "comment" : "\n     * Used to check if the user currently running in the <b>foreground</b> is an\n     * {@link #isAdminUser() admin} user.\n     *\n     * @return whether the foreground user is an admin user.\n     * @see #isAdminUser()\n     * @see #isUserForeground()\n     ",
    "links" : [ "#isAdminUser()" ]
  }, {
    "name" : "public boolean isUserOfType(@NonNull String userType)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the context user is of the given user type.\n     *\n     * @param userType the name of the user's user type, e.g.\n     *                 {@link UserManager#USER_TYPE_PROFILE_MANAGED}.\n     * @return true if the user is of the given user type.\n     * @hide\n     ",
    "links" : [ "android.os.UserManager#USER_TYPE_PROFILE_MANAGED" ]
  }, {
    "name" : "public static boolean isUserTypeManagedProfile(@Nullable String userType)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the user type is a\n     * {@link UserManager#USER_TYPE_PROFILE_MANAGED managed profile}.\n     * @hide\n     ",
    "links" : [ "android.os.UserManager#USER_TYPE_PROFILE_MANAGED" ]
  }, {
    "name" : "public static boolean isUserTypeGuest(@Nullable String userType)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the user type is a {@link UserManager#USER_TYPE_FULL_GUEST guest user}.\n     * @hide\n     ",
    "links" : [ "android.os.UserManager#USER_TYPE_FULL_GUEST" ]
  }, {
    "name" : "public static boolean isUserTypeRestricted(@Nullable String userType)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the user type is a\n     * {@link UserManager#USER_TYPE_FULL_RESTRICTED restricted user}.\n     * @hide\n     ",
    "links" : [ "android.os.UserManager#USER_TYPE_FULL_RESTRICTED" ]
  }, {
    "name" : "public static boolean isUserTypeDemo(@Nullable String userType)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the user type is a {@link UserManager#USER_TYPE_FULL_DEMO demo user}.\n     * @hide\n     ",
    "links" : [ "android.os.UserManager#USER_TYPE_FULL_DEMO" ]
  }, {
    "name" : "public static boolean isUserTypeCloneProfile(@Nullable String userType)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the user type is a {@link UserManager#USER_TYPE_PROFILE_CLONE clone user}.\n     * @hide\n     ",
    "links" : [ "android.os.UserManager#USER_TYPE_PROFILE_CLONE" ]
  }, {
    "name" : "public static boolean isUserTypeCommunalProfile(@Nullable String userType)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the user type is a\n     * {@link UserManager#USER_TYPE_PROFILE_COMMUNAL communal profile}.\n     * @hide\n     ",
    "links" : [ "android.os.UserManager#USER_TYPE_PROFILE_COMMUNAL" ]
  }, {
    "name" : "public static boolean isUserTypePrivateProfile(@Nullable String userType)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the user type is a\n     * {@link UserManager#USER_TYPE_PROFILE_PRIVATE private profile}.\n     *\n     * @hide\n     ",
    "links" : [ "android.os.UserManager#USER_TYPE_PROFILE_PRIVATE" ]
  }, {
    "name" : "public boolean isLinkedUser()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * @deprecated Use {@link #isRestrictedProfile()}\n     ",
    "links" : [ "#isRestrictedProfile()" ]
  }, {
    "name" : "public boolean isRestrictedProfile()",
    "returnType" : "boolean",
    "comment" : "\n     * Used to check if the context user is a restricted profile. Restricted profiles\n     * may have a reduced number of available apps, app restrictions, and account restrictions.\n     *\n     * <p>The caller must be in the same profile group as the context user or else hold\n     * <li>{@link android.Manifest.permission#MANAGE_USERS},\n     * <li>or {@link android.Manifest.permission#CREATE_USERS},\n     * <li>or, for devices after {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE},\n     * {@link android.Manifest.permission#QUERY_USERS}.\n     *\n     * @return whether the context user is a restricted profile.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_USERS", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.Manifest.permission#CREATE_USERS", "android.Manifest.permission#QUERY_USERS" ]
  }, {
    "name" : "public boolean isRestrictedProfile(@NonNull UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if a user is a restricted profile. Restricted profiles may have a reduced number of\n     * available apps, app restrictions, and account restrictions.\n     *\n     * <p>Requires\n     * <li>{@link android.Manifest.permission#MANAGE_USERS},\n     * <li>or {@link android.Manifest.permission#CREATE_USERS},\n     * <li>or, for devices after {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE},\n     * {@link android.Manifest.permission#QUERY_USERS}.\n     *\n     * @param user the user to check\n     * @return whether the user is a restricted profile.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_USERS", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.Manifest.permission#CREATE_USERS", "android.Manifest.permission#QUERY_USERS" ]
  }, {
    "name" : "public boolean canHaveRestrictedProfile()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the context user can have a restricted profile.\n     * @return whether the context user can have a restricted profile.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean canAddPrivateProfile()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if it's possible to add a private profile to the context user\n     * @return whether the context user can add a private profile.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasRestrictedProfiles()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the context user has at least one restricted profile associated with it.\n     * @return whether the user has a restricted profile associated with it\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public UserHandle getRestrictedProfileParent()",
    "returnType" : "UserHandle",
    "comment" : "\n     * Get the parent of a restricted profile.\n     *\n     * @return the parent of the user or {@code null} if the user is not restricted profile\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isGuestUser(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if a user is a guest user.\n     * @return whether user is a guest user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isGuestUser()",
    "returnType" : "boolean",
    "comment" : "\n     * Used to check if the context user is a guest user. A guest user may be transient.\n     *\n     * @return whether the context user is a guest user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isDemoUser()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the context user is a demo user. When running in a demo user,\n     * apps can be more helpful to the user, or explain their features in more detail.\n     *\n     * @return whether the context user is a demo user.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isProfile()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the context user is running in a profile. A profile is a user that\n     * typically has its own separate data but shares its UI with some parent user. For example, a\n     * {@link #isManagedProfile() managed profile} is a type of profile.\n     *\n     * @return whether the context user is in a profile.\n     ",
    "links" : [ "#isManagedProfile()" ]
  }, {
    "name" : "public boolean isProfile(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the specified user is a profile.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private String getProfileType()",
    "returnType" : "String",
    "comment" : "\n     * Returns the user type of the context user if it is a profile.\n     *\n     * This is a more specific form of {@link #getUserType()} with relaxed permission requirements.\n     *\n     * @return the user type of the context user if it is a {@link #isProfile() profile},\n     *         an empty string if it is not a profile,\n     *         or null if the user doesn't exist.\n     ",
    "links" : [ "#isProfile()", "#getUserType()" ]
  }, {
    "name" : "private String getProfileType(@UserIdInt int userId)",
    "returnType" : "String",
    "comment" : " @see #getProfileType() ",
    "links" : [ ]
  }, {
    "name" : "public boolean isManagedProfile()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the context user is a managed profile.\n     *\n     * Note that this applies specifically to <em>managed</em> profiles. For profiles in general,\n     * use {@link #isProfile()} instead.\n     *\n     * @return whether the context user is a managed profile.\n     ",
    "links" : [ "#isProfile()" ]
  }, {
    "name" : "public boolean isManagedProfile(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the specified user is a managed profile.\n     * Requires {@link android.Manifest.permission#MANAGE_USERS} or\n     * {@link android.Manifest.permission#INTERACT_ACROSS_USERS} or\n     * {@link android.Manifest.permission#QUERY_USERS} permission, otherwise the caller\n     * must be in the same profile group of specified user.\n     *\n     * Note that this applies specifically to <em>managed</em> profiles. For profiles in general,\n     * use {@link #isProfile()} instead.\n     *\n     * @return whether the specified user is a managed profile.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_USERS", "#isProfile()", "android.Manifest.permission#INTERACT_ACROSS_USERS", "android.Manifest.permission#QUERY_USERS" ]
  }, {
    "name" : "public boolean isCloneProfile()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the context user is a clone profile.\n     *\n     * @return whether the context user is a clone profile.\n     *\n     * @see android.os.UserManager#USER_TYPE_PROFILE_CLONE\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isPrivateProfile()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the context user is a private profile.\n     *\n     * <p>A Private profile is a separate {@link #isProfile() profile} that can be used to store\n     * sensitive apps and data, which can be hidden or revealed at the user's discretion.\n     *\n     * @return whether the context user is a private profile.\n     *\n     * @hide\n     ",
    "links" : [ "#isProfile()" ]
  }, {
    "name" : "public boolean isEphemeralUser()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the context user is an ephemeral user.\n     *\n     * @return whether the context user is an ephemeral user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUserEphemeral(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the specified user is ephemeral.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUserRunning(UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether the given user is actively running.  This means that\n     * the user is in the \"started\" state, not \"stopped\" -- it is currently\n     * allowed to run code through scheduled alarms, receiving broadcasts,\n     * etc.  A started user may be either the current foreground user or a\n     * background user; the result here does not distinguish between the two.\n     *\n     * <p>Note prior to Android Nougat MR1 (SDK version <= 24;\n     * {@link android.os.Build.VERSION_CODES#N}, this API required a system permission\n     * in order to check other profile's status.\n     * Since Android Nougat MR1 (SDK version >= 25;\n     * {@link android.os.Build.VERSION_CODES#N_MR1}), the restriction has been relaxed, and now\n     * it'll accept any {@link android.os.UserHandle} within the same profile group as the caller.\n     *\n     * @param user The user to retrieve the running state for.\n     ",
    "links" : [ "android.os.UserHandle", "android.os.Build.VERSION_CODES#N_MR1", "android.os.Build.VERSION_CODES#N" ]
  }, {
    "name" : "public boolean isUserRunning(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUserRunningOrStopping(UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether the given user is actively running <em>or</em> stopping.\n     * This is like {@link #isUserRunning(UserHandle)}, but will also return\n     * true if the user had been running but is in the process of being stopped\n     * (but is not yet fully stopped, and still running some code).\n     *\n     * <p>Note prior to Android Nougat MR1 (SDK version <= 24;\n     * {@link android.os.Build.VERSION_CODES#N}, this API required a system permission\n     * in order to check other profile's status.\n     * Since Android Nougat MR1 (SDK version >= 25;\n     * {@link android.os.Build.VERSION_CODES#N_MR1}), the restriction has been relaxed, and now\n     * it'll accept any {@link android.os.UserHandle} within the same profile group as the caller.\n     *\n     * @param user The user to retrieve the running state for.\n     ",
    "links" : [ "#isUserRunning(UserHandle)", "android.os.UserHandle", "android.os.Build.VERSION_CODES#N_MR1", "android.os.Build.VERSION_CODES#N" ]
  }, {
    "name" : "public boolean isUserForeground()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the context user is running in the foreground.\n     *\n     * @return whether the context user is running in the foreground.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isVisibleBackgroundUsersEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * @see #isVisibleBackgroundUsersSupported()\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isVisibleBackgroundUsersSupported()",
    "returnType" : "boolean",
    "comment" : " TODO(b/310249114): Rename to isVisibleBackgroundFullUsersSupported",
    "links" : [ ]
  }, {
    "name" : "public static boolean isVisibleBackgroundUsersOnDefaultDisplayEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isVisibleBackgroundUsersOnDefaultDisplaySupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the device allows full users to be started in background visible in the\n     * {@link android.view.Display#DEFAULT_DISPLAY default display}.\n     *\n     * @return {@code false} for most devices, except passenger-only automotive build (i.e., when\n     * Android runs in a separate system in the back seat to manage the passenger displays).\n     *\n     * @see #isVisibleBackgroundUsersSupported()\n     * @hide\n     ",
    "links" : [ "android.view.Display#DEFAULT_DISPLAY" ]
  }, {
    "name" : "public boolean isUserVisible()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the user is visible at the moment.\n     *\n     * <p>Roughly speaking, a \"visible user\" is a user that can present UI on at least one display.\n     * It includes:\n     *\n     * <ol>\n     *   <li>The current foreground user.\n     *   <li>(Running) profiles of the current foreground user.\n     *   <li>Background users assigned to secondary displays (for example, passenger users on\n     *   automotive builds, using the display associated with their seats).\n     *   <li>A communal profile, if present.\n     * </ol>\n     *\n     * @return whether the user is visible at the moment, as defined above.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Set<UserHandle> getVisibleUsers()",
    "returnType" : "Set<UserHandle>",
    "comment" : "\n     * Gets the visible users (as defined by {@link #isUserVisible()}.\n     *\n     * @return visible users at the moment.\n     *\n     * @hide\n     ",
    "links" : [ "#isUserVisible()" ]
  }, {
    "name" : "public int getMainDisplayIdAssignedToUser()",
    "returnType" : "int",
    "comment" : "\n     * See {@link com.android.server.pm.UserManagerInternal#getMainDisplayAssignedToUser(int)}.\n     *\n     * @hide\n     ",
    "links" : [ "com.android.server.pm.UserManagerInternal#getMainDisplayAssignedToUser(int)" ]
  }, {
    "name" : "public boolean isUserUnlocked()",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether the context user is running in an \"unlocked\" state.\n     * <p>\n     * On devices with direct boot, a user is unlocked only after they've\n     * entered their credentials (such as a lock pattern or PIN). On devices\n     * without direct boot, a user is unlocked as soon as it starts.\n     * <p>\n     * When a user is locked, only device-protected data storage is available.\n     * When a user is unlocked, both device-protected and credential-protected\n     * private app data storage is available.\n     *\n     * @see Intent#ACTION_USER_UNLOCKED\n     * @see Context#createDeviceProtectedStorageContext()\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUserUnlocked(UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether the given user is running in an \"unlocked\" state.\n     * <p>\n     * On devices with direct boot, a user is unlocked only after they've\n     * entered their credentials (such as a lock pattern or PIN). On devices\n     * without direct boot, a user is unlocked as soon as it starts.\n     * <p>\n     * When a user is locked, only device-protected data storage is available.\n     * When a user is unlocked, both device-protected and credential-protected\n     * private app data storage is available.\n     * <p>Requires {@code android.permission.MANAGE_USERS} or\n     * {@code android.permission.INTERACT_ACROSS_USERS}, otherwise specified {@link UserHandle user}\n     * must be the calling user or a profile associated with it.\n     *\n     * @param user to retrieve the unlocked state for.\n     * @see Intent#ACTION_USER_UNLOCKED\n     * @see Context#createDeviceProtectedStorageContext()\n     ",
    "links" : [ "android.os.UserHandle" ]
  }, {
    "name" : "public boolean isUserUnlocked(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void disableIsUserUnlockedCache()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static final void invalidateIsUserUnlockedCache()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUserUnlockingOrUnlocked(@NonNull UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether the provided user is already running in an\n     * \"unlocked\" state or in the process of unlocking.\n     * <p>\n     * On devices with direct boot, a user is unlocked only after they've\n     * entered their credentials (such as a lock pattern or PIN). On devices\n     * without direct boot, a user is unlocked as soon as it starts.\n     * <p>\n     * When a user is locked, only device-protected data storage is available.\n     * When a user is unlocked, both device-protected and credential-protected\n     * private app data storage is available.\n     *\n     * <p>Requires {@code android.permission.MANAGE_USERS} or\n     * {@code android.permission.INTERACT_ACROSS_USERS}, otherwise specified {@link UserHandle user}\n     * must be the calling user or a profile associated with it.\n     *\n     * @hide\n     ",
    "links" : [ "android.os.UserHandle" ]
  }, {
    "name" : "public boolean isUserUnlockingOrUnlocked(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public long getUserStartRealtime()",
    "returnType" : "long",
    "comment" : "\n     * Return the time when the calling user started in elapsed milliseconds since boot,\n     * or 0 if not started.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getUserUnlockRealtime()",
    "returnType" : "long",
    "comment" : "\n     * Return the time when the context user was unlocked elapsed milliseconds since boot,\n     * or 0 if not unlocked.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public UserInfo getUserInfo(@UserIdInt int userId)",
    "returnType" : "UserInfo",
    "comment" : "\n     * Returns the UserInfo object describing a specific user.\n     * @param userId the user handle of the user whose information is being requested.\n     * @return the UserInfo object for a specific user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public UserProperties getUserProperties(@NonNull UserHandle userHandle)",
    "returnType" : "UserProperties",
    "comment" : "\n     * Returns a {@link UserProperties} object describing the properties of the given user.\n     *\n     * Note that the caller may not have permission to access all items; requesting any item for\n     * which permission is lacking will throw a {@link SecurityException}.\n     *\n     * <p> Requires\n     * {@code android.Manifest.permission#MANAGE_USERS},\n     * {@code android.Manifest.permission#QUERY_USERS}, or\n     * {@code android.Manifest.permission#INTERACT_ACROSS_USERS}\n     * permission, or else the caller must be in the same profile group as the caller.\n     *\n     * @param userHandle the user handle of the user whose information is being requested.\n     * @return a UserProperties object for a specific user.\n     * @throws IllegalArgumentException if {@code userHandle} doesn't correspond to an existing user\n     *\n     * @hide\n     ",
    "links" : [ "android.content.pm.UserProperties", "SecurityException" ]
  }, {
    "name" : "public int getUserRestrictionSource(@UserRestrictionKey String restrictionKey, UserHandle userHandle)",
    "returnType" : "int",
    "comment" : "\n     * @hide\n     *\n     * Returns who set a user restriction on a user.\n     * @param restrictionKey the string key representing the restriction\n     * @param userHandle the UserHandle of the user for whom to retrieve the restrictions.\n     * @return The source of user restriction. Any combination of {@link #RESTRICTION_NOT_SET},\n     *         {@link #RESTRICTION_SOURCE_SYSTEM}, {@link #RESTRICTION_SOURCE_DEVICE_OWNER}\n     *         and {@link #RESTRICTION_SOURCE_PROFILE_OWNER}\n     * @deprecated use {@link #getUserRestrictionSources(String, int)} instead.\n     ",
    "links" : [ "#RESTRICTION_SOURCE_DEVICE_OWNER", "#getUserRestrictionSources(String", "#RESTRICTION_NOT_SET", "#RESTRICTION_SOURCE_SYSTEM", "#RESTRICTION_SOURCE_PROFILE_OWNER" ]
  }, {
    "name" : "public List<EnforcingUser> getUserRestrictionSources(@UserRestrictionKey String restrictionKey, UserHandle userHandle)",
    "returnType" : "List<EnforcingUser>",
    "comment" : "\n     * @hide\n     *\n     * Returns a list of users who set a user restriction on a given user.\n     * @param restrictionKey the string key representing the restriction\n     * @param userHandle the UserHandle of the user for whom to retrieve the restrictions.\n     * @return a list of user ids enforcing this restriction.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Bundle getUserRestrictions()",
    "returnType" : "Bundle",
    "comment" : "\n     * Returns the user-wide restrictions imposed on the context user.\n     * @return a Bundle containing all the restrictions.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Bundle getUserRestrictions(UserHandle userHandle)",
    "returnType" : "Bundle",
    "comment" : "\n     * Returns the user-wide restrictions imposed on the user specified by <code>userHandle</code>.\n     * @param userHandle the UserHandle of the user for whom to retrieve the restrictions.\n     * @return a Bundle containing all the restrictions.\n     *\n     * <p>Requires {@code android.permission.MANAGE_USERS} or\n     * {@code android.permission.INTERACT_ACROSS_USERS}, otherwise specified {@link UserHandle user}\n     * must be the calling user or a profile associated with it.\n     ",
    "links" : [ "android.os.UserHandle" ]
  }, {
    "name" : "public boolean hasBaseUserRestriction(@UserRestrictionKey @NonNull String restrictionKey, @NonNull UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Returns whether the given user has been disallowed from performing certain actions\n     * or setting certain settings through UserManager (e.g. this type of restriction would prevent\n     * the guest user from doing certain things, such as making calls). This method disregards\n     * restrictions set by device policy.\n     * @param restrictionKey the string key representing the restriction\n     * @param userHandle the UserHandle of the user for whom to retrieve the restrictions.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setUserRestrictions(Bundle restrictions)",
    "returnType" : "void",
    "comment" : " System apps should use UserManager.setUserRestriction() instead.",
    "links" : [ ]
  }, {
    "name" : "public void setUserRestrictions(Bundle restrictions, UserHandle userHandle)",
    "returnType" : "void",
    "comment" : " System apps should use UserManager.setUserRestriction() instead.",
    "links" : [ ]
  }, {
    "name" : "public void setUserRestriction(String key, boolean value)",
    "returnType" : "void",
    "comment" : "\n     * Sets the value of a specific restriction on the context user.\n     * Requires the MANAGE_USERS permission.\n     * @param key the key of the restriction\n     * @param value the value for the restriction\n     * @deprecated use {@link android.app.admin.DevicePolicyManager#addUserRestriction(\n     * android.content.ComponentName, String)} or\n     * {@link android.app.admin.DevicePolicyManager#clearUserRestriction(\n     * android.content.ComponentName, String)} instead.\n     ",
    "links" : [ "android.app.admin.DevicePolicyManager#clearUserRestriction(", "android.app.admin.DevicePolicyManager#addUserRestriction(" ]
  }, {
    "name" : "public void setUserRestriction(String key, boolean value, UserHandle userHandle)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Sets the value of a specific restriction on a specific user.\n     * @param key the key of the restriction\n     * @param value the value for the restriction\n     * @param userHandle the user whose restriction is to be changed.\n     * @deprecated use {@link android.app.admin.DevicePolicyManager#addUserRestriction(\n     * android.content.ComponentName, String)} or\n     * {@link android.app.admin.DevicePolicyManager#clearUserRestriction(\n     * android.content.ComponentName, String)} instead.\n     ",
    "links" : [ "android.app.admin.DevicePolicyManager#clearUserRestriction(", "android.app.admin.DevicePolicyManager#addUserRestriction(" ]
  }, {
    "name" : "public boolean hasUserRestriction(@UserRestrictionKey String restrictionKey)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the context user has been disallowed from performing certain actions\n     * or setting certain settings.\n     *\n     * @param restrictionKey The string key representing the restriction.\n     * @return {@code true} if the context user has the given restriction, {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasUserRestriction(@UserRestrictionKey String restrictionKey, UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Returns whether the given user has been disallowed from performing certain actions\n     * or setting certain settings.\n     * @param restrictionKey the string key representing the restriction\n     * @param userHandle the UserHandle of the user for whom to retrieve the restrictions.\n     * @deprecated Use {@link #hasUserRestrictionForUser(String, UserHandle)} instead.\n     ",
    "links" : [ "#hasUserRestrictionForUser(String" ]
  }, {
    "name" : "public boolean hasUserRestrictionForUser(@NonNull @UserRestrictionKey String restrictionKey, @NonNull UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the given user has been disallowed from performing certain actions\n     * or setting certain settings.\n     * @param restrictionKey the string key representing the restriction\n     * @param userHandle the UserHandle of the user for whom to retrieve the restrictions.\n     *\n     * <p>Requires {@code android.permission.MANAGE_USERS} or\n     * {@code android.permission.INTERACT_ACROSS_USERS}, otherwise specified {@link UserHandle user}\n     * must be the calling user or a profile associated with it.\n     *\n     * @hide\n     ",
    "links" : [ "android.os.UserHandle" ]
  }, {
    "name" : "private boolean hasUserRestrictionForUser(@NonNull @UserRestrictionKey String restrictionKey, @UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean hasUserRestrictionOnAnyUser(@UserRestrictionKey String restrictionKey)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Returns whether any user on the device has the given user restriction set.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isSettingRestrictedForUser(String setting, @UserIdInt int userId, String value, int callingUid)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     *\n     * Checks whether changing the given setting to the given value is prohibited\n     * by the corresponding user restriction in the given user.\n     *\n     * May only be called by the OS itself.\n     *\n     * @return {@code true} if the change is prohibited, {@code false} if the change is allowed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addUserRestrictionsListener(final IUserRestrictionsListener listener)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Register a binder callback for user restrictions changes.\n     * May only be called by the OS itself.\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getSerialNumberForUser(UserHandle user)",
    "returnType" : "long",
    "comment" : "\n     * Return the serial number for a user.  This is a device-unique\n     * number assigned to that user; if the user is deleted and then a new\n     * user created, the new users will not be given the same serial number.\n     * @param user The user whose serial number is to be retrieved.\n     * @return The serial number of the given user; returns -1 if the\n     * given UserHandle does not exist.\n     * @see #getUserForSerialNumber(long)\n     ",
    "links" : [ ]
  }, {
    "name" : "public UserHandle getUserForSerialNumber(long serialNumber)",
    "returnType" : "UserHandle",
    "comment" : "\n     * Return the user associated with a serial number previously\n     * returned by {@link #getSerialNumberForUser(UserHandle)}.\n     * @param serialNumber The serial number of the user that is being\n     * retrieved.\n     * @return Return the user associated with the serial number, or null\n     * if there is not one.\n     * @see #getSerialNumberForUser(UserHandle)\n     ",
    "links" : [ "#getSerialNumberForUser(UserHandle)" ]
  }, {
    "name" : "public UserInfo createUser(@Nullable String name, @UserInfoFlag int flags)",
    "returnType" : "UserInfo",
    "comment" : "\n     * Creates a user with the specified name and options.\n     * Default user restrictions will be applied.\n     * Requires {@link android.Manifest.permission#MANAGE_USERS} permission.\n     *\n     * @param name the user's name\n     * @param flags UserInfo flags that identify the type of user and other properties.\n     * @see UserInfo\n     *\n     * @return the UserInfo object for the created user, or null if the user could not be created.\n     * @throws IllegalArgumentException if flags do not correspond to a valid user type.\n     * @deprecated Use {@link #createUser(String, String, int)} instead.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_USERS", "#createUser(String" ]
  }, {
    "name" : "public UserInfo createUser(@Nullable String name, @NonNull String userType, @UserInfoFlag int flags)",
    "returnType" : "UserInfo",
    "comment" : "\n     * Creates a user with the specified name and options.\n     * Default user restrictions will be applied.\n     *\n     * <p>Requires {@link android.Manifest.permission#MANAGE_USERS}.\n     * {@link android.Manifest.permission#CREATE_USERS} suffices if flags are in\n     * com.android.server.pm.UserManagerService#ALLOWED_FLAGS_FOR_CREATE_USERS_PERMISSION.\n     *\n     * @param name     the user's name\n     * @param userType the type of user, such as {@link UserManager#USER_TYPE_FULL_GUEST}.\n     * @param flags    UserInfo flags that specify user properties.\n     * @return the {@link UserInfo} object for the created user, or {@code null} if the user\n     *         could not be created.\n     *\n     * @see UserInfo\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_USERS", "android.Manifest.permission#CREATE_USERS", "android.os.UserManager#USER_TYPE_FULL_GUEST", "android.content.pm.UserInfo" ]
  }, {
    "name" : "public NewUserResponse createUser(@NonNull NewUserRequest newUserRequest)",
    "returnType" : "NewUserResponse",
    "comment" : "\n     * Creates a user with the specified {@link NewUserRequest}.\n     *\n     * @param newUserRequest specify the user information\n     *\n     * @hide\n     ",
    "links" : [ "android.os.NewUserRequest" ]
  }, {
    "name" : "public UserInfo preCreateUser(@NonNull String userType) throws UserOperationException",
    "returnType" : "UserInfo",
    "comment" : "\n     * Pre-creates a user of the specified type. Default user restrictions will be applied.\n     *\n     * <p>This method can be used by OEMs to \"warm\" up the user creation by pre-creating some users\n     * at the first boot, so they when the \"real\" user is created (for example,\n     * by {@link #createUser(String, String, int)} or {@link #createGuest(Context)}), it\n     * takes less time.\n     *\n     * <p>This method completes the majority of work necessary for user creation: it\n     * creates user data, CE and DE encryption keys, app data directories, initializes the user and\n     * grants default permissions. When pre-created users become \"real\" users, only then are\n     * components notified of new user creation by firing user creation broadcasts.\n     *\n     * <p>All pre-created users are removed during system upgrade.\n     *\n     * <p>Requires {@link android.Manifest.permission#MANAGE_USERS}.\n     * {@link android.Manifest.permission#CREATE_USERS} suffices if flags are in\n     * com.android.server.pm.UserManagerService#ALLOWED_FLAGS_FOR_CREATE_USERS_PERMISSION.\n     *\n     *\n     * @param userType the type of user, such as {@link UserManager#USER_TYPE_FULL_GUEST}.\n     * @return the {@link UserInfo} object for the created user.\n     *\n     * @throws UserOperationException if the user could not be created.\n     *\n     * @deprecated Pre-created users are deprecated. This method should no longer be used, and will\n     *             be removed once all the callers are removed.\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_USERS", "#createUser(String", "#createGuest(Context)", "android.Manifest.permission#CREATE_USERS", "android.os.UserManager#USER_TYPE_FULL_GUEST", "android.content.pm.UserInfo" ]
  }, {
    "name" : "public UserInfo createGuest(Context context)",
    "returnType" : "UserInfo",
    "comment" : "\n     * Creates a guest user and configures it.\n     * @param context an application context\n     * @return the {@link UserInfo} object for the created user, or {@code null} if the user\n     *         could not be created.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.pm.UserInfo" ]
  }, {
    "name" : "public UserInfo findCurrentGuestUser()",
    "returnType" : "UserInfo",
    "comment" : "\n     * Gets the existing guest user if it exists.  This does not include guest users that are dying.\n     * @return The existing guest user if it exists. Null otherwise.\n     * @hide\n     *\n     * @deprecated Use {@link #getGuestUsers()}\n     ",
    "links" : [ "#getGuestUsers()" ]
  }, {
    "name" : "public List<UserInfo> getGuestUsers()",
    "returnType" : "List<UserInfo>",
    "comment" : "\n     * Returns the existing guest users.  This does not include guest users that are dying.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public UserHandle createProfile(@NonNull String name, @NonNull String userType, @NonNull Set<String> disallowedPackages) throws UserOperationException",
    "returnType" : "UserHandle",
    "comment" : "\n     * Creates a user with the specified name and options as a profile of the context's user.\n     *\n     * @param name the user's name.\n     * @param userType the type of user, such as {@link UserManager#USER_TYPE_PROFILE_MANAGED}.\n     * @param disallowedPackages packages to not install for this profile.\n     *\n     * @return the {@link android.os.UserHandle} object for the created user,\n     *         or throws {@link UserOperationException} if the user could not be created\n     *         and calling app is targeting {@link android.os.Build.VERSION_CODES#R} or above\n     *         (otherwise returns {@code null}).\n     *\n     * @throws UserOperationException if the user could not be created and the calling app is\n     *         targeting {@link android.os.Build.VERSION_CODES#R} or above.\n     *\n     * @hide\n     ",
    "links" : [ "android.os.UserManager#USER_TYPE_PROFILE_MANAGED", "android.os.Build.VERSION_CODES#R", "android.os.UserHandle", "UserOperationException" ]
  }, {
    "name" : "public UserInfo createProfileForUser(String name, @UserInfoFlag int flags, @UserIdInt int userId)",
    "returnType" : "UserInfo",
    "comment" : "\n     * Creates a user with the specified name and options as a profile of another user.\n     * <p>Requires MANAGE_USERS. CREATE_USERS suffices for ALLOWED_FLAGS_FOR_CREATE_USERS_PERMISSION\n     *\n     * @param name the user's name\n     * @param flags flags that identify the type of user and other properties.\n     * @param userId new user will be a profile of this user.\n     *\n     * @return the {@link UserInfo} object for the created user, or null if the user\n     *         could not be created.\n     * @throws IllegalArgumentException if flags do not correspond to a valid user type.\n     * @deprecated Use {@link #createProfileForUser(String, String, int, int)} instead.\n     * @hide\n     ",
    "links" : [ "android.content.pm.UserInfo", "#createProfileForUser(String" ]
  }, {
    "name" : "public UserInfo createProfileForUser(String name, @NonNull String userType, @UserInfoFlag int flags, @UserIdInt int userId)",
    "returnType" : "UserInfo",
    "comment" : "\n     * Creates a user with the specified name and options as a profile of another user.\n     *\n     * @param name the user's name\n     * @param userType the type of user, such as {@link UserManager#USER_TYPE_PROFILE_MANAGED}.\n     * @param flags UserInfo flags that specify user properties.\n     * @param userId new user will be a profile of this user.\n     *\n     * @return the {@link UserInfo} object for the created user, or null if the user\n     *         could not be created.\n     * @hide\n     ",
    "links" : [ "android.os.UserManager#USER_TYPE_PROFILE_MANAGED", "android.content.pm.UserInfo" ]
  }, {
    "name" : "public UserInfo createProfileForUser(@Nullable String name, @NonNull String userType, @UserInfoFlag int flags, @UserIdInt int userId, @Nullable String[] disallowedPackages)",
    "returnType" : "UserInfo",
    "comment" : "\n     * Version of {@link #createProfileForUser(String, String, int, int)} that allows you to specify\n     * any packages that should not be installed in the new profile by default, these packages can\n     * still be installed later by the user if needed.\n     *\n     * @param name the user's name\n     * @param userType the type of user, such as {@link UserManager#USER_TYPE_PROFILE_MANAGED}.\n     * @param flags UserInfo flags that specify user properties.\n     * @param userId new user will be a profile of this user.\n     * @param disallowedPackages packages that will not be installed in the profile being created.\n     *\n     * @return the {@link UserInfo} object for the created user, or {@code null} if the user could\n     *         not be created.\n     *\n     * @hide\n     ",
    "links" : [ "android.os.UserManager#USER_TYPE_PROFILE_MANAGED", "android.content.pm.UserInfo", "#createProfileForUser(String" ]
  }, {
    "name" : "public UserInfo createProfileForUserEvenWhenDisallowed(String name, @NonNull String userType, @UserInfoFlag int flags, @UserIdInt int userId, String[] disallowedPackages)",
    "returnType" : "UserInfo",
    "comment" : "\n     * Similar to {@link #createProfileForUser(String, String, int, int, String[])}\n     * except bypassing the checking of {@link UserManager#DISALLOW_ADD_MANAGED_PROFILE}.\n     *\n     * @see #createProfileForUser(String, String, int, int, String[])\n     * @hide\n     ",
    "links" : [ "android.os.UserManager#DISALLOW_ADD_MANAGED_PROFILE", "#createProfileForUser(String" ]
  }, {
    "name" : "public UserInfo createRestrictedProfile(@Nullable String name)",
    "returnType" : "UserInfo",
    "comment" : "\n     * Creates a restricted profile with the specified name. This method also sets necessary\n     * restrictions and adds shared accounts (with the context user).\n     *\n     * @param name profile's name\n     * @return the {@link UserInfo} object for the created user, or {@code null} if the user\n     *         could not be created.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.pm.UserInfo" ]
  }, {
    "name" : "public static Intent createUserCreationIntent(@Nullable String userName, @Nullable String accountName, @Nullable String accountType, @Nullable PersistableBundle accountOptions)",
    "returnType" : "Intent",
    "comment" : "\n     * Returns an intent to create a user for the provided name and account name. The name\n     * and account name will be used when the setup process for the new user is started.\n     * <p>\n     * The intent should be launched using startActivityForResult and the return result will\n     * indicate if the user consented to adding a new user and if the operation succeeded. Any\n     * errors in creating the user will be returned in the result code. If the user cancels the\n     * request, the return result will be {@link Activity#RESULT_CANCELED}. On success, the\n     * result code will be {@link Activity#RESULT_OK}.\n     * <p>\n     * Use {@link #supportsMultipleUsers()} to first check if the device supports this operation\n     * at all.\n     * <p>\n     * The new user is created but not initialized. After switching into the user for the first\n     * time, the preferred user name and account information are used by the setup process for that\n     * user.\n     *\n     * This API should only be called if the current user is an {@link #isAdminUser() admin} user,\n     * as otherwise the returned intent will not be able to create a user.\n     *\n     * @param userName Optional name to assign to the user. Character limit is 100.\n     * @param accountName Optional account name that will be used by the setup wizard to initialize\n     *                    the user. Character limit is 500.\n     * @param accountType Optional account type for the account to be created. This is required\n     *                    if the account name is specified. Character limit is 500.\n     * @param accountOptions Optional bundle of data to be passed in during account creation in the\n     *                       new user via {@link AccountManager#addAccount(String, String, String[],\n     *                       Bundle, android.app.Activity, android.accounts.AccountManagerCallback,\n     *                       Handler)}. Character limit is 1000.\n     * @return An Intent that can be launched from an Activity.\n     * @see #USER_CREATION_FAILED_NOT_PERMITTED\n     * @see #USER_CREATION_FAILED_NO_MORE_USERS\n     * @see #supportsMultipleUsers\n     ",
    "links" : [ "android.app.Activity#RESULT_CANCELED", "android.app.Activity#RESULT_OK", "#supportsMultipleUsers()", "android.accounts.AccountManager#addAccount(String", "#isAdminUser()" ]
  }, {
    "name" : "public Set<String> getPreInstallableSystemPackages(@NonNull String userType)",
    "returnType" : "Set<String>",
    "comment" : "\n     * Returns the list of the system packages that would be installed on this type of user upon\n     * its creation.\n     *\n     * Returns {@code null} if all system packages would be installed.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getSeedAccountName()",
    "returnType" : "String",
    "comment" : "\n     * @hide\n     *\n     * Returns the preferred account name for the context user's creation.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getSeedAccountType()",
    "returnType" : "String",
    "comment" : "\n     * @hide\n     *\n     * Returns the preferred account type for the context user's creation.\n     ",
    "links" : [ ]
  }, {
    "name" : "public PersistableBundle getSeedAccountOptions()",
    "returnType" : "PersistableBundle",
    "comment" : "\n     * @hide\n     *\n     * Returns the preferred account's options bundle for user creation.\n     * @return Any options set by the requestor that created the context user.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSeedAccountData(int userId, String accountName, String accountType, PersistableBundle accountOptions)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     *\n     * Called by a system activity to set the seed account information of a user created\n     * through the user creation intent.\n     * @param userId\n     * @param accountName\n     * @param accountType\n     * @param accountOptions\n     * @see #createUserCreationIntent(String, String, String, PersistableBundle)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void clearSeedAccountData()",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Clears the seed information used to create the context user.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean markGuestForDeletion(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     * Marks the guest user for deletion to allow a new guest to be created before deleting\n     * the current user who is a guest.\n     * @param userId\n     * @return\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setUserEnabled(@UserIdInt int userId)",
    "returnType" : "void",
    "comment" : "\n     * Sets the user as enabled, if such an user exists.\n     *\n     * <p>Note that the default is true, it's only that managed profiles might not be enabled.\n     * (Managed profiles created by DevicePolicyManager will start out disabled, and DPM will later\n     * toggle them to enabled once they are provisioned. This is the primary purpose of the\n     * {@link UserInfo#FLAG_DISABLED} flag.)\n     * Also ephemeral users can be disabled to indicate that their removal is in progress and they\n     * shouldn't be re-entered. Therefore ephemeral users should not be re-enabled once disabled.\n     *\n     * @param userId the id of the profile to enable\n     * @hide\n     ",
    "links" : [ "android.content.pm.UserInfo#FLAG_DISABLED" ]
  }, {
    "name" : "public void setUserAdmin(@UserIdInt int userId)",
    "returnType" : "void",
    "comment" : "\n     * Assigns admin privileges to the user, if such a user exists.\n     *\n     * <p>Note that this does not alter the user's pre-existing user restrictions.\n     *\n     * @param userId the id of the user to become admin\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void revokeUserAdmin(@UserIdInt int userId)",
    "returnType" : "void",
    "comment" : "\n     * Revokes admin privileges from the user, if such a user exists.\n     *\n     * <p>Note that this does not alter the user's pre-existing user restrictions.\n     *\n     * @param userId the id of the user to revoke admin rights from\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void evictCredentialEncryptionKey(@UserIdInt int userId)",
    "returnType" : "void",
    "comment" : "\n     * Evicts the user's credential encryption key from memory by stopping and restarting the user.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getUserCount()",
    "returnType" : "int",
    "comment" : "\n     * Return the number of users currently created on the device.\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<UserInfo> getUsers()",
    "returnType" : "List<UserInfo>",
    "comment" : "\n     * Returns information for all fully-created users on this device, including ones marked for\n     * deletion.\n     *\n     * <p>To retrieve only users that are not marked for deletion, use {@link #getAliveUsers()}.\n     *\n     * <p>To retrieve *all* users (including partial and pre-created users), use\n     * {@link #getUsers(boolean, boolean, boolean)) getUsers(false, false, false)}.\n     *\n     * <p>To retrieve a more specific list of users, use\n     * {@link #getUsers(boolean, boolean, boolean)}.\n     *\n     * @return the list of users that were created.\n     *\n     * @hide\n     ",
    "links" : [ "#getUsers(boolean", "#getAliveUsers()" ]
  }, {
    "name" : "public List<UserInfo> getAliveUsers()",
    "returnType" : "List<UserInfo>",
    "comment" : "\n     * Returns information for all \"usable\" users on this device (i.e, it excludes users that are\n     * marked for deletion, pre-created users, etc...).\n     *\n     * <p>To retrieve all fully-created users, use {@link #getUsers()}.\n     *\n     * <p>To retrieve a more specific list of users, use\n     * {@link #getUsers(boolean, boolean, boolean)}.\n     *\n     * @return the list of users that were created.\n     * @hide\n     ",
    "links" : [ "#getUsers()", "#getUsers(boolean" ]
  }, {
    "name" : "public List<UserInfo> getUsers(boolean excludeDying)",
    "returnType" : "List<UserInfo>",
    "comment" : "\n     * @deprecated use {@link #getAliveUsers()} for {@code getUsers(true)}, or\n     * {@link #getUsers()} for @code getUsers(false)}.\n     *\n     * @hide\n     ",
    "links" : [ "#getUsers()", "#getAliveUsers()" ]
  }, {
    "name" : "public List<UserInfo> getUsers(boolean excludePartial, boolean excludeDying, boolean excludePreCreated)",
    "returnType" : "List<UserInfo>",
    "comment" : "\n     * Returns information for all users on this device, based on the filtering parameters.\n     *\n     * @deprecated Pre-created users are deprecated and no longer supported.\n     *             Use {@link #getUsers()}, or {@link #getAliveUsers()} instead.\n     * @hide\n     ",
    "links" : [ "#getUsers()", "#getAliveUsers()" ]
  }, {
    "name" : "public List<UserHandle> getUserHandles(boolean excludeDying)",
    "returnType" : "List<UserHandle>",
    "comment" : "\n     * Returns the user handles for all users on this device, based on the filtering parameters.\n     *\n     * @param excludeDying specify if the list should exclude users being removed.\n     * @return the list of user handles.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public long[] getSerialNumbersOfUsers(boolean excludeDying)",
    "returnType" : "long[]",
    "comment" : "\n     * Returns serial numbers of all users on this device.\n     *\n     * @param excludeDying specify if the list should exclude users being removed.\n     * @return the list of serial numbers of users that exist on the device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getUserAccount(@UserIdInt int userId)",
    "returnType" : "String",
    "comment" : "\n     * @return the user's account name, null if not found.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setUserAccount(@UserIdInt int userId, @Nullable String accountName)",
    "returnType" : "void",
    "comment" : "\n     * Set account name for the given user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public UserInfo getPrimaryUser()",
    "returnType" : "UserInfo",
    "comment" : "\n     * Returns information for Primary user (which in practice is the same as the System user).\n     *\n     * @return the Primary user, null if not found.\n     * @deprecated For the system user, call {@link #getUserInfo} on {@link UserHandle#USER_SYSTEM},\n     *             or just use {@link UserHandle#SYSTEM} or {@link UserHandle#USER_SYSTEM}.\n     *             For the designated MainUser, use {@link #getMainUser()}.\n     *\n     * @hide\n     ",
    "links" : [ "#getUserInfo", "android.os.UserHandle#USER_SYSTEM", "#getMainUser()", "android.os.UserHandle#SYSTEM" ]
  }, {
    "name" : "public UserHandle getPreviousForegroundUser()",
    "returnType" : "UserHandle",
    "comment" : "\n     * Returns the user who was last in the foreground, not including the current user and not\n     * including profiles.\n     *\n     * <p>Returns {@code null} if there is no previous user, for example if there\n     * is only one full user (i.e. only one user which is not a profile) on the device.\n     *\n     * <p>This method may be used for example to find the user to switch back to if the\n     * current user is removed, or if creating a new user is aborted.\n     *\n     * <p>Note that reboots do not interrupt this calculation; the previous user need not have\n     * used the device since it rebooted.\n     *\n     * <p>Note also that on devices that support multiple users on multiple displays, it is possible\n     * that the returned user will be visible on a secondary display, as the foreground user is the\n     * one associated with the main display.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean canAddMoreUsers()",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether it's possible to add more users.\n     *\n     * @return true if more users can be added, false if limit has been reached.\n     *\n     * @deprecated use {@link #canAddMoreUsers(String)} instead.\n     *\n     * @hide\n     ",
    "links" : [ "#canAddMoreUsers(String)" ]
  }, {
    "name" : "public boolean canAddMoreUsers(@NonNull String userType)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether it is possible to add more users of the given user type.\n     *\n     * @param userType the type of user, such as {@link UserManager#USER_TYPE_FULL_SECONDARY}.\n     * @return true if more users of the given type can be added, otherwise false.\n     * @hide\n     ",
    "links" : [ "android.os.UserManager#USER_TYPE_FULL_SECONDARY" ]
  }, {
    "name" : "public int getRemainingCreatableUserCount(@NonNull String userType)",
    "returnType" : "int",
    "comment" : "\n     * Returns the remaining number of users of the given type that can be created.\n     *\n     * @param userType the type of user, such as {@link UserManager#USER_TYPE_FULL_SECONDARY}.\n     * @return how many additional users can be created.\n     * @hide\n     ",
    "links" : [ "android.os.UserManager#USER_TYPE_FULL_SECONDARY" ]
  }, {
    "name" : "public int getRemainingCreatableProfileCount(@NonNull String userType)",
    "returnType" : "int",
    "comment" : "\n     * Returns the remaining number of profiles that can be added to the context user.\n     * <p>Note that is applicable to any profile type (currently not including Restricted profiles).\n     *\n     * @param userType the type of profile, such as {@link UserManager#USER_TYPE_PROFILE_MANAGED}.\n     * @return how many additional profiles can be created.\n     * @hide\n     ",
    "links" : [ "android.os.UserManager#USER_TYPE_PROFILE_MANAGED" ]
  }, {
    "name" : "public boolean canAddMoreManagedProfiles(@UserIdInt int userId, boolean allowedToRemoveOne)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether it's possible to add more managed profiles.\n     * if allowedToRemoveOne is true and if the user already has a managed profile, then return if\n     * we could add a new managed profile to this user after removing the existing one.\n     *\n     * @return true if more managed profiles can be added, false if limit has been reached.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean canAddMoreProfilesToUser(@NonNull String userType, @UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether it's possible to add more profiles of the given type to the given user.\n     *\n     * @param userType the type of user, such as {@link UserManager#USER_TYPE_PROFILE_MANAGED}.\n     * @return true if more profiles can be added, false if limit has been reached.\n     * @hide\n     ",
    "links" : [ "android.os.UserManager#USER_TYPE_PROFILE_MANAGED" ]
  }, {
    "name" : "public boolean isUserTypeEnabled(@NonNull String userType)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether this device supports users of the given user type.\n     *\n     * @param userType the type of user, such as {@link UserManager#USER_TYPE_FULL_SECONDARY}.\n     * @return true if the creation of users of the given user type is enabled on this device.\n     * @hide\n     ",
    "links" : [ "android.os.UserManager#USER_TYPE_FULL_SECONDARY" ]
  }, {
    "name" : "public List<UserInfo> getProfiles(@UserIdInt int userId)",
    "returnType" : "List<UserInfo>",
    "comment" : "\n     * Returns list of the profiles of userId including userId itself.\n     * Note that this returns both enabled and not enabled profiles. See\n     * {@link #getEnabledProfiles(int)} if you need only the enabled ones.\n     * <p>Note that this includes all profile types (not including Restricted profiles).\n     *\n     * <p>Requires {@link android.Manifest.permission#MANAGE_USERS} or\n     * {@link android.Manifest.permission#CREATE_USERS} or\n     * {@link android.Manifest.permission#QUERY_USERS} if userId is not the calling user.\n     * @param userId profiles of this user will be returned.\n     * @return the list of profiles.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_USERS", "#getEnabledProfiles(int)", "android.Manifest.permission#CREATE_USERS", "android.Manifest.permission#QUERY_USERS" ]
  }, {
    "name" : "public List<UserInfo> getProfilesIncludingCommunal(@UserIdInt int userId)",
    "returnType" : "List<UserInfo>",
    "comment" : "\n     * Returns list of the profiles of the given user, including userId itself, as well as the\n     * communal profile, if there is one.\n     *\n     * <p>Note that this returns both enabled and not enabled profiles.\n     * <p>Note that this includes all profile types (not including Restricted profiles).\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isSameProfileGroup(@NonNull UserHandle user, @NonNull UserHandle otherUser)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the 2 provided user handles belong to the same profile group.\n     *\n     * @param user one of the two user handles to check.\n     * @param otherUser one of the two user handles to check.\n     * @return true if the two users are in the same profile group.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isSameProfileGroup(@UserIdInt int userId, int otherUserId)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the 2 provided user ids belong to the same profile group.\n     * @param userId one of the two user ids to check.\n     * @param otherUserId one of the two user ids to check.\n     * @return true if the two user ids are in the same profile group.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<UserInfo> getEnabledProfiles(@UserIdInt int userId)",
    "returnType" : "List<UserInfo>",
    "comment" : "\n     * Returns list of the profiles of userId including userId itself.\n     * Note that this returns only {@link UserInfo#isEnabled() enabled} profiles.\n     * <p>Note that this includes all profile types (not including Restricted profiles).\n     *\n     * <p>Requires {@link android.Manifest.permission#MANAGE_USERS} or\n     * {@link android.Manifest.permission#CREATE_USERS} or\n     * {@link android.Manifest.permission#QUERY_USERS} if userId is not the calling user.\n     * @param userId profiles of this user will be returned.\n     * @return the list of profiles.\n     * @deprecated use {@link #getUserProfiles()} instead.\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_USERS", "#getUserProfiles()", "android.Manifest.permission#CREATE_USERS", "android.content.pm.UserInfo#isEnabled()", "android.Manifest.permission#QUERY_USERS" ]
  }, {
    "name" : "public List<UserHandle> getUserProfiles()",
    "returnType" : "List<UserHandle>",
    "comment" : "\n     * Returns a list of UserHandles for profiles associated with the context user, including the\n     * user itself.\n     * <p>Note that this includes all profile types (not including Restricted profiles).\n     *\n     * @return A non-empty list of UserHandles associated with the context user.\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<UserHandle> getEnabledProfiles()",
    "returnType" : "List<UserHandle>",
    "comment" : "\n     * Returns a list of ids for enabled profiles associated with the context user including the\n     * user itself.\n     * <p>Note that this includes all profile types (not including Restricted profiles).\n     *\n     * @return A non-empty list of UserHandles associated with the context user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<UserHandle> getAllProfiles()",
    "returnType" : "List<UserHandle>",
    "comment" : "\n     * Returns a list of ids for all profiles associated with the context user including the user\n     * itself.\n     * <p>Note that this includes all profile types (not including Restricted profiles).\n     *\n     * @return A non-empty list of UserHandles associated with the context user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private List<UserHandle> getProfiles(boolean enabledOnly)",
    "returnType" : "List<UserHandle>",
    "comment" : "\n     * Returns a list of ids for profiles associated with the context user including the user\n     * itself.\n     * <p>Note that this includes all profile types (not including Restricted profiles).\n     *\n     * @param enabledOnly whether to return only {@link UserInfo#isEnabled() enabled} profiles\n     * @return A non-empty list of UserHandles associated with the context user.\n     ",
    "links" : [ "android.content.pm.UserInfo#isEnabled()" ]
  }, {
    "name" : "private List<UserHandle> convertUserIdsToUserHandles(@NonNull int[] userIds)",
    "returnType" : "List<UserHandle>",
    "comment" : " Converts the given array of userIds to a List of UserHandles. ",
    "links" : [ ]
  }, {
    "name" : "public int[] getProfileIds(@UserIdInt int userId, boolean enabledOnly)",
    "returnType" : "int[]",
    "comment" : "\n     * Returns a list of ids for profiles associated with the specified user including the user\n     * itself.\n     * <p>Note that this includes all profile types (not including Restricted profiles).\n     *\n     * @param userId      id of the user to return profiles for\n     * @param enabledOnly whether return only {@link UserInfo#isEnabled() enabled} profiles\n     * @return A non-empty list of ids of profiles associated with the specified user.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.pm.UserInfo#isEnabled()" ]
  }, {
    "name" : "public int[] getProfileIdsWithDisabled(@UserIdInt int userId)",
    "returnType" : "int[]",
    "comment" : "\n     * @see #getProfileIds(int, boolean)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int[] getEnabledProfileIds(@UserIdInt int userId)",
    "returnType" : "int[]",
    "comment" : "\n     * @see #getProfileIds(int, boolean)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int[] getProfileIdsExcludingHidden(@UserIdInt int userId, boolean enabled)",
    "returnType" : "int[]",
    "comment" : "\n     * @return A list of ids of profiles associated with the specified user excluding those with\n     * {@link UserProperties#getProfileApiVisibility()} set to hidden. The returned list includes\n     * the user itself.\n     * @hide\n     * @see #getProfileIds(int, boolean)\n     ",
    "links" : [ "android.content.pm.UserProperties#getProfileApiVisibility()" ]
  }, {
    "name" : "public int getCredentialOwnerProfile(@UserIdInt int userId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the device credential owner id of the profile from\n     * which this method is called, or userId if called from a user that\n     * is not a profile.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public UserInfo getProfileParent(@UserIdInt int userId)",
    "returnType" : "UserInfo",
    "comment" : "\n     * Returns the parent of the profile which this method is called from\n     * or null if it has no parent (e.g. if it is not a profile).\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public UserHandle getProfileParent(@NonNull UserHandle user)",
    "returnType" : "UserHandle",
    "comment" : "\n     * Get the parent of a user profile.\n     *\n     * @param user the handle of the user profile\n     *\n     * @return the parent of the user or {@code null} if the user has no parent\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean requestQuietModeEnabled(boolean enableQuietMode, @NonNull UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Enables or disables quiet mode for a managed profile. If quiet mode is enabled, apps in a\n     * managed profile don't run, generate notifications, or consume data or battery.\n     * <p>\n     * If a user's credential is needed to turn off quiet mode, a confirm credential screen will be\n     * shown to the user.\n     * <p>\n     * The change may not happen instantly, however apps can listen for\n     * {@link Intent#ACTION_MANAGED_PROFILE_AVAILABLE} and\n     * {@link Intent#ACTION_MANAGED_PROFILE_UNAVAILABLE} broadcasts in order to be notified of\n     * the change of the quiet mode. Apps can also check the current state of quiet mode by\n     * calling {@link #isQuietModeEnabled(UserHandle)}.\n     * <p>\n     * The caller must either be the foreground default launcher or have one of these permissions:\n     * {@code MANAGE_USERS} or {@code MODIFY_QUIET_MODE}.\n     *\n     * @param enableQuietMode whether quiet mode should be enabled or disabled\n     * @param userHandle user handle of the profile\n     * @return {@code false} if user's credential is needed in order to turn off quiet mode,\n     *         {@code true} otherwise\n     * @throws SecurityException if the caller is invalid\n     * @throws IllegalArgumentException if {@code userHandle} is not a managed profile\n     *\n     * @see #isQuietModeEnabled(UserHandle)\n     ",
    "links" : [ "android.content.Intent#ACTION_MANAGED_PROFILE_UNAVAILABLE", "android.content.Intent#ACTION_MANAGED_PROFILE_AVAILABLE", "#isQuietModeEnabled(UserHandle)" ]
  }, {
    "name" : "public boolean requestQuietModeEnabled(boolean enableQuietMode, @NonNull UserHandle userHandle, @QuietModeFlag int flags)",
    "returnType" : "boolean",
    "comment" : "\n     * Perform the same operation as {@link #requestQuietModeEnabled(boolean, UserHandle)}, but\n     * with a flag to tweak the behavior of the request.\n     *\n     * @param enableQuietMode whether quiet mode should be enabled or disabled\n     * @param userHandle user handle of the profile\n     * @param flags Can be 0 or {@link #QUIET_MODE_DISABLE_ONLY_IF_CREDENTIAL_NOT_REQUIRED}.\n     * @return {@code false} if user's credential is needed in order to turn off quiet mode,\n     *         {@code true} otherwise\n     * @throws SecurityException if the caller is invalid\n     * @throws IllegalArgumentException if {@code userHandle} is not a managed profile\n     *\n     * @see #isQuietModeEnabled(UserHandle)\n     ",
    "links" : [ "#requestQuietModeEnabled(boolean", "#QUIET_MODE_DISABLE_ONLY_IF_CREDENTIAL_NOT_REQUIRED" ]
  }, {
    "name" : "public boolean requestQuietModeEnabled(boolean enableQuietMode, @NonNull UserHandle userHandle, IntentSender target)",
    "returnType" : "boolean",
    "comment" : "\n     * Similar to {@link #requestQuietModeEnabled(boolean, UserHandle)}, except you can specify\n     * a target to start when user is unlocked. If {@code target} is specified, caller must have\n     * the {@link android.Manifest.permission#MANAGE_USERS} permission.\n     *\n     * @see {@link #requestQuietModeEnabled(boolean, UserHandle)}\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_USERS", "#requestQuietModeEnabled(boolean" ]
  }, {
    "name" : "public boolean requestQuietModeEnabled(boolean enableQuietMode, @NonNull UserHandle userHandle, IntentSender target, int flags)",
    "returnType" : "boolean",
    "comment" : "\n     * Similar to {@link #requestQuietModeEnabled(boolean, UserHandle)}, except you can specify\n     * a target to start when user is unlocked. If {@code target} is specified, caller must have\n     * the {@link android.Manifest.permission#MANAGE_USERS} permission.\n     *\n     * @see #requestQuietModeEnabled(boolean, UserHandle)\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_USERS", "#requestQuietModeEnabled(boolean" ]
  }, {
    "name" : "public boolean isQuietModeEnabled(UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the given profile is in quiet mode or not.\n     * Notes: Quiet mode is only supported for managed profiles.\n     *\n     * @param userHandle The user handle of the profile to be queried.\n     * @return true if the profile is in quiet mode, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasBadge(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the given user has a badge (generally to put on profiles' icons).\n     *\n     * @param userId userId of the user in question\n     * @return true if the user's icons should display a badge; false otherwise.\n     *\n     * @see #getBadgedIconForUser more information about badging in general\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasBadge()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the user associated with the context has a badge (generally to put on\n     * profiles' icons).\n     *\n     * @return true if the user's icons should display a badge; false otherwise.\n     * @see #getBadgedIconForUser more information about badging in general\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getUserBadgeColor(@UserIdInt int userId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the light theme badge color for the given user (generally to color a profile's\n     * icon's badge).\n     *\n     * <p>To check whether a badge color is expected for the user, first call {@link #hasBadge}.\n     *\n     * @return the color (not the resource ID) to be used for the user's badge\n     * @throws Resources.NotFoundException if no valid badge color exists for this user\n     *\n     * @see #getBadgedIconForUser more information about badging in general\n     * @hide\n     ",
    "links" : [ "#hasBadge" ]
  }, {
    "name" : "public int getUserBadgeDarkColor(@UserIdInt int userId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the dark theme badge color for the given user (generally to color a profile's icon's\n     * badge).\n     *\n     * <p>To check whether a badge color is expected for the user, first call {@link #hasBadge}.\n     *\n     * @return the color (not the resource ID) to be used for the user's badge\n     * @throws Resources.NotFoundException if no valid badge color exists for this user\n     *\n     * @see #getBadgedIconForUser more information about badging in general\n     * @hide\n     ",
    "links" : [ "#hasBadge" ]
  }, {
    "name" : "public int getUserIconBadgeResId(@UserIdInt int userId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the Resource ID of the user's icon badge.\n     *\n     * @return the Resource ID of the user's icon badge if it has one; otherwise\n     *         {@link Resources#ID_NULL}.\n     *\n     * @see #getBadgedIconForUser more information about badging in general\n     * @hide\n     ",
    "links" : [ "android.content.res.Resources#ID_NULL" ]
  }, {
    "name" : "public int getUserBadgeResId(@UserIdInt int userId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the Resource ID of the user's badge.\n     *\n     * @return the Resource ID of the user's badge if it has one; otherwise\n     *         {@link Resources#ID_NULL}.\n     *\n     * @see #getBadgedIconForUser more information about badging in general\n     * @hide\n     ",
    "links" : [ "android.content.res.Resources#ID_NULL" ]
  }, {
    "name" : "public int getUserBadgeNoBackgroundResId(@UserIdInt int userId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the Resource ID of the user's badge without a background.\n     *\n     * @return the Resource ID of the user's no-background badge if it has one; otherwise\n     *         {@link Resources#ID_NULL}.\n     *\n     * @see #getBadgedIconForUser more information about badging in general\n     * @hide\n     ",
    "links" : [ "android.content.res.Resources#ID_NULL" ]
  }, {
    "name" : "public int getUserStatusBarIconResId(@UserIdInt int userId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the Resource ID of the user's status bar icon.\n     *\n     * @return the Resource ID of the user's status bar icon if it has one; otherwise\n     *         {@link Resources#ID_NULL}.\n     * @hide\n     ",
    "links" : [ "android.content.res.Resources#ID_NULL" ]
  }, {
    "name" : "public Drawable getBadgedIconForUser(Drawable icon, UserHandle user)",
    "returnType" : "Drawable",
    "comment" : "\n     * If the target user is a profile of the calling user or the caller\n     * is itself a profile, then this returns a badged copy of the given\n     * icon to be able to distinguish it from the original icon. For badging an\n     * arbitrary drawable use {@link #getBadgedDrawableForUser(\n     * android.graphics.drawable.Drawable, UserHandle, android.graphics.Rect, int)}.\n     * <p>\n     * If the original drawable is a BitmapDrawable and the backing bitmap is\n     * mutable as per {@link android.graphics.Bitmap#isMutable()}, the badging\n     * is performed in place and the original drawable is returned.\n     * </p>\n     *\n     * @param icon The icon to badge.\n     * @param user The target user.\n     * @return A drawable that combines the original icon and a badge as\n     *         determined by the system.\n     * @removed\n     ",
    "links" : [ "android.graphics.Bitmap#isMutable()", "#getBadgedDrawableForUser(" ]
  }, {
    "name" : "public Drawable getBadgedDrawableForUser(Drawable badgedDrawable, UserHandle user, Rect badgeLocation, int badgeDensity)",
    "returnType" : "Drawable",
    "comment" : "\n     * If the target user is a profile of the calling user or the caller\n     * is itself a profile, then this returns a badged copy of the given\n     * drawable allowing the user to distinguish it from the original drawable.\n     * The caller can specify the location in the bounds of the drawable to be\n     * badged where the badge should be applied as well as the density of the\n     * badge to be used.\n     * <p>\n     * If the original drawable is a BitmapDrawable and the backing bitmap is\n     * mutable as per {@link android.graphics.Bitmap#isMutable()}, the badging\n     * is performed in place and the original drawable is returned.\n     * </p>\n     *\n     * @param badgedDrawable The drawable to badge.\n     * @param user The target user.\n     * @param badgeLocation Where in the bounds of the badged drawable to place\n     *         the badge. If it's {@code null}, the badge is applied on top of the entire\n     *         drawable being badged.\n     * @param badgeDensity The optional desired density for the badge as per\n     *         {@link android.util.DisplayMetrics#densityDpi}. If it's not positive,\n     *         the density of the display is used.\n     * @return A drawable that combines the original drawable and a badge as\n     *         determined by the system.\n     * @removed\n     ",
    "links" : [ "android.util.DisplayMetrics#densityDpi", "android.graphics.Bitmap#isMutable()" ]
  }, {
    "name" : "public Drawable getUserBadge()",
    "returnType" : "Drawable",
    "comment" : "\n     * Retrieves a user badge associated with the current context user. This is only\n     * applicable to profile users since non-profile users do not have badges.\n     *\n     * @return A {@link Drawable} user badge corresponding to the context user\n     * @throws android.content.res.Resources.NotFoundException if the user is not a profile or\n     * does not have a badge defined.\n     * @hide\n     ",
    "links" : [ "android.graphics.drawable.Drawable" ]
  }, {
    "name" : "private Drawable getDefaultUserBadge(@UserIdInt int userId)",
    "returnType" : "Drawable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public CharSequence getBadgedLabelForUser(CharSequence label, UserHandle user)",
    "returnType" : "CharSequence",
    "comment" : "\n     * If the target user is a profile of the calling user or the caller\n     * is itself a profile, then this returns a copy of the label with\n     * badging for accessibility services like talkback. E.g. passing in \"Email\"\n     * and it might return \"Work Email\" for Email in the work profile.\n     *\n     * <p>Requires {@link android.Manifest.permission#MANAGE_USERS} or\n     * {@link android.Manifest.permission#INTERACT_ACROSS_USERS} permission, otherwise the caller\n     * must be in the same profile group of specified user.\n     *\n     * @param label The label to change.\n     * @param user The target user.\n     * @return A label that combines the original label and a badge as\n     *         determined by the system.\n     * @removed\n     ",
    "links" : [ "android.Manifest.permission#MANAGE_USERS", "android.Manifest.permission#INTERACT_ACROSS_USERS" ]
  }, {
    "name" : "private String getUpdatableUserBadgedLabelId(int userId)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private String getDefaultUserBadgedLabel(CharSequence label, int userId)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public String getProfileLabel()",
    "returnType" : "String",
    "comment" : "\n     * Returns the string/label that should be used to represent the context user. For example,\n     * this string can represent a profile in tabbed views. This is only applicable to\n     * {@link #isProfile() profile users}. This string is translated to the device default language.\n     *\n     * @return String representing the label for the context user.\n     *\n     * @throws android.content.res.Resources.NotFoundException if the user does not have a label\n     * defined.\n     *\n     * @hide\n     ",
    "links" : [ "#isProfile()" ]
  }, {
    "name" : "private String getDefaultProfileLabel(int userId)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public String getProfileAccessibilityString(int userId)",
    "returnType" : "String",
    "comment" : "\n     * Returns the string used to represent the profile associated with the given userId. This\n     * string typically includes the profile name used by accessibility services like TalkBack.\n     * @hide\n     *\n     * @return String representing the accessibility label for the given profile user.\n     *\n     * @throws android.content.res.Resources.NotFoundException if the user does not have a label\n     * defined.\n     ",
    "links" : [ ]
  }, {
    "name" : "private String getProfileAccessibilityLabel(int userId)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isMediaSharedWithParent()",
    "returnType" : "boolean",
    "comment" : "\n     * If the user is a {@link UserManager#isProfile profile}, checks if the user\n     * shares media with its parent user (the user that created this profile).\n     * Returns false for any other type of user.\n     *\n     * @return true if the user shares media with its parent user, false otherwise.\n     *\n     * @deprecated use {@link #getUserProperties(UserHandle)} with\n     *            {@link UserProperties#isMediaSharedWithParent()} instead.\n     * @hide\n     ",
    "links" : [ "android.os.UserManager#isProfile", "#getUserProperties(UserHandle)", "android.content.pm.UserProperties#isMediaSharedWithParent()" ]
  }, {
    "name" : "public boolean isCredentialSharableWithParent()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the user can have shared lockscreen credential with its parent user.\n     *\n     * This API only works for {@link UserManager#isProfile() profiles}\n     * and will always return false for any other user type.\n     *\n     * @deprecated use {@link #getUserProperties(UserHandle)} with\n     *            {@link UserProperties#isCredentialShareableWithParent()} instead.\n     * @hide\n     ",
    "links" : [ "android.os.UserManager#isProfile()", "android.content.pm.UserProperties#isCredentialShareableWithParent()", "#getUserProperties(UserHandle)" ]
  }, {
    "name" : "public boolean removeUser(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Removes a user and its profiles along with their associated data.\n     * @param userId the integer handle of the user.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean removeUser(@NonNull UserHandle user)",
    "returnType" : "boolean",
    "comment" : "\n     * Removes a user and its profiles along with their associated data.\n     *\n     * @param user the user that needs to be removed.\n     * @return {@code true} if the user was successfully removed, {@code false} otherwise.\n     * @throws IllegalArgumentException if {@code user} is {@code null}\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean removeUserEvenWhenDisallowed(@UserIdInt int userId)",
    "returnType" : "boolean",
    "comment" : "\n     * Similar to {@link #removeUser(int)} except bypassing the checking of\n     * {@link UserManager#DISALLOW_REMOVE_USER}\n     * or {@link UserManager#DISALLOW_REMOVE_MANAGED_PROFILE}.\n     *\n     * @see {@link #removeUser(int)}\n     * @hide\n     ",
    "links" : [ "#removeUser(int)", "android.os.UserManager#DISALLOW_REMOVE_USER", "android.os.UserManager#DISALLOW_REMOVE_MANAGED_PROFILE" ]
  }, {
    "name" : "public int removeUserWhenPossible(@NonNull UserHandle user, boolean overrideDevicePolicy)",
    "returnType" : "int",
    "comment" : "\n     * Immediately removes the user and its profiles or, if the user cannot be removed, such as\n     * when the user is the current user, then set the user as ephemeral\n     * so that it will be removed when it is stopped.\n     *\n     * @param overrideDevicePolicy when {@code true}, user is removed even if the caller has\n     * the {@link #DISALLOW_REMOVE_USER} or {@link #DISALLOW_REMOVE_MANAGED_PROFILE} restriction\n     *\n     * @return the {@link RemoveResult} code: {@link #REMOVE_RESULT_REMOVED},\n     * {@link #REMOVE_RESULT_DEFERRED}, {@link #REMOVE_RESULT_ALREADY_BEING_REMOVED},\n     * {@link #REMOVE_RESULT_ERROR_USER_RESTRICTION}, {@link #REMOVE_RESULT_ERROR_USER_NOT_FOUND},\n     * {@link #REMOVE_RESULT_ERROR_SYSTEM_USER},\n     * {@link #REMOVE_RESULT_ERROR_MAIN_USER_PERMANENT_ADMIN}, or\n     * {@link #REMOVE_RESULT_ERROR_UNKNOWN}. All error codes have negative values.\n     *\n     * @hide\n     ",
    "links" : [ "#REMOVE_RESULT_ALREADY_BEING_REMOVED", "#REMOVE_RESULT_ERROR_UNKNOWN", "RemoveResult", "#DISALLOW_REMOVE_MANAGED_PROFILE", "#REMOVE_RESULT_REMOVED", "#REMOVE_RESULT_DEFERRED", "#REMOVE_RESULT_ERROR_MAIN_USER_PERMANENT_ADMIN", "#DISALLOW_REMOVE_USER", "#REMOVE_RESULT_ERROR_USER_RESTRICTION", "#REMOVE_RESULT_ERROR_USER_NOT_FOUND", "#REMOVE_RESULT_ERROR_SYSTEM_USER" ]
  }, {
    "name" : "public static boolean isRemoveResultSuccessful(@RemoveResult int result)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if {@link #removeUserWhenPossible} returned a success code which means that the user\n     * has been removed or is slated for removal.\n     *\n     * @param result is {@link #RemoveResult} code return by {@link #removeUserWhenPossible}.\n     * @return {@code true} if it is a success code.\n     * @hide\n     ",
    "links" : [ "#RemoveResult", "#removeUserWhenPossible" ]
  }, {
    "name" : "public void setUserName(@UserIdInt int userId, String name)",
    "returnType" : "void",
    "comment" : "\n     * Updates the user's name.\n     *\n     * @param userId the user's integer id\n     * @param name the new name for the user\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setUserEphemeral(@UserIdInt int userId, boolean enableEphemeral)",
    "returnType" : "boolean",
    "comment" : "\n     * Set the user as ephemeral or non-ephemeral.\n     *\n     * If the user was initially created as ephemeral then this\n     * method has no effect and false is returned.\n     *\n     * @param userId the user's integer id\n     * @param enableEphemeral true: change user state to ephemeral,\n     *                        false: change user state to non-ephemeral\n     * @return true: user now has the desired ephemeral state,\n     *         false: desired user ephemeral state could not be set\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setUserName(@Nullable String name)",
    "returnType" : "void",
    "comment" : "\n     * Updates the context user's name.\n     *\n     * @param name the new name for the user\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setUserIcon(@UserIdInt int userId, @NonNull Bitmap icon)",
    "returnType" : "void",
    "comment" : "\n     * Sets the user's photo.\n     * @param userId the user for whom to change the photo.\n     * @param icon the bitmap to set as the photo.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setUserIcon(@NonNull Bitmap icon) throws UserOperationException",
    "returnType" : "void",
    "comment" : "\n     * Sets the context user's photo.\n     *\n     * @param icon the bitmap to set as the photo.\n     *\n     * @throws UserOperationException according to the function signature, but may not actually\n     * throw it in practice. Catch RuntimeException instead.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Bitmap getUserIcon(@UserIdInt int userId)",
    "returnType" : "Bitmap",
    "comment" : "\n     * Returns a bitmap of the user's photo\n     * @param userId the user whose photo we want to read.\n     * @return a {@link Bitmap} of the user's photo, or null if there's no photo.\n     * @see com.android.internal.util.UserIcons#getDefaultUserIcon for a default.\n     * @hide\n     ",
    "links" : [ "android.graphics.Bitmap" ]
  }, {
    "name" : "public Bitmap getUserIcon()",
    "returnType" : "Bitmap",
    "comment" : "\n     * Returns a Bitmap for the context user's photo.\n     *\n     * @return a {@link Bitmap} of the user's photo, or null if there's no photo.\n     * @see com.android.internal.util.UserIcons#getDefaultUserIcon for a default.\n     * @hide\n     ",
    "links" : [ "android.graphics.Bitmap" ]
  }, {
    "name" : "public static int getMaxSupportedUsers()",
    "returnType" : "int",
    "comment" : "\n     * Returns the maximum number of users that can be created on this device. A return value\n     * of 1 means that it is a single user device.\n     * @hide\n     * @return a value greater than or equal to 1\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUserSwitcherEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the user switcher is enabled (regardless of whether there is anything\n     * interesting for it to show).\n     *\n     * @return true if user switcher is enabled\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isUserSwitcherEnabled(boolean showEvenIfNotActionable)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the user switcher should be shown.\n     *\n     * @param showEvenIfNotActionable value to return if the feature is enabled but there is nothing\n     *                                actionable for the user to do anyway\n     * @return true if user switcher should be shown.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isDeviceInDemoMode(Context context)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getUserSerialNumber(@UserIdInt int userId)",
    "returnType" : "int",
    "comment" : "\n     * Returns a serial number on this device for a given userId. User handles can be recycled\n     * when deleting and creating users, but serial numbers are not reused until the device is wiped.\n     * @param userId\n     * @return a serial number associated with that user, or -1 if the userId is not valid.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getUserHandle(int userSerialNumber)",
    "returnType" : "int",
    "comment" : "\n     * Returns a userId on this device for a given user serial number. User handles can be\n     * recycled when deleting and creating users, but serial numbers are not reused until the device\n     * is wiped.\n     * @param userSerialNumber\n     * @return the userId associated with that user serial number, or -1 if the serial number\n     * is not valid.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Bundle getApplicationRestrictions(String packageName)",
    "returnType" : "Bundle",
    "comment" : "\n     * Returns a {@link Bundle} containing any saved application restrictions for the context user,\n     * for the given package name. Only an application with this package name can call this method.\n     *\n     * <p>The returned {@link Bundle} consists of key-value pairs, as defined by the application,\n     * where the types of values may be:\n     * <ul>\n     * <li>{@code boolean}\n     * <li>{@code int}\n     * <li>{@code String} or {@code String[]}\n     * <li>From {@link android.os.Build.VERSION_CODES#M}, {@code Bundle} or {@code Bundle[]}\n     * </ul>\n     *\n     * <p>NOTE: The method performs disk I/O and shouldn't be called on the main thread\n     *\n     * @param packageName the package name of the calling application\n     * @return a {@link Bundle} with the restrictions for that package, or an empty {@link Bundle}\n     * if there are no saved restrictions.\n     *\n     * @see #KEY_RESTRICTIONS_PENDING\n     *\n     * <p>Starting from Android version {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE},\n     * it is possible for there to be multiple managing apps on the device with the ability to set\n     * restrictions, e.g. an Enterprise Device Policy Controller (DPC) and a Supervision admin.\n     * This API will only to return the restrictions set by the DPCs. To retrieve restrictions\n     * set by all managing apps, use\n     * {@link android.content.RestrictionsManager#getApplicationRestrictionsPerAdmin} instead.\n     *\n     * @see DevicePolicyManager\n     ",
    "links" : [ "android.content.RestrictionsManager#getApplicationRestrictionsPerAdmin", "android.os.Bundle", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE", "android.os.Build.VERSION_CODES#M" ]
  }, {
    "name" : "public Bundle getApplicationRestrictions(String packageName, UserHandle user)",
    "returnType" : "Bundle",
    "comment" : "\n     * <p>Starting from Android version {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE},\n     * it is possible for there to be multiple managing apps on the device with the ability to set\n     * restrictions, e.g. an Enterprise Device Policy Controller (DPC) and a Supervision admin.\n     * This API will only to return the restrictions set by the DPCs. To retrieve restrictions\n     * set by all managing apps, use\n     * {@link android.content.RestrictionsManager#getApplicationRestrictionsPerAdmin} instead.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.RestrictionsManager#getApplicationRestrictionsPerAdmin", "android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE" ]
  }, {
    "name" : "public void setApplicationRestrictions(String packageName, Bundle restrictions, UserHandle user)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setRestrictionsChallenge(String newPin)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets a new challenge PIN for restrictions. This is only for use by pre-installed\n     * apps and requires the MANAGE_USERS permission.\n     * @param newPin the PIN to use for challenge dialogs.\n     * @return Returns true if the challenge PIN was set successfully.\n     * @deprecated The restrictions PIN functionality is no longer provided by the system.\n     * This method is preserved for backwards compatibility reasons and always returns false.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDefaultGuestRestrictions(Bundle restrictions)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     * Set restrictions that should apply to any future guest user that's created.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Bundle getDefaultGuestRestrictions()",
    "returnType" : "Bundle",
    "comment" : "\n     * @hide\n     * Gets the default guest restrictions.\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getUserCreationTime(UserHandle userHandle)",
    "returnType" : "long",
    "comment" : "\n     * Returns creation time of the given user. The given user must be the calling user or\n     * a profile associated with it.\n     * @param userHandle user handle of the calling user or a profile associated with the\n     *                   calling user.\n     * @return creation time in milliseconds since Epoch time.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean someUserHasSeedAccount(String accountName, String accountType)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if any uninitialized user has the specific seed account name and type.\n     *\n     * @param accountName The account name to check for\n     * @param accountType The account type of the account to check for\n     * @return whether the seed account was found\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean someUserHasAccount(@NonNull String accountName, @NonNull String accountType)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if any initialized or uninitialized user has the specific account name and type.\n     *\n     * @param accountName The account name to check for\n     * @param accountType The account type of the account to check for\n     * @return whether the account was found\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setBootUser(@NonNull UserHandle bootUser)",
    "returnType" : "void",
    "comment" : "\n     * Sets the user who should be in the foreground when boot completes. This should be called\n     * during boot, and the provided user must be a full user (i.e. not a profile).\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public UserHandle getBootUser()",
    "returnType" : "UserHandle",
    "comment" : "\n     * Returns the user who should be in the foreground when boot completes.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static final void invalidateStaticUserProperties()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static final void invalidateUserPropertiesCache()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  } ],
  "methodNames" : [ "private T returnNullOrThrowUserOperationException(ServiceSpecificException exception, boolean throwInsteadOfNull) throws UserOperationException", "private int getContextUserIfAppropriate()", "public static UserManager get(Context context)", "public static boolean supportsMultipleUsers()", "public static boolean isGuestUserAlwaysEphemeral()", "public static boolean isGuestUserAllowEphemeralStateChange()", "public static boolean isCommunalProfileEnabled()", "public static boolean isPrivateProfileEnabled()", "public static boolean isMultipleAdminEnabled()", "public static boolean isHeadlessSystemUserMode()", "public boolean canSwitchUsers()", "public int getUserSwitchability()", "public int getUserSwitchability(UserHandle userHandle)", "public int getUserHandle()", "public int getProcessUserId()", "public String getUserType()", "public String getUserName()", "public boolean isUserNameSet()", "public boolean isUserAGoat()", "public boolean isPrimaryUser()", "public boolean isSystemUser()", "public boolean isMainUser()", "public UserHandle getMainUser()", "public UserHandle getCommunalProfile()", "public boolean isCommunalProfile()", "private boolean isCommunalProfile(@UserIdInt int userId)", "public boolean isAdminUser()", "public boolean isUserAdmin(@UserIdInt int userId)", "public boolean isForegroundUserAdmin()", "public boolean isUserOfType(@NonNull String userType)", "public static boolean isUserTypeManagedProfile(@Nullable String userType)", "public static boolean isUserTypeGuest(@Nullable String userType)", "public static boolean isUserTypeRestricted(@Nullable String userType)", "public static boolean isUserTypeDemo(@Nullable String userType)", "public static boolean isUserTypeCloneProfile(@Nullable String userType)", "public static boolean isUserTypeCommunalProfile(@Nullable String userType)", "public static boolean isUserTypePrivateProfile(@Nullable String userType)", "public boolean isLinkedUser()", "public boolean isRestrictedProfile()", "public boolean isRestrictedProfile(@NonNull UserHandle user)", "public boolean canHaveRestrictedProfile()", "public boolean canAddPrivateProfile()", "public boolean hasRestrictedProfiles()", "public UserHandle getRestrictedProfileParent()", "public boolean isGuestUser(@UserIdInt int userId)", "public boolean isGuestUser()", "public boolean isDemoUser()", "public boolean isProfile()", "public boolean isProfile(@UserIdInt int userId)", "private String getProfileType()", "private String getProfileType(@UserIdInt int userId)", "public boolean isManagedProfile()", "public boolean isManagedProfile(@UserIdInt int userId)", "public boolean isCloneProfile()", "public boolean isPrivateProfile()", "public boolean isEphemeralUser()", "public boolean isUserEphemeral(@UserIdInt int userId)", "public boolean isUserRunning(UserHandle user)", "public boolean isUserRunning(@UserIdInt int userId)", "public boolean isUserRunningOrStopping(UserHandle user)", "public boolean isUserForeground()", "public static boolean isVisibleBackgroundUsersEnabled()", "public boolean isVisibleBackgroundUsersSupported()", "public static boolean isVisibleBackgroundUsersOnDefaultDisplayEnabled()", "public boolean isVisibleBackgroundUsersOnDefaultDisplaySupported()", "public boolean isUserVisible()", "public Set<UserHandle> getVisibleUsers()", "public int getMainDisplayIdAssignedToUser()", "public boolean isUserUnlocked()", "public boolean isUserUnlocked(UserHandle user)", "public boolean isUserUnlocked(@UserIdInt int userId)", "public void disableIsUserUnlockedCache()", "public static final void invalidateIsUserUnlockedCache()", "public boolean isUserUnlockingOrUnlocked(@NonNull UserHandle user)", "public boolean isUserUnlockingOrUnlocked(@UserIdInt int userId)", "public long getUserStartRealtime()", "public long getUserUnlockRealtime()", "public UserInfo getUserInfo(@UserIdInt int userId)", "public UserProperties getUserProperties(@NonNull UserHandle userHandle)", "public int getUserRestrictionSource(@UserRestrictionKey String restrictionKey, UserHandle userHandle)", "public List<EnforcingUser> getUserRestrictionSources(@UserRestrictionKey String restrictionKey, UserHandle userHandle)", "public Bundle getUserRestrictions()", "public Bundle getUserRestrictions(UserHandle userHandle)", "public boolean hasBaseUserRestriction(@UserRestrictionKey @NonNull String restrictionKey, @NonNull UserHandle userHandle)", "public void setUserRestrictions(Bundle restrictions)", "public void setUserRestrictions(Bundle restrictions, UserHandle userHandle)", "public void setUserRestriction(String key, boolean value)", "public void setUserRestriction(String key, boolean value, UserHandle userHandle)", "public boolean hasUserRestriction(@UserRestrictionKey String restrictionKey)", "public boolean hasUserRestriction(@UserRestrictionKey String restrictionKey, UserHandle userHandle)", "public boolean hasUserRestrictionForUser(@NonNull @UserRestrictionKey String restrictionKey, @NonNull UserHandle userHandle)", "private boolean hasUserRestrictionForUser(@NonNull @UserRestrictionKey String restrictionKey, @UserIdInt int userId)", "public boolean hasUserRestrictionOnAnyUser(@UserRestrictionKey String restrictionKey)", "public boolean isSettingRestrictedForUser(String setting, @UserIdInt int userId, String value, int callingUid)", "public void addUserRestrictionsListener(final IUserRestrictionsListener listener)", "public long getSerialNumberForUser(UserHandle user)", "public UserHandle getUserForSerialNumber(long serialNumber)", "public UserInfo createUser(@Nullable String name, @UserInfoFlag int flags)", "public UserInfo createUser(@Nullable String name, @NonNull String userType, @UserInfoFlag int flags)", "public NewUserResponse createUser(@NonNull NewUserRequest newUserRequest)", "public UserInfo preCreateUser(@NonNull String userType) throws UserOperationException", "public UserInfo createGuest(Context context)", "public UserInfo findCurrentGuestUser()", "public List<UserInfo> getGuestUsers()", "public UserHandle createProfile(@NonNull String name, @NonNull String userType, @NonNull Set<String> disallowedPackages) throws UserOperationException", "public UserInfo createProfileForUser(String name, @UserInfoFlag int flags, @UserIdInt int userId)", "public UserInfo createProfileForUser(String name, @NonNull String userType, @UserInfoFlag int flags, @UserIdInt int userId)", "public UserInfo createProfileForUser(@Nullable String name, @NonNull String userType, @UserInfoFlag int flags, @UserIdInt int userId, @Nullable String[] disallowedPackages)", "public UserInfo createProfileForUserEvenWhenDisallowed(String name, @NonNull String userType, @UserInfoFlag int flags, @UserIdInt int userId, String[] disallowedPackages)", "public UserInfo createRestrictedProfile(@Nullable String name)", "public static Intent createUserCreationIntent(@Nullable String userName, @Nullable String accountName, @Nullable String accountType, @Nullable PersistableBundle accountOptions)", "public Set<String> getPreInstallableSystemPackages(@NonNull String userType)", "public String getSeedAccountName()", "public String getSeedAccountType()", "public PersistableBundle getSeedAccountOptions()", "public void setSeedAccountData(int userId, String accountName, String accountType, PersistableBundle accountOptions)", "public void clearSeedAccountData()", "public boolean markGuestForDeletion(@UserIdInt int userId)", "public void setUserEnabled(@UserIdInt int userId)", "public void setUserAdmin(@UserIdInt int userId)", "public void revokeUserAdmin(@UserIdInt int userId)", "public void evictCredentialEncryptionKey(@UserIdInt int userId)", "public int getUserCount()", "public List<UserInfo> getUsers()", "public List<UserInfo> getAliveUsers()", "public List<UserInfo> getUsers(boolean excludeDying)", "public List<UserInfo> getUsers(boolean excludePartial, boolean excludeDying, boolean excludePreCreated)", "public List<UserHandle> getUserHandles(boolean excludeDying)", "public long[] getSerialNumbersOfUsers(boolean excludeDying)", "public String getUserAccount(@UserIdInt int userId)", "public void setUserAccount(@UserIdInt int userId, @Nullable String accountName)", "public UserInfo getPrimaryUser()", "public UserHandle getPreviousForegroundUser()", "public boolean canAddMoreUsers()", "public boolean canAddMoreUsers(@NonNull String userType)", "public int getRemainingCreatableUserCount(@NonNull String userType)", "public int getRemainingCreatableProfileCount(@NonNull String userType)", "public boolean canAddMoreManagedProfiles(@UserIdInt int userId, boolean allowedToRemoveOne)", "public boolean canAddMoreProfilesToUser(@NonNull String userType, @UserIdInt int userId)", "public boolean isUserTypeEnabled(@NonNull String userType)", "public List<UserInfo> getProfiles(@UserIdInt int userId)", "public List<UserInfo> getProfilesIncludingCommunal(@UserIdInt int userId)", "public boolean isSameProfileGroup(@NonNull UserHandle user, @NonNull UserHandle otherUser)", "public boolean isSameProfileGroup(@UserIdInt int userId, int otherUserId)", "public List<UserInfo> getEnabledProfiles(@UserIdInt int userId)", "public List<UserHandle> getUserProfiles()", "public List<UserHandle> getEnabledProfiles()", "public List<UserHandle> getAllProfiles()", "private List<UserHandle> getProfiles(boolean enabledOnly)", "private List<UserHandle> convertUserIdsToUserHandles(@NonNull int[] userIds)", "public int[] getProfileIds(@UserIdInt int userId, boolean enabledOnly)", "public int[] getProfileIdsWithDisabled(@UserIdInt int userId)", "public int[] getEnabledProfileIds(@UserIdInt int userId)", "public int[] getProfileIdsExcludingHidden(@UserIdInt int userId, boolean enabled)", "public int getCredentialOwnerProfile(@UserIdInt int userId)", "public UserInfo getProfileParent(@UserIdInt int userId)", "public UserHandle getProfileParent(@NonNull UserHandle user)", "public boolean requestQuietModeEnabled(boolean enableQuietMode, @NonNull UserHandle userHandle)", "public boolean requestQuietModeEnabled(boolean enableQuietMode, @NonNull UserHandle userHandle, @QuietModeFlag int flags)", "public boolean requestQuietModeEnabled(boolean enableQuietMode, @NonNull UserHandle userHandle, IntentSender target)", "public boolean requestQuietModeEnabled(boolean enableQuietMode, @NonNull UserHandle userHandle, IntentSender target, int flags)", "public boolean isQuietModeEnabled(UserHandle userHandle)", "public boolean hasBadge(@UserIdInt int userId)", "public boolean hasBadge()", "public int getUserBadgeColor(@UserIdInt int userId)", "public int getUserBadgeDarkColor(@UserIdInt int userId)", "public int getUserIconBadgeResId(@UserIdInt int userId)", "public int getUserBadgeResId(@UserIdInt int userId)", "public int getUserBadgeNoBackgroundResId(@UserIdInt int userId)", "public int getUserStatusBarIconResId(@UserIdInt int userId)", "public Drawable getBadgedIconForUser(Drawable icon, UserHandle user)", "public Drawable getBadgedDrawableForUser(Drawable badgedDrawable, UserHandle user, Rect badgeLocation, int badgeDensity)", "public Drawable getUserBadge()", "private Drawable getDefaultUserBadge(@UserIdInt int userId)", "public CharSequence getBadgedLabelForUser(CharSequence label, UserHandle user)", "private String getUpdatableUserBadgedLabelId(int userId)", "private String getDefaultUserBadgedLabel(CharSequence label, int userId)", "public String getProfileLabel()", "private String getDefaultProfileLabel(int userId)", "public String getProfileAccessibilityString(int userId)", "private String getProfileAccessibilityLabel(int userId)", "public boolean isMediaSharedWithParent()", "public boolean isCredentialSharableWithParent()", "public boolean removeUser(@UserIdInt int userId)", "public boolean removeUser(@NonNull UserHandle user)", "public boolean removeUserEvenWhenDisallowed(@UserIdInt int userId)", "public int removeUserWhenPossible(@NonNull UserHandle user, boolean overrideDevicePolicy)", "public static boolean isRemoveResultSuccessful(@RemoveResult int result)", "public void setUserName(@UserIdInt int userId, String name)", "public boolean setUserEphemeral(@UserIdInt int userId, boolean enableEphemeral)", "public void setUserName(@Nullable String name)", "public void setUserIcon(@UserIdInt int userId, @NonNull Bitmap icon)", "public void setUserIcon(@NonNull Bitmap icon) throws UserOperationException", "public Bitmap getUserIcon(@UserIdInt int userId)", "public Bitmap getUserIcon()", "public static int getMaxSupportedUsers()", "public boolean isUserSwitcherEnabled()", "public boolean isUserSwitcherEnabled(boolean showEvenIfNotActionable)", "public static boolean isDeviceInDemoMode(Context context)", "public int getUserSerialNumber(@UserIdInt int userId)", "public int getUserHandle(int userSerialNumber)", "public Bundle getApplicationRestrictions(String packageName)", "public Bundle getApplicationRestrictions(String packageName, UserHandle user)", "public void setApplicationRestrictions(String packageName, Bundle restrictions, UserHandle user)", "public boolean setRestrictionsChallenge(String newPin)", "public void setDefaultGuestRestrictions(Bundle restrictions)", "public Bundle getDefaultGuestRestrictions()", "public long getUserCreationTime(UserHandle userHandle)", "public boolean someUserHasSeedAccount(String accountName, String accountType)", "public boolean someUserHasAccount(@NonNull String accountName, @NonNull String accountType)", "public void setBootUser(@NonNull UserHandle bootUser)", "public UserHandle getBootUser()", "public static final void invalidateStaticUserProperties()", "public static final void invalidateUserPropertiesCache()" ],
  "variableNames" : [ "TAG", "mService", "mContext", "mUserId", "mProfileTypeOfProcessUser", "sIsHeadlessSystemUser", "MAX_USER_NAME_LENGTH", "MAX_ACCOUNT_STRING_LENGTH", "MAX_ACCOUNT_OPTIONS_LENGTH", "USER_TYPE_FULL_SYSTEM", "USER_TYPE_FULL_SECONDARY", "USER_TYPE_FULL_GUEST", "USER_TYPE_FULL_DEMO", "USER_TYPE_FULL_RESTRICTED", "USER_TYPE_PROFILE_MANAGED", "USER_TYPE_PROFILE_CLONE", "USER_TYPE_PROFILE_PRIVATE", "USER_TYPE_PROFILE_TEST", "USER_TYPE_PROFILE_COMMUNAL", "USER_TYPE_SYSTEM_HEADLESS", "QUIET_MODE_DISABLE_ONLY_IF_CREDENTIAL_NOT_REQUIRED", "QUIET_MODE_DISABLE_DONT_ASK_CREDENTIAL", "RESTRICTION_NOT_SET", "RESTRICTION_SOURCE_SYSTEM", "RESTRICTION_SOURCE_DEVICE_OWNER", "RESTRICTION_SOURCE_PROFILE_OWNER", "DISALLOW_MODIFY_ACCOUNTS", "DISALLOW_CONFIG_WIFI", "DISALLOW_CHANGE_WIFI_STATE", "DISALLOW_WIFI_TETHERING", "DISALLOW_GRANT_ADMIN", "DISALLOW_SHARING_ADMIN_CONFIGURED_WIFI", "DISALLOW_WIFI_DIRECT", "DISALLOW_ADD_WIFI_CONFIG", "DISALLOW_CONFIG_LOCALE", "DISALLOW_INSTALL_APPS", "DISALLOW_UNINSTALL_APPS", "DISALLOW_SHARE_LOCATION", "DISALLOW_AIRPLANE_MODE", "DISALLOW_CONFIG_BRIGHTNESS", "DISALLOW_AMBIENT_DISPLAY", "DISALLOW_CONFIG_SCREEN_TIMEOUT", "DISALLOW_INSTALL_UNKNOWN_SOURCES", "DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY", "DISALLOW_CONFIG_BLUETOOTH", "DISALLOW_BLUETOOTH", "DISALLOW_BLUETOOTH_SHARING", "DISALLOW_USB_FILE_TRANSFER", "DISALLOW_CONFIG_CREDENTIALS", "DISALLOW_REMOVE_USER", "DISALLOW_REMOVE_MANAGED_PROFILE", "DISALLOW_DEBUGGING_FEATURES", "DISALLOW_CONFIG_VPN", "DISALLOW_CONFIG_LOCATION", "DISALLOW_CONFIG_DATE_TIME", "DISALLOW_CONFIG_TETHERING", "DISALLOW_NETWORK_RESET", "DISALLOW_FACTORY_RESET", "DISALLOW_ADD_USER", "DISALLOW_ADD_MANAGED_PROFILE", "DISALLOW_ADD_CLONE_PROFILE", "DISALLOW_ADD_PRIVATE_PROFILE", "ENSURE_VERIFY_APPS", "DISALLOW_CONFIG_CELL_BROADCASTS", "DISALLOW_CONFIG_MOBILE_NETWORKS", "DISALLOW_APPS_CONTROL", "DISALLOW_MOUNT_PHYSICAL_MEDIA", "DISALLOW_UNMUTE_MICROPHONE", "DISALLOW_ADJUST_VOLUME", "DISALLOW_OUTGOING_CALLS", "DISALLOW_SMS", "DISALLOW_FUN", "DISALLOW_CREATE_WINDOWS", "DISALLOW_SYSTEM_ERROR_DIALOGS", "DISALLOW_CROSS_PROFILE_COPY_PASTE", "DISALLOW_OUTGOING_BEAM", "DISALLOW_WALLPAPER", "DISALLOW_SET_WALLPAPER", "DISALLOW_SAFE_BOOT", "DISALLOW_RECORD_AUDIO", "DISALLOW_RUN_IN_BACKGROUND", "DISALLOW_CAMERA", "DISALLOW_UNMUTE_DEVICE", "DISALLOW_DATA_ROAMING", "DISALLOW_SET_USER_ICON", "DISALLOW_OEM_UNLOCK", "DISALLOW_UNIFIED_PASSWORD", "ALLOW_PARENT_PROFILE_APP_LINKING", "DISALLOW_AUTOFILL", "DISALLOW_CONTENT_CAPTURE", "DISALLOW_CONTENT_SUGGESTIONS", "DISALLOW_USER_SWITCH", "DISALLOW_SHARE_INTO_MANAGED_PROFILE", "DISALLOW_PRINTING", "DISALLOW_CONFIG_PRIVATE_DNS", "DISALLOW_MICROPHONE_TOGGLE", "DISALLOW_CAMERA_TOGGLE", "DISALLOW_BIOMETRIC", "DISALLOW_CONFIG_DEFAULT_APPS", "KEY_RESTRICTIONS_PENDING", "DISALLOW_CELLULAR_2G", "DISALLOW_ULTRA_WIDEBAND_RADIO", "DISALLOW_NEAR_FIELD_COMMUNICATION_RADIO", "DISALLOW_THREAD_NETWORK", "DISALLOW_SIM_GLOBALLY", "DISALLOW_ASSIST_CONTENT", "SYSTEM_USER_MODE_EMULATION_PROPERTY", "SYSTEM_USER_MODE_EMULATION_DEFAULT", "SYSTEM_USER_MODE_EMULATION_FULL", "SYSTEM_USER_MODE_EMULATION_HEADLESS", "DEV_CREATE_OVERRIDE_PROPERTY", "ACTION_CREATE_USER", "ACTION_CREATE_SUPERVISED_USER", "EXTRA_USER_NAME", "EXTRA_USER_ACCOUNT_NAME", "EXTRA_USER_ACCOUNT_TYPE", "EXTRA_USER_ACCOUNT_OPTIONS", "PIN_VERIFICATION_FAILED_INCORRECT", "PIN_VERIFICATION_FAILED_NOT_SET", "PIN_VERIFICATION_SUCCESS", "ACTION_USER_RESTRICTIONS_CHANGED", "USER_CREATION_FAILED_NOT_PERMITTED", "USER_CREATION_FAILED_NO_MORE_USERS", "SWITCHABILITY_STATUS_OK", "SWITCHABILITY_STATUS_USER_IN_CALL", "SWITCHABILITY_STATUS_USER_SWITCH_DISALLOWED", "SWITCHABILITY_STATUS_SYSTEM_USER_LOCKED", "REMOVE_RESULT_REMOVED", "REMOVE_RESULT_DEFERRED", "REMOVE_RESULT_ALREADY_BEING_REMOVED", "REMOVE_RESULT_USER_IS_REMOVABLE", "REMOVE_RESULT_ERROR_UNKNOWN", "REMOVE_RESULT_ERROR_USER_RESTRICTION", "REMOVE_RESULT_ERROR_USER_NOT_FOUND", "REMOVE_RESULT_ERROR_SYSTEM_USER", "REMOVE_RESULT_ERROR_MAIN_USER_PERMANENT_ADMIN", "USER_OPERATION_SUCCESS", "USER_OPERATION_ERROR_UNKNOWN", "USER_OPERATION_ERROR_MANAGED_PROFILE", "USER_OPERATION_ERROR_MAX_RUNNING_USERS", "USER_OPERATION_ERROR_CURRENT_USER", "USER_OPERATION_ERROR_LOW_STORAGE", "USER_OPERATION_ERROR_MAX_USERS", "USER_OPERATION_ERROR_USER_ACCOUNT_ALREADY_EXISTS", "USER_OPERATION_ERROR_DISABLED_USER", "USER_OPERATION_ERROR_PRIVATE_PROFILE", "ALWAYS_USE_CONTEXT_USER", "CACHE_KEY_IS_USER_UNLOCKED_PROPERTY", "mIsUserUnlockedCache", "mIsUserUnlockingOrUnlockedCache", "CACHE_KEY_STATIC_USER_PROPERTIES", "mProfileTypeCache", "CACHE_KEY_USER_PROPERTIES", "mUserPropertiesCache" ]
}