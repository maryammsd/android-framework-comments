{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/app/Instrumentation.java",
  "packageName" : "android.app",
  "className" : "Instrumentation",
  "comment" : "\n * Base class for implementing application instrumentation code.  When running\n * with instrumentation turned on, this class will be instantiated for you\n * before any of the application code, allowing you to monitor all of the\n * interaction the system has with the application.  An Instrumentation\n * implementation is described to the system through an AndroidManifest.xml's\n * &lt;instrumentation&gt; tag.\n ",
  "variables" : [ {
    "name" : "REPORT_KEY_IDENTIFIER",
    "type" : "String",
    "comment" : "\n     * If included in the status or final bundle sent to an IInstrumentationWatcher, this key \n     * identifies the class that is writing the report.  This can be used to provide more structured\n     * logging or reporting capabilities in the IInstrumentationWatcher.\n     ",
    "links" : [ ]
  }, {
    "name" : "REPORT_KEY_STREAMRESULT",
    "type" : "String",
    "comment" : "\n     * If included in the status or final bundle sent to an IInstrumentationWatcher, this key \n     * identifies a string which can simply be printed to the output stream.  Using these streams\n     * provides a \"pretty printer\" version of the status & final packets.  Any bundles including \n     * this key should also include the complete set of raw key/value pairs, so that the\n     * instrumentation can also be launched, and results collected, by an automated system.\n     ",
    "links" : [ ]
  }, {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mSync",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mThread",
    "type" : "ActivityThread",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMessageQueue",
    "type" : "MessageQueue",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInstrContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAppContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mComponent",
    "type" : "ComponentName",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mRunner",
    "type" : "Thread",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWaitingActivities",
    "type" : "List<ActivityWaiter>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mActivityMonitors",
    "type" : "List<ActivityMonitor>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWatcher",
    "type" : "IInstrumentationWatcher",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUiAutomationConnection",
    "type" : "IUiAutomationConnection",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAutomaticPerformanceSnapshots",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPerformanceCollector",
    "type" : "PerformanceCollector",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPerfMetrics",
    "type" : "Bundle",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUiAutomation",
    "type" : "UiAutomation",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAnimationCompleteLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private void checkInstrumenting(String method)",
    "returnType" : "void",
    "comment" : "\n     * Called for methods that shouldn't be called by standard apps and\n     * should only be used in instrumentation environments. This is not\n     * security feature as these classes will still be accessible through\n     * reflection, but it will serve as noticeable discouragement from\n     * doing such a thing.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onCreate(Bundle arguments)",
    "returnType" : "void",
    "comment" : "\n     * Called when the instrumentation is starting, before any application code\n     * has been loaded.  Usually this will be implemented to simply call\n     * {@link #start} to begin the instrumentation thread, which will then\n     * continue execution in {@link #onStart}.\n     * \n     * <p>If you do not need your own thread -- that is you are writing your\n     * instrumentation to be completely asynchronous (returning to the event\n     * loop so that the application can run), you can simply begin your\n     * instrumentation here, for example call {@link Context#startActivity} to\n     * begin the appropriate first activity of the application. \n     *  \n     * @param arguments Any additional arguments that were supplied when the \n     *                  instrumentation was started.\n     ",
    "links" : [ "#start", "#onStart", "Context#startActivity" ]
  }, {
    "name" : "public void start()",
    "returnType" : "void",
    "comment" : "\n     * Create and start a new thread in which to run instrumentation.  This new\n     * thread will call to {@link #onStart} where you can implement the\n     * instrumentation.\n     ",
    "links" : [ "#onStart" ]
  }, {
    "name" : "public void onStart()",
    "returnType" : "void",
    "comment" : "\n     * Method where the instrumentation thread enters execution.  This allows\n     * you to run your instrumentation code in a separate thread than the\n     * application, so that it can perform blocking operation such as\n     * {@link #sendKeySync} or {@link #startActivitySync}.\n     * \n     * <p>You will typically want to call finish() when this function is done,\n     * to end your instrumentation.\n     ",
    "links" : [ "#sendKeySync", "#startActivitySync" ]
  }, {
    "name" : "public boolean onException(Object obj, Throwable e)",
    "returnType" : "boolean",
    "comment" : "\n     * This is called whenever the system captures an unhandled exception that\n     * was thrown by the application.  The default implementation simply\n     * returns false, allowing normal system handling of the exception to take\n     * place.\n     * \n     * @param obj The client object that generated the exception.  May be an\n     *            Application, Activity, BroadcastReceiver, Service, or null.\n     * @param e The exception that was thrown.\n     *  \n     * @return To allow normal system exception process to occur, return false.\n     *         If true is returned, the system will proceed as if the exception\n     *         didn't happen.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void sendStatus(int resultCode, Bundle results)",
    "returnType" : "void",
    "comment" : "\n     * Provide a status report about the application.\n     *  \n     * @param resultCode Current success/failure of instrumentation. \n     * @param results Any results to send back to the code that started the instrumentation.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addResults(Bundle results)",
    "returnType" : "void",
    "comment" : "\n     * Report some results in the middle of instrumentation execution.  Later results (including\n     * those provided by {@link #finish}) will be combined with {@link Bundle#putAll}.\n     ",
    "links" : [ "#finish", "Bundle#putAll" ]
  }, {
    "name" : "public void finish(int resultCode, Bundle results)",
    "returnType" : "void",
    "comment" : "\n     * Terminate instrumentation of the application.  This will cause the\n     * application process to exit, removing this instrumentation from the next\n     * time the application is started.  If multiple processes are currently running\n     * for this instrumentation, all of those processes will be killed.\n     *  \n     * @param resultCode Overall success/failure of instrumentation. \n     * @param results Any results to send back to the code that started the \n     *                instrumentation.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAutomaticPerformanceSnapshots()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void startPerformanceSnapshot()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void endPerformanceSnapshot()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onDestroy()",
    "returnType" : "void",
    "comment" : "\n     * Called when the instrumented application is stopping, after all of the\n     * normal application cleanup has occurred.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Context getContext()",
    "returnType" : "Context",
    "comment" : "\n     * Return the Context of this instrumentation's package.  Note that this is\n     * often different than the Context of the application being\n     * instrumentated, since the instrumentation code often lives is a\n     * different package than that of the application it is running against.\n     * See {@link #getTargetContext} to retrieve a Context for the target\n     * application.\n     * \n     * @return The instrumentation's package context.\n     * \n     * @see #getTargetContext\n     ",
    "links" : [ "#getTargetContext" ]
  }, {
    "name" : "public ComponentName getComponentName()",
    "returnType" : "ComponentName",
    "comment" : "\n     * Returns complete component name of this instrumentation.\n     * \n     * @return Returns the complete component name for this instrumentation.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Context getTargetContext()",
    "returnType" : "Context",
    "comment" : "\n     * Return a Context for the target application being instrumented.  Note\n     * that this is often different than the Context of the instrumentation\n     * code, since the instrumentation code often lives is a different package\n     * than that of the application it is running against. See\n     * {@link #getContext} to retrieve a Context for the instrumentation code.\n     * \n     * @return A Context in the target application.\n     * \n     * @see #getContext\n     ",
    "links" : [ "#getContext" ]
  }, {
    "name" : "public String getProcessName()",
    "returnType" : "String",
    "comment" : "\n     * Return the name of the process this instrumentation is running in.  Note this should\n     * only be used for testing and debugging.  If you are thinking about using this to,\n     * for example, conditionalize what is initialized in an Application class, it is strongly\n     * recommended to instead use lazy initialization (such as a getter for the state that\n     * only creates it when requested).  This can greatly reduce the work your process does\n     * when created for secondary things, such as to receive a broadcast.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isProfiling()",
    "returnType" : "boolean",
    "comment" : "\n     * Check whether this instrumentation was started with profiling enabled.\n     * \n     * @return Returns true if profiling was enabled when starting, else false.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startProfiling()",
    "returnType" : "void",
    "comment" : "\n     * This method will start profiling if isProfiling() returns true. You should\n     * only call this method if you set the handleProfiling attribute in the \n     * manifest file for this Instrumentation to true.  \n     ",
    "links" : [ ]
  }, {
    "name" : "public void stopProfiling()",
    "returnType" : "void",
    "comment" : "\n     * Stops profiling if isProfiling() returns true.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setInTouchMode(boolean inTouch)",
    "returnType" : "void",
    "comment" : "\n     * Force the global system in or out of touch mode.  This can be used if\n     * your instrumentation relies on the UI being in one more or the other\n     * when it starts.\n     * \n     * @param inTouch Set to true to be in touch mode, false to be in\n     * focus mode.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void waitForIdle(Runnable recipient)",
    "returnType" : "void",
    "comment" : "\n     * Schedule a callback for when the application's main thread goes idle\n     * (has no more events to process).\n     * \n     * @param recipient Called the next time the thread's message queue is\n     *                  idle.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void waitForIdleSync()",
    "returnType" : "void",
    "comment" : "\n     * Synchronously wait for the application to be idle.  Can not be called\n     * from the main application thread -- use {@link #start} to execute\n     * instrumentation in its own thread.\n     ",
    "links" : [ "#start" ]
  }, {
    "name" : "private void waitForEnterAnimationComplete(Activity activity)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onEnterAnimationComplete()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void runOnMainSync(Runnable runner)",
    "returnType" : "void",
    "comment" : "\n     * Execute a call on the application's main thread, blocking until it is\n     * complete.  Useful for doing things that are not thread-safe, such as\n     * looking at or modifying the view hierarchy.\n     * \n     * @param runner The code to run on the main thread.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Activity startActivitySync(Intent intent)",
    "returnType" : "Activity",
    "comment" : "\n     * Start a new activity and wait for it to begin running before returning.\n     * In addition to being synchronous, this method as some semantic\n     * differences from the standard {@link Context#startActivity} call: the\n     * activity component is resolved before talking with the activity manager\n     * (its class name is specified in the Intent that this method ultimately\n     * starts), and it does not allow you to start activities that run in a\n     * different process.  In addition, if the given Intent resolves to\n     * multiple activities, instead of displaying a dialog for the user to\n     * select an activity, an exception will be thrown.\n     *\n     * <p>The function returns as soon as the activity goes idle following the\n     * call to its {@link Activity#onCreate}.  Generally this means it has gone\n     * through the full initialization including {@link Activity#onResume} and\n     * drawn and displayed its initial window.\n     *\n     * @param intent Description of the activity to start.\n     *\n     * @see Context#startActivity\n     * @see #startActivitySync(Intent, Bundle)\n     ",
    "links" : [ "Context#startActivity", "Activity#onCreate", "Activity#onResume" ]
  }, {
    "name" : "public Activity startActivitySync(@NonNull Intent intent, @Nullable Bundle options)",
    "returnType" : "Activity",
    "comment" : "\n     * Start a new activity and wait for it to begin running before returning.\n     * In addition to being synchronous, this method as some semantic\n     * differences from the standard {@link Context#startActivity} call: the\n     * activity component is resolved before talking with the activity manager\n     * (its class name is specified in the Intent that this method ultimately\n     * starts), and it does not allow you to start activities that run in a\n     * different process.  In addition, if the given Intent resolves to\n     * multiple activities, instead of displaying a dialog for the user to\n     * select an activity, an exception will be thrown.\n     *\n     * <p>The function returns as soon as the activity goes idle following the\n     * call to its {@link Activity#onCreate}.  Generally this means it has gone\n     * through the full initialization including {@link Activity#onResume} and\n     * drawn and displayed its initial window.\n     *\n     * @param intent Description of the activity to start.\n     * @param options Additional options for how the Activity should be started.\n     * May be null if there are no options.  See {@link android.app.ActivityOptions}\n     * for how to build the Bundle supplied here; there are no supported definitions\n     * for building it manually.\n     *\n     * @see Context#startActivity(Intent, Bundle)\n     ",
    "links" : [ "Context#startActivity", "Activity#onCreate", "Activity#onResume", "android.app.ActivityOptions" ]
  }, {
    "name" : "public void addMonitor(ActivityMonitor monitor)",
    "returnType" : "void",
    "comment" : "\n     * Add a new {@link ActivityMonitor} that will be checked whenever an \n     * activity is started.  The monitor is added \n     * after any existing ones; the monitor will be hit only if none of the \n     * existing monitors can themselves handle the Intent. \n     *  \n     * @param monitor The new ActivityMonitor to see. \n     *  \n     * @see #addMonitor(IntentFilter, ActivityResult, boolean) \n     * @see #checkMonitorHit \n     ",
    "links" : [ "ActivityMonitor" ]
  }, {
    "name" : "public ActivityMonitor addMonitor(IntentFilter filter, ActivityResult result, boolean block)",
    "returnType" : "ActivityMonitor",
    "comment" : "\n     * A convenience wrapper for {@link #addMonitor(ActivityMonitor)} that \n     * creates an intent filter matching {@link ActivityMonitor} for you and \n     * returns it. \n     *  \n     * @param filter The set of intents this monitor is responsible for.\n     * @param result A canned result to return if the monitor is hit; can \n     *               be null.\n     * @param block Controls whether the monitor should block the activity \n     *              start (returning its canned result) or let the call\n     *              proceed.\n     * \n     * @return The newly created and added activity monitor. \n     *  \n     * @see #addMonitor(ActivityMonitor) \n     * @see #checkMonitorHit \n     ",
    "links" : [ "#addMonitor", "ActivityMonitor" ]
  }, {
    "name" : "public ActivityMonitor addMonitor(String cls, ActivityResult result, boolean block)",
    "returnType" : "ActivityMonitor",
    "comment" : "\n     * A convenience wrapper for {@link #addMonitor(ActivityMonitor)} that \n     * creates a class matching {@link ActivityMonitor} for you and returns it.\n     *  \n     * @param cls The activity class this monitor is responsible for.\n     * @param result A canned result to return if the monitor is hit; can \n     *               be null.\n     * @param block Controls whether the monitor should block the activity \n     *              start (returning its canned result) or let the call\n     *              proceed.\n     * \n     * @return The newly created and added activity monitor. \n     *  \n     * @see #addMonitor(ActivityMonitor) \n     * @see #checkMonitorHit \n     ",
    "links" : [ "#addMonitor", "ActivityMonitor" ]
  }, {
    "name" : "public boolean checkMonitorHit(ActivityMonitor monitor, int minHits)",
    "returnType" : "boolean",
    "comment" : "\n     * Test whether an existing {@link ActivityMonitor} has been hit.  If the \n     * monitor has been hit at least <var>minHits</var> times, then it will be \n     * removed from the activity monitor list and true returned.  Otherwise it \n     * is left as-is and false is returned. \n     *  \n     * @param monitor The ActivityMonitor to check.\n     * @param minHits The minimum number of hits required.\n     * \n     * @return True if the hit count has been reached, else false. \n     *  \n     * @see #addMonitor \n     ",
    "links" : [ "ActivityMonitor" ]
  }, {
    "name" : "public Activity waitForMonitor(ActivityMonitor monitor)",
    "returnType" : "Activity",
    "comment" : "\n     * Wait for an existing {@link ActivityMonitor} to be hit.  Once the \n     * monitor has been hit, it is removed from the activity monitor list and \n     * the first created Activity object that matched it is returned.\n     *  \n     * @param monitor The ActivityMonitor to wait for.\n     * \n     * @return The Activity object that matched the monitor.\n     ",
    "links" : [ "ActivityMonitor" ]
  }, {
    "name" : "public Activity waitForMonitorWithTimeout(ActivityMonitor monitor, long timeOut)",
    "returnType" : "Activity",
    "comment" : "\n     * Wait for an existing {@link ActivityMonitor} to be hit till the timeout\n     * expires.  Once the monitor has been hit, it is removed from the activity \n     * monitor list and the first created Activity object that matched it is \n     * returned.  If the timeout expires, a null object is returned. \n     *\n     * @param monitor The ActivityMonitor to wait for.\n     * @param timeOut The timeout value in milliseconds.\n     *\n     * @return The Activity object that matched the monitor.\n     ",
    "links" : [ "ActivityMonitor" ]
  }, {
    "name" : "public void removeMonitor(ActivityMonitor monitor)",
    "returnType" : "void",
    "comment" : "\n     * Remove an {@link ActivityMonitor} that was previously added with \n     * {@link #addMonitor}.\n     *  \n     * @param monitor The monitor to remove.\n     *  \n     * @see #addMonitor \n     ",
    "links" : [ "ActivityMonitor", "#addMonitor" ]
  }, {
    "name" : "public boolean invokeMenuActionSync(Activity targetActivity, int id, int flag)",
    "returnType" : "boolean",
    "comment" : "\n     * Execute a particular menu item.\n     * \n     * @param targetActivity The activity in question.\n     * @param id The identifier associated with the menu item.\n     * @param flag Additional flags, if any.\n     * @return Whether the invocation was successful (for example, it could be\n     *         false if item is disabled).\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean invokeContextMenuAction(Activity targetActivity, int id, int flag)",
    "returnType" : "boolean",
    "comment" : "\n     * Show the context menu for the currently focused view and executes a\n     * particular context menu item.\n     * \n     * @param targetActivity The activity in question.\n     * @param id The identifier associated with the context menu item.\n     * @param flag Additional flags, if any.\n     * @return Whether the invocation was successful (for example, it could be\n     *         false if item is disabled).\n     ",
    "links" : [ ]
  }, {
    "name" : "public void sendStringSync(String text)",
    "returnType" : "void",
    "comment" : "\n     * Sends the key events corresponding to the text to the app being\n     * instrumented.\n     * \n     * @param text The text to be sent. \n     ",
    "links" : [ ]
  }, {
    "name" : "public void sendKeySync(KeyEvent event)",
    "returnType" : "void",
    "comment" : "\n     * Send a key event to the currently focused window/view and wait for it to\n     * be processed.  Finished at some point after the recipient has returned\n     * from its event processing, though it may <em>not</em> have completely\n     * finished reacting from the event -- for example, if it needs to update\n     * its display as a result, it may still be in the process of doing that.\n     *\n     * @param event The event to send to the current focus.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void sendKeyDownUpSync(int key)",
    "returnType" : "void",
    "comment" : "\n     * Sends an up and down key event sync to the currently focused window.\n     * \n     * @param key The integer keycode for the event.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void sendCharacterSync(int keyCode)",
    "returnType" : "void",
    "comment" : "\n     * Higher-level method for sending both the down and up key events for a\n     * particular character key code.  Equivalent to creating both KeyEvent\n     * objects by hand and calling {@link #sendKeySync}.  The event appears\n     * as if it came from keyboard 0, the built in one.\n     * \n     * @param keyCode The key code of the character to send.\n     ",
    "links" : [ "#sendKeySync" ]
  }, {
    "name" : "public void sendPointerSync(MotionEvent event)",
    "returnType" : "void",
    "comment" : "\n     * Dispatch a pointer event. Finished at some point after the recipient has\n     * returned from its event processing, though it may <em>not</em> have\n     * completely finished reacting from the event -- for example, if it needs\n     * to update its display as a result, it may still be in the process of\n     * doing that.\n     * \n     * @param event A motion event describing the pointer action.  (As noted in \n     * {@link MotionEvent#obtain(long, long, int, float, float, int)}, be sure to use \n     * {@link SystemClock#uptimeMillis()} as the timebase.\n     ",
    "links" : [ "MotionEvent#obtain", "SystemClock#uptimeMillis" ]
  }, {
    "name" : "public void sendTrackballEventSync(MotionEvent event)",
    "returnType" : "void",
    "comment" : "\n     * Dispatch a trackball event. Finished at some point after the recipient has\n     * returned from its event processing, though it may <em>not</em> have\n     * completely finished reacting from the event -- for example, if it needs\n     * to update its display as a result, it may still be in the process of\n     * doing that.\n     * \n     * @param event A motion event describing the trackball action.  (As noted in \n     * {@link MotionEvent#obtain(long, long, int, float, float, int)}, be sure to use \n     * {@link SystemClock#uptimeMillis()} as the timebase.\n     ",
    "links" : [ "MotionEvent#obtain", "SystemClock#uptimeMillis" ]
  }, {
    "name" : "public Application newApplication(ClassLoader cl, String className, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException",
    "returnType" : "Application",
    "comment" : "\n     * Perform instantiation of the process's {@link Application} object.  The\n     * default implementation provides the normal system behavior.\n     * \n     * @param cl The ClassLoader with which to instantiate the object.\n     * @param className The name of the class implementing the Application\n     *                  object.\n     * @param context The context to initialize the application with\n     * \n     * @return The newly instantiated Application object.\n     ",
    "links" : [ "Application" ]
  }, {
    "name" : "public static Application newApplication(Class<?> clazz, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException",
    "returnType" : "Application",
    "comment" : "\n     * Perform instantiation of the process's {@link Application} object.  The\n     * default implementation provides the normal system behavior.\n     * \n     * @param clazz The class used to create an Application object from.\n     * @param context The context to initialize the application with\n     * \n     * @return The newly instantiated Application object.\n     ",
    "links" : [ "Application" ]
  }, {
    "name" : "public void callApplicationOnCreate(Application app)",
    "returnType" : "void",
    "comment" : "\n     * Perform calling of the application's {@link Application#onCreate}\n     * method.  The default implementation simply calls through to that method.\n     *\n     * <p>Note: This method will be called immediately after {@link #onCreate(Bundle)}.\n     * Often instrumentation tests start their test thread in onCreate(); you\n     * need to be careful of races between these.  (Well between it and\n     * everything else, but let's start here.)\n     *\n     * @param app The application being created.\n     ",
    "links" : [ "Application#onCreate", "#onCreate" ]
  }, {
    "name" : "public Activity newActivity(Class<?> clazz, Context context, IBinder token, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, Object lastNonConfigurationInstance) throws InstantiationException, IllegalAccessException",
    "returnType" : "Activity",
    "comment" : "\n     * Perform instantiation of an {@link Activity} object.  This method is intended for use with\n     * unit tests, such as android.test.ActivityUnitTestCase.  The activity will be useable\n     * locally but will be missing some of the linkages necessary for use within the system.\n     * \n     * @param clazz The Class of the desired Activity\n     * @param context The base context for the activity to use\n     * @param token The token for this activity to communicate with\n     * @param application The application object (if any)\n     * @param intent The intent that started this Activity\n     * @param info ActivityInfo from the manifest\n     * @param title The title, typically retrieved from the ActivityInfo record\n     * @param parent The parent Activity (if any)\n     * @param id The embedded Id (if any)\n     * @param lastNonConfigurationInstance Arbitrary object that will be\n     * available via {@link Activity#getLastNonConfigurationInstance()\n     * Activity.getLastNonConfigurationInstance()}.\n     * @return Returns the instantiated activity\n     * @throws InstantiationException\n     * @throws IllegalAccessException\n     ",
    "links" : [ "Activity", "Activity#getLastNonConfigurationInstance" ]
  }, {
    "name" : "public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException",
    "returnType" : "Activity",
    "comment" : "\n     * Perform instantiation of the process's {@link Activity} object.  The\n     * default implementation provides the normal system behavior.\n     * \n     * @param cl The ClassLoader with which to instantiate the object.\n     * @param className The name of the class implementing the Activity\n     *                  object.\n     * @param intent The Intent object that specified the activity class being\n     *               instantiated.\n     * \n     * @return The newly instantiated Activity object.\n     ",
    "links" : [ "Activity" ]
  }, {
    "name" : "private AppComponentFactory getFactory(String pkg)",
    "returnType" : "AppComponentFactory",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void prePerformCreate(Activity activity)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void postPerformCreate(Activity activity)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void callActivityOnCreate(Activity activity, Bundle icicle)",
    "returnType" : "void",
    "comment" : "\n     * Perform calling of an activity's {@link Activity#onCreate}\n     * method.  The default implementation simply calls through to that method.\n     *\n     * @param activity The activity being created.\n     * @param icicle The previously frozen state (or null) to pass through to onCreate().\n     ",
    "links" : [ "Activity#onCreate" ]
  }, {
    "name" : "public void callActivityOnCreate(Activity activity, Bundle icicle, PersistableBundle persistentState)",
    "returnType" : "void",
    "comment" : "\n     * Perform calling of an activity's {@link Activity#onCreate}\n     * method.  The default implementation simply calls through to that method.\n     *  @param activity The activity being created.\n     * @param icicle The previously frozen state (or null) to pass through to\n     * @param persistentState The previously persisted state (or null)\n     ",
    "links" : [ "Activity#onCreate" ]
  }, {
    "name" : "public void callActivityOnDestroy(Activity activity)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void callActivityOnRestoreInstanceState(@NonNull Activity activity, @NonNull Bundle savedInstanceState)",
    "returnType" : "void",
    "comment" : "\n     * Perform calling of an activity's {@link Activity#onRestoreInstanceState}\n     * method.  The default implementation simply calls through to that method.\n     *\n     * @param activity The activity being restored.\n     * @param savedInstanceState The previously saved state being restored.\n     ",
    "links" : [ "Activity#onRestoreInstanceState" ]
  }, {
    "name" : "public void callActivityOnRestoreInstanceState(@NonNull Activity activity, @Nullable Bundle savedInstanceState, @Nullable PersistableBundle persistentState)",
    "returnType" : "void",
    "comment" : "\n     * Perform calling of an activity's {@link Activity#onRestoreInstanceState}\n     * method.  The default implementation simply calls through to that method.\n     *\n     * @param activity The activity being restored.\n     * @param savedInstanceState The previously saved state being restored (or null).\n     * @param persistentState The previously persisted state (or null)\n     ",
    "links" : [ "Activity#onRestoreInstanceState" ]
  }, {
    "name" : "public void callActivityOnPostCreate(@NonNull Activity activity, @Nullable Bundle savedInstanceState)",
    "returnType" : "void",
    "comment" : "\n     * Perform calling of an activity's {@link Activity#onPostCreate} method.\n     * The default implementation simply calls through to that method.\n     *\n     * @param activity The activity being created.\n     * @param savedInstanceState The previously saved state (or null) to pass through to\n     *               onPostCreate().\n     ",
    "links" : [ "Activity#onPostCreate" ]
  }, {
    "name" : "public void callActivityOnPostCreate(@NonNull Activity activity, @Nullable Bundle savedInstanceState, @Nullable PersistableBundle persistentState)",
    "returnType" : "void",
    "comment" : "\n     * Perform calling of an activity's {@link Activity#onPostCreate} method.\n     * The default implementation simply calls through to that method.\n     *\n     * @param activity The activity being created.\n     * @param savedInstanceState The previously frozen state (or null) to pass through to\n     *               onPostCreate().\n     * @param persistentState The previously persisted state (or null)\n     ",
    "links" : [ "Activity#onPostCreate" ]
  }, {
    "name" : "public void callActivityOnNewIntent(Activity activity, Intent intent)",
    "returnType" : "void",
    "comment" : "\n     * Perform calling of an activity's {@link Activity#onNewIntent}\n     * method.  The default implementation simply calls through to that method.\n     * \n     * @param activity The activity receiving a new Intent.\n     * @param intent The new intent being received.\n     ",
    "links" : [ "Activity#onNewIntent" ]
  }, {
    "name" : "public void callActivityOnNewIntent(Activity activity, ReferrerIntent intent)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void callActivityOnStart(Activity activity)",
    "returnType" : "void",
    "comment" : "\n     * Perform calling of an activity's {@link Activity#onStart}\n     * method.  The default implementation simply calls through to that method.\n     * \n     * @param activity The activity being started.\n     ",
    "links" : [ "Activity#onStart" ]
  }, {
    "name" : "public void callActivityOnRestart(Activity activity)",
    "returnType" : "void",
    "comment" : "\n     * Perform calling of an activity's {@link Activity#onRestart}\n     * method.  The default implementation simply calls through to that method.\n     * \n     * @param activity The activity being restarted.\n     ",
    "links" : [ "Activity#onRestart" ]
  }, {
    "name" : "public void callActivityOnResume(Activity activity)",
    "returnType" : "void",
    "comment" : "\n     * Perform calling of an activity's {@link Activity#onResume} method.  The\n     * default implementation simply calls through to that method.\n     * \n     * @param activity The activity being resumed.\n     ",
    "links" : [ "Activity#onResume" ]
  }, {
    "name" : "public void callActivityOnStop(Activity activity)",
    "returnType" : "void",
    "comment" : "\n     * Perform calling of an activity's {@link Activity#onStop}\n     * method.  The default implementation simply calls through to that method.\n     * \n     * @param activity The activity being stopped.\n     ",
    "links" : [ "Activity#onStop" ]
  }, {
    "name" : "public void callActivityOnSaveInstanceState(@NonNull Activity activity, @NonNull Bundle outState)",
    "returnType" : "void",
    "comment" : "\n     * Perform calling of an activity's {@link Activity#onSaveInstanceState}\n     * method.  The default implementation simply calls through to that method.\n     *\n     * @param activity The activity being saved.\n     * @param outState The bundle to pass to the call.\n     ",
    "links" : [ "Activity#onSaveInstanceState" ]
  }, {
    "name" : "public void callActivityOnSaveInstanceState(@NonNull Activity activity, @NonNull Bundle outState, @NonNull PersistableBundle outPersistentState)",
    "returnType" : "void",
    "comment" : "\n     * Perform calling of an activity's {@link Activity#onSaveInstanceState}\n     * method.  The default implementation simply calls through to that method.\n     *  @param activity The activity being saved.\n     * @param outState The bundle to pass to the call.\n     * @param outPersistentState The persistent bundle to pass to the call.\n     ",
    "links" : [ "Activity#onSaveInstanceState" ]
  }, {
    "name" : "public void callActivityOnPause(Activity activity)",
    "returnType" : "void",
    "comment" : "\n     * Perform calling of an activity's {@link Activity#onPause} method.  The\n     * default implementation simply calls through to that method.\n     * \n     * @param activity The activity being paused.\n     ",
    "links" : [ "Activity#onPause" ]
  }, {
    "name" : "public void callActivityOnUserLeaving(Activity activity)",
    "returnType" : "void",
    "comment" : "\n     * Perform calling of an activity's {@link Activity#onUserLeaveHint} method.\n     * The default implementation simply calls through to that method.\n     * \n     * @param activity The activity being notified that the user has navigated away\n     ",
    "links" : [ "Activity#onUserLeaveHint" ]
  }, {
    "name" : "public void callActivityOnPictureInPictureRequested(@NonNull Activity activity)",
    "returnType" : "void",
    "comment" : "\n     * Perform calling of an activity's {@link Activity#onPictureInPictureRequested} method.\n     * The default implementation simply calls through to that method.\n     *\n     * @param activity The activity being notified that picture-in-picture is being requested.\n     ",
    "links" : [ "Activity#onPictureInPictureRequested" ]
  }, {
    "name" : "public void startAllocCounting()",
    "returnType" : "void",
    "comment" : "\n     * Starts allocation counting. This triggers a gc and resets the counts.\n     *\n     * @deprecated Accurate counting is a burden on the runtime and may be removed.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void stopAllocCounting()",
    "returnType" : "void",
    "comment" : "\n     * Stops allocation counting.\n     *\n     * @deprecated Accurate counting is a burden on the runtime and may be removed.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void addValue(String key, int value, Bundle results)",
    "returnType" : "void",
    "comment" : "\n     * If Results already contains Key, it appends Value to the key's ArrayList\n     * associated with the key. If the key doesn't already exist in results, it\n     * adds the key/value pair to results.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Bundle getAllocCounts()",
    "returnType" : "Bundle",
    "comment" : "\n     * Returns a bundle with the current results from the allocation counting.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Bundle getBinderCounts()",
    "returnType" : "Bundle",
    "comment" : "\n     * Returns a bundle with the counts for various binder counts for this process. Currently the only two that are\n     * reported are the number of send and the number of received transactions.\n     ",
    "links" : [ ]
  }, {
    "name" : "public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options)",
    "returnType" : "ActivityResult",
    "comment" : "\n     * Execute a startActivity call made by the application.  The default \n     * implementation takes care of updating any active {@link ActivityMonitor}\n     * objects and dispatches this call to the system activity manager; you can\n     * override this to watch for the application to start an activity, and \n     * modify what happens when it does. \n     *\n     * <p>This method returns an {@link ActivityResult} object, which you can \n     * use when intercepting application calls to avoid performing the start \n     * activity action but still return the result the application is \n     * expecting.  To do this, override this method to catch the call to start \n     * activity so that it returns a new ActivityResult containing the results \n     * you would like the application to see, and don't call up to the super \n     * class.  Note that an application is only expecting a result if \n     * <var>requestCode</var> is &gt;= 0.\n     *\n     * <p>This method throws {@link android.content.ActivityNotFoundException}\n     * if there was no Activity found to run the given Intent.\n     *\n     * @param who The Context from which the activity is being started.\n     * @param contextThread The main thread of the Context from which the activity\n     *                      is being started.\n     * @param token Internal token identifying to the system who is starting \n     *              the activity; may be null.\n     * @param target Which activity is performing the start (and thus receiving \n     *               any result); may be null if this call is not being made\n     *               from an activity.\n     * @param intent The actual Intent to start.\n     * @param requestCode Identifier for this request's result; less than zero \n     *                    if the caller is not expecting a result.\n     * @param options Addition options.\n     *\n     * @return To force the return of a particular result, return an \n     *         ActivityResult object containing the desired data; otherwise\n     *         return null.  The default implementation always returns null.\n     *\n     * @throws android.content.ActivityNotFoundException\n     *\n     * @see Activity#startActivity(Intent)\n     * @see Activity#startActivityForResult(Intent, int)\n     *\n     * {@hide}\n     ",
    "links" : [ "ActivityMonitor", "ActivityResult", "android.content.ActivityNotFoundException" ]
  }, {
    "name" : "public void execStartActivities(Context who, IBinder contextThread, IBinder token, Activity target, Intent[] intents, Bundle options)",
    "returnType" : "void",
    "comment" : "\n     * Like {@link #execStartActivity(Context, IBinder, IBinder, Activity, Intent, int, Bundle)},\n     * but accepts an array of activities to be started.  Note that active\n     * {@link ActivityMonitor} objects only match against the first activity in\n     * the array.\n     *\n     * {@hide}\n     ",
    "links" : [ "#execStartActivity", "ActivityMonitor" ]
  }, {
    "name" : "public int execStartActivitiesAsUser(Context who, IBinder contextThread, IBinder token, Activity target, Intent[] intents, Bundle options, int userId)",
    "returnType" : "int",
    "comment" : "\n     * Like {@link #execStartActivity(Context, IBinder, IBinder, Activity, Intent, int, Bundle)},\n     * but accepts an array of activities to be started.  Note that active\n     * {@link ActivityMonitor} objects only match against the first activity in\n     * the array.\n     *\n     * @return The corresponding flag {@link ActivityManager#START_CANCELED},\n     *         {@link ActivityManager#START_SUCCESS} etc. indicating whether the launch was\n     *         successful.\n     *\n     * {@hide}\n     ",
    "links" : [ "#execStartActivity", "ActivityMonitor", "ActivityManager#START_CANCELED", "ActivityManager#START_SUCCESS" ]
  }, {
    "name" : "public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, String target, Intent intent, int requestCode, Bundle options)",
    "returnType" : "ActivityResult",
    "comment" : "\n     * Like {@link #execStartActivity(android.content.Context, android.os.IBinder,\n     * android.os.IBinder, String, android.content.Intent, int, android.os.Bundle)},\n     * but for calls from a {@link Fragment}.\n     * \n     * @param who The Context from which the activity is being started.\n     * @param contextThread The main thread of the Context from which the activity\n     *                      is being started.\n     * @param token Internal token identifying to the system who is starting \n     *              the activity; may be null.\n     * @param target Which element is performing the start (and thus receiving \n     *               any result).\n     * @param intent The actual Intent to start.\n     * @param requestCode Identifier for this request's result; less than zero \n     *                    if the caller is not expecting a result.\n     * \n     * @return To force the return of a particular result, return an \n     *         ActivityResult object containing the desired data; otherwise\n     *         return null.  The default implementation always returns null.\n     *  \n     * @throws android.content.ActivityNotFoundException\n     * \n     * @see Activity#startActivity(Intent)\n     * @see Activity#startActivityForResult(Intent, int)\n     * \n     * {@hide}\n     ",
    "links" : [ "#execStartActivity", "Fragment" ]
  }, {
    "name" : "public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, String resultWho, Intent intent, int requestCode, Bundle options, UserHandle user)",
    "returnType" : "ActivityResult",
    "comment" : "\n     * Like {@link #execStartActivity(Context, IBinder, IBinder, Activity, Intent, int, Bundle)},\n     * but for starting as a particular user.\n     *\n     * @param who The Context from which the activity is being started.\n     * @param contextThread The main thread of the Context from which the activity\n     *                      is being started.\n     * @param token Internal token identifying to the system who is starting\n     *              the activity; may be null.\n     * @param target Which fragment is performing the start (and thus receiving\n     *               any result).\n     * @param intent The actual Intent to start.\n     * @param requestCode Identifier for this request's result; less than zero\n     *                    if the caller is not expecting a result.\n     *\n     * @return To force the return of a particular result, return an\n     *         ActivityResult object containing the desired data; otherwise\n     *         return null.  The default implementation always returns null.\n     *\n     * @throws android.content.ActivityNotFoundException\n     *\n     * @see Activity#startActivity(Intent)\n     * @see Activity#startActivityForResult(Intent, int)\n     *\n     * {@hide}\n     ",
    "links" : [ "#execStartActivity" ]
  }, {
    "name" : "public ActivityResult execStartActivityAsCaller(Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options, IBinder permissionToken, boolean ignoreTargetSecurity, int userId)",
    "returnType" : "ActivityResult",
    "comment" : "\n     * Special version!\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void execStartActivityFromAppTask(Context who, IBinder contextThread, IAppTask appTask, Intent intent, Bundle options)",
    "returnType" : "void",
    "comment" : "\n     * Special version!\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " final void init(ActivityThread thread, Context instrContext, Context appContext, ComponentName component, IInstrumentationWatcher watcher, IUiAutomationConnection uiAutomationConnection)",
    "returnType" : "void",
    "comment" : "package",
    "links" : [ ]
  }, {
    "name" : " final void basicInit(ActivityThread thread)",
    "returnType" : "void",
    "comment" : "\n     * Only sets the ActivityThread up, keeps everything else null because app is not being\n     * instrumented.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void checkStartActivityResult(int res, Object intent)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private final void validateNotAppThread()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public UiAutomation getUiAutomation()",
    "returnType" : "UiAutomation",
    "comment" : "\n     * Gets the {@link UiAutomation} instance with no flags set.\n     * <p>\n     * <strong>Note:</strong> The APIs exposed via the returned {@link UiAutomation}\n     * work across application boundaries while the APIs exposed by the instrumentation\n     * do not. For example, {@link Instrumentation#sendPointerSync(MotionEvent)} will\n     * not allow you to inject the event in an app different from the instrumentation\n     * target, while {@link UiAutomation#injectInputEvent(android.view.InputEvent, boolean)}\n     * will work regardless of the current application.\n     * </p>\n     * <p>\n     * A typical test case should be using either the {@link UiAutomation} or\n     * {@link Instrumentation} APIs. Using both APIs at the same time is not\n     * a mistake by itself but a client has to be aware of the APIs limitations.\n     * </p>\n     * <p>\n     * Equivalent to {@code getUiAutomation(0)}. If a {@link UiAutomation} exists with different\n     * flags, the flags on that instance will be changed, and then it will be returned.\n     * </p>\n     * @return The UI automation instance.\n     *\n     * @see UiAutomation\n     ",
    "links" : [ "UiAutomation", "UiAutomation", "Instrumentation#sendPointerSync", "UiAutomation#injectInputEvent", "UiAutomation", "Instrumentation", "UiAutomation" ]
  }, {
    "name" : "public UiAutomation getUiAutomation(@UiAutomationFlags int flags)",
    "returnType" : "UiAutomation",
    "comment" : "\n     * Gets the {@link UiAutomation} instance with flags set.\n     * <p>\n     * <strong>Note:</strong> The APIs exposed via the returned {@link UiAutomation}\n     * work across application boundaries while the APIs exposed by the instrumentation\n     * do not. For example, {@link Instrumentation#sendPointerSync(MotionEvent)} will\n     * not allow you to inject the event in an app different from the instrumentation\n     * target, while {@link UiAutomation#injectInputEvent(android.view.InputEvent, boolean)}\n     * will work regardless of the current application.\n     * </p>\n     * <p>\n     * A typical test case should be using either the {@link UiAutomation} or\n     * {@link Instrumentation} APIs. Using both APIs at the same time is not\n     * a mistake by itself but a client has to be aware of the APIs limitations.\n     * </p>\n     * <p>\n     * If a {@link UiAutomation} exists with different flags, the flags on that instance will be\n     * changed, and then it will be returned.\n     * </p>\n     *\n     * @param flags The flags to be passed to the UiAutomation, for example\n     *        {@link UiAutomation#FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES}.\n     *\n     * @return The UI automation instance.\n     *\n     * @see UiAutomation\n     ",
    "links" : [ "UiAutomation", "UiAutomation", "Instrumentation#sendPointerSync", "UiAutomation#injectInputEvent", "UiAutomation", "Instrumentation", "UiAutomation", "UiAutomation#FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES" ]
  }, {
    "name" : "public TestLooperManager acquireLooperManager(Looper looper)",
    "returnType" : "TestLooperManager",
    "comment" : "\n     * Takes control of the execution of messages on the specified looper until\n     * {@link TestLooperManager#release} is called.\n     ",
    "links" : [ "TestLooperManager#release" ]
  } ],
  "variableNames" : [ "REPORT_KEY_IDENTIFIER", "REPORT_KEY_STREAMRESULT", "TAG", "mSync", "mThread", "mMessageQueue", "mInstrContext", "mAppContext", "mComponent", "mRunner", "mWaitingActivities", "mActivityMonitors", "mWatcher", "mUiAutomationConnection", "mAutomaticPerformanceSnapshots", "mPerformanceCollector", "mPerfMetrics", "mUiAutomation", "mAnimationCompleteLock" ],
  "methodNames" : [ "private void checkInstrumenting(String method)", "public void onCreate(Bundle arguments)", "public void start()", "public void onStart()", "public boolean onException(Object obj, Throwable e)", "public void sendStatus(int resultCode, Bundle results)", "public void addResults(Bundle results)", "public void finish(int resultCode, Bundle results)", "public void setAutomaticPerformanceSnapshots()", "public void startPerformanceSnapshot()", "public void endPerformanceSnapshot()", "public void onDestroy()", "public Context getContext()", "public ComponentName getComponentName()", "public Context getTargetContext()", "public String getProcessName()", "public boolean isProfiling()", "public void startProfiling()", "public void stopProfiling()", "public void setInTouchMode(boolean inTouch)", "public void waitForIdle(Runnable recipient)", "public void waitForIdleSync()", "private void waitForEnterAnimationComplete(Activity activity)", "public void onEnterAnimationComplete()", "public void runOnMainSync(Runnable runner)", "public Activity startActivitySync(Intent intent)", "public Activity startActivitySync(@NonNull Intent intent, @Nullable Bundle options)", "public void addMonitor(ActivityMonitor monitor)", "public ActivityMonitor addMonitor(IntentFilter filter, ActivityResult result, boolean block)", "public ActivityMonitor addMonitor(String cls, ActivityResult result, boolean block)", "public boolean checkMonitorHit(ActivityMonitor monitor, int minHits)", "public Activity waitForMonitor(ActivityMonitor monitor)", "public Activity waitForMonitorWithTimeout(ActivityMonitor monitor, long timeOut)", "public void removeMonitor(ActivityMonitor monitor)", "public boolean invokeMenuActionSync(Activity targetActivity, int id, int flag)", "public boolean invokeContextMenuAction(Activity targetActivity, int id, int flag)", "public void sendStringSync(String text)", "public void sendKeySync(KeyEvent event)", "public void sendKeyDownUpSync(int key)", "public void sendCharacterSync(int keyCode)", "public void sendPointerSync(MotionEvent event)", "public void sendTrackballEventSync(MotionEvent event)", "public Application newApplication(ClassLoader cl, String className, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException", "public static Application newApplication(Class<?> clazz, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException", "public void callApplicationOnCreate(Application app)", "public Activity newActivity(Class<?> clazz, Context context, IBinder token, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, Object lastNonConfigurationInstance) throws InstantiationException, IllegalAccessException", "public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException", "private AppComponentFactory getFactory(String pkg)", "private void prePerformCreate(Activity activity)", "private void postPerformCreate(Activity activity)", "public void callActivityOnCreate(Activity activity, Bundle icicle)", "public void callActivityOnCreate(Activity activity, Bundle icicle, PersistableBundle persistentState)", "public void callActivityOnDestroy(Activity activity)", "public void callActivityOnRestoreInstanceState(@NonNull Activity activity, @NonNull Bundle savedInstanceState)", "public void callActivityOnRestoreInstanceState(@NonNull Activity activity, @Nullable Bundle savedInstanceState, @Nullable PersistableBundle persistentState)", "public void callActivityOnPostCreate(@NonNull Activity activity, @Nullable Bundle savedInstanceState)", "public void callActivityOnPostCreate(@NonNull Activity activity, @Nullable Bundle savedInstanceState, @Nullable PersistableBundle persistentState)", "public void callActivityOnNewIntent(Activity activity, Intent intent)", "public void callActivityOnNewIntent(Activity activity, ReferrerIntent intent)", "public void callActivityOnStart(Activity activity)", "public void callActivityOnRestart(Activity activity)", "public void callActivityOnResume(Activity activity)", "public void callActivityOnStop(Activity activity)", "public void callActivityOnSaveInstanceState(@NonNull Activity activity, @NonNull Bundle outState)", "public void callActivityOnSaveInstanceState(@NonNull Activity activity, @NonNull Bundle outState, @NonNull PersistableBundle outPersistentState)", "public void callActivityOnPause(Activity activity)", "public void callActivityOnUserLeaving(Activity activity)", "public void callActivityOnPictureInPictureRequested(@NonNull Activity activity)", "public void startAllocCounting()", "public void stopAllocCounting()", "private void addValue(String key, int value, Bundle results)", "public Bundle getAllocCounts()", "public Bundle getBinderCounts()", "public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options)", "public void execStartActivities(Context who, IBinder contextThread, IBinder token, Activity target, Intent[] intents, Bundle options)", "public int execStartActivitiesAsUser(Context who, IBinder contextThread, IBinder token, Activity target, Intent[] intents, Bundle options, int userId)", "public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, String target, Intent intent, int requestCode, Bundle options)", "public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, String resultWho, Intent intent, int requestCode, Bundle options, UserHandle user)", "public ActivityResult execStartActivityAsCaller(Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options, IBinder permissionToken, boolean ignoreTargetSecurity, int userId)", "public void execStartActivityFromAppTask(Context who, IBinder contextThread, IAppTask appTask, Intent intent, Bundle options)", " final void init(ActivityThread thread, Context instrContext, Context appContext, ComponentName component, IInstrumentationWatcher watcher, IUiAutomationConnection uiAutomationConnection)", " final void basicInit(ActivityThread thread)", "public static void checkStartActivityResult(int res, Object intent)", "private final void validateNotAppThread()", "public UiAutomation getUiAutomation()", "public UiAutomation getUiAutomation(@UiAutomationFlags int flags)", "public TestLooperManager acquireLooperManager(Looper looper)" ]
}