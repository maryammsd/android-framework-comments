{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/service/voice/AlwaysOnHotwordDetector.java",
  "packageName" : "android.service.voice",
  "className" : "AlwaysOnHotwordDetector",
  "comment" : "\n * A class that lets a VoiceInteractionService implementation interact with\n * always-on keyphrase detection APIs.\n ",
  "variables" : [ {
    "name" : "STATE_INVALID",
    "type" : "int",
    "comment" : "\n     * Indicates that this hotword detector is no longer valid for any recognition\n     * and should not be used anymore.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATE_HARDWARE_UNAVAILABLE",
    "type" : "int",
    "comment" : "\n     * Indicates that recognition for the given keyphrase is not available on the system\n     * because of the hardware configuration.\n     * No further interaction should be performed with the detector that returns this availability.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATE_KEYPHRASE_UNSUPPORTED",
    "type" : "int",
    "comment" : "\n     * Indicates that recognition for the given keyphrase is not supported.\n     * No further interaction should be performed with the detector that returns this availability.\n     *\n     * @deprecated This is no longer a valid state. Enrollment can occur outside of\n     * {@link KeyphraseEnrollmentInfo} through another privileged application. We can no longer\n     * determine ahead of time if the keyphrase and locale are unsupported by the system.\n     ",
    "links" : [ "KeyphraseEnrollmentInfo" ]
  }, {
    "name" : "STATE_KEYPHRASE_UNENROLLED",
    "type" : "int",
    "comment" : "\n     * Indicates that the given keyphrase is not enrolled.\n     * The caller may choose to begin an enrollment flow for the keyphrase.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATE_KEYPHRASE_ENROLLED",
    "type" : "int",
    "comment" : "\n     * Indicates that the given keyphrase is currently enrolled and it's possible to start\n     * recognition for it.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATE_NOT_READY",
    "type" : "int",
    "comment" : "\n     * Indicates that the detector isn't ready currently.\n     ",
    "links" : [ ]
  }, {
    "name" : "RECOGNITION_FLAG_NONE",
    "type" : "int",
    "comment" : "\n     * Empty flag for {@link #startRecognition(int)}.\n     *\n     * @hide\n     ",
    "links" : [ "#startRecognition" ]
  }, {
    "name" : "RECOGNITION_FLAG_CAPTURE_TRIGGER_AUDIO",
    "type" : "int",
    "comment" : "\n     * Recognition flag for {@link #startRecognition(int)} that indicates\n     * whether the trigger audio for hotword needs to be captured.\n     ",
    "links" : [ "#startRecognition" ]
  }, {
    "name" : "RECOGNITION_FLAG_ALLOW_MULTIPLE_TRIGGERS",
    "type" : "int",
    "comment" : "\n     * Recognition flag for {@link #startRecognition(int)} that indicates\n     * whether the recognition should keep going on even after the keyphrase triggers.\n     * If this flag is specified, it's possible to get multiple triggers after a\n     * call to {@link #startRecognition(int)} if the user speaks the keyphrase multiple times.\n     * When this isn't specified, the default behavior is to stop recognition once the\n     * keyphrase is spoken, till the caller starts recognition again.\n     ",
    "links" : [ "#startRecognition", "#startRecognition" ]
  }, {
    "name" : "RECOGNITION_FLAG_ENABLE_AUDIO_ECHO_CANCELLATION",
    "type" : "int",
    "comment" : "\n     * Audio capabilities flag for {@link #startRecognition(int)} that indicates\n     * if the underlying recognition should use AEC.\n     * This capability may or may not be supported by the system, and support can be queried\n     * by calling {@link #getSupportedAudioCapabilities()}. The corresponding capabilities field for\n     * this flag is {@link #AUDIO_CAPABILITY_ECHO_CANCELLATION}. If this flag is passed without the\n     * audio capability supported, there will be no audio effect applied.\n     ",
    "links" : [ "#startRecognition", "#getSupportedAudioCapabilities", "#AUDIO_CAPABILITY_ECHO_CANCELLATION" ]
  }, {
    "name" : "RECOGNITION_FLAG_ENABLE_AUDIO_NOISE_SUPPRESSION",
    "type" : "int",
    "comment" : "\n     * Audio capabilities flag for {@link #startRecognition(int)} that indicates\n     * if the underlying recognition should use noise suppression.\n     * This capability may or may not be supported by the system, and support can be queried\n     * by calling {@link #getSupportedAudioCapabilities()}. The corresponding capabilities field for\n     * this flag is {@link #AUDIO_CAPABILITY_NOISE_SUPPRESSION}. If this flag is passed without the\n     * audio capability supported, there will be no audio effect applied.\n     ",
    "links" : [ "#startRecognition", "#getSupportedAudioCapabilities", "#AUDIO_CAPABILITY_NOISE_SUPPRESSION" ]
  }, {
    "name" : "RECOGNITION_MODE_VOICE_TRIGGER",
    "type" : "int",
    "comment" : "\n     * Simple recognition of the key phrase.\n     * Returned by {@link #getSupportedRecognitionModes()}\n     ",
    "links" : [ "#getSupportedRecognitionModes" ]
  }, {
    "name" : "RECOGNITION_MODE_USER_IDENTIFICATION",
    "type" : "int",
    "comment" : "\n     * User identification performed with the keyphrase recognition.\n     * Returned by {@link #getSupportedRecognitionModes()}\n     ",
    "links" : [ "#getSupportedRecognitionModes" ]
  }, {
    "name" : "AUDIO_CAPABILITY_ECHO_CANCELLATION",
    "type" : "int",
    "comment" : "\n     * If set the underlying module supports AEC.\n     * Returned by {@link #getSupportedAudioCapabilities()}\n     ",
    "links" : [ "#getSupportedAudioCapabilities" ]
  }, {
    "name" : "AUDIO_CAPABILITY_NOISE_SUPPRESSION",
    "type" : "int",
    "comment" : "\n     * If set, the underlying module supports noise suppression.\n     * Returned by {@link #getSupportedAudioCapabilities()}\n     ",
    "links" : [ "#getSupportedAudioCapabilities" ]
  }, {
    "name" : "MODEL_PARAM_THRESHOLD_FACTOR",
    "type" : "int",
    "comment" : "\n     * Controls the sensitivity threshold adjustment factor for a given model.\n     * Negative value corresponds to less sensitive model (high threshold) and\n     * a positive value corresponds to a more sensitive model (low threshold).\n     * Default value is 0.\n     ",
    "links" : [ ]
  }, {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DBG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "STATUS_ERROR",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "STATUS_OK",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_AVAILABILITY_CHANGED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_HOTWORD_DETECTED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DETECTION_ERROR",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DETECTION_PAUSE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MSG_DETECTION_RESUME",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mText",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLocale",
    "type" : "Locale",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mKeyphraseMetadata",
    "type" : "KeyphraseMetadata",
    "comment" : "\n     * The metadata of the Keyphrase, derived from the enrollment application.\n     * This may be null if this keyphrase isn't supported by the enrollment application.\n     ",
    "links" : [ ]
  }, {
    "name" : "mKeyphraseEnrollmentInfo",
    "type" : "KeyphraseEnrollmentInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mModelManagementService",
    "type" : "IVoiceInteractionManagerService",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mInternalCallback",
    "type" : "SoundTriggerListener",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mExternalCallback",
    "type" : "Callback",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHandler",
    "type" : "Handler",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAvailability",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public int getSupportedRecognitionModes()",
    "returnType" : "int",
    "comment" : "\n     * Gets the recognition modes supported by the associated keyphrase.\n     *\n     * @see #RECOGNITION_MODE_USER_IDENTIFICATION\n     * @see #RECOGNITION_MODE_VOICE_TRIGGER\n     *\n     * @throws UnsupportedOperationException if the keyphrase itself isn't supported.\n     *         Callers should only call this method after a supported state callback on\n     *         {@link Callback#onAvailabilityChanged(int)} to avoid this exception.\n     * @throws IllegalStateException if the detector is in an invalid state.\n     *         This may happen if another detector has been instantiated or the\n     *         {@link VoiceInteractionService} hosting this detector has been shut down.\n     ",
    "links" : [ "Callback#onAvailabilityChanged", "VoiceInteractionService" ]
  }, {
    "name" : "private int getSupportedRecognitionModesLocked()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getSupportedAudioCapabilities()",
    "returnType" : "int",
    "comment" : "\n     * Get the audio capabilities supported by the platform which can be enabled when\n     * starting a recognition.\n     * Caller must be the active voice interaction service via\n     * Settings.Secure.VOICE_INTERACTION_SERVICE.\n     *\n     * @see #AUDIO_CAPABILITY_ECHO_CANCELLATION\n     * @see #AUDIO_CAPABILITY_NOISE_SUPPRESSION\n     *\n     * @return Bit field encoding of the AudioCapabilities supported.\n     ",
    "links" : [ ]
  }, {
    "name" : "private int getSupportedAudioCapabilitiesLocked()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean startRecognition(@RecognitionFlags int recognitionFlags)",
    "returnType" : "boolean",
    "comment" : "\n     * Starts recognition for the associated keyphrase.\n     * Caller must be the active voice interaction service via\n     * Settings.Secure.VOICE_INTERACTION_SERVICE.\n     *\n     * @see #RECOGNITION_FLAG_CAPTURE_TRIGGER_AUDIO\n     * @see #RECOGNITION_FLAG_ALLOW_MULTIPLE_TRIGGERS\n     *\n     * @param recognitionFlags The flags to control the recognition properties.\n     * @return Indicates whether the call succeeded or not.\n     * @throws UnsupportedOperationException if the recognition isn't supported.\n     *         Callers should only call this method after a supported state callback on\n     *         {@link Callback#onAvailabilityChanged(int)} to avoid this exception.\n     * @throws IllegalStateException if the detector is in an invalid state.\n     *         This may happen if another detector has been instantiated or the\n     *         {@link VoiceInteractionService} hosting this detector has been shut down.\n     ",
    "links" : [ "Callback#onAvailabilityChanged", "VoiceInteractionService" ]
  }, {
    "name" : "public boolean stopRecognition()",
    "returnType" : "boolean",
    "comment" : "\n     * Stops recognition for the associated keyphrase.\n     * Caller must be the active voice interaction service via\n     * Settings.Secure.VOICE_INTERACTION_SERVICE.\n     *\n     * @return Indicates whether the call succeeded or not.\n     * @throws UnsupportedOperationException if the recognition isn't supported.\n     *         Callers should only call this method after a supported state callback on\n     *         {@link Callback#onAvailabilityChanged(int)} to avoid this exception.\n     * @throws IllegalStateException if the detector is in an invalid state.\n     *         This may happen if another detector has been instantiated or the\n     *         {@link VoiceInteractionService} hosting this detector has been shut down.\n     ",
    "links" : [ "Callback#onAvailabilityChanged", "VoiceInteractionService" ]
  }, {
    "name" : "public int setParameter(@ModelParams int modelParam, int value)",
    "returnType" : "int",
    "comment" : "\n     * Set a model specific {@link ModelParams} with the given value. This\n     * parameter will keep its value for the duration the model is loaded regardless of starting and\n     * stopping recognition. Once the model is unloaded, the value will be lost.\n     * {@link AlwaysOnHotwordDetector#queryParameter} should be checked first before calling this\n     * method.\n     * Caller must be the active voice interaction service via\n     * Settings.Secure.VOICE_INTERACTION_SERVICE.\n     *\n     * @param modelParam   {@link ModelParams}\n     * @param value        Value to set\n     * @return - {@link SoundTrigger#STATUS_OK} in case of success\n     *         - {@link SoundTrigger#STATUS_NO_INIT} if the native service cannot be reached\n     *         - {@link SoundTrigger#STATUS_BAD_VALUE} invalid input parameter\n     *         - {@link SoundTrigger#STATUS_INVALID_OPERATION} if the call is out of sequence or\n     *           if API is not supported by HAL\n     ",
    "links" : [ "ModelParams", "AlwaysOnHotwordDetector#queryParameter", "ModelParams", "SoundTrigger#STATUS_OK", "SoundTrigger#STATUS_NO_INIT", "SoundTrigger#STATUS_BAD_VALUE", "SoundTrigger#STATUS_INVALID_OPERATION" ]
  }, {
    "name" : "public int getParameter(@ModelParams int modelParam)",
    "returnType" : "int",
    "comment" : "\n     * Get a model specific {@link ModelParams}. This parameter will keep its value\n     * for the duration the model is loaded regardless of starting and stopping recognition.\n     * Once the model is unloaded, the value will be lost. If the value is not set, a default\n     * value is returned. See {@link ModelParams} for parameter default values.\n     * {@link AlwaysOnHotwordDetector#queryParameter} should be checked first before\n     * calling this method.\n     * Caller must be the active voice interaction service via\n     * Settings.Secure.VOICE_INTERACTION_SERVICE.\n     *\n     * @param modelParam   {@link ModelParams}\n     * @return value of parameter\n     ",
    "links" : [ "ModelParams", "ModelParams", "AlwaysOnHotwordDetector#queryParameter", "ModelParams" ]
  }, {
    "name" : "public ModelParamRange queryParameter(@ModelParams int modelParam)",
    "returnType" : "ModelParamRange",
    "comment" : "\n     * Determine if parameter control is supported for the given model handle.\n     * This method should be checked prior to calling {@link AlwaysOnHotwordDetector#setParameter}\n     * or {@link AlwaysOnHotwordDetector#getParameter}.\n     * Caller must be the active voice interaction service via\n     * Settings.Secure.VOICE_INTERACTION_SERVICE.\n     *\n     * @param modelParam {@link ModelParams}\n     * @return supported range of parameter, null if not supported\n     ",
    "links" : [ "AlwaysOnHotwordDetector#setParameter", "AlwaysOnHotwordDetector#getParameter", "ModelParams" ]
  }, {
    "name" : "public Intent createEnrollIntent()",
    "returnType" : "Intent",
    "comment" : "\n     * Creates an intent to start the enrollment for the associated keyphrase.\n     * This intent must be invoked using {@link Context#startForegroundService(Intent)}.\n     * Starting re-enrollment is only valid if the keyphrase is un-enrolled,\n     * i.e. {@link #STATE_KEYPHRASE_UNENROLLED},\n     * otherwise {@link #createReEnrollIntent()} should be preferred.\n     *\n     * @return An {@link Intent} to start enrollment for the given keyphrase.\n     * @throws UnsupportedOperationException if managing they keyphrase isn't supported.\n     *         Callers should only call this method after a supported state callback on\n     *         {@link Callback#onAvailabilityChanged(int)} to avoid this exception.\n     * @throws IllegalStateException if the detector is in an invalid state.\n     *         This may happen if another detector has been instantiated or the\n     *         {@link VoiceInteractionService} hosting this detector has been shut down.\n     ",
    "links" : [ "Context#startForegroundService", "#STATE_KEYPHRASE_UNENROLLED", "#createReEnrollIntent", "Intent", "Callback#onAvailabilityChanged", "VoiceInteractionService" ]
  }, {
    "name" : "public Intent createUnEnrollIntent()",
    "returnType" : "Intent",
    "comment" : "\n     * Creates an intent to start the un-enrollment for the associated keyphrase.\n     * This intent must be invoked using {@link Context#startForegroundService(Intent)}.\n     * Starting re-enrollment is only valid if the keyphrase is already enrolled,\n     * i.e. {@link #STATE_KEYPHRASE_ENROLLED}, otherwise invoking this may result in an error.\n     *\n     * @return An {@link Intent} to start un-enrollment for the given keyphrase.\n     * @throws UnsupportedOperationException if managing they keyphrase isn't supported.\n     *         Callers should only call this method after a supported state callback on\n     *         {@link Callback#onAvailabilityChanged(int)} to avoid this exception.\n     * @throws IllegalStateException if the detector is in an invalid state.\n     *         This may happen if another detector has been instantiated or the\n     *         {@link VoiceInteractionService} hosting this detector has been shut down.\n     ",
    "links" : [ "Context#startForegroundService", "#STATE_KEYPHRASE_ENROLLED", "Intent", "Callback#onAvailabilityChanged", "VoiceInteractionService" ]
  }, {
    "name" : "public Intent createReEnrollIntent()",
    "returnType" : "Intent",
    "comment" : "\n     * Creates an intent to start the re-enrollment for the associated keyphrase.\n     * This intent must be invoked using {@link Context#startForegroundService(Intent)}.\n     * Starting re-enrollment is only valid if the keyphrase is already enrolled,\n     * i.e. {@link #STATE_KEYPHRASE_ENROLLED}, otherwise invoking this may result in an error.\n     *\n     * @return An {@link Intent} to start re-enrollment for the given keyphrase.\n     * @throws UnsupportedOperationException if managing they keyphrase isn't supported.\n     *         Callers should only call this method after a supported state callback on\n     *         {@link Callback#onAvailabilityChanged(int)} to avoid this exception.\n     * @throws IllegalStateException if the detector is in an invalid state.\n     *         This may happen if another detector has been instantiated or the\n     *         {@link VoiceInteractionService} hosting this detector has been shut down.\n     ",
    "links" : [ "Context#startForegroundService", "#STATE_KEYPHRASE_ENROLLED", "Intent", "Callback#onAvailabilityChanged", "VoiceInteractionService" ]
  }, {
    "name" : "private Intent getManageIntentLocked(@KeyphraseEnrollmentInfo.ManageActions int action)",
    "returnType" : "Intent",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void invalidate()",
    "returnType" : "void",
    "comment" : "\n     * Invalidates this hotword detector so that any future calls to this result\n     * in an IllegalStateException.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " void onSoundModelsChanged()",
    "returnType" : "void",
    "comment" : "\n     * Reloads the sound models from the service.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private int startRecognitionLocked(int recognitionFlags)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int stopRecognitionLocked()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int setParameterLocked(@ModelParams int modelParam, int value)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getParameterLocked(@ModelParams int modelParam)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private ModelParamRange queryParameterLocked(@ModelParams int modelParam)",
    "returnType" : "ModelParamRange",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void notifyStateChangedLocked()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dump(String prefix, PrintWriter pw)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  } ],
  "variableNames" : [ "STATE_INVALID", "STATE_HARDWARE_UNAVAILABLE", "STATE_KEYPHRASE_UNSUPPORTED", "STATE_KEYPHRASE_UNENROLLED", "STATE_KEYPHRASE_ENROLLED", "STATE_NOT_READY", "RECOGNITION_FLAG_NONE", "RECOGNITION_FLAG_CAPTURE_TRIGGER_AUDIO", "RECOGNITION_FLAG_ALLOW_MULTIPLE_TRIGGERS", "RECOGNITION_FLAG_ENABLE_AUDIO_ECHO_CANCELLATION", "RECOGNITION_FLAG_ENABLE_AUDIO_NOISE_SUPPRESSION", "RECOGNITION_MODE_VOICE_TRIGGER", "RECOGNITION_MODE_USER_IDENTIFICATION", "AUDIO_CAPABILITY_ECHO_CANCELLATION", "AUDIO_CAPABILITY_NOISE_SUPPRESSION", "MODEL_PARAM_THRESHOLD_FACTOR", "TAG", "DBG", "STATUS_ERROR", "STATUS_OK", "MSG_AVAILABILITY_CHANGED", "MSG_HOTWORD_DETECTED", "MSG_DETECTION_ERROR", "MSG_DETECTION_PAUSE", "MSG_DETECTION_RESUME", "mText", "mLocale", "mKeyphraseMetadata", "mKeyphraseEnrollmentInfo", "mModelManagementService", "mInternalCallback", "mExternalCallback", "mLock", "mHandler", "mAvailability" ],
  "methodNames" : [ "public int getSupportedRecognitionModes()", "private int getSupportedRecognitionModesLocked()", "public int getSupportedAudioCapabilities()", "private int getSupportedAudioCapabilitiesLocked()", "public boolean startRecognition(@RecognitionFlags int recognitionFlags)", "public boolean stopRecognition()", "public int setParameter(@ModelParams int modelParam, int value)", "public int getParameter(@ModelParams int modelParam)", "public ModelParamRange queryParameter(@ModelParams int modelParam)", "public Intent createEnrollIntent()", "public Intent createUnEnrollIntent()", "public Intent createReEnrollIntent()", "private Intent getManageIntentLocked(@KeyphraseEnrollmentInfo.ManageActions int action)", " void invalidate()", " void onSoundModelsChanged()", "private int startRecognitionLocked(int recognitionFlags)", "private int stopRecognitionLocked()", "private int setParameterLocked(@ModelParams int modelParam, int value)", "private int getParameterLocked(@ModelParams int modelParam)", "private ModelParamRange queryParameterLocked(@ModelParams int modelParam)", "private void notifyStateChangedLocked()", "public void dump(String prefix, PrintWriter pw)" ]
}