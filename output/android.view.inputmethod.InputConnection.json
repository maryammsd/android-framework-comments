{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/view/inputmethod/InputConnection.java",
  "packageName" : "android.view.inputmethod",
  "className" : "InputConnection",
  "comment" : "\n * The InputConnection interface is the communication channel from an\n * {@link InputMethod} back to the application that is receiving its\n * input. It is used to perform such things as reading text around the\n * cursor, committing text to the text box, and sending raw key events\n * to the application.\n *\n * <p>Starting from API Level {@link android.os.Build.VERSION_CODES#N},\n * the system can deal with the situation where the application directly\n * implements this class but one or more of the following methods are\n * not implemented.</p>\n * <ul>\n *     <li>{@link #getSelectedText(int)}, which was introduced in\n *     {@link android.os.Build.VERSION_CODES#GINGERBREAD}.</li>\n *     <li>{@link #setComposingRegion(int, int)}, which was introduced\n *     in {@link android.os.Build.VERSION_CODES#GINGERBREAD}.</li>\n *     <li>{@link #commitCorrection(CorrectionInfo)}, which was introduced\n *     in {@link android.os.Build.VERSION_CODES#HONEYCOMB}.</li>\n *     <li>{@link #requestCursorUpdates(int)}, which was introduced in\n *     {@link android.os.Build.VERSION_CODES#LOLLIPOP}.</li>\n *     <li>{@link #deleteSurroundingTextInCodePoints(int, int)}, which\n *     was introduced in {@link android.os.Build.VERSION_CODES#N}.</li>\n *     <li>{@link #getHandler()}, which was introduced in\n *     {@link android.os.Build.VERSION_CODES#N}.</li>\n *     <li>{@link #closeConnection()}, which was introduced in\n *     {@link android.os.Build.VERSION_CODES#N}.</li>\n *     <li>{@link #commitContent(InputContentInfo, int, Bundle)}, which was\n *     introduced in {@link android.os.Build.VERSION_CODES#N_MR1}.</li>\n * </ul>\n *\n * <h3>Implementing an IME or an editor</h3>\n * <p>Text input is the result of the synergy of two essential components:\n * an Input Method Engine (IME) and an editor. The IME can be a\n * software keyboard, a handwriting interface, an emoji palette, a\n * speech-to-text engine, and so on. There are typically several IMEs\n * installed on any given Android device. In Android, IMEs extend\n * {@link android.inputmethodservice.InputMethodService}.\n * For more information about how to create an IME, see the\n * <a href=\"{@docRoot}guide/topics/text/creating-input-method.html\">\n * Creating an input method</a> guide.\n *\n * The editor is the component that receives text and displays it.\n * Typically, this is an {@link android.widget.EditText} instance, but\n * some applications may choose to implement their own editor for\n * various reasons. This is a large and complicated task, and an\n * application that does this needs to make sure the behavior is\n * consistent with standard EditText behavior in Android. An editor\n * needs to interact with the IME, receiving commands through\n * this InputConnection interface, and sending commands through\n * {@link android.view.inputmethod.InputMethodManager}. An editor\n * should start by implementing\n * {@link android.view.View#onCreateInputConnection(EditorInfo)}\n * to return its own input connection.</p>\n *\n * <p>If you are implementing your own IME, you will need to call the\n * methods in this interface to interact with the application. Be sure\n * to test your IME with a wide range of applications, including\n * browsers and rich text editors, as some may have peculiarities you\n * need to deal with. Remember your IME may not be the only source of\n * changes on the text, and try to be as conservative as possible in\n * the data you send and as liberal as possible in the data you\n * receive.</p>\n *\n * <p>If you are implementing your own editor, you will probably need\n * to provide your own subclass of {@link BaseInputConnection} to\n * answer to the commands from IMEs. Please be sure to test your\n * editor with as many IMEs as you can as their behavior can vary a\n * lot. Also be sure to test with various languages, including CJK\n * languages and right-to-left languages like Arabic, as these may\n * have different input requirements. When in doubt about the\n * behavior you should adopt for a particular call, please mimic the\n * default TextView implementation in the latest Android version, and\n * if you decide to drift from it, please consider carefully that\n * inconsistencies in text editor behavior is almost universally felt\n * as a bad thing by users.</p>\n *\n * <h3>Cursors, selections and compositions</h3>\n * <p>In Android, the cursor and the selection are one and the same\n * thing. A \"cursor\" is just the special case of a zero-sized\n * selection. As such, this documentation uses them\n * interchangeably. Any method acting \"before the cursor\" would act\n * before the start of the selection if there is one, and any method\n * acting \"after the cursor\" would act after the end of the\n * selection.</p>\n *\n * <p>An editor needs to be able to keep track of a currently\n * \"composing\" region, like the standard edition widgets do. The\n * composition is marked in a specific style: see\n * {@link android.text.Spanned#SPAN_COMPOSING}. IMEs use this to help\n * the user keep track of what part of the text they are currently\n * focusing on, and interact with the editor using\n * {@link InputConnection#setComposingText(CharSequence, int)},\n * {@link InputConnection#setComposingRegion(int, int)} and\n * {@link InputConnection#finishComposingText()}.\n * The composing region and the selection are completely independent\n * of each other, and the IME may use them however they see fit.</p>\n ",
  "links" : [ "#requestCursorUpdates(int)", "#commitContent(InputContentInfo", "android.os.Build.VERSION_CODES#LOLLIPOP", "android.view.inputmethod.InputMethod", "android.os.Build.VERSION_CODES#HONEYCOMB", "android.view.inputmethod.InputConnection#finishComposingText()", "#getSelectedText(int)", "android.os.Build.VERSION_CODES#GINGERBREAD", "android.text.Spanned#SPAN_COMPOSING", "#deleteSurroundingTextInCodePoints(int", "android.inputmethodservice.InputMethodService", "android.view.inputmethod.InputConnection#setComposingRegion(int", "#commitCorrection(CorrectionInfo)", "android.os.Build.VERSION_CODES#N", "android.view.inputmethod.InputMethodManager", "#setComposingRegion(int", "#getHandler()", "android.view.View#onCreateInputConnection(EditorInfo)", "#closeConnection()", "android.view.inputmethod.BaseInputConnection", "android.os.Build.VERSION_CODES#N_MR1", "android.view.inputmethod.InputConnection#setComposingText(CharSequence", "android.widget.EditText" ],
  "variables" : [ {
    "name" : "GET_TEXT_WITH_STYLES",
    "type" : "int",
    "comment" : "\n     * Flag for use with {@link #getTextAfterCursor}, {@link #getTextBeforeCursor} and\n     * {@link #getSurroundingText} to have style information returned along with the text. If not\n     * set, {@link #getTextAfterCursor} sends only the raw text, without style or other spans. If\n     * set, it may return a complex CharSequence of both text and style spans.\n     * <strong>Editor authors</strong>: you should strive to send text with styles if possible, but\n     * it is not required.\n     ",
    "links" : [ "#getTextAfterCursor", "#getTextBeforeCursor", "#getSurroundingText" ]
  }, {
    "name" : "GET_EXTRACTED_TEXT_MONITOR",
    "type" : "int",
    "comment" : "\n     * Flag for use with {@link #getExtractedText} to indicate you\n     * would like to receive updates when the extracted text changes.\n     ",
    "links" : [ "#getExtractedText" ]
  }, {
    "name" : "HANDWRITING_GESTURE_RESULT_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Result for {@link #performHandwritingGesture(HandwritingGesture, Executor, IntConsumer)} when\n     * editor didn't provide any result.\n     ",
    "links" : [ "#performHandwritingGesture(HandwritingGesture" ]
  }, {
    "name" : "HANDWRITING_GESTURE_RESULT_SUCCESS",
    "type" : "int",
    "comment" : "\n     * Result for {@link #performHandwritingGesture(HandwritingGesture, Executor, IntConsumer)} when\n     * {@link HandwritingGesture} is successfully executed on text.\n     ",
    "links" : [ "android.view.inputmethod.HandwritingGesture", "#performHandwritingGesture(HandwritingGesture" ]
  }, {
    "name" : "HANDWRITING_GESTURE_RESULT_UNSUPPORTED",
    "type" : "int",
    "comment" : "\n     * Result for {@link #performHandwritingGesture(HandwritingGesture, Executor, IntConsumer)} when\n     * {@link HandwritingGesture} is unsupported by the current editor.\n     ",
    "links" : [ "android.view.inputmethod.HandwritingGesture", "#performHandwritingGesture(HandwritingGesture" ]
  }, {
    "name" : "HANDWRITING_GESTURE_RESULT_FAILED",
    "type" : "int",
    "comment" : "\n     * Result for {@link #performHandwritingGesture(HandwritingGesture, Executor, IntConsumer)} when\n     * {@link HandwritingGesture} failed and there was no applicable\n     * {@link HandwritingGesture#getFallbackText()} or it couldn't\n     * be applied for any other reason.\n     ",
    "links" : [ "android.view.inputmethod.HandwritingGesture#getFallbackText()", "android.view.inputmethod.HandwritingGesture", "#performHandwritingGesture(HandwritingGesture" ]
  }, {
    "name" : "HANDWRITING_GESTURE_RESULT_CANCELLED",
    "type" : "int",
    "comment" : "\n     * Result for {@link #performHandwritingGesture(HandwritingGesture, Executor, IntConsumer)} when\n     * {@link HandwritingGesture} was cancelled. This happens when the {@link InputConnection} is\n     * or becomes invalidated while performing the gesture, for example because a new\n     * {@code InputConnection} was started, or due to {@link InputMethodManager#invalidateInput}.\n     ",
    "links" : [ "android.view.inputmethod.InputConnection", "android.view.inputmethod.HandwritingGesture", "#performHandwritingGesture(HandwritingGesture", "android.view.inputmethod.InputMethodManager#invalidateInput" ]
  }, {
    "name" : "HANDWRITING_GESTURE_RESULT_FALLBACK",
    "type" : "int",
    "comment" : "\n     * Result for {@link #performHandwritingGesture(HandwritingGesture, Executor, IntConsumer)} when\n     * {@link HandwritingGesture} failed but {@link HandwritingGesture#getFallbackText()} was\n     * committed.\n     ",
    "links" : [ "android.view.inputmethod.HandwritingGesture#getFallbackText()", "android.view.inputmethod.HandwritingGesture", "#performHandwritingGesture(HandwritingGesture" ]
  }, {
    "name" : "CURSOR_UPDATE_IMMEDIATE",
    "type" : "int",
    "comment" : "\n     * The editor is requested to call\n     * {@link InputMethodManager#updateCursorAnchorInfo(android.view.View, CursorAnchorInfo)} at\n     * once, as soon as possible, regardless of cursor/anchor position changes. This flag can be\n     * used together with {@link #CURSOR_UPDATE_MONITOR}.\n     * <p>\n     * Note by default all of {@link #CURSOR_UPDATE_FILTER_EDITOR_BOUNDS},\n     * {@link #CURSOR_UPDATE_FILTER_CHARACTER_BOUNDS},\n     * {@link #CURSOR_UPDATE_FILTER_VISIBLE_LINE_BOUNDS},\n     * {@link #CURSOR_UPDATE_FILTER_TEXT_APPEARANCE}, and\n     * {@link #CURSOR_UPDATE_FILTER_INSERTION_MARKER}, are included but specifying them can\n     * filter-out others.\n     * It can be CPU intensive to include all, filtering specific info is recommended.\n     * </p>\n     ",
    "links" : [ "#CURSOR_UPDATE_MONITOR", "#CURSOR_UPDATE_FILTER_VISIBLE_LINE_BOUNDS", "#CURSOR_UPDATE_FILTER_INSERTION_MARKER", "android.view.inputmethod.InputMethodManager#updateCursorAnchorInfo(android.view.View", "#CURSOR_UPDATE_FILTER_CHARACTER_BOUNDS", "#CURSOR_UPDATE_FILTER_TEXT_APPEARANCE", "#CURSOR_UPDATE_FILTER_EDITOR_BOUNDS" ]
  }, {
    "name" : "CURSOR_UPDATE_MONITOR",
    "type" : "int",
    "comment" : "\n     * The editor is requested to call\n     * {@link InputMethodManager#updateCursorAnchorInfo(android.view.View, CursorAnchorInfo)}\n     * whenever cursor/anchor position is changed. To disable monitoring, call\n     * {@link InputConnection#requestCursorUpdates(int)} again with this flag off.\n     * <p>\n     * This flag can be used together with {@link #CURSOR_UPDATE_IMMEDIATE}.\n     * </p>\n     * <p>\n     * Note by default all of {@link #CURSOR_UPDATE_FILTER_EDITOR_BOUNDS},\n     * {@link #CURSOR_UPDATE_FILTER_CHARACTER_BOUNDS},\n     * {@link #CURSOR_UPDATE_FILTER_VISIBLE_LINE_BOUNDS},\n     * {@link #CURSOR_UPDATE_FILTER_TEXT_APPEARANCE}, and\n     * {@link #CURSOR_UPDATE_FILTER_INSERTION_MARKER}, are included but specifying them can\n     * filter-out others.\n     * It can be CPU intensive to include all, filtering specific info is recommended.\n     * </p>\n     ",
    "links" : [ "#CURSOR_UPDATE_FILTER_VISIBLE_LINE_BOUNDS", "#CURSOR_UPDATE_IMMEDIATE", "android.view.inputmethod.InputConnection#requestCursorUpdates(int)", "#CURSOR_UPDATE_FILTER_INSERTION_MARKER", "android.view.inputmethod.InputMethodManager#updateCursorAnchorInfo(android.view.View", "#CURSOR_UPDATE_FILTER_CHARACTER_BOUNDS", "#CURSOR_UPDATE_FILTER_TEXT_APPEARANCE", "#CURSOR_UPDATE_FILTER_EDITOR_BOUNDS" ]
  }, {
    "name" : "CURSOR_UPDATE_FILTER_EDITOR_BOUNDS",
    "type" : "int",
    "comment" : "\n     * The editor is requested to call\n     * {@link InputMethodManager#updateCursorAnchorInfo(android.view.View, CursorAnchorInfo)}\n     * with new {@link EditorBoundsInfo} whenever cursor/anchor position is changed. To disable\n     * monitoring, call {@link InputConnection#requestCursorUpdates(int)} again with this flag off.\n     * <p>\n     * This flag can be used together with filters: {@link #CURSOR_UPDATE_FILTER_CHARACTER_BOUNDS},\n     * {@link #CURSOR_UPDATE_FILTER_VISIBLE_LINE_BOUNDS},\n     * {@link #CURSOR_UPDATE_FILTER_TEXT_APPEARANCE},\n     * {@link #CURSOR_UPDATE_FILTER_INSERTION_MARKER} and update flags\n     * {@link #CURSOR_UPDATE_IMMEDIATE} and {@link #CURSOR_UPDATE_MONITOR}.\n     * </p>\n     ",
    "links" : [ "#CURSOR_UPDATE_MONITOR", "#CURSOR_UPDATE_FILTER_VISIBLE_LINE_BOUNDS", "#CURSOR_UPDATE_IMMEDIATE", "android.view.inputmethod.InputConnection#requestCursorUpdates(int)", "#CURSOR_UPDATE_FILTER_INSERTION_MARKER", "android.view.inputmethod.InputMethodManager#updateCursorAnchorInfo(android.view.View", "android.view.inputmethod.EditorBoundsInfo", "#CURSOR_UPDATE_FILTER_CHARACTER_BOUNDS", "#CURSOR_UPDATE_FILTER_TEXT_APPEARANCE" ]
  }, {
    "name" : "CURSOR_UPDATE_FILTER_CHARACTER_BOUNDS",
    "type" : "int",
    "comment" : "\n     * The editor is requested to call\n     * {@link InputMethodManager#updateCursorAnchorInfo(android.view.View, CursorAnchorInfo)}\n     * with new character bounds {@link CursorAnchorInfo#getCharacterBounds(int)} whenever\n     * cursor/anchor position is changed. To disable\n     * monitoring, call {@link InputConnection#requestCursorUpdates(int)} again with this flag off.\n     * <p>\n     * This flag can be combined with other filters: {@link #CURSOR_UPDATE_FILTER_EDITOR_BOUNDS},\n     * {@link #CURSOR_UPDATE_FILTER_VISIBLE_LINE_BOUNDS},\n     * {@link #CURSOR_UPDATE_FILTER_TEXT_APPEARANCE}, {@link #CURSOR_UPDATE_FILTER_INSERTION_MARKER}\n     * and update flags {@link #CURSOR_UPDATE_IMMEDIATE} and {@link #CURSOR_UPDATE_MONITOR}.\n     * </p>\n     ",
    "links" : [ "#CURSOR_UPDATE_MONITOR", "#CURSOR_UPDATE_FILTER_VISIBLE_LINE_BOUNDS", "#CURSOR_UPDATE_IMMEDIATE", "android.view.inputmethod.InputConnection#requestCursorUpdates(int)", "android.view.inputmethod.CursorAnchorInfo#getCharacterBounds(int)", "#CURSOR_UPDATE_FILTER_INSERTION_MARKER", "android.view.inputmethod.InputMethodManager#updateCursorAnchorInfo(android.view.View", "#CURSOR_UPDATE_FILTER_TEXT_APPEARANCE", "#CURSOR_UPDATE_FILTER_EDITOR_BOUNDS" ]
  }, {
    "name" : "CURSOR_UPDATE_FILTER_INSERTION_MARKER",
    "type" : "int",
    "comment" : "\n     * The editor is requested to call\n     * {@link InputMethodManager#updateCursorAnchorInfo(android.view.View, CursorAnchorInfo)}\n     * with new Insertion marker info {@link CursorAnchorInfo#getInsertionMarkerFlags()},\n     * {@link CursorAnchorInfo#getInsertionMarkerBaseline()}, etc whenever cursor/anchor position is\n     * changed. To disable monitoring, call {@link InputConnection#requestCursorUpdates(int)} again\n     * with this flag off.\n     * <p>\n     * This flag can be combined with other filters: {@link #CURSOR_UPDATE_FILTER_CHARACTER_BOUNDS},\n     * {@link #CURSOR_UPDATE_FILTER_VISIBLE_LINE_BOUNDS},\n     * {@link #CURSOR_UPDATE_FILTER_TEXT_APPEARANCE}, {@link #CURSOR_UPDATE_FILTER_EDITOR_BOUNDS}\n     * and update flags {@link #CURSOR_UPDATE_IMMEDIATE} and {@link #CURSOR_UPDATE_MONITOR}.\n     * </p>\n     ",
    "links" : [ "#CURSOR_UPDATE_MONITOR", "#CURSOR_UPDATE_FILTER_VISIBLE_LINE_BOUNDS", "#CURSOR_UPDATE_IMMEDIATE", "android.view.inputmethod.InputConnection#requestCursorUpdates(int)", "android.view.inputmethod.InputMethodManager#updateCursorAnchorInfo(android.view.View", "android.view.inputmethod.CursorAnchorInfo#getInsertionMarkerFlags()", "#CURSOR_UPDATE_FILTER_CHARACTER_BOUNDS", "android.view.inputmethod.CursorAnchorInfo#getInsertionMarkerBaseline()", "#CURSOR_UPDATE_FILTER_TEXT_APPEARANCE", "#CURSOR_UPDATE_FILTER_EDITOR_BOUNDS" ]
  }, {
    "name" : "CURSOR_UPDATE_FILTER_VISIBLE_LINE_BOUNDS",
    "type" : "int",
    "comment" : "\n     * The editor is requested to call\n     * {@link InputMethodManager#updateCursorAnchorInfo(android.view.View, CursorAnchorInfo)}\n     * with new visible line bounds {@link CursorAnchorInfo#getVisibleLineBounds()} whenever\n     * cursor/anchor position is changed, the editor or its parent is scrolled or the line bounds\n     * changed due to text updates. To disable monitoring, call\n     * {@link InputConnection#requestCursorUpdates(int)} again with this flag off.\n     * <p>\n     * This flag can be combined with other filters: {@link #CURSOR_UPDATE_FILTER_CHARACTER_BOUNDS},\n     * {@link #CURSOR_UPDATE_FILTER_EDITOR_BOUNDS}, {@link #CURSOR_UPDATE_FILTER_INSERTION_MARKER},\n     * {@link #CURSOR_UPDATE_FILTER_TEXT_APPEARANCE} and update flags\n     * {@link #CURSOR_UPDATE_IMMEDIATE} and {@link #CURSOR_UPDATE_MONITOR}.\n     * </p>\n     ",
    "links" : [ "#CURSOR_UPDATE_MONITOR", "#CURSOR_UPDATE_IMMEDIATE", "android.view.inputmethod.CursorAnchorInfo#getVisibleLineBounds()", "android.view.inputmethod.InputConnection#requestCursorUpdates(int)", "#CURSOR_UPDATE_FILTER_INSERTION_MARKER", "android.view.inputmethod.InputMethodManager#updateCursorAnchorInfo(android.view.View", "#CURSOR_UPDATE_FILTER_CHARACTER_BOUNDS", "#CURSOR_UPDATE_FILTER_TEXT_APPEARANCE", "#CURSOR_UPDATE_FILTER_EDITOR_BOUNDS" ]
  }, {
    "name" : "CURSOR_UPDATE_FILTER_TEXT_APPEARANCE",
    "type" : "int",
    "comment" : "\n     * The editor is requested to call\n     * {@link InputMethodManager#updateCursorAnchorInfo(android.view.View, CursorAnchorInfo)}\n     * with new text appearance info {@link CursorAnchorInfo#getTextAppearanceInfo()}}\n     * whenever cursor/anchor position is changed. To disable monitoring, call\n     * {@link InputConnection#requestCursorUpdates(int)} again with this flag off.\n     * <p>\n     * This flag can be combined with other filters: {@link #CURSOR_UPDATE_FILTER_CHARACTER_BOUNDS},\n     * {@link #CURSOR_UPDATE_FILTER_EDITOR_BOUNDS}, {@link #CURSOR_UPDATE_FILTER_INSERTION_MARKER},\n     * {@link #CURSOR_UPDATE_FILTER_VISIBLE_LINE_BOUNDS} and update flags\n     * {@link #CURSOR_UPDATE_IMMEDIATE} and {@link #CURSOR_UPDATE_MONITOR}.\n     * </p>\n     ",
    "links" : [ "#CURSOR_UPDATE_MONITOR", "#CURSOR_UPDATE_FILTER_VISIBLE_LINE_BOUNDS", "#CURSOR_UPDATE_IMMEDIATE", "android.view.inputmethod.InputConnection#requestCursorUpdates(int)", "#CURSOR_UPDATE_FILTER_INSERTION_MARKER", "android.view.inputmethod.InputMethodManager#updateCursorAnchorInfo(android.view.View", "#CURSOR_UPDATE_FILTER_CHARACTER_BOUNDS", "android.view.inputmethod.CursorAnchorInfo#getTextAppearanceInfo()", "#CURSOR_UPDATE_FILTER_EDITOR_BOUNDS" ]
  }, {
    "name" : "INPUT_CONTENT_GRANT_READ_URI_PERMISSION",
    "type" : "int",
    "comment" : "\n     * When this flag is used, the editor will be able to request read access to the content URI\n     * contained in the {@link InputContentInfo} object.\n     *\n     * <p>Make sure that the content provider owning the Uri sets the\n     * {@link android.R.styleable#AndroidManifestProvider_grantUriPermissions\n     * grantUriPermissions} attribute in its manifest or included the\n     * {@link android.R.styleable#AndroidManifestGrantUriPermission\n     * &lt;grant-uri-permissions&gt;} tag. Otherwise {@link InputContentInfo#requestPermission()}\n     * can fail.</p>\n     *\n     * <p>Although calling this API is allowed only for the IME that is currently selected, the\n     * client is able to request a temporary read-only access even after the current IME is switched\n     * to any other IME as long as the client keeps {@link InputContentInfo} object.</p>\n     *",
    "links" : [ "android.view.inputmethod.InputContentInfo#requestPermission()", "android.R.styleable#AndroidManifestProvider_grantUriPermissionsgrantUriPermissions", "android.R.styleable#AndroidManifestGrantUriPermission", "android.view.inputmethod.InputContentInfo" ]
  } ],
  "methods" : [ {
    "name" : " CharSequence getTextBeforeCursor(@IntRange(from = 0) int n, int flags)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Get <var>n</var> characters of text before the current cursor\n     * position.\n     *\n     * <p>This method may fail either if the input connection has\n     * become invalid (such as its process crashing) or the editor is\n     * taking too long to respond with the text (it is given a couple\n     * seconds to return). In either case, null is returned. This\n     * method does not affect the text in the editor in any way, nor\n     * does it affect the selection or composing spans.</p>\n     *\n     * <p>If {@link #GET_TEXT_WITH_STYLES} is supplied as flags, the\n     * editor should return a {@link android.text.SpannableString}\n     * with all the spans set on the text.</p>\n     *\n     * <p><strong>IME authors:</strong> please consider this will\n     * trigger an IPC round-trip that will take some time. Assume this\n     * method consumes a lot of time. Also, please keep in mind the\n     * Editor may choose to return less characters than requested even\n     * if they are available for performance reasons. If you are using\n     * this to get the initial text around the cursor, you may consider\n     * using {@link EditorInfo#getInitialTextBeforeCursor(int, int)},\n     * {@link EditorInfo#getInitialSelectedText(int)}, and\n     * {@link EditorInfo#getInitialTextAfterCursor(int, int)} to prevent IPC costs.</p>\n     *\n     * <p><strong>Editor authors:</strong> please be careful of race\n     * conditions in implementing this call. An IME can make a change\n     * to the text and use this method right away; you need to make\n     * sure the returned value is consistent with the result of the\n     * latest edits. Also, you may return less than n characters if performance\n     * dictates so, but keep in mind IMEs are relying on this for many\n     * functions: you should not, for example, limit the returned value to\n     * the current line, and specifically do not return 0 characters unless\n     * the cursor is really at the start of the text.</p>\n     *\n     * @param n The expected length of the text. This must be non-negative.\n     * @param flags Supplies additional options controlling how the text is\n     * returned. May be either {@code 0} or {@link #GET_TEXT_WITH_STYLES}.\n     * @return the text before the cursor position; the length of the\n     * returned text might be less than <var>n</var>.\n     * @throws IllegalArgumentException if {@code n} is negative.\n     ",
    "links" : [ "#GET_TEXT_WITH_STYLES", "android.text.SpannableString", "android.view.inputmethod.EditorInfo#getInitialTextBeforeCursor(int", "android.view.inputmethod.EditorInfo#getInitialSelectedText(int)", "android.view.inputmethod.EditorInfo#getInitialTextAfterCursor(int" ]
  }, {
    "name" : " CharSequence getTextAfterCursor(@IntRange(from = 0) int n, int flags)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Get <var>n</var> characters of text after the current cursor\n     * position.\n     *\n     * <p>This method may fail either if the input connection has\n     * become invalid (such as its process crashing) or the client is\n     * taking too long to respond with the text (it is given a couple\n     * seconds to return). In either case, null is returned.\n     *\n     * <p>This method does not affect the text in the editor in any\n     * way, nor does it affect the selection or composing spans.</p>\n     *\n     * <p>If {@link #GET_TEXT_WITH_STYLES} is supplied as flags, the\n     * editor should return a {@link android.text.SpannableString}\n     * with all the spans set on the text.</p>\n     *\n     * <p><strong>IME authors:</strong> please consider this will\n     * trigger an IPC round-trip that will take some time. Assume this\n     * method consumes a lot of time. If you are using this to get the\n     * initial text around the cursor, you may consider using\n     * {@link EditorInfo#getInitialTextBeforeCursor(int, int)},\n     * {@link EditorInfo#getInitialSelectedText(int)}, and\n     * {@link EditorInfo#getInitialTextAfterCursor(int, int)} to prevent IPC costs.</p>\n     *\n     * <p><strong>Editor authors:</strong> please be careful of race\n     * conditions in implementing this call. An IME can make a change\n     * to the text and use this method right away; you need to make\n     * sure the returned value is consistent with the result of the\n     * latest edits. Also, you may return less than n characters if performance\n     * dictates so, but keep in mind IMEs are relying on this for many\n     * functions: you should not, for example, limit the returned value to\n     * the current line, and specifically do not return 0 characters unless\n     * the cursor is really at the end of the text.</p>\n     *\n     * @param n The expected length of the text. This must be non-negative.\n     * @param flags Supplies additional options controlling how the text is\n     * returned. May be either {@code 0} or {@link #GET_TEXT_WITH_STYLES}.\n     *\n     * @return the text after the cursor position; the length of the\n     * returned text might be less than <var>n</var>.\n     * @throws IllegalArgumentException if {@code n} is negative.\n     ",
    "links" : [ "#GET_TEXT_WITH_STYLES", "android.text.SpannableString", "android.view.inputmethod.EditorInfo#getInitialTextBeforeCursor(int", "android.view.inputmethod.EditorInfo#getInitialSelectedText(int)", "android.view.inputmethod.EditorInfo#getInitialTextAfterCursor(int" ]
  }, {
    "name" : " CharSequence getSelectedText(int flags)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Gets the selected text, if any.\n     *\n     * <p>This method may fail if either the input connection has\n     * become invalid (such as its process crashing) or the client is\n     * taking too long to respond with the text (it is given a couple\n     * of seconds to return). In either case, null is returned.</p>\n     *\n     * <p>This method must not cause any changes in the editor's\n     * state.</p>\n     *\n     * <p>If {@link #GET_TEXT_WITH_STYLES} is supplied as flags, the\n     * editor should return a {@link android.text.SpannableString}\n     * with all the spans set on the text.</p>\n     *\n     * <p><strong>IME authors:</strong> please consider this will\n     * trigger an IPC round-trip that will take some time. Assume this\n     * method consumes a lot of time. If you are using this to get the\n     * initial text around the cursor, you may consider using\n     * {@link EditorInfo#getInitialTextBeforeCursor(int, int)},\n     * {@link EditorInfo#getInitialSelectedText(int)}, and\n     * {@link EditorInfo#getInitialTextAfterCursor(int, int)} to prevent IPC costs.</p>\n     *\n     * <p><strong>Editor authors:</strong> please be careful of race\n     * conditions in implementing this call. An IME can make a change\n     * to the text or change the selection position and use this\n     * method right away; you need to make sure the returned value is\n     * consistent with the results of the latest edits.</p>\n     *\n     * @param flags Supplies additional options controlling how the text is\n     * returned. May be either {@code 0} or {@link #GET_TEXT_WITH_STYLES}.\n     * @return the text that is currently selected, if any, or {@code null} if no text is selected.\n     ",
    "links" : [ "#GET_TEXT_WITH_STYLES", "android.text.SpannableString", "android.view.inputmethod.EditorInfo#getInitialTextBeforeCursor(int", "android.view.inputmethod.EditorInfo#getInitialSelectedText(int)", "android.view.inputmethod.EditorInfo#getInitialTextAfterCursor(int" ]
  }, {
    "name" : " SurroundingText getSurroundingText(@IntRange(from = 0) int beforeLength, @IntRange(from = 0) int afterLength, @GetTextType int flags)",
    "returnType" : "SurroundingText",
    "comment" : "\n     * Gets the surrounding text around the current cursor, with <var>beforeLength</var> characters\n     * of text before the cursor (start of the selection), <var>afterLength</var> characters of text\n     * after the cursor (end of the selection), and all of the selected text. The range are for java\n     * characters, not glyphs that can be multiple characters.\n     *\n     * <p>This method may fail either if the input connection has become invalid (such as its\n     * process crashing), or the client is taking too long to respond with the text (it is given a\n     * couple seconds to return), or the protocol is not supported. In any of these cases, null is\n     * returned.\n     *\n     * <p>This method does not affect the text in the editor in any way, nor does it affect the\n     * selection or composing spans.</p>\n     *\n     * <p>If {@link #GET_TEXT_WITH_STYLES} is supplied as flags, the editor should return a\n     * {@link android.text.Spanned} with all the spans set on the text.</p>\n     *\n     * <p><strong>IME authors:</strong> please consider this will trigger an IPC round-trip that\n     * will take some time. Assume this method consumes a lot of time. If you are using this to get\n     * the initial surrounding text around the cursor, you may consider using\n     * {@link EditorInfo#getInitialTextBeforeCursor(int, int)},\n     * {@link EditorInfo#getInitialSelectedText(int)}, and\n     * {@link EditorInfo#getInitialTextAfterCursor(int, int)} to prevent IPC costs.</p>\n     *\n     * @param beforeLength The expected length of the text before the cursor.\n     * @param afterLength The expected length of the text after the cursor.\n     * @param flags Supplies additional options controlling how the text is returned. May be either\n     *              {@code 0} or {@link #GET_TEXT_WITH_STYLES}.\n     * @return an {@link android.view.inputmethod.SurroundingText} object describing the surrounding\n     * text and state of selection, or null if the input connection is no longer valid, or the\n     * editor can't comply with the request for some reason, or the application does not implement\n     * this method. The length of the returned text might be less than the sum of\n     * <var>beforeLength</var> and <var>afterLength</var> .\n     * @throws IllegalArgumentException if {@code beforeLength} or {@code afterLength} is negative.\n     ",
    "links" : [ "#GET_TEXT_WITH_STYLES", "android.text.Spanned", "android.view.inputmethod.EditorInfo#getInitialTextBeforeCursor(int", "android.view.inputmethod.SurroundingText", "android.view.inputmethod.EditorInfo#getInitialSelectedText(int)", "android.view.inputmethod.EditorInfo#getInitialTextAfterCursor(int" ]
  }, {
    "name" : " int getCursorCapsMode(int reqModes)",
    "returnType" : "int",
    "comment" : "\n     * Retrieve the current capitalization mode in effect at the\n     * current cursor position in the text. See\n     * {@link android.text.TextUtils#getCapsMode TextUtils.getCapsMode}\n     * for more information.\n     *\n     * <p>This method may fail either if the input connection has\n     * become invalid (such as its process crashing) or the client is\n     * taking too long to respond with the text (it is given a couple\n     * seconds to return). In either case, 0 is returned.</p>\n     *\n     * <p>This method does not affect the text in the editor in any\n     * way, nor does it affect the selection or composing spans.</p>\n     *\n     * <p><strong>Editor authors:</strong> please be careful of race\n     * conditions in implementing this call. An IME can change the\n     * cursor position and use this method right away; you need to make\n     * sure the returned value is consistent with the results of the\n     * latest edits and changes to the cursor position.</p>\n     *\n     * @param reqModes The desired modes to retrieve, as defined by\n     * {@link android.text.TextUtils#getCapsMode TextUtils.getCapsMode}. These\n     * constants are defined so that you can simply pass the current\n     * {@link EditorInfo#inputType TextBoxAttribute.contentType} value\n     * directly in to here.\n     * @return the caps mode flags that are in effect at the current\n     * cursor position. See TYPE_TEXT_FLAG_CAPS_* in {@link android.text.InputType}.\n     ",
    "links" : [ "android.text.InputType", "android.view.inputmethod.EditorInfo#inputType", "android.text.TextUtils#getCapsMode" ]
  }, {
    "name" : " ExtractedText getExtractedText(ExtractedTextRequest request, int flags)",
    "returnType" : "ExtractedText",
    "comment" : "\n     * Retrieve the current text in the input connection's editor, and\n     * monitor for any changes to it. This function returns with the\n     * current text, and optionally the input connection can send\n     * updates to the input method when its text changes.\n     *\n     * <p>This method may fail either if the input connection has\n     * become invalid (such as its process crashing) or the client is\n     * taking too long to respond with the text (it is given a couple\n     * seconds to return). In either case, null is returned.</p>\n     *\n     * <p>Editor authors: as a general rule, try to comply with the\n     * fields in <code>request</code> for how many chars to return,\n     * but if performance or convenience dictates otherwise, please\n     * feel free to do what is most appropriate for your case. Also,\n     * if the\n     * {@link #GET_EXTRACTED_TEXT_MONITOR} flag is set, you should be\n     * calling\n     * {@link InputMethodManager#updateExtractedText(View, int, ExtractedText)}\n     * whenever you call\n     * {@link InputMethodManager#updateSelection(View, int, int, int, int)}.</p>\n     *\n     * @param request Description of how the text should be returned.\n     * {@link android.view.inputmethod.ExtractedTextRequest}\n     * @param flags Additional options to control the client, either {@code 0} or\n     * {@link #GET_EXTRACTED_TEXT_MONITOR}.\n\n     * @return an {@link android.view.inputmethod.ExtractedText}\n     * object describing the state of the text view and containing the\n     * extracted text itself, or null if the input connection is no\n     * longer valid of the editor can't comply with the request for\n     * some reason.\n     ",
    "links" : [ "android.view.inputmethod.InputMethodManager#updateExtractedText(View", "android.view.inputmethod.ExtractedTextRequest", "android.view.inputmethod.InputMethodManager#updateSelection(View", "android.view.inputmethod.ExtractedText", "#GET_EXTRACTED_TEXT_MONITOR" ]
  }, {
    "name" : " boolean deleteSurroundingText(int beforeLength, int afterLength)",
    "returnType" : "boolean",
    "comment" : "\n     * Delete <var>beforeLength</var> characters of text before the\n     * current cursor position, and delete <var>afterLength</var>\n     * characters of text after the current cursor position, excluding\n     * the selection. Before and after refer to the order of the\n     * characters in the string, not to their visual representation:\n     * this means you don't have to figure out the direction of the\n     * text and can just use the indices as-is.\n     *\n     * <p>The lengths are supplied in Java chars, not in code points\n     * or in glyphs.</p>\n     *\n     * <p>Since this method only operates on text before and after the\n     * selection, it can't affect the contents of the selection. This\n     * may affect the composing span if the span includes characters\n     * that are to be deleted, but otherwise will not change it. If\n     * some characters in the composing span are deleted, the\n     * composing span will persist but get shortened by however many\n     * chars inside it have been removed.</p>\n     *\n     * <p><strong>IME authors:</strong> please be careful not to\n     * delete only half of a surrogate pair. Also take care not to\n     * delete more characters than are in the editor, as that may have\n     * ill effects on the application. Calling this method will cause\n     * the editor to call\n     * {@link android.inputmethodservice.InputMethodService#onUpdateSelection(int, int, int, int,\n     * int, int)} on your service after the batch input is over.</p>\n     *\n     * <p><strong>Editor authors:</strong> please be careful of race\n     * conditions in implementing this call. An IME can make a change\n     * to the text or change the selection position and use this\n     * method right away; you need to make sure the effects are\n     * consistent with the results of the latest edits. Also, although\n     * the IME should not send lengths bigger than the contents of the\n     * string, you should check the values for overflows and trim the\n     * indices to the size of the contents to avoid crashes. Since\n     * this changes the contents of the editor, you need to make the\n     * changes known to the input method by calling\n     * {@link InputMethodManager#updateSelection(View, int, int, int, int)},\n     * but be careful to wait until the batch edit is over if one is\n     * in progress.</p>\n     *\n     * @param beforeLength The number of characters before the cursor to be deleted, in code unit.\n     *        If this is greater than the number of existing characters between the beginning of the\n     *        text and the cursor, then this method does not fail but deletes all the characters in\n     *        that range.\n     * @param afterLength The number of characters after the cursor to be deleted, in code unit.\n     *        If this is greater than the number of existing characters between the cursor and\n     *        the end of the text, then this method does not fail but deletes all the characters in\n     *        that range.\n     * @return true on success, false if the input connection is no longer valid.\n     ",
    "links" : [ "android.inputmethodservice.InputMethodService#onUpdateSelection(int", "android.view.inputmethod.InputMethodManager#updateSelection(View" ]
  }, {
    "name" : " boolean deleteSurroundingTextInCodePoints(int beforeLength, int afterLength)",
    "returnType" : "boolean",
    "comment" : "\n     * A variant of {@link #deleteSurroundingText(int, int)}. Major differences are:\n     *\n     * <ul>\n     *     <li>The lengths are supplied in code points, not in Java chars or in glyphs.</>\n     *     <li>This method does nothing if there are one or more invalid surrogate pairs in the\n     *     requested range.</li>\n     * </ul>\n     *\n     * <p><strong>Editor authors:</strong> In addition to the requirement in\n     * {@link #deleteSurroundingText(int, int)}, make sure to do nothing when one ore more invalid\n     * surrogate pairs are found in the requested range.</p>\n     *\n     * @see #deleteSurroundingText(int, int)\n     *\n     * @param beforeLength The number of characters before the cursor to be deleted, in code points.\n     *        If this is greater than the number of existing characters between the beginning of the\n     *        text and the cursor, then this method does not fail but deletes all the characters in\n     *        that range.\n     * @param afterLength The number of characters after the cursor to be deleted, in code points.\n     *        If this is greater than the number of existing characters between the cursor and\n     *        the end of the text, then this method does not fail but deletes all the characters in\n     *        that range.\n     * @return {@code true} on success, {@code false} if the input connection is no longer valid.\n     *         Before Android {@link android.os.Build.VERSION_CODES#TIRAMISU}, this API returned\n     *         {@code false} when the target application does not implement this method.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#TIRAMISU", "#deleteSurroundingText(int" ]
  }, {
    "name" : " boolean setComposingText(CharSequence text, int newCursorPosition)",
    "returnType" : "boolean",
    "comment" : "\n     * Replace the currently composing text with the given text, and\n     * set the new cursor position. Any composing text set previously\n     * will be removed automatically.\n     *\n     * <p>If there is any composing span currently active, all\n     * characters that it comprises are removed. The passed text is\n     * added in its place, and a composing span is added to this\n     * text. If there is no composing span active, the passed text is\n     * added at the cursor position (removing selected characters\n     * first if any), and a composing span is added on the new text.\n     * Finally, the cursor is moved to the location specified by\n     * <code>newCursorPosition</code>.</p>\n     *\n     * <p>This is usually called by IMEs to add or remove or change\n     * characters in the composing span. Calling this method will\n     * cause the editor to call\n     * {@link android.inputmethodservice.InputMethodService#onUpdateSelection(int, int, int, int,\n     * int, int)} on the current IME after the batch input is over.</p>\n     *\n     * <p><strong>Editor authors:</strong> please keep in mind the\n     * text may be very similar or completely different than what was\n     * in the composing span at call time, or there may not be a\n     * composing span at all. Please note that although it's not\n     * typical use, the string may be empty. Treat this normally,\n     * replacing the currently composing text with an empty string.\n     * Also, be careful with the cursor position. IMEs rely on this\n     * working exactly as described above. Since this changes the\n     * contents of the editor, you need to make the changes known to\n     * the input method by calling\n     * {@link InputMethodManager#updateSelection(View, int, int, int, int)},\n     * but be careful to wait until the batch edit is over if one is\n     * in progress. Note that this method can set the cursor position\n     * on either edge of the composing text or entirely outside it,\n     * but the IME may also go on to move the cursor position to\n     * within the composing text in a subsequent call so you should\n     * make no assumption at all: the composing text and the selection\n     * are entirely independent.</p>\n     *\n     * @param text The composing text with styles if necessary. If no style\n     *        object attached to the text, the default style for composing text\n     *        is used. See {@link android.text.Spanned} for how to attach style\n     *        object to the text. {@link android.text.SpannableString} and\n     *        {@link android.text.SpannableStringBuilder} are two\n     *        implementations of the interface {@link android.text.Spanned}.\n     * @param newCursorPosition The new cursor position around the text. If\n     *        > 0, this is relative to the end of the text - 1; if <= 0, this\n     *        is relative to the start of the text. So a value of 1 will\n     *        always advance you to the position after the full text being\n     *        inserted. Note that this means you can't position the cursor\n     *        within the text, because the editor can make modifications to\n     *        the text you are providing so it is not possible to correctly\n     *        specify locations there.\n     * @return true on success, false if the input connection is no longer\n     * valid.\n     ",
    "links" : [ "android.text.SpannableStringBuilder", "android.text.Spanned", "android.text.SpannableString", "android.inputmethodservice.InputMethodService#onUpdateSelection(int", "android.view.inputmethod.InputMethodManager#updateSelection(View" ]
  }, {
    "name" : " boolean setComposingText(@NonNull CharSequence text, int newCursorPosition, @Nullable TextAttribute textAttribute)",
    "returnType" : "boolean",
    "comment" : "\n     * The variant of {@link #setComposingText(CharSequence, int)}. This method is\n     * used to allow the IME to provide extra information while setting up composing text.\n     *\n     * @param text The composing text with styles if necessary. If no style\n     *        object attached to the text, the default style for composing text\n     *        is used. See {@link android.text.Spanned} for how to attach style\n     *        object to the text. {@link android.text.SpannableString} and\n     *        {@link android.text.SpannableStringBuilder} are two\n     *        implementations of the interface {@link android.text.Spanned}.\n     * @param newCursorPosition The new cursor position around the text. If\n     *        > 0, this is relative to the end of the text - 1; if <= 0, this\n     *        is relative to the start of the text. So a value of 1 will\n     *        always advance you to the position after the full text being\n     *        inserted. Note that this means you can't position the cursor\n     *        within the text, because the editor can make modifications to\n     *        the text you are providing so it is not possible to correctly\n     *        specify locations there.\n     * @param textAttribute The extra information about the text.\n     * @return true on success, false if the input connection is no longer\n     *\n     ",
    "links" : [ "android.text.SpannableStringBuilder", "android.text.Spanned", "#setComposingText(CharSequence", "android.text.SpannableString" ]
  }, {
    "name" : " boolean setComposingRegion(int start, int end)",
    "returnType" : "boolean",
    "comment" : "\n     * Mark a certain region of text as composing text. If there was a\n     * composing region, the characters are left as they were and the\n     * composing span removed, as if {@link #finishComposingText()}\n     * has been called. The default style for composing text is used.\n     *\n     * <p>The passed indices are clipped to the contents bounds. If\n     * the resulting region is zero-sized, no region is marked and the\n     * effect is the same as that of calling {@link #finishComposingText()}.\n     * The order of start and end is not important. In effect, the\n     * region from start to end and the region from end to start is\n     * the same. Editor authors, be ready to accept a start that is\n     * greater than end.</p>\n     *\n     * <p>Since this does not change the contents of the text, editors should not call\n     * {@link InputMethodManager#updateSelection(View, int, int, int, int)} and\n     * IMEs should not receive\n     * {@link android.inputmethodservice.InputMethodService#onUpdateSelection(int, int, int, int,\n     * int, int)}.</p>\n     *\n     * <p>This has no impact on the cursor/selection position. It may\n     * result in the cursor being anywhere inside or outside the\n     * composing region, including cases where the selection and the\n     * composing region overlap partially or entirely.</p>\n     *\n     * @param start the position in the text at which the composing region begins\n     * @param end the position in the text at which the composing region ends\n     * @return {@code true} on success, {@code false} if the input connection is no longer valid.\n     *         Since Android {@link android.os.Build.VERSION_CODES#N} until\n     *         {@link android.os.Build.VERSION_CODES#TIRAMISU}, this API returned {@code false} when\n     *         the target application does not implement this method.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#TIRAMISU", "android.inputmethodservice.InputMethodService#onUpdateSelection(int", "android.view.inputmethod.InputMethodManager#updateSelection(View", "#finishComposingText()", "android.os.Build.VERSION_CODES#N" ]
  }, {
    "name" : " boolean setComposingRegion(int start, int end, @Nullable TextAttribute textAttribute)",
    "returnType" : "boolean",
    "comment" : "\n     * The variant of {@link InputConnection#setComposingRegion(int, int)}. This method is\n     * used to allow the IME to provide extra information while setting up text.\n     *\n     * @param start the position in the text at which the composing region begins\n     * @param end the position in the text at which the composing region ends\n     * @param textAttribute The extra information about the text.\n     * @return {@code true} on success, {@code false} if the input connection is no longer valid.\n     *         Since Android {@link android.os.Build.VERSION_CODES#N} until\n     *         {@link android.os.Build.VERSION_CODES#TIRAMISU}, this API returned {@code false} when\n     *         the target application does not implement this method.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#TIRAMISU", "android.view.inputmethod.InputConnection#setComposingRegion(int", "android.os.Build.VERSION_CODES#N" ]
  }, {
    "name" : " boolean finishComposingText()",
    "returnType" : "boolean",
    "comment" : "\n     * Have the text editor finish whatever composing text is\n     * currently active. This simply leaves the text as-is, removing\n     * any special composing styling or other state that was around\n     * it. The cursor position remains unchanged.\n     *\n     * <p><strong>IME authors:</strong> be aware that this call may be\n     * expensive with some editors.</p>\n     *\n     * <p><strong>Editor authors:</strong> please note that the cursor\n     * may be anywhere in the contents when this is called, including\n     * in the middle of the composing span or in a completely\n     * unrelated place. It must not move.</p>\n     *\n     * @return true on success, false if the input connection\n     * is no longer valid.\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean commitText(CharSequence text, int newCursorPosition)",
    "returnType" : "boolean",
    "comment" : "\n     * Commit text to the text box and set the new cursor position.\n     *\n     * <p>This method removes the contents of the currently composing\n     * text and replaces it with the passed CharSequence, and then\n     * moves the cursor according to {@code newCursorPosition}. If there\n     * is no composing text when this method is called, the new text is\n     * inserted at the cursor position, removing text inside the selection\n     * if any. This behaves like calling\n     * {@link #setComposingText(CharSequence, int) setComposingText(text, newCursorPosition)}\n     * then {@link #finishComposingText()}.</p>\n     *\n     * <p>Calling this method will cause the editor to call\n     * {@link android.inputmethodservice.InputMethodService#onUpdateSelection(int, int, int, int,\n     * int, int)} on the current IME after the batch input is over.\n     * <strong>Editor authors</strong>, for this to happen you need to\n     * make the changes known to the input method by calling\n     * {@link InputMethodManager#updateSelection(View, int, int, int, int)},\n     * but be careful to wait until the batch edit is over if one is\n     * in progress.</p>\n     *\n     * @param text The text to commit. This may include styles.\n     * @param newCursorPosition The new cursor position around the text,\n     *        in Java characters. If > 0, this is relative to the end\n     *        of the text - 1; if <= 0, this is relative to the start\n     *        of the text. So a value of 1 will always advance the cursor\n     *        to the position after the full text being inserted. Note that\n     *        this means you can't position the cursor within the text,\n     *        because the editor can make modifications to the text\n     *        you are providing so it is not possible to correctly specify\n     *        locations there.\n     * @return true on success, false if the input connection is no longer\n     * valid.\n     ",
    "links" : [ "#setComposingText(CharSequence", "android.inputmethodservice.InputMethodService#onUpdateSelection(int", "android.view.inputmethod.InputMethodManager#updateSelection(View", "#finishComposingText()" ]
  }, {
    "name" : " boolean commitText(@NonNull CharSequence text, int newCursorPosition, @Nullable TextAttribute textAttribute)",
    "returnType" : "boolean",
    "comment" : "\n     * The variant of {@link InputConnection#commitText(CharSequence, int)}. This method is\n     * used to allow the IME to provide extra information while setting up text.\n     *\n     * @param text The text to commit. This may include styles.\n     * @param newCursorPosition The new cursor position around the text,\n     *        in Java characters. If > 0, this is relative to the end\n     *        of the text - 1; if <= 0, this is relative to the start\n     *        of the text. So a value of 1 will always advance the cursor\n     *        to the position after the full text being inserted. Note that\n     *        this means you can't position the cursor within the text,\n     *        because the editor can make modifications to the text\n     *        you are providing so it is not possible to correctly specify\n     *        locations there.\n     * @param textAttribute The extra information about the text.\n     * @return true on success, false if the input connection is no longer\n     ",
    "links" : [ "android.view.inputmethod.InputConnection#commitText(CharSequence" ]
  }, {
    "name" : " boolean commitCompletion(CompletionInfo text)",
    "returnType" : "boolean",
    "comment" : "\n     * Commit a completion the user has selected from the possible ones\n     * previously reported to {@link InputMethodSession#displayCompletions\n     * InputMethodSession#displayCompletions(CompletionInfo[])} or\n     * {@link InputMethodManager#displayCompletions\n     * InputMethodManager#displayCompletions(View, CompletionInfo[])}.\n     * This will result in the same behavior as if the user had\n     * selected the completion from the actual UI. In all other\n     * respects, this behaves like {@link #commitText(CharSequence, int)}.\n     *\n     * <p><strong>IME authors:</strong> please take care to send the\n     * same object that you received through\n     * {@link android.inputmethodservice.InputMethodService#onDisplayCompletions(CompletionInfo[])}.\n     * </p>\n     *\n     * <p><strong>Editor authors:</strong> if you never call\n     * {@link InputMethodSession#displayCompletions(CompletionInfo[])} or\n     * {@link InputMethodManager#displayCompletions(View, CompletionInfo[])} then\n     * a well-behaved IME should never call this on your input\n     * connection, but be ready to deal with misbehaving IMEs without\n     * crashing.</p>\n     *\n     * <p>Calling this method (with a valid {@link CompletionInfo} object)\n     * will cause the editor to call\n     * {@link android.inputmethodservice.InputMethodService#onUpdateSelection(int, int, int, int,\n     * int, int)} on the current IME after the batch input is over.\n     * <strong>Editor authors</strong>, for this to happen you need to\n     * make the changes known to the input method by calling\n     * {@link InputMethodManager#updateSelection(View, int, int, int, int)},\n     * but be careful to wait until the batch edit is over if one is\n     * in progress.</p>\n     *\n     * @param text The committed completion.\n     * @return true on success, false if the input connection is no longer\n     * valid.\n     ",
    "links" : [ "android.view.inputmethod.CompletionInfo", "android.inputmethodservice.InputMethodService#onDisplayCompletions(CompletionInfo", "android.inputmethodservice.InputMethodService#onUpdateSelection(int", "#commitText(CharSequence", "android.view.inputmethod.InputMethodManager#updateSelection(View", "android.view.inputmethod.InputMethodSession#displayCompletions(CompletionInfo", "android.view.inputmethod.InputMethodManager#displayCompletions(View", "android.view.inputmethod.InputMethodSession#displayCompletionsInputMethodSession", "android.view.inputmethod.InputMethodManager#displayCompletionsInputMethodManager" ]
  }, {
    "name" : " boolean commitCorrection(CorrectionInfo correctionInfo)",
    "returnType" : "boolean",
    "comment" : "\n     * Commit a correction automatically performed on the raw user's input. A\n     * typical example would be to correct typos using a dictionary.\n     *\n     * <p>Calling this method will cause the editor to call\n     * {@link android.inputmethodservice.InputMethodService#onUpdateSelection(int, int, int, int,\n     * int, int)} on the current IME after the batch input is over.\n     * <strong>Editor authors</strong>, for this to happen you need to\n     * make the changes known to the input method by calling\n     * {@link InputMethodManager#updateSelection(View, int, int, int, int)},\n     * but be careful to wait until the batch edit is over if one is\n     * in progress.</p>\n     *\n     * @param correctionInfo Detailed information about the correction.\n     * @return {@code true} on success, {@code false} if the input connection is no longer valid.\n     *         Since Android {@link android.os.Build.VERSION_CODES#N} until\n     *         {@link android.os.Build.VERSION_CODES#TIRAMISU}, this API returned {@code false} when\n     *         the target application does not implement this method.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#TIRAMISU", "android.inputmethodservice.InputMethodService#onUpdateSelection(int", "android.view.inputmethod.InputMethodManager#updateSelection(View", "android.os.Build.VERSION_CODES#N" ]
  }, {
    "name" : " boolean setSelection(int start, int end)",
    "returnType" : "boolean",
    "comment" : "\n     * Set the selection of the text editor. To set the cursor\n     * position, start and end should have the same value.\n     *\n     * <p>Since this moves the cursor, calling this method will cause\n     * the editor to call\n     * {@link android.inputmethodservice.InputMethodService#onUpdateSelection(int, int, int, int,\n     * int, int)} on the current IME after the batch input is over.\n     * <strong>Editor authors</strong>, for this to happen you need to\n     * make the changes known to the input method by calling\n     * {@link InputMethodManager#updateSelection(View, int, int, int, int)},\n     * but be careful to wait until the batch edit is over if one is\n     * in progress.</p>\n     *\n     * <p>This has no effect on the composing region which must stay\n     * unchanged. The order of start and end is not important. In\n     * effect, the region from start to end and the region from end to\n     * start is the same. Editor authors, be ready to accept a start\n     * that is greater than end.</p>\n     *\n     * @param start the character index where the selection should start.\n     * @param end the character index where the selection should end.\n     * @return true on success, false if the input connection is no longer\n     * valid.\n     ",
    "links" : [ "android.inputmethodservice.InputMethodService#onUpdateSelection(int", "android.view.inputmethod.InputMethodManager#updateSelection(View" ]
  }, {
    "name" : " boolean performEditorAction(int editorAction)",
    "returnType" : "boolean",
    "comment" : "\n     * Have the editor perform an action it has said it can do.\n     *\n     * <p>This is typically used by IMEs when the user presses the key\n     * associated with the action.</p>\n     *\n     * @param editorAction This must be one of the action constants for\n     * {@link EditorInfo#imeOptions EditorInfo.imeOptions}, such as\n     * {@link EditorInfo#IME_ACTION_GO EditorInfo.EDITOR_ACTION_GO}, or the value of\n     * {@link EditorInfo#actionId EditorInfo.actionId} if a custom action is available.\n     * @return true on success, false if the input connection is no longer\n     * valid.\n     ",
    "links" : [ "android.view.inputmethod.EditorInfo#actionId", "android.view.inputmethod.EditorInfo#IME_ACTION_GO", "android.view.inputmethod.EditorInfo#imeOptions" ]
  }, {
    "name" : " boolean performContextMenuAction(int id)",
    "returnType" : "boolean",
    "comment" : "\n     * Perform a context menu action on the field. The given id may be one of:\n     * {@link android.R.id#selectAll},\n     * {@link android.R.id#startSelectingText}, {@link android.R.id#stopSelectingText},\n     * {@link android.R.id#cut}, {@link android.R.id#copy},\n     * {@link android.R.id#paste}, {@link android.R.id#copyUrl},\n     * or {@link android.R.id#switchInputMethod}\n     ",
    "links" : [ "android.R.id#copyUrl", "android.R.id#paste", "android.R.id#cut", "android.R.id#selectAll", "android.R.id#stopSelectingText", "android.R.id#switchInputMethod", "android.R.id#copy", "android.R.id#startSelectingText" ]
  }, {
    "name" : " boolean beginBatchEdit()",
    "returnType" : "boolean",
    "comment" : "\n     * Tell the editor that you are starting a batch of editor\n     * operations. The editor will try to avoid sending you updates\n     * about its state until {@link #endBatchEdit} is called. Batch\n     * edits nest.\n     *\n     * <p><strong>IME authors:</strong> use this to avoid getting\n     * calls to\n     * {@link android.inputmethodservice.InputMethodService#onUpdateSelection(int, int, int, int,\n     * int, int)} corresponding to intermediate state. Also, use this to avoid\n     * flickers that may arise from displaying intermediate state. Be\n     * sure to call {@link #endBatchEdit} for each call to this, or\n     * you may block updates in the editor.</p>\n     *\n     * <p><strong>Editor authors:</strong> while a batch edit is in\n     * progress, take care not to send updates to the input method and\n     * not to update the display. IMEs use this intensively to this\n     * effect. Also please note that batch edits need to nest\n     * correctly.</p>\n     *\n     * @return true if a batch edit is now in progress, false otherwise. Since\n     * this method starts a batch edit, that means it will always return true\n     * unless the input connection is no longer valid.\n     ",
    "links" : [ "#endBatchEdit", "android.inputmethodservice.InputMethodService#onUpdateSelection(int" ]
  }, {
    "name" : " boolean endBatchEdit()",
    "returnType" : "boolean",
    "comment" : "\n     * Tell the editor that you are done with a batch edit previously initiated with\n     * {@link #beginBatchEdit()}. This ends the latest batch only.\n     *\n     * <p><strong>IME authors:</strong> make sure you call this exactly once for each call to\n     * {@link #beginBatchEdit()}.</p>\n     *\n     * <p><strong>Editor authors:</strong> please be careful about batch edit nesting. Updates still\n     * to be held back until the end of the last batch edit.  In case you are delegating this API\n     * call to the one obtained from\n     * {@link android.widget.EditText#onCreateInputConnection(EditorInfo)}, there was an off-by-one\n     * that had returned {@code true} when its nested batch edit count becomes {@code 0} as a result\n     * of invoking this API.  This bug is fixed in {@link android.os.Build.VERSION_CODES#TIRAMISU}.\n     * </p>\n     *\n     * @return For editor authors, you must return {@code true} if a batch edit is still in progress\n     *         after closing the latest one (in other words, if the nesting count is still a\n     *         positive number). Return {@code false} otherwise.  For IME authors, you will\n     *         always receive {@code true} as long as the request was sent to the editor, and\n     *         receive {@code false} only if the input connection is no longer valid.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#TIRAMISU", "#beginBatchEdit()", "android.widget.EditText#onCreateInputConnection(EditorInfo)" ]
  }, {
    "name" : " boolean sendKeyEvent(KeyEvent event)",
    "returnType" : "boolean",
    "comment" : "\n     * Send a key event to the process that is currently attached\n     * through this input connection. The event will be dispatched\n     * like a normal key event, to the currently focused view; this\n     * generally is the view that is providing this InputConnection,\n     * but due to the asynchronous nature of this protocol that can\n     * not be guaranteed and the focus may have changed by the time\n     * the event is received.\n     *\n     * <p>This method can be used to send key events to the\n     * application. For example, an on-screen keyboard may use this\n     * method to simulate a hardware keyboard. There are three types\n     * of standard keyboards, numeric (12-key), predictive (20-key)\n     * and ALPHA (QWERTY). You can specify the keyboard type by\n     * specify the device id of the key event.</p>\n     *\n     * <p>You will usually want to set the flag\n     * {@link KeyEvent#FLAG_SOFT_KEYBOARD KeyEvent.FLAG_SOFT_KEYBOARD}\n     * on all key event objects you give to this API; the flag will\n     * not be set for you.</p>\n     *\n     * <p>Note that it's discouraged to send such key events in normal\n     * operation; this is mainly for use with\n     * {@link android.text.InputType#TYPE_NULL} type text fields. Use\n     * the {@link #commitText} family of methods to send text to the\n     * application instead.</p>\n     *\n     * @param event The key event.\n     * @return true on success, false if the input connection is no longer\n     * valid.\n     *\n     * @see KeyEvent\n     * @see KeyCharacterMap#NUMERIC\n     * @see KeyCharacterMap#PREDICTIVE\n     * @see KeyCharacterMap#ALPHA\n     ",
    "links" : [ "android.view.KeyEvent#FLAG_SOFT_KEYBOARD", "#commitText", "android.text.InputType#TYPE_NULL" ]
  }, {
    "name" : " boolean clearMetaKeyStates(int states)",
    "returnType" : "boolean",
    "comment" : "\n     * Clear the given meta key pressed states in the given input\n     * connection.\n     *\n     * <p>This can be used by the IME to clear the meta key states set\n     * by a hardware keyboard with latched meta keys, if the editor\n     * keeps track of these.</p>\n     *\n     * @param states The states to be cleared, may be one or more bits as\n     * per {@link KeyEvent#getMetaState() KeyEvent.getMetaState()}.\n     * @return true on success, false if the input connection is no longer\n     * valid.\n     ",
    "links" : [ "android.view.KeyEvent#getMetaState()" ]
  }, {
    "name" : " boolean reportFullscreenMode(boolean enabled)",
    "returnType" : "boolean",
    "comment" : "\n     * Called back when the connected IME switches between fullscreen and normal modes.\n     *\n     * <p><p><strong>Editor authors:</strong> There is a bug on\n     * {@link android.os.Build.VERSION_CODES#O} and later devices that this method is called back\n     * on the main thread even when {@link #getHandler()} is overridden.  This bug is fixed in\n     * {@link android.os.Build.VERSION_CODES#TIRAMISU}.</p>\n     *\n     * <p><p><strong>IME authors:</strong> On {@link android.os.Build.VERSION_CODES#O} and later\n     * devices, input methods are no longer allowed to directly call this method at any time.\n     * To signal this event in the target application, input methods should always call\n     * {@link InputMethodService#updateFullscreenMode()} instead. This approach should work on API\n     * {@link android.os.Build.VERSION_CODES#N_MR1} and prior devices.</p>\n     *\n     * @return For editor authors, the return value will always be ignored. For IME authors, this\n     *         always returns {@code true} on {@link android.os.Build.VERSION_CODES#N_MR1} and prior\n     *         devices and {@code false} on {@link android.os.Build.VERSION_CODES#O} and later\n     *         devices.\n     * @see InputMethodManager#isFullscreenMode()\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#TIRAMISU", "android.os.Build.VERSION_CODES#O", "#getHandler()", "android.os.Build.VERSION_CODES#N_MR1", "android.inputmethodservice.InputMethodService#updateFullscreenMode()" ]
  }, {
    "name" : " boolean performSpellCheck()",
    "returnType" : "boolean",
    "comment" : "\n     * Have the editor perform spell checking for the full content.\n     *\n     * <p>The editor can ignore this method call if it does not support spell checking.\n     *\n     * @return For editor authors, the return value will always be ignored. For IME authors, this\n     *         method returns true if the spell check request was sent (whether or not the\n     *         associated editor supports spell checking), false if the input connection is no\n     *         longer valid.\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean performPrivateCommand(String action, Bundle data)",
    "returnType" : "boolean",
    "comment" : "\n     * API to send private commands from an input method to its\n     * connected editor. This can be used to provide domain-specific\n     * features that are only known between certain input methods and\n     * their clients. Note that because the InputConnection protocol\n     * is asynchronous, you have no way to get a result back or know\n     * if the client understood the command; you can use the\n     * information in {@link EditorInfo} to determine if a client\n     * supports a particular command.\n     *\n     * @param action Name of the command to be performed. This <em>must</em>\n     * be a scoped name, i.e. prefixed with a package name you own, so that\n     * different developers will not create conflicting commands.\n     * @param data Any data to include with the command.\n     * @return true if the command was sent (whether or not the\n     * associated editor understood it), false if the input connection is no longer\n     * valid.\n     ",
    "links" : [ "android.view.inputmethod.EditorInfo" ]
  }, {
    "name" : " void performHandwritingGesture(@NonNull HandwritingGesture gesture, @Nullable @CallbackExecutor Executor executor, @Nullable IntConsumer consumer)",
    "returnType" : "void",
    "comment" : "\n     * Perform a handwriting gesture on text.\n     *\n     * <p>Note: A supported gesture {@link EditorInfo#getSupportedHandwritingGestures()} may not\n     * have preview supported {@link EditorInfo#getSupportedHandwritingGesturePreviews()}.</p>\n     * @param gesture the gesture to perform\n     * @param executor The executor to run the callback on.\n     * @param consumer if the caller passes a non-null consumer, the editor must invoke this\n     * with one of {@link #HANDWRITING_GESTURE_RESULT_UNKNOWN},\n     * {@link #HANDWRITING_GESTURE_RESULT_SUCCESS}, {@link #HANDWRITING_GESTURE_RESULT_FAILED},\n     * {@link #HANDWRITING_GESTURE_RESULT_CANCELLED}, {@link #HANDWRITING_GESTURE_RESULT_FALLBACK},\n     * {@link #HANDWRITING_GESTURE_RESULT_UNSUPPORTED} after applying the {@code gesture} has\n     * completed. Will be invoked on the given {@link Executor}.\n     * Default implementation provides a callback to {@link IntConsumer} with\n     * {@link #HANDWRITING_GESTURE_RESULT_UNSUPPORTED}.\n     * @see #previewHandwritingGesture(PreviewableHandwritingGesture, CancellationSignal)\n     ",
    "links" : [ "#HANDWRITING_GESTURE_RESULT_CANCELLED", "android.view.inputmethod.EditorInfo#getSupportedHandwritingGestures()", "#HANDWRITING_GESTURE_RESULT_SUCCESS", "#HANDWRITING_GESTURE_RESULT_FAILED", "java.util.function.IntConsumer", "android.view.inputmethod.EditorInfo#getSupportedHandwritingGesturePreviews()", "android.annotation.CallbackExecutor", "#HANDWRITING_GESTURE_RESULT_UNKNOWN", "#HANDWRITING_GESTURE_RESULT_UNSUPPORTED", "#HANDWRITING_GESTURE_RESULT_FALLBACK" ]
  }, {
    "name" : " boolean previewHandwritingGesture(@NonNull PreviewableHandwritingGesture gesture, @Nullable CancellationSignal cancellationSignal)",
    "returnType" : "boolean",
    "comment" : "\n     * Preview a handwriting gesture on text.\n     * Provides a real-time preview for a gesture to user for an ongoing gesture. e.g. as user\n     * begins to draw a circle around text, resulting selection {@link SelectGesture} is previewed\n     * while stylus is moving over applicable text.\n     *\n     * <p>Note: A supported gesture {@link EditorInfo#getSupportedHandwritingGestures()} might not\n     * have preview supported {@link EditorInfo#getSupportedHandwritingGesturePreviews()}.</p>\n     * @param gesture the gesture to preview. Preview support for a gesture (regardless of whether\n     *  implemented by editor) can be determined if gesture subclasses\n     *  {@link PreviewableHandwritingGesture}. Supported previewable gestures include\n     *  {@link SelectGesture}, {@link SelectRangeGesture}, {@link DeleteGesture} and\n     *  {@link DeleteRangeGesture}.\n     * @param cancellationSignal signal to cancel an ongoing preview.\n     * @return true on successfully sending command to Editor, false if not implemented by editor or\n     * the input connection is no longer valid or preview was cancelled with\n     * {@link CancellationSignal}.\n     * @see #performHandwritingGesture(HandwritingGesture, Executor, IntConsumer)\n     ",
    "links" : [ "android.view.inputmethod.EditorInfo#getSupportedHandwritingGestures()", "android.view.inputmethod.PreviewableHandwritingGesture", "android.view.inputmethod.SelectRangeGesture", "android.view.inputmethod.DeleteRangeGesture", "android.view.inputmethod.DeleteGesture", "android.os.CancellationSignal", "android.view.inputmethod.EditorInfo#getSupportedHandwritingGesturePreviews()", "android.view.inputmethod.SelectGesture" ]
  }, {
    "name" : " boolean requestCursorUpdates(int cursorUpdateMode)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by the input method to ask the editor for calling back\n     * {@link InputMethodManager#updateCursorAnchorInfo(android.view.View, CursorAnchorInfo)} to\n     * notify cursor/anchor locations.\n     *\n     * @param cursorUpdateMode any combination of update modes and filters:\n     * {@link #CURSOR_UPDATE_IMMEDIATE}, {@link #CURSOR_UPDATE_MONITOR}, and data filters:\n     * {@link #CURSOR_UPDATE_FILTER_CHARACTER_BOUNDS}, {@link #CURSOR_UPDATE_FILTER_EDITOR_BOUNDS},\n     * {@link #CURSOR_UPDATE_FILTER_INSERTION_MARKER},\n     * {@link #CURSOR_UPDATE_FILTER_VISIBLE_LINE_BOUNDS},\n     * {@link #CURSOR_UPDATE_FILTER_TEXT_APPEARANCE}.\n     * Pass {@code 0} to disable them. However, if an unknown flag is provided, request will be\n     * rejected and method will return {@code false}.\n     * @return {@code true} if the request is scheduled. {@code false} to indicate that when the\n     *         application will not call {@link InputMethodManager#updateCursorAnchorInfo(\n     *         android.view.View, CursorAnchorInfo)}.\n     *         Since Android {@link android.os.Build.VERSION_CODES#N} until\n     *         {@link android.os.Build.VERSION_CODES#TIRAMISU}, this API returned {@code false} when\n     *         the target application does not implement this method.\n     ",
    "links" : [ "android.view.inputmethod.InputMethodManager#updateCursorAnchorInfo(", "android.os.Build.VERSION_CODES#TIRAMISU", "#CURSOR_UPDATE_MONITOR", "#CURSOR_UPDATE_FILTER_VISIBLE_LINE_BOUNDS", "#CURSOR_UPDATE_IMMEDIATE", "#CURSOR_UPDATE_FILTER_INSERTION_MARKER", "android.view.inputmethod.InputMethodManager#updateCursorAnchorInfo(android.view.View", "#CURSOR_UPDATE_FILTER_CHARACTER_BOUNDS", "#CURSOR_UPDATE_FILTER_TEXT_APPEARANCE", "android.os.Build.VERSION_CODES#N", "#CURSOR_UPDATE_FILTER_EDITOR_BOUNDS" ]
  }, {
    "name" : " boolean requestCursorUpdates(@CursorUpdateMode int cursorUpdateMode, @CursorUpdateFilter int cursorUpdateFilter)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by the input method to ask the editor for calling back\n     * {@link InputMethodManager#updateCursorAnchorInfo(android.view.View, CursorAnchorInfo)} to\n     * notify cursor/anchor locations.\n     *\n     * @param cursorUpdateMode combination of update modes:\n     * {@link #CURSOR_UPDATE_IMMEDIATE}, {@link #CURSOR_UPDATE_MONITOR}\n     * @param cursorUpdateFilter any combination of data filters:\n     * {@link #CURSOR_UPDATE_FILTER_CHARACTER_BOUNDS}, {@link #CURSOR_UPDATE_FILTER_EDITOR_BOUNDS},\n     * {@link #CURSOR_UPDATE_FILTER_INSERTION_MARKER},\n     * {@link #CURSOR_UPDATE_FILTER_VISIBLE_LINE_BOUNDS},\n     * {@link #CURSOR_UPDATE_FILTER_TEXT_APPEARANCE}.\n     *\n     * <p>Pass {@code 0} to disable them. However, if an unknown flag is provided, request will be\n     * rejected and method will return {@code false}.</p>\n     * @return {@code true} if the request is scheduled. {@code false} to indicate that when the\n     *         application will not call {@link InputMethodManager#updateCursorAnchorInfo(\n     *         android.view.View, CursorAnchorInfo)}.\n     *         Since Android {@link android.os.Build.VERSION_CODES#N} until\n     *         {@link android.os.Build.VERSION_CODES#TIRAMISU}, this API returned {@code false} when\n     *         the target application does not implement this method.\n     ",
    "links" : [ "android.view.inputmethod.InputMethodManager#updateCursorAnchorInfo(", "android.os.Build.VERSION_CODES#TIRAMISU", "#CURSOR_UPDATE_MONITOR", "#CURSOR_UPDATE_FILTER_VISIBLE_LINE_BOUNDS", "#CURSOR_UPDATE_IMMEDIATE", "#CURSOR_UPDATE_FILTER_INSERTION_MARKER", "android.view.inputmethod.InputMethodManager#updateCursorAnchorInfo(android.view.View", "#CURSOR_UPDATE_FILTER_CHARACTER_BOUNDS", "#CURSOR_UPDATE_FILTER_TEXT_APPEARANCE", "android.os.Build.VERSION_CODES#N", "#CURSOR_UPDATE_FILTER_EDITOR_BOUNDS" ]
  }, {
    "name" : " void requestTextBoundsInfo(@NonNull RectF bounds, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<TextBoundsInfoResult> consumer)",
    "returnType" : "void",
    "comment" : "\n     * Called by input method to request the {@link TextBoundsInfo} for a range of text which is\n     * covered by or in vicinity of the given {@code bounds}. It can be used as a supplementary\n     * method to implement the handwriting gesture API -\n     * {@link #performHandwritingGesture(HandwritingGesture, Executor, IntConsumer)}.\n     *\n     * <p><strong>Editor authors</strong>: It's preferred that the editor returns a\n     * {@link TextBoundsInfo} of all the text lines whose bounds intersect with the given\n     * {@code bounds}.\n     * </p>\n     *\n     * <p><strong>IME authors</strong>: This method is expensive when the text is long. Please\n     * consider that both the text bounds computation and IPC round-trip to send the data are time\n     * consuming. It's preferable to only request text bounds in smaller areas.\n     * </p>\n     *\n     * @param bounds the interested area where the text bounds are requested, in the screen\n     *              coordinates.\n     * @param executor the executor to run the callback.\n     * @param consumer the callback invoked by editor to return the result. It must return a\n     *                 non-null object.\n     *\n     * @see TextBoundsInfo\n     * @see android.view.inputmethod.TextBoundsInfoResult\n     ",
    "links" : [ "android.view.inputmethod.TextBoundsInfo", "#performHandwritingGesture(HandwritingGesture" ]
  }, {
    "name" : " Handler getHandler()",
    "returnType" : "Handler",
    "comment" : "\n     * Called by the system to enable application developers to specify a dedicated thread on which\n     * {@link InputConnection} methods are called back.\n     *\n     * <p><strong>Editor authors</strong>: although you can return your custom subclasses of\n     * {@link Handler}, the system only uses {@link android.os.Looper} returned from\n     * {@link Handler#getLooper()}.  You cannot intercept or cancel {@link InputConnection}\n     * callbacks by implementing this method.</p>\n     *\n     * <p><strong>IME authors</strong>: This method is not intended to be called from the IME.  You\n     * will always receive {@code null}.</p>\n     *\n     * @return {@code null} to use the default {@link Handler}.\n     ",
    "links" : [ "android.os.Handler#getLooper()", "android.view.inputmethod.InputConnection", "android.os.Handler", "android.os.Looper" ]
  }, {
    "name" : " void closeConnection()",
    "returnType" : "void",
    "comment" : "\n     * Called by the system up to only once to notify that the system is about to invalidate\n     * connection between the input method and the application.\n     *\n     * <p><strong>Editor authors</strong>: You can clear all the nested batch edit right now and\n     * you no longer need to handle subsequent callbacks on this connection, including\n     * {@link #beginBatchEdit()}}.  Note that although the system tries to call this method whenever\n     * possible, there may be a chance that this method is not called in some exceptional\n     * situations.</p>\n     *\n     * <p>Note: This does nothing when called from input methods.</p>\n     ",
    "links" : [ "#beginBatchEdit()" ]
  }, {
    "name" : " boolean commitContent(@NonNull InputContentInfo inputContentInfo, int flags, @Nullable Bundle opts)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by the input method to commit content such as a PNG image to the editor.\n     *\n     * <p>In order to avoid a variety of compatibility issues, this focuses on a simple use case,\n     * where editors and IMEs are expected to work cooperatively as follows:</p>\n     * <ul>\n     *     <li>Editor must keep {@link EditorInfo#contentMimeTypes} equal to {@code null} if it does\n     *     not support this method at all.</li>\n     *     <li>Editor can ignore this request when the MIME type specified in\n     *     {@code inputContentInfo} does not match any of {@link EditorInfo#contentMimeTypes}.\n     *     </li>\n     *     <li>Editor can ignore the cursor position when inserting the provided content.</li>\n     *     <li>Editor can return {@code true} asynchronously, even before it starts loading the\n     *     content.</li>\n     *     <li>Editor should provide a way to delete the content inserted by this method or to\n     *     revert the effect caused by this method.</li>\n     *     <li>IME should not call this method when there is any composing text, in case calling\n     *     this method causes a focus change.</li>\n     *     <li>IME should grant a permission for the editor to read the content. See\n     *     {@link EditorInfo#packageName} about how to obtain the package name of the editor.</li>\n     * </ul>\n     *\n     * @param inputContentInfo Content to be inserted.\n     * @param flags {@link #INPUT_CONTENT_GRANT_READ_URI_PERMISSION} if the content provider\n     * allows {@link android.R.styleable#AndroidManifestProvider_grantUriPermissions\n     * grantUriPermissions} or {@code 0} if the application does not need to call\n     * {@link InputContentInfo#requestPermission()}.\n     * @param opts optional bundle data. This can be {@code null}.\n     * @return {@code true} if this request is accepted by the application, whether the request\n     * is already handled or still being handled in background, {@code false} otherwise.\n     ",
    "links" : [ "android.view.inputmethod.EditorInfo#packageName", "android.view.inputmethod.InputContentInfo#requestPermission()", "#INPUT_CONTENT_GRANT_READ_URI_PERMISSION", "android.R.styleable#AndroidManifestProvider_grantUriPermissionsgrantUriPermissions", "android.view.inputmethod.EditorInfo#contentMimeTypes" ]
  }, {
    "name" : " boolean setImeConsumesInput(boolean imeConsumesInput)",
    "returnType" : "boolean",
    "comment" : "\n     * Called by the input method to indicate that it consumes all input for itself, or no longer\n     * does so.\n     *\n     * <p>Editors should reflect that they are not receiving input by hiding the cursor if\n     * {@code imeConsumesInput} is {@code true}, and resume showing the cursor if it is\n     * {@code false}.\n     *\n     * @param imeConsumesInput {@code true} when the IME is consuming input and the cursor should be\n     * hidden, {@code false} when input to the editor resumes and the cursor should be shown again.\n     * @return For editor authors, the return value will always be ignored. For IME authors, this\n     *         method returns {@code true} if the request was sent (whether or not the associated\n     *         editor does something based on this request), {@code false} if the input connection\n     *         is no longer valid.\n     ",
    "links" : [ ]
  }, {
    "name" : " TextSnapshot takeSnapshot()",
    "returnType" : "TextSnapshot",
    "comment" : "\n     * Called by the system when it needs to take a snapshot of multiple text-related data in an\n     * atomic manner.\n     *\n     * <p><strong>Editor authors</strong>: Supporting this method is strongly encouraged. Atomically\n     * taken {@link TextSnapshot} is going to be really helpful for the system when optimizing IPCs\n     * in a safe and deterministic manner.  Return {@code null} if an atomically taken\n     * {@link TextSnapshot} is unavailable.  The system continues supporting such a scenario\n     * gracefully.</p>\n     *\n     * <p><strong>IME authors</strong>: Currently IMEs cannot call this method directly and always\n     * receive {@code null} as the result.</p>\n     *\n     * @return {@code null} if {@link TextSnapshot} is unavailable and/or this API is called from\n     *         IMEs.\n     ",
    "links" : [ "android.view.inputmethod.TextSnapshot" ]
  }, {
    "name" : " boolean replaceText(@IntRange(from = 0) int start, @IntRange(from = 0) int end, @NonNull CharSequence text, int newCursorPosition, @Nullable TextAttribute textAttribute)",
    "returnType" : "boolean",
    "comment" : "\n     * Replace the specific range in the editor with suggested text.\n     *\n     * <p>This method finishes whatever composing text is currently active and leaves the text\n     * as-it, replaces the specific range of text with the passed CharSequence, and then moves the\n     * cursor according to {@code newCursorPosition}. This behaves like calling {@link\n     * #finishComposingText()}, {@link #setSelection(int, int) setSelection(start, end)}, and then\n     * {@link #commitText(CharSequence, int, TextAttribute) commitText(text, newCursorPosition,\n     * textAttribute)}.\n     *\n     * <p>Similar to {@link #setSelection(int, int)}, the order of start and end is not important.\n     * In effect, the region from start to end and the region from end to start is the same. Editor\n     * authors, be ready to accept a start that is greater than end.\n     *\n     * @param start the character index where the replacement should start.\n     * @param end the character index where the replacement should end.\n     * @param newCursorPosition the new cursor position around the text. If > 0, this is relative to\n     *     the end of the text - 1; if <= 0, this is relative to the start of the text. So a value\n     *     of 1 will always advance you to the position after the full text being inserted. Note\n     *     that this means you can't position the cursor within the text.\n     * @param text the text to replace. This may include styles.\n     * @param textAttribute The extra information about the text. This value may be null.\n     * @return {@code true} if the replace command was sent to the associated editor (regardless of\n     *     whether the replacement is success or not), {@code false} otherwise.\n     ",
    "links" : [ "#setSelection(int", "#commitText(CharSequence", "#finishComposingText()" ]
  } ],
  "methodNames" : [ " CharSequence getTextBeforeCursor(@IntRange(from = 0) int n, int flags)", " CharSequence getTextAfterCursor(@IntRange(from = 0) int n, int flags)", " CharSequence getSelectedText(int flags)", " SurroundingText getSurroundingText(@IntRange(from = 0) int beforeLength, @IntRange(from = 0) int afterLength, @GetTextType int flags)", " int getCursorCapsMode(int reqModes)", " ExtractedText getExtractedText(ExtractedTextRequest request, int flags)", " boolean deleteSurroundingText(int beforeLength, int afterLength)", " boolean deleteSurroundingTextInCodePoints(int beforeLength, int afterLength)", " boolean setComposingText(CharSequence text, int newCursorPosition)", " boolean setComposingText(@NonNull CharSequence text, int newCursorPosition, @Nullable TextAttribute textAttribute)", " boolean setComposingRegion(int start, int end)", " boolean setComposingRegion(int start, int end, @Nullable TextAttribute textAttribute)", " boolean finishComposingText()", " boolean commitText(CharSequence text, int newCursorPosition)", " boolean commitText(@NonNull CharSequence text, int newCursorPosition, @Nullable TextAttribute textAttribute)", " boolean commitCompletion(CompletionInfo text)", " boolean commitCorrection(CorrectionInfo correctionInfo)", " boolean setSelection(int start, int end)", " boolean performEditorAction(int editorAction)", " boolean performContextMenuAction(int id)", " boolean beginBatchEdit()", " boolean endBatchEdit()", " boolean sendKeyEvent(KeyEvent event)", " boolean clearMetaKeyStates(int states)", " boolean reportFullscreenMode(boolean enabled)", " boolean performSpellCheck()", " boolean performPrivateCommand(String action, Bundle data)", " void performHandwritingGesture(@NonNull HandwritingGesture gesture, @Nullable @CallbackExecutor Executor executor, @Nullable IntConsumer consumer)", " boolean previewHandwritingGesture(@NonNull PreviewableHandwritingGesture gesture, @Nullable CancellationSignal cancellationSignal)", " boolean requestCursorUpdates(int cursorUpdateMode)", " boolean requestCursorUpdates(@CursorUpdateMode int cursorUpdateMode, @CursorUpdateFilter int cursorUpdateFilter)", " void requestTextBoundsInfo(@NonNull RectF bounds, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<TextBoundsInfoResult> consumer)", " Handler getHandler()", " void closeConnection()", " boolean commitContent(@NonNull InputContentInfo inputContentInfo, int flags, @Nullable Bundle opts)", " boolean setImeConsumesInput(boolean imeConsumesInput)", " TextSnapshot takeSnapshot()", " boolean replaceText(@IntRange(from = 0) int start, @IntRange(from = 0) int end, @NonNull CharSequence text, int newCursorPosition, @Nullable TextAttribute textAttribute)" ],
  "variableNames" : [ "GET_TEXT_WITH_STYLES", "GET_EXTRACTED_TEXT_MONITOR", "HANDWRITING_GESTURE_RESULT_UNKNOWN", "HANDWRITING_GESTURE_RESULT_SUCCESS", "HANDWRITING_GESTURE_RESULT_UNSUPPORTED", "HANDWRITING_GESTURE_RESULT_FAILED", "HANDWRITING_GESTURE_RESULT_CANCELLED", "HANDWRITING_GESTURE_RESULT_FALLBACK", "CURSOR_UPDATE_IMMEDIATE", "CURSOR_UPDATE_MONITOR", "CURSOR_UPDATE_FILTER_EDITOR_BOUNDS", "CURSOR_UPDATE_FILTER_CHARACTER_BOUNDS", "CURSOR_UPDATE_FILTER_INSERTION_MARKER", "CURSOR_UPDATE_FILTER_VISIBLE_LINE_BOUNDS", "CURSOR_UPDATE_FILTER_TEXT_APPEARANCE", "INPUT_CONTENT_GRANT_READ_URI_PERMISSION" ]
}