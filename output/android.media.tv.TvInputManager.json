{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/media/tv/TvInputManager.java",
  "packageName" : "android.media.tv",
  "className" : "TvInputManager",
  "comment" : "\n * Central system API to the overall TV input framework (TIF) architecture, which arbitrates\n * interaction between applications and the selected TV inputs.\n *\n * <p>There are three primary parties involved in the TV input framework (TIF) architecture:\n *\n * <ul>\n * <li>The <strong>TV input manager</strong> as expressed by this class is the central point of the\n * system that manages interaction between all other parts. It is expressed as the client-side API\n * here which exists in each application context and communicates with a global system service that\n * manages the interaction across all processes.\n * <li>A <strong>TV input</strong> implemented by {@link TvInputService} represents an input source\n * of TV, which can be a pass-through input such as HDMI, or a tuner input which provides broadcast\n * TV programs. The system binds to the TV input per applicationâ€™s request.\n * on implementing TV inputs.\n * <li><strong>Applications</strong> talk to the TV input manager to list TV inputs and check their\n * status. Once an application find the input to use, it uses {@link TvView} or\n * {@link TvRecordingClient} for further interaction such as watching and recording broadcast TV\n * programs.\n * </ul>\n ",
  "links" : [ "android.media.tv.TvInputService", "android.media.tv.TvView", "android.media.tv.TvRecordingClient" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DVB_DEVICE_START",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DVB_DEVICE_END",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DVB_DEVICE_DEMUX",
    "type" : "int",
    "comment" : "\n     * A demux device of DVB API for controlling the filters of DVB hardware/software.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DVB_DEVICE_DVR",
    "type" : "int",
    "comment" : "\n     * A DVR device of DVB API for reading transport streams.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DVB_DEVICE_FRONTEND",
    "type" : "int",
    "comment" : "\n     * A frontend device of DVB API for controlling the tuner and DVB demodulator hardware.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TV_MESSAGE_TYPE_WATERMARK",
    "type" : "int",
    "comment" : " Indicates that this TV message contains watermarking data ",
    "links" : [ ]
  }, {
    "name" : "TV_MESSAGE_TYPE_CLOSED_CAPTION",
    "type" : "int",
    "comment" : " Indicates that this TV message contains Closed Captioning data ",
    "links" : [ ]
  }, {
    "name" : "TV_MESSAGE_TYPE_OTHER",
    "type" : "int",
    "comment" : " Indicates that this TV message contains other data ",
    "links" : [ ]
  }, {
    "name" : "TV_MESSAGE_KEY_STREAM_ID",
    "type" : "String",
    "comment" : "\n     * This constant is used as a {@link Bundle} key for TV messages. The value of the key\n     * identifies the stream on the TV input source for which the watermark event is relevant to.\n     *\n     * <p> Type: String\n     ",
    "links" : [ "android.os.Bundle" ]
  }, {
    "name" : "TV_MESSAGE_GROUP_ID_NONE",
    "type" : "long",
    "comment" : "\n     * This value for {@link #TV_MESSAGE_KEY_GROUP_ID} denotes that the message doesn't\n     * belong to any group.\n     ",
    "links" : [ "#TV_MESSAGE_KEY_GROUP_ID" ]
  }, {
    "name" : "TV_MESSAGE_KEY_GROUP_ID",
    "type" : "String",
    "comment" : "\n     * This constant is used as a {@link Bundle} key for TV messages. This is used to\n     * optionally identify messages that belong together, such as headers and bodies\n     * of the same event. For messages that do not have a group, this value\n     * should be {@link #TV_MESSAGE_GROUP_ID_NONE}.\n     *\n     * <p> As -1 is a reserved value, -1 should not be used as a valid groupId.\n     *\n     * <p> Type: long\n     ",
    "links" : [ "android.os.Bundle", "#TV_MESSAGE_GROUP_ID_NONE" ]
  }, {
    "name" : "TV_MESSAGE_SUBTYPE_WATERMARKING_A335",
    "type" : "String",
    "comment" : "\n     * This is a subtype for TV messages that can be potentially found as a value\n     * at {@link #TV_MESSAGE_KEY_SUBTYPE}. It identifies the subtype of the message\n     * as the watermarking format ATSC A/335.\n     ",
    "links" : [ "#TV_MESSAGE_KEY_SUBTYPE" ]
  }, {
    "name" : "TV_MESSAGE_SUBTYPE_CC_608E",
    "type" : "String",
    "comment" : "\n     * This is a subtype for TV messages that can be potentially found as a value\n     * at {@link #TV_MESSAGE_KEY_SUBTYPE}. It identifies the subtype of the message\n     * as the CC format CTA 608-E.\n     ",
    "links" : [ "#TV_MESSAGE_KEY_SUBTYPE" ]
  }, {
    "name" : "TV_MESSAGE_KEY_SUBTYPE",
    "type" : "String",
    "comment" : "\n     * This constant is used as a {@link Bundle} key for TV messages. The value of the key\n     * identifies the subtype of the data, such as the format of the CC data. The format\n     * found at this key can then be used to identify how to parse the data at\n     * {@link #TV_MESSAGE_KEY_RAW_DATA}.\n     *\n     * <p> To parse the raw data based on the subtype, please refer to the official\n     * documentation of the concerning subtype. For example, for the subtype\n     * {@link #TV_MESSAGE_SUBTYPE_WATERMARKING_A335}, the document for A/335 from the ATSC\n     * standard details how this data is formatted. Similarly, the subtype\n     * {@link #TV_MESSAGE_SUBTYPE_CC_608E} is documented in the ANSI/CTA standard for\n     * 608-E. These subtypes are examples of common formats for their respective uses\n     * and other subtypes may exist.\n     *\n     * <p> Type: String\n     ",
    "links" : [ "#TV_MESSAGE_KEY_RAW_DATA", "#TV_MESSAGE_SUBTYPE_WATERMARKING_A335", "android.os.Bundle", "#TV_MESSAGE_SUBTYPE_CC_608E" ]
  }, {
    "name" : "TV_MESSAGE_KEY_RAW_DATA",
    "type" : "String",
    "comment" : "\n     * This constant is used as a {@link Bundle} key for TV messages. The value of the key\n     * stores the raw data contained in this TV message. The format of this data is determined\n     * by the format defined by the subtype, found using the key at\n     * {@link #TV_MESSAGE_KEY_SUBTYPE}. See {@link #TV_MESSAGE_KEY_SUBTYPE} for more\n     * information on how to parse this data.\n     *\n     * <p> Type: byte[]\n     ",
    "links" : [ "android.os.Bundle", "#TV_MESSAGE_KEY_SUBTYPE" ]
  }, {
    "name" : "VIDEO_UNAVAILABLE_REASON_START",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "VIDEO_UNAVAILABLE_REASON_END",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "VIDEO_UNAVAILABLE_REASON_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Reason for {@link TvInputService.Session#notifyVideoUnavailable(int)} and\n     * {@link TvView.TvInputCallback#onVideoUnavailable(String, int)}: Video is unavailable due to\n     * an unspecified error.\n     ",
    "links" : [ "TvView.TvInputCallback#onVideoUnavailable(String", "TvInputService.Session#notifyVideoUnavailable(int)" ]
  }, {
    "name" : "VIDEO_UNAVAILABLE_REASON_TUNING",
    "type" : "int",
    "comment" : "\n     * Reason for {@link TvInputService.Session#notifyVideoUnavailable(int)} and\n     * {@link TvView.TvInputCallback#onVideoUnavailable(String, int)}: Video is unavailable because\n     * the corresponding TV input is in the middle of tuning to a new channel.\n     ",
    "links" : [ "TvView.TvInputCallback#onVideoUnavailable(String", "TvInputService.Session#notifyVideoUnavailable(int)" ]
  }, {
    "name" : "VIDEO_UNAVAILABLE_REASON_WEAK_SIGNAL",
    "type" : "int",
    "comment" : "\n     * Reason for {@link TvInputService.Session#notifyVideoUnavailable(int)} and\n     * {@link TvView.TvInputCallback#onVideoUnavailable(String, int)}: Video is unavailable due to\n     * weak TV signal.\n     ",
    "links" : [ "TvView.TvInputCallback#onVideoUnavailable(String", "TvInputService.Session#notifyVideoUnavailable(int)" ]
  }, {
    "name" : "VIDEO_UNAVAILABLE_REASON_BUFFERING",
    "type" : "int",
    "comment" : "\n     * Reason for {@link TvInputService.Session#notifyVideoUnavailable(int)} and\n     * {@link TvView.TvInputCallback#onVideoUnavailable(String, int)}: Video is unavailable because\n     * the corresponding TV input has stopped playback temporarily to buffer more data.\n     ",
    "links" : [ "TvView.TvInputCallback#onVideoUnavailable(String", "TvInputService.Session#notifyVideoUnavailable(int)" ]
  }, {
    "name" : "VIDEO_UNAVAILABLE_REASON_AUDIO_ONLY",
    "type" : "int",
    "comment" : "\n     * Reason for {@link TvInputService.Session#notifyVideoUnavailable(int)} and\n     * {@link TvView.TvInputCallback#onVideoUnavailable(String, int)}: Video is unavailable because\n     * the current TV program is audio-only.\n     ",
    "links" : [ "TvView.TvInputCallback#onVideoUnavailable(String", "TvInputService.Session#notifyVideoUnavailable(int)" ]
  }, {
    "name" : "VIDEO_UNAVAILABLE_REASON_NOT_CONNECTED",
    "type" : "int",
    "comment" : "\n     * Reason for {@link TvInputService.Session#notifyVideoUnavailable(int)} and\n     * {@link TvView.TvInputCallback#onVideoUnavailable(String, int)}: Video is unavailable because\n     * the source is not physically connected, for example the HDMI cable is not connected.\n     ",
    "links" : [ "TvView.TvInputCallback#onVideoUnavailable(String", "TvInputService.Session#notifyVideoUnavailable(int)" ]
  }, {
    "name" : "VIDEO_UNAVAILABLE_REASON_INSUFFICIENT_RESOURCE",
    "type" : "int",
    "comment" : "\n     * Reason for {@link TvInputService.Session#notifyVideoUnavailable(int)} and\n     * {@link TvView.TvInputCallback#onVideoUnavailable(String, int)}: Video is unavailable because\n     * the resource is not enough to meet requirement.\n     ",
    "links" : [ "TvView.TvInputCallback#onVideoUnavailable(String", "TvInputService.Session#notifyVideoUnavailable(int)" ]
  }, {
    "name" : "VIDEO_UNAVAILABLE_REASON_CAS_INSUFFICIENT_OUTPUT_PROTECTION",
    "type" : "int",
    "comment" : "\n     * Reason for {@link TvInputService.Session#notifyVideoUnavailable(int)} and\n     * {@link TvView.TvInputCallback#onVideoUnavailable(String, int)}: Video is unavailable because\n     * the output protection level enabled on the device is not sufficient to meet the requirements\n     * in the license policy.\n     ",
    "links" : [ "TvView.TvInputCallback#onVideoUnavailable(String", "TvInputService.Session#notifyVideoUnavailable(int)" ]
  }, {
    "name" : "VIDEO_UNAVAILABLE_REASON_CAS_PVR_RECORDING_NOT_ALLOWED",
    "type" : "int",
    "comment" : "\n     * Reason for {@link TvInputService.Session#notifyVideoUnavailable(int)} and\n     * {@link TvView.TvInputCallback#onVideoUnavailable(String, int)}: Video is unavailable because\n     * the PVR record is not allowed by the license policy.\n     ",
    "links" : [ "TvView.TvInputCallback#onVideoUnavailable(String", "TvInputService.Session#notifyVideoUnavailable(int)" ]
  }, {
    "name" : "VIDEO_UNAVAILABLE_REASON_CAS_NO_LICENSE",
    "type" : "int",
    "comment" : "\n     * Reason for {@link TvInputService.Session#notifyVideoUnavailable(int)} and\n     * {@link TvView.TvInputCallback#onVideoUnavailable(String, int)}: Video is unavailable because\n     * no license keys have been provided.\n     * @hide\n     ",
    "links" : [ "TvView.TvInputCallback#onVideoUnavailable(String", "TvInputService.Session#notifyVideoUnavailable(int)" ]
  }, {
    "name" : "VIDEO_UNAVAILABLE_REASON_CAS_LICENSE_EXPIRED",
    "type" : "int",
    "comment" : "\n     * Reason for {@link TvInputService.Session#notifyVideoUnavailable(int)} and\n     * {@link TvView.TvInputCallback#onVideoUnavailable(String, int)}: Video is unavailable because\n     * Using a license in whhich the keys have expired.\n     ",
    "links" : [ "TvView.TvInputCallback#onVideoUnavailable(String", "TvInputService.Session#notifyVideoUnavailable(int)" ]
  }, {
    "name" : "VIDEO_UNAVAILABLE_REASON_CAS_NEED_ACTIVATION",
    "type" : "int",
    "comment" : "\n     * Reason for {@link TvInputService.Session#notifyVideoUnavailable(int)} and\n     * {@link TvView.TvInputCallback#onVideoUnavailable(String, int)}: Video is unavailable because\n     * the device need be activated.\n     ",
    "links" : [ "TvView.TvInputCallback#onVideoUnavailable(String", "TvInputService.Session#notifyVideoUnavailable(int)" ]
  }, {
    "name" : "VIDEO_UNAVAILABLE_REASON_CAS_NEED_PAIRING",
    "type" : "int",
    "comment" : "\n     * Reason for {@link TvInputService.Session#notifyVideoUnavailable(int)} and\n     * {@link TvView.TvInputCallback#onVideoUnavailable(String, int)}: Video is unavailable because\n     * the device need be paired.\n     ",
    "links" : [ "TvView.TvInputCallback#onVideoUnavailable(String", "TvInputService.Session#notifyVideoUnavailable(int)" ]
  }, {
    "name" : "VIDEO_UNAVAILABLE_REASON_CAS_NO_CARD",
    "type" : "int",
    "comment" : "\n     * Reason for {@link TvInputService.Session#notifyVideoUnavailable(int)} and\n     * {@link TvView.TvInputCallback#onVideoUnavailable(String, int)}: Video is unavailable because\n     * smart card is missed.\n     ",
    "links" : [ "TvView.TvInputCallback#onVideoUnavailable(String", "TvInputService.Session#notifyVideoUnavailable(int)" ]
  }, {
    "name" : "VIDEO_UNAVAILABLE_REASON_CAS_CARD_MUTE",
    "type" : "int",
    "comment" : "\n     * Reason for {@link TvInputService.Session#notifyVideoUnavailable(int)} and\n     * {@link TvView.TvInputCallback#onVideoUnavailable(String, int)}: Video is unavailable because\n     * smart card is muted.\n     ",
    "links" : [ "TvView.TvInputCallback#onVideoUnavailable(String", "TvInputService.Session#notifyVideoUnavailable(int)" ]
  }, {
    "name" : "VIDEO_UNAVAILABLE_REASON_CAS_CARD_INVALID",
    "type" : "int",
    "comment" : "\n     * Reason for {@link TvInputService.Session#notifyVideoUnavailable(int)} and\n     * {@link TvView.TvInputCallback#onVideoUnavailable(String, int)}: Video is unavailable because\n     * smart card is invalid.\n     ",
    "links" : [ "TvView.TvInputCallback#onVideoUnavailable(String", "TvInputService.Session#notifyVideoUnavailable(int)" ]
  }, {
    "name" : "VIDEO_UNAVAILABLE_REASON_CAS_BLACKOUT",
    "type" : "int",
    "comment" : "\n     * Reason for {@link TvInputService.Session#notifyVideoUnavailable(int)} and\n     * {@link TvView.TvInputCallback#onVideoUnavailable(String, int)}: Video is unavailable because\n     * of a geographical blackout.\n     ",
    "links" : [ "TvView.TvInputCallback#onVideoUnavailable(String", "TvInputService.Session#notifyVideoUnavailable(int)" ]
  }, {
    "name" : "VIDEO_UNAVAILABLE_REASON_CAS_REBOOTING",
    "type" : "int",
    "comment" : "\n     * Reason for {@link TvInputService.Session#notifyVideoUnavailable(int)} and\n     * {@link TvView.TvInputCallback#onVideoUnavailable(String, int)}: Video is unavailable because\n     * CAS system is rebooting.\n     ",
    "links" : [ "TvView.TvInputCallback#onVideoUnavailable(String", "TvInputService.Session#notifyVideoUnavailable(int)" ]
  }, {
    "name" : "VIDEO_UNAVAILABLE_REASON_CAS_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Reason for {@link TvInputService.Session#notifyVideoUnavailable(int)} and\n     * {@link TvView.TvInputCallback#onVideoUnavailable(String, int)}: Video is unavailable because\n     * of unknown CAS error.\n     ",
    "links" : [ "TvView.TvInputCallback#onVideoUnavailable(String", "TvInputService.Session#notifyVideoUnavailable(int)" ]
  }, {
    "name" : "VIDEO_UNAVAILABLE_REASON_STOPPED",
    "type" : "int",
    "comment" : "\n     * Reason for {@link TvInputService.Session#notifyVideoUnavailable(int)} and\n     * {@link TvView.TvInputCallback#onVideoUnavailable(String, int)}: Video is unavailable because\n     * it has been stopped by {@link TvView#stopPlayback(int)}.\n     ",
    "links" : [ "TvView.TvInputCallback#onVideoUnavailable(String", "android.media.tv.TvView#stopPlayback(int)", "TvInputService.Session#notifyVideoUnavailable(int)" ]
  }, {
    "name" : "TIME_SHIFT_STATUS_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Status for {@link TvInputService.Session#notifyTimeShiftStatusChanged(int)} and\n     * {@link TvView.TvInputCallback#onTimeShiftStatusChanged(String, int)}: Unknown status. Also\n     * the status prior to calling {@code notifyTimeShiftStatusChanged}.\n     ",
    "links" : [ "TvInputService.Session#notifyTimeShiftStatusChanged(int)", "TvView.TvInputCallback#onTimeShiftStatusChanged(String" ]
  }, {
    "name" : "TIME_SHIFT_STATUS_UNSUPPORTED",
    "type" : "int",
    "comment" : "\n     * Status for {@link TvInputService.Session#notifyTimeShiftStatusChanged(int)} and\n     * {@link TvView.TvInputCallback#onTimeShiftStatusChanged(String, int)}: The current TV input\n     * does not support time shifting.\n     ",
    "links" : [ "TvInputService.Session#notifyTimeShiftStatusChanged(int)", "TvView.TvInputCallback#onTimeShiftStatusChanged(String" ]
  }, {
    "name" : "TIME_SHIFT_STATUS_UNAVAILABLE",
    "type" : "int",
    "comment" : "\n     * Status for {@link TvInputService.Session#notifyTimeShiftStatusChanged(int)} and\n     * {@link TvView.TvInputCallback#onTimeShiftStatusChanged(String, int)}: Time shifting is\n     * currently unavailable but might work again later.\n     ",
    "links" : [ "TvInputService.Session#notifyTimeShiftStatusChanged(int)", "TvView.TvInputCallback#onTimeShiftStatusChanged(String" ]
  }, {
    "name" : "TIME_SHIFT_STATUS_AVAILABLE",
    "type" : "int",
    "comment" : "\n     * Status for {@link TvInputService.Session#notifyTimeShiftStatusChanged(int)} and\n     * {@link TvView.TvInputCallback#onTimeShiftStatusChanged(String, int)}: Time shifting is\n     * currently available. In this status, the application assumes it can pause/resume playback,\n     * seek to a specified time position and set playback rate and audio mode.\n     ",
    "links" : [ "TvInputService.Session#notifyTimeShiftStatusChanged(int)", "TvView.TvInputCallback#onTimeShiftStatusChanged(String" ]
  }, {
    "name" : "TIME_SHIFT_INVALID_TIME",
    "type" : "long",
    "comment" : "\n     * Value returned by {@link TvInputService.Session#onTimeShiftGetCurrentPosition()} and\n     * {@link TvInputService.Session#onTimeShiftGetStartPosition()} when time shifting has not\n     * yet started.\n     ",
    "links" : [ "TvInputService.Session#onTimeShiftGetStartPosition()", "TvInputService.Session#onTimeShiftGetCurrentPosition()" ]
  }, {
    "name" : "TIME_SHIFT_MODE_OFF",
    "type" : "int",
    "comment" : "\n     * Time shift mode: off.\n     * <p>Time shift is disabled.\n     ",
    "links" : [ ]
  }, {
    "name" : "TIME_SHIFT_MODE_LOCAL",
    "type" : "int",
    "comment" : "\n     * Time shift mode: local.\n     * <p>Time shift is handle locally, using on-device data. E.g. playing a local file.\n     ",
    "links" : [ ]
  }, {
    "name" : "TIME_SHIFT_MODE_NETWORK",
    "type" : "int",
    "comment" : "\n     * Time shift mode: network.\n     * <p>Time shift is handle remotely via network. E.g. online streaming.\n     ",
    "links" : [ ]
  }, {
    "name" : "TIME_SHIFT_MODE_AUTO",
    "type" : "int",
    "comment" : "\n     * Time shift mode: auto.\n     * <p>Time shift mode is handled automatically.\n     ",
    "links" : [ ]
  }, {
    "name" : "RECORDING_ERROR_START",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RECORDING_ERROR_END",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RECORDING_ERROR_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Error for {@link TvInputService.RecordingSession#notifyError(int)} and\n     * {@link TvRecordingClient.RecordingCallback#onError(int)}: The requested operation cannot be\n     * completed due to a problem that does not fit under any other error codes, or the error code\n     * for the problem is defined on the higher version than application's\n     * <code>android:targetSdkVersion</code>.\n     ",
    "links" : [ "TvRecordingClient.RecordingCallback#onError(int)", "TvInputService.RecordingSession#notifyError(int)" ]
  }, {
    "name" : "RECORDING_ERROR_INSUFFICIENT_SPACE",
    "type" : "int",
    "comment" : "\n     * Error for {@link TvInputService.RecordingSession#notifyError(int)} and\n     * {@link TvRecordingClient.RecordingCallback#onError(int)}: Recording cannot proceed due to\n     * insufficient storage space.\n     ",
    "links" : [ "TvRecordingClient.RecordingCallback#onError(int)", "TvInputService.RecordingSession#notifyError(int)" ]
  }, {
    "name" : "RECORDING_ERROR_RESOURCE_BUSY",
    "type" : "int",
    "comment" : "\n     * Error for {@link TvInputService.RecordingSession#notifyError(int)} and\n     * {@link TvRecordingClient.RecordingCallback#onError(int)}: Recording cannot proceed because\n     * a required recording resource was not able to be allocated.\n     ",
    "links" : [ "TvRecordingClient.RecordingCallback#onError(int)", "TvInputService.RecordingSession#notifyError(int)" ]
  }, {
    "name" : "INPUT_STATE_CONNECTED",
    "type" : "int",
    "comment" : "\n     * State for {@link #getInputState(String)} and\n     * {@link TvInputCallback#onInputStateChanged(String, int)}: The input source is connected.\n     *\n     * <p>This state indicates that a source device is connected to the input port and is in the\n     * normal operation mode. It is mostly relevant to hardware inputs such as HDMI input.\n     * Non-hardware inputs are considered connected all the time.\n     ",
    "links" : [ "#getInputState(String)", "#onInputStateChanged(String" ]
  }, {
    "name" : "INPUT_STATE_CONNECTED_STANDBY",
    "type" : "int",
    "comment" : "\n     * State for {@link #getInputState(String)} and\n     * {@link TvInputCallback#onInputStateChanged(String, int)}: The input source is connected but\n     * in standby mode.\n     *\n     * <p>This state indicates that a source device is connected to the input port but is in standby\n     * or low power mode. It is mostly relevant to hardware inputs such as HDMI input and Component\n     * inputs.\n     ",
    "links" : [ "#getInputState(String)", "#onInputStateChanged(String" ]
  }, {
    "name" : "INPUT_STATE_DISCONNECTED",
    "type" : "int",
    "comment" : "\n     * State for {@link #getInputState(String)} and\n     * {@link TvInputCallback#onInputStateChanged(String, int)}: The input source is disconnected.\n     *\n     * <p>This state indicates that a source device is disconnected from the input port. It is\n     * mostly relevant to hardware inputs such as HDMI input.\n     *\n     ",
    "links" : [ "#getInputState(String)", "#onInputStateChanged(String" ]
  }, {
    "name" : "BROADCAST_INFO_TYPE_TS",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "BROADCAST_INFO_TYPE_TABLE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "BROADCAST_INFO_TYPE_SECTION",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "BROADCAST_INFO_TYPE_PES",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "BROADCAST_INFO_STREAM_EVENT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "BROADCAST_INFO_TYPE_DSMCC",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "BROADCAST_INFO_TYPE_COMMAND",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "BROADCAST_INFO_TYPE_TIMELINE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "BROADCAST_INFO_TYPE_SIGNALING_DATA",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SIGNAL_STRENGTH_LOST",
    "type" : "int",
    "comment" : "\n     * Signal lost.\n     ",
    "links" : [ ]
  }, {
    "name" : "SIGNAL_STRENGTH_WEAK",
    "type" : "int",
    "comment" : "\n     * Weak signal.\n     ",
    "links" : [ ]
  }, {
    "name" : "SIGNAL_STRENGTH_STRONG",
    "type" : "int",
    "comment" : "\n     * Strong signal.\n     ",
    "links" : [ ]
  }, {
    "name" : "SESSION_DATA_TYPE_TUNED",
    "type" : "String",
    "comment" : "\n     * Informs the application that the session has been tuned to the given channel.\n     *\n     * @see TvInputService.Session#sendTvInputSessionData(String, Bundle)\n     * @see SESSION_DATA_KEY_CHANNEL_URI\n     ",
    "links" : [ ]
  }, {
    "name" : "SESSION_DATA_TYPE_TRACK_SELECTED",
    "type" : "String",
    "comment" : "\n     * Sends the type and ID of a selected track. This is used to inform the application that a\n     * specific track is selected.\n     *\n     * @see TvInputService.Session#sendTvInputSessionData(String, Bundle)\n     * @see SESSION_DATA_KEY_TRACK_TYPE\n     * @see SESSION_DATA_KEY_TRACK_ID\n     ",
    "links" : [ ]
  }, {
    "name" : "SESSION_DATA_TYPE_TRACKS_CHANGED",
    "type" : "String",
    "comment" : "\n     * Sends the list of all audio/video/subtitle tracks.\n     *\n     * @see TvInputService.Session#sendTvInputSessionData(String, Bundle)\n     * @see SESSION_DATA_KEY_TRACKS\n     ",
    "links" : [ ]
  }, {
    "name" : "SESSION_DATA_TYPE_VIDEO_AVAILABLE",
    "type" : "String",
    "comment" : "\n     * Informs the application that the video is now available for watching.\n     *\n     * @see TvInputService.Session#sendTvInputSessionData(String, Bundle)\n     ",
    "links" : [ ]
  }, {
    "name" : "SESSION_DATA_TYPE_VIDEO_UNAVAILABLE",
    "type" : "String",
    "comment" : "\n     * Informs the application that the video became unavailable for some reason.\n     *\n     * @see TvInputService.Session#sendTvInputSessionData(String, Bundle)\n     * @see SESSION_DATA_KEY_VIDEO_UNAVAILABLE_REASON\n     ",
    "links" : [ ]
  }, {
    "name" : "SESSION_DATA_TYPE_BROADCAST_INFO_RESPONSE",
    "type" : "String",
    "comment" : "\n     * Notifies response for broadcast info.\n     *\n     * @see TvInputService.Session#sendTvInputSessionData(String, Bundle)\n     * @see SESSION_DATA_KEY_BROADCAST_INFO_RESPONSE\n     ",
    "links" : [ ]
  }, {
    "name" : "SESSION_DATA_TYPE_AD_RESPONSE",
    "type" : "String",
    "comment" : "\n     * Notifies response for advertisement.\n     *\n     * @see TvInputService.Session#sendTvInputSessionData(String, Bundle)\n     * @see SESSION_DATA_KEY_AD_RESPONSE\n     ",
    "links" : [ ]
  }, {
    "name" : "SESSION_DATA_TYPE_AD_BUFFER_CONSUMED",
    "type" : "String",
    "comment" : "\n     * Notifies the advertisement buffer is consumed.\n     *\n     * @see TvInputService.Session#sendTvInputSessionData(String, Bundle)\n     * @see SESSION_DATA_KEY_AD_BUFFER\n     ",
    "links" : [ ]
  }, {
    "name" : "SESSION_DATA_TYPE_TV_MESSAGE",
    "type" : "String",
    "comment" : "\n     * Sends the TV message.\n     *\n     * @see TvInputService.Session#sendTvInputSessionData(String, Bundle)\n     * @see TvInputService.Session#notifyTvMessage(int, Bundle)\n     * @see SESSION_DATA_KEY_TV_MESSAGE_TYPE\n     ",
    "links" : [ ]
  }, {
    "name" : "SESSION_DATA_KEY_CHANNEL_URI",
    "type" : "String",
    "comment" : "\n     * The URI of a channel.\n     *\n     * <p> Type: android.net.Uri\n     *\n     * @see TvInputService.Session#sendTvInputSessionData(String, Bundle)\n     ",
    "links" : [ ]
  }, {
    "name" : "SESSION_DATA_KEY_TRACK_TYPE",
    "type" : "String",
    "comment" : "\n     * The type of the track.\n     *\n     * <p>One of {@link TvTrackInfo#TYPE_AUDIO}, {@link TvTrackInfo#TYPE_VIDEO},\n     * {@link TvTrackInfo#TYPE_SUBTITLE}.\n     *\n     * <p> Type: Integer\n     *\n     * @see TvTrackInfo#getType()\n     * @see TvInputService.Session#sendTvInputSessionData(String, Bundle)\n     ",
    "links" : [ "android.media.tv.TvTrackInfo#TYPE_VIDEO", "android.media.tv.TvTrackInfo#TYPE_SUBTITLE", "android.media.tv.TvTrackInfo#TYPE_AUDIO" ]
  }, {
    "name" : "SESSION_DATA_KEY_TRACK_ID",
    "type" : "String",
    "comment" : "\n     * The ID of the track.\n     *\n     * <p> Type: String\n     *\n     * @see TvTrackInfo#getId()\n     * @see TvInputService.Session#sendTvInputSessionData(String, Bundle)\n     ",
    "links" : [ ]
  }, {
    "name" : "SESSION_DATA_KEY_TRACKS",
    "type" : "String",
    "comment" : "\n     * A list which includes track information.\n     *\n     * <p> Type: {@code java.util.List<android.media.tv.TvTrackInfo> }\n     *\n     * @see TvInputService.Session#sendTvInputSessionData(String, Bundle)\n     ",
    "links" : [ ]
  }, {
    "name" : "SESSION_DATA_KEY_VIDEO_UNAVAILABLE_REASON",
    "type" : "String",
    "comment" : "\n     * The reason why the video became unavailable.\n     * <p>The value can be {@link VIDEO_UNAVAILABLE_REASON_BUFFERING},\n     * {@link VIDEO_UNAVAILABLE_REASON_AUDIO_ONLY}, etc.\n     *\n     * <p> Type: Integer\n     *\n     * @see TvInputService.Session#sendTvInputSessionData(String, Bundle)\n     ",
    "links" : [ "VIDEO_UNAVAILABLE_REASON_BUFFERING", "VIDEO_UNAVAILABLE_REASON_AUDIO_ONLY" ]
  }, {
    "name" : "SESSION_DATA_KEY_BROADCAST_INFO_RESPONSE",
    "type" : "String",
    "comment" : "\n     * An object of {@link BroadcastInfoResponse}.\n     *\n     * <p> Type: android.media.tv.BroadcastInfoResponse\n     *\n     * @see TvInputService.Session#sendTvInputSessionData(String, Bundle)\n     ",
    "links" : [ "android.media.tv.BroadcastInfoResponse" ]
  }, {
    "name" : "SESSION_DATA_KEY_AD_RESPONSE",
    "type" : "String",
    "comment" : "\n     * An object of {@link AdResponse}.\n     *\n     * <p> Type: android.media.tv.AdResponse\n     *\n     * @see TvInputService.Session#sendTvInputSessionData(String, Bundle)\n     ",
    "links" : [ "android.media.tv.AdResponse" ]
  }, {
    "name" : "SESSION_DATA_KEY_AD_BUFFER",
    "type" : "String",
    "comment" : "\n     * An object of {@link AdBuffer}.\n     *\n     * <p> Type: android.media.tv.AdBuffer\n     *\n     * @see TvInputService.Session#sendTvInputSessionData(String, Bundle)\n     ",
    "links" : [ "android.media.tv.AdBuffer" ]
  }, {
    "name" : "SESSION_DATA_KEY_TV_MESSAGE_TYPE",
    "type" : "String",
    "comment" : "\n     * The type of TV message.\n     * <p>It can be one of {@link TV_MESSAGE_TYPE_WATERMARK},\n     * {@link TV_MESSAGE_TYPE_CLOSED_CAPTION}, {@link TV_MESSAGE_TYPE_OTHER}\n     *\n     * <p> Type: Integer\n     *\n     * @see TvInputService.Session#sendTvInputSessionData(String, Bundle)\n     ",
    "links" : [ "TV_MESSAGE_TYPE_WATERMARK", "TV_MESSAGE_TYPE_CLOSED_CAPTION", "TV_MESSAGE_TYPE_OTHER" ]
  }, {
    "name" : "UNKNOWN_CLIENT_PID",
    "type" : "int",
    "comment" : "\n     * An unknown state of the client pid gets from the TvInputManager. Client gets this value when\n     * query through {@link getClientPid(String sessionId)} fails.\n     *\n     * @hide\n     ",
    "links" : [ "getClientPid(String" ]
  }, {
    "name" : "ACTION_BLOCKED_RATINGS_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action when the user blocked content ratings change. For use with the\n     * {@link #isRatingBlocked}.\n     ",
    "links" : [ "#isRatingBlocked" ]
  }, {
    "name" : "ACTION_PARENTAL_CONTROLS_ENABLED_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action when the parental controls enabled state changes. For use with the\n     * {@link #isParentalControlsEnabled}.\n     ",
    "links" : [ "#isParentalControlsEnabled" ]
  }, {
    "name" : "ACTION_QUERY_CONTENT_RATING_SYSTEMS",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action used to query available content rating systems.\n     *\n     * <p>The TV input manager service locates available content rating systems by querying\n     * broadcast receivers that are registered for this action. An application can offer additional\n     * content rating systems to the user by declaring a suitable broadcast receiver in its\n     * manifest.\n     *\n     * <p>Here is an example broadcast receiver declaration that an application might include in its\n     * AndroidManifest.xml to advertise custom content rating systems. The meta-data specifies a\n     * resource that contains a description of each content rating system that is provided by the\n     * application.\n     *\n     * <p><pre class=\"prettyprint\">\n     * {@literal\n     * <receiver android:name=\".TvInputReceiver\">\n     *     <intent-filter>\n     *         <action android:name=\n     *                 \"android.media.tv.action.QUERY_CONTENT_RATING_SYSTEMS\" />\n     *     </intent-filter>\n     *     <meta-data\n     *             android:name=\"android.media.tv.metadata.CONTENT_RATING_SYSTEMS\"\n     *             android:resource=\"@xml/tv_content_rating_systems\" />\n     * </receiver>}</pre>\n     *\n     * <p>In the above example, the <code>@xml/tv_content_rating_systems</code> resource refers to an\n     * XML resource whose root element is <code>&lt;rating-system-definitions&gt;</code> that\n     * contains zero or more <code>&lt;rating-system-definition&gt;</code> elements. Each <code>\n     * &lt;rating-system-definition&gt;</code> element specifies the ratings, sub-ratings and rating\n     * orders of a particular content rating system.\n     *\n     * @see TvContentRating\n     ",
    "links" : [ ]
  }, {
    "name" : "META_DATA_CONTENT_RATING_SYSTEMS",
    "type" : "String",
    "comment" : "\n     * Content rating systems metadata associated with {@link #ACTION_QUERY_CONTENT_RATING_SYSTEMS}.\n     *\n     * <p>Specifies the resource ID of an XML resource that describes the content rating systems\n     * that are provided by the application.\n     ",
    "links" : [ "#ACTION_QUERY_CONTENT_RATING_SYSTEMS" ]
  }, {
    "name" : "ACTION_SETUP_INPUTS",
    "type" : "String",
    "comment" : "\n     * Activity action to set up channel sources i.e.&nbsp;TV inputs of type\n     * {@link TvInputInfo#TYPE_TUNER}. When invoked, the system will display an appropriate UI for\n     * the user to initiate the individual setup flow provided by\n     * {@link android.R.attr#setupActivity} of each TV input service.\n     ",
    "links" : [ "android.R.attr#setupActivity", "android.media.tv.TvInputInfo#TYPE_TUNER" ]
  }, {
    "name" : "ACTION_VIEW_RECORDING_SCHEDULES",
    "type" : "String",
    "comment" : "\n     * Activity action to display the recording schedules. When invoked, the system will display an\n     * appropriate UI to browse the schedules.\n     ",
    "links" : [ ]
  }, {
    "name" : "mService",
    "type" : "ITvInputManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLock",
    "type" : "Object",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mCallbackRecords",
    "type" : "List<TvInputCallbackRecord>",
    "comment" : " @GuardedBy(\"mLock\")",
    "links" : [ ]
  }, {
    "name" : "mStateMap",
    "type" : "Map<String, Integer>",
    "comment" : " @GuardedBy(\"mLock\")",
    "links" : [ ]
  }, {
    "name" : "mSessionCallbackRecordMap",
    "type" : "SparseArray<SessionCallbackRecord>",
    "comment" : " A mapping from the sequence number of a session to its SessionCallbackRecord.",
    "links" : [ ]
  }, {
    "name" : "mNextSeq",
    "type" : "int",
    "comment" : " {@code mSessionCallbackRecordMap}.",
    "links" : [ ]
  }, {
    "name" : "mClient",
    "type" : "ITvInputClient",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUserId",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public List<TvInputInfo> getTvInputList()",
    "returnType" : "List<TvInputInfo>",
    "comment" : "\n     * Returns the complete list of TV inputs on the system.\n     *\n     * @return List of {@link TvInputInfo} for each TV input that describes its meta information.\n     ",
    "links" : [ "android.media.tv.TvInputInfo" ]
  }, {
    "name" : "public TvInputInfo getTvInputInfo(@NonNull String inputId)",
    "returnType" : "TvInputInfo",
    "comment" : "\n     * Returns the {@link TvInputInfo} for a given TV input.\n     *\n     * @param inputId The ID of the TV input.\n     * @return the {@link TvInputInfo} for a given TV input. {@code null} if not found.\n     ",
    "links" : [ "android.media.tv.TvInputInfo" ]
  }, {
    "name" : "public void updateTvInputInfo(@NonNull TvInputInfo inputInfo)",
    "returnType" : "void",
    "comment" : "\n     * Updates the <code>TvInputInfo</code> for an existing TV input. A TV input service\n     * implementation may call this method to pass the application and system an up-to-date\n     * <code>TvInputInfo</code> object that describes itself.\n     *\n     * <p>The system automatically creates a <code>TvInputInfo</code> object for each TV input,\n     * based on the information collected from the <code>AndroidManifest.xml</code>, thus it is not\n     * necessary to call this method unless such information has changed dynamically.\n     * Use {@link TvInputInfo.Builder} to build a new <code>TvInputInfo</code> object.\n     *\n     * <p>Attempting to change information about a TV input that the calling package does not own\n     * does nothing.\n     *\n     * @param inputInfo The <code>TvInputInfo</code> object that contains new information.\n     * @throws IllegalArgumentException if the argument is {@code null}.\n     * @see TvInputCallback#onTvInputInfoUpdated(TvInputInfo)\n     ",
    "links" : [ "TvInputInfo.Builder" ]
  }, {
    "name" : "public int getInputState(@NonNull String inputId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the state of a given TV input.\n     *\n     * <p>The state is one of the following:\n     * <ul>\n     * <li>{@link #INPUT_STATE_CONNECTED}\n     * <li>{@link #INPUT_STATE_CONNECTED_STANDBY}\n     * <li>{@link #INPUT_STATE_DISCONNECTED}\n     * </ul>\n     *\n     * @param inputId The ID of the TV input.\n     * @throws IllegalArgumentException if the argument is {@code null}.\n     ",
    "links" : [ "#INPUT_STATE_CONNECTED", "#INPUT_STATE_CONNECTED_STANDBY", "#INPUT_STATE_DISCONNECTED" ]
  }, {
    "name" : "public List<String> getAvailableExtensionInterfaceNames(@NonNull String inputId)",
    "returnType" : "List<String>",
    "comment" : "\n     * Returns available extension interfaces of a given hardware TV input. This can be used to\n     * provide domain-specific features that are only known between certain hardware TV inputs\n     * and their clients.\n     *\n     * @param inputId The ID of the TV input.\n     * @return a non-null list of extension interface names available to the caller. An empty\n     *         list indicates the given TV input is not found, or the given TV input is not a\n     *         hardware TV input, or the given TV input doesn't support any extension\n     *         interfaces, or the caller doesn't hold the required permission for the extension\n     *         interfaces supported by the given TV input.\n     * @see #getExtensionInterface\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public IBinder getExtensionInterface(@NonNull String inputId, @NonNull String name)",
    "returnType" : "IBinder",
    "comment" : "\n     * Returns an extension interface of a given hardware TV input. This can be used to provide\n     * domain-specific features that are only known between certain hardware TV inputs and\n     * their clients.\n     *\n     * @param inputId The ID of the TV input.\n     * @param name The extension interface name.\n     * @return an {@link IBinder} for the given extension interface, {@code null} if the given TV\n     *         input is not found, or if the given TV input is not a hardware TV input, or if the\n     *         given TV input doesn't support the given extension interface, or if the caller\n     *         doesn't hold the required permission for the given extension interface.\n     * @see #getAvailableExtensionInterfaceNames\n     * @hide\n     ",
    "links" : [ "android.os.IBinder" ]
  }, {
    "name" : "public void registerCallback(@NonNull TvInputCallback callback, @NonNull Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Registers a {@link TvInputCallback}.\n     *\n     * @param callback A callback used to monitor status of the TV inputs.\n     * @param handler A {@link Handler} that the status change will be delivered to.\n     ",
    "links" : [ "android.os.Handler", "TvInputCallback" ]
  }, {
    "name" : "public void unregisterCallback(@NonNull final TvInputCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters the existing {@link TvInputCallback}.\n     *\n     * @param callback The existing callback to remove.\n     ",
    "links" : [ "TvInputCallback" ]
  }, {
    "name" : "public boolean isParentalControlsEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns the user's parental controls enabled state.\n     *\n     * @return {@code true} if the user enabled the parental controls, {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setParentalControlsEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Sets the user's parental controls enabled state.\n     *\n     * @param enabled The user's parental controls enabled state. {@code true} if the user enabled\n     *            the parental controls, {@code false} otherwise.\n     * @see #isParentalControlsEnabled\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isRatingBlocked(@NonNull TvContentRating rating)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether a given TV content rating is blocked by the user.\n     *\n     * @param rating The TV content rating to check. Can be {@link TvContentRating#UNRATED}.\n     * @return {@code true} if the given TV content rating is blocked, {@code false} otherwise.\n     ",
    "links" : [ "android.media.tv.TvContentRating#UNRATED" ]
  }, {
    "name" : "public List<TvContentRating> getBlockedRatings()",
    "returnType" : "List<TvContentRating>",
    "comment" : "\n     * Returns the list of blocked content ratings.\n     *\n     * @return the list of content ratings blocked by the user.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addBlockedRating(@NonNull TvContentRating rating)",
    "returnType" : "void",
    "comment" : "\n     * Adds a user blocked content rating.\n     *\n     * @param rating The content rating to block.\n     * @see #isRatingBlocked\n     * @see #removeBlockedRating\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeBlockedRating(@NonNull TvContentRating rating)",
    "returnType" : "void",
    "comment" : "\n     * Removes a user blocked content rating.\n     *\n     * @param rating The content rating to unblock.\n     * @see #isRatingBlocked\n     * @see #addBlockedRating\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<TvContentRatingSystemInfo> getTvContentRatingSystemList()",
    "returnType" : "List<TvContentRatingSystemInfo>",
    "comment" : "\n     * Returns the list of all TV content rating systems defined.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void notifyPreviewProgramBrowsableDisabled(String packageName, long programId)",
    "returnType" : "void",
    "comment" : "\n     * Notifies the TV input of the given preview program that the program's browsable state is\n     * disabled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void notifyWatchNextProgramBrowsableDisabled(String packageName, long programId)",
    "returnType" : "void",
    "comment" : "\n     * Notifies the TV input of the given watch next program that the program's browsable state is\n     * disabled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void notifyPreviewProgramAddedToWatchNext(String packageName, long previewProgramId, long watchNextProgramId)",
    "returnType" : "void",
    "comment" : "\n     * Notifies the TV input of the given preview program that the program is added to watch next.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void createSession(@NonNull String inputId, @NonNull AttributionSource tvAppAttributionSource, @NonNull final SessionCallback callback, @NonNull Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Creates a {@link Session} for a given TV input.\n     *\n     * <p>The number of sessions that can be created at the same time is limited by the capability\n     * of the given TV input.\n     *\n     * @param inputId The ID of the TV input.\n     * @param tvAppAttributionSource The Attribution Source of the TV App.\n     * @param callback A callback used to receive the created session.\n     * @param handler A {@link Handler} that the session creation will be delivered to.\n     * @hide\n     ",
    "links" : [ "android.os.Handler", "Session" ]
  }, {
    "name" : "public int getClientPid(@NonNull String sessionId)",
    "returnType" : "int",
    "comment" : "\n     * Get a the client pid when creating the session with the session id provided.\n     *\n     * @param sessionId a String of session id that is used to query the client pid.\n     * @return the client pid when created the session. Returns {@link #UNKNOWN_CLIENT_PID}\n     *         if the call fails.\n     *\n     * @hide\n     ",
    "links" : [ "#UNKNOWN_CLIENT_PID" ]
  }, {
    "name" : "public int getClientPriority(@TvInputService.PriorityHintUseCaseType int useCase, @NonNull String sessionId)",
    "returnType" : "int",
    "comment" : "\n     * Returns a priority for the given use case type and the client's foreground or background\n     * status.\n     *\n     * @param useCase the use case type of the client.\n     *        {@see TvInputService#PriorityHintUseCaseType}.\n     * @param sessionId the unique id of the session owned by the client.\n     *        {@see TvInputService#onCreateSession(String, String, AttributionSource)}.\n     *\n     * @return the use case priority value for the given use case type and the client's foreground\n     *         or background status.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getClientPriority(@TvInputService.PriorityHintUseCaseType int useCase)",
    "returnType" : "int",
    "comment" : "\n     * Returns a priority for the given use case type and the caller's foreground or background\n     * status.\n     *\n     * @param useCase the use case type of the caller.\n     *        {@see TvInputService#PriorityHintUseCaseType}.\n     *\n     * @return the use case priority value for the given use case type and the caller's foreground\n     *         or background status.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void createRecordingSession(@NonNull String inputId, @NonNull final SessionCallback callback, @NonNull Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Creates a recording {@link Session} for a given TV input.\n     *\n     * <p>The number of sessions that can be created at the same time is limited by the capability\n     * of the given TV input.\n     *\n     * @param inputId The ID of the TV input.\n     * @param callback A callback used to receive the created session.\n     * @param handler A {@link Handler} that the session creation will be delivered to.\n     * @hide\n     ",
    "links" : [ "android.os.Handler", "Session" ]
  }, {
    "name" : "private void createSessionInternal(String inputId, AttributionSource tvAppAttributionSource, boolean isRecordingSession, SessionCallback callback, Handler handler)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getClientPidInternal(String sessionId)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getClientPriorityInternal(int useCase, String sessionId)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean isValidUseCase(int useCase)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public List<TvStreamConfig> getAvailableTvStreamConfigList(String inputId)",
    "returnType" : "List<TvStreamConfig>",
    "comment" : "\n     * Returns the TvStreamConfig list of the given TV input.\n     *\n     * If you are using {@link Hardware} object from {@link\n     * #acquireTvInputHardware}, you should get the list of available streams\n     * from {@link HardwareCallback#onStreamConfigChanged} method, not from\n     * here. This method is designed to be used with {@link #captureFrame} in\n     * capture scenarios specifically and not suitable for any other use.\n     *\n     * @param inputId The ID of the TV input.\n     * @return List of {@link TvStreamConfig} which is available for capturing\n     *   of the given TV input.\n     * @hide\n     ",
    "links" : [ "#acquireTvInputHardware", "#onStreamConfigChanged", "android.media.tv.TvStreamConfig", "Hardware", "#captureFrame" ]
  }, {
    "name" : "public boolean captureFrame(String inputId, Surface surface, TvStreamConfig config)",
    "returnType" : "boolean",
    "comment" : "\n     * Take a snapshot of the given TV input into the provided Surface.\n     *\n     * @param inputId The ID of the TV input.\n     * @param surface the {@link Surface} to which the snapshot is captured.\n     * @param config the {@link TvStreamConfig} which is used for capturing.\n     * @return true when the {@link Surface} is ready to be captured.\n     * @hide\n     ",
    "links" : [ "android.view.Surface", "android.media.tv.TvStreamConfig" ]
  }, {
    "name" : "public boolean isSingleSessionActive()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if there is only a single TV input session.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<TvInputHardwareInfo> getHardwareList()",
    "returnType" : "List<TvInputHardwareInfo>",
    "comment" : "\n     * Returns a list of TvInputHardwareInfo objects representing available hardware.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Hardware acquireTvInputHardware(int deviceId, final HardwareCallback callback, TvInputInfo info)",
    "returnType" : "Hardware",
    "comment" : "\n     * Acquires {@link Hardware} object for the given device ID.\n     *\n     * <p>A subsequent call to this method on the same {@code deviceId} will release the currently\n     * acquired Hardware.\n     *\n     * @param deviceId The device ID to acquire Hardware for.\n     * @param callback A callback to receive updates on Hardware.\n     * @param info The TV input which will use the acquired Hardware.\n     * @return Hardware on success, {@code null} otherwise.\n     *\n     * @hide\n     * @removed\n     ",
    "links" : [ "Hardware" ]
  }, {
    "name" : "public Hardware acquireTvInputHardware(int deviceId, @NonNull TvInputInfo info, @NonNull final HardwareCallback callback)",
    "returnType" : "Hardware",
    "comment" : "\n     * Acquires {@link Hardware} object for the given device ID.\n     *\n     * <p>A subsequent call to this method on the same {@code deviceId} could release the currently\n     * acquired Hardware if TunerResourceManager(TRM) detects higher priority from the current\n     * request.\n     *\n     * <p>If the client would like to provide information for the TRM to compare, use\n     * {@link #acquireTvInputHardware(int, TvInputInfo, HardwareCallback, String, int)} instead.\n     *\n     * <p>Otherwise default priority will be applied.\n     *\n     * @param deviceId The device ID to acquire Hardware for.\n     * @param info The TV input which will use the acquired Hardware.\n     * @param callback A callback to receive updates on Hardware.\n     * @return Hardware on success, {@code null} otherwise.\n     *\n     * @hide\n     ",
    "links" : [ "#acquireTvInputHardware(int", "Hardware" ]
  }, {
    "name" : "public Hardware acquireTvInputHardware(int deviceId, @NonNull TvInputInfo info, @Nullable String tvInputSessionId, @TvInputService.PriorityHintUseCaseType int priorityHint, @NonNull @CallbackExecutor Executor executor, @NonNull final HardwareCallback callback)",
    "returnType" : "Hardware",
    "comment" : "\n     * Acquires {@link Hardware} object for the given device ID.\n     *\n     * <p>A subsequent call to this method on the same {@code deviceId} could release the currently\n     * acquired Hardware if TunerResourceManager(TRM) detects higher priority from the current\n     * request.\n     *\n     * @param deviceId The device ID to acquire Hardware for.\n     * @param info The TV input which will use the acquired Hardware.\n     * @param tvInputSessionId a String returned to TIS when the session was created.\n     *        {@see TvInputService#onCreateSession(String, String, AttributionSource)}. If null, the\n     *        client will be treated as a background app.\n     * @param priorityHint The use case of the client. {@see TvInputService#PriorityHintUseCaseType}\n     * @param executor the executor on which the listener would be invoked.\n     * @param callback A callback to receive updates on Hardware.\n     * @return Hardware on success, {@code null} otherwise. When the TRM decides to not grant\n     *         resource, null is returned and the {@link IllegalStateException} is thrown with\n     *         \"No enough resources\".\n     *\n     * @hide\n     ",
    "links" : [ "IllegalStateException", "Hardware" ]
  }, {
    "name" : "public void addHardwareDevice(int deviceId)",
    "returnType" : "void",
    "comment" : "\n     * API to add a hardware device in the TvInputHardwareManager for CTS testing\n     * purpose.\n     *\n     * @param deviceId Id of the adding hardware device.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void removeHardwareDevice(int deviceId)",
    "returnType" : "void",
    "comment" : "\n     * API to remove a hardware device in the TvInputHardwareManager for CTS testing\n     * purpose.\n     *\n     * @param deviceId Id of the removing hardware device.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private Hardware acquireTvInputHardwareInternal(int deviceId, TvInputInfo info, String tvInputSessionId, int priorityHint, Executor executor, final HardwareCallback callback)",
    "returnType" : "Hardware",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void releaseTvInputHardware(int deviceId, Hardware hardware)",
    "returnType" : "void",
    "comment" : "\n     * Releases previously acquired hardware object.\n     *\n     * @param deviceId The device ID this Hardware was acquired for\n     * @param hardware Hardware to release.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<DvbDeviceInfo> getDvbDeviceList()",
    "returnType" : "List<DvbDeviceInfo>",
    "comment" : "\n     * Returns the list of currently available DVB frontend devices on the system.\n     *\n     * @return the list of {@link DvbDeviceInfo} objects representing available DVB devices.\n     * @hide\n     ",
    "links" : [ "android.media.tv.DvbDeviceInfo" ]
  }, {
    "name" : "public ParcelFileDescriptor openDvbDevice(@NonNull DvbDeviceInfo info, @DvbDeviceType int deviceType)",
    "returnType" : "ParcelFileDescriptor",
    "comment" : "\n     * Returns a {@link ParcelFileDescriptor} of a specified DVB device of a given type for a given\n     * {@link DvbDeviceInfo}.\n     *\n     * @param info A {@link DvbDeviceInfo} to open a DVB device.\n     * @param deviceType A DVB device type.\n     * @return a {@link ParcelFileDescriptor} of a specified DVB device for a given\n     * {@link DvbDeviceInfo}, or {@code null} if the given {@link DvbDeviceInfo}\n     * failed to open.\n     * @throws IllegalArgumentException if {@code deviceType} is invalid or the device is not found.\n\n     * @see <a href=\"https://www.linuxtv.org/docs/dvbapi/dvbapi.html\">Linux DVB API v3</a>\n     * @hide\n     ",
    "links" : [ "android.media.tv.DvbDeviceInfo", "android.os.ParcelFileDescriptor" ]
  }, {
    "name" : "public void requestChannelBrowsable(Uri channelUri)",
    "returnType" : "void",
    "comment" : "\n     * Requests to make a channel browsable.\n     *\n     * <p>Once called, the system will review the request and make the channel browsable based on\n     * its policy. The first request from a package is guaranteed to be approved.\n     *\n     * @param channelUri The URI for the channel to be browsable.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<TunedInfo> getCurrentTunedInfos()",
    "returnType" : "List<TunedInfo>",
    "comment" : "\n     * Returns the list of session information for {@link TvInputService.Session} that are\n     * currently in use.\n     * <p> Permission com.android.providers.tv.permission.ACCESS_WATCHED_PROGRAMS is required to get\n     * the channel URIs. If the permission is not granted,\n     * {@link TunedInfo#getChannelUri()} returns {@code null}.\n     * @hide\n     ",
    "links" : [ "android.media.tv.TunedInfo#getChannelUri()", "TvInputService.Session" ]
  } ],
  "methodNames" : [ "public List<TvInputInfo> getTvInputList()", "public TvInputInfo getTvInputInfo(@NonNull String inputId)", "public void updateTvInputInfo(@NonNull TvInputInfo inputInfo)", "public int getInputState(@NonNull String inputId)", "public List<String> getAvailableExtensionInterfaceNames(@NonNull String inputId)", "public IBinder getExtensionInterface(@NonNull String inputId, @NonNull String name)", "public void registerCallback(@NonNull TvInputCallback callback, @NonNull Handler handler)", "public void unregisterCallback(@NonNull final TvInputCallback callback)", "public boolean isParentalControlsEnabled()", "public void setParentalControlsEnabled(boolean enabled)", "public boolean isRatingBlocked(@NonNull TvContentRating rating)", "public List<TvContentRating> getBlockedRatings()", "public void addBlockedRating(@NonNull TvContentRating rating)", "public void removeBlockedRating(@NonNull TvContentRating rating)", "public List<TvContentRatingSystemInfo> getTvContentRatingSystemList()", "public void notifyPreviewProgramBrowsableDisabled(String packageName, long programId)", "public void notifyWatchNextProgramBrowsableDisabled(String packageName, long programId)", "public void notifyPreviewProgramAddedToWatchNext(String packageName, long previewProgramId, long watchNextProgramId)", "public void createSession(@NonNull String inputId, @NonNull AttributionSource tvAppAttributionSource, @NonNull final SessionCallback callback, @NonNull Handler handler)", "public int getClientPid(@NonNull String sessionId)", "public int getClientPriority(@TvInputService.PriorityHintUseCaseType int useCase, @NonNull String sessionId)", "public int getClientPriority(@TvInputService.PriorityHintUseCaseType int useCase)", "public void createRecordingSession(@NonNull String inputId, @NonNull final SessionCallback callback, @NonNull Handler handler)", "private void createSessionInternal(String inputId, AttributionSource tvAppAttributionSource, boolean isRecordingSession, SessionCallback callback, Handler handler)", "private int getClientPidInternal(String sessionId)", "private int getClientPriorityInternal(int useCase, String sessionId)", "private boolean isValidUseCase(int useCase)", "public List<TvStreamConfig> getAvailableTvStreamConfigList(String inputId)", "public boolean captureFrame(String inputId, Surface surface, TvStreamConfig config)", "public boolean isSingleSessionActive()", "public List<TvInputHardwareInfo> getHardwareList()", "public Hardware acquireTvInputHardware(int deviceId, final HardwareCallback callback, TvInputInfo info)", "public Hardware acquireTvInputHardware(int deviceId, @NonNull TvInputInfo info, @NonNull final HardwareCallback callback)", "public Hardware acquireTvInputHardware(int deviceId, @NonNull TvInputInfo info, @Nullable String tvInputSessionId, @TvInputService.PriorityHintUseCaseType int priorityHint, @NonNull @CallbackExecutor Executor executor, @NonNull final HardwareCallback callback)", "public void addHardwareDevice(int deviceId)", "public void removeHardwareDevice(int deviceId)", "private Hardware acquireTvInputHardwareInternal(int deviceId, TvInputInfo info, String tvInputSessionId, int priorityHint, Executor executor, final HardwareCallback callback)", "public void releaseTvInputHardware(int deviceId, Hardware hardware)", "public List<DvbDeviceInfo> getDvbDeviceList()", "public ParcelFileDescriptor openDvbDevice(@NonNull DvbDeviceInfo info, @DvbDeviceType int deviceType)", "public void requestChannelBrowsable(Uri channelUri)", "public List<TunedInfo> getCurrentTunedInfos()" ],
  "variableNames" : [ "TAG", "DVB_DEVICE_START", "DVB_DEVICE_END", "DVB_DEVICE_DEMUX", "DVB_DEVICE_DVR", "DVB_DEVICE_FRONTEND", "TV_MESSAGE_TYPE_WATERMARK", "TV_MESSAGE_TYPE_CLOSED_CAPTION", "TV_MESSAGE_TYPE_OTHER", "TV_MESSAGE_KEY_STREAM_ID", "TV_MESSAGE_GROUP_ID_NONE", "TV_MESSAGE_KEY_GROUP_ID", "TV_MESSAGE_SUBTYPE_WATERMARKING_A335", "TV_MESSAGE_SUBTYPE_CC_608E", "TV_MESSAGE_KEY_SUBTYPE", "TV_MESSAGE_KEY_RAW_DATA", "VIDEO_UNAVAILABLE_REASON_START", "VIDEO_UNAVAILABLE_REASON_END", "VIDEO_UNAVAILABLE_REASON_UNKNOWN", "VIDEO_UNAVAILABLE_REASON_TUNING", "VIDEO_UNAVAILABLE_REASON_WEAK_SIGNAL", "VIDEO_UNAVAILABLE_REASON_BUFFERING", "VIDEO_UNAVAILABLE_REASON_AUDIO_ONLY", "VIDEO_UNAVAILABLE_REASON_NOT_CONNECTED", "VIDEO_UNAVAILABLE_REASON_INSUFFICIENT_RESOURCE", "VIDEO_UNAVAILABLE_REASON_CAS_INSUFFICIENT_OUTPUT_PROTECTION", "VIDEO_UNAVAILABLE_REASON_CAS_PVR_RECORDING_NOT_ALLOWED", "VIDEO_UNAVAILABLE_REASON_CAS_NO_LICENSE", "VIDEO_UNAVAILABLE_REASON_CAS_LICENSE_EXPIRED", "VIDEO_UNAVAILABLE_REASON_CAS_NEED_ACTIVATION", "VIDEO_UNAVAILABLE_REASON_CAS_NEED_PAIRING", "VIDEO_UNAVAILABLE_REASON_CAS_NO_CARD", "VIDEO_UNAVAILABLE_REASON_CAS_CARD_MUTE", "VIDEO_UNAVAILABLE_REASON_CAS_CARD_INVALID", "VIDEO_UNAVAILABLE_REASON_CAS_BLACKOUT", "VIDEO_UNAVAILABLE_REASON_CAS_REBOOTING", "VIDEO_UNAVAILABLE_REASON_CAS_UNKNOWN", "VIDEO_UNAVAILABLE_REASON_STOPPED", "TIME_SHIFT_STATUS_UNKNOWN", "TIME_SHIFT_STATUS_UNSUPPORTED", "TIME_SHIFT_STATUS_UNAVAILABLE", "TIME_SHIFT_STATUS_AVAILABLE", "TIME_SHIFT_INVALID_TIME", "TIME_SHIFT_MODE_OFF", "TIME_SHIFT_MODE_LOCAL", "TIME_SHIFT_MODE_NETWORK", "TIME_SHIFT_MODE_AUTO", "RECORDING_ERROR_START", "RECORDING_ERROR_END", "RECORDING_ERROR_UNKNOWN", "RECORDING_ERROR_INSUFFICIENT_SPACE", "RECORDING_ERROR_RESOURCE_BUSY", "INPUT_STATE_CONNECTED", "INPUT_STATE_CONNECTED_STANDBY", "INPUT_STATE_DISCONNECTED", "BROADCAST_INFO_TYPE_TS", "BROADCAST_INFO_TYPE_TABLE", "BROADCAST_INFO_TYPE_SECTION", "BROADCAST_INFO_TYPE_PES", "BROADCAST_INFO_STREAM_EVENT", "BROADCAST_INFO_TYPE_DSMCC", "BROADCAST_INFO_TYPE_COMMAND", "BROADCAST_INFO_TYPE_TIMELINE", "BROADCAST_INFO_TYPE_SIGNALING_DATA", "SIGNAL_STRENGTH_LOST", "SIGNAL_STRENGTH_WEAK", "SIGNAL_STRENGTH_STRONG", "SESSION_DATA_TYPE_TUNED", "SESSION_DATA_TYPE_TRACK_SELECTED", "SESSION_DATA_TYPE_TRACKS_CHANGED", "SESSION_DATA_TYPE_VIDEO_AVAILABLE", "SESSION_DATA_TYPE_VIDEO_UNAVAILABLE", "SESSION_DATA_TYPE_BROADCAST_INFO_RESPONSE", "SESSION_DATA_TYPE_AD_RESPONSE", "SESSION_DATA_TYPE_AD_BUFFER_CONSUMED", "SESSION_DATA_TYPE_TV_MESSAGE", "SESSION_DATA_KEY_CHANNEL_URI", "SESSION_DATA_KEY_TRACK_TYPE", "SESSION_DATA_KEY_TRACK_ID", "SESSION_DATA_KEY_TRACKS", "SESSION_DATA_KEY_VIDEO_UNAVAILABLE_REASON", "SESSION_DATA_KEY_BROADCAST_INFO_RESPONSE", "SESSION_DATA_KEY_AD_RESPONSE", "SESSION_DATA_KEY_AD_BUFFER", "SESSION_DATA_KEY_TV_MESSAGE_TYPE", "UNKNOWN_CLIENT_PID", "ACTION_BLOCKED_RATINGS_CHANGED", "ACTION_PARENTAL_CONTROLS_ENABLED_CHANGED", "ACTION_QUERY_CONTENT_RATING_SYSTEMS", "META_DATA_CONTENT_RATING_SYSTEMS", "ACTION_SETUP_INPUTS", "ACTION_VIEW_RECORDING_SCHEDULES", "mService", "mLock", "mCallbackRecords", "mStateMap", "mSessionCallbackRecordMap", "mNextSeq", "mClient", "mUserId" ]
}