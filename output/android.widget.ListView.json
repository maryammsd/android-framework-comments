{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/widget/ListView.java",
  "packageName" : "android.widget",
  "className" : "ListView",
  "comment" : "\n * <p>Displays a vertically-scrollable collection of views, where each view is positioned\n * immediatelybelow the previous view in the list.  For a more modern, flexible, and performant\n * approach to displaying lists, use {@link android.support.v7.widget.RecyclerView}.</p>\n *\n * <p>To display a list, you can include a list view in your layout XML file:</p>\n *\n * <pre>&lt;ListView\n *      android:id=\"@+id/list_view\"\n *      android:layout_width=\"match_parent\"\n *      android:layout_height=\"match_parent\" /&gt;</pre>\n *\n * <p>A list view is an <a href=\"{@docRoot}guide/topics/ui/declaring-layout.html#AdapterViews\">\n * adapter view</a> that does not know the details, such as type and contents, of the views it\n * contains. Instead list view requests views on demand from a {@link ListAdapter} as needed,\n * such as to display new views as the user scrolls up or down.</p>\n *\n * <p>In order to display items in the list, call {@link #setAdapter(ListAdapter adapter)}\n * to associate an adapter with the list.  For a simple example, see the discussion of filling an\n * adapter view with text in the\n * <a href=\"{@docRoot}guide/topics/ui/declaring-layout.html#FillingTheLayout\">\n * Layouts</a> guide.</p>\n *\n * <p>To display a more custom view for each item in your dataset, implement a ListAdapter.\n * For example, extend {@link BaseAdapter} and create and configure the view for each data item in\n * {@code getView(...)}:</p>\n *\n *  <pre>private class MyAdapter extends BaseAdapter {\n *\n *      // override other abstract methods here\n *\n *      &#64;Override\n *      public View getView(int position, View convertView, ViewGroup container) {\n *          if (convertView == null) {\n *              convertView = getLayoutInflater().inflate(R.layout.list_item, container, false);\n *          }\n *\n *          ((TextView) convertView.findViewById(android.R.id.text1))\n *                  .setText(getItem(position));\n *          return convertView;\n *      }\n *  }</pre>\n *\n * <p class=\"note\">ListView attempts to reuse view objects in order to improve performance and\n * avoid a lag in response to user scrolls.  To take advantage of this feature, check if the\n * {@code convertView} provided to {@code getView(...)} is null before creating or inflating a new\n * view object.  See\n * <a href=\"{@docRoot}training/improving-layouts/smooth-scrolling.html\">\n * Making ListView Scrolling Smooth</a> for more ways to ensure a smooth user experience.</p>\n *\n * <p>To specify an action when a user clicks or taps on a single list item, see\n * <a href=\"{@docRoot}guide/topics/ui/declaring-layout.html#HandlingUserSelections\">\n *     Handling click events</a>.</p>\n *\n * <p>To learn how to populate a list view with a CursorAdapter, see the discussion of filling an\n * adapter view with text in the\n * <a href=\"{@docRoot}guide/topics/ui/declaring-layout.html#FillingTheLayout\">\n * Layouts</a> guide.\n * See <a href=\"{@docRoot}guide/topics/ui/layout/listview.html\">\n *     Using a Loader</a>\n * to learn how to avoid blocking the main thread when using a cursor.</p>\n *\n * <p class=\"note\">Note, many examples use {@link android.app.ListActivity ListActivity}\n * or {@link android.app.ListFragment ListFragment}\n * to display a list view. Instead, favor the more flexible approach when writing your own app:\n * use a more generic Activity subclass or Fragment subclass and add a list view to the layout\n * or view hierarchy directly.  This approach gives you more direct control of the\n * list view and adapter.</p>\n *\n * @attr ref android.R.styleable#ListView_entries\n * @attr ref android.R.styleable#ListView_divider\n * @attr ref android.R.styleable#ListView_dividerHeight\n * @attr ref android.R.styleable#ListView_headerDividersEnabled\n * @attr ref android.R.styleable#ListView_footerDividersEnabled\n ",
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NO_POSITION",
    "type" : "int",
    "comment" : "\n     * Used to indicate a no preference for a position type.\n     ",
    "links" : [ ]
  }, {
    "name" : "MAX_SCROLL_FACTOR",
    "type" : "float",
    "comment" : "\n     * When arrow scrolling, ListView will never scroll more than this factor\n     * times the height of the list.\n     ",
    "links" : [ ]
  }, {
    "name" : "MIN_SCROLL_PREVIEW_PIXELS",
    "type" : "int",
    "comment" : "\n     * When arrow scrolling, need a certain amount of pixels to preview next\n     * items.  This is usually the fading edge, but if that is small enough,\n     * we want to make sure we preview at least this many pixels.\n     ",
    "links" : [ ]
  }, {
    "name" : "mHeaderViewInfos",
    "type" : "ArrayList<FixedViewInfo>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFooterViewInfos",
    "type" : "ArrayList<FixedViewInfo>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDivider",
    "type" : "Drawable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDividerHeight",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOverScrollHeader",
    "type" : "Drawable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOverScrollFooter",
    "type" : "Drawable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsCacheColorOpaque",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDividerIsOpaque",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHeaderDividersEnabled",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFooterDividersEnabled",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mAreAllItemsSelectable",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mItemsCanFocus",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTempRect",
    "type" : "Rect",
    "comment" : " used for temporary calculations.",
    "links" : [ ]
  }, {
    "name" : "mDividerPaint",
    "type" : "Paint",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mArrowScrollFocusResult",
    "type" : "ArrowScrollFocusResult",
    "comment" : " allocating these thingies too often.",
    "links" : [ ]
  }, {
    "name" : "mFocusSelector",
    "type" : "FocusSelector",
    "comment" : " Keeps focused children visible through resizes",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public int getMaxScrollAmount()",
    "returnType" : "int",
    "comment" : "\n     * @return The maximum amount a list view will scroll in response to\n     *   an arrow event.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void adjustViewsUpOrDown()",
    "returnType" : "void",
    "comment" : "\n     * Make sure views are touching the top or bottom edge, as appropriate for\n     * our gravity\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addHeaderView(View v, Object data, boolean isSelectable)",
    "returnType" : "void",
    "comment" : "\n     * Add a fixed view to appear at the top of the list. If this method is\n     * called more than once, the views will appear in the order they were\n     * added. Views added using this call can take focus if they want.\n     * <p>\n     * Note: When first introduced, this method could only be called before\n     * setting the adapter with {@link #setAdapter(ListAdapter)}. Starting with\n     * {@link android.os.Build.VERSION_CODES#KITKAT}, this method may be\n     * called at any time. If the ListView's adapter does not extend\n     * {@link HeaderViewListAdapter}, it will be wrapped with a supporting\n     * instance of {@link WrapperListAdapter}.\n     *\n     * @param v The view to add.\n     * @param data Data to associate with this view\n     * @param isSelectable whether the item is selectable\n     ",
    "links" : [ "#setAdapter(ListAdapter)", "android.widget.HeaderViewListAdapter", "android.os.Build.VERSION_CODES#KITKAT", "android.widget.WrapperListAdapter" ]
  }, {
    "name" : "public void addHeaderView(View v)",
    "returnType" : "void",
    "comment" : "\n     * Add a fixed view to appear at the top of the list. If addHeaderView is\n     * called more than once, the views will appear in the order they were\n     * added. Views added using this call can take focus if they want.\n     * <p>\n     * Note: When first introduced, this method could only be called before\n     * setting the adapter with {@link #setAdapter(ListAdapter)}. Starting with\n     * {@link android.os.Build.VERSION_CODES#KITKAT}, this method may be\n     * called at any time. If the ListView's adapter does not extend\n     * {@link HeaderViewListAdapter}, it will be wrapped with a supporting\n     * instance of {@link WrapperListAdapter}.\n     *\n     * @param v The view to add.\n     ",
    "links" : [ "#setAdapter(ListAdapter)", "android.widget.HeaderViewListAdapter", "android.os.Build.VERSION_CODES#KITKAT", "android.widget.WrapperListAdapter" ]
  }, {
    "name" : "public int getHeaderViewsCount()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean removeHeaderView(View v)",
    "returnType" : "boolean",
    "comment" : "\n     * Removes a previously-added header view.\n     *\n     * @param v The view to remove\n     * @return true if the view was removed, false if the view was not a header\n     *         view\n     ",
    "links" : [ ]
  }, {
    "name" : "private void removeFixedViewInfo(View v, ArrayList<FixedViewInfo> where)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void addFooterView(View v, Object data, boolean isSelectable)",
    "returnType" : "void",
    "comment" : "\n     * Add a fixed view to appear at the bottom of the list. If addFooterView is\n     * called more than once, the views will appear in the order they were\n     * added. Views added using this call can take focus if they want.\n     * <p>\n     * Note: When first introduced, this method could only be called before\n     * setting the adapter with {@link #setAdapter(ListAdapter)}. Starting with\n     * {@link android.os.Build.VERSION_CODES#KITKAT}, this method may be\n     * called at any time. If the ListView's adapter does not extend\n     * {@link HeaderViewListAdapter}, it will be wrapped with a supporting\n     * instance of {@link WrapperListAdapter}.\n     *\n     * @param v The view to add.\n     * @param data Data to associate with this view\n     * @param isSelectable true if the footer view can be selected\n     ",
    "links" : [ "#setAdapter(ListAdapter)", "android.widget.HeaderViewListAdapter", "android.os.Build.VERSION_CODES#KITKAT", "android.widget.WrapperListAdapter" ]
  }, {
    "name" : "public void addFooterView(View v)",
    "returnType" : "void",
    "comment" : "\n     * Add a fixed view to appear at the bottom of the list. If addFooterView is\n     * called more than once, the views will appear in the order they were\n     * added. Views added using this call can take focus if they want.\n     * <p>\n     * Note: When first introduced, this method could only be called before\n     * setting the adapter with {@link #setAdapter(ListAdapter)}. Starting with\n     * {@link android.os.Build.VERSION_CODES#KITKAT}, this method may be\n     * called at any time. If the ListView's adapter does not extend\n     * {@link HeaderViewListAdapter}, it will be wrapped with a supporting\n     * instance of {@link WrapperListAdapter}.\n     *\n     * @param v The view to add.\n     ",
    "links" : [ "#setAdapter(ListAdapter)", "android.widget.HeaderViewListAdapter", "android.os.Build.VERSION_CODES#KITKAT", "android.widget.WrapperListAdapter" ]
  }, {
    "name" : "public int getFooterViewsCount()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean removeFooterView(View v)",
    "returnType" : "boolean",
    "comment" : "\n     * Removes a previously-added footer view.\n     *\n     * @param v The view to remove\n     * @return\n     * true if the view was removed, false if the view was not a footer view\n     ",
    "links" : [ ]
  }, {
    "name" : "public ListAdapter getAdapter()",
    "returnType" : "ListAdapter",
    "comment" : "\n     * Returns the adapter currently in use in this ListView. The returned adapter\n     * might not be the same adapter passed to {@link #setAdapter(ListAdapter)} but\n     * might be a {@link WrapperListAdapter}.\n     *\n     * @return The adapter currently used to display data in this ListView.\n     *\n     * @see #setAdapter(ListAdapter)\n     ",
    "links" : [ "#setAdapter(ListAdapter)", "android.widget.WrapperListAdapter" ]
  }, {
    "name" : "public void setRemoteViewsAdapter(Intent intent)",
    "returnType" : "void",
    "comment" : "\n     * Sets up this AbsListView to use a remote views adapter which connects to a RemoteViewsService\n     * through the specified intent.\n     * @param intent the intent used to identify the RemoteViewsService for the adapter to connect to.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAdapter(ListAdapter adapter)",
    "returnType" : "void",
    "comment" : "\n     * Sets the data behind this ListView.\n     *\n     * The adapter passed to this method may be wrapped by a {@link WrapperListAdapter},\n     * depending on the ListView features currently in use. For instance, adding\n     * headers and/or footers will cause the adapter to be wrapped.\n     *\n     * @param adapter The ListAdapter which is responsible for maintaining the\n     *        data backing this list and for producing a view to represent an\n     *        item in that data set.\n     *\n     * @see #getAdapter()\n     ",
    "links" : [ "android.widget.WrapperListAdapter" ]
  }, {
    "name" : " void resetList()",
    "returnType" : "void",
    "comment" : "\n     * The list is empty. Clear everything out.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void clearRecycledState(ArrayList<FixedViewInfo> infos)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean showingTopFadingEdge()",
    "returnType" : "boolean",
    "comment" : "\n     * @return Whether the list needs to show the top fading edge\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean showingBottomFadingEdge()",
    "returnType" : "boolean",
    "comment" : "\n     * @return Whether the list needs to show the bottom fading edge\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean requestChildRectangleOnScreen(View child, Rect rect, boolean immediate)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void fillGap(boolean down)",
    "returnType" : "void",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "private View fillDown(int pos, int nextTop)",
    "returnType" : "View",
    "comment" : "\n     * Fills the list from pos down to the end of the list view.\n     *\n     * @param pos The first position to put in the list\n     *\n     * @param nextTop The location where the top of the item associated with pos\n     *        should be drawn\n     *\n     * @return The view that is currently selected, if it happens to be in the\n     *         range that we draw.\n     ",
    "links" : [ ]
  }, {
    "name" : "private View fillUp(int pos, int nextBottom)",
    "returnType" : "View",
    "comment" : "\n     * Fills the list from pos up to the top of the list view.\n     *\n     * @param pos The first position to put in the list\n     *\n     * @param nextBottom The location where the bottom of the item associated\n     *        with pos should be drawn\n     *\n     * @return The view that is currently selected\n     ",
    "links" : [ ]
  }, {
    "name" : "private View fillFromTop(int nextTop)",
    "returnType" : "View",
    "comment" : "\n     * Fills the list from top to bottom, starting with mFirstPosition\n     *\n     * @param nextTop The location where the top of the first item should be\n     *        drawn\n     *\n     * @return The view that is currently selected\n     ",
    "links" : [ ]
  }, {
    "name" : "private View fillFromMiddle(int childrenTop, int childrenBottom)",
    "returnType" : "View",
    "comment" : "\n     * Put mSelectedPosition in the middle of the screen and then build up and\n     * down from there. This method forces mSelectedPosition to the center.\n     *\n     * @param childrenTop Top of the area in which children can be drawn, as\n     *        measured in pixels\n     * @param childrenBottom Bottom of the area in which children can be drawn,\n     *        as measured in pixels\n     * @return Currently selected view\n     ",
    "links" : [ ]
  }, {
    "name" : "private void fillAboveAndBelow(View sel, int position)",
    "returnType" : "void",
    "comment" : "\n     * Once the selected view as been placed, fill up the visible area above and\n     * below it.\n     *\n     * @param sel The selected view\n     * @param position The position corresponding to sel\n     ",
    "links" : [ ]
  }, {
    "name" : "private View fillFromSelection(int selectedTop, int childrenTop, int childrenBottom)",
    "returnType" : "View",
    "comment" : "\n     * Fills the grid based on positioning the new selection at a specific\n     * location. The selection may be moved so that it does not intersect the\n     * faded edges. The grid is then filled upwards and downwards from there.\n     *\n     * @param selectedTop Where the selected item should be\n     * @param childrenTop Where to start drawing children\n     * @param childrenBottom Last pixel where children can be drawn\n     * @return The view that currently has selection\n     ",
    "links" : [ ]
  }, {
    "name" : "private int getBottomSelectionPixel(int childrenBottom, int fadingEdgeLength, int selectedPosition)",
    "returnType" : "int",
    "comment" : "\n     * Calculate the bottom-most pixel we can draw the selection into\n     *\n     * @param childrenBottom Bottom pixel were children can be drawn\n     * @param fadingEdgeLength Length of the fading edge in pixels, if present\n     * @param selectedPosition The position that will be selected\n     * @return The bottom-most pixel we can draw the selection into\n     ",
    "links" : [ ]
  }, {
    "name" : "private int getTopSelectionPixel(int childrenTop, int fadingEdgeLength, int selectedPosition)",
    "returnType" : "int",
    "comment" : "\n     * Calculate the top-most pixel we can draw the selection into\n     *\n     * @param childrenTop Top pixel were children can be drawn\n     * @param fadingEdgeLength Length of the fading edge in pixels, if present\n     * @param selectedPosition The position that will be selected\n     * @return The top-most pixel we can draw the selection into\n     ",
    "links" : [ ]
  }, {
    "name" : "public void smoothScrollToPosition(int position)",
    "returnType" : "void",
    "comment" : "\n     * Smoothly scroll to the specified adapter position. The view will\n     * scroll such that the indicated position is displayed.\n     * @param position Scroll to this adapter position.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void smoothScrollByOffset(int offset)",
    "returnType" : "void",
    "comment" : "\n     * Smoothly scroll to the specified adapter position offset. The view will\n     * scroll such that the indicated position is displayed.\n     * @param offset The amount to offset from the adapter position to scroll to.\n     ",
    "links" : [ ]
  }, {
    "name" : "private View moveSelection(View oldSel, View newSel, int delta, int childrenTop, int childrenBottom)",
    "returnType" : "View",
    "comment" : "\n     * Fills the list based on positioning the new selection relative to the old\n     * selection. The new selection will be placed at, above, or below the\n     * location of the new selection depending on how the selection is moving.\n     * The selection will then be pinned to the visible part of the screen,\n     * excluding the edges that are faded. The list is then filled upwards and\n     * downwards from there.\n     *\n     * @param oldSel The old selected view. Useful for trying to put the new\n     *        selection in the same place\n     * @param newSel The view that is to become selected. Useful for trying to\n     *        put the new selection in the same place\n     * @param delta Which way we are moving\n     * @param childrenTop Where to start drawing children\n     * @param childrenBottom Last pixel where children can be drawn\n     * @return The view that currently has selection\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void onDetachedFromWindow()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void onSizeChanged(int w, int h, int oldw, int oldh)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void measureScrapChild(View child, int position, int widthMeasureSpec, int heightHint)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected boolean recycleOnMeasure()",
    "returnType" : "boolean",
    "comment" : "\n     * @return True to recycle the views used to measure this ListView in\n     *         UNSPECIFIED/AT_MOST modes, false otherwise.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " final int measureHeightOfChildren(int widthMeasureSpec, int startPosition, int endPosition, int maxHeight, int disallowPartialChildPosition)",
    "returnType" : "int",
    "comment" : "\n     * Measures the height of the given range of children (inclusive) and\n     * returns the height with this ListView's padding and divider heights\n     * included. If maxHeight is provided, the measuring will stop when the\n     * current height reaches maxHeight.\n     *\n     * @param widthMeasureSpec The width measure spec to be given to a child's\n     *            {@link View#measure(int, int)}.\n     * @param startPosition The position of the first child to be shown.\n     * @param endPosition The (inclusive) position of the last child to be\n     *            shown. Specify {@link #NO_POSITION} if the last child should be\n     *            the last available child from the adapter.\n     * @param maxHeight The maximum height that will be returned (if all the\n     *            children don't fit in this value, this value will be\n     *            returned).\n     * @param disallowPartialChildPosition In general, whether the returned\n     *            height should only contain entire children. This is more\n     *            powerful--it is the first inclusive position at which partial\n     *            children will not be allowed. Example: it looks nice to have\n     *            at least 3 completely visible children, and in portrait this\n     *            will most likely fit; but in landscape there could be times\n     *            when even 2 children can not be completely shown, so a value\n     *            of 2 (remember, inclusive) would be good (assuming\n     *            startPosition is 0).\n     * @return The height of this ListView with the given children.\n     ",
    "links" : [ "android.view.View#measure(int", "#NO_POSITION" ]
  }, {
    "name" : " int findMotionRow(int y)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private View fillSpecific(int position, int top)",
    "returnType" : "View",
    "comment" : "\n     * Put a specific item at a specific location on the screen and then build\n     * up and down from there.\n     *\n     * @param position The reference view to use as the starting point\n     * @param top Pixel offset from the top of this view to the top of the\n     *        reference view.\n     *\n     * @return The selected view, or null if the selected view is outside the\n     *         visible area.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void correctTooHigh(int childCount)",
    "returnType" : "void",
    "comment" : "\n     * Check if we have dragged the bottom of the list too high (we have pushed the\n     * top element off the top of the screen when we did not need to). Correct by sliding\n     * everything back down.\n     *\n     * @param childCount Number of children\n     ",
    "links" : [ ]
  }, {
    "name" : "private void correctTooLow(int childCount)",
    "returnType" : "void",
    "comment" : "\n     * Check if we have dragged the bottom of the list too low (we have pushed the\n     * bottom element off the bottom of the screen when we did not need to). Correct by sliding\n     * everything back up.\n     *\n     * @param childCount Number of children\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void layoutChildren()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean trackMotionScroll(int deltaY, int incrementalDeltaY)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void removeUnusedFixedViews(@Nullable List<FixedViewInfo> infoList)",
    "returnType" : "void",
    "comment" : "\n     * Header and Footer views are not scrapped / recycled like other views but they are still\n     * detached from the ViewGroup. After a layout operation, call this method to remove such views.\n     *\n     * @param infoList The info list to be traversed\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isDirectChildHeaderOrFooter(View child)",
    "returnType" : "boolean",
    "comment" : "\n     * @param child a direct child of this list.\n     * @return Whether child is a header or footer view.\n     ",
    "links" : [ ]
  }, {
    "name" : "private View makeAndAddView(int position, int y, boolean flow, int childrenLeft, boolean selected)",
    "returnType" : "View",
    "comment" : "\n     * Obtains the view and adds it to our list of children. The view can be\n     * made fresh, converted from an unused view, or used as is if it was in\n     * the recycle bin.\n     *\n     * @param position logical position in the list\n     * @param y top or bottom edge of the view to add\n     * @param flow {@code true} to align top edge to y, {@code false} to align\n     *             bottom edge to y\n     * @param childrenLeft left edge where children should be positioned\n     * @param selected {@code true} if the position is selected, {@code false}\n     *                 otherwise\n     * @return the view that was added\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setupChild(View child, int position, int y, boolean flowDown, int childrenLeft, boolean selected, boolean isAttachedToWindow)",
    "returnType" : "void",
    "comment" : "\n     * Adds a view as a child and make sure it is measured (if necessary) and\n     * positioned properly.\n     *\n     * @param child the view to add\n     * @param position the position of this child\n     * @param y the y position relative to which this view will be positioned\n     * @param flowDown {@code true} to align top edge to y, {@code false} to\n     *                 align bottom edge to y\n     * @param childrenLeft left edge where children should be positioned\n     * @param selected {@code true} if the position is selected, {@code false}\n     *                 otherwise\n     * @param isAttachedToWindow {@code true} if the view is already attached\n     *                           to the window, e.g. whether it was reused, or\n     *                           {@code false} otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "protected boolean canAnimate()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setSelection(int position)",
    "returnType" : "void",
    "comment" : "\n     * Sets the currently selected item. If in touch mode, the item will not be selected\n     * but it will still be positioned appropriately. If the specified selection position\n     * is less than 0, then the item at position 0 will be selected.\n     *\n     * @param position Index (starting at 0) of the data item to be selected.\n     ",
    "links" : [ ]
  }, {
    "name" : " void setSelectionInt(int position)",
    "returnType" : "void",
    "comment" : "\n     * Makes the item at the supplied position selected.\n     *\n     * @param position the position of the item to select\n     ",
    "links" : [ ]
  }, {
    "name" : " int lookForSelectablePosition(int position, boolean lookDown)",
    "returnType" : "int",
    "comment" : "\n     * Find a position that can be selected (i.e., is not a separator).\n     *\n     * @param position The starting position to look at.\n     * @param lookDown Whether to look down for other positions.\n     * @return The next selectable position starting at position and then searching either up or\n     *         down. Returns {@link #INVALID_POSITION} if nothing can be found.\n     ",
    "links" : [ "#INVALID_POSITION" ]
  }, {
    "name" : " int lookForSelectablePositionAfter(int current, int position, boolean lookDown)",
    "returnType" : "int",
    "comment" : "\n     * Find a position that can be selected (i.e., is not a separator). If there\n     * are no selectable positions in the specified direction from the starting\n     * position, searches in the opposite direction from the starting position\n     * to the current position.\n     *\n     * @param current the current position\n     * @param position the starting position\n     * @param lookDown whether to look down for other positions\n     * @return the next selectable position, or {@link #INVALID_POSITION} if\n     *         nothing can be found\n     ",
    "links" : [ "#INVALID_POSITION" ]
  }, {
    "name" : "public void setSelectionAfterHeaderView()",
    "returnType" : "void",
    "comment" : "\n     * setSelectionAfterHeaderView set the selection to be the first list item\n     * after the header views.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean dispatchKeyEvent(KeyEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean onKeyDown(int keyCode, KeyEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean onKeyMultiple(int keyCode, int repeatCount, KeyEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean onKeyUp(int keyCode, KeyEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean commonKey(int keyCode, int count, KeyEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean pageScroll(int direction)",
    "returnType" : "boolean",
    "comment" : "\n     * Scrolls up or down by the number of items currently present on screen.\n     *\n     * @param direction either {@link View#FOCUS_UP} or {@link View#FOCUS_DOWN}\n     * @return whether selection was moved\n     ",
    "links" : [ "android.view.View#FOCUS_DOWN", "android.view.View#FOCUS_UP" ]
  }, {
    "name" : " boolean fullScroll(int direction)",
    "returnType" : "boolean",
    "comment" : "\n     * Go to the last or first item if possible (not worrying about panning\n     * across or navigating within the internal focus of the currently selected\n     * item.)\n     *\n     * @param direction either {@link View#FOCUS_UP} or {@link View#FOCUS_DOWN}\n     * @return whether selection was moved\n     ",
    "links" : [ "android.view.View#FOCUS_DOWN", "android.view.View#FOCUS_UP" ]
  }, {
    "name" : "private boolean handleHorizontalFocusWithinListItem(int direction)",
    "returnType" : "boolean",
    "comment" : "\n     * To avoid horizontal focus searches changing the selected item, we\n     * manually focus search within the selected item (as applicable), and\n     * prevent focus from jumping to something within another item.\n     * @param direction one of {View.FOCUS_LEFT, View.FOCUS_RIGHT}\n     * @return Whether this consumes the key event.\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean arrowScroll(int direction)",
    "returnType" : "boolean",
    "comment" : "\n     * Scrolls to the next or previous item if possible.\n     *\n     * @param direction either {@link View#FOCUS_UP} or {@link View#FOCUS_DOWN}\n     *\n     * @return whether selection was moved\n     ",
    "links" : [ "android.view.View#FOCUS_DOWN", "android.view.View#FOCUS_UP" ]
  }, {
    "name" : "private final int nextSelectedPositionForDirection(View selectedView, int selectedPos, int direction)",
    "returnType" : "int",
    "comment" : "\n     * Used by {@link #arrowScrollImpl(int)} to help determine the next selected position\n     * to move to. This return a position in the direction given if the selected item\n     * is fully visible.\n     *\n     * @param selectedView Current selected view to move from\n     * @param selectedPos Current selected position to move from\n     * @param direction Direction to move in\n     * @return Desired selected position after moving in the given direction\n     ",
    "links" : [ "#arrowScrollImpl(int)" ]
  }, {
    "name" : "private boolean arrowScrollImpl(int direction)",
    "returnType" : "boolean",
    "comment" : "\n     * Handle an arrow scroll going up or down.  Take into account whether items are selectable,\n     * whether there are focusable items etc.\n     *\n     * @param direction Either {@link android.view.View#FOCUS_UP} or {@link android.view.View#FOCUS_DOWN}.\n     * @return Whether any scrolling, selection or focus change occured.\n     ",
    "links" : [ "android.view.View#FOCUS_DOWN", "android.view.View#FOCUS_UP" ]
  }, {
    "name" : "private void handleNewSelectionChange(View selectedView, int direction, int newSelectedPosition, boolean newFocusAssigned)",
    "returnType" : "void",
    "comment" : "\n     * When selection changes, it is possible that the previously selected or the\n     * next selected item will change its size.  If so, we need to offset some folks,\n     * and re-layout the items as appropriate.\n     *\n     * @param selectedView The currently selected view (before changing selection).\n     *   should be <code>null</code> if there was no previous selection.\n     * @param direction Either {@link android.view.View#FOCUS_UP} or\n     *        {@link android.view.View#FOCUS_DOWN}.\n     * @param newSelectedPosition The position of the next selection.\n     * @param newFocusAssigned whether new focus was assigned.  This matters because\n     *        when something has focus, we don't want to show selection (ugh).\n     ",
    "links" : [ "android.view.View#FOCUS_DOWN", "android.view.View#FOCUS_UP" ]
  }, {
    "name" : "private void measureAndAdjustDown(View child, int childIndex, int numChildren)",
    "returnType" : "void",
    "comment" : "\n     * Re-measure a child, and if its height changes, lay it out preserving its\n     * top, and adjust the children below it appropriately.\n     * @param child The child\n     * @param childIndex The view group index of the child.\n     * @param numChildren The number of children in the view group.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void measureItem(View child)",
    "returnType" : "void",
    "comment" : "\n     * Measure a particular list child.\n     * TODO: unify with setUpChild.\n     * @param child The child.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void relayoutMeasuredItem(View child)",
    "returnType" : "void",
    "comment" : "\n     * Layout a child that has been measured, preserving its top position.\n     * TODO: unify with setUpChild.\n     * @param child The child.\n     ",
    "links" : [ ]
  }, {
    "name" : "private int getArrowScrollPreviewLength()",
    "returnType" : "int",
    "comment" : "\n     * @return The amount to preview next items when arrow srolling.\n     ",
    "links" : [ ]
  }, {
    "name" : "private int amountToScroll(int direction, int nextSelectedPosition)",
    "returnType" : "int",
    "comment" : "\n     * Determine how much we need to scroll in order to get the next selected view\n     * visible, with a fading edge showing below as applicable.  The amount is\n     * capped at {@link #getMaxScrollAmount()} .\n     *\n     * @param direction either {@link android.view.View#FOCUS_UP} or\n     *        {@link android.view.View#FOCUS_DOWN}.\n     * @param nextSelectedPosition The position of the next selection, or\n     *        {@link #INVALID_POSITION} if there is no next selectable position\n     * @return The amount to scroll. Note: this is always positive!  Direction\n     *         needs to be taken into account when actually scrolling.\n     ",
    "links" : [ "#getMaxScrollAmount()", "#INVALID_POSITION", "android.view.View#FOCUS_DOWN", "android.view.View#FOCUS_UP" ]
  }, {
    "name" : "private int lookForSelectablePositionOnScreen(int direction)",
    "returnType" : "int",
    "comment" : "\n     * @param direction either {@link android.view.View#FOCUS_UP} or\n     *        {@link android.view.View#FOCUS_DOWN}.\n     * @return The position of the next selectable position of the views that\n     *         are currently visible, taking into account the fact that there might\n     *         be no selection.  Returns {@link #INVALID_POSITION} if there is no\n     *         selectable view on screen in the given direction.\n     ",
    "links" : [ "#INVALID_POSITION", "android.view.View#FOCUS_DOWN", "android.view.View#FOCUS_UP" ]
  }, {
    "name" : "private ArrowScrollFocusResult arrowScrollFocused(final int direction)",
    "returnType" : "ArrowScrollFocusResult",
    "comment" : "\n     * Do an arrow scroll based on focus searching.  If a new view is\n     * given focus, return the selection delta and amount to scroll via\n     * an {@link ArrowScrollFocusResult}, otherwise, return null.\n     *\n     * @param direction either {@link android.view.View#FOCUS_UP} or\n     *        {@link android.view.View#FOCUS_DOWN}.\n     * @return The result if focus has changed, or <code>null</code>.\n     ",
    "links" : [ "ArrowScrollFocusResult", "android.view.View#FOCUS_DOWN", "android.view.View#FOCUS_UP" ]
  }, {
    "name" : "private int positionOfNewFocus(View newFocus)",
    "returnType" : "int",
    "comment" : "\n     * @param newFocus The view that would have focus.\n     * @return the position that contains newFocus\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isViewAncestorOf(View child, View parent)",
    "returnType" : "boolean",
    "comment" : "\n     * Return true if child is an ancestor of parent, (or equal to the parent).\n     ",
    "links" : [ ]
  }, {
    "name" : "private int amountToScrollToNewFocus(int direction, View newFocus, int positionOfNewFocus)",
    "returnType" : "int",
    "comment" : "\n     * Determine how much we need to scroll in order to get newFocus in view.\n     * @param direction either {@link android.view.View#FOCUS_UP} or\n     *        {@link android.view.View#FOCUS_DOWN}.\n     * @param newFocus The view that would take focus.\n     * @param positionOfNewFocus The position of the list item containing newFocus\n     * @return The amount to scroll.  Note: this is always positive!  Direction\n     *   needs to be taken into account when actually scrolling.\n     ",
    "links" : [ "android.view.View#FOCUS_DOWN", "android.view.View#FOCUS_UP" ]
  }, {
    "name" : "private int distanceToView(View descendant)",
    "returnType" : "int",
    "comment" : "\n     * Determine the distance to the nearest edge of a view in a particular\n     * direction.\n     *\n     * @param descendant A descendant of this list.\n     * @return The distance, or 0 if the nearest edge is already on screen.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void scrollListItemsBy(int amount)",
    "returnType" : "void",
    "comment" : "\n     * Scroll the children by amount, adding a view at the end and removing\n     * views that fall off as necessary.\n     *\n     * @param amount The amount (positive or negative) to scroll.\n     ",
    "links" : [ ]
  }, {
    "name" : "private View addViewAbove(View theView, int position)",
    "returnType" : "View",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private View addViewBelow(View theView, int position)",
    "returnType" : "View",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setItemsCanFocus(boolean itemsCanFocus)",
    "returnType" : "void",
    "comment" : "\n     * Indicates that the views created by the ListAdapter can contain focusable\n     * items.\n     *\n     * @param itemsCanFocus true if items can get focus, false otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getItemsCanFocus()",
    "returnType" : "boolean",
    "comment" : "\n     * @return Whether the views created by the ListAdapter can contain focusable\n     * items.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isOpaque()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setCacheColorHint(int color)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void drawOverscrollHeader(Canvas canvas, Drawable drawable, Rect bounds)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void drawOverscrollFooter(Canvas canvas, Drawable drawable, Rect bounds)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void dispatchDraw(Canvas canvas)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected boolean drawChild(Canvas canvas, View child, long drawingTime)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void drawDivider(Canvas canvas, Rect bounds, int childIndex)",
    "returnType" : "void",
    "comment" : "\n     * Draws a divider for the given child in the given bounds.\n     *\n     * @param canvas The canvas to draw to.\n     * @param bounds The bounds of the divider.\n     * @param childIndex The index of child (of the View) above the divider.\n     *            This will be -1 if there is no child above the divider to be\n     *            drawn.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Drawable getDivider()",
    "returnType" : "Drawable",
    "comment" : "\n     * Returns the drawable that will be drawn between each item in the list.\n     *\n     * @return the current drawable drawn between list elements\n     * @attr ref R.styleable#ListView_divider\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDivider(@Nullable Drawable divider)",
    "returnType" : "void",
    "comment" : "\n     * Sets the drawable that will be drawn between each item in the list.\n     * <p>\n     * <strong>Note:</strong> If the drawable does not have an intrinsic\n     * height, you should also call {@link #setDividerHeight(int)}.\n     *\n     * @param divider the drawable to use\n     * @attr ref R.styleable#ListView_divider\n     ",
    "links" : [ "#setDividerHeight(int)" ]
  }, {
    "name" : "public int getDividerHeight()",
    "returnType" : "int",
    "comment" : "\n     * @return Returns the height of the divider that will be drawn between each item in the list.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDividerHeight(int height)",
    "returnType" : "void",
    "comment" : "\n     * Sets the height of the divider that will be drawn between each item in the list. Calling\n     * this will override the intrinsic height as set by {@link #setDivider(Drawable)}\n     *\n     * @param height The new height of the divider in pixels.\n     ",
    "links" : [ "#setDivider(Drawable)" ]
  }, {
    "name" : "public void setHeaderDividersEnabled(boolean headerDividersEnabled)",
    "returnType" : "void",
    "comment" : "\n     * Enables or disables the drawing of the divider for header views.\n     *\n     * @param headerDividersEnabled True to draw the headers, false otherwise.\n     *\n     * @see #setFooterDividersEnabled(boolean)\n     * @see #areHeaderDividersEnabled()\n     * @see #addHeaderView(android.view.View)\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean areHeaderDividersEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * @return Whether the drawing of the divider for header views is enabled\n     *\n     * @see #setHeaderDividersEnabled(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setFooterDividersEnabled(boolean footerDividersEnabled)",
    "returnType" : "void",
    "comment" : "\n     * Enables or disables the drawing of the divider for footer views.\n     *\n     * @param footerDividersEnabled True to draw the footers, false otherwise.\n     *\n     * @see #setHeaderDividersEnabled(boolean)\n     * @see #areFooterDividersEnabled()\n     * @see #addFooterView(android.view.View)\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean areFooterDividersEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * @return Whether the drawing of the divider for footer views is enabled\n     *\n     * @see #setFooterDividersEnabled(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOverscrollHeader(Drawable header)",
    "returnType" : "void",
    "comment" : "\n     * Sets the drawable that will be drawn above all other list content.\n     * This area can become visible when the user overscrolls the list.\n     *\n     * @param header The drawable to use\n     ",
    "links" : [ ]
  }, {
    "name" : "public Drawable getOverscrollHeader()",
    "returnType" : "Drawable",
    "comment" : "\n     * @return The drawable that will be drawn above all other list content\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOverscrollFooter(Drawable footer)",
    "returnType" : "void",
    "comment" : "\n     * Sets the drawable that will be drawn below all other list content.\n     * This area can become visible when the user overscrolls the list,\n     * or when the list's content does not fully fill the container area.\n     *\n     * @param footer The drawable to use\n     ",
    "links" : [ ]
  }, {
    "name" : "public Drawable getOverscrollFooter()",
    "returnType" : "Drawable",
    "comment" : "\n     * @return The drawable that will be drawn below all other list content\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void onFocusChanged(boolean gainFocus, int direction, Rect previouslyFocusedRect)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void onFinishInflate()",
    "returnType" : "void",
    "comment" : "\n     * (non-Javadoc)\n     *\n     * Children specified in XML are assumed to be header views. After we have\n     * parsed them move them out of the children list and into mHeaderViews.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected T findViewTraversal(@IdRes int id)",
    "returnType" : "T",
    "comment" : "\n     * @see android.view.View#findViewById(int)\n     * @removed For internal use only. This should have been hidden.\n     ",
    "links" : [ ]
  }, {
    "name" : " View findViewInHeadersOrFooters(ArrayList<FixedViewInfo> where, int id)",
    "returnType" : "View",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected T findViewWithTagTraversal(Object tag)",
    "returnType" : "T",
    "comment" : "\n     * @see android.view.View#findViewWithTag(Object)\n     * @removed For internal use only. This should have been hidden.\n     ",
    "links" : [ ]
  }, {
    "name" : " View findViewWithTagInHeadersOrFooters(ArrayList<FixedViewInfo> where, Object tag)",
    "returnType" : "View",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected T findViewByPredicateTraversal(Predicate<View> predicate, View childToSkip)",
    "returnType" : "T",
    "comment" : "\n     * First look in our children, then in any header and footer views that may\n     * be scrolled off.\n     *\n     * @see android.view.View#findViewByPredicate(Predicate)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : " View findViewByPredicateInHeadersOrFooters(ArrayList<FixedViewInfo> where, Predicate<View> predicate, View childToSkip)",
    "returnType" : "View",
    "comment" : "\n     * Look in the passed in list of headers or footers for the first view that\n     * matches the predicate.\n     ",
    "links" : [ ]
  }, {
    "name" : "public long[] getCheckItemIds()",
    "returnType" : "long[]",
    "comment" : "\n     * Returns the set of checked items ids. The result is only valid if the\n     * choice mode has not been set to {@link #CHOICE_MODE_NONE}.\n     *\n     * @return A new array which contains the id of each checked item in the\n     *         list.\n     *\n     * @deprecated Use {@link #getCheckedItemIds()} instead.\n     ",
    "links" : [ "#getCheckedItemIds()", "#CHOICE_MODE_NONE" ]
  }, {
    "name" : " int getHeightForPosition(int position)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean shouldAdjustHeightForDivider(int itemIndex)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public CharSequence getAccessibilityClassName()",
    "returnType" : "CharSequence",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo info)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean performAccessibilityActionInternal(int action, Bundle arguments)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void onInitializeAccessibilityNodeInfoForItem(View view, int position, AccessibilityNodeInfo info)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void encodeProperties(@NonNull ViewHierarchyEncoder encoder)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "protected HeaderViewListAdapter wrapHeaderListAdapterInternal(ArrayList<ListView.FixedViewInfo> headerViewInfos, ArrayList<ListView.FixedViewInfo> footerViewInfos, ListAdapter adapter)",
    "returnType" : "HeaderViewListAdapter",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "protected void wrapHeaderListAdapterInternal()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "protected void dispatchDataSetObserverOnChangedInternal()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  } ],
  "variableNames" : [ "TAG", "NO_POSITION", "MAX_SCROLL_FACTOR", "MIN_SCROLL_PREVIEW_PIXELS", "mHeaderViewInfos", "mFooterViewInfos", "mDivider", "mDividerHeight", "mOverScrollHeader", "mOverScrollFooter", "mIsCacheColorOpaque", "mDividerIsOpaque", "mHeaderDividersEnabled", "mFooterDividersEnabled", "mAreAllItemsSelectable", "mItemsCanFocus", "mTempRect", "mDividerPaint", "mArrowScrollFocusResult", "mFocusSelector" ],
  "methodNames" : [ "public int getMaxScrollAmount()", "private void adjustViewsUpOrDown()", "public void addHeaderView(View v, Object data, boolean isSelectable)", "public void addHeaderView(View v)", "public int getHeaderViewsCount()", "public boolean removeHeaderView(View v)", "private void removeFixedViewInfo(View v, ArrayList<FixedViewInfo> where)", "public void addFooterView(View v, Object data, boolean isSelectable)", "public void addFooterView(View v)", "public int getFooterViewsCount()", "public boolean removeFooterView(View v)", "public ListAdapter getAdapter()", "public void setRemoteViewsAdapter(Intent intent)", "public void setAdapter(ListAdapter adapter)", " void resetList()", "private void clearRecycledState(ArrayList<FixedViewInfo> infos)", "private boolean showingTopFadingEdge()", "private boolean showingBottomFadingEdge()", "public boolean requestChildRectangleOnScreen(View child, Rect rect, boolean immediate)", " void fillGap(boolean down)", "private View fillDown(int pos, int nextTop)", "private View fillUp(int pos, int nextBottom)", "private View fillFromTop(int nextTop)", "private View fillFromMiddle(int childrenTop, int childrenBottom)", "private void fillAboveAndBelow(View sel, int position)", "private View fillFromSelection(int selectedTop, int childrenTop, int childrenBottom)", "private int getBottomSelectionPixel(int childrenBottom, int fadingEdgeLength, int selectedPosition)", "private int getTopSelectionPixel(int childrenTop, int fadingEdgeLength, int selectedPosition)", "public void smoothScrollToPosition(int position)", "public void smoothScrollByOffset(int offset)", "private View moveSelection(View oldSel, View newSel, int delta, int childrenTop, int childrenBottom)", "protected void onDetachedFromWindow()", "protected void onSizeChanged(int w, int h, int oldw, int oldh)", "protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)", "private void measureScrapChild(View child, int position, int widthMeasureSpec, int heightHint)", "protected boolean recycleOnMeasure()", " final int measureHeightOfChildren(int widthMeasureSpec, int startPosition, int endPosition, int maxHeight, int disallowPartialChildPosition)", " int findMotionRow(int y)", "private View fillSpecific(int position, int top)", "private void correctTooHigh(int childCount)", "private void correctTooLow(int childCount)", "protected void layoutChildren()", " boolean trackMotionScroll(int deltaY, int incrementalDeltaY)", "private void removeUnusedFixedViews(@Nullable List<FixedViewInfo> infoList)", "private boolean isDirectChildHeaderOrFooter(View child)", "private View makeAndAddView(int position, int y, boolean flow, int childrenLeft, boolean selected)", "private void setupChild(View child, int position, int y, boolean flowDown, int childrenLeft, boolean selected, boolean isAttachedToWindow)", "protected boolean canAnimate()", "public void setSelection(int position)", " void setSelectionInt(int position)", " int lookForSelectablePosition(int position, boolean lookDown)", " int lookForSelectablePositionAfter(int current, int position, boolean lookDown)", "public void setSelectionAfterHeaderView()", "public boolean dispatchKeyEvent(KeyEvent event)", "public boolean onKeyDown(int keyCode, KeyEvent event)", "public boolean onKeyMultiple(int keyCode, int repeatCount, KeyEvent event)", "public boolean onKeyUp(int keyCode, KeyEvent event)", "private boolean commonKey(int keyCode, int count, KeyEvent event)", " boolean pageScroll(int direction)", " boolean fullScroll(int direction)", "private boolean handleHorizontalFocusWithinListItem(int direction)", " boolean arrowScroll(int direction)", "private final int nextSelectedPositionForDirection(View selectedView, int selectedPos, int direction)", "private boolean arrowScrollImpl(int direction)", "private void handleNewSelectionChange(View selectedView, int direction, int newSelectedPosition, boolean newFocusAssigned)", "private void measureAndAdjustDown(View child, int childIndex, int numChildren)", "private void measureItem(View child)", "private void relayoutMeasuredItem(View child)", "private int getArrowScrollPreviewLength()", "private int amountToScroll(int direction, int nextSelectedPosition)", "private int lookForSelectablePositionOnScreen(int direction)", "private ArrowScrollFocusResult arrowScrollFocused(final int direction)", "private int positionOfNewFocus(View newFocus)", "private boolean isViewAncestorOf(View child, View parent)", "private int amountToScrollToNewFocus(int direction, View newFocus, int positionOfNewFocus)", "private int distanceToView(View descendant)", "private void scrollListItemsBy(int amount)", "private View addViewAbove(View theView, int position)", "private View addViewBelow(View theView, int position)", "public void setItemsCanFocus(boolean itemsCanFocus)", "public boolean getItemsCanFocus()", "public boolean isOpaque()", "public void setCacheColorHint(int color)", " void drawOverscrollHeader(Canvas canvas, Drawable drawable, Rect bounds)", " void drawOverscrollFooter(Canvas canvas, Drawable drawable, Rect bounds)", "protected void dispatchDraw(Canvas canvas)", "protected boolean drawChild(Canvas canvas, View child, long drawingTime)", " void drawDivider(Canvas canvas, Rect bounds, int childIndex)", "public Drawable getDivider()", "public void setDivider(@Nullable Drawable divider)", "public int getDividerHeight()", "public void setDividerHeight(int height)", "public void setHeaderDividersEnabled(boolean headerDividersEnabled)", "public boolean areHeaderDividersEnabled()", "public void setFooterDividersEnabled(boolean footerDividersEnabled)", "public boolean areFooterDividersEnabled()", "public void setOverscrollHeader(Drawable header)", "public Drawable getOverscrollHeader()", "public void setOverscrollFooter(Drawable footer)", "public Drawable getOverscrollFooter()", "protected void onFocusChanged(boolean gainFocus, int direction, Rect previouslyFocusedRect)", "protected void onFinishInflate()", "protected T findViewTraversal(@IdRes int id)", " View findViewInHeadersOrFooters(ArrayList<FixedViewInfo> where, int id)", "protected T findViewWithTagTraversal(Object tag)", " View findViewWithTagInHeadersOrFooters(ArrayList<FixedViewInfo> where, Object tag)", "protected T findViewByPredicateTraversal(Predicate<View> predicate, View childToSkip)", " View findViewByPredicateInHeadersOrFooters(ArrayList<FixedViewInfo> where, Predicate<View> predicate, View childToSkip)", "public long[] getCheckItemIds()", " int getHeightForPosition(int position)", "private boolean shouldAdjustHeightForDivider(int itemIndex)", "public CharSequence getAccessibilityClassName()", "public void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo info)", "public boolean performAccessibilityActionInternal(int action, Bundle arguments)", "public void onInitializeAccessibilityNodeInfoForItem(View view, int position, AccessibilityNodeInfo info)", "protected void encodeProperties(@NonNull ViewHierarchyEncoder encoder)", "protected HeaderViewListAdapter wrapHeaderListAdapterInternal(ArrayList<ListView.FixedViewInfo> headerViewInfos, ArrayList<ListView.FixedViewInfo> footerViewInfos, ListAdapter adapter)", "protected void wrapHeaderListAdapterInternal()", "protected void dispatchDataSetObserverOnChangedInternal()" ]
}