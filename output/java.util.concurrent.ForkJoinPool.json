{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/util/concurrent/ForkJoinPool.java",
  "packageName" : "java.util.concurrent",
  "className" : "ForkJoinPool",
  "comment" : "\n * An {@link ExecutorService} for running {@link ForkJoinTask}s.\n * A {@code ForkJoinPool} provides the entry point for submissions\n * from non-{@code ForkJoinTask} clients, as well as management and\n * monitoring operations.\n *\n * <p>A {@code ForkJoinPool} differs from other kinds of {@link\n * ExecutorService} mainly by virtue of employing\n * <em>work-stealing</em>: all threads in the pool attempt to find and\n * execute tasks submitted to the pool and/or created by other active\n * tasks (eventually blocking waiting for work if none exist). This\n * enables efficient processing when most tasks spawn other subtasks\n * (as do most {@code ForkJoinTask}s), as well as when many small\n * tasks are submitted to the pool from external clients.  Especially\n * when setting <em>asyncMode</em> to true in constructors, {@code\n * ForkJoinPool}s may also be appropriate for use with event-style\n * tasks that are never joined. All worker threads are initialized\n * with {@link Thread#isDaemon} set {@code true}.\n *\n * <p>A static {@link #commonPool()} is available and appropriate for\n * most applications. The common pool is used by any ForkJoinTask that\n * is not explicitly submitted to a specified pool. Using the common\n * pool normally reduces resource usage (its threads are slowly\n * reclaimed during periods of non-use, and reinstated upon subsequent\n * use).\n *\n * <p>For applications that require separate or custom pools, a {@code\n * ForkJoinPool} may be constructed with a given target parallelism\n * level; by default, equal to the number of available processors.\n * The pool attempts to maintain enough active (or available) threads\n * by dynamically adding, suspending, or resuming internal worker\n * threads, even if some tasks are stalled waiting to join others.\n * However, no such adjustments are guaranteed in the face of blocked\n * I/O or other unmanaged synchronization. The nested {@link\n * ManagedBlocker} interface enables extension of the kinds of\n * synchronization accommodated. The default policies may be\n * overridden using a constructor with parameters corresponding to\n * those documented in class {@link ThreadPoolExecutor}.\n *\n * <p>In addition to execution and lifecycle control methods, this\n * class provides status check methods (for example\n * {@link #getStealCount}) that are intended to aid in developing,\n * tuning, and monitoring fork/join applications. Also, method\n * {@link #toString} returns indications of pool state in a\n * convenient form for informal monitoring.\n *\n * <p>As is the case with other ExecutorServices, there are three\n * main task execution methods summarized in the following table.\n * These are designed to be used primarily by clients not already\n * engaged in fork/join computations in the current pool.  The main\n * forms of these methods accept instances of {@code ForkJoinTask},\n * but overloaded forms also allow mixed execution of plain {@code\n * Runnable}- or {@code Callable}- based activities as well.  However,\n * tasks that are already executing in a pool should normally instead\n * use the within-computation forms listed in the table unless using\n * async event-style tasks that are not usually joined, in which case\n * there is little difference among choice of methods.\n *\n * <table class=\"plain\">\n * <caption>Summary of task execution methods</caption>\n *  <tr>\n *    <td></td>\n *    <th scope=\"col\"> Call from non-fork/join clients</th>\n *    <th scope=\"col\"> Call from within fork/join computations</th>\n *  </tr>\n *  <tr>\n *    <th scope=\"row\" style=\"text-align:left\"> Arrange async execution</th>\n *    <td> {@link #execute(ForkJoinTask)}</td>\n *    <td> {@link ForkJoinTask#fork}</td>\n *  </tr>\n *  <tr>\n *    <th scope=\"row\" style=\"text-align:left\"> Await and obtain result</th>\n *    <td> {@link #invoke(ForkJoinTask)}</td>\n *    <td> {@link ForkJoinTask#invoke}</td>\n *  </tr>\n *  <tr>\n *    <th scope=\"row\" style=\"text-align:left\"> Arrange exec and obtain Future</th>\n *    <td> {@link #submit(ForkJoinTask)}</td>\n *    <td> {@link ForkJoinTask#fork} (ForkJoinTasks <em>are</em> Futures)</td>\n *  </tr>\n * </table>\n *\n * <p>The parameters used to construct the common pool may be controlled by\n * setting the following {@linkplain System#getProperty system properties}:\n * <ul>\n * <li>{@code java.util.concurrent.ForkJoinPool.common.parallelism}\n * - the parallelism level, a non-negative integer\n * <li>{@code java.util.concurrent.ForkJoinPool.common.threadFactory}\n * - the class name of a {@link ForkJoinWorkerThreadFactory}.\n * The {@linkplain ClassLoader#getSystemClassLoader() system class loader}\n * is used to load this class.\n * <li>{@code java.util.concurrent.ForkJoinPool.common.exceptionHandler}\n * - the class name of a {@link UncaughtExceptionHandler}.\n * The {@linkplain ClassLoader#getSystemClassLoader() system class loader}\n * is used to load this class.\n * <li>{@code java.util.concurrent.ForkJoinPool.common.maximumSpares}\n * - the maximum number of allowed extra threads to maintain target\n * parallelism (default 256).\n * </ul>\n * If no thread factory is supplied via a system property, then the\n * common pool uses a factory that uses the system class loader as the\n * {@linkplain Thread#getContextClassLoader() thread context class loader}.\n * In addition, if a {@link SecurityManager} is present, then\n * the common pool uses a factory supplying threads that have no\n * {@link Permissions} enabled.\n *\n * Upon any error in establishing these settings, default parameters\n * are used. It is possible to disable or limit the use of threads in\n * the common pool by setting the parallelism property to zero, and/or\n * using a factory that may return {@code null}. However doing so may\n * cause unjoined tasks to never be executed.\n *\n * <p><b>Implementation notes:</b> This implementation restricts the\n * maximum number of running threads to 32767. Attempts to create\n * pools with greater than the maximum number result in\n * {@code IllegalArgumentException}.\n *\n * <p>This implementation rejects submitted tasks (that is, by throwing\n * {@link RejectedExecutionException}) only when the pool is shut down\n * or internal resources have been exhausted.\n *\n * @since 1.7\n * @author Doug Lea\n ",
  "links" : [ "java.util.concurrent.ForkJoinTask", "#isDaemon", "#submit(ForkJoinTask)", "SecurityManager", "java.util.concurrent.ThreadPoolExecutor", "#getStealCount", "java.util.concurrent.ForkJoinTask#invoke", "java.lang.Thread.UncaughtExceptionHandler", "ManagedBlocker", "java.util.concurrent.RejectedExecutionException", "ForkJoinWorkerThreadFactory", "#execute(ForkJoinTask)", "#commonPool()", "java.util.concurrent.ForkJoinTask#fork", "java.util.concurrent.ExecutorService", "#toString", "#invoke(ForkJoinTask)", "java.security.Permissions" ],
  "variables" : [ {
    "name" : "SWIDTH",
    "type" : "int",
    "comment" : " width of short",
    "links" : [ ]
  }, {
    "name" : "SMASK",
    "type" : "int",
    "comment" : " short bits == max index",
    "links" : [ ]
  }, {
    "name" : "MAX_CAP",
    "type" : "int",
    "comment" : " max #workers - 1",
    "links" : [ ]
  }, {
    "name" : "UNSIGNALLED",
    "type" : "int",
    "comment" : " must be negative",
    "links" : [ ]
  }, {
    "name" : "SS_SEQ",
    "type" : "int",
    "comment" : " version count",
    "links" : [ ]
  }, {
    "name" : "FIFO",
    "type" : "int",
    "comment" : " fifo queue or access mode",
    "links" : [ ]
  }, {
    "name" : "SRC",
    "type" : "int",
    "comment" : " set for valid queue ids",
    "links" : [ ]
  }, {
    "name" : "INNOCUOUS",
    "type" : "int",
    "comment" : " set for Innocuous workers",
    "links" : [ ]
  }, {
    "name" : "QUIET",
    "type" : "int",
    "comment" : " quiescing phase or source",
    "links" : [ ]
  }, {
    "name" : "SHUTDOWN",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TERMINATED",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "STOP",
    "type" : "int",
    "comment" : " must be negative",
    "links" : [ ]
  }, {
    "name" : "UNCOMPENSATE",
    "type" : "int",
    "comment" : " tryCompensate return",
    "links" : [ ]
  }, {
    "name" : "INITIAL_QUEUE_CAPACITY",
    "type" : "int",
    "comment" : "\n     * Initial capacity of work-stealing queue array.  Must be a power\n     * of two, at least 2. See above.\n     ",
    "links" : [ ]
  }, {
    "name" : "defaultForkJoinWorkerThreadFactory",
    "type" : "ForkJoinWorkerThreadFactory",
    "comment" : "\n     * Creates a new ForkJoinWorkerThread. This factory is used unless\n     * overridden in ForkJoinPool constructors.\n     ",
    "links" : [ ]
  }, {
    "name" : "modifyThreadPermission",
    "type" : "RuntimePermission",
    "comment" : "\n     * Permission required for callers of methods that may start or\n     * kill threads.\n     ",
    "links" : [ ]
  }, {
    "name" : "common",
    "type" : "ForkJoinPool",
    "comment" : "\n     * Common (static) pool. Non-null for public use unless a static\n     * construction exception, but internal usages null-check on use\n     * to paranoically avoid potential initialization circularities\n     * as well as to simplify generated code.\n     ",
    "links" : [ ]
  }, {
    "name" : "COMMON_PARALLELISM",
    "type" : "int",
    "comment" : "\n     * Common pool parallelism. To allow simpler use and management\n     * when common pool threads are disabled, we allow the underlying\n     * common.parallelism field to be zero, but in that case still report\n     * parallelism as 1 to reflect resulting caller-runs mechanics.\n     ",
    "links" : [ ]
  }, {
    "name" : "COMMON_MAX_SPARES",
    "type" : "int",
    "comment" : "\n     * Limit on spare thread construction in tryCompensate.\n     ",
    "links" : [ ]
  }, {
    "name" : "poolIds",
    "type" : "int",
    "comment" : "\n     * Sequence number for creating worker names\n     ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_KEEPALIVE",
    "type" : "long",
    "comment" : "\n     * Default idle timeout value (in milliseconds) for the thread\n     * triggering quiescence to park waiting for new work\n     ",
    "links" : [ ]
  }, {
    "name" : "TIMEOUT_SLOP",
    "type" : "long",
    "comment" : "\n     * Undershoot tolerance for idle timeouts\n     ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_COMMON_MAX_SPARES",
    "type" : "int",
    "comment" : "\n     * The default value for COMMON_MAX_SPARES.  Overridable using the\n     * \"java.util.concurrent.ForkJoinPool.common.maximumSpares\" system\n     * property.  The default value is far in excess of normal\n     * requirements, but also far short of MAX_CAP and typical OS\n     * thread limits, so allows JVMs to catch misuse/abuse before\n     * running out of resources needed to do so.\n     ",
    "links" : [ ]
  }, {
    "name" : "SP_MASK",
    "type" : "long",
    "comment" : " Lower and upper word masks",
    "links" : [ ]
  }, {
    "name" : "UC_MASK",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RC_SHIFT",
    "type" : "int",
    "comment" : " Release counts",
    "links" : [ ]
  }, {
    "name" : "RC_UNIT",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RC_MASK",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TC_SHIFT",
    "type" : "int",
    "comment" : " Total counts",
    "links" : [ ]
  }, {
    "name" : "TC_UNIT",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TC_MASK",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ADD_WORKER",
    "type" : "long",
    "comment" : " sign",
    "links" : [ ]
  }, {
    "name" : "keepAlive",
    "type" : "long",
    "comment" : " milliseconds before dropping if idle",
    "links" : [ ]
  }, {
    "name" : "stealCount",
    "type" : "long",
    "comment" : " collects worker nsteals",
    "links" : [ ]
  }, {
    "name" : "scanRover",
    "type" : "int",
    "comment" : " advances across pollScan calls",
    "links" : [ ]
  }, {
    "name" : "threadIds",
    "type" : "int",
    "comment" : " for worker thread names",
    "links" : [ ]
  }, {
    "name" : "bounds",
    "type" : "int",
    "comment" : " min, max threads packed as shorts",
    "links" : [ ]
  }, {
    "name" : "mode",
    "type" : "int",
    "comment" : " parallelism, runstate, queue mode",
    "links" : [ ]
  }, {
    "name" : "queues",
    "type" : "WorkQueue[]",
    "comment" : " main registry",
    "links" : [ ]
  }, {
    "name" : "registrationLock",
    "type" : "ReentrantLock",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "termination",
    "type" : "Condition",
    "comment" : " lazily constructed",
    "links" : [ ]
  }, {
    "name" : "workerNamePrefix",
    "type" : "String",
    "comment" : " null for common pool",
    "links" : [ ]
  }, {
    "name" : "factory",
    "type" : "ForkJoinWorkerThreadFactory",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ueh",
    "type" : "UncaughtExceptionHandler",
    "comment" : " per-worker UEH",
    "links" : [ ]
  }, {
    "name" : "saturate",
    "type" : "Predicate<? super ForkJoinPool>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ctl",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "CTL",
    "type" : "VarHandle",
    "comment" : " Support for atomic operations",
    "links" : [ ]
  }, {
    "name" : "MODE",
    "type" : "VarHandle",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "THREADIDS",
    "type" : "VarHandle",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "POOLIDS",
    "type" : "VarHandle",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private static void checkPermission()",
    "returnType" : "void",
    "comment" : "\n     * If there is a security manager, makes sure caller has\n     * permission to modify threads.\n     ",
    "links" : [ ]
  }, {
    "name" : " static AccessControlContext contextWithPermissions(Permission... perms)",
    "returnType" : "AccessControlContext",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean compareAndSetCtl(long c, long v)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private long compareAndExchangeCtl(long c, long v)",
    "returnType" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private long getAndAddCtl(long v)",
    "returnType" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getAndBitwiseOrMode(int v)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int getAndAddThreadIds(int x)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static int getAndAddPoolIds(int x)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean createWorker()",
    "returnType" : "boolean",
    "comment" : "\n     * Tries to construct and start one worker. Assumes that total\n     * count has already been incremented as a reservation.  Invokes\n     * deregisterWorker on any failure.\n     *\n     * @return true if successful\n     ",
    "links" : [ ]
  }, {
    "name" : " final String nextWorkerThreadName()",
    "returnType" : "String",
    "comment" : "\n     * Provides a name for ForkJoinWorkerThread constructor.\n     ",
    "links" : [ ]
  }, {
    "name" : " final void registerWorker(WorkQueue w)",
    "returnType" : "void",
    "comment" : "\n     * Finishes initializing and records owned queue.\n     *\n     * @param w caller's WorkQueue\n     ",
    "links" : [ ]
  }, {
    "name" : " final void deregisterWorker(ForkJoinWorkerThread wt, Throwable ex)",
    "returnType" : "void",
    "comment" : "\n     * Final callback from terminating worker, as well as upon failure\n     * to construct or start a worker.  Removes record of worker from\n     * array, and adjusts counts. If pool is shutting down, tries to\n     * complete termination.\n     *\n     * @param wt the worker thread, or null if construction failed\n     * @param ex the exception causing failure, or null if none\n     ",
    "links" : [ ]
  }, {
    "name" : " final void signalWork()",
    "returnType" : "void",
    "comment" : "\n     * Tries to create or release a worker if too few are running.\n     ",
    "links" : [ ]
  }, {
    "name" : " final void runWorker(WorkQueue w)",
    "returnType" : "void",
    "comment" : "\n     * Top-level runloop for workers, called by ForkJoinWorkerThread.run.\n     * See above for explanation.\n     *\n     * @param w caller's WorkQueue (may be null on failed initialization)\n     ",
    "links" : [ ]
  }, {
    "name" : "private int scan(WorkQueue w, int prevSrc, int r)",
    "returnType" : "int",
    "comment" : "\n     * Scans for and if found executes top-level tasks: Tries to poll\n     * each queue starting at a random index with random stride,\n     * returning source id or retry indicator if contended or\n     * inconsistent.\n     *\n     * @param w caller's WorkQueue\n     * @param prevSrc the previous queue stolen from in current phase, or 0\n     * @param r random seed\n     * @return id of queue if taken, negative if none found, prevSrc for retry\n     ",
    "links" : [ ]
  }, {
    "name" : "private int awaitWork(WorkQueue w)",
    "returnType" : "int",
    "comment" : "\n     * Advances worker phase, pushes onto ctl stack, and awaits signal\n     * or reports termination.\n     *\n     * @return negative if terminated, else 0\n     ",
    "links" : [ ]
  }, {
    "name" : " final boolean canStop()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if can start terminating if enabled, or already terminated\n     ",
    "links" : [ ]
  }, {
    "name" : "private int tryCompensate(long c)",
    "returnType" : "int",
    "comment" : "\n     * Tries to decrement counts (sometimes implicitly) and possibly\n     * arrange for a compensating worker in preparation for\n     * blocking. May fail due to interference, in which case -1 is\n     * returned so caller may retry. A zero return value indicates\n     * that the caller doesn't need to re-adjust counts when later\n     * unblocked.\n     *\n     * @param c incoming ctl value\n     * @return UNCOMPENSATE: block then adjust, 0: block, -1 : retry\n     ",
    "links" : [ ]
  }, {
    "name" : " final void uncompensate()",
    "returnType" : "void",
    "comment" : "\n     * Readjusts RC count; called from ForkJoinTask after blocking.\n     ",
    "links" : [ ]
  }, {
    "name" : " final int helpJoin(ForkJoinTask<?> task, WorkQueue w, boolean canHelp)",
    "returnType" : "int",
    "comment" : "\n     * Helps if possible until the given task is done.  Scans other\n     * queues for a task produced by one of w's stealers; returning\n     * compensated blocking sentinel if none are found.\n     *\n     * @param task the task\n     * @param w caller's WorkQueue\n     * @param canHelp if false, compensate only\n     * @return task status on exit, or UNCOMPENSATE for compensated blocking\n     ",
    "links" : [ ]
  }, {
    "name" : " final int helpComplete(ForkJoinTask<?> task, WorkQueue w, boolean owned)",
    "returnType" : "int",
    "comment" : "\n     * Extra helpJoin steps for CountedCompleters.  Scans for and runs\n     * subtasks of the given root task, returning if none are found.\n     *\n     * @param task root of CountedCompleter computation\n     * @param w caller's WorkQueue\n     * @param owned true if owned by a ForkJoinWorkerThread\n     * @return task status on exit\n     ",
    "links" : [ ]
  }, {
    "name" : "private ForkJoinTask<?> pollScan(boolean submissionsOnly)",
    "returnType" : "ForkJoinTask<?>",
    "comment" : "\n     * Scans for and returns a polled task, if available.  Used only\n     * for untracked polls. Begins scan at an index (scanRover)\n     * advanced on each call, to avoid systematic unfairness.\n     *\n     * @param submissionsOnly if true, only scan submission queues\n     ",
    "links" : [ ]
  }, {
    "name" : " final int helpQuiescePool(WorkQueue w, long nanos, boolean interruptible)",
    "returnType" : "int",
    "comment" : "\n     * Runs tasks until {@code isQuiescent()}. Rather than blocking\n     * when tasks cannot be found, rescans until all others cannot\n     * find tasks either.\n     *\n     * @param nanos max wait time (Long.MAX_VALUE if effectively untimed)\n     * @param interruptible true if return on interrupt\n     * @return positive if quiescent, negative if interrupted, else 0\n     ",
    "links" : [ ]
  }, {
    "name" : " final int externalHelpQuiescePool(long nanos, boolean interruptible)",
    "returnType" : "int",
    "comment" : "\n     * Helps quiesce from external caller until done, interrupted, or timeout\n     *\n     * @param nanos max wait time (Long.MAX_VALUE if effectively untimed)\n     * @param interruptible true if return on interrupt\n     * @return positive if quiescent, negative if interrupted, else 0\n     ",
    "links" : [ ]
  }, {
    "name" : " final ForkJoinTask<?> nextTaskFor(WorkQueue w)",
    "returnType" : "ForkJoinTask<?>",
    "comment" : "\n     * Gets and removes a local or stolen task for the given worker.\n     *\n     * @return a task, if available\n     ",
    "links" : [ ]
  }, {
    "name" : " final WorkQueue submissionQueue()",
    "returnType" : "WorkQueue",
    "comment" : "\n     * Finds and locks a WorkQueue for an external submitter, or\n     * returns null if shutdown or terminating.\n     ",
    "links" : [ ]
  }, {
    "name" : " final void externalPush(ForkJoinTask<?> task)",
    "returnType" : "void",
    "comment" : "\n     * Adds the given task to an external submission queue, or throws\n     * exception if shutdown or terminating.\n     *\n     * @param task the task. Caller must ensure non-null.\n     ",
    "links" : [ ]
  }, {
    "name" : "private ForkJoinTask<T> externalSubmit(ForkJoinTask<T> task)",
    "returnType" : "ForkJoinTask<T>",
    "comment" : "\n     * Pushes a possibly-external submission.\n     ",
    "links" : [ ]
  }, {
    "name" : " static WorkQueue commonQueue()",
    "returnType" : "WorkQueue",
    "comment" : "\n     * Returns common pool queue for an external thread that has\n     * possibly ever submitted a common pool task (nonzero probe), or\n     * null if none.\n     ",
    "links" : [ ]
  }, {
    "name" : " final WorkQueue externalQueue()",
    "returnType" : "WorkQueue",
    "comment" : "\n     * Returns queue for an external thread, if one exists\n     ",
    "links" : [ ]
  }, {
    "name" : " static void helpAsyncBlocker(Executor e, ManagedBlocker blocker)",
    "returnType" : "void",
    "comment" : "\n     * If the given executor is a ForkJoinPool, poll and execute\n     * AsynchronousCompletionTasks from worker's queue until none are\n     * available or blocker is released.\n     ",
    "links" : [ ]
  }, {
    "name" : " static int getSurplusQueuedTaskCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns a cheap heuristic guide for task partitioning when\n     * programmers, frameworks, tools, or languages have little or no\n     * idea about task granularity.  In essence, by offering this\n     * method, we ask users only about tradeoffs in overhead vs\n     * expected throughput and its variance, rather than how finely to\n     * partition tasks.\n     *\n     * In a steady state strict (tree-structured) computation, each\n     * thread makes available for stealing enough tasks for other\n     * threads to remain active. Inductively, if all threads play by\n     * the same rules, each thread should make available only a\n     * constant number of tasks.\n     *\n     * The minimum useful constant is just 1. But using a value of 1\n     * would require immediate replenishment upon each steal to\n     * maintain enough tasks, which is infeasible.  Further,\n     * partitionings/granularities of offered tasks should minimize\n     * steal rates, which in general means that threads nearer the top\n     * of computation tree should generate more than those nearer the\n     * bottom. In perfect steady state, each thread is at\n     * approximately the same level of computation tree. However,\n     * producing extra tasks amortizes the uncertainty of progress and\n     * diffusion assumptions.\n     *\n     * So, users will want to use values larger (but not much larger)\n     * than 1 to both smooth over transient shortages and hedge\n     * against uneven progress; as traded off against the cost of\n     * extra task overhead. We leave the user to pick a threshold\n     * value to compare with the results of this call to guide\n     * decisions, but recommend values such as 3.\n     *\n     * When all threads are active, it is on average OK to estimate\n     * surplus strictly locally. In steady-state, if one thread is\n     * maintaining say 2 surplus tasks, then so are others. So we can\n     * just use estimated queue length.  However, this strategy alone\n     * leads to serious mis-estimates in some non-steady-state\n     * conditions (ramp-up, ramp-down, other stalls). We can detect\n     * many of these by further considering the number of \"idle\"\n     * threads, that are known to have zero queued tasks, so\n     * compensate by a factor of (#idle/#active) threads.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean tryTerminate(boolean now, boolean enable)",
    "returnType" : "boolean",
    "comment" : "\n     * Possibly initiates and/or completes termination.\n     *\n     * @param now if true, unconditionally terminate, else only\n     * if no work and no active workers\n     * @param enable if true, terminate when next possible\n     * @return true if terminating or terminated\n     ",
    "links" : [ ]
  }, {
    "name" : "private static Object newInstanceFromSystemProperty(String property) throws ReflectiveOperationException",
    "returnType" : "Object",
    "comment" : " helper method for commonPool constructor",
    "links" : [ ]
  }, {
    "name" : "public static ForkJoinPool commonPool()",
    "returnType" : "ForkJoinPool",
    "comment" : "\n     * Returns the common pool instance. This pool is statically\n     * constructed; its run state is unaffected by attempts to {@link\n     * #shutdown} or {@link #shutdownNow}. However this pool and any\n     * ongoing processing are automatically terminated upon program\n     * {@link System#exit}.  Any program that relies on asynchronous\n     * task processing to complete before program termination should\n     * invoke {@code commonPool().}{@link #awaitQuiescence awaitQuiescence},\n     * before exit.\n     *\n     * @return the common pool instance\n     * @since 1.8\n     ",
    "links" : [ "#shutdownNow", "#shutdown", "#awaitQuiescence", "#exit" ]
  }, {
    "name" : "public T invoke(ForkJoinTask<T> task)",
    "returnType" : "T",
    "comment" : "\n     * Performs the given task, returning its result upon completion.\n     * If the computation encounters an unchecked Exception or Error,\n     * it is rethrown as the outcome of this invocation.  Rethrown\n     * exceptions behave in the same way as regular exceptions, but,\n     * when possible, contain stack traces (as displayed for example\n     * using {@code ex.printStackTrace()}) of both the current thread\n     * as well as the thread actually encountering the exception;\n     * minimally only the latter.\n     *\n     * @param task the task\n     * @param <T> the type of the task's result\n     * @return the task's result\n     * @throws NullPointerException if the task is null\n     * @throws RejectedExecutionException if the task cannot be\n     *         scheduled for execution\n     ",
    "links" : [ ]
  }, {
    "name" : "public void execute(ForkJoinTask<?> task)",
    "returnType" : "void",
    "comment" : "\n     * Arranges for (asynchronous) execution of the given task.\n     *\n     * @param task the task\n     * @throws NullPointerException if the task is null\n     * @throws RejectedExecutionException if the task cannot be\n     *         scheduled for execution\n     ",
    "links" : [ ]
  }, {
    "name" : "public void execute(Runnable task)",
    "returnType" : "void",
    "comment" : "\n     * @throws NullPointerException if the task is null\n     * @throws RejectedExecutionException if the task cannot be\n     *         scheduled for execution\n     ",
    "links" : [ ]
  }, {
    "name" : "public ForkJoinTask<T> submit(ForkJoinTask<T> task)",
    "returnType" : "ForkJoinTask<T>",
    "comment" : "\n     * Submits a ForkJoinTask for execution.\n     *\n     * @param task the task to submit\n     * @param <T> the type of the task's result\n     * @return the task\n     * @throws NullPointerException if the task is null\n     * @throws RejectedExecutionException if the task cannot be\n     *         scheduled for execution\n     ",
    "links" : [ ]
  }, {
    "name" : "public ForkJoinTask<T> submit(Callable<T> task)",
    "returnType" : "ForkJoinTask<T>",
    "comment" : "\n     * @throws NullPointerException if the task is null\n     * @throws RejectedExecutionException if the task cannot be\n     *         scheduled for execution\n     ",
    "links" : [ ]
  }, {
    "name" : "public ForkJoinTask<T> submit(Runnable task, T result)",
    "returnType" : "ForkJoinTask<T>",
    "comment" : "\n     * @throws NullPointerException if the task is null\n     * @throws RejectedExecutionException if the task cannot be\n     *         scheduled for execution\n     ",
    "links" : [ ]
  }, {
    "name" : "public ForkJoinTask<?> submit(Runnable task)",
    "returnType" : "ForkJoinTask<?>",
    "comment" : "\n     * @throws NullPointerException if the task is null\n     * @throws RejectedExecutionException if the task cannot be\n     *         scheduled for execution\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)",
    "returnType" : "List<Future<T>>",
    "comment" : "\n     * @throws NullPointerException       {@inheritDoc}\n     * @throws RejectedExecutionException {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException",
    "returnType" : "List<Future<T>>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException",
    "returnType" : "T",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException",
    "returnType" : "T",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public ForkJoinWorkerThreadFactory getFactory()",
    "returnType" : "ForkJoinWorkerThreadFactory",
    "comment" : "\n     * Returns the factory used for constructing new workers.\n     *\n     * @return the factory used for constructing new workers\n     ",
    "links" : [ ]
  }, {
    "name" : "public UncaughtExceptionHandler getUncaughtExceptionHandler()",
    "returnType" : "UncaughtExceptionHandler",
    "comment" : "\n     * Returns the handler for internal worker threads that terminate\n     * due to unrecoverable errors encountered while executing tasks.\n     *\n     * @return the handler, or {@code null} if none\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getParallelism()",
    "returnType" : "int",
    "comment" : "\n     * Returns the targeted parallelism level of this pool.\n     *\n     * @return the targeted parallelism level of this pool\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getCommonPoolParallelism()",
    "returnType" : "int",
    "comment" : "\n     * Returns the targeted parallelism level of the common pool.\n     *\n     * @return the targeted parallelism level of the common pool\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getPoolSize()",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of worker threads that have started but not\n     * yet terminated.  The result returned by this method may differ\n     * from {@link #getParallelism} when threads are created to\n     * maintain parallelism when others are cooperatively blocked.\n     *\n     * @return the number of worker threads\n     ",
    "links" : [ "#getParallelism" ]
  }, {
    "name" : "public boolean getAsyncMode()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if this pool uses local first-in-first-out\n     * scheduling mode for forked tasks that are never joined.\n     *\n     * @return {@code true} if this pool uses async mode\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getRunningThreadCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns an estimate of the number of worker threads that are\n     * not blocked waiting to join tasks or for other managed\n     * synchronization. This method may overestimate the\n     * number of running threads.\n     *\n     * @return the number of worker threads\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getActiveThreadCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns an estimate of the number of threads that are currently\n     * stealing or executing tasks. This method may overestimate the\n     * number of active threads.\n     *\n     * @return the number of active threads\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isQuiescent()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if all worker threads are currently idle.\n     * An idle worker is one that cannot obtain a task to execute\n     * because none are available to steal from other threads, and\n     * there are no pending submissions to the pool. This method is\n     * conservative; it might not return {@code true} immediately upon\n     * idleness of all threads, but will eventually become true if\n     * threads remain inactive.\n     *\n     * @return {@code true} if all threads are currently idle\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getStealCount()",
    "returnType" : "long",
    "comment" : "\n     * Returns an estimate of the total number of completed tasks that\n     * were executed by a thread other than their submitter. The\n     * reported value underestimates the actual total number of steals\n     * when the pool is not quiescent. This value may be useful for\n     * monitoring and tuning fork/join programs: in general, steal\n     * counts should be high enough to keep threads busy, but low\n     * enough to avoid overhead and contention across threads.\n     *\n     * @return the number of steals\n     ",
    "links" : [ ]
  }, {
    "name" : "public long getQueuedTaskCount()",
    "returnType" : "long",
    "comment" : "\n     * Returns an estimate of the total number of tasks currently held\n     * in queues by worker threads (but not including tasks submitted\n     * to the pool that have not begun executing). This value is only\n     * an approximation, obtained by iterating across all threads in\n     * the pool. This method may be useful for tuning task\n     * granularities.\n     *\n     * @return the number of queued tasks\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getQueuedSubmissionCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns an estimate of the number of tasks submitted to this\n     * pool that have not yet begun executing.  This method may take\n     * time proportional to the number of submissions.\n     *\n     * @return the number of queued submissions\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasQueuedSubmissions()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if there are any tasks submitted to this\n     * pool that have not yet begun executing.\n     *\n     * @return {@code true} if there are any queued submissions\n     ",
    "links" : [ ]
  }, {
    "name" : "protected ForkJoinTask<?> pollSubmission()",
    "returnType" : "ForkJoinTask<?>",
    "comment" : "\n     * Removes and returns the next unexecuted submission if one is\n     * available.  This method may be useful in extensions to this\n     * class that re-assign work in systems with multiple pools.\n     *\n     * @return the next submission, or {@code null} if none\n     ",
    "links" : [ ]
  }, {
    "name" : "protected int drainTasksTo(Collection<? super ForkJoinTask<?>> c)",
    "returnType" : "int",
    "comment" : "\n     * Removes all available unexecuted submitted and forked tasks\n     * from scheduling queues and adds them to the given collection,\n     * without altering their execution status. These may include\n     * artificially generated or wrapped tasks. This method is\n     * designed to be invoked only when the pool is known to be\n     * quiescent. Invocations at other times may not remove all\n     * tasks. A failure encountered while attempting to add elements\n     * to collection {@code c} may result in elements being in\n     * neither, either or both collections when the associated\n     * exception is thrown.  The behavior of this operation is\n     * undefined if the specified collection is modified while the\n     * operation is in progress.\n     *\n     * @param c the collection to transfer elements into\n     * @return the number of elements transferred\n     ",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "\n     * Returns a string identifying this pool, as well as its state,\n     * including indications of run state, parallelism level, and\n     * worker and task counts.\n     *\n     * @return a string identifying this pool, as well as its state\n     ",
    "links" : [ ]
  }, {
    "name" : "public void shutdown()",
    "returnType" : "void",
    "comment" : "\n     * Possibly initiates an orderly shutdown in which previously\n     * submitted tasks are executed, but no new tasks will be\n     * accepted. Invocation has no effect on execution state if this\n     * is the {@link #commonPool()}, and no additional effect if\n     * already shut down.  Tasks that are in the process of being\n     * submitted concurrently during the course of this method may or\n     * may not be rejected.\n     *\n     * @throws SecurityException if a security manager exists and\n     *         the caller is not permitted to modify threads\n     *         because it does not hold {@link\n     *         java.lang.RuntimePermission}{@code (\"modifyThread\")}\n     ",
    "links" : [ "#commonPool()", "java.lang.RuntimePermission" ]
  }, {
    "name" : "public List<Runnable> shutdownNow()",
    "returnType" : "List<Runnable>",
    "comment" : "\n     * Possibly attempts to cancel and/or stop all tasks, and reject\n     * all subsequently submitted tasks.  Invocation has no effect on\n     * execution state if this is the {@link #commonPool()}, and no\n     * additional effect if already shut down. Otherwise, tasks that\n     * are in the process of being submitted or executed concurrently\n     * during the course of this method may or may not be\n     * rejected. This method cancels both existing and unexecuted\n     * tasks, in order to permit termination in the presence of task\n     * dependencies. So the method always returns an empty list\n     * (unlike the case for some other Executors).\n     *\n     * @return an empty list\n     * @throws SecurityException if a security manager exists and\n     *         the caller is not permitted to modify threads\n     *         because it does not hold {@link\n     *         java.lang.RuntimePermission}{@code (\"modifyThread\")}\n     ",
    "links" : [ "#commonPool()", "java.lang.RuntimePermission" ]
  }, {
    "name" : "public boolean isTerminated()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if all tasks have completed following shut down.\n     *\n     * @return {@code true} if all tasks have completed following shut down\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isTerminating()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the process of termination has\n     * commenced but not yet completed.  This method may be useful for\n     * debugging. A return of {@code true} reported a sufficient\n     * period after shutdown may indicate that submitted tasks have\n     * ignored or suppressed interruption, or are waiting for I/O,\n     * causing this executor not to properly terminate. (See the\n     * advisory notes for class {@link ForkJoinTask} stating that\n     * tasks should not normally entail blocking operations.  But if\n     * they do, they must abort them on interrupt.)\n     *\n     * @return {@code true} if terminating but not yet terminated\n     ",
    "links" : [ "java.util.concurrent.ForkJoinTask" ]
  }, {
    "name" : "public boolean isShutdown()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if this pool has been shut down.\n     *\n     * @return {@code true} if this pool has been shut down\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException",
    "returnType" : "boolean",
    "comment" : "\n     * Blocks until all tasks have completed execution after a\n     * shutdown request, or the timeout occurs, or the current thread\n     * is interrupted, whichever happens first. Because the {@link\n     * #commonPool()} never terminates until program shutdown, when\n     * applied to the common pool, this method is equivalent to {@link\n     * #awaitQuiescence(long, TimeUnit)} but always returns {@code false}.\n     *\n     * @param timeout the maximum time to wait\n     * @param unit the time unit of the timeout argument\n     * @return {@code true} if this executor terminated and\n     *         {@code false} if the timeout elapsed before termination\n     * @throws InterruptedException if interrupted while waiting\n     ",
    "links" : [ "#awaitQuiescence(long", "#commonPool()" ]
  }, {
    "name" : "public boolean awaitQuiescence(long timeout, TimeUnit unit)",
    "returnType" : "boolean",
    "comment" : "\n     * If called by a ForkJoinTask operating in this pool, equivalent\n     * in effect to {@link ForkJoinTask#helpQuiesce}. Otherwise,\n     * waits and/or attempts to assist performing tasks until this\n     * pool {@link #isQuiescent} or the indicated timeout elapses.\n     *\n     * @param timeout the maximum time to wait\n     * @param unit the time unit of the timeout argument\n     * @return {@code true} if quiescent; {@code false} if the\n     * timeout elapsed.\n     ",
    "links" : [ "java.util.concurrent.ForkJoinTask#helpQuiesce", "#isQuiescent" ]
  }, {
    "name" : "public static void managedBlock(ManagedBlocker blocker) throws InterruptedException",
    "returnType" : "void",
    "comment" : "\n     * Runs the given possibly blocking task.  When {@linkplain\n     * ForkJoinTask#inForkJoinPool() running in a ForkJoinPool}, this\n     * method possibly arranges for a spare thread to be activated if\n     * necessary to ensure sufficient parallelism while the current\n     * thread is blocked in {@link ManagedBlocker#block blocker.block()}.\n     *\n     * <p>This method repeatedly calls {@code blocker.isReleasable()} and\n     * {@code blocker.block()} until either method returns {@code true}.\n     * Every call to {@code blocker.block()} is preceded by a call to\n     * {@code blocker.isReleasable()} that returned {@code false}.\n     *\n     * <p>If not running in a ForkJoinPool, this method is\n     * behaviorally equivalent to\n     * <pre> {@code\n     * while (!blocker.isReleasable())\n     *   if (blocker.block())\n     *     break;}</pre>\n     *\n     * If running in a ForkJoinPool, the pool may first be expanded to\n     * ensure sufficient parallelism available during the call to\n     * {@code blocker.block()}.\n     *\n     * @param blocker the blocker task\n     * @throws InterruptedException if {@code blocker.block()} did so\n     ",
    "links" : [ "#block" ]
  }, {
    "name" : "private void compensatedBlock(ManagedBlocker blocker) throws InterruptedException",
    "returnType" : "void",
    "comment" : " ManagedBlock for ForkJoinWorkerThreads ",
    "links" : [ ]
  }, {
    "name" : "private static void unmanagedBlock(ManagedBlocker blocker) throws InterruptedException",
    "returnType" : "void",
    "comment" : " ManagedBlock for external threads ",
    "links" : [ ]
  }, {
    "name" : "protected RunnableFuture<T> newTaskFor(Runnable runnable, T value)",
    "returnType" : "RunnableFuture<T>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected RunnableFuture<T> newTaskFor(Callable<T> callable)",
    "returnType" : "RunnableFuture<T>",
    "comment" : "",
    "links" : [ ]
  } ],
  "methodNames" : [ "private static void checkPermission()", " static AccessControlContext contextWithPermissions(Permission... perms)", "private boolean compareAndSetCtl(long c, long v)", "private long compareAndExchangeCtl(long c, long v)", "private long getAndAddCtl(long v)", "private int getAndBitwiseOrMode(int v)", "private int getAndAddThreadIds(int x)", "private static int getAndAddPoolIds(int x)", "private boolean createWorker()", " final String nextWorkerThreadName()", " final void registerWorker(WorkQueue w)", " final void deregisterWorker(ForkJoinWorkerThread wt, Throwable ex)", " final void signalWork()", " final void runWorker(WorkQueue w)", "private int scan(WorkQueue w, int prevSrc, int r)", "private int awaitWork(WorkQueue w)", " final boolean canStop()", "private int tryCompensate(long c)", " final void uncompensate()", " final int helpJoin(ForkJoinTask<?> task, WorkQueue w, boolean canHelp)", " final int helpComplete(ForkJoinTask<?> task, WorkQueue w, boolean owned)", "private ForkJoinTask<?> pollScan(boolean submissionsOnly)", " final int helpQuiescePool(WorkQueue w, long nanos, boolean interruptible)", " final int externalHelpQuiescePool(long nanos, boolean interruptible)", " final ForkJoinTask<?> nextTaskFor(WorkQueue w)", " final WorkQueue submissionQueue()", " final void externalPush(ForkJoinTask<?> task)", "private ForkJoinTask<T> externalSubmit(ForkJoinTask<T> task)", " static WorkQueue commonQueue()", " final WorkQueue externalQueue()", " static void helpAsyncBlocker(Executor e, ManagedBlocker blocker)", " static int getSurplusQueuedTaskCount()", "private boolean tryTerminate(boolean now, boolean enable)", "private static Object newInstanceFromSystemProperty(String property) throws ReflectiveOperationException", "public static ForkJoinPool commonPool()", "public T invoke(ForkJoinTask<T> task)", "public void execute(ForkJoinTask<?> task)", "public void execute(Runnable task)", "public ForkJoinTask<T> submit(ForkJoinTask<T> task)", "public ForkJoinTask<T> submit(Callable<T> task)", "public ForkJoinTask<T> submit(Runnable task, T result)", "public ForkJoinTask<?> submit(Runnable task)", "public List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)", "public List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException", "public T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException", "public T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException", "public ForkJoinWorkerThreadFactory getFactory()", "public UncaughtExceptionHandler getUncaughtExceptionHandler()", "public int getParallelism()", "public static int getCommonPoolParallelism()", "public int getPoolSize()", "public boolean getAsyncMode()", "public int getRunningThreadCount()", "public int getActiveThreadCount()", "public boolean isQuiescent()", "public long getStealCount()", "public long getQueuedTaskCount()", "public int getQueuedSubmissionCount()", "public boolean hasQueuedSubmissions()", "protected ForkJoinTask<?> pollSubmission()", "protected int drainTasksTo(Collection<? super ForkJoinTask<?>> c)", "public String toString()", "public void shutdown()", "public List<Runnable> shutdownNow()", "public boolean isTerminated()", "public boolean isTerminating()", "public boolean isShutdown()", "public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException", "public boolean awaitQuiescence(long timeout, TimeUnit unit)", "public static void managedBlock(ManagedBlocker blocker) throws InterruptedException", "private void compensatedBlock(ManagedBlocker blocker) throws InterruptedException", "private static void unmanagedBlock(ManagedBlocker blocker) throws InterruptedException", "protected RunnableFuture<T> newTaskFor(Runnable runnable, T value)", "protected RunnableFuture<T> newTaskFor(Callable<T> callable)" ],
  "variableNames" : [ "SWIDTH", "SMASK", "MAX_CAP", "UNSIGNALLED", "SS_SEQ", "FIFO", "SRC", "INNOCUOUS", "QUIET", "SHUTDOWN", "TERMINATED", "STOP", "UNCOMPENSATE", "INITIAL_QUEUE_CAPACITY", "defaultForkJoinWorkerThreadFactory", "modifyThreadPermission", "common", "COMMON_PARALLELISM", "COMMON_MAX_SPARES", "poolIds", "DEFAULT_KEEPALIVE", "TIMEOUT_SLOP", "DEFAULT_COMMON_MAX_SPARES", "SP_MASK", "UC_MASK", "RC_SHIFT", "RC_UNIT", "RC_MASK", "TC_SHIFT", "TC_UNIT", "TC_MASK", "ADD_WORKER", "keepAlive", "stealCount", "scanRover", "threadIds", "bounds", "mode", "queues", "registrationLock", "termination", "workerNamePrefix", "factory", "ueh", "saturate", "ctl", "CTL", "MODE", "THREADIDS", "POOLIDS" ]
}