{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/net/wifi/WifiManager.java",
  "packageName" : "android.net.wifi",
  "className" : "WifiManager",
  "comment" : "\n * This class provides the primary API for managing all aspects of Wi-Fi\n * connectivity.\n * <p>\n * On releases before {@link android.os.Build.VERSION_CODES#N}, this object\n * should only be obtained from an {@linkplain Context#getApplicationContext()\n * application context}, and not from any other derived context to avoid memory\n * leaks within the calling process.\n * <p>\n * It deals with several categories of items:\n * </p>\n * <ul>\n * <li>The list of configured networks. The list can be viewed and updated, and\n * attributes of individual entries can be modified.</li>\n * <li>The currently active Wi-Fi network, if any. Connectivity can be\n * established or torn down, and dynamic information about the state of the\n * network can be queried.</li>\n * <li>Results of access point scans, containing enough information to make\n * decisions about what access point to connect to.</li>\n * <li>It defines the names of various Intent actions that are broadcast upon\n * any sort of change in Wi-Fi state.\n * </ul>\n * <p>\n * This is the API to use when performing Wi-Fi specific operations. To perform\n * operations that pertain to network connectivity at an abstract level, use\n * {@link android.net.ConnectivityManager}.\n * </p>\n ",
  "links" : [ "android.net.ConnectivityManager", "android.os.Build.VERSION_CODES#N" ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "NOT_OVERRIDE_EXISTING_NETWORKS_ON_RESTORE",
    "type" : "long",
    "comment" : "\n     * Local networks should not be modified by B&R since the user may have\n     * updated it with the latest configurations.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_AUTHENTICATING",
    "type" : "int",
    "comment" : "\n     * The error code if there was a problem authenticating.\n     * @deprecated This is no longer supported.\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_AUTH_FAILURE_NONE",
    "type" : "int",
    "comment" : "\n     * The reason code if there is no error during authentication.\n     * It could also imply that there no authentication in progress,\n     * this reason code also serves as a reset value.\n     * @deprecated This is no longer supported.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_AUTH_FAILURE_TIMEOUT",
    "type" : "int",
    "comment" : "\n     * The reason code if there was a timeout authenticating.\n     * @deprecated This is no longer supported.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_AUTH_FAILURE_WRONG_PSWD",
    "type" : "int",
    "comment" : "\n     * The reason code if there was a wrong password while\n     * authenticating.\n     * @deprecated This is no longer supported.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ERROR_AUTH_FAILURE_EAP_FAILURE",
    "type" : "int",
    "comment" : "\n     * The reason code if there was EAP failure while\n     * authenticating.\n     * @deprecated This is no longer supported.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_SUGGESTIONS_MAX_PER_APP_LOW_RAM",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "NETWORK_SUGGESTIONS_MAX_PER_APP_HIGH_RAM",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "STATUS_NETWORK_SUGGESTIONS_SUCCESS",
    "type" : "int",
    "comment" : "\n     * Reason code if all of the network suggestions were successfully added or removed.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_NETWORK_SUGGESTIONS_ERROR_INTERNAL",
    "type" : "int",
    "comment" : "\n     * Reason code if there was an internal error in the platform while processing the addition or\n     * removal of suggestions.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_NETWORK_SUGGESTIONS_ERROR_APP_DISALLOWED",
    "type" : "int",
    "comment" : "\n     * Reason code if the user has disallowed \"android:change_wifi_state\" app-ops from the app.\n     * @see android.app.AppOpsManager#unsafeCheckOp(String, int, String).\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_NETWORK_SUGGESTIONS_ERROR_ADD_DUPLICATE",
    "type" : "int",
    "comment" : "\n     * Reason code if one or more of the network suggestions added already exists in platform's\n     * database.\n     * Note: this code will not be returned with Android 11 as in-place modification is allowed,\n     * please check {@link #addNetworkSuggestions(List)}.\n     * @see WifiNetworkSuggestion#equals(Object)\n     ",
    "links" : [ "#addNetworkSuggestions(List)" ]
  }, {
    "name" : "STATUS_NETWORK_SUGGESTIONS_ERROR_ADD_EXCEEDS_MAX_PER_APP",
    "type" : "int",
    "comment" : "\n     * Reason code if the number of network suggestions provided by the app crosses the max\n     * threshold set per app.\n     * The framework will reject all suggestions provided by {@link #addNetworkSuggestions(List)} if\n     * the total size exceeds the limit.\n     * @see #getMaxNumberOfNetworkSuggestionsPerApp()\n     ",
    "links" : [ "#addNetworkSuggestions(List)" ]
  }, {
    "name" : "STATUS_NETWORK_SUGGESTIONS_ERROR_REMOVE_INVALID",
    "type" : "int",
    "comment" : "\n     * Reason code if one or more of the network suggestions removed does not exist in platform's\n     * database.\n     * The framework won't remove any suggestions if one or more of suggestions provided\n     * by {@link #removeNetworkSuggestions(List)} does not exist in database.\n     * @see WifiNetworkSuggestion#equals(Object)\n     ",
    "links" : [ "#removeNetworkSuggestions(List)" ]
  }, {
    "name" : "STATUS_NETWORK_SUGGESTIONS_ERROR_ADD_NOT_ALLOWED",
    "type" : "int",
    "comment" : "\n     * Reason code if one or more of the network suggestions added is not allowed.\n     * The framework will reject all suggestions provided by {@link #addNetworkSuggestions(List)}\n     * if one or more of them is not allowed.\n     * This error may be caused by suggestion is using SIM-based encryption method, but calling app\n     * is not carrier privileged.\n     ",
    "links" : [ "#addNetworkSuggestions(List)" ]
  }, {
    "name" : "STATUS_NETWORK_SUGGESTIONS_ERROR_ADD_INVALID",
    "type" : "int",
    "comment" : "\n     * Reason code if one or more of the network suggestions added is invalid. Framework will reject\n     * all the suggestions in the list.\n     * The framework will reject all suggestions provided by {@link #addNetworkSuggestions(List)}\n     * if one or more of them is invalid.\n     * Please use {@link WifiNetworkSuggestion.Builder} to create network suggestions.\n     ",
    "links" : [ "WifiNetworkSuggestion.Builder", "#addNetworkSuggestions(List)" ]
  }, {
    "name" : "STATUS_NETWORK_SUGGESTIONS_ERROR_RESTRICTED_BY_ADMIN",
    "type" : "int",
    "comment" : "\n     * Reason code if {@link android.os.UserManager#DISALLOW_ADD_WIFI_CONFIG} user restriction\n     * is set and calling app is restricted by device admin.\n     ",
    "links" : [ "android.os.UserManager#DISALLOW_ADD_WIFI_CONFIG" ]
  }, {
    "name" : "STATUS_SUGGESTION_CONNECTION_FAILURE_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Reason code if suggested network connection attempt failed with an unknown failure.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_SUGGESTION_CONNECTION_FAILURE_ASSOCIATION",
    "type" : "int",
    "comment" : "\n     * Reason code if suggested network connection attempt failed with association failure.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_SUGGESTION_CONNECTION_FAILURE_AUTHENTICATION",
    "type" : "int",
    "comment" : "\n     * Reason code if suggested network connection attempt failed with an authentication failure.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_SUGGESTION_CONNECTION_FAILURE_IP_PROVISIONING",
    "type" : "int",
    "comment" : "\n     * Reason code if suggested network connection attempt failed with an IP provision failure.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_LOCAL_ONLY_CONNECTION_FAILURE_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Reason code if local-only network connection attempt failed with an unknown failure.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_LOCAL_ONLY_CONNECTION_FAILURE_ASSOCIATION",
    "type" : "int",
    "comment" : "\n     * Reason code if local-only network connection attempt failed with association failure.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_LOCAL_ONLY_CONNECTION_FAILURE_AUTHENTICATION",
    "type" : "int",
    "comment" : "\n     * Reason code if local-only network connection attempt failed with an authentication failure.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_LOCAL_ONLY_CONNECTION_FAILURE_IP_PROVISIONING",
    "type" : "int",
    "comment" : "\n     * Reason code if local-only network connection attempt failed with an IP provisioning failure.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_LOCAL_ONLY_CONNECTION_FAILURE_NOT_FOUND",
    "type" : "int",
    "comment" : "\n     * Reason code if local-only network connection attempt failed with AP not in range.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_LOCAL_ONLY_CONNECTION_FAILURE_NO_RESPONSE",
    "type" : "int",
    "comment" : "\n     * Reason code if local-only network connection attempt failed with AP not responding\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_SUGGESTION_APPROVAL_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Status code if suggestion approval status is unknown, an App which hasn't made any\n     * suggestions will get this code.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_SUGGESTION_APPROVAL_PENDING",
    "type" : "int",
    "comment" : "\n     * Status code if the calling app is still pending user approval for suggestions.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_SUGGESTION_APPROVAL_APPROVED_BY_USER",
    "type" : "int",
    "comment" : "\n     * Status code if the calling app got the user approval for suggestions.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_SUGGESTION_APPROVAL_REJECTED_BY_USER",
    "type" : "int",
    "comment" : "\n     * Status code if the calling app suggestions were rejected by the user.\n     ",
    "links" : [ ]
  }, {
    "name" : "STATUS_SUGGESTION_APPROVAL_APPROVED_BY_CARRIER_PRIVILEGE",
    "type" : "int",
    "comment" : "\n     * Status code if the calling app was approved by virtue of being a carrier privileged app.\n     *\n     * @see android.telephony.TelephonyManager#hasCarrierPrivileges()\n     ",
    "links" : [ ]
  }, {
    "name" : "PNO_SCAN_STATE_DISABLED_UNTIL_REBOOT",
    "type" : "int",
    "comment" : "\n     * Disable PNO scan until device reboot.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PNO_SCAN_STATE_DISABLED_UNTIL_WIFI_TOGGLE",
    "type" : "int",
    "comment" : "\n     * Disable PNO scan until device reboot or Wi-Fi is toggled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PNO_SCAN_STATE_ENABLED",
    "type" : "int",
    "comment" : "\n     * Enable PNO scan.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_REMOVE_SUGGESTION_LINGER",
    "type" : "int",
    "comment" : "\n     * If one of the removed suggestions is currently connected, that network will be disconnected\n     * after a short delay as opposed to immediately (which will be done by\n     * {@link #ACTION_REMOVE_SUGGESTION_DISCONNECT}). The {@link ConnectivityManager} may call the\n     * {@link NetworkCallback#onLosing(Network, int)} on such networks.\n     ",
    "links" : [ "android.net.ConnectivityManager", "#ACTION_REMOVE_SUGGESTION_DISCONNECT", "android.net.ConnectivityManager.NetworkCallback#onLosing(Network" ]
  }, {
    "name" : "ACTION_REMOVE_SUGGESTION_DISCONNECT",
    "type" : "int",
    "comment" : "\n     * If one of the removed suggestions is currently connected, trigger an immediate disconnect\n     * after suggestions removal\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_PARAM_KEY_ATTRIBUTION_SOURCE",
    "type" : "String",
    "comment" : "\n     * Only available on Android S or later.\n     * @hide\n     *",
    "links" : [ ]
  }, {
    "name" : "ACTION_WIFI_SCAN_AVAILABILITY_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating whether Wi-Fi scanning is currently available.\n     * Available extras:\n     * - {@link #EXTRA_SCAN_AVAILABLE}\n     ",
    "links" : [ "#EXTRA_SCAN_AVAILABLE" ]
  }, {
    "name" : "EXTRA_SCAN_AVAILABLE",
    "type" : "String",
    "comment" : "\n     * A boolean extra indicating whether scanning is currently available.\n     * Sent in the broadcast {@link #ACTION_WIFI_SCAN_AVAILABILITY_CHANGED}.\n     * Its value is true if scanning is currently available, false otherwise.\n     ",
    "links" : [ "#ACTION_WIFI_SCAN_AVAILABILITY_CHANGED" ]
  }, {
    "name" : "WIFI_CREDENTIAL_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that the credential of a Wi-Fi network\n     * has been changed. One extra provides the ssid of the network. Another\n     * extra provides the event type, whether the credential is saved or forgot.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_WIFI_CREDENTIAL_EVENT_TYPE",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_WIFI_CREDENTIAL_SSID",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "WIFI_CREDENTIAL_SAVED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "WIFI_CREDENTIAL_FORGOT",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "PASSPOINT_HOME_NETWORK",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "PASSPOINT_ROAMING_NETWORK",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "API_SCANNING_ENABLED",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of {@link WifiScanner#setScanningEnabled(boolean)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.WifiScanner#setScanningEnabled(boolean)" ]
  }, {
    "name" : "API_WIFI_ENABLED",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of {@link WifiManager#setWifiEnabled(boolean)} .\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.WifiManager#setWifiEnabled(boolean)" ]
  }, {
    "name" : "API_SOFT_AP",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of {@link WifiManager#startSoftAp(WifiConfiguration)} and\n     * {@link WifiManager#stopSoftAp()}.\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.WifiManager#startSoftAp(WifiConfiguration)", "android.net.wifi.WifiManager#stopSoftAp()" ]
  }, {
    "name" : "API_TETHERED_HOTSPOT",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of {@link WifiManager#startTetheredHotspot(SoftApConfiguration)}.\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.WifiManager#startTetheredHotspot(SoftApConfiguration)" ]
  }, {
    "name" : "API_AUTOJOIN_GLOBAL",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of {@link WifiManager#allowAutojoinGlobal(boolean)}.\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#allowAutojoinGlobal(boolean)", "android.net.wifi.WifiManager#getLastCallerInfoForApi(int" ]
  }, {
    "name" : "API_SET_SCAN_SCHEDULE",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of {@link WifiManager#setScreenOnScanSchedule(List)}.\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#setScreenOnScanSchedule(List)", "android.net.wifi.WifiManager#getLastCallerInfoForApi(int" ]
  }, {
    "name" : "API_SET_ONE_SHOT_SCREEN_ON_CONNECTIVITY_SCAN_DELAY",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of {@link WifiManager#setOneShotScreenOnConnectivityScanDelayMillis(int)}.\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.WifiManager#setOneShotScreenOnConnectivityScanDelayMillis(int)" ]
  }, {
    "name" : "API_SET_NETWORK_SELECTION_CONFIG",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiManager#setNetworkSelectionConfig(WifiNetworkSelectionConfig)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.WifiManager#setNetworkSelectionConfig(WifiNetworkSelectionConfig)" ]
  }, {
    "name" : "API_SET_THIRD_PARTY_APPS_ENABLING_WIFI_CONFIRMATION_DIALOG",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiManager#setThirdPartyAppEnablingWifiConfirmationDialogEnabled(boolean)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#setThirdPartyAppEnablingWifiConfirmationDialogEnabled(boolean)", "android.net.wifi.WifiManager#getLastCallerInfoForApi(int" ]
  }, {
    "name" : "API_ADD_NETWORK",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiManager#addNetwork(WifiConfiguration)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#addNetwork(WifiConfiguration)", "android.net.wifi.WifiManager#getLastCallerInfoForApi(int" ]
  }, {
    "name" : "API_UPDATE_NETWORK",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiManager#updateNetwork(WifiConfiguration)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.WifiManager#updateNetwork(WifiConfiguration)" ]
  }, {
    "name" : "API_ALLOW_AUTOJOIN",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiManager#allowAutojoin(int, boolean)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#allowAutojoin(int", "android.net.wifi.WifiManager#getLastCallerInfoForApi(int" ]
  }, {
    "name" : "API_CONNECT_CONFIG",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiManager#connect(WifiConfiguration, ActionListener)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#connect(WifiConfiguration", "android.net.wifi.WifiManager#getLastCallerInfoForApi(int" ]
  }, {
    "name" : "API_CONNECT_NETWORK_ID",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiManager#connect(int, ActionListener)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#connect(int", "android.net.wifi.WifiManager#getLastCallerInfoForApi(int" ]
  }, {
    "name" : "API_DISABLE_NETWORK",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiManager#disableNetwork(int)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.WifiManager#disableNetwork(int)" ]
  }, {
    "name" : "API_ENABLE_NETWORK",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiManager#enableNetwork(int, boolean)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#enableNetwork(int", "android.net.wifi.WifiManager#getLastCallerInfoForApi(int" ]
  }, {
    "name" : "API_FORGET",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiManager#forget(int, ActionListener)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.WifiManager#forget(int" ]
  }, {
    "name" : "API_SAVE",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiManager#save(WifiConfiguration, ActionListener)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.WifiManager#save(WifiConfiguration" ]
  }, {
    "name" : "API_START_SCAN",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiManager#startScan()}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#startScan()", "android.net.wifi.WifiManager#getLastCallerInfoForApi(int" ]
  }, {
    "name" : "API_START_LOCAL_ONLY_HOTSPOT",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiManager#startLocalOnlyHotspot(LocalOnlyHotspotCallback, Handler)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.WifiManager#startLocalOnlyHotspot(LocalOnlyHotspotCallback" ]
  }, {
    "name" : "API_P2P_DISCOVER_PEERS",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiP2pManager#discoverPeers(WifiP2pManager.Channel, WifiP2pManager.ActionListener)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.p2p.WifiP2pManager#discoverPeers(WifiP2pManager.Channel" ]
  }, {
    "name" : "API_P2P_DISCOVER_PEERS_ON_SOCIAL_CHANNELS",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiP2pManager#discoverPeersOnSocialChannels(WifiP2pManager.Channel,\n     * WifiP2pManager.ActionListener)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.p2p.WifiP2pManager#discoverPeersOnSocialChannels(WifiP2pManager.Channel" ]
  }, {
    "name" : "API_P2P_DISCOVER_PEERS_ON_SPECIFIC_FREQUENCY",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiP2pManager#discoverPeersOnSpecificFrequency(WifiP2pManager.Channel, int,\n     * WifiP2pManager.ActionListener)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.p2p.WifiP2pManager#discoverPeersOnSpecificFrequency(WifiP2pManager.Channel" ]
  }, {
    "name" : "API_P2P_STOP_PEER_DISCOVERY",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiP2pManager#stopPeerDiscovery(WifiP2pManager.Channel,\n     * WifiP2pManager.ActionListener)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.p2p.WifiP2pManager#stopPeerDiscovery(WifiP2pManager.Channel" ]
  }, {
    "name" : "API_P2P_CONNECT",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiP2pManager#connect(WifiP2pManager.Channel, WifiP2pConfig,\n     * WifiP2pManager.ActionListener)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.p2p.WifiP2pManager#connect(WifiP2pManager.Channel" ]
  }, {
    "name" : "API_P2P_CANCEL_CONNECT",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiP2pManager#cancelConnect(WifiP2pManager.Channel, WifiP2pManager.ActionListener)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.p2p.WifiP2pManager#cancelConnect(WifiP2pManager.Channel" ]
  }, {
    "name" : "API_P2P_CREATE_GROUP",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiP2pManager#createGroup(WifiP2pManager.Channel, WifiP2pManager.ActionListener)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.p2p.WifiP2pManager#createGroup(WifiP2pManager.Channel" ]
  }, {
    "name" : "API_P2P_CREATE_GROUP_P2P_CONFIG",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiP2pManager#createGroup(WifiP2pManager.Channel, WifiP2pConfig,\n     * WifiP2pManager.ActionListener)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.p2p.WifiP2pManager#createGroup(WifiP2pManager.Channel" ]
  }, {
    "name" : "API_P2P_REMOVE_GROUP",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiP2pManager#removeGroup(WifiP2pManager.Channel, WifiP2pManager.ActionListener)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.p2p.WifiP2pManager#removeGroup(WifiP2pManager.Channel" ]
  }, {
    "name" : "API_P2P_START_LISTENING",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiP2pManager#startListening(WifiP2pManager.Channel, WifiP2pManager.ActionListener)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.p2p.WifiP2pManager#startListening(WifiP2pManager.Channel" ]
  }, {
    "name" : "API_P2P_STOP_LISTENING",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiP2pManager#stopListening(WifiP2pManager.Channel, WifiP2pManager.ActionListener)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.p2p.WifiP2pManager#stopListening(WifiP2pManager.Channel" ]
  }, {
    "name" : "API_P2P_SET_CHANNELS",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiP2pManager#setWifiP2pChannels(WifiP2pManager.Channel, int, int,\n     * WifiP2pManager.ActionListener)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.p2p.WifiP2pManager#setWifiP2pChannels(WifiP2pManager.Channel" ]
  }, {
    "name" : "API_WIFI_SCANNER_START_SCAN",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiScanner#startScan(WifiScanner.ScanSettings, WifiScanner.ScanListener)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.WifiScanner#startScan(WifiScanner.ScanSettings" ]
  }, {
    "name" : "API_SET_TDLS_ENABLED",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiManager#setTdlsEnabled(InetAddress, boolean)} and\n     * {@link WifiManager#setTdlsEnabled(InetAddress, boolean, Executor, Consumer)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.WifiManager#setTdlsEnabled(InetAddress" ]
  }, {
    "name" : "API_SET_TDLS_ENABLED_WITH_MAC_ADDRESS",
    "type" : "int",
    "comment" : "\n     * A constant used in\n     * {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of\n     * {@link WifiManager#setTdlsEnabledWithMacAddress(String, boolean)} and\n     * {@link WifiManager#setTdlsEnabledWithMacAddress(String, boolean, Executor, Consumer)}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.WifiManager#setTdlsEnabledWithMacAddress(String" ]
  }, {
    "name" : "API_SET_PNO_SCAN_ENABLED",
    "type" : "int",
    "comment" : "\n     * A constant used in {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of {@link WifiManager#setPnoScanState(int)}\n     *\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.WifiManager#setPnoScanState(int)" ]
  }, {
    "name" : "API_P2P_DISCOVER_PEERS_WITH_CONFIG_PARAMS",
    "type" : "int",
    "comment" : "\n     * A constant used in {@link WifiManager#getLastCallerInfoForApi(int, Executor, BiConsumer)}\n     * Tracks usage of {@link WifiP2pManager#discoverPeersWithConfigParams(\n     * WifiP2pManager.Channel, WifiP2pDiscoveryConfig, WifiP2pManager.ActionListener)}\n     *\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getLastCallerInfoForApi(int", "android.net.wifi.p2p.WifiP2pManager#discoverPeersWithConfigParams(" ]
  }, {
    "name" : "API_MAX",
    "type" : "int",
    "comment" : "\n     * Used internally to keep track of boundary.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_PASSPOINT_ICON",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that a Passpoint provider icon has been received.\n     *\n     * Included extras:\n     * {@link #EXTRA_BSSID_LONG}\n     * {@link #EXTRA_FILENAME}\n     * {@link #EXTRA_ICON}\n     *\n     * Receiver Required Permission: android.Manifest.permission.ACCESS_WIFI_STATE\n     *\n     * <p>Note: The broadcast is only delivered to registered receivers - no manifest registered\n     * components will be launched.\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_ICON", "#EXTRA_FILENAME", "#EXTRA_BSSID_LONG" ]
  }, {
    "name" : "EXTRA_BSSID_LONG",
    "type" : "String",
    "comment" : "\n     * BSSID of an AP in long representation.  The {@link #EXTRA_BSSID} contains BSSID in\n     * String representation.\n     *\n     * Retrieve with {@link android.content.Intent#getLongExtra(String, long)}.\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_BSSID", "android.content.Intent#getLongExtra(String" ]
  }, {
    "name" : "EXTRA_ICON",
    "type" : "String",
    "comment" : "\n     * Icon data.\n     *\n     * Retrieve with {@link android.content.Intent#getParcelableExtra(String)} and cast into\n     * {@link android.graphics.drawable.Icon}.\n     *\n     * @hide\n     ",
    "links" : [ "android.graphics.drawable.Icon", "android.content.Intent#getParcelableExtra(String)" ]
  }, {
    "name" : "EXTRA_FILENAME",
    "type" : "String",
    "comment" : "\n     * Name of a file.\n     *\n     * Retrieve with {@link android.content.Intent#getStringExtra(String)}.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Intent#getStringExtra(String)" ]
  }, {
    "name" : "ACTION_PASSPOINT_OSU_PROVIDERS_LIST",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating a Passpoint OSU Providers List element has been received.\n     *\n     * Included extras:\n     * {@link #EXTRA_BSSID_LONG}\n     * {@link #EXTRA_ANQP_ELEMENT_DATA}\n     *\n     * Receiver Required Permission: android.Manifest.permission.ACCESS_WIFI_STATE\n     *\n     * <p>Note: The broadcast is only delivered to registered receivers - no manifest registered\n     * components will be launched.\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_ANQP_ELEMENT_DATA", "#EXTRA_BSSID_LONG" ]
  }, {
    "name" : "EXTRA_ANQP_ELEMENT_DATA",
    "type" : "String",
    "comment" : "\n     * Raw binary data of an ANQP (Access Network Query Protocol) element.\n     *\n     * Retrieve with {@link android.content.Intent#getByteArrayExtra(String)}.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Intent#getByteArrayExtra(String)" ]
  }, {
    "name" : "ACTION_PASSPOINT_DEAUTH_IMMINENT",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that a Passpoint Deauth Imminent frame has been received.\n     *\n     * Included extras:\n     * {@link #EXTRA_BSSID_LONG}\n     * {@link #EXTRA_ESS}\n     * {@link #EXTRA_DELAY}\n     * {@link #EXTRA_URL}\n     *\n     * Receiver Required Permission: android.Manifest.permission.ACCESS_WIFI_STATE\n     *\n     * <p>Note: The broadcast is only delivered to registered receivers - no manifest registered\n     * components will be launched.\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_DELAY", "#EXTRA_URL", "#EXTRA_BSSID_LONG", "#EXTRA_ESS" ]
  }, {
    "name" : "EXTRA_ESS",
    "type" : "String",
    "comment" : "\n     * Flag indicating BSS (Basic Service Set) or ESS (Extended Service Set). This will be set to\n     * {@code true} for ESS.\n     *\n     * Retrieve with {@link android.content.Intent#getBooleanExtra(String, boolean)}.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Intent#getBooleanExtra(String" ]
  }, {
    "name" : "EXTRA_DELAY",
    "type" : "String",
    "comment" : "\n     * Delay in seconds.\n     *\n     * Retrieve with {@link android.content.Intent#getIntExtra(String, int)}.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Intent#getIntExtra(String" ]
  }, {
    "name" : "ACTION_PASSPOINT_SUBSCRIPTION_REMEDIATION",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating a Passpoint subscription remediation frame has been\n     * received.\n     *\n     * Included extras:\n     * {@link #EXTRA_BSSID_LONG}\n     * {@link #EXTRA_SUBSCRIPTION_REMEDIATION_METHOD}\n     * {@link #EXTRA_URL}\n     *\n     * Receiver Required Permission: android.Manifest.permission.ACCESS_WIFI_STATE\n     *\n     * <p>Note: The broadcast is only delivered to registered receivers - no manifest registered\n     * components will be launched.\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_URL", "#EXTRA_SUBSCRIPTION_REMEDIATION_METHOD", "#EXTRA_BSSID_LONG" ]
  }, {
    "name" : "EXTRA_SUBSCRIPTION_REMEDIATION_METHOD",
    "type" : "String",
    "comment" : "\n     * The protocol supported by the subscription remediation server. The possible values are:\n     * 0 - OMA DM\n     * 1 - SOAP XML SPP\n     *\n     * Retrieve with {@link android.content.Intent#getIntExtra(String, int)}.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Intent#getIntExtra(String" ]
  }, {
    "name" : "ACTION_PASSPOINT_LAUNCH_OSU_VIEW",
    "type" : "String",
    "comment" : "\n     * Activity Action: Receiver should launch Passpoint OSU (Online Sign Up) view.\n     * Included extras:\n     *\n     * {@link #EXTRA_OSU_NETWORK}: {@link Network} instance associated with OSU AP.\n     * {@link #EXTRA_URL}: String representation of a server URL used for OSU process.\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_URL", "android.net.Network", "#EXTRA_OSU_NETWORK" ]
  }, {
    "name" : "EXTRA_OSU_NETWORK",
    "type" : "String",
    "comment" : "\n     * The lookup key for a {@link android.net.Network} associated with a Passpoint OSU server.\n     * Included in the {@link #ACTION_PASSPOINT_LAUNCH_OSU_VIEW} broadcast.\n     *\n     * Retrieve with {@link android.content.Intent#getParcelableExtra(String)}.\n     *\n     * @hide\n     ",
    "links" : [ "android.net.Network", "android.content.Intent#getParcelableExtra(String)", "#ACTION_PASSPOINT_LAUNCH_OSU_VIEW" ]
  }, {
    "name" : "EXTRA_URL",
    "type" : "String",
    "comment" : "\n     * String representation of an URL for Passpoint OSU.\n     * Included in the {@link #ACTION_PASSPOINT_LAUNCH_OSU_VIEW} broadcast.\n     *\n     * Retrieve with {@link android.content.Intent#getStringExtra(String)}.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Intent#getStringExtra(String)", "#ACTION_PASSPOINT_LAUNCH_OSU_VIEW" ]
  }, {
    "name" : "WIFI_STATE_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that Wi-Fi has been enabled, disabled,\n     * enabling, disabling, or unknown. One extra provides this state as an int.\n     * Another extra provides the previous state, if available.  No network-related\n     * permissions are required to subscribe to this broadcast.\n     *\n     * <p class=\"note\">This broadcast is not delivered to manifest receivers in\n     * applications that target API version 26 or later.\n     *\n     * @see #EXTRA_WIFI_STATE\n     * @see #EXTRA_PREVIOUS_WIFI_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_WIFI_STATE",
    "type" : "String",
    "comment" : "\n     * The lookup key for an int that indicates whether Wi-Fi is enabled,\n     * disabled, enabling, disabling, or unknown.  Retrieve it with\n     * {@link android.content.Intent#getIntExtra(String,int)}.\n     *\n     * @see #WIFI_STATE_DISABLED\n     * @see #WIFI_STATE_DISABLING\n     * @see #WIFI_STATE_ENABLED\n     * @see #WIFI_STATE_ENABLING\n     * @see #WIFI_STATE_UNKNOWN\n     ",
    "links" : [ "android.content.Intent#getIntExtra(String" ]
  }, {
    "name" : "EXTRA_PREVIOUS_WIFI_STATE",
    "type" : "String",
    "comment" : "\n     * The previous Wi-Fi state.\n     *\n     * @see #EXTRA_WIFI_STATE\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_STATE_DISABLING",
    "type" : "int",
    "comment" : "\n     * Wi-Fi is currently being disabled. The state will change to {@link #WIFI_STATE_DISABLED} if\n     * it finishes successfully.\n     *\n     * @see #WIFI_STATE_CHANGED_ACTION\n     * @see #getWifiState()\n     ",
    "links" : [ "#WIFI_STATE_DISABLED" ]
  }, {
    "name" : "WIFI_STATE_DISABLED",
    "type" : "int",
    "comment" : "\n     * Wi-Fi is disabled.\n     *\n     * @see #WIFI_STATE_CHANGED_ACTION\n     * @see #getWifiState()\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_STATE_ENABLING",
    "type" : "int",
    "comment" : "\n     * Wi-Fi is currently being enabled. The state will change to {@link #WIFI_STATE_ENABLED} if\n     * it finishes successfully.\n     *\n     * @see #WIFI_STATE_CHANGED_ACTION\n     * @see #getWifiState()\n     ",
    "links" : [ "#WIFI_STATE_ENABLED" ]
  }, {
    "name" : "WIFI_STATE_ENABLED",
    "type" : "int",
    "comment" : "\n     * Wi-Fi is enabled.\n     *\n     * @see #WIFI_STATE_CHANGED_ACTION\n     * @see #getWifiState()\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_STATE_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Wi-Fi is in an unknown state. This state will occur when an error happens while enabling\n     * or disabling.\n     *\n     * @see #WIFI_STATE_CHANGED_ACTION\n     * @see #getWifiState()\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_AP_STATE_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that Wi-Fi AP has been enabled, disabled,\n     * enabling, disabling, or failed.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_WIFI_AP_STATE",
    "type" : "String",
    "comment" : "\n     * The lookup key for an int that indicates whether Wi-Fi AP is enabled,\n     * disabled, enabling, disabling, or failed.  Retrieve it with\n     * {@link android.content.Intent#getIntExtra(String,int)}.\n     *\n     * @see #WIFI_AP_STATE_DISABLED\n     * @see #WIFI_AP_STATE_DISABLING\n     * @see #WIFI_AP_STATE_ENABLED\n     * @see #WIFI_AP_STATE_ENABLING\n     * @see #WIFI_AP_STATE_FAILED\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Intent#getIntExtra(String" ]
  }, {
    "name" : "EXTRA_WIFI_AP_FAILURE_REASON",
    "type" : "String",
    "comment" : "\n     * An extra containing the int error code for Soft AP start failure.\n     * Can be obtained from the {@link #WIFI_AP_STATE_CHANGED_ACTION} using\n     * {@link android.content.Intent#getIntExtra}.\n     * This extra will only be attached if {@link #EXTRA_WIFI_AP_STATE} is\n     * attached and is equal to {@link #WIFI_AP_STATE_FAILED}.\n     *\n     * The error code will be one of:\n     * {@link #SAP_START_FAILURE_GENERAL},\n     * {@link #SAP_START_FAILURE_NO_CHANNEL},\n     * {@link #SAP_START_FAILURE_UNSUPPORTED_CONFIGURATION}\n     * {@link #SAP_START_FAILURE_USER_REJECTED}\n     *\n     * @hide\n     ",
    "links" : [ "#SAP_START_FAILURE_GENERAL", "#WIFI_AP_STATE_FAILED", "#EXTRA_WIFI_AP_STATE", "#SAP_START_FAILURE_NO_CHANNEL", "android.content.Intent#getIntExtra", "#WIFI_AP_STATE_CHANGED_ACTION", "#SAP_START_FAILURE_UNSUPPORTED_CONFIGURATION", "#SAP_START_FAILURE_USER_REJECTED" ]
  }, {
    "name" : "EXTRA_PREVIOUS_WIFI_AP_STATE",
    "type" : "String",
    "comment" : "\n     * The previous Wi-Fi state.\n     *\n     * @see #EXTRA_WIFI_AP_STATE\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_WIFI_AP_INTERFACE_NAME",
    "type" : "String",
    "comment" : "\n     * The lookup key for a String extra that stores the interface name used for the Soft AP.\n     * This extra is included in the broadcast {@link #WIFI_AP_STATE_CHANGED_ACTION}.\n     * Retrieve its value with {@link android.content.Intent#getStringExtra(String)}.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Intent#getStringExtra(String)", "#WIFI_AP_STATE_CHANGED_ACTION" ]
  }, {
    "name" : "EXTRA_WIFI_AP_MODE",
    "type" : "String",
    "comment" : "\n     * The lookup key for an int extra that stores the intended IP mode for this Soft AP.\n     * One of {@link #IFACE_IP_MODE_TETHERED} or {@link #IFACE_IP_MODE_LOCAL_ONLY}.\n     * This extra is included in the broadcast {@link #WIFI_AP_STATE_CHANGED_ACTION}.\n     * Retrieve its value with {@link android.content.Intent#getIntExtra(String, int)}.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.Intent#getIntExtra(String", "#IFACE_IP_MODE_TETHERED", "#WIFI_AP_STATE_CHANGED_ACTION", "#IFACE_IP_MODE_LOCAL_ONLY" ]
  }, {
    "name" : "WIFI_AP_STATE_DISABLING",
    "type" : "int",
    "comment" : "\n     * Wi-Fi AP is currently being disabled. The state will change to\n     * {@link #WIFI_AP_STATE_DISABLED} if it finishes successfully.\n     *\n     * @see #WIFI_AP_STATE_CHANGED_ACTION\n     * @see #getWifiApState()\n     *\n     * @hide\n     ",
    "links" : [ "#WIFI_AP_STATE_DISABLED" ]
  }, {
    "name" : "WIFI_AP_STATE_DISABLED",
    "type" : "int",
    "comment" : "\n     * Wi-Fi AP is disabled.\n     *\n     * @see #WIFI_AP_STATE_CHANGED_ACTION\n     * @see #getWifiState()\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_AP_STATE_ENABLING",
    "type" : "int",
    "comment" : "\n     * Wi-Fi AP is currently being enabled. The state will change to\n     * {@link #WIFI_AP_STATE_ENABLED} if it finishes successfully.\n     *\n     * @see #WIFI_AP_STATE_CHANGED_ACTION\n     * @see #getWifiApState()\n     *\n     * @hide\n     ",
    "links" : [ "#WIFI_AP_STATE_ENABLED" ]
  }, {
    "name" : "WIFI_AP_STATE_ENABLED",
    "type" : "int",
    "comment" : "\n     * Wi-Fi AP is enabled.\n     *\n     * @see #WIFI_AP_STATE_CHANGED_ACTION\n     * @see #getWifiApState()\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_AP_STATE_FAILED",
    "type" : "int",
    "comment" : "\n     * Wi-Fi AP is in a failed state. This state will occur when an error occurs during\n     * enabling or disabling\n     *\n     * @see #WIFI_AP_STATE_CHANGED_ACTION\n     * @see #getWifiApState()\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SAP_START_FAILURE_GENERAL",
    "type" : "int",
    "comment" : "\n     *  All other reasons for AP start failure besides {@link #SAP_START_FAILURE_NO_CHANNEL},\n     *  {@link #SAP_START_FAILURE_UNSUPPORTED_CONFIGURATION}, and\n     *  {@link #SAP_START_FAILURE_USER_REJECTED}.\n     *\n     *  @hide\n     ",
    "links" : [ "#SAP_START_FAILURE_NO_CHANNEL", "#SAP_START_FAILURE_UNSUPPORTED_CONFIGURATION", "#SAP_START_FAILURE_USER_REJECTED" ]
  }, {
    "name" : "SAP_START_FAILURE_NO_CHANNEL",
    "type" : "int",
    "comment" : "\n     *  If Wi-Fi AP start failed, this reason code means that no legal channel exists on user\n     *  selected band due to regulatory constraints.\n     *\n     *  @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SAP_START_FAILURE_UNSUPPORTED_CONFIGURATION",
    "type" : "int",
    "comment" : "\n     *  If Wi-Fi AP start failed, this reason code means that the specified configuration\n     *  is not supported by the current HAL version.\n     *\n     *  @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SAP_START_FAILURE_USER_REJECTED",
    "type" : "int",
    "comment" : "\n     *  If Wi-Fi AP start failed, this reason code means that the user was asked for confirmation to\n     *  create the AP and the user declined.\n     *\n     *  @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SAP_CLIENT_BLOCK_REASON_CODE_BLOCKED_BY_USER",
    "type" : "int",
    "comment" : "\n     *  If Soft Ap client is blocked, this reason code means that client doesn't exist in the\n     *  specified configuration {@link SoftApConfiguration.Builder#setBlockedClientList(List)}\n     *  and {@link SoftApConfiguration.Builder#setAllowedClientList(List)}\n     *  and the {@link SoftApConfiguration.Builder#setClientControlByUserEnabled(boolean)}\n     *  is configured as well.\n     *  @hide\n     ",
    "links" : [ "SoftApConfiguration.Builder#setAllowedClientList(List)", "SoftApConfiguration.Builder#setClientControlByUserEnabled(boolean)", "SoftApConfiguration.Builder#setBlockedClientList(List)" ]
  }, {
    "name" : "SAP_CLIENT_BLOCK_REASON_CODE_NO_MORE_STAS",
    "type" : "int",
    "comment" : "\n     *  If Soft Ap client is blocked, this reason code means that no more clients can be\n     *  associated to this AP since it reached maximum capacity. The maximum capacity is\n     *  the minimum of {@link SoftApConfiguration.Builder#setMaxNumberOfClients(int)} and\n     *  {@link SoftApCapability#getMaxSupportedClients} which get from\n     *  {@link WifiManager.SoftApCallback#onCapabilityChanged(SoftApCapability)}.\n     *\n     *  @hide\n     ",
    "links" : [ "android.net.wifi.SoftApCapability#getMaxSupportedClients", "SoftApConfiguration.Builder#setMaxNumberOfClients(int)", "WifiManager.SoftApCallback#onCapabilityChanged(SoftApCapability)" ]
  }, {
    "name" : "SAP_CLIENT_DISCONNECT_REASON_CODE_UNSPECIFIED",
    "type" : "int",
    "comment" : "\n     * Client disconnected for unspecified reason. This could for example be because the AP is being\n     * shut down.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "IFACE_IP_MODE_UNSPECIFIED",
    "type" : "int",
    "comment" : "\n     * Interface IP mode unspecified.\n     *\n     * @see #updateInterfaceIpState(String, int)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "IFACE_IP_MODE_CONFIGURATION_ERROR",
    "type" : "int",
    "comment" : "\n     * Interface IP mode for configuration error.\n     *\n     * @see #updateInterfaceIpState(String, int)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "IFACE_IP_MODE_TETHERED",
    "type" : "int",
    "comment" : "\n     * Interface IP mode for tethering.\n     *\n     * @see #updateInterfaceIpState(String, int)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "IFACE_IP_MODE_LOCAL_ONLY",
    "type" : "int",
    "comment" : "\n     * Interface IP mode for Local Only Hotspot.\n     *\n     * @see #updateInterfaceIpState(String, int)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_NETWORK_SETTINGS_RESET",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that the wifi network settings\n     * had been reset.\n     *\n     * Note: This intent is sent as a directed broadcast to each manifest registered receiver.\n     * Intent will not be received by dynamically registered receivers.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_REFRESH_USER_PROVISIONING",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that the wifi network profiles provisioned\n     * may need refresh.\n     *\n     * Note: This intent is sent as a directed broadcast to each manifest registered receiver;\n     * And restricted to those apps which have the NETWORK_CARRIER_PROVISIONING permission.\n     * Intent will not be received by dynamically registered receivers.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SUPPLICANT_CONNECTION_CHANGE_ACTION",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that a connection to the supplicant has\n     * been established (and it is now possible\n     * to perform Wi-Fi operations) or the connection to the supplicant has been\n     * lost. One extra provides the connection state as a boolean, where {@code true}\n     * means CONNECTED.\n     * @deprecated This is no longer supported.\n     * @see #EXTRA_SUPPLICANT_CONNECTED\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_SUPPLICANT_CONNECTED",
    "type" : "String",
    "comment" : "\n     * The lookup key for a boolean that indicates whether a connection to\n     * the supplicant daemon has been gained or lost. {@code true} means\n     * a connection now exists.\n     * Retrieve it with {@link android.content.Intent#getBooleanExtra(String,boolean)}.\n     * @deprecated This is no longer supported.\n     ",
    "links" : [ "android.content.Intent#getBooleanExtra(String" ]
  }, {
    "name" : "NETWORK_STATE_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that the state of Wi-Fi connectivity\n     * has changed. An extra provides the new state\n     * in the form of a {@link android.net.NetworkInfo} object.  No network-related\n     * permissions are required to subscribe to this broadcast.\n     *\n     * <p class=\"note\">This broadcast is not delivered to manifest receivers in\n     * applications that target API version 26 or later.\n     * @see #EXTRA_NETWORK_INFO\n     ",
    "links" : [ "android.net.NetworkInfo" ]
  }, {
    "name" : "EXTRA_NETWORK_INFO",
    "type" : "String",
    "comment" : "\n     * The lookup key for a {@link android.net.NetworkInfo} object associated with the\n     * Wi-Fi network. Retrieve with\n     * {@link android.content.Intent#getParcelableExtra(String)}.\n     ",
    "links" : [ "android.net.NetworkInfo", "android.content.Intent#getParcelableExtra(String)" ]
  }, {
    "name" : "EXTRA_BSSID",
    "type" : "String",
    "comment" : "\n     * The lookup key for a String giving the BSSID of the access point to which\n     * we are connected. No longer used.\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_WIFI_INFO",
    "type" : "String",
    "comment" : "\n     * The lookup key for a {@link android.net.wifi.WifiInfo} object giving the\n     * information about the access point to which we are connected.\n     * No longer used.\n     ",
    "links" : [ "android.net.wifi.WifiInfo" ]
  }, {
    "name" : "SUPPLICANT_STATE_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that the state of establishing a connection to\n     * an access point has changed.One extra provides the new\n     * {@link SupplicantState}. Note that the supplicant state is Wi-Fi specific, and\n     * is not generally the most useful thing to look at if you are just interested in\n     * the overall state of connectivity.\n     * @see #EXTRA_NEW_STATE\n     * @see #EXTRA_SUPPLICANT_ERROR\n     * @deprecated This is no longer supported.\n     ",
    "links" : [ "android.net.wifi.SupplicantState" ]
  }, {
    "name" : "EXTRA_NEW_STATE",
    "type" : "String",
    "comment" : "\n     * The lookup key for a {@link SupplicantState} describing the new state\n     * Retrieve with\n     * {@link android.content.Intent#getParcelableExtra(String)}.\n     * @deprecated This is no longer supported.\n     ",
    "links" : [ "android.net.wifi.SupplicantState", "android.content.Intent#getParcelableExtra(String)" ]
  }, {
    "name" : "EXTRA_SUPPLICANT_ERROR",
    "type" : "String",
    "comment" : "\n     * The lookup key for a {@link SupplicantState} describing the supplicant\n     * error code if any\n     * Retrieve with\n     * {@link android.content.Intent#getIntExtra(String, int)}.\n     * @see #ERROR_AUTHENTICATING\n     * @deprecated This is no longer supported.\n     ",
    "links" : [ "android.content.Intent#getIntExtra(String", "android.net.wifi.SupplicantState" ]
  }, {
    "name" : "EXTRA_SUPPLICANT_ERROR_REASON",
    "type" : "String",
    "comment" : "\n     * The lookup key for a {@link SupplicantState} describing the supplicant\n     * error reason if any\n     * Retrieve with\n     * {@link android.content.Intent#getIntExtra(String, int)}.\n     * @see #ERROR_AUTH_FAILURE_#REASON_CODE\n     * @deprecated This is no longer supported.\n     * @hide\n     ",
    "links" : [ "android.content.Intent#getIntExtra(String", "android.net.wifi.SupplicantState" ]
  }, {
    "name" : "CONFIGURED_NETWORKS_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that the configured networks changed.\n     * This can be as a result of adding/updating/deleting a network.\n     * <br />\n     * {@link #EXTRA_CHANGE_REASON} contains whether the configuration was added/changed/removed.\n     * {@link #EXTRA_WIFI_CONFIGURATION} is never set beginning in\n     * {@link android.os.Build.VERSION_CODES#R}.\n     * {@link #EXTRA_MULTIPLE_NETWORKS_CHANGED} is set for backwards compatibility reasons, but\n     * its value is always true beginning in {@link android.os.Build.VERSION_CODES#R}, even if only\n     * a single network changed.\n     * <br />\n     * The {@link android.Manifest.permission#ACCESS_WIFI_STATE ACCESS_WIFI_STATE} permission is\n     * required to receive this broadcast.\n     *\n     * @hide\n     ",
    "links" : [ "#EXTRA_CHANGE_REASON", "android.os.Build.VERSION_CODES#R", "#EXTRA_WIFI_CONFIGURATION", "#EXTRA_MULTIPLE_NETWORKS_CHANGED", "android.Manifest.permission#ACCESS_WIFI_STATE" ]
  }, {
    "name" : "EXTRA_WIFI_CONFIGURATION",
    "type" : "String",
    "comment" : "\n     * The lookup key for a {@link android.net.wifi.WifiConfiguration} object representing\n     * the changed Wi-Fi configuration when the {@link #CONFIGURED_NETWORKS_CHANGED_ACTION}\n     * broadcast is sent.\n     * @deprecated This extra is never set beginning in {@link android.os.Build.VERSION_CODES#R},\n     * regardless of the target SDK version. Use {@link #getConfiguredNetworks} to get the full list\n     * of configured networks.\n     * @hide\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#R", "#getConfiguredNetworks", "#CONFIGURED_NETWORKS_CHANGED_ACTION", "android.net.wifi.WifiConfiguration" ]
  }, {
    "name" : "EXTRA_MULTIPLE_NETWORKS_CHANGED",
    "type" : "String",
    "comment" : "\n     * Multiple network configurations have changed.\n     * @see #CONFIGURED_NETWORKS_CHANGED_ACTION\n     * @deprecated This extra's value is always true beginning in\n     * {@link android.os.Build.VERSION_CODES#R}, regardless of the target SDK version.\n     * @hide\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#R" ]
  }, {
    "name" : "EXTRA_CHANGE_REASON",
    "type" : "String",
    "comment" : "\n     * The lookup key for an integer indicating the reason a Wi-Fi network configuration\n     * has changed. One of {@link #CHANGE_REASON_ADDED}, {@link #CHANGE_REASON_REMOVED},\n     * {@link #CHANGE_REASON_CONFIG_CHANGE}.\n     *\n     * @see #CONFIGURED_NETWORKS_CHANGED_ACTION\n     * @hide\n     ",
    "links" : [ "#CHANGE_REASON_REMOVED", "#CHANGE_REASON_ADDED", "#CHANGE_REASON_CONFIG_CHANGE" ]
  }, {
    "name" : "CHANGE_REASON_ADDED",
    "type" : "int",
    "comment" : "\n     * The configuration is new and was added.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CHANGE_REASON_REMOVED",
    "type" : "int",
    "comment" : "\n     * The configuration was removed and is no longer present in the system's list of\n     * configured networks.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CHANGE_REASON_CONFIG_CHANGE",
    "type" : "int",
    "comment" : "\n     * The configuration has changed as a result of explicit action or because the system\n     * took an automated action such as disabling a malfunctioning configuration.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SCAN_RESULTS_AVAILABLE_ACTION",
    "type" : "String",
    "comment" : "\n     * An access point scan has completed, and results are available.\n     * Call {@link #getScanResults()} to obtain the results.\n     * The broadcast intent may contain an extra field with the key {@link #EXTRA_RESULTS_UPDATED}\n     * and a {@code boolean} value indicating if the scan was successful.\n     ",
    "links" : [ "#EXTRA_RESULTS_UPDATED", "#getScanResults()" ]
  }, {
    "name" : "EXTRA_RESULTS_UPDATED",
    "type" : "String",
    "comment" : "\n     * Lookup key for a {@code boolean} extra in intent {@link #SCAN_RESULTS_AVAILABLE_ACTION}\n     * representing if the scan was successful or not.\n     * Scans may fail for multiple reasons, these may include:\n     * <ol>\n     * <li>An app requested too many scans in a certain period of time.\n     * This may lead to additional scan request rejections via \"scan throttling\" for both\n     * foreground and background apps.\n     * Note: Apps holding android.Manifest.permission.NETWORK_SETTINGS permission are\n     * exempted from scan throttling.\n     * </li>\n     * <li>The device is idle and scanning is disabled.</li>\n     * <li>Wifi hardware reported a scan failure.</li>\n     * </ol>\n     * @return true scan was successful, results are updated\n     * @return false scan was not successful, results haven't been updated since previous scan\n     ",
    "links" : [ "#SCAN_RESULTS_AVAILABLE_ACTION" ]
  }, {
    "name" : "BATCHED_SCAN_RESULTS_AVAILABLE_ACTION",
    "type" : "String",
    "comment" : "\n     * A batch of access point scans has been completed and the results areavailable.\n     * Call {@link #getBatchedScanResults()} to obtain the results.\n     * @deprecated This API is nolonger supported.\n     * Use {@link WifiScanner} API\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiScanner", "#getBatchedScanResults()" ]
  }, {
    "name" : "RSSI_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * The RSSI (signal strength) has changed.\n     *\n     * Receiver Required Permission: android.Manifest.permission.ACCESS_WIFI_STATE\n     * @see #EXTRA_NEW_RSSI\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_NEW_RSSI",
    "type" : "String",
    "comment" : "\n     * The lookup key for an {@code int} giving the new RSSI in dBm.\n     ",
    "links" : [ ]
  }, {
    "name" : "LINK_CONFIGURATION_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * @see #ACTION_LINK_CONFIGURATION_CHANGED\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_LINK_CONFIGURATION_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast intent action indicating that the link configuration changed on wifi.\n     * <br /> No permissions are required to listen to this broadcast.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_LINK_PROPERTIES",
    "type" : "String",
    "comment" : "\n     * The lookup key for a {@link android.net.LinkProperties} object associated with the\n     * Wi-Fi network.\n     * Included in the {@link #ACTION_LINK_CONFIGURATION_CHANGED} broadcast.\n     *\n     * Retrieve with {@link android.content.Intent#getParcelableExtra(String)}.\n     *\n     * @deprecated this extra is no longer populated.\n     *\n     * @hide\n     ",
    "links" : [ "#ACTION_LINK_CONFIGURATION_CHANGED", "android.net.LinkProperties", "android.content.Intent#getParcelableExtra(String)" ]
  }, {
    "name" : "EXTRA_NETWORK_CAPABILITIES",
    "type" : "String",
    "comment" : "\n     * The lookup key for a {@link android.net.NetworkCapabilities} object associated with the\n     * Wi-Fi network. Retrieve with\n     * {@link android.content.Intent#getParcelableExtra(String)}.\n     * @hide\n     ",
    "links" : [ "android.net.NetworkCapabilities", "android.content.Intent#getParcelableExtra(String)" ]
  }, {
    "name" : "NETWORK_IDS_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * The network IDs of the configured networks could have changed.\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_REQUEST_SCAN_ALWAYS_AVAILABLE",
    "type" : "String",
    "comment" : "\n     * Activity Action: Show a system activity that allows the user to enable\n     * scans to be available even with Wi-Fi turned off.\n     *\n     * <p>Notification of the result of this activity is posted using the\n     * {@link android.app.Activity#onActivityResult} callback. The\n     * <code>resultCode</code>\n     * will be {@link android.app.Activity#RESULT_OK} if scan always mode has\n     * been turned on or {@link android.app.Activity#RESULT_CANCELED} if the user\n     * has rejected the request or an error has occurred.\n     ",
    "links" : [ "android.app.Activity#RESULT_CANCELED", "android.app.Activity#RESULT_OK", "android.app.Activity#onActivityResult" ]
  }, {
    "name" : "ACTION_PICK_WIFI_NETWORK",
    "type" : "String",
    "comment" : "\n     * Activity Action: Pick a Wi-Fi network to connect to.\n     * <p>Input: Nothing.\n     * <p>Output: Nothing.\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_REQUEST_ENABLE",
    "type" : "String",
    "comment" : "\n     * Activity Action: Receiver should show UI to get user approval to enable WiFi.\n     * <p>Input: {@link android.content.Intent#EXTRA_PACKAGE_NAME} string extra with\n     *           the name of the app requesting the action.\n     * <p>Output: Nothing.\n     * <p>No permissions are required to send this action.\n     * @hide\n     ",
    "links" : [ "android.content.Intent#EXTRA_PACKAGE_NAME" ]
  }, {
    "name" : "ACTION_REQUEST_DISABLE",
    "type" : "String",
    "comment" : "\n     * Activity Action: Receiver should show UI to get user approval to disable WiFi.\n     * <p>Input: {@link android.content.Intent#EXTRA_PACKAGE_NAME} string extra with\n     *           the name of the app requesting the action.\n     * <p>Output: Nothing.\n     * <p>No permissions are required to send this action.\n     * @hide\n     ",
    "links" : [ "android.content.Intent#EXTRA_PACKAGE_NAME" ]
  }, {
    "name" : "ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION",
    "type" : "String",
    "comment" : "\n     * Directed broadcast intent action indicating that the device has connected to one of the\n     * network suggestions provided by the app. This will be sent post connection to a network\n     * which was created with {@link WifiNetworkSuggestion.Builder#setIsAppInteractionRequired(\n     * boolean)}\n     * flag set.\n     * <p>\n     * Note: The broadcast is sent to the app only if it holds\n     * {@link android.Manifest.permission#ACCESS_FINE_LOCATION ACCESS_FINE_LOCATION} permission.\n     *\n     * @see #EXTRA_NETWORK_SUGGESTION\n     ",
    "links" : [ "android.Manifest.permission#ACCESS_FINE_LOCATION", "WifiNetworkSuggestion.Builder#setIsAppInteractionRequired(" ]
  }, {
    "name" : "EXTRA_NETWORK_SUGGESTION",
    "type" : "String",
    "comment" : "\n     * Sent as as a part of {@link #ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION} that holds\n     * an instance of {@link WifiNetworkSuggestion} corresponding to the connected network.\n     ",
    "links" : [ "#ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION", "android.net.wifi.WifiNetworkSuggestion" ]
  }, {
    "name" : "WIFI_MODE_NO_LOCKS_HELD",
    "type" : "int",
    "comment" : "\n     * Internally used Wi-Fi lock mode representing the case were no locks are held.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_MODE_FULL",
    "type" : "int",
    "comment" : "\n     * In this Wi-Fi lock mode, Wi-Fi will be kept active,\n     * and will behave normally, i.e., it will attempt to automatically\n     * establish a connection to a remembered access point that is\n     * within range, and will do periodic scans if there are remembered\n     * access points but none are in range.\n     *\n     * @deprecated This API is non-functional and will have no impact.\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_MODE_SCAN_ONLY",
    "type" : "int",
    "comment" : "\n     * In this Wi-Fi lock mode, Wi-Fi will be kept active,\n     * but the only operation that will be supported is initiation of\n     * scans, and the subsequent reporting of scan results. No attempts\n     * will be made to automatically connect to remembered access points,\n     * nor will periodic scans be automatically performed looking for\n     * remembered access points. Scans must be explicitly requested by\n     * an application in this mode.\n     *\n     * @deprecated This API is non-functional and will have no impact.\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_MODE_FULL_HIGH_PERF",
    "type" : "int",
    "comment" : "\n     * In this Wi-Fi lock mode, Wi-Fi will not go to power save.\n     * This results in operating with low packet latency.\n     * The lock is only active when the device is connected to an access point.\n     * The lock is active even when the device screen is off or the acquiring application is\n     * running in the background.\n     * This mode will consume more power and hence should be used only\n     * when there is a need for this tradeoff.\n     * <p>\n     * An example use case is when a voice connection needs to be\n     * kept active even after the device screen goes off.\n     * Holding a {@link #WIFI_MODE_FULL_HIGH_PERF} lock for the\n     * duration of the voice call may improve the call quality.\n     * <p>\n     * When there is no support from the hardware, the {@link #WIFI_MODE_FULL_HIGH_PERF}\n     * lock will have no impact.\n     *\n     * @deprecated The {@code WIFI_MODE_FULL_HIGH_PERF} is deprecated and is automatically replaced\n     * with {@link #WIFI_MODE_FULL_LOW_LATENCY} with all the restrictions documented on that lock.\n     * I.e. any request to the {@code WIFI_MODE_FULL_HIGH_PERF} will now obtain a\n     * {@link #WIFI_MODE_FULL_LOW_LATENCY} lock instead.\n     * Deprecation is due to the impact of {@code WIFI_MODE_FULL_HIGH_PERF} on power dissipation.\n     * The {@link #WIFI_MODE_FULL_LOW_LATENCY} provides much of the same desired functionality with\n     * less impact on power dissipation.\n     ",
    "links" : [ "#WIFI_MODE_FULL_HIGH_PERF", "#WIFI_MODE_FULL_LOW_LATENCY" ]
  }, {
    "name" : "WIFI_MODE_FULL_LOW_LATENCY",
    "type" : "int",
    "comment" : "\n     * In this Wi-Fi lock mode, Wi-Fi will operate with a priority to achieve low latency.\n     * {@link #WIFI_MODE_FULL_LOW_LATENCY} lock has the following limitations:\n     * <ol>\n     * <li>The lock is only active when the device is connected to an access point.</li>\n     * <li>The lock is only active when the screen is on.</li>\n     * <li>The lock is only active when the acquiring app is running in the foreground.</li>\n     * </ol>\n     * Low latency mode optimizes for reduced packet latency,\n     * and as a result other performance measures may suffer when there are trade-offs to make:\n     * <ol>\n     * <li>Battery life may be reduced.</li>\n     * <li>Throughput may be reduced.</li>\n     * <li>Frequency of Wi-Fi scanning may be reduced. This may result in: </li>\n     * <ul>\n     * <li>The device may not roam or switch to the AP with highest signal quality.</li>\n     * <li>Location accuracy may be reduced.</li>\n     * </ul>\n     * </ol>\n     * <p>\n     * Example use cases are real time gaming or virtual reality applications where\n     * low latency is a key factor for user experience.\n     * <p>\n     * Note: For an app which acquires both {@link #WIFI_MODE_FULL_LOW_LATENCY} and\n     * {@link #WIFI_MODE_FULL_HIGH_PERF} locks, {@link #WIFI_MODE_FULL_LOW_LATENCY}\n     * lock will be effective when app is running in foreground and screen is on,\n     * while the {@link #WIFI_MODE_FULL_HIGH_PERF} lock will take effect otherwise.\n     ",
    "links" : [ "#WIFI_MODE_FULL_HIGH_PERF", "#WIFI_MODE_FULL_LOW_LATENCY" ]
  }, {
    "name" : "MIN_RSSI",
    "type" : "int",
    "comment" : " Anything worse than or equal to this will show 0 bars. ",
    "links" : [ ]
  }, {
    "name" : "MAX_RSSI",
    "type" : "int",
    "comment" : " Anything better than or equal to this will show the max bars. ",
    "links" : [ ]
  }, {
    "name" : "RSSI_LEVELS",
    "type" : "int",
    "comment" : "\n     * Number of RSSI levels used in the framework to initiate {@link #RSSI_CHANGED_ACTION}\n     * broadcast, where each level corresponds to a range of RSSI values.\n     * The {@link #RSSI_CHANGED_ACTION} broadcast will only fire if the RSSI\n     * change is significant enough to change the RSSI signal level.\n     * @hide\n     ",
    "links" : [ "#RSSI_CHANGED_ACTION" ]
  }, {
    "name" : "WIFI_FREQUENCY_BAND_AUTO",
    "type" : "int",
    "comment" : "\n     * Auto settings in the driver. The driver could choose to operate on both\n     * 2.4 GHz and 5 GHz or make a dynamic decision on selecting the band.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_FREQUENCY_BAND_5GHZ",
    "type" : "int",
    "comment" : "\n     * Operation on 5 GHz alone\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_FREQUENCY_BAND_2GHZ",
    "type" : "int",
    "comment" : "\n     * Operation on 2.4 GHz alone\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_POOR_NETWORK_AVOIDANCE_ENABLED",
    "type" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MAX_ACTIVE_LOCKS",
    "type" : "int",
    "comment" : "\n     * Maximum number of active locks we allow.\n     * This limit was added to prevent apps from creating a ridiculous number\n     * of locks and crashing the system by overflowing the global ref table.\n     ",
    "links" : [ ]
  }, {
    "name" : "UNKNOWN_SSID",
    "type" : "String",
    "comment" : " Indicates an invalid SSID. ",
    "links" : [ ]
  }, {
    "name" : "ALL_ZEROS_MAC_ADDRESS",
    "type" : "MacAddress",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "WIFI_MULTI_INTERNET_MODE_DISABLED",
    "type" : "int",
    "comment" : "\n     * Wi-Fi simultaneous connection to multiple internet-providing Wi-Fi networks (APs) is\n     * disabled.\n     *\n     * @see #getStaConcurrencyForMultiInternetMode()\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_MULTI_INTERNET_MODE_DBS_AP",
    "type" : "int",
    "comment" : "\n     * Wi-Fi simultaneous connection to multiple internet-providing Wi-FI networks (APs) is enabled\n     * and restricted to a single network on different bands (e.g. a DBS AP).\n     *\n     * @see #getStaConcurrencyForMultiInternetMode()\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_MULTI_INTERNET_MODE_MULTI_AP",
    "type" : "int",
    "comment" : "\n     * Wi-Fi simultaneous connection to multiple internet-providing Wi-Fi networks (APs) is enabled.\n     * The device can connect to any networks/APs - it is just restricted to using different bands\n     * for individual connections.\n     *\n     * @see #getStaConcurrencyForMultiInternetMode()\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "CHANNEL_DATA_KEY_FREQUENCY_MHZ",
    "type" : "String",
    "comment" : "\n     * The bundle key string for the channel frequency in MHz.\n     * See {@link #getChannelData(Executor, Consumer)}\n     ",
    "links" : [ "#getChannelData(Executor" ]
  }, {
    "name" : "CHANNEL_DATA_KEY_NUM_AP",
    "type" : "String",
    "comment" : "\n     * The bundle key for the number of APs found on the corresponding channel specified by\n     * {@link WifiManager#CHANNEL_DATA_KEY_FREQUENCY_MHZ}.\n     * See {@link #getChannelData(Executor, Consumer)}\n     ",
    "links" : [ "android.net.wifi.WifiManager#CHANNEL_DATA_KEY_FREQUENCY_MHZ", "#getChannelData(Executor" ]
  }, {
    "name" : "QOS_REQUEST_STATUS_TRACKING",
    "type" : "int",
    "comment" : "\n     * This policy is being tracked by the Wifi service.\n     * Indicates success for {@link #addQosPolicies(List, Executor, Consumer)}.\n     * @hide\n     ",
    "links" : [ "#addQosPolicies(List" ]
  }, {
    "name" : "QOS_REQUEST_STATUS_ALREADY_ACTIVE",
    "type" : "int",
    "comment" : "\n     * A policy with the same policy ID is already being tracked.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "QOS_REQUEST_STATUS_INSUFFICIENT_RESOURCES",
    "type" : "int",
    "comment" : "\n     * There are insufficient resources to handle this request at this time.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "QOS_REQUEST_STATUS_INVALID_PARAMETERS",
    "type" : "int",
    "comment" : "\n     * The parameters in the policy request are invalid.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "QOS_REQUEST_STATUS_FAILURE_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * An unspecified failure occurred while processing this request.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "MAX_POLICIES_PER_QOS_REQUEST",
    "type" : "int",
    "comment" : "\n     * Maximum number of policies that can be included in a QoS add/remove request.\n     ",
    "links" : [ ]
  }, {
    "name" : "mActiveLockCount",
    "type" : "int",
    "comment" : " Number of currently active WifiLocks and MulticastLocks ",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mService",
    "type" : "IWifiManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTargetSdkVersion",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLooper",
    "type" : "Looper",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mVerboseLoggingEnabled",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLock",
    "type" : "Object",
    "comment" : " lock guarding access to the following vars",
    "links" : [ ]
  }, {
    "name" : "mLOHSCallbackProxy",
    "type" : "LocalOnlyHotspotCallbackProxy",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLOHSObserverProxy",
    "type" : "LocalOnlyHotspotObserverProxy",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sOnWifiUsabilityStatsListenerMap",
    "type" : "SparseArray<IOnWifiUsabilityStatsListener>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sSuggestionConnectionStatusListenerMap",
    "type" : "SparseArray<ISuggestionConnectionStatusListener>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sSuggestionUserApprovalStatusListenerMap",
    "type" : "SparseArray<ISuggestionUserApprovalStatusListener>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sWifiVerboseLoggingStatusChangedListenerMap",
    "type" : "SparseArray<IWifiVerboseLoggingStatusChangedListener>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sNetworkRequestMatchCallbackMap",
    "type" : "SparseArray<INetworkRequestMatchCallback>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sTrafficStateCallbackMap",
    "type" : "SparseArray<ITrafficStateCallback>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sSoftApCallbackMap",
    "type" : "SparseArray<ISoftApCallback>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sActiveCountryCodeChangedCallbackMap",
    "type" : "SparseArray<IOnWifiDriverCountryCodeChangedListener>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sLocalOnlyHotspotSoftApCallbackMap",
    "type" : "SparseArray<ISoftApCallback>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sLocalOnlyConnectionStatusListenerMap",
    "type" : "SparseArray<ILocalOnlyConnectionStatusListener>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sOnWifiNetworkStateChangedListenerMap",
    "type" : "SparseArray<IWifiNetworkStateChangedListener>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sWifiLowLatencyLockListenerMap",
    "type" : "SparseArray<IWifiLowLatencyLockListener>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MLO_MODE_DEFAULT",
    "type" : "int",
    "comment" : "\n     * Multi-link operation (MLO) will allow Wi-Fi devices to operate on multiple links at the same\n     * time through a single connection, aiming to support applications that require lower latency,\n     * and higher capacity. Chip vendors have algorithms that run on the chip to use available links\n     * based on incoming traffic and various inputs. Below is a list of Multi-Link Operation modes\n     * that applications can suggest to be accommodated in the algorithm.\n     *\n     * The default MLO mode is for chip vendors to use algorithms to select the optimum links to\n     * operate on, without any guidance from the calling app.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "MLO_MODE_LOW_LATENCY",
    "type" : "int",
    "comment" : "\n     * Low latency mode for Multi-link operation. In this mode, the chip vendor's algorithm\n     * should select MLO links that will achieve low latency.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "MLO_MODE_HIGH_THROUGHPUT",
    "type" : "int",
    "comment" : "\n     * High throughput mode for Multi-link operation. In this mode, the chip vendor's algorithm\n     * should select MLO links that will achieve higher throughput.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "MLO_MODE_LOW_POWER",
    "type" : "int",
    "comment" : "\n     * Low power mode for Multi-link operation. In this mode, the chip vendor's algorithm\n     * should select MLO links that will achieve low power.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ROAMING_MODE_NONE",
    "type" : "int",
    "comment" : "\n     * Roaming is disabled.\n     ",
    "links" : [ ]
  }, {
    "name" : "ROAMING_MODE_NORMAL",
    "type" : "int",
    "comment" : "\n     * Chipset has roaming trigger capability based on the score calculated\n     * using multiple parameters. If device is configured to this mode then it\n     * will be using chipset's normal (default) roaming.\n     ",
    "links" : [ ]
  }, {
    "name" : "ROAMING_MODE_AGGRESSIVE",
    "type" : "int",
    "comment" : "\n     * Allows the device to roam more quickly than the normal roaming mode.\n     * Used in cases such as where APs are installed in a high density.\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_INFRA",
    "type" : "long",
    "comment" : " Basic infrastructure mode",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_PASSPOINT",
    "type" : "long",
    "comment" : " Support for GAS/ANQP",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_P2P",
    "type" : "long",
    "comment" : " Wifi-Direct",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_MOBILE_HOTSPOT",
    "type" : "long",
    "comment" : " Soft AP",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_SCANNER",
    "type" : "long",
    "comment" : " WifiScanner APIs",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_AWARE",
    "type" : "long",
    "comment" : " Wi-Fi Aware networking",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_D2D_RTT",
    "type" : "long",
    "comment" : " Device-to-device RTT",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_D2AP_RTT",
    "type" : "long",
    "comment" : " Device-to-AP RTT",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_PNO",
    "type" : "long",
    "comment" : " Preferred network offload",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_TDLS",
    "type" : "long",
    "comment" : " Tunnel directed link setup",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_TDLS_OFFCHANNEL",
    "type" : "long",
    "comment" : " TDLS off channel",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_AP_STA",
    "type" : "long",
    "comment" : " AP STA Concurrency",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_LINK_LAYER_STATS",
    "type" : "long",
    "comment" : " Link layer stats",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_LOGGER",
    "type" : "long",
    "comment" : " WiFi Logger",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_RSSI_MONITOR",
    "type" : "long",
    "comment" : " RSSI Monitor",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_MKEEP_ALIVE",
    "type" : "long",
    "comment" : " mkeep_alive",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_CONFIG_NDO",
    "type" : "long",
    "comment" : " ND offload",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_CONTROL_ROAMING",
    "type" : "long",
    "comment" : " Control firmware roaming",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_IE_WHITELIST",
    "type" : "long",
    "comment" : " Probe IE white listing",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_SCAN_RAND",
    "type" : "long",
    "comment" : " Random MAC & Probe seq",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_TX_POWER_LIMIT",
    "type" : "long",
    "comment" : " Set Tx power limit",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_WPA3_SAE",
    "type" : "long",
    "comment" : " WPA3-Personal SAE",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_WPA3_SUITE_B",
    "type" : "long",
    "comment" : " WPA3-Enterprise Suite-B",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_OWE",
    "type" : "long",
    "comment" : " Enhanced Open",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_LOW_LATENCY",
    "type" : "long",
    "comment" : " Low Latency modes",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_DPP",
    "type" : "long",
    "comment" : " DPP (Easy-Connect)",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_P2P_RAND_MAC",
    "type" : "long",
    "comment" : " Random P2P MAC",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_CONNECTED_RAND_MAC",
    "type" : "long",
    "comment" : " Random STA MAC",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_AP_RAND_MAC",
    "type" : "long",
    "comment" : " Random AP MAC",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_MBO",
    "type" : "long",
    "comment" : " MBO Support",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_OCE",
    "type" : "long",
    "comment" : " OCE Support",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_WAPI",
    "type" : "long",
    "comment" : " WAPI",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_FILS_SHA256",
    "type" : "long",
    "comment" : " FILS-SHA256",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_FILS_SHA384",
    "type" : "long",
    "comment" : " FILS-SHA384",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_SAE_PK",
    "type" : "long",
    "comment" : " SAE-PK",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_STA_BRIDGED_AP",
    "type" : "long",
    "comment" : " STA + Bridged AP",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_BRIDGED_AP",
    "type" : "long",
    "comment" : " Bridged AP",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_INFRA_60G",
    "type" : "long",
    "comment" : " 60 GHz Band Support",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_ADDITIONAL_STA_LOCAL_ONLY",
    "type" : "long",
    "comment" : "\n     * Support for 2 STA's for the local-only (peer to peer) connection + internet connection\n     * concurrency.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_ADDITIONAL_STA_MBB",
    "type" : "long",
    "comment" : "\n     * Support for 2 STA's for the make before break concurrency.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_ADDITIONAL_STA_RESTRICTED",
    "type" : "long",
    "comment" : "\n     * Support for 2 STA's for the restricted connection + internet connection concurrency.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_DPP_ENROLLEE_RESPONDER",
    "type" : "long",
    "comment" : "\n     * DPP (Easy-Connect) Enrollee Responder mode support\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_PASSPOINT_TERMS_AND_CONDITIONS",
    "type" : "long",
    "comment" : "\n     * Passpoint Terms and Conditions feature support\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_SAE_H2E",
    "type" : "long",
    "comment" : " Hash-to-Element",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_WFD_R2",
    "type" : "long",
    "comment" : " Wi-Fi Display R2",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_DECORATED_IDENTITY",
    "type" : "long",
    "comment" : "\n     * RFC 7542 decorated identity support\n     * @hide ",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_TRUST_ON_FIRST_USE",
    "type" : "long",
    "comment" : "\n     * Trust On First Use support for WPA Enterprise network\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_ADDITIONAL_STA_MULTI_INTERNET",
    "type" : "long",
    "comment" : "\n     * Support for 2 STA's multi internet concurrency.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_DPP_AKM",
    "type" : "long",
    "comment" : "\n     * Support for DPP (Easy-Connect) AKM.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_SET_TLS_MINIMUM_VERSION",
    "type" : "long",
    "comment" : "\n     * Support for setting TLS minimum version.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_TLS_V1_3",
    "type" : "long",
    "comment" : "\n     * Support for TLS v.13.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_DUAL_BAND_SIMULTANEOUS",
    "type" : "long",
    "comment" : "\n     * Support for Dual Band Simultaneous (DBS) operation.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_T2LM_NEGOTIATION",
    "type" : "long",
    "comment" : "\n     * Support for TID-To-Link Mapping negotiation.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_WEP",
    "type" : "long",
    "comment" : "\n     * Support for WEP Wi-Fi Network\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_WPA_PERSONAL",
    "type" : "long",
    "comment" : "\n     * Support for WPA PERSONAL Wi-Fi Network\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_AGGRESSIVE_ROAMING_MODE_SUPPORT",
    "type" : "long",
    "comment" : "\n     * Support for Roaming Mode\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_FEATURE_D2D_WHEN_INFRA_STA_DISABLED",
    "type" : "long",
    "comment" : "\n     * Supports device-to-device connections when infra STA is disabled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "COEX_RESTRICTION_WIFI_DIRECT",
    "type" : "int",
    "comment" : "\n     * Mandatory coex restriction flag for Wi-Fi Direct.\n     *\n     * @see #setCoexUnsafeChannels(List, int)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "COEX_RESTRICTION_SOFTAP",
    "type" : "int",
    "comment" : "\n     * Mandatory coex restriction flag for SoftAP\n     *\n     * @see #setCoexUnsafeChannels(List, int)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "COEX_RESTRICTION_WIFI_AWARE",
    "type" : "int",
    "comment" : "\n     * Mandatory coex restriction flag for Wi-Fi Aware.\n     *\n     * @see #setCoexUnsafeChannels(List, int)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WPS_OVERLAP_ERROR",
    "type" : "int",
    "comment" : " WPS overlap detected\n     * @deprecated This is deprecated\n     ",
    "links" : [ ]
  }, {
    "name" : "WPS_WEP_PROHIBITED",
    "type" : "int",
    "comment" : " WEP on WPS is prohibited\n     * @deprecated This is deprecated\n     ",
    "links" : [ ]
  }, {
    "name" : "WPS_TKIP_ONLY_PROHIBITED",
    "type" : "int",
    "comment" : " TKIP only prohibited\n     * @deprecated This is deprecated\n     ",
    "links" : [ ]
  }, {
    "name" : "WPS_AUTH_FAILURE",
    "type" : "int",
    "comment" : " Authentication failure on WPS\n     * @deprecated This is deprecated\n     ",
    "links" : [ ]
  }, {
    "name" : "WPS_TIMED_OUT",
    "type" : "int",
    "comment" : " WPS timed out\n     * @deprecated This is deprecated\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_MOBILITY_STATE_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Unknown device mobility state\n     *\n     * @see #setDeviceMobilityState(int)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_MOBILITY_STATE_HIGH_MVMT",
    "type" : "int",
    "comment" : "\n     * High movement device mobility state.\n     * e.g. on a bike, in a motor vehicle\n     *\n     * @see #setDeviceMobilityState(int)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_MOBILITY_STATE_LOW_MVMT",
    "type" : "int",
    "comment" : "\n     * Low movement device mobility state.\n     * e.g. walking, running\n     *\n     * @see #setDeviceMobilityState(int)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEVICE_MOBILITY_STATE_STATIONARY",
    "type" : "int",
    "comment" : "\n     * Stationary device mobility state\n     *\n     * @see #setDeviceMobilityState(int)\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EASY_CONNECT_NETWORK_ROLE_STA",
    "type" : "int",
    "comment" : "\n     * Easy Connect Network role: Station.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EASY_CONNECT_NETWORK_ROLE_AP",
    "type" : "int",
    "comment" : "\n     * Easy Connect Network role: Access Point.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EASY_CONNECT_DEVICE_INFO_MAXIMUM_LENGTH",
    "type" : "int",
    "comment" : " Easy Connect Device information maximum allowed length ",
    "links" : [ ]
  }, {
    "name" : "EASY_CONNECT_CRYPTOGRAPHY_CURVE_PRIME256V1",
    "type" : "int",
    "comment" : "\n     * Easy Connect Cryptography Curve name: prime256v1\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EASY_CONNECT_CRYPTOGRAPHY_CURVE_SECP384R1",
    "type" : "int",
    "comment" : "\n     * Easy Connect Cryptography Curve name: secp384r1\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EASY_CONNECT_CRYPTOGRAPHY_CURVE_SECP521R1",
    "type" : "int",
    "comment" : "\n     * Easy Connect Cryptography Curve name: secp521r1\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EASY_CONNECT_CRYPTOGRAPHY_CURVE_BRAINPOOLP256R1",
    "type" : "int",
    "comment" : "\n     * Easy Connect Cryptography Curve name: brainpoolP256r1\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EASY_CONNECT_CRYPTOGRAPHY_CURVE_BRAINPOOLP384R1",
    "type" : "int",
    "comment" : "\n     * Easy Connect Cryptography Curve name: brainpoolP384r1\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EASY_CONNECT_CRYPTOGRAPHY_CURVE_BRAINPOOLP512R1",
    "type" : "int",
    "comment" : "\n     * Easy Connect Cryptography Curve name: brainpoolP512r1\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "VERBOSE_LOGGING_LEVEL_DISABLED",
    "type" : "int",
    "comment" : "\n     * Verbose logging mode: DISABLED.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "VERBOSE_LOGGING_LEVEL_ENABLED",
    "type" : "int",
    "comment" : "\n     * Verbose logging mode: ENABLED.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "VERBOSE_LOGGING_LEVEL_ENABLED_SHOW_KEY",
    "type" : "int",
    "comment" : "\n     * Verbose logging mode: ENABLED_SHOW_KEY. This mode causes the Wi-Fi password and encryption\n     * keys to be output to the logcat. This is security sensitive information useful for debugging.\n     * This configuration is enabled for 30 seconds and then falls back to the regular verbose mode\n     * (i.e. to {@link VERBOSE_LOGGING_LEVEL_ENABLED}). Show key mode is not persistent, i.e.\n     * rebooting the device would fallback to the regular verbose mode.\n     *\n     * @hide\n     ",
    "links" : [ "VERBOSE_LOGGING_LEVEL_ENABLED" ]
  }, {
    "name" : "VERBOSE_LOGGING_LEVEL_WIFI_AWARE_ENABLED_ONLY",
    "type" : "int",
    "comment" : "\n     * Verbose logging mode: only enable for Wi-Fi Aware feature.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_LAUNCH_DIALOG",
    "type" : "String",
    "comment" : "\n     * Intent action to launch a dialog from the WifiDialog app.\n     * Must include EXTRA_DIALOG_ID, EXTRA_DIALOG_TYPE, and appropriate extras for the dialog type.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_DISMISS_DIALOG",
    "type" : "String",
    "comment" : "\n     * Intent action to dismiss an existing dialog from the WifiDialog app.\n     * Must include EXTRA_DIALOG_ID.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DIALOG_TYPE_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Unknown DialogType.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DIALOG_TYPE_SIMPLE",
    "type" : "int",
    "comment" : "\n     * DialogType for a simple dialog.\n     * @see {@link com.android.server.wifi.WifiDialogManager#createSimpleDialog}\n     * @hide\n     ",
    "links" : [ "com.android.server.wifi.WifiDialogManager#createSimpleDialog" ]
  }, {
    "name" : "DIALOG_TYPE_P2P_INVITATION_SENT",
    "type" : "int",
    "comment" : "\n     * DialogType for a P2P Invitation Sent dialog.\n     * @see {@link com.android.server.wifi.WifiDialogManager#createP2pInvitationSentDialog}\n     * @hide\n     ",
    "links" : [ "com.android.server.wifi.WifiDialogManager#createP2pInvitationSentDialog" ]
  }, {
    "name" : "DIALOG_TYPE_P2P_INVITATION_RECEIVED",
    "type" : "int",
    "comment" : "\n     * DialogType for a P2P Invitation Received dialog.\n     * @see {@link com.android.server.wifi.WifiDialogManager#createP2pInvitationReceivedDialog}\n     * @hide\n     ",
    "links" : [ "com.android.server.wifi.WifiDialogManager#createP2pInvitationReceivedDialog" ]
  }, {
    "name" : "DIALOG_REPLY_POSITIVE",
    "type" : "int",
    "comment" : "\n     * Dialog positive button was clicked.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DIALOG_REPLY_NEGATIVE",
    "type" : "int",
    "comment" : "\n     * Dialog negative button was clicked.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DIALOG_REPLY_NEUTRAL",
    "type" : "int",
    "comment" : "\n     * Dialog neutral button was clicked.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DIALOG_REPLY_CANCELLED",
    "type" : "int",
    "comment" : "\n     * Dialog was cancelled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "INVALID_DIALOG_ID",
    "type" : "int",
    "comment" : "\n     * Invalid dialog id for dialogs that are not currently active.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_DIALOG_TYPE",
    "type" : "String",
    "comment" : "\n     * Extra int indicating the type of dialog to display.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_DIALOG_ID",
    "type" : "String",
    "comment" : "\n     * Extra int indicating the ID of a dialog. The value must not be {@link #INVALID_DIALOG_ID}.\n     * @hide\n     ",
    "links" : [ "#INVALID_DIALOG_ID" ]
  }, {
    "name" : "EXTRA_DIALOG_TITLE",
    "type" : "String",
    "comment" : "\n     * Extra String indicating the title of a simple dialog.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_DIALOG_MESSAGE",
    "type" : "String",
    "comment" : "\n     * Extra String indicating the message of a simple dialog.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_DIALOG_MESSAGE_URL",
    "type" : "String",
    "comment" : "\n     * Extra String indicating the message URL of a simple dialog.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_DIALOG_MESSAGE_URL_START",
    "type" : "String",
    "comment" : "\n     * Extra String indicating the start index of a message URL span of a simple dialog.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_DIALOG_MESSAGE_URL_END",
    "type" : "String",
    "comment" : "\n     * Extra String indicating the end index of a message URL span of a simple dialog.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_DIALOG_POSITIVE_BUTTON_TEXT",
    "type" : "String",
    "comment" : "\n     * Extra String indicating the positive button text of a simple dialog.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_DIALOG_NEGATIVE_BUTTON_TEXT",
    "type" : "String",
    "comment" : "\n     * Extra String indicating the negative button text of a simple dialog.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_DIALOG_NEUTRAL_BUTTON_TEXT",
    "type" : "String",
    "comment" : "\n     * Extra String indicating the neutral button text of a simple dialog.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_DIALOG_TIMEOUT_MS",
    "type" : "String",
    "comment" : "\n     * Extra long indicating the timeout in milliseconds of a dialog.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_P2P_DEVICE_NAME",
    "type" : "String",
    "comment" : "\n     * Extra String indicating a P2P device name for a P2P Invitation Sent/Received dialog.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_P2P_PIN_REQUESTED",
    "type" : "String",
    "comment" : "\n     * Extra boolean indicating that a PIN is requested for a P2P Invitation Received dialog.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_P2P_DISPLAY_PIN",
    "type" : "String",
    "comment" : "\n     * Extra String indicating the PIN to be displayed for a P2P Invitation Sent/Received dialog.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EXTRA_CLOSE_SYSTEM_DIALOGS_EXCEPT_WIFI",
    "type" : "String",
    "comment" : "\n     * Extra boolean indicating ACTION_CLOSE_SYSTEM_DIALOGS should not close the Wi-Fi dialogs.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_INTERFACE_TYPE_STA",
    "type" : "int",
    "comment" : "\n     * Wi-Fi interface of type STA (station/client Wi-Fi infrastructure device).\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_INTERFACE_TYPE_AP",
    "type" : "int",
    "comment" : "\n     * Wi-Fi interface of type AP (access point Wi-Fi infrastructure device).\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_INTERFACE_TYPE_AWARE",
    "type" : "int",
    "comment" : "\n     * Wi-Fi interface of type Wi-Fi Aware (aka NAN).\n     ",
    "links" : [ ]
  }, {
    "name" : "WIFI_INTERFACE_TYPE_DIRECT",
    "type" : "int",
    "comment" : "\n     * Wi-Fi interface of type Wi-Fi Direct (aka P2P).\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_SEND_DHCP_HOSTNAME_RESTRICTION_OPEN",
    "type" : "int",
    "comment" : "\n     * Do not send the DHCP hostname to open networks.\n     ",
    "links" : [ ]
  }, {
    "name" : "FLAG_SEND_DHCP_HOSTNAME_RESTRICTION_SECURE",
    "type" : "int",
    "comment" : "\n     * Do not send the DHCP hostname to secure network.\n     ",
    "links" : [ ]
  }, {
    "name" : "TWT_CAPABILITIES_KEY_BOOLEAN_TWT_REQUESTER",
    "type" : "String",
    "comment" : "\n     * Bundle key to check target wake time requester mode supported or not\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TWT_CAPABILITIES_KEY_INT_MIN_WAKE_DURATION_MICROS",
    "type" : "String",
    "comment" : "\n     * Bundle key to get minimum wake duration supported in microseconds\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TWT_CAPABILITIES_KEY_INT_MAX_WAKE_DURATION_MICROS",
    "type" : "String",
    "comment" : "\n     * Bundle key to get maximum wake duration supported in microseconds\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TWT_CAPABILITIES_KEY_LONG_MIN_WAKE_INTERVAL_MICROS",
    "type" : "String",
    "comment" : "\n     * Bundle key to get minimum wake interval supported in microseconds\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TWT_CAPABILITIES_KEY_LONG_MAX_WAKE_INTERVAL_MICROS",
    "type" : "String",
    "comment" : "\n     * Bundle key to get maximum wake interval supported in microseconds\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static int getMaxNumberOfPoliciesPerQosRequest()",
    "returnType" : "int",
    "comment" : "\n     * Get the maximum number of policies that can be included in a request to\n     * {@link #addQosPolicies(List, Executor, Consumer)} or {@link #removeQosPolicies(int[])}.\n     * @hide\n     ",
    "links" : [ "#removeQosPolicies(int", "#addQosPolicies(List" ]
  }, {
    "name" : "public List<WifiConfiguration> getConfiguredNetworks()",
    "returnType" : "List<WifiConfiguration>",
    "comment" : "\n     * Return a list of all the networks configured for the current foreground\n     * user.\n     *\n     * Not all fields of WifiConfiguration are returned. Only the following\n     * fields are filled in:\n     * <ul>\n     * <li>networkId</li>\n     * <li>SSID</li>\n     * <li>BSSID</li>\n     * <li>priority</li>\n     * <li>allowedProtocols</li>\n     * <li>allowedKeyManagement</li>\n     * <li>allowedAuthAlgorithms</li>\n     * <li>allowedPairwiseCiphers</li>\n     * <li>allowedGroupCiphers</li>\n     * <li>status</li>\n     * </ul>\n     * @return a list of network configurations in the form of a list\n     * of {@link WifiConfiguration} objects.\n     *\n     * @deprecated\n     * a) See {@link WifiNetworkSpecifier.Builder#build()} for new\n     * mechanism to trigger connection to a Wi-Fi network.\n     * b) See {@link #addNetworkSuggestions(List)},\n     * {@link #removeNetworkSuggestions(List)} for new API to add Wi-Fi networks for consideration\n     * when auto-connecting to wifi.\n     * <b>Compatibility Note:</b> For applications targeting\n     * {@link android.os.Build.VERSION_CODES#Q} or above, this API will always fail and return an\n     * empty list.\n     * <p>\n     * Deprecation Exemptions:\n     * <ul>\n     * <li>Device Owner (DO), Profile Owner (PO) and system apps will have access to the full list.\n     * <li>Callers with Carrier privilege will receive a restricted list only containing\n     * configurations which they created.\n     * </ul>\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#Q", "WifiNetworkSpecifier.Builder#build()", "#removeNetworkSuggestions(List)", "android.net.wifi.WifiConfiguration", "#addNetworkSuggestions(List)" ]
  }, {
    "name" : "public List<WifiConfiguration> getCallerConfiguredNetworks()",
    "returnType" : "List<WifiConfiguration>",
    "comment" : "\n     * Return a list of all the networks previously configured by the calling app. Can\n     * be called by Device Owner (DO), Profile Owner (PO), Callers with Carrier privilege and\n     * system apps.\n     *\n     * @return a list of network configurations in the form of a list\n     * of {@link WifiConfiguration} objects.\n     * @throws SecurityException if the caller is not allowed to call this API\n     ",
    "links" : [ "android.net.wifi.WifiConfiguration" ]
  }, {
    "name" : "public List<WifiConfiguration> getPrivilegedConfiguredNetworks()",
    "returnType" : "List<WifiConfiguration>",
    "comment" : "\n     * Applications targeting {@link android.os.Build.VERSION_CODES#TIRAMISU} or later need to have\n     * the following permissions: {@link android.Manifest.permission#NEARBY_WIFI_DEVICES},\n     * {@link android.Manifest.permission#ACCESS_WIFI_STATE} and\n     * {@link android.Manifest.permission#READ_WIFI_CREDENTIAL}.\n     * Applications targeting {@link Build.VERSION_CODES#S} or prior SDK levels need to have the\n     * following permissions: {@link android.Manifest.permission#ACCESS_FINE_LOCATION},\n     * {@link android.Manifest.permission#CHANGE_WIFI_STATE} and\n     * {@link android.Manifest.permission#READ_WIFI_CREDENTIAL}.\n     * <p> See {@link #getPrivilegedConnectedNetwork()} to get the WifiConfiguration for only the\n     * connected network that's providing internet by default.\n     *\n     * @hide\n     *",
    "links" : [ "android.os.Build.VERSION_CODES#TIRAMISU", "android.Manifest.permission#READ_WIFI_CREDENTIAL", "Build.VERSION_CODES#S", "android.Manifest.permission#ACCESS_FINE_LOCATION", "android.Manifest.permission#ACCESS_WIFI_STATE", "android.Manifest.permission#NEARBY_WIFI_DEVICES", "#getPrivilegedConnectedNetwork()", "android.Manifest.permission#CHANGE_WIFI_STATE" ]
  }, {
    "name" : "public WifiConfiguration getPrivilegedConnectedNetwork()",
    "returnType" : "WifiConfiguration",
    "comment" : "\n     * Gets the {@link WifiConfiguration} with credentials of the connected wifi network\n     * that's providing internet by default.\n     * <p>\n     * On {@link android.os.Build.VERSION_CODES#TIRAMISU} or later SDKs, the caller need to have\n     * the following permissions: {@link android.Manifest.permission#NEARBY_WIFI_DEVICES} with\n     * android:usesPermissionFlags=\"neverForLocation\",\n     * {@link android.Manifest.permission#ACCESS_WIFI_STATE} and\n     * {@link android.Manifest.permission#READ_WIFI_CREDENTIAL}. If the app does not have\n     * android:usesPermissionFlags=\"neverForLocation\", then it must also have\n     * {@link android.Manifest.permission#ACCESS_FINE_LOCATION}.\n     * <p>\n     * On {@link Build.VERSION_CODES#S} or prior SDKs, the caller need to have the\n     * following permissions: {@link android.Manifest.permission#ACCESS_FINE_LOCATION},\n     * {@link android.Manifest.permission#CHANGE_WIFI_STATE} and\n     * {@link android.Manifest.permission#READ_WIFI_CREDENTIAL}.\n     *\n     * @return The WifiConfiguration representation of the connected wifi network providing\n     * internet, or null if wifi is not connected.\n     *\n     * @throws SecurityException if caller does not have the required permissions\n     * @hide\n     *",
    "links" : [ "android.os.Build.VERSION_CODES#TIRAMISU", "android.Manifest.permission#READ_WIFI_CREDENTIAL", "Build.VERSION_CODES#S", "android.Manifest.permission#ACCESS_FINE_LOCATION", "android.Manifest.permission#ACCESS_WIFI_STATE", "android.Manifest.permission#NEARBY_WIFI_DEVICES", "android.net.wifi.WifiConfiguration", "android.Manifest.permission#CHANGE_WIFI_STATE" ]
  }, {
    "name" : "public List<Pair<WifiConfiguration, Map<Integer, List<ScanResult>>>> getAllMatchingWifiConfigs(@NonNull List<ScanResult> scanResults)",
    "returnType" : "List<Pair<WifiConfiguration, Map<Integer, List<ScanResult>>>>",
    "comment" : "\n     * Returns a list of all matching WifiConfigurations of PasspointConfiguration for a given list\n     * of ScanResult.\n     *\n     * An empty list will be returned when no PasspointConfiguration are installed or if no\n     * PasspointConfiguration match the ScanResult.\n     *\n     * @param scanResults a list of scanResult that represents the BSSID\n     * @return List that consists of {@link WifiConfiguration} and corresponding scanResults per\n     * network type({@link #PASSPOINT_HOME_NETWORK} and {@link #PASSPOINT_ROAMING_NETWORK}).\n     * @hide\n     ",
    "links" : [ "#PASSPOINT_ROAMING_NETWORK", "#PASSPOINT_HOME_NETWORK", "android.net.wifi.WifiConfiguration" ]
  }, {
    "name" : "public void setNetworkSelectionConfig(@NonNull WifiNetworkSelectionConfig nsConfig)",
    "returnType" : "void",
    "comment" : "\n     * This API allows a privileged app to customize the wifi framework's network selection logic.\n     * To revert to default behavior, call this API with a {@link WifiNetworkSelectionConfig}\n     * created from a default {@link WifiNetworkSelectionConfig.Builder}.\n     *\n     * Use {@link WifiManager#getNetworkSelectionConfig(Executor, Consumer)} to get the current\n     * network selection configuration.\n     * <P>\n     * @param nsConfig an Object representing the network selection configuration being programmed.\n     *                 This should be created with a {@link WifiNetworkSelectionConfig.Builder}.\n     *\n     * @throws UnsupportedOperationException if the API is not supported on this SDK version.\n     * @throws IllegalArgumentException if input is invalid.\n     * @throws SecurityException if the caller does not have permission.\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getNetworkSelectionConfig(Executor", "WifiNetworkSelectionConfig.Builder", "android.net.wifi.WifiNetworkSelectionConfig" ]
  }, {
    "name" : "public void getNetworkSelectionConfig(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<WifiNetworkSelectionConfig> resultsCallback)",
    "returnType" : "void",
    "comment" : "\n     * This API allows a privileged app to retrieve the {@link WifiNetworkSelectionConfig}\n     * currently being used by the network selector.\n     *\n     * Use {@link WifiManager#setNetworkSelectionConfig(WifiNetworkSelectionConfig)} to set a\n     * new network selection configuration.\n     * <P>\n     * @param executor The executor on which callback will be invoked.\n     * @param resultsCallback An asynchronous callback that will return\n     *                        {@link WifiNetworkSelectionConfig}\n     *\n     * @throws UnsupportedOperationException if the API is not supported on this SDK version.\n     * @throws SecurityException if the caller does not have permission.\n     * @throws NullPointerException if the caller provided invalid inputs.\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#setNetworkSelectionConfig(WifiNetworkSelectionConfig)", "android.net.wifi.WifiNetworkSelectionConfig" ]
  }, {
    "name" : "public void setThirdPartyAppEnablingWifiConfirmationDialogEnabled(boolean enable)",
    "returnType" : "void",
    "comment" : "\n     * Allows a privileged app to enable/disable whether a confirmation dialog should be displayed\n     * when third-party apps attempt to turn on WiFi.\n     *\n     * Use {@link #isThirdPartyAppEnablingWifiConfirmationDialogEnabled()} to get the\n     * currently configured value.\n     *\n     * Note: Only affects behavior for apps with targetSDK < Q, since third party apps are not\n     * allowed to enable wifi on targetSDK >= Q.\n     *\n     * This overrides the overlay value |config_showConfirmationDialogForThirdPartyAppsEnablingWifi|\n     * <P>\n     * @param enable true to enable the confirmation dialog, false otherwise\n     *\n     * @throws UnsupportedOperationException if the API is not supported on this SDK version.\n     * @throws SecurityException if the caller does not have permission.\n     * @hide\n     ",
    "links" : [ "#isThirdPartyAppEnablingWifiConfirmationDialogEnabled()" ]
  }, {
    "name" : "public boolean isThirdPartyAppEnablingWifiConfirmationDialogEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Check whether the wifi configuration indicates that a confirmation dialog should be displayed\n     * when third-party apps attempt to turn on WiFi.\n     *\n     * Use {@link #setThirdPartyAppEnablingWifiConfirmationDialogEnabled(boolean)} to set this\n     * value.\n     *\n     * Note: This setting only affects behavior for apps with targetSDK < Q, since third party apps\n     *       are not allowed to enable wifi on targetSDK >= Q.\n     *\n     * <P>\n     * @throws UnsupportedOperationException if the API is not supported on this SDK version.\n     * @throws SecurityException if the caller does not have permission.\n     * @return true if dialog should be displayed, false otherwise.\n     * @hide\n     ",
    "links" : [ "#setThirdPartyAppEnablingWifiConfirmationDialogEnabled(boolean)" ]
  }, {
    "name" : "public void setScreenOnScanSchedule(@Nullable List<ScreenOnScanSchedule> screenOnScanSchedule)",
    "returnType" : "void",
    "comment" : "\n     * Allows a privileged app to customize the screen-on scan behavior. When a non-null schedule\n     * is set via this API, it will always get used instead of the scan schedules defined in the\n     * overlay. When a null schedule is set via this API, the wifi subsystem will go back to using\n     * the scan schedules defined in the overlay. Also note, the scan schedule will be truncated\n     * (rounded down) to the nearest whole second.\n     * <p>\n     * Example usage:\n     * The following call specifies that first scheduled scan should be in 20 seconds using\n     * {@link WifiScanner#SCAN_TYPE_HIGH_ACCURACY}, and all\n     * scheduled scans later should happen every 40 seconds using\n     * {@link WifiScanner#SCAN_TYPE_LOW_POWER}.\n     * <pre>\n     * List<ScreenOnScanSchedule> schedule = new ArrayList<>();\n     * schedule.add(new ScreenOnScanSchedule(Duration.ofSeconds(20),\n     *         WifiScanner.SCAN_TYPE_HIGH_ACCURACY));\n     * schedule.add(new ScreenOnScanSchedule(Duration.ofSeconds(40),\n     *         WifiScanner.SCAN_TYPE_LOW_POWER));\n     * wifiManager.setScreenOnScanSchedule(schedule);\n     * </pre>\n     * @param screenOnScanSchedule defines the screen-on scan schedule and the corresponding\n     *                             scan type. Set to null to clear any previously set value.\n     *\n     * @throws IllegalStateException if input is invalid\n     * @throws UnsupportedOperationException if the API is not supported on this SDK version.\n     * @throws SecurityException if the caller does not have permission.\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiScanner#SCAN_TYPE_HIGH_ACCURACY", "android.net.wifi.WifiScanner#SCAN_TYPE_LOW_POWER" ]
  }, {
    "name" : "public void setOneShotScreenOnConnectivityScanDelayMillis(@IntRange(from = 0) int delayMs)",
    "returnType" : "void",
    "comment" : "\n     * The Wi-Fi framework may trigger connectivity scans in response to the screen turning on for\n     * network selection purposes. This API allows a privileged app to set a delay to the next\n     * connectivity scan triggered by the Wi-Fi framework in response to the next screen-on event.\n     * This gives a window for the privileged app to issue their own custom scans to influence Wi-Fi\n     * network selection. The expected usage is the privileged app monitor for the screen turning\n     * off, and then call this API if it believes delaying the next screen-on connectivity scan is\n     * needed.\n     * <p>\n     * Note that this API will only delay screen-on connectivity scans once. This API will need to\n     * be called again if further screen-on scan delays are needed after it resolves.\n     * @param delayMs defines the time in milliseconds to delay the next screen-on connectivity\n     *                scan. Setting this to 0 will remove the delay.\n     *\n     * @throws IllegalStateException if input is invalid\n     * @throws UnsupportedOperationException if the API is not supported on this SDK version.\n     * @throws SecurityException if the caller does not have permission.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<WifiConfiguration> getWifiConfigForMatchedNetworkSuggestionsSharedWithUser(@NonNull List<ScanResult> scanResults)",
    "returnType" : "List<WifiConfiguration>",
    "comment" : "\n     * Retrieve a list of {@link WifiConfiguration} for available {@link WifiNetworkSuggestion}\n     * matching the given list of {@link ScanResult}.\n     *\n     * An available {@link WifiNetworkSuggestion} must satisfy:\n     * <ul>\n     * <li> Matching one of the {@link ScanResult} from the given list.\n     * <li> and {@link WifiNetworkSuggestion.Builder#setIsUserAllowedToManuallyConnect(boolean)} set\n     * to true.\n     * </ul>\n     *\n     * @param scanResults a list of scanResult.\n     * @return a list of @link WifiConfiguration} for available {@link WifiNetworkSuggestion}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.ScanResult", "android.net.wifi.WifiNetworkSuggestion", "WifiNetworkSuggestion.Builder#setIsUserAllowedToManuallyConnect(boolean)", "android.net.wifi.WifiConfiguration" ]
  }, {
    "name" : "public void setSsidsAllowlist(@NonNull Set<WifiSsid> ssids)",
    "returnType" : "void",
    "comment" : "\n     * Specify a set of SSIDs that will not get disabled internally by the Wi-Fi subsystem when\n     * connection issues occur. To clear the list, call this API with an empty Set.\n     * <p>\n     * {@link #getSsidsAllowlist()} can be used to check the SSIDs that have been set.\n     * @param ssids - list of WifiSsid that will not get disabled internally\n     * @throws SecurityException if the calling app is not a Device Owner (DO), Profile Owner (PO),\n     *                           or a privileged app that has one of the permissions required by\n     *                           this API.\n     * @throws IllegalArgumentException if the input is null.\n     * @hide\n     ",
    "links" : [ "#getSsidsAllowlist()" ]
  }, {
    "name" : "public Set<WifiSsid> getSsidsAllowlist()",
    "returnType" : "Set<WifiSsid>",
    "comment" : "\n     * Get the Set of SSIDs that will not get disabled internally by the Wi-Fi subsystem when\n     * connection issues occur.\n     * @throws SecurityException if the calling app is not a Device Owner (DO), Profile Owner (PO),\n     *                           or a privileged app that has one of the permissions required by\n     *                           this API.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Map<OsuProvider, List<ScanResult>> getMatchingOsuProviders(@Nullable List<ScanResult> scanResults)",
    "returnType" : "Map<OsuProvider, List<ScanResult>>",
    "comment" : "\n     * Returns a list of unique Hotspot 2.0 OSU (Online Sign-Up) providers associated with a given\n     * list of ScanResult.\n     *\n     * An empty list will be returned if no match is found.\n     *\n     * @param scanResults a list of ScanResult\n     * @return Map that consists {@link OsuProvider} and a list of matching {@link ScanResult}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.ScanResult", "android.net.wifi.hotspot2.OsuProvider" ]
  }, {
    "name" : "public Map<OsuProvider, PasspointConfiguration> getMatchingPasspointConfigsForOsuProviders(@NonNull Set<OsuProvider> osuProviders)",
    "returnType" : "Map<OsuProvider, PasspointConfiguration>",
    "comment" : "\n     * Returns the matching Passpoint R2 configurations for given OSU (Online Sign-Up) providers.\n     *\n     * Given a list of OSU providers, this only returns OSU providers that already have Passpoint R2\n     * configurations in the device.\n     * An empty map will be returned when there is no matching Passpoint R2 configuration for the\n     * given OsuProviders.\n     *\n     * @param osuProviders a set of {@link OsuProvider}\n     * @return Map that consists of {@link OsuProvider} and matching {@link PasspointConfiguration}.\n     * @hide\n     ",
    "links" : [ "android.net.wifi.hotspot2.OsuProvider", "android.net.wifi.hotspot2.PasspointConfiguration" ]
  }, {
    "name" : "public int addNetwork(WifiConfiguration config)",
    "returnType" : "int",
    "comment" : "\n     * Add a new network description to the set of configured networks.\n     * The {@code networkId} field of the supplied configuration object\n     * is ignored.\n     * <p/>\n     * The new network will be marked DISABLED by default. To enable it,\n     * called {@link #enableNetwork}.\n     *\n     * @param config the set of variables that describe the configuration,\n     *            contained in a {@link WifiConfiguration} object.\n     *            If the {@link WifiConfiguration} has an Http Proxy set\n     *            the calling app must be System, or be provisioned as the Profile or Device Owner.\n     * @return the ID of the newly created network description. This is used in\n     *         other operations to specified the network to be acted upon.\n     *         Returns {@code -1} on failure.\n     *\n     * @deprecated\n     * a) See {@link WifiNetworkSpecifier.Builder#build()} for new\n     * mechanism to trigger connection to a Wi-Fi network.\n     * b) See {@link #addNetworkSuggestions(List)},\n     * {@link #removeNetworkSuggestions(List)} for new API to add Wi-Fi networks for consideration\n     * when auto-connecting to wifi.\n     * <b>Compatibility Note:</b> For applications targeting\n     * {@link android.os.Build.VERSION_CODES#Q} or above, this API will always fail and return\n     * {@code -1}.\n     * <p>\n     * Deprecation Exemptions:\n     * <ul>\n     * <li>Device Owner (DO), Profile Owner (PO) and system apps.\n     * </ul>\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#Q", "#enableNetwork", "WifiNetworkSpecifier.Builder#build()", "#removeNetworkSuggestions(List)", "android.net.wifi.WifiConfiguration", "#addNetworkSuggestions(List)" ]
  }, {
    "name" : "public AddNetworkResult addNetworkPrivileged(@NonNull WifiConfiguration config)",
    "returnType" : "AddNetworkResult",
    "comment" : "\n     * This is a new version of {@link #addNetwork(WifiConfiguration)} which returns more detailed\n     * failure codes. The usage of this API is limited to Device Owner (DO), Profile Owner (PO),\n     * system app, and privileged apps.\n     * <p>\n     * Add a new network description to the set of configured networks. The {@code networkId}\n     * field of the supplied configuration object is ignored. The new network will be marked\n     * DISABLED by default. To enable it, call {@link #enableNetwork}.\n     * <p>\n     * @param config the set of variables that describe the configuration,\n     *            contained in a {@link WifiConfiguration} object.\n     *            If the {@link WifiConfiguration} has an Http Proxy set\n     *            the calling app must be System, or be provisioned as the Profile or Device Owner.\n     * @return A {@link AddNetworkResult} Object.\n     * @throws SecurityException if the calling app is not a Device Owner (DO),\n     *                           Profile Owner (PO), system app, or a privileged app that has one of\n     *                           the permissions required by this API.\n     * @throws IllegalArgumentException if the input configuration is null or if the\n     *            security type in input configuration is not supported.\n     ",
    "links" : [ "#enableNetwork", "#addNetwork(WifiConfiguration)", "AddNetworkResult", "android.net.wifi.WifiConfiguration" ]
  }, {
    "name" : "public int updateNetwork(WifiConfiguration config)",
    "returnType" : "int",
    "comment" : "\n     * Update the network description of an existing configured network.\n     *\n     * @param config the set of variables that describe the configuration,\n     *            contained in a {@link WifiConfiguration} object. It may\n     *            be sparse, so that only the items that are being changed\n     *            are non-<code>null</code>. The {@code networkId} field\n     *            must be set to the ID of the existing network being updated.\n     *            If the {@link WifiConfiguration} has an Http Proxy set\n     *            the calling app must be System, or be provisioned as the Profile or Device Owner.\n     * @return Returns the {@code networkId} of the supplied\n     *         {@code WifiConfiguration} on success.\n     *         <br/>\n     *         Returns {@code -1} on failure, including when the {@code networkId}\n     *         field of the {@code WifiConfiguration} does not refer to an\n     *         existing network.\n     *\n     * @deprecated\n     * a) See {@link WifiNetworkSpecifier.Builder#build()} for new\n     * mechanism to trigger connection to a Wi-Fi network.\n     * b) See {@link #addNetworkSuggestions(List)},\n     * {@link #removeNetworkSuggestions(List)} for new API to add Wi-Fi networks for consideration\n     * when auto-connecting to wifi.\n     * <b>Compatibility Note:</b> For applications targeting\n     * {@link android.os.Build.VERSION_CODES#Q} or above, this API will always fail and return\n     * {@code -1}.\n     * <p>\n     * Deprecation Exemptions:\n     * <ul>\n     * <li>Device Owner (DO), Profile Owner (PO) and system apps.\n     * </ul>\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#Q", "WifiNetworkSpecifier.Builder#build()", "#removeNetworkSuggestions(List)", "android.net.wifi.WifiConfiguration", "#addNetworkSuggestions(List)" ]
  }, {
    "name" : "private int addOrUpdateNetwork(WifiConfiguration config)",
    "returnType" : "int",
    "comment" : "\n     * Internal method for doing the RPC that creates a new network description\n     * or updates an existing one.\n     *\n     * @param config The possibly sparse object containing the variables that\n     *         are to set or updated in the network description.\n     * @return the ID of the network on success, {@code -1} on failure.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerNetworkRequestMatchCallback(@NonNull @CallbackExecutor Executor executor, @NonNull NetworkRequestMatchCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Registers a callback for NetworkRequest matches. See {@link NetworkRequestMatchCallback}.\n     * Caller can unregister a previously registered callback using\n     * {@link #unregisterNetworkRequestMatchCallback(NetworkRequestMatchCallback)}\n     * <p>\n     * Applications should have the\n     * {@link android.Manifest.permission#NETWORK_SETTINGS} permission. Callers\n     * without the permission will trigger a {@link java.lang.SecurityException}.\n     * <p>\n     *\n     * @param executor The Executor on whose thread to execute the callbacks of the {@code callback}\n     *                 object.\n     * @param callback Callback for network match events to register.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#NETWORK_SETTINGS", "NetworkRequestMatchCallback", "java.lang.SecurityException", "#unregisterNetworkRequestMatchCallback(NetworkRequestMatchCallback)" ]
  }, {
    "name" : "public void unregisterNetworkRequestMatchCallback(@NonNull NetworkRequestMatchCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters a callback for NetworkRequest matches. See {@link NetworkRequestMatchCallback}.\n     * <p>\n     * Applications should have the\n     * {@link android.Manifest.permission#NETWORK_SETTINGS} permission. Callers\n     * without the permission will trigger a {@link java.lang.SecurityException}.\n     * <p>\n     *\n     * @param callback Callback for network match events to unregister.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#NETWORK_SETTINGS", "NetworkRequestMatchCallback", "java.lang.SecurityException" ]
  }, {
    "name" : "public void removeAppState(int targetAppUid, @NonNull String targetAppPackageName)",
    "returnType" : "void",
    "comment" : "\n     * Privileged API to revoke all app state from wifi stack (equivalent to operations that the\n     * wifi stack performs to clear state for an app that was uninstalled.\n     * This removes:\n     * <li> All saved networks or passpoint profiles added by the app </li>\n     * <li> All previously approved peer to peer connection to access points initiated by the app\n     * using {@link WifiNetworkSpecifier}</li>\n     * <li> All network suggestions and approvals provided using {@link WifiNetworkSuggestion}</li>\n     * <p>\n     * @param targetAppUid UID of the app.\n     * @param targetAppPackageName Package name of the app.\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiNetworkSpecifier", "android.net.wifi.WifiNetworkSuggestion" ]
  }, {
    "name" : "public int addNetworkSuggestions(@NonNull List<WifiNetworkSuggestion> networkSuggestions)",
    "returnType" : "int",
    "comment" : "\n     * Provide a list of network suggestions to the device. See {@link WifiNetworkSuggestion}\n     * for a detailed explanation of the parameters.\n     * When the device decides to connect to one of the provided network suggestions, platform sends\n     * a directed broadcast {@link #ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION} to the app if\n     * the network was created with\n     * {@link WifiNetworkSuggestion.Builder#setIsAppInteractionRequired(boolean)} flag set and the\n     * app holds {@link android.Manifest.permission#ACCESS_FINE_LOCATION ACCESS_FINE_LOCATION}\n     * permission.\n     *<p>\n     * NOTE:\n     * <ul>\n     * <li> These networks are just a suggestion to the platform. The platform will ultimately\n     * decide on which network the device connects to. </li>\n     * <li> When an app is uninstalled or disabled, all its suggested networks are discarded.\n     * If the device is currently connected to a suggested network which is being removed then the\n     * device will disconnect from that network.</li>\n     * <li> If user reset network settings, all added suggestions will be discarded. Apps can use\n     * {@link #getNetworkSuggestions()} to check if their suggestions are in the device.</li>\n     * <li> In-place modification of existing suggestions are allowed.</li>\n     * <ul>\n     * <li> If the provided suggestions include any previously provided suggestions by the app,\n     * previous suggestions will be updated.</li>\n     * <li>If one of the provided suggestions marks a previously unmetered suggestion as metered and\n     * the device is currently connected to that suggested network, then the device will disconnect\n     * from that network. The system will immediately re-evaluate all the network candidates\n     * and possibly reconnect back to the same suggestion. This disconnect is to make sure that any\n     * traffic flowing over unmetered networks isn't accidentally continued over a metered network.\n     * </li>\n     * <li>\n     * On {@link android.os.Build.VERSION_CODES#TIRAMISU} or above If one of the provided\n     * suggestions marks a previously trusted suggestion as untrusted and the device is currently\n     * connected to that suggested network, then the device will disconnect from that network. The\n     * system will immediately re-evaluate all the network candidates. This disconnect is to make\n     * sure device will not remain connected to an untrusted network without a related\n     * {@link android.net.NetworkRequest}.\n     * </li>\n     * </ul>\n     * </ul>\n     *\n     * @param networkSuggestions List of network suggestions provided by the app.\n     * @return Status code for the operation. One of the STATUS_NETWORK_SUGGESTIONS_ values.\n     * @throws SecurityException if the caller is missing required permissions.\n     * @see WifiNetworkSuggestion#equals(Object)\n     ",
    "links" : [ "WifiNetworkSuggestion.Builder#setIsAppInteractionRequired(boolean)", "android.os.Build.VERSION_CODES#TIRAMISU", "#ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION", "android.Manifest.permission#ACCESS_FINE_LOCATION", "#getNetworkSuggestions()", "android.net.wifi.WifiNetworkSuggestion", "android.net.NetworkRequest" ]
  }, {
    "name" : "public int removeNetworkSuggestions(@NonNull List<WifiNetworkSuggestion> networkSuggestions)",
    "returnType" : "int",
    "comment" : "\n     * Remove some or all of the network suggestions that were previously provided by the app.\n     * If one of the suggestions being removed was used to establish connection to the current\n     * network, then the device will immediately disconnect from that network. This method is same\n     * as {@link #removeNetworkSuggestions(List, int)} with\n     * {@link #ACTION_REMOVE_SUGGESTION_DISCONNECT}\n     *\n     * See {@link WifiNetworkSuggestion} for a detailed explanation of the parameters.\n     * See {@link WifiNetworkSuggestion#equals(Object)} for the equivalence evaluation used.\n     * <p></\n     * Note: Use {@link #removeNetworkSuggestions(List, int)}. An {@code action} of\n     * {@link #ACTION_REMOVE_SUGGESTION_DISCONNECT} is equivalent to the current behavior.\n     *\n     * @param networkSuggestions List of network suggestions to be removed. Pass an empty list\n     *                           to remove all the previous suggestions provided by the app.\n     * @return Status code for the operation. One of the {@code STATUS_NETWORK_SUGGESTIONS_*}\n     * values. Any matching suggestions are removed from the device and will not be considered for\n     * any further connection attempts.\n     ",
    "links" : [ "#removeNetworkSuggestions(List", "android.net.wifi.WifiNetworkSuggestion", "android.net.wifi.WifiNetworkSuggestion#equals(Object)", "#ACTION_REMOVE_SUGGESTION_DISCONNECT" ]
  }, {
    "name" : "public int removeNetworkSuggestions(@NonNull List<WifiNetworkSuggestion> networkSuggestions, @ActionAfterRemovingSuggestion int action)",
    "returnType" : "int",
    "comment" : "\n     * Remove some or all of the network suggestions that were previously provided by the app.\n     * If one of the suggestions being removed was used to establish connection to the current\n     * network, then the specified action will be executed.\n     *\n     * See {@link WifiNetworkSuggestion} for a detailed explanation of the parameters.\n     * See {@link WifiNetworkSuggestion#equals(Object)} for the equivalence evaluation used.\n     *\n     * @param networkSuggestions List of network suggestions to be removed. Pass an empty list\n     *                           to remove all the previous suggestions provided by the app.\n     * @param action Desired action to execute after removing the suggestion. One of\n     *               {@code ACTION_REMOVE_SUGGESTION_*}\n     * @return Status code for the operation. One of the {@code STATUS_NETWORK_SUGGESTIONS_*}\n     * values. Any matching suggestions are removed from the device and will not be considered for\n     * further connection attempts.\n     ",
    "links" : [ "android.net.wifi.WifiNetworkSuggestion", "android.net.wifi.WifiNetworkSuggestion#equals(Object)" ]
  }, {
    "name" : "public List<WifiNetworkSuggestion> getNetworkSuggestions()",
    "returnType" : "List<WifiNetworkSuggestion>",
    "comment" : "\n     * Get all network suggestions provided by the calling app.\n     * See {@link #addNetworkSuggestions(List)}\n     * See {@link #removeNetworkSuggestions(List)}\n     * @return a list of {@link WifiNetworkSuggestion}\n     ",
    "links" : [ "#removeNetworkSuggestions(List)", "android.net.wifi.WifiNetworkSuggestion", "#addNetworkSuggestions(List)" ]
  }, {
    "name" : "public int getMaxNumberOfNetworkSuggestionsPerApp()",
    "returnType" : "int",
    "comment" : "\n     * Returns the max number of network suggestions that are allowed per app on the device.\n     * @see #addNetworkSuggestions(List)\n     * @see #removeNetworkSuggestions(List)\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getMaxNumberOfNetworkSuggestionsPerApp(boolean isLowRamDevice)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void addOrUpdatePasspointConfiguration(PasspointConfiguration config)",
    "returnType" : "void",
    "comment" : "\n     * Add or update a Passpoint configuration.  The configuration provides a credential\n     * for connecting to Passpoint networks that are operated by the Passpoint\n     * service provider specified in the configuration.\n     *\n     * Each configuration is uniquely identified by a unique key which depends on the contents of\n     * the configuration. This allows the caller to install multiple profiles with the same FQDN\n     * (Fully qualified domain name). Therefore, in order to update an existing profile, it is\n     * first required to remove it using {@link WifiManager#removePasspointConfiguration(String)}.\n     * Otherwise, a new profile will be added with both configuration.\n     *\n     * Deprecated for general app usage - except DO/PO apps.\n     * See {@link WifiNetworkSuggestion.Builder#setPasspointConfig(PasspointConfiguration)} to\n     * create a passpoint suggestion.\n     * See {@link #addNetworkSuggestions(List)}, {@link #removeNetworkSuggestions(List)} for new\n     * API to add Wi-Fi networks for consideration when auto-connecting to wifi.\n     * <b>Compatibility Note:</b> For applications targeting\n     * {@link android.os.Build.VERSION_CODES#R} or above, this API will always fail and throw\n     * {@link IllegalArgumentException}.\n     * <p>\n     * Deprecation Exemptions:\n     * <ul>\n     * <li>Device Owner (DO), Profile Owner (PO) and system apps.\n     * </ul>\n     *\n     * @param config The Passpoint configuration to be added\n     * @throws IllegalArgumentException if configuration is invalid or Passpoint is not enabled on\n     *                                  the device.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#R", "android.net.wifi.WifiManager#removePasspointConfiguration(String)", "#removeNetworkSuggestions(List)", "IllegalArgumentException", "WifiNetworkSuggestion.Builder#setPasspointConfig(PasspointConfiguration)", "#addNetworkSuggestions(List)" ]
  }, {
    "name" : "public void removePasspointConfiguration(String fqdn)",
    "returnType" : "void",
    "comment" : "\n     * Remove the Passpoint configuration identified by its FQDN (Fully Qualified Domain Name) added\n     * by the caller.\n     *\n     * @param fqdn The FQDN of the Passpoint configuration added by the caller to be removed\n     * @throws IllegalArgumentException if no configuration is associated with the given FQDN or\n     *                                  Passpoint is not enabled on the device.\n     * @deprecated This will be non-functional in a future release.\n     * <br>\n     * Requires {@code android.Manifest.permission.NETWORK_SETTINGS} or\n     * {@code android.Manifest.permission.NETWORK_CARRIER_PROVISIONING}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<PasspointConfiguration> getPasspointConfigurations()",
    "returnType" : "List<PasspointConfiguration>",
    "comment" : "\n     * Return the list of installed Passpoint configurations added by the caller.\n     *\n     * An empty list will be returned when no configurations are installed.\n     *\n     * @return A list of {@link PasspointConfiguration} added by the caller\n     * @deprecated This will be non-functional in a future release.\n     * <br>\n     * Requires {@code android.Manifest.permission.NETWORK_SETTINGS} or\n     * {@code android.Manifest.permission.NETWORK_SETUP_WIZARD}.\n     ",
    "links" : [ "android.net.wifi.hotspot2.PasspointConfiguration" ]
  }, {
    "name" : "public void queryPasspointIcon(long bssid, String fileName)",
    "returnType" : "void",
    "comment" : "\n     * Query for a Hotspot 2.0 release 2 OSU icon file. An {@link #ACTION_PASSPOINT_ICON} intent\n     * will be broadcasted once the request is completed.  The presence of the intent extra\n     * {@link #EXTRA_ICON} will indicate the result of the request.\n     * A missing intent extra {@link #EXTRA_ICON} will indicate a failure.\n     *\n     * @param bssid The BSSID of the AP\n     * @param fileName Name of the icon file (remote file) to query from the AP\n     *\n     * @throws UnsupportedOperationException if Passpoint is not enabled on the device.\n     * @hide\n     ",
    "links" : [ "#EXTRA_ICON", "#ACTION_PASSPOINT_ICON" ]
  }, {
    "name" : "public int matchProviderWithCurrentNetwork(String fqdn)",
    "returnType" : "int",
    "comment" : "\n     * Match the currently associated network against the SP matching the given FQDN\n     * @param fqdn FQDN of the SP\n     * @return ordinal [HomeProvider, RoamingProvider, Incomplete, None, Declined]\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean removeNetwork(int netId)",
    "returnType" : "boolean",
    "comment" : "\n     * Remove the specified network from the list of configured networks.\n     * This may result in the asynchronous delivery of state change\n     * events.\n     *\n     * Applications are not allowed to remove networks created by other\n     * applications.\n     *\n     * @param netId the ID of the network as returned by {@link #addNetwork} or {@link\n     *        #getConfiguredNetworks}.\n     * @return {@code true} if the operation succeeded\n     *\n     * @deprecated\n     * a) See {@link WifiNetworkSpecifier.Builder#build()} for new\n     * mechanism to trigger connection to a Wi-Fi network.\n     * b) See {@link #addNetworkSuggestions(List)},\n     * {@link #removeNetworkSuggestions(List)} for new API to add Wi-Fi networks for consideration\n     * when auto-connecting to wifi.\n     * <b>Compatibility Note:</b> For applications targeting\n     * {@link android.os.Build.VERSION_CODES#Q} or above, this API will always fail and return\n     * {@code false}.\n     * <p>\n     * Deprecation Exemptions:\n     * <ul>\n     * <li>Device Owner (DO), Profile Owner (PO) and system apps.\n     * </ul>\n     ",
    "links" : [ "#addNetwork", "android.os.Build.VERSION_CODES#Q", "WifiNetworkSpecifier.Builder#build()", "#removeNetworkSuggestions(List)", "#getConfiguredNetworks", "#addNetworkSuggestions(List)" ]
  }, {
    "name" : "public boolean removeNonCallerConfiguredNetworks()",
    "returnType" : "boolean",
    "comment" : "\n     * Remove all configured networks that were not created by the calling app. Can only\n     * be called by a Device Owner (DO) app.\n     *\n     * @return {@code true} if at least one network is removed, {@code false} otherwise\n     * @throws SecurityException if the caller is not a Device Owner app\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean enableNetwork(int netId, boolean attemptConnect)",
    "returnType" : "boolean",
    "comment" : "\n     * Allow a previously configured network to be associated with. If\n     * <code>attemptConnect</code> is true, an attempt to connect to the selected\n     * network is initiated. This may result in the asynchronous delivery\n     * of state change events.\n     * <p>\n     * <b>Note:</b> Network communication may not use Wi-Fi even if Wi-Fi is connected;\n     * traffic may instead be sent through another network, such as cellular data,\n     * Bluetooth tethering, or Ethernet. For example, traffic will never use a\n     * Wi-Fi network that does not provide Internet access (e.g. a wireless\n     * printer), if another network that does offer Internet access (e.g.\n     * cellular data) is available. Applications that need to ensure that their\n     * network traffic uses Wi-Fi should use APIs such as\n     * {@link Network#bindSocket(java.net.Socket)},\n     * {@link Network#openConnection(java.net.URL)}, or\n     * {@link ConnectivityManager#bindProcessToNetwork} to do so.\n     *\n     * Applications are not allowed to enable networks created by other\n     * applications.\n     *\n     * @param netId the ID of the network as returned by {@link #addNetwork} or {@link\n     *        #getConfiguredNetworks}.\n     * @param attemptConnect The way to select a particular network to connect to is specify\n     *        {@code true} for this parameter.\n     * @return {@code true} if the operation succeeded\n     *\n     * @deprecated\n     * a) See {@link WifiNetworkSpecifier.Builder#build()} for new\n     * mechanism to trigger connection to a Wi-Fi network.\n     * b) See {@link #addNetworkSuggestions(List)},\n     * {@link #removeNetworkSuggestions(List)} for new API to add Wi-Fi networks for consideration\n     * when auto-connecting to wifi.\n     * <b>Compatibility Note:</b> For applications targeting\n     * {@link android.os.Build.VERSION_CODES#Q} or above, this API will always fail and return\n     * {@code false}.\n     * Deprecation Exemptions:\n     * <ul>\n     * <li>Device Owner (DO), Profile Owner (PO) and system apps.\n     * </ul>\n     ",
    "links" : [ "#addNetwork", "android.os.Build.VERSION_CODES#Q", "android.net.Network#bindSocket(java.net.Socket)", "WifiNetworkSpecifier.Builder#build()", "#removeNetworkSuggestions(List)", "#getConfiguredNetworks", "android.net.Network#openConnection(java.net.URL)", "android.net.ConnectivityManager#bindProcessToNetwork", "#addNetworkSuggestions(List)" ]
  }, {
    "name" : "public boolean disableNetwork(int netId)",
    "returnType" : "boolean",
    "comment" : "\n     * Disable a configured network. The specified network will not be\n     * a candidate for associating. This may result in the asynchronous\n     * delivery of state change events.\n     *\n     * Applications are not allowed to disable networks created by other\n     * applications.\n     *\n     * @param netId the ID of the network as returned by {@link #addNetwork} or {@link\n     *        #getConfiguredNetworks}.\n     * @return {@code true} if the operation succeeded\n     *\n     * @deprecated\n     * a) See {@link WifiNetworkSpecifier.Builder#build()} for new\n     * mechanism to trigger connection to a Wi-Fi network.\n     * b) See {@link #addNetworkSuggestions(List)},\n     * {@link #removeNetworkSuggestions(List)} for new API to add Wi-Fi networks for consideration\n     * when auto-connecting to wifi.\n     * <b>Compatibility Note:</b> For applications targeting\n     * {@link android.os.Build.VERSION_CODES#Q} or above, this API will always fail and return\n     * {@code false}.\n     * <p>\n     * Deprecation Exemptions:\n     * <ul>\n     * <li>Device Owner (DO), Profile Owner (PO) and system apps.\n     * </ul>\n     ",
    "links" : [ "#addNetwork", "android.os.Build.VERSION_CODES#Q", "WifiNetworkSpecifier.Builder#build()", "#removeNetworkSuggestions(List)", "#getConfiguredNetworks", "#addNetworkSuggestions(List)" ]
  }, {
    "name" : "public boolean disconnect()",
    "returnType" : "boolean",
    "comment" : "\n     * Disassociate from the currently active access point. This may result\n     * in the asynchronous delivery of state change events.\n     * @return {@code true} if the operation succeeded\n     *\n     * @deprecated\n     * a) See {@link WifiNetworkSpecifier.Builder#build()} for new\n     * mechanism to trigger connection to a Wi-Fi network.\n     * b) See {@link #addNetworkSuggestions(List)},\n     * {@link #removeNetworkSuggestions(List)} for new API to add Wi-Fi networks for consideration\n     * when auto-connecting to wifi.\n     * <b>Compatibility Note:</b> For applications targeting\n     * {@link android.os.Build.VERSION_CODES#Q} or above, this API will always fail and return\n     * {@code false}.\n     * <p>\n     * Deprecation Exemptions:\n     * <ul>\n     * <li>Device Owner (DO), Profile Owner (PO) and system apps.\n     * </ul>\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#Q", "WifiNetworkSpecifier.Builder#build()", "#removeNetworkSuggestions(List)", "#addNetworkSuggestions(List)" ]
  }, {
    "name" : "public boolean reconnect()",
    "returnType" : "boolean",
    "comment" : "\n     * Reconnect to the currently active access point, if we are currently\n     * disconnected. This may result in the asynchronous delivery of state\n     * change events.\n     * @return {@code true} if the operation succeeded\n     *\n     * @deprecated\n     * a) See {@link WifiNetworkSpecifier.Builder#build()} for new\n     * mechanism to trigger connection to a Wi-Fi network.\n     * b) See {@link #addNetworkSuggestions(List)},\n     * {@link #removeNetworkSuggestions(List)} for new API to add Wi-Fi networks for consideration\n     * when auto-connecting to wifi.\n     * <b>Compatibility Note:</b> For applications targeting\n     * {@link android.os.Build.VERSION_CODES#Q} or above, this API will always fail and return\n     * {@code false}.\n     * <p>\n     * Deprecation Exemptions:\n     * <ul>\n     * <li>Device Owner (DO), Profile Owner (PO) and system apps.\n     * </ul>\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#Q", "WifiNetworkSpecifier.Builder#build()", "#removeNetworkSuggestions(List)", "#addNetworkSuggestions(List)" ]
  }, {
    "name" : "public boolean reassociate()",
    "returnType" : "boolean",
    "comment" : "\n     * Reconnect to the currently active access point, even if we are already\n     * connected. This may result in the asynchronous delivery of state\n     * change events.\n     * @return {@code true} if the operation succeeded\n     *\n     * @deprecated\n     * a) See {@link WifiNetworkSpecifier.Builder#build()} for new\n     * mechanism to trigger connection to a Wi-Fi network.\n     * b) See {@link #addNetworkSuggestions(List)},\n     * {@link #removeNetworkSuggestions(List)} for new API to add Wi-Fi networks for consideration\n     * when auto-connecting to wifi.\n     * <b>Compatibility Note:</b> For applications targeting\n     * {@link android.os.Build.VERSION_CODES#Q} or above, this API will always return false.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#Q", "WifiNetworkSpecifier.Builder#build()", "#removeNetworkSuggestions(List)", "#addNetworkSuggestions(List)" ]
  }, {
    "name" : "public boolean pingSupplicant()",
    "returnType" : "boolean",
    "comment" : "\n     * Check that the supplicant daemon is responding to requests.\n     * @return {@code true} if we were able to communicate with the supplicant and\n     * it returned the expected response to the PING message.\n     * @deprecated Will return the output of {@link #isWifiEnabled()} instead.\n     ",
    "links" : [ "#isWifiEnabled()" ]
  }, {
    "name" : "private long getSupportedFeatures()",
    "returnType" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean isFeatureSupported(long feature)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isPasspointSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this adapter supports Passpoint\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isP2pSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this adapter supports WifiP2pManager (Wi-Fi Direct)\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isPortableHotspotSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this adapter supports portable Wi-Fi hotspot\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isWifiScannerSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this adapter supports WifiScanner APIs\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isWifiAwareSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this adapter supports Neighbour Awareness Network APIs\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isStaApConcurrencySupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Query whether or not the device supports Station (STA) + Access point (AP) concurrency.\n     *\n     * @return true if this device supports STA + AP concurrency, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isStaConcurrencyForLocalOnlyConnectionsSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Query whether or not the device supports concurrent station (STA) connections for local-only\n     * connections using {@link WifiNetworkSpecifier}.\n     *\n     * @return true if this device supports multiple STA concurrency for this use-case, false\n     * otherwise.\n     ",
    "links" : [ "android.net.wifi.WifiNetworkSpecifier" ]
  }, {
    "name" : "public boolean isMakeBeforeBreakWifiSwitchingSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Query whether or not the device supports concurrent station (STA) connections for\n     * make-before-break wifi to wifi switching.\n     *\n     * Note: This is an internal feature which is not available to apps.\n     *\n     * @return true if this device supports multiple STA concurrency for this use-case, false\n     * otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isStaConcurrencyForMultiInternetSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Query whether or not the device supports concurrent station (STA) connections for multi\n     * internet connections.\n     *\n     * @return true if this device supports multiple STA concurrency for this use-case, false\n     * otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isStaConcurrencyForRestrictedConnectionsSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Query whether or not the device supports concurrent station (STA) connections for restricted\n     * connections using {@link WifiNetworkSuggestion.Builder#setOemPaid(boolean)} /\n     * {@link WifiNetworkSuggestion.Builder#setOemPrivate(boolean)}.\n     *\n     * @return true if this device supports multiple STA concurrency for this use-case, false\n     * otherwise.\n     * @hide\n     ",
    "links" : [ "WifiNetworkSuggestion.Builder#setOemPaid(boolean)", "WifiNetworkSuggestion.Builder#setOemPrivate(boolean)" ]
  }, {
    "name" : "public boolean isDeviceToDeviceRttSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @deprecated Please use {@link android.content.pm.PackageManager#hasSystemFeature(String)}\n     * with {@link android.content.pm.PackageManager#FEATURE_WIFI_RTT} and\n     * {@link android.content.pm.PackageManager#FEATURE_WIFI_AWARE}.\n     *\n     * @return true if this adapter supports Device-to-device RTT\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#hasSystemFeature(String)", "android.content.pm.PackageManager#FEATURE_WIFI_AWARE", "android.content.pm.PackageManager#FEATURE_WIFI_RTT" ]
  }, {
    "name" : "public boolean isDeviceToApRttSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @deprecated Please use {@link android.content.pm.PackageManager#hasSystemFeature(String)}\n     * with {@link android.content.pm.PackageManager#FEATURE_WIFI_RTT}.\n     *\n     * @return true if this adapter supports Device-to-AP RTT\n     ",
    "links" : [ "android.content.pm.PackageManager#hasSystemFeature(String)", "android.content.pm.PackageManager#FEATURE_WIFI_RTT" ]
  }, {
    "name" : "public boolean isPreferredNetworkOffloadSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this adapter supports offloaded connectivity scan\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isTdlsSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this adapter supports Tunnel Directed Link Setup\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isOffChannelTdlsSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this adapter supports Off Channel Tunnel Directed Link Setup\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isEnhancedPowerReportingSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this adapter supports advanced power/performance counters\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isConnectedMacRandomizationSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this device supports connected MAC randomization.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isApMacRandomizationSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this device supports AP MAC randomization.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isLowLatencyModeSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this device supports Low latency mode.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean is24GHzBandSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the chipset supports 2.4GHz band.\n     * @return {@code true} if supported, {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean is5GHzBandSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the chipset supports 5GHz band.\n     * @return {@code true} if supported, {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean is60GHzBandSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the chipset supports the 60GHz frequency band.\n     *\n     * @return {@code true} if supported, {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean is6GHzBandSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the chipset supports 6GHz band.\n     * @return {@code true} if supported, {@code false} otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isWifiStandardSupported(@WifiAnnotations.WifiStandard int standard)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the chipset supports a certain Wi-Fi standard.\n     * @param standard the IEEE 802.11 standard to check on.\n     *        valid values from {@link ScanResult}'s {@code WIFI_STANDARD_}\n     * @return {@code true} if supported, {@code false} otherwise.\n     ",
    "links" : [ "android.net.wifi.ScanResult" ]
  }, {
    "name" : "public boolean isStaBridgedApConcurrencySupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Query whether or not the device supports concurrency of Station (STA) + multiple access\n     * points (AP) (where the APs bridged together).\n     *\n     * @return true if this device supports concurrency of STA + multiple APs which are bridged\n     *         together, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isBridgedApConcurrencySupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Query whether or not the device supports multiple Access point (AP) which are bridged\n     * together.\n     *\n     * @return true if this device supports concurrency of multiple AP which bridged together,\n     *         false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isD2dSupportedWhenInfraStaDisabled()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this devices supports device-to-device (D2d) Wi-Fi use-cases\n     * such as Wi-Fi Direct when infra station (STA) is disabled.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void getWifiActivityEnergyInfoAsync(@NonNull @CallbackExecutor Executor executor, @NonNull OnWifiActivityEnergyInfoListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Request to get the current {@link WifiActivityEnergyInfo} asynchronously.\n     * Note: This method will return null if {@link #isEnhancedPowerReportingSupported()} returns\n     * false.\n     *\n     * @param executor the executor that the listener will be invoked on\n     * @param listener the listener that will receive the {@link WifiActivityEnergyInfo} object\n     *                 when it becomes available. The listener will be triggered at most once for\n     *                 each call to this method.\n     *\n     * @hide\n     ",
    "links" : [ "android.os.connectivity.WifiActivityEnergyInfo", "#isEnhancedPowerReportingSupported()" ]
  }, {
    "name" : "public boolean startScan()",
    "returnType" : "boolean",
    "comment" : "\n     * Request a scan for access points. Returns immediately. The availability\n     * of the results is made known later by means of an asynchronous event sent\n     * on completion of the scan.\n     * <p>\n     * To initiate a Wi-Fi scan, declare the\n     * {@link android.Manifest.permission#CHANGE_WIFI_STATE}\n     * permission in the manifest, and perform these steps:\n     * </p>\n     * <ol style=\"1\">\n     * <li>Invoke the following method:\n     * {@code ((WifiManager) getSystemService(WIFI_SERVICE)).startScan()}</li>\n     * <li>\n     * Register a BroadcastReceiver to listen to\n     * {@code SCAN_RESULTS_AVAILABLE_ACTION}.</li>\n     * <li>When a broadcast is received, call:\n     * {@code ((WifiManager) getSystemService(WIFI_SERVICE)).getScanResults()}</li>\n     * </ol>\n     * @return {@code true} if the operation succeeded, i.e., the scan was initiated.\n     * @deprecated The ability for apps to trigger scan requests will be removed in a future\n     * release.\n     ",
    "links" : [ "android.Manifest.permission#CHANGE_WIFI_STATE" ]
  }, {
    "name" : "public boolean startScan(WorkSource workSource)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public String getCurrentNetworkWpsNfcConfigurationToken()",
    "returnType" : "String",
    "comment" : "\n     * WPS has been deprecated from Client mode operation.\n     *\n     * @return null\n     * @hide\n     * @deprecated This API is deprecated\n     ",
    "links" : [ ]
  }, {
    "name" : "public WifiInfo getConnectionInfo()",
    "returnType" : "WifiInfo",
    "comment" : "\n     * Return dynamic information about the current Wi-Fi connection, if any is active.\n     * <p>\n     *\n     * @return the Wi-Fi information, contained in {@link WifiInfo}.\n     *\n     * @deprecated Starting with {@link Build.VERSION_CODES#S}, WifiInfo retrieval is moved to\n     * {@link ConnectivityManager} API surface. WifiInfo is attached in\n     * {@link NetworkCapabilities#getTransportInfo()} which is available via callback in\n     * {@link NetworkCallback#onCapabilitiesChanged(Network, NetworkCapabilities)} or on-demand from\n     * {@link ConnectivityManager#getNetworkCapabilities(Network)}.\n     *\n     *</p>\n     * Usage example:\n     * <pre>\n     * final NetworkRequest request =\n     *      new NetworkRequest.Builder()\n     *      .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)\n     *      .build();\n     * final ConnectivityManager connectivityManager =\n     *      context.getSystemService(ConnectivityManager.class);\n     * final NetworkCallback networkCallback = new NetworkCallback() {\n     *      ...\n     *      &#64;Override\n     *      void onAvailable(Network network) {}\n     *\n     *      &#64;Override\n     *      void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) {\n     *          WifiInfo wifiInfo = (WifiInfo) networkCapabilities.getTransportInfo();\n     *      }\n     *      // etc.\n     * };\n     * connectivityManager.requestNetwork(request, networkCallback); // For request\n     * connectivityManager.registerNetworkCallback(request, networkCallback); // For listen\n     * </pre>\n     * <p>\n     * <b>Compatibility Notes:</b>\n     * <li>Apps can continue using this API, however newer features\n     * such as ability to mask out location sensitive data in WifiInfo will not be supported\n     * via this API. </li>\n     * <li>On devices supporting concurrent connections (indicated via\n     * {@link #isStaConcurrencyForLocalOnlyConnectionsSupported()}, etc) this API will return\n     * the details of the internet providing connection (if any) to all apps, except for the apps\n     * that triggered the creation of the concurrent connection. For such apps, this API will return\n     * the details of the connection they created. e.g. apps using {@link WifiNetworkSpecifier} will\n     * trigger a concurrent connection on supported devices and hence this API will provide\n     * details of their peer to peer connection (not the internet providing connection). This\n     * is to maintain backwards compatibility with behavior on single STA devices.</li>\n     * </p>\n     ",
    "links" : [ "android.net.ConnectivityManager", "Build.VERSION_CODES#S", "android.net.wifi.WifiInfo", "android.net.ConnectivityManager#getNetworkCapabilities(Network)", "android.net.NetworkCapabilities#getTransportInfo()", "android.net.wifi.WifiNetworkSpecifier", "android.net.ConnectivityManager.NetworkCallback#onCapabilitiesChanged(Network", "#isStaConcurrencyForLocalOnlyConnectionsSupported()" ]
  }, {
    "name" : "public List<ScanResult> getScanResults()",
    "returnType" : "List<ScanResult>",
    "comment" : "\n     * Return the results of the latest access point scan.\n     * @return the list of access points found in the most recent scan. An app must hold\n     * {@link android.Manifest.permission#ACCESS_FINE_LOCATION ACCESS_FINE_LOCATION} permission\n     * and {@link android.Manifest.permission#ACCESS_WIFI_STATE} permission\n     * in order to get valid results.\n     *\n     * <p>\n     * When an Access Points beacon or probe response includes a Multi-BSSID Element, the\n     * returned scan results should include separate scan result for each BSSID within the\n     * Multi-BSSID Information Element. This includes both transmitted and non-transmitted BSSIDs.\n     * Original Multi-BSSID Element will be included in the Information Elements attached to\n     * each of the scan results.\n     * Note: This is the expected behavior for devices supporting 11ax (WiFi-6) and above, and an\n     * optional requirement for devices running with older WiFi generations.\n     * </p>\n     ",
    "links" : [ "android.Manifest.permission#ACCESS_FINE_LOCATION", "android.Manifest.permission#ACCESS_WIFI_STATE" ]
  }, {
    "name" : "public Map<WifiNetworkSuggestion, List<ScanResult>> getMatchingScanResults(@NonNull List<WifiNetworkSuggestion> networkSuggestionsToMatch, @Nullable List<ScanResult> scanResults)",
    "returnType" : "Map<WifiNetworkSuggestion, List<ScanResult>>",
    "comment" : "\n     * Get the filtered ScanResults which match the network configurations specified by the\n     * {@code networkSuggestionsToMatch}. Suggestions which use {@link WifiConfiguration} use\n     * SSID and the security type to match. Suggestions which use {@link PasspointConfigration}\n     * use the matching rules of Hotspot 2.0.\n     * @param networkSuggestionsToMatch The list of {@link WifiNetworkSuggestion} to match against.\n     * These may or may not be suggestions which are installed on the device.\n     * @param scanResults The scan results to be filtered. Optional - if not provided(empty list),\n     * the Wi-Fi service will use the most recent scan results which the system has.\n     * @return The map of {@link WifiNetworkSuggestion} to the list of {@link ScanResult}\n     * corresponding to networks which match them.\n     * @hide\n     ",
    "links" : [ "android.net.wifi.ScanResult", "android.net.wifi.WifiNetworkSuggestion", "PasspointConfigration", "android.net.wifi.WifiConfiguration" ]
  }, {
    "name" : "public void setScanAlwaysAvailable(boolean isAvailable)",
    "returnType" : "void",
    "comment" : "\n     * Set if scanning is always available.\n     *\n     * If set to {@code true}, apps can issue {@link #startScan} and fetch scan results\n     * even when Wi-Fi is turned off.\n     *\n     * @param isAvailable true to enable, false to disable.\n     * @hide\n     * @see #isScanAlwaysAvailable()\n     ",
    "links" : [ "#startScan" ]
  }, {
    "name" : "public boolean isScanAlwaysAvailable()",
    "returnType" : "boolean",
    "comment" : "\n     * Check if scanning is always available.\n     *\n     * If this return {@code true}, apps can issue {@link #startScan} and fetch scan results\n     * even when Wi-Fi is turned off.\n     *\n     * To change this setting, see {@link #ACTION_REQUEST_SCAN_ALWAYS_AVAILABLE}.\n     * @deprecated The ability for apps to trigger scan requests will be removed in a future\n     * release.\n     ",
    "links" : [ "#startScan", "#ACTION_REQUEST_SCAN_ALWAYS_AVAILABLE" ]
  }, {
    "name" : "public void getChannelData(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<List<Bundle>> resultsCallback)",
    "returnType" : "void",
    "comment" : "\n     * Get channel data such as the number of APs found on each channel from the most recent scan.\n     * App requires {@link android.Manifest.permission#NEARBY_WIFI_DEVICES}\n     *\n     * @param executor        The executor on which callback will be invoked.\n     * @param resultsCallback A callback that will return {@code List<Bundle>} containing channel\n     *                       data such as the number of APs found on each channel.\n     *                       {@link WifiManager#CHANNEL_DATA_KEY_FREQUENCY_MHZ} and\n     *                       {@link WifiManager#CHANNEL_DATA_KEY_NUM_AP} are used to get\n     *                       the frequency (Mhz) and number of APs.\n     * @throws UnsupportedOperationException if the API is not supported on this SDK version.\n     * @throws SecurityException             if the caller does not have permission.\n     * @throws NullPointerException          if the caller provided invalid inputs.\n     ",
    "links" : [ "android.net.wifi.WifiManager#CHANNEL_DATA_KEY_FREQUENCY_MHZ", "android.net.wifi.WifiManager#CHANNEL_DATA_KEY_NUM_AP", "android.Manifest.permission#NEARBY_WIFI_DEVICES" ]
  }, {
    "name" : "public boolean saveConfiguration()",
    "returnType" : "boolean",
    "comment" : "\n     * Tell the device to persist the current list of configured networks.\n     * <p>\n     * Note: It is possible for this method to change the network IDs of\n     * existing networks. You should assume the network IDs can be different\n     * after calling this method.\n     *\n     * @return {@code false}.\n     * @deprecated There is no need to call this method -\n     * {@link #addNetwork(WifiConfiguration)}, {@link #updateNetwork(WifiConfiguration)}\n     * and {@link #removeNetwork(int)} already persist the configurations automatically.\n     ",
    "links" : [ "#addNetwork(WifiConfiguration)", "#removeNetwork(int)", "#updateNetwork(WifiConfiguration)" ]
  }, {
    "name" : "public void registerActiveCountryCodeChangedCallback(@NonNull @CallbackExecutor Executor executor, @NonNull ActiveCountryCodeChangedCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Add the provided callback for the active country code changed event.\n     * Caller will receive either\n     * {@link WifiManager.ActiveCountryCodeChangedCallback#onActiveCountryCodeChanged(String)}\n     * or {@link WifiManager.ActiveCountryCodeChangedCallback#onCountryCodeInactive()}\n     * on registration.\n     *\n     * Note: When the global location setting is off or the caller does not have runtime location\n     * permission, caller will not receive the callback even if caller register callback succeeded.\n     *\n     *\n     * Caller can remove a previously registered callback using\n     * {@link WifiManager#unregisterActiveCountryCodeChangedCallback(\n     * ActiveCountryCodeChangedCallback)}.\n     *\n     * <p>\n     * Note:\n     * The value provided by\n     * {@link WifiManager.ActiveCountryCodeChangedCallback#onActiveCountryCodeChanged(String)}\n     * may be different from the returned value from {@link WifiManager#getCountryCode()} even if\n     * the Wi-Fi subsystem is active. See: {@link WifiManager#getCountryCode()} for details.\n     * </p>\n     *\n     * @param executor The Executor on which to execute the callbacks.\n     * @param callback callback for the driver country code changed events.\n     * @hide\n     ",
    "links" : [ "WifiManager.ActiveCountryCodeChangedCallback#onCountryCodeInactive()", "android.net.wifi.WifiManager#getCountryCode()", "WifiManager.ActiveCountryCodeChangedCallback#onActiveCountryCodeChanged(String)", "android.net.wifi.WifiManager#unregisterActiveCountryCodeChangedCallback(" ]
  }, {
    "name" : "public void unregisterActiveCountryCodeChangedCallback(@NonNull ActiveCountryCodeChangedCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Allow callers to remove a previously registered listener. After calling this method,\n     * applications will no longer receive the active country code changed events through that\n     * callback.\n     *\n     * @param callback Callback to remove the active country code changed events.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addWifiNetworkStateChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull WifiNetworkStateChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Add a listener to listen to Wi-Fi network state changes on available client mode roles\n     * specified in {@link WifiNetworkStateChangedListener.WifiClientModeRole}.\n     * When wifi state changes such as connected/disconnect happens, results will be delivered via\n     * {@link WifiNetworkStateChangedListener#onWifiNetworkStateChanged(int, int)}.\n     *\n     * @param executor The Executor on which to execute the callbacks.\n     * @param listener listener for the network status updates.\n     * @throws SecurityException if the caller is missing required permissions.\n     * @throws IllegalArgumentException if incorrect input arguments are provided.\n     * @hide\n     ",
    "links" : [ "#onWifiNetworkStateChanged(int", "WifiNetworkStateChangedListener.WifiClientModeRole" ]
  }, {
    "name" : "public void removeWifiNetworkStateChangedListener(@NonNull WifiNetworkStateChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Remove a listener added using\n     * {@link #addWifiNetworkStateChangedListener(Executor, WifiNetworkStateChangedListener)}.\n     * @param listener the listener to be removed.\n     * @throws IllegalArgumentException if incorrect input arguments are provided.\n     * @hide\n     ",
    "links" : [ "#addWifiNetworkStateChangedListener(Executor" ]
  }, {
    "name" : "public String getCountryCode()",
    "returnType" : "String",
    "comment" : "\n     * Get the country code as resolved by the Wi-Fi framework.\n     * The Wi-Fi framework uses multiple sources to resolve a country code\n     * - in order of priority (high to low):\n     * 1. Override country code set by {@link WifiManager#setOverrideCountryCode(String)}\n     * and cleared by {@link WifiManager#clearOverrideCountryCode()}. Typically only used\n     * for testing.\n     * 2. Country code supplied by the telephony module. Typically provided from the\n     * current network or from emergency cell information.\n     * 3. Country code supplied by the wifi driver module. (802.11d)\n     * 4. Default country code set either via {@code ro.boot.wificountrycode}\n     * or the {@link WifiManager#setDefaultCountryCode(String)}.\n     *\n     * <p>\n     * Note:\n     * This method returns the Country Code value used by the framework - even if not currently\n     * used by the Wi-Fi subsystem. I.e. the returned value from this API may be different from the\n     * value provided by\n     * {@link WifiManager.ActiveCountryCodeChangedCallback#onActiveCountryCodeChanged(String)}.\n     * Such a difference may happen when there is an ongoing network connection (STA, AP, Direct,\n     * or Aware) and the Wi-Fi subsystem does not support dynamic updates - at that point the\n     * framework may defer setting the Country Code to the Wi-Fi subsystem.\n     * </p>\n     * @return the country code in ISO 3166 alpha-2 (2-letter) upper format,\n     * or null if there is no country code configured.\n     *\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#setDefaultCountryCode(String)", "WifiManager.ActiveCountryCodeChangedCallback#onActiveCountryCodeChanged(String)", "android.net.wifi.WifiManager#clearOverrideCountryCode()", "android.net.wifi.WifiManager#setOverrideCountryCode(String)" ]
  }, {
    "name" : "public void setOverrideCountryCode(@NonNull String country)",
    "returnType" : "void",
    "comment" : "\n     * Set the override country code - may be used for testing. See the country code resolution\n     * order and format in {@link #getCountryCode()}.\n     * @param country A 2-Character alphanumeric country code.\n     * @see #getCountryCode().\n     *\n     * @hide\n     ",
    "links" : [ "#getCountryCode()" ]
  }, {
    "name" : "public void clearOverrideCountryCode()",
    "returnType" : "void",
    "comment" : "\n     * This clears the override country code which was previously set by\n     * {@link WifiManager#setOverrideCountryCode(String)} method.\n     * @see #getCountryCode().\n     *\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#setOverrideCountryCode(String)" ]
  }, {
    "name" : "public void setDefaultCountryCode(@NonNull String country)",
    "returnType" : "void",
    "comment" : "\n     * Used to configure the default country code. See {@link #getCountryCode()} for resolution\n     * method of the country code.\n     * @param country A 2-character alphanumeric country code.\n     * @see #getCountryCode().\n     *\n     * @hide\n     ",
    "links" : [ "#getCountryCode()" ]
  }, {
    "name" : "public DhcpInfo getDhcpInfo()",
    "returnType" : "DhcpInfo",
    "comment" : "\n     * Return the DHCP-assigned addresses from the last successful DHCP request,\n     * if any.\n     *\n     * @return the DHCP information\n     *\n     * @deprecated Use the methods on {@link android.net.LinkProperties} which can be obtained\n     * either via {@link NetworkCallback#onLinkPropertiesChanged(Network, LinkProperties)} or\n     * {@link ConnectivityManager#getLinkProperties(Network)}.\n     *\n     * <p>\n     * <b>Compatibility Notes:</b>\n     * <li>On devices supporting concurrent connections (indicated via\n     * {@link #isStaConcurrencyForLocalOnlyConnectionsSupported()}, etc), this API will return\n     * the details of the internet providing connection (if any) to all apps, except for the apps\n     * that triggered the creation of the concurrent connection. For such apps, this API will return\n     * the details of the connection they created. e.g. apps using {@link WifiNetworkSpecifier} will\n     * trigger a concurrent connection on supported devices and hence this API will provide\n     * details of their peer to peer connection (not the internet providing connection). This\n     * is to maintain backwards compatibility with behavior on single STA devices.</li>\n     * </p>\n     ",
    "links" : [ "android.net.ConnectivityManager.NetworkCallback#onLinkPropertiesChanged(Network", "android.net.wifi.WifiNetworkSpecifier", "android.net.LinkProperties", "android.net.ConnectivityManager#getLinkProperties(Network)", "#isStaConcurrencyForLocalOnlyConnectionsSupported()" ]
  }, {
    "name" : "public boolean setWifiEnabled(boolean enabled)",
    "returnType" : "boolean",
    "comment" : "\n     * Enable or disable Wi-Fi.\n     * <p>\n     * Applications must have the {@link android.Manifest.permission#CHANGE_WIFI_STATE}\n     * permission to toggle wifi.\n     *\n     * @param enabled {@code true} to enable, {@code false} to disable.\n     * @return {@code false} if the request cannot be satisfied; {@code true} indicates that wifi is\n     *         either already in the requested state, or in progress toward the requested state.\n     * @throws  SecurityException if the caller is missing required permissions.\n     *\n     * @deprecated Starting with Build.VERSION_CODES#Q, applications are not allowed to\n     * enable/disable Wi-Fi.\n     * <b>Compatibility Note:</b> For applications targeting\n     * {@link android.os.Build.VERSION_CODES#Q} or above, this API will always fail and return\n     * {@code false}. If apps are targeting an older SDK ({@link android.os.Build.VERSION_CODES#P}\n     * or below), they can continue to use this API.\n     * <p>\n     * Deprecation Exemptions:\n     * <ul>\n     * <li>Device Owner (DO), Profile Owner (PO) and system apps.\n     * </ul>\n     *\n     * Starting with {@link android.os.Build.VERSION_CODES#TIRAMISU}, DO/COPE may set\n     * a user restriction (DISALLOW_CHANGE_WIFI_STATE) to only allow DO/PO to use this API.\n     ",
    "links" : [ "android.os.Build.VERSION_CODES#P", "android.os.Build.VERSION_CODES#TIRAMISU", "android.os.Build.VERSION_CODES#Q", "android.Manifest.permission#CHANGE_WIFI_STATE" ]
  }, {
    "name" : "public void registerSubsystemRestartTrackingCallback(@NonNull @CallbackExecutor Executor executor, @NonNull SubsystemRestartTrackingCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Registers a {@link SubsystemRestartTrackingCallback} to listen to Wi-Fi subsystem restarts.\n     * The subsystem may restart due to internal recovery mechanisms or via user action.\n     *\n     * @see #unregisterSubsystemRestartTrackingCallback(SubsystemRestartTrackingCallback)\n     *\n     * @param executor Executor to execute callback on\n     * @param callback {@link SubsystemRestartTrackingCallback} to register\n     ",
    "links" : [ "SubsystemRestartTrackingCallback" ]
  }, {
    "name" : "public void unregisterSubsystemRestartTrackingCallback(@NonNull SubsystemRestartTrackingCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters a {@link SubsystemRestartTrackingCallback} registered with\n     * {@link #registerSubsystemRestartTrackingCallback(Executor, SubsystemRestartTrackingCallback)}\n     *\n     * @param callback {@link SubsystemRestartTrackingCallback} to unregister\n     ",
    "links" : [ "#registerSubsystemRestartTrackingCallback(Executor", "SubsystemRestartTrackingCallback" ]
  }, {
    "name" : "public void restartWifiSubsystem()",
    "returnType" : "void",
    "comment" : "\n     * Restart the Wi-Fi subsystem.\n     *\n     * Restarts the Wi-Fi subsystem - effectively disabling it and re-enabling it. All existing\n     * Access Point (AP) associations are torn down, all Soft APs are disabled, Wi-Fi Direct and\n     * Wi-Fi Aware are disabled.\n     *\n     * The state of the system after restart is not guaranteed to match its state before the API is\n     * called - for instance the device may associate to a different Access Point (AP), and tethered\n     * hotspots may or may not be restored.\n     *\n     * Use the\n     * {@link #registerSubsystemRestartTrackingCallback(Executor, SubsystemRestartTrackingCallback)}\n     * to track the operation.\n     *\n     * @hide\n     ",
    "links" : [ "#registerSubsystemRestartTrackingCallback(Executor" ]
  }, {
    "name" : "public int getWifiState()",
    "returnType" : "int",
    "comment" : "\n     * Gets the Wi-Fi enabled state.\n     * @return One of {@link #WIFI_STATE_DISABLED},\n     *         {@link #WIFI_STATE_DISABLING}, {@link #WIFI_STATE_ENABLED},\n     *         {@link #WIFI_STATE_ENABLING}, {@link #WIFI_STATE_UNKNOWN}\n     * @see #isWifiEnabled()\n     ",
    "links" : [ "#WIFI_STATE_DISABLED", "#WIFI_STATE_ENABLED", "#WIFI_STATE_UNKNOWN", "#WIFI_STATE_ENABLING", "#WIFI_STATE_DISABLING" ]
  }, {
    "name" : "public boolean isWifiEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether Wi-Fi is enabled or disabled.\n     * @return {@code true} if Wi-Fi is enabled\n     * @see #getWifiState()\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int calculateSignalLevel(int rssi, int numLevels)",
    "returnType" : "int",
    "comment" : "\n     * Calculates the level of the signal. This should be used any time a signal\n     * is being shown.\n     *\n     * @param rssi The power of the signal measured in RSSI.\n     * @param numLevels The number of levels to consider in the calculated level.\n     * @return A level of the signal, given in the range of 0 to numLevels-1 (both inclusive).\n     * @deprecated Callers should use {@link #calculateSignalLevel(int)} instead to get the\n     * signal level using the system default RSSI thresholds, or otherwise compute the RSSI level\n     * themselves using their own formula.\n     ",
    "links" : [ "#calculateSignalLevel(int)" ]
  }, {
    "name" : "public int calculateSignalLevel(int rssi)",
    "returnType" : "int",
    "comment" : "\n     * Given a raw RSSI, return the RSSI signal quality rating using the system default RSSI\n     * quality rating thresholds.\n     * @param rssi a raw RSSI value, in dBm, usually between -55 and -90\n     * @return the RSSI signal quality rating, in the range\n     * [0, {@link #getMaxSignalLevel()}], where 0 is the lowest (worst signal) RSSI\n     * rating and {@link #getMaxSignalLevel()} is the highest (best signal) RSSI rating.\n     ",
    "links" : [ "#getMaxSignalLevel()" ]
  }, {
    "name" : "public int getMaxSignalLevel()",
    "returnType" : "int",
    "comment" : "\n     * Get the system default maximum signal level.\n     * This is the maximum RSSI level returned by {@link #calculateSignalLevel(int)}.\n     ",
    "links" : [ "#calculateSignalLevel(int)" ]
  }, {
    "name" : "public static int compareSignalLevel(int rssiA, int rssiB)",
    "returnType" : "int",
    "comment" : "\n     * Compares two signal strengths.\n     *\n     * @param rssiA The power of the first signal measured in RSSI.\n     * @param rssiB The power of the second signal measured in RSSI.\n     * @return Returns <0 if the first signal is weaker than the second signal,\n     *         0 if the two signals have the same strength, and >0 if the first\n     *         signal is stronger than the second signal.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void updateInterfaceIpState(@Nullable String ifaceName, @IfaceIpMode int mode)",
    "returnType" : "void",
    "comment" : "\n     * Call allowing ConnectivityService to update WifiService with interface mode changes.\n     *\n     * @param ifaceName String name of the updated interface, or null to represent all interfaces\n     * @param mode int representing the new mode, one of:\n     *             {@link #IFACE_IP_MODE_TETHERED},\n     *             {@link #IFACE_IP_MODE_LOCAL_ONLY},\n     *             {@link #IFACE_IP_MODE_CONFIGURATION_ERROR},\n     *             {@link #IFACE_IP_MODE_UNSPECIFIED}\n     *\n     * @hide\n     ",
    "links" : [ "#IFACE_IP_MODE_CONFIGURATION_ERROR", "#IFACE_IP_MODE_UNSPECIFIED", "#IFACE_IP_MODE_TETHERED", "#IFACE_IP_MODE_LOCAL_ONLY" ]
  }, {
    "name" : "public boolean isDefaultCoexAlgorithmEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * @return {@code true} if the default coex algorithm is enabled. {@code false} otherwise.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCoexUnsafeChannels(@NonNull List<CoexUnsafeChannel> unsafeChannels, @CoexRestriction int restrictions)",
    "returnType" : "void",
    "comment" : "\n     * Specify the list of {@link CoexUnsafeChannel} to propagate through the framework for\n     * Wi-Fi/Cellular coex channel avoidance if the default algorithm is disabled via overlay\n     * (i.e. config_wifiCoexDefaultAlgorithmEnabled = false). Otherwise do nothing.\n     *\n     * @param unsafeChannels List of {@link CoexUnsafeChannel} to avoid.\n     * @param restrictions Bitmap of {@code COEX_RESTRICTION_*} constants specifying the mode\n     *                     restrictions on the specified channels. If any restrictions are set,\n     *                     then the supplied CoexUnsafeChannels should be completely avoided for\n     *                     the specified modes, rather than be avoided with best effort.\n     *\n     * @hide\n     ",
    "links" : [ "android.net.wifi.CoexUnsafeChannel" ]
  }, {
    "name" : "public void registerCoexCallback(@NonNull @CallbackExecutor Executor executor, @NonNull CoexCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Registers a CoexCallback to listen on the current CoexUnsafeChannels and restrictions being\n     * used for Wi-Fi/cellular coex channel avoidance. The callback method\n     * {@link CoexCallback#onCoexUnsafeChannelsChanged(List, int)} will be called immediately after\n     * registration to return the current values.\n     *\n     * @param executor Executor to execute listener callback on\n     * @param callback CoexCallback to register\n     *\n     * @hide\n     ",
    "links" : [ "#onCoexUnsafeChannelsChanged(List" ]
  }, {
    "name" : "public void unregisterCoexCallback(@NonNull CoexCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Unregisters a CoexCallback from listening on the current CoexUnsafeChannels and restrictions\n     * being used for Wi-Fi/cellular coex channel avoidance.\n     * @param callback CoexCallback to unregister\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean startSoftAp(@Nullable WifiConfiguration wifiConfig)",
    "returnType" : "boolean",
    "comment" : "\n     * Start Soft AP (hotspot) mode for tethering purposes with the specified configuration.\n     * Note that starting Soft AP mode may disable station mode operation if the device does not\n     * support concurrency.\n     * @param wifiConfig SSID, security and channel details as part of WifiConfiguration, or null to\n     *                   use the persisted Soft AP configuration that was previously set using\n     *                   {@link #setWifiApConfiguration(WifiConfiguration)}.\n     * @return {@code true} if the operation succeeded, {@code false} otherwise\n     *\n     * @hide\n     ",
    "links" : [ "#setWifiApConfiguration(WifiConfiguration)" ]
  }, {
    "name" : "public boolean startTetheredHotspot(@Nullable SoftApConfiguration softApConfig)",
    "returnType" : "boolean",
    "comment" : "\n     * Start Soft AP (hotspot) mode for tethering purposes with the specified configuration.\n     * Note that starting Soft AP mode may disable station mode operation if the device does not\n     * support concurrency.\n     *\n     * Note: Call {@link WifiManager#validateSoftApConfiguration(SoftApConfiguration)} to avoid\n     * unexpected error due to invalid configuration.\n     *\n     * @param softApConfig A valid SoftApConfiguration specifying the configuration of the SAP, or\n     *                     null to use the persisted Soft AP configuration that was previously set\n     *                     using {@link WifiManager#setSoftApConfiguration(SoftApConfiguration)}.\n     * @return {@code true} if the operation succeeded, {@code false} otherwise\n     *\n     * @deprecated Use {@link #startTetheredHotspot(TetheringManager.TetheringRequest)}\n     *             instead.\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#setSoftApConfiguration(SoftApConfiguration)", "android.net.wifi.WifiManager#validateSoftApConfiguration(SoftApConfiguration)", "#startTetheredHotspot(TetheringManager.TetheringRequest)" ]
  }, {
    "name" : "public void startTetheredHotspot(@NonNull TetheringManager.TetheringRequest request, @NonNull @CallbackExecutor Executor executor, @NonNull SoftApCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Start Soft AP (hotspot) mode for tethering purposes with the specified TetheringRequest.\n     * Note that starting Soft AP mode may disable station mode operation if the device does not\n     * support concurrency.\n     *\n     * @param request  A valid TetheringRequest specifying the configuration of the SAP.\n     * @param executor Executor to run the callback on.\n     * @param callback Callback to listen on state changes for this specific request.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean stopSoftAp()",
    "returnType" : "boolean",
    "comment" : "\n     * Stop SoftAp mode.\n     * Note that stopping softap mode will restore the previous wifi mode.\n     * @return {@code true} if the operation succeeds, {@code false} otherwise\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean validateSoftApConfiguration(@NonNull SoftApConfiguration config)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if input configuration is valid.\n     *\n     * @param config a configuration would like to be checked.\n     * @return true if config is valid, otherwise false.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startLocalOnlyHotspot(LocalOnlyHotspotCallback callback, @Nullable Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Request a local only hotspot that an application can use to communicate between co-located\n     * devices connected to the created WiFi hotspot.  The network created by this method will not\n     * have Internet access.  Each application can make a single request for the hotspot, but\n     * multiple applications could be requesting the hotspot at the same time.  When multiple\n     * applications have successfully registered concurrently, they will be sharing the underlying\n     * hotspot. {@link LocalOnlyHotspotCallback#onStarted(LocalOnlyHotspotReservation)} is called\n     * when the hotspot is ready for use by the application.\n     * <p>\n     * Each application can make a single active call to this method. The {@link\n     * LocalOnlyHotspotCallback#onStarted(LocalOnlyHotspotReservation)} callback supplies the\n     * requestor with a {@link LocalOnlyHotspotReservation} that contains a\n     * {@link SoftApConfiguration} with the SSID, security type and credentials needed to connect\n     * to the hotspot.  Communicating this information is up to the application.\n     * <p>\n     * If the LocalOnlyHotspot cannot be created, the {@link LocalOnlyHotspotCallback#onFailed(int)}\n     * method will be called. Example failures include errors bringing up the network or if\n     * there is an incompatible operating mode.  For example, if the user is currently using Wifi\n     * Tethering to provide an upstream to another device, LocalOnlyHotspot may not start due to\n     * an incompatible mode. The possible error codes include:\n     * {@link LocalOnlyHotspotCallback#ERROR_NO_CHANNEL},\n     * {@link LocalOnlyHotspotCallback#ERROR_GENERIC},\n     * {@link LocalOnlyHotspotCallback#ERROR_INCOMPATIBLE_MODE} and\n     * {@link LocalOnlyHotspotCallback#ERROR_TETHERING_DISALLOWED}.\n     * <p>\n     * Internally, requests will be tracked to prevent the hotspot from being torn down while apps\n     * are still using it.  The {@link LocalOnlyHotspotReservation} object passed in the  {@link\n     * LocalOnlyHotspotCallback#onStarted(LocalOnlyHotspotReservation)} call should be closed when\n     * the LocalOnlyHotspot is no longer needed using {@link LocalOnlyHotspotReservation#close()}.\n     * Since the hotspot may be shared among multiple applications, removing the final registered\n     * application request will trigger the hotspot teardown.  This means that applications should\n     * not listen to broadcasts containing wifi state to determine if the hotspot was stopped after\n     * they are done using it. Additionally, once {@link LocalOnlyHotspotReservation#close()} is\n     * called, applications will not receive callbacks of any kind.\n     * <p>\n     * Applications should be aware that the user may also stop the LocalOnlyHotspot through the\n     * Settings UI; it is not guaranteed to stay up as long as there is a requesting application.\n     * The requestors will be notified of this case via\n     * {@link LocalOnlyHotspotCallback#onStopped()}.  Other cases may arise where the hotspot is\n     * torn down (Emergency mode, etc).  Application developers should be aware that it can stop\n     * unexpectedly, but they will receive a notification if they have properly registered.\n     * <p>\n     * Applications should also be aware that this network will be shared with other applications.\n     * Applications are responsible for protecting their data on this network (e.g. TLS).\n     * <p>\n     * Applications targeting {@link android.os.Build.VERSION_CODES#TIRAMISU} or later need to have\n     * the following permissions: {@link android.Manifest.permission#CHANGE_WIFI_STATE} and\n     * {@link android.Manifest.permission#NEARBY_WIFI_DEVICES}.\n     * Applications targeting {@link Build.VERSION_CODES#S} or prior SDK levels need to have the\n     * following permissions: {@link android.Manifest.permission#CHANGE_WIFI_STATE} and\n     * {@link android.Manifest.permission#ACCESS_FINE_LOCATION}\n     * Callers without\n     * the permissions will trigger a {@link java.lang.SecurityException}.\n     * <p>\n     * @param callback LocalOnlyHotspotCallback for the application to receive updates about\n     * operating status.\n     * @param handler Handler to be used for callbacks.  If the caller passes a null Handler, the\n     * main thread will be used.\n     ",
    "links" : [ "#onFailed(int)", "#ERROR_INCOMPATIBLE_MODE", "Build.VERSION_CODES#S", "#onStarted(LocalOnlyHotspotReservation)", "#ERROR_GENERIC", "#ERROR_NO_CHANNEL", "#onStopped()", "android.Manifest.permission#NEARBY_WIFI_DEVICES", "LocalOnlyHotspotReservation", "android.net.wifi.SoftApConfiguration", "android.Manifest.permission#CHANGE_WIFI_STATE", "android.os.Build.VERSION_CODES#TIRAMISU", "android.Manifest.permission#ACCESS_FINE_LOCATION", "#ERROR_TETHERING_DISALLOWED", "#close()", "java.lang.SecurityException" ]
  }, {
    "name" : "public void startLocalOnlyHotspot(@NonNull SoftApConfiguration config, @Nullable @CallbackExecutor Executor executor, @Nullable LocalOnlyHotspotCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Starts a local-only hotspot with a specific configuration applied. See\n     * {@link #startLocalOnlyHotspot(LocalOnlyHotspotCallback, Handler)}.\n     *\n     * Applications need either {@link android.Manifest.permission#NETWORK_SETUP_WIZARD},\n     * {@link android.Manifest.permission#NETWORK_SETTINGS} or\n     * {@link android.Manifest.permission#NEARBY_WIFI_DEVICES} to call this method.\n     *\n     * Since custom configuration settings may be incompatible with each other, the hotspot started\n     * through this method cannot coexist with another hotspot created through\n     * startLocalOnlyHotspot. If this is attempted, the first hotspot request wins and others\n     * receive {@link LocalOnlyHotspotCallback#ERROR_GENERIC} through\n     * {@link LocalOnlyHotspotCallback#onFailed}.\n     *\n     * @param config Custom configuration for the hotspot. See {@link SoftApConfiguration}.\n     * @param executor Executor to run callback methods on, or null to use the main thread.\n     * @param callback Callback object for updates about hotspot status, or null for no updates.\n     * @hide\n     ",
    "links" : [ "#startLocalOnlyHotspot(LocalOnlyHotspotCallback", "android.Manifest.permission#NETWORK_SETTINGS", "#ERROR_GENERIC", "#onFailed", "android.Manifest.permission#NEARBY_WIFI_DEVICES", "android.net.wifi.SoftApConfiguration", "android.Manifest.permission#NETWORK_SETUP_WIZARD" ]
  }, {
    "name" : "private void startLocalOnlyHotspotInternal(@Nullable SoftApConfiguration config, @Nullable @CallbackExecutor Executor executor, @Nullable LocalOnlyHotspotCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Common implementation of both configurable and non-configurable LOHS.\n     *\n     * @param config App-specified configuration, or null. When present, additional privileges are\n     *               required, and the hotspot cannot be shared with other clients.\n     * @param executor Executor to run callback methods on, or null to use the main thread.\n     * @param callback Callback object for updates about hotspot status, or null for no updates.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void cancelLocalOnlyHotspotRequest()",
    "returnType" : "void",
    "comment" : "\n     * Cancels a pending local only hotspot request.  This can be used by the calling application to\n     * cancel the existing request if the provided callback has not been triggered.  Calling this\n     * method will be equivalent to closing the returned LocalOnlyHotspotReservation, but it is not\n     * explicitly required.\n     * <p>\n     * When cancelling this request, application developers should be aware that there may still be\n     * outstanding local only hotspot requests and the hotspot may still start, or continue running.\n     * Additionally, if a callback was registered, it will no longer be triggered after calling\n     * cancel.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void stopLocalOnlyHotspot()",
    "returnType" : "void",
    "comment" : "\n     *  Method used to inform WifiService that the LocalOnlyHotspot is no longer needed.  This\n     *  method is used by WifiManager to release LocalOnlyHotspotReservations held by calling\n     *  applications and removes the internal tracking for the hotspot request.  When all requesting\n     *  applications are finished using the hotspot, it will be stopped and WiFi will return to the\n     *  previous operational mode.\n     *\n     *  This method should not be called by applications.  Instead, they should call the close()\n     *  method on their LocalOnlyHotspotReservation.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void registerLocalOnlyHotspotSoftApCallback(@NonNull @CallbackExecutor Executor executor, @NonNull SoftApCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Registers a callback for local only hotspot. See {@link SoftApCallback}. Caller will receive\n     * the following callbacks on registration:\n     * <ul>\n     * <li> {@link SoftApCallback#onStateChanged(int, int)}</li>\n     * <li> {@link SoftApCallback#onConnectedClientsChanged(List<WifiClient>)}</li>\n     * <li> {@link SoftApCallback#onInfoChanged(List<SoftApInfo>)}</li>\n     * <li> {@link SoftApCallback#onCapabilityChanged(SoftApCapability)}</li>\n     * </ul>\n     *\n     * Use {@link SoftApCallback#onConnectedClientsChanged(SoftApInfo, List<WifiClient>)} to know\n     * if there are any clients connected to a specific bridged instance of this AP\n     * (if bridged AP is enabled).\n     *\n     * Note: Caller will receive the callback\n     * {@link SoftApCallback#onConnectedClientsChanged(SoftApInfo, List<WifiClient>)}\n     * on registration when there are clients connected to AP.\n     *\n     * These will be dispatched on registration to provide the caller with the current state\n     * (and are not an indication of any current change). Note that receiving an immediate\n     * WIFI_AP_STATE_FAILED value for soft AP state indicates that the latest attempt to start\n     * soft AP has failed. Caller can unregister a previously registered callback using\n     * {@link #unregisterLocalOnlyHotspotSoftApCallback}\n     * <p>\n     *\n     * @param executor The Executor on whose thread to execute the callbacks of the {@code callback}\n     *                 object.\n     * @param callback Callback for local only hotspot events\n     * @hide\n     ",
    "links" : [ "SoftApCallback", "#onStateChanged(int", "#onCapabilityChanged(SoftApCapability)", "#onConnectedClientsChanged(List", "#onInfoChanged(List", "#unregisterLocalOnlyHotspotSoftApCallback", "#onConnectedClientsChanged(SoftApInfo" ]
  }, {
    "name" : "public void unregisterLocalOnlyHotspotSoftApCallback(@NonNull SoftApCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Allow callers to unregister a previously registered callback. After calling this method,\n     * applications will no longer receive local only hotspot events.\n     *\n     * <p>\n     *\n     * @param callback Callback to unregister for soft AP events\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void watchLocalOnlyHotspot(LocalOnlyHotspotObserver observer, @Nullable Handler handler)",
    "returnType" : "void",
    "comment" : "\n     * Allow callers (Settings UI) to watch LocalOnlyHotspot state changes.  Callers will\n     * receive a {@link LocalOnlyHotspotSubscription} object as a parameter of the\n     * {@link LocalOnlyHotspotObserver#onRegistered(LocalOnlyHotspotSubscription)}. The registered\n     * callers will receive the {@link LocalOnlyHotspotObserver#onStarted(SoftApConfiguration)} and\n     * {@link LocalOnlyHotspotObserver#onStopped()} callbacks.\n     * <p>\n     * Applications should have the\n     * {@link android.Manifest.permission#ACCESS_FINE_LOCATION ACCESS_FINE_LOCATION}\n     * permission.  Callers without the permission will trigger a\n     * {@link java.lang.SecurityException}.\n     * <p>\n     * @param observer LocalOnlyHotspotObserver callback.\n     * @param handler Handler to use for callbacks\n     *\n     * @hide\n     ",
    "links" : [ "LocalOnlyHotspotSubscription", "#onStarted(SoftApConfiguration)", "android.Manifest.permission#ACCESS_FINE_LOCATION", "#onStopped()", "java.lang.SecurityException", "#onRegistered(LocalOnlyHotspotSubscription)" ]
  }, {
    "name" : "public void unregisterLocalOnlyHotspotObserver()",
    "returnType" : "void",
    "comment" : "\n     * Allow callers to stop watching LocalOnlyHotspot state changes.  After calling this method,\n     * applications will no longer receive callbacks.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getWifiApState()",
    "returnType" : "int",
    "comment" : "\n     * Gets the tethered Wi-Fi hotspot enabled state.\n     * @return One of {@link #WIFI_AP_STATE_DISABLED},\n     *         {@link #WIFI_AP_STATE_DISABLING}, {@link #WIFI_AP_STATE_ENABLED},\n     *         {@link #WIFI_AP_STATE_ENABLING}, {@link #WIFI_AP_STATE_FAILED}\n     * @see #isWifiApEnabled()\n     *\n     * @hide\n     ",
    "links" : [ "#WIFI_AP_STATE_DISABLING", "#WIFI_AP_STATE_ENABLED", "#WIFI_AP_STATE_FAILED", "#WIFI_AP_STATE_DISABLED", "#WIFI_AP_STATE_ENABLING" ]
  }, {
    "name" : "public boolean isWifiApEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Return whether tethered Wi-Fi AP is enabled or disabled.\n     * @return {@code true} if tethered  Wi-Fi AP is enabled\n     * @see #getWifiApState()\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public WifiConfiguration getWifiApConfiguration()",
    "returnType" : "WifiConfiguration",
    "comment" : "\n     * Gets the tethered Wi-Fi AP Configuration.\n     * @return AP details in WifiConfiguration\n     *\n     * Note that AP detail may contain configuration which is cannot be represented\n     * by the legacy WifiConfiguration, in such cases a null will be returned.\n     *\n     * @deprecated This API is deprecated. Use {@link #getSoftApConfiguration()} instead.\n     * @hide\n     ",
    "links" : [ "#getSoftApConfiguration()" ]
  }, {
    "name" : "public SoftApConfiguration getSoftApConfiguration()",
    "returnType" : "SoftApConfiguration",
    "comment" : "\n     * Gets the Wi-Fi tethered AP Configuration.\n     * @return AP details in {@link SoftApConfiguration}\n     *\n     * @hide\n     ",
    "links" : [ "android.net.wifi.SoftApConfiguration" ]
  }, {
    "name" : "public void queryLastConfiguredTetheredApPassphraseSinceBoot(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<String> resultCallback)",
    "returnType" : "void",
    "comment" : "\n     * Gets the last configured Wi-Fi tethered AP passphrase.\n     *\n     * Note: It may be null when there is no passphrase changed since\n     * device boot.\n     *\n     * @param executor The executor on which callback will be invoked.\n     * @param resultCallback An asynchronous callback that will return the last configured\n     *                       Wi-Fi tethered AP passphrase.\n     *\n     * @throws SecurityException if the caller does not have permission.\n     * @throws NullPointerException if the caller provided invalid inputs.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setWifiApConfiguration(WifiConfiguration wifiConfig)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets the tethered Wi-Fi AP Configuration.\n     * @return {@code true} if the operation succeeded, {@code false} otherwise\n     *\n     * @deprecated This API is deprecated. Use {@link #setSoftApConfiguration(SoftApConfiguration)}\n     * instead.\n     * @hide\n     ",
    "links" : [ "#setSoftApConfiguration(SoftApConfiguration)" ]
  }, {
    "name" : "public boolean setSoftApConfiguration(@NonNull SoftApConfiguration softApConfig)",
    "returnType" : "boolean",
    "comment" : "\n     * Sets the tethered Wi-Fi AP Configuration.\n     *\n     * If the API is called while the tethered soft AP is enabled, the configuration will apply to\n     * the current soft AP if the new configuration only includes\n     * {@link SoftApConfiguration.Builder#setMaxNumberOfClients(int)}\n     * or {@link SoftApConfiguration.Builder#setShutdownTimeoutMillis(long)}\n     * or {@link SoftApConfiguration.Builder#setClientControlByUserEnabled(boolean)}\n     * or {@link SoftApConfiguration.Builder#setBlockedClientList(List)}\n     * or {@link SoftApConfiguration.Builder#setAllowedClientList(List)}\n     * or {@link SoftApConfiguration.Builder#setAutoShutdownEnabled(boolean)}\n     * or {@link SoftApConfiguration.Builder#setBridgedModeOpportunisticShutdownEnabled(boolean)}\n     *\n     * Otherwise, the configuration changes will be applied when the Soft AP is next started\n     * (the framework will not stop/start the AP).\n     *\n     * Note: Call {@link WifiManager#validateSoftApConfiguration(SoftApConfiguration)} to avoid\n     * unexpected error due to invalid configuration.\n     *\n     * @param softApConfig  A valid SoftApConfiguration specifying the configuration of the SAP.\n     * @return {@code true} if the operation succeeded, {@code false} otherwise\n     *\n     * @hide\n     ",
    "links" : [ "SoftApConfiguration.Builder#setAllowedClientList(List)", "SoftApConfiguration.Builder#setBridgedModeOpportunisticShutdownEnabled(boolean)", "android.net.wifi.WifiManager#validateSoftApConfiguration(SoftApConfiguration)", "SoftApConfiguration.Builder#setClientControlByUserEnabled(boolean)", "SoftApConfiguration.Builder#setMaxNumberOfClients(int)", "SoftApConfiguration.Builder#setAutoShutdownEnabled(boolean)", "SoftApConfiguration.Builder#setBlockedClientList(List)", "SoftApConfiguration.Builder#setShutdownTimeoutMillis(long)" ]
  }, {
    "name" : "public void setTdlsEnabled(InetAddress remoteIPAddress, boolean enable)",
    "returnType" : "void",
    "comment" : "\n     * Enable/Disable TDLS on a specific local route.\n     *\n     * <p>\n     * TDLS enables two wireless endpoints to talk to each other directly\n     * without going through the access point that is managing the local\n     * network. It saves bandwidth and improves quality of the link.\n     * </p>\n     * <p>\n     * This API enables/disables the option of using TDLS. If enabled, the\n     * underlying hardware is free to use TDLS or a hop through the access\n     * point. If disabled, existing TDLS session is torn down and\n     * hardware is restricted to use access point for transferring wireless\n     * packets. Default value for all routes is 'disabled', meaning restricted\n     * to use access point for transferring packets.\n     * </p>\n     *\n     * @param remoteIPAddress IP address of the endpoint to setup TDLS with\n     * @param enable true = setup and false = tear down TDLS\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTdlsEnabled(@NonNull InetAddress remoteIPAddress, boolean enable, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Boolean> resultsCallback)",
    "returnType" : "void",
    "comment" : "\n     * Enable/Disable TDLS on a specific local route.\n     *\n     * Similar to {@link #setTdlsEnabled(InetAddress, boolean)}, except\n     * this version sends the result of the Enable/Disable request.\n     *\n     * @param remoteIPAddress IP address of the endpoint to setup TDLS with\n     * @param enable true = setup and false = tear down TDLS\n     * @param executor The executor on which callback will be invoked.\n     * @param resultsCallback An asynchronous callback that will return {@code Boolean} indicating\n     *                        whether TDLS was successfully enabled or disabled.\n     *                        {@code true} for success, {@code false} for failure.\n     *\n     * @throws NullPointerException if the caller provided invalid inputs.\n     ",
    "links" : [ "#setTdlsEnabled(InetAddress" ]
  }, {
    "name" : "public void setTdlsEnabledWithMacAddress(String remoteMacAddress, boolean enable)",
    "returnType" : "void",
    "comment" : "\n     * Similar to {@link #setTdlsEnabled(InetAddress, boolean) }, except\n     * this version allows you to specify remote endpoint with a MAC address.\n     * @param remoteMacAddress MAC address of the remote endpoint such as 00:00:0c:9f:f2:ab\n     * @param enable true = setup and false = tear down TDLS\n     ",
    "links" : [ "#setTdlsEnabled(InetAddress" ]
  }, {
    "name" : "public void setTdlsEnabledWithMacAddress(@NonNull String remoteMacAddress, boolean enable, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Boolean> resultsCallback)",
    "returnType" : "void",
    "comment" : "\n     * Enable/Disable TDLS with a specific peer Mac Address.\n     *\n     * Similar to {@link #setTdlsEnabledWithMacAddress(String, boolean)}, except\n     * this version sends the result of the Enable/Disable request.\n     *\n     * @param remoteMacAddress Mac address of the endpoint to setup TDLS with\n     * @param enable true = setup and false = tear down TDLS\n     * @param executor The executor on which callback will be invoked.\n     * @param resultsCallback An asynchronous callback that will return {@code Boolean} indicating\n     *                        whether TDLS was successfully enabled or disabled.\n     *                        {@code true} for success, {@code false} for failure.\n     *\n     * @throws NullPointerException if the caller provided invalid inputs.\n     ",
    "links" : [ "#setTdlsEnabledWithMacAddress(String" ]
  }, {
    "name" : "public void isTdlsOperationCurrentlyAvailable(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Boolean> resultsCallback)",
    "returnType" : "void",
    "comment" : "\n     * Check if a TDLS session can be established at this time via\n     * {@link #setTdlsEnabled(InetAddress, boolean)} or\n     * {@link #setTdlsEnabledWithMacAddress(String, boolean)} or\n     * {@link #setTdlsEnabled(InetAddress, boolean, Executor, Consumer)} or\n     * {@link #setTdlsEnabledWithMacAddress(String, boolean, Executor, Consumer)}\n     *\n     * Internally framework checks the STA connected state, device support for TDLS and\n     * the number of TDLS sessions available in driver/firmware.\n     *\n     * @param executor The executor on which callback will be invoked.\n     * @param resultsCallback An asynchronous callback that will return {@code Boolean} indicating\n     *                        whether a TDLS session can be established at this time.\n     *                        {@code true} for available, {@code false} for not available.\n     *\n     * @throws NullPointerException if the caller provided invalid inputs.\n     ",
    "links" : [ "#setTdlsEnabled(InetAddress", "#setTdlsEnabledWithMacAddress(String" ]
  }, {
    "name" : "public void getMaxSupportedConcurrentTdlsSessions(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Integer> resultsCallback)",
    "returnType" : "void",
    "comment" : "\n     * Return the maximum number of concurrent TDLS sessions supported by the device.\n     *\n     * @param executor The executor on which callback will be invoked.\n     * @param resultsCallback An asynchronous callback that will return the maximum number of\n     *                        concurrent TDLS sessions supported by the device. Returns\n     *                        {@code -1} if information is not available,\n     *                        e.g. if the driver/firmware doesn't provide this information.\n     *\n     * @throws NullPointerException if the caller provided invalid inputs.\n     * @throws UnsupportedOperationException if the feature is not available.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void getNumberOfEnabledTdlsSessions(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Integer> resultsCallback)",
    "returnType" : "void",
    "comment" : "\n     * Return the number of currently enabled TDLS sessions.\n     *\n     * Tracks the number of peers enabled for TDLS session via\n     * {@link #setTdlsEnabled(InetAddress, boolean) },\n     * {@link #setTdlsEnabledWithMacAddress(String, boolean) },\n     * {@link #setTdlsEnabled(InetAddress, boolean, Executor, Consumer) } and\n     * {@link #setTdlsEnabledWithMacAddress(String, boolean, Executor, Consumer) }\n     *\n     * @param executor The executor on which callback will be invoked.\n     * @param resultsCallback An asynchronous callback that will return the number of Peer\n     *                        Mac addresses configured in the driver for TDLS session.\n     *\n     * @throws NullPointerException if the caller provided invalid inputs.\n     ",
    "links" : [ "#setTdlsEnabled(InetAddress", "#setTdlsEnabledWithMacAddress(String" ]
  }, {
    "name" : "public void registerSoftApCallback(@NonNull @CallbackExecutor Executor executor, @NonNull SoftApCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Registers a callback for Soft AP. See {@link SoftApCallback}. Caller will receive the\n     * following callbacks on registration:\n     * <ul>\n     * <li> {@link SoftApCallback#onStateChanged(int, int)}</li>\n     * <li> {@link SoftApCallback#onConnectedClientsChanged(List<WifiClient>)}</li>\n     * <li> {@link SoftApCallback#onInfoChanged(SoftApInfo)}</li>\n     * <li> {@link SoftApCallback#onInfoChanged(List<SoftApInfo>)}</li>\n     * <li> {@link SoftApCallback#onCapabilityChanged(SoftApCapability)}</li>\n     * </ul>\n     *\n     * Use {@link SoftApCallback#onConnectedClientsChanged(SoftApInfo, List<WifiClient>)} to know\n     * if there are any clients connected to a specific bridged instance of this AP\n     * (if bridged AP is enabled).\n     *\n     * Note: Caller will receive the callback\n     * {@link SoftApCallback#onConnectedClientsChanged(SoftApInfo, List<WifiClient>)}\n     * on registration when there are clients connected to AP.\n     *\n     * These will be dispatched on registration to provide the caller with the current state\n     * (and are not an indication of any current change). Note that receiving an immediate\n     * WIFI_AP_STATE_FAILED value for soft AP state indicates that the latest attempt to start\n     * soft AP has failed. Caller can unregister a previously registered callback using\n     * {@link #unregisterSoftApCallback}\n     * <p>\n     * Applications should have the\n     * {@link android.Manifest.permission#NETWORK_SETTINGS NETWORK_SETTINGS} permission. Callers\n     * without the permission will trigger a {@link java.lang.SecurityException}.\n     * <p>\n     *\n     * @param executor The Executor on whose thread to execute the callbacks of the {@code callback}\n     *                 object.\n     * @param callback Callback for soft AP events\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#NETWORK_SETTINGS", "SoftApCallback", "#onStateChanged(int", "#onCapabilityChanged(SoftApCapability)", "#onConnectedClientsChanged(List", "#onInfoChanged(List", "java.lang.SecurityException", "#unregisterSoftApCallback", "#onConnectedClientsChanged(SoftApInfo", "#onInfoChanged(SoftApInfo)" ]
  }, {
    "name" : "public void unregisterSoftApCallback(@NonNull SoftApCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Allow callers to unregister a previously registered callback. After calling this method,\n     * applications will no longer receive soft AP events.\n     *\n     * @param callback Callback to unregister for soft AP events\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void connectInternal(@Nullable WifiConfiguration config, int networkId, @Nullable ActionListener listener)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void connect(@NonNull WifiConfiguration config, @Nullable ActionListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Connect to a network with the given configuration. The network also\n     * gets added to the list of configured networks for the foreground user.\n     *\n     * For a new network, this function is used instead of a\n     * sequence of addNetwork(), enableNetwork(), and reconnect()\n     *\n     * @param config the set of variables that describe the configuration,\n     *            contained in a {@link WifiConfiguration} object.\n     * @param listener for callbacks on success or failure. Can be null.\n     * @throws IllegalStateException if the WifiManager instance needs to be\n     * initialized again\n     *\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiConfiguration" ]
  }, {
    "name" : "public void connect(int networkId, @Nullable ActionListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Connect to a network with the given networkId.\n     *\n     * This function is used instead of a enableNetwork() and reconnect()\n     *\n     * <li> This API will cause reconnect if the credentials of the current active\n     * connection has been changed.</li>\n     * <li> This API will cause reconnect if the current active connection is marked metered.</li>\n     *\n     * @param networkId the ID of the network as returned by {@link #addNetwork} or {@link\n     *        #getConfiguredNetworks()}.\n     * @param listener for callbacks on success or failure. Can be null.\n     * @throws IllegalStateException if the WifiManager instance needs to be\n     * initialized again\n     * @hide\n     ",
    "links" : [ "#addNetwork", "#getConfiguredNetworks()" ]
  }, {
    "name" : "public void startRestrictingAutoJoinToSubscriptionId(int subscriptionId)",
    "returnType" : "void",
    "comment" : "\n     * Temporarily disable autojoin for all currently visible and provisioned (saved, suggested)\n     * wifi networks except merged carrier networks from the provided subscription ID.\n     *\n     * Disabled networks will get automatically re-enabled when they are out of range for a period\n     * of time, or after the maximum disable duration specified in the framework.\n     *\n     * Calling {@link #stopRestrictingAutoJoinToSubscriptionId()} will immediately re-enable\n     * autojoin on all disabled networks.\n     *\n     * @param subscriptionId the subscription ID of the carrier whose merged wifi networks won't be\n     *                       disabled {@link android.telephony.SubscriptionInfo#getSubscriptionId()}\n     * @hide\n     ",
    "links" : [ "#stopRestrictingAutoJoinToSubscriptionId()", "android.telephony.SubscriptionInfo#getSubscriptionId()" ]
  }, {
    "name" : "public void stopRestrictingAutoJoinToSubscriptionId()",
    "returnType" : "void",
    "comment" : "\n     * Re-enable autojoin for all non carrier merged wifi networks temporarily disconnected by\n     * {@link #startRestrictingAutoJoinToSubscriptionId(int)}.\n     * @hide\n     ",
    "links" : [ "#startRestrictingAutoJoinToSubscriptionId(int)" ]
  }, {
    "name" : "public void save(@NonNull WifiConfiguration config, @Nullable ActionListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Save the given network to the list of configured networks for the\n     * foreground user. If the network already exists, the configuration\n     * is updated. Any new network is enabled by default.\n     *\n     * For a new network, this function is used instead of a\n     * sequence of addNetwork() and enableNetwork().\n     *\n     * For an existing network, it accomplishes the task of updateNetwork()\n     *\n     * <li> This API will cause reconnect if the credentials of the current active\n     * connection has been changed.</li>\n     * <li> This API will cause disconnect if the current active connection is marked metered.</li>\n     *\n     * @param config the set of variables that describe the configuration,\n     *            contained in a {@link WifiConfiguration} object.\n     * @param listener for callbacks on success or failure. Can be null.\n     * @throws IllegalStateException if the WifiManager instance needs to be\n     * initialized again\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiConfiguration" ]
  }, {
    "name" : "public void forget(int netId, @Nullable ActionListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Delete the network from the list of configured networks for the\n     * foreground user.\n     *\n     * This function is used instead of a sequence of removeNetwork()\n     *\n     * @param config the set of variables that describe the configuration,\n     *            contained in a {@link WifiConfiguration} object.\n     * @param listener for callbacks on success or failure. Can be null.\n     * @throws IllegalStateException if the WifiManager instance needs to be\n     * initialized again\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiConfiguration" ]
  }, {
    "name" : "public void disable(int netId, @Nullable ActionListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Disable network\n     *\n     * @param netId is the network Id\n     * @param listener for callbacks on success or failure. Can be null.\n     * @throws IllegalStateException if the WifiManager instance needs to be\n     * initialized again\n     * @deprecated This API is deprecated. Use {@link #disableNetwork(int)} instead.\n     * @hide\n     ",
    "links" : [ "#disableNetwork(int)" ]
  }, {
    "name" : "public void allowAutojoinGlobal(boolean allowAutojoin)",
    "returnType" : "void",
    "comment" : "\n     * Control whether the device will automatically search for and connect to Wi-Fi networks -\n     * auto-join Wi-Fi networks. Disabling this option will not impact manual connections - i.e.\n     * the user will still be able to manually select and connect to a Wi-Fi network. Disabling\n     * this option significantly impacts the device connectivity and is a restricted operation\n     * (see below for permissions). Note that disabling this operation will also disable\n     * connectivity initiated scanning operations.\n     * <p>\n     * Disabling the auto-join configuration is a temporary operation (with the exception of a\n     * DO/PO caller): it will be reset (to enabled) when the device reboots or the user toggles\n     * Wi-Fi off/on. When the caller is a DO/PO then toggling Wi-Fi will not reset the\n     * configuration. Additionally, if a DO/PO disables auto-join then it cannot be (re)enabled by\n     * a non-DO/PO caller.\n     *\n     * @param allowAutojoin true to allow auto-join, false to disallow auto-join\n     *\n     * Available for DO/PO apps.\n     * Other apps require {@code android.Manifest.permission#NETWORK_SETTINGS} or\n     * {@code android.Manifest.permission#MANAGE_WIFI_NETWORK_SELECTION} permission.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void queryAutojoinGlobal(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Boolean> resultsCallback)",
    "returnType" : "void",
    "comment" : "\n     * Query whether or not auto-join global is enabled/disabled\n     * @see #allowAutojoinGlobal(boolean)\n     *\n     * Available for DO/PO apps.\n     * Other apps require {@code android.Manifest.permission#NETWORK_SETTINGS} or\n     * {@code android.Manifest.permission#MANAGE_WIFI_NETWORK_SELECTION} permission.\n     *\n     * @param executor The executor on which callback will be invoked.\n     * @param resultsCallback An asynchronous callback that will return {@code Boolean} indicating\n     *                        whether auto-join global is enabled/disabled.\n     *\n     * @throws SecurityException if the caller does not have permission.\n     * @throws NullPointerException if the caller provided invalid inputs.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void allowAutojoin(int netId, boolean allowAutojoin)",
    "returnType" : "void",
    "comment" : "\n     * Sets the user choice for allowing auto-join to a network.\n     * The updated choice will be made available through the updated config supplied by the\n     * CONFIGURED_NETWORKS_CHANGED broadcast.\n     *\n     * @param netId the id of the network to allow/disallow auto-join for.\n     * @param allowAutojoin true to allow auto-join, false to disallow auto-join\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void allowAutojoinPasspoint(@NonNull String fqdn, boolean allowAutojoin)",
    "returnType" : "void",
    "comment" : "\n     * Configure auto-join settings for a Passpoint profile.\n     *\n     * @param fqdn the FQDN (fully qualified domain name) of the passpoint profile.\n     * @param allowAutojoin true to enable auto-join, false to disable auto-join.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setMacRandomizationSettingPasspointEnabled(@NonNull String fqdn, boolean enable)",
    "returnType" : "void",
    "comment" : "\n     * Configure MAC randomization setting for a Passpoint profile.\n     * MAC randomization is enabled by default.\n     *\n     * @param fqdn the FQDN (fully qualified domain name) of the passpoint profile.\n     * @param enable true to enable MAC randomization, false to disable MAC randomization.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setPasspointMeteredOverride(@NonNull String fqdn, @WifiConfiguration.MeteredOverride int meteredOverride)",
    "returnType" : "void",
    "comment" : "\n     * Sets the user's choice of metered override for a Passpoint profile.\n     *\n     * @param fqdn the FQDN (fully qualified domain name) of the passpoint profile.\n     * @param meteredOverride One of three values: {@link WifiConfiguration#METERED_OVERRIDE_NONE},\n     *                        {@link WifiConfiguration#METERED_OVERRIDE_METERED},\n     *                        {@link WifiConfiguration#METERED_OVERRIDE_NOT_METERED}\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiConfiguration#METERED_OVERRIDE_NOT_METERED", "android.net.wifi.WifiConfiguration#METERED_OVERRIDE_METERED", "android.net.wifi.WifiConfiguration#METERED_OVERRIDE_NONE" ]
  }, {
    "name" : "public void disableEphemeralNetwork(@NonNull String network)",
    "returnType" : "void",
    "comment" : "\n     * Temporarily disable a network. Should always trigger with user disconnect network.\n     *\n     * @param network Input can be SSID or FQDN. And caller must ensure that the SSID passed thru\n     *                this API matched the WifiConfiguration.SSID rules, and thus be surrounded by\n     *                quotes.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startWps(WpsInfo config, WpsCallback listener)",
    "returnType" : "void",
    "comment" : "\n     * WPS suport has been deprecated from Client mode and this method will immediately trigger\n     * {@link WpsCallback#onFailed(int)} with a generic error.\n     *\n     * @param config WPS configuration (does not support {@link WpsInfo#LABEL})\n     * @param listener for callbacks on success or failure. Can be null.\n     * @throws IllegalStateException if the WifiManager instance needs to be initialized again\n     * @deprecated This API is deprecated\n     ",
    "links" : [ "#onFailed(int)", "android.net.wifi.WpsInfo#LABEL" ]
  }, {
    "name" : "public void cancelWps(WpsCallback listener)",
    "returnType" : "void",
    "comment" : "\n     * WPS support has been deprecated from Client mode and this method will immediately trigger\n     * {@link WpsCallback#onFailed(int)} with a generic error.\n     *\n     * @param listener for callbacks on success or failure. Can be null.\n     * @throws IllegalStateException if the WifiManager instance needs to be initialized again\n     * @deprecated This API is deprecated\n     ",
    "links" : [ "#onFailed(int)" ]
  }, {
    "name" : "public WifiLock createWifiLock(int lockType, String tag)",
    "returnType" : "WifiLock",
    "comment" : "\n     * Creates a new WifiLock.\n     *\n     * @param lockType the type of lock to create. See {@link #WIFI_MODE_FULL_HIGH_PERF}\n     * and {@link #WIFI_MODE_FULL_LOW_LATENCY} for descriptions of the types of Wi-Fi locks.\n     * @param tag a tag for the WifiLock to identify it in debugging messages.  This string is\n     *            never shown to the user under normal conditions, but should be descriptive\n     *            enough to identify your application and the specific WifiLock within it, if it\n     *            holds multiple WifiLocks.\n     *\n     * @return a new, unacquired WifiLock with the given tag.\n     *\n     * @see WifiLock\n     ",
    "links" : [ "#WIFI_MODE_FULL_HIGH_PERF", "#WIFI_MODE_FULL_LOW_LATENCY" ]
  }, {
    "name" : "public void addWifiLowLatencyLockListener(@NonNull @CallbackExecutor Executor executor, @NonNull WifiLowLatencyLockListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Add a listener for monitoring the low latency lock. The caller can unregister a previously\n     * registered listener using {@link WifiManager#removeWifiLowLatencyLockListener(\n     * WifiLowLatencyLockListener)}.\n     *\n     * <p>Applications should have the {@link android.Manifest.permission#NETWORK_SETTINGS} and\n     * {@link android.Manifest.permission#MANAGE_WIFI_NETWORK_SELECTION} permission. Callers without\n     * the permission will trigger a {@link java.lang.SecurityException}.\n     *\n     * @param executor The Executor on which to execute the callbacks.\n     * @param listener The listener for the latency mode change.\n     * @throws IllegalArgumentException if incorrect input arguments are provided.\n     * @throws SecurityException if the caller is not allowed to call this API\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#NETWORK_SETTINGS", "android.Manifest.permission#MANAGE_WIFI_NETWORK_SELECTION", "android.net.wifi.WifiManager#removeWifiLowLatencyLockListener(", "java.lang.SecurityException" ]
  }, {
    "name" : "public void removeWifiLowLatencyLockListener(@NonNull WifiLowLatencyLockListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Removes a listener added using {@link WifiManager#addWifiLowLatencyLockListener(Executor,\n     * WifiLowLatencyLockListener)}. After calling this method, applications will no longer receive\n     * low latency mode notifications.\n     *\n     * @param listener the listener to be removed.\n     * @throws IllegalArgumentException if incorrect input arguments are provided.\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#addWifiLowLatencyLockListener(Executor" ]
  }, {
    "name" : "public WifiLock createWifiLock(String tag)",
    "returnType" : "WifiLock",
    "comment" : "\n     * Creates a new WifiLock.\n     *\n     * @param tag a tag for the WifiLock to identify it in debugging messages.  This string is\n     *            never shown to the user under normal conditions, but should be descriptive\n     *            enough to identify your application and the specific WifiLock within it, if it\n     *            holds multiple WifiLocks.\n     *\n     * @return a new, unacquired WifiLock with the given tag.\n     *\n     * @see WifiLock\n     *\n     * @deprecated This API is non-functional.\n     ",
    "links" : [ ]
  }, {
    "name" : "public MulticastLock createMulticastLock(String tag)",
    "returnType" : "MulticastLock",
    "comment" : "\n     * Create a new MulticastLock\n     *\n     * @param tag a tag for the MulticastLock to identify it in debugging\n     *            messages.  This string is never shown to the user under\n     *            normal conditions, but should be descriptive enough to\n     *            identify your application and the specific MulticastLock\n     *            within it, if it holds multiple MulticastLocks.\n     *\n     * @return a new, unacquired MulticastLock with the given tag.\n     *\n     * @see MulticastLock\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isMulticastEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Check multicast filter status.\n     *\n     * @return true if multicast packets are allowed.\n     *\n     * @hide pending API council approval\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean initializeMulticastFiltering()",
    "returnType" : "boolean",
    "comment" : "\n     * Initialize the multicast filtering to 'on'\n     * @hide no intent to publish\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setVerboseLoggingEnabled(boolean enable)",
    "returnType" : "void",
    "comment" : "\n     * Set Wi-Fi verbose logging level from developer settings.\n     *\n     * @param enable true to enable verbose logging, false to disable.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setVerboseLoggingLevel(@VerboseLoggingLevel int verbose)",
    "returnType" : "void",
    "comment" : "\n     * Set Wi-Fi verbose logging level from developer settings.\n     *\n     * @param verbose the verbose logging mode which could be\n     * {@link #VERBOSE_LOGGING_LEVEL_DISABLED}, {@link #VERBOSE_LOGGING_LEVEL_ENABLED}, or\n     * {@link #VERBOSE_LOGGING_LEVEL_ENABLED_SHOW_KEY}.\n     *\n     * @hide\n     ",
    "links" : [ "#VERBOSE_LOGGING_LEVEL_DISABLED", "#VERBOSE_LOGGING_LEVEL_ENABLED_SHOW_KEY", "#VERBOSE_LOGGING_LEVEL_ENABLED" ]
  }, {
    "name" : "public void enableVerboseLogging(@VerboseLoggingLevel int verbose)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean isVerboseLoggingEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Get the persisted Wi-Fi verbose logging level, set by\n     * {@link #setVerboseLoggingEnabled(boolean)} or {@link #setVerboseLoggingLevel(int)}.\n     * No permissions are required to call this method.\n     *\n     * @return true to indicate that verbose logging is enabled, false to indicate that verbose\n     * logging is disabled.\n     *\n     * @hide\n     ",
    "links" : [ "#setVerboseLoggingEnabled(boolean)", "#setVerboseLoggingLevel(int)" ]
  }, {
    "name" : "public int getVerboseLoggingLevel()",
    "returnType" : "int",
    "comment" : "\n     * Get the persisted Wi-Fi verbose logging level, set by\n     * {@link #setVerboseLoggingEnabled(boolean)} or {@link #setVerboseLoggingLevel(int)}.\n     * No permissions are required to call this method.\n     *\n     * @return one of {@link #VERBOSE_LOGGING_LEVEL_DISABLED},\n     *         {@link #VERBOSE_LOGGING_LEVEL_ENABLED},\n     *         or {@link #VERBOSE_LOGGING_LEVEL_ENABLED_SHOW_KEY}.\n     *\n     * @hide\n     ",
    "links" : [ "#setVerboseLoggingEnabled(boolean)", "#setVerboseLoggingLevel(int)", "#VERBOSE_LOGGING_LEVEL_DISABLED", "#VERBOSE_LOGGING_LEVEL_ENABLED_SHOW_KEY", "#VERBOSE_LOGGING_LEVEL_ENABLED" ]
  }, {
    "name" : "public void factoryReset()",
    "returnType" : "void",
    "comment" : "\n     * Removes all saved Wi-Fi networks, Passpoint configurations, ephemeral networks, Network\n     * Requests, and Network Suggestions.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public Network getCurrentNetwork()",
    "returnType" : "Network",
    "comment" : "\n     * Get {@link Network} object of current wifi network, or null if not connected.\n     * @hide\n     ",
    "links" : [ "android.net.Network" ]
  }, {
    "name" : "public boolean setEnableAutoJoinWhenAssociated(boolean enabled)",
    "returnType" : "boolean",
    "comment" : "\n     * Deprecated\n     * returns false\n     * @hide\n     * @deprecated\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean getEnableAutoJoinWhenAssociated()",
    "returnType" : "boolean",
    "comment" : "\n     * Deprecated\n     * returns false\n     * @hide\n     * @deprecated\n     ",
    "links" : [ ]
  }, {
    "name" : "public void retrieveWifiBackupData(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<byte[]> resultsCallback)",
    "returnType" : "void",
    "comment" : "\n     * Returns a byte stream representing the data that needs to be backed up to save the\n     * current Wifi state.\n     * This Wifi state can be restored by calling {@link #restoreWifiBackupData(byte[])}.\n     * @hide\n     ",
    "links" : [ "#restoreWifiBackupData(byte" ]
  }, {
    "name" : "public void restoreWifiBackupData(@NonNull byte[] data)",
    "returnType" : "void",
    "comment" : "\n     * Restore state from the backed up data.\n     * @param data byte stream in the same format produced by {@link #retrieveWifiBackupData()}\n     * @hide\n     ",
    "links" : [ "#retrieveWifiBackupData()" ]
  }, {
    "name" : "public byte[] retrieveBackupData()",
    "returnType" : "byte[]",
    "comment" : "\n     * Returns a byte stream representing the data that needs to be backed up to save the\n     * current Wifi state.\n     * This Wifi state can be restored by calling {@link #restoreBackupData(byte[])}.\n     * @hide\n     ",
    "links" : [ "#restoreBackupData(byte" ]
  }, {
    "name" : "public void restoreBackupData(@NonNull byte[] data)",
    "returnType" : "void",
    "comment" : "\n     * Restore state from the backed up data.\n     * @param data byte stream in the same format produced by {@link #retrieveBackupData()}\n     * @hide\n     ",
    "links" : [ "#retrieveBackupData()" ]
  }, {
    "name" : "public byte[] retrieveSoftApBackupData()",
    "returnType" : "byte[]",
    "comment" : "\n     * Returns a byte stream representing the data that needs to be backed up to save the\n     * current soft ap config data.\n     *\n     * This soft ap config can be restored by calling {@link #restoreSoftApBackupData(byte[])}\n     * @hide\n     ",
    "links" : [ "#restoreSoftApBackupData(byte" ]
  }, {
    "name" : "public SoftApConfiguration restoreSoftApBackupData(@NonNull byte[] data)",
    "returnType" : "SoftApConfiguration",
    "comment" : "\n     * Returns soft ap config from the backed up data or null if data is invalid.\n     * @param data byte stream in the same format produced by {@link #retrieveSoftApBackupData()}\n     *\n     * @hide\n     ",
    "links" : [ "#retrieveSoftApBackupData()" ]
  }, {
    "name" : "public void restoreSupplicantBackupData(@NonNull byte[] supplicantData, @NonNull byte[] ipConfigData)",
    "returnType" : "void",
    "comment" : "\n     * Restore state from the older version of back up data.\n     * The old backup data was essentially a backup of wpa_supplicant.conf\n     * and ipconfig.txt file.\n     * @param supplicantData bytes representing wpa_supplicant.conf\n     * @param ipConfigData bytes representing ipconfig.txt\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startSubscriptionProvisioning(@NonNull OsuProvider provider, @NonNull @CallbackExecutor Executor executor, @NonNull ProvisioningCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Start subscription provisioning flow\n     *\n     * @param provider {@link OsuProvider} to provision with\n     * @param executor the Executor on which to run the callback.\n     * @param callback {@link ProvisioningCallback} for updates regarding provisioning flow\n     * @hide\n     ",
    "links" : [ "android.net.wifi.hotspot2.IProvisioningCallback", "android.net.wifi.hotspot2.OsuProvider" ]
  }, {
    "name" : "public void registerTrafficStateCallback(@NonNull @CallbackExecutor Executor executor, @NonNull TrafficStateCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Registers a callback for monitoring traffic state. See {@link TrafficStateCallback}. These\n     * callbacks will be invoked periodically by platform to inform clients about the current\n     * traffic state. Caller can unregister a previously registered callback using\n     * {@link #unregisterTrafficStateCallback(TrafficStateCallback)}\n     * <p>\n     * Applications should have the\n     * {@link android.Manifest.permission#NETWORK_SETTINGS NETWORK_SETTINGS} permission. Callers\n     * without the permission will trigger a {@link java.lang.SecurityException}.\n     * <p>\n     *\n     * @param executor The Executor on whose thread to execute the callbacks of the {@code callback}\n     *                 object.\n     * @param callback Callback for traffic state events\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#NETWORK_SETTINGS", "#unregisterTrafficStateCallback(TrafficStateCallback)", "TrafficStateCallback", "java.lang.SecurityException" ]
  }, {
    "name" : "public void unregisterTrafficStateCallback(@NonNull TrafficStateCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Allow callers to unregister a previously registered callback. After calling this method,\n     * applications will no longer receive traffic state notifications.\n     *\n     * @param callback Callback to unregister for traffic state events\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private void updateVerboseLoggingEnabledFromService()",
    "returnType" : "void",
    "comment" : "\n     * Helper method to update the local verbose logging flag based on the verbose logging\n     * level from wifi service.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isWpa3SaeSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this device supports WPA3-Personal SAE\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isWpa3SuiteBSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this device supports WPA3-Enterprise Suite-B-192\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isEnhancedOpenSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this device supports Wi-Fi Enhanced Open (OWE)\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isEasyConnectSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Wi-Fi Easy Connect (DPP) introduces standardized mechanisms to simplify the provisioning and\n     * configuration of Wi-Fi devices.\n     * For more details, visit <a href=\"https://www.wi-fi.org/\">https://www.wi-fi.org/</a> and\n     * search for \"Easy Connect\" or \"Device Provisioning Protocol specification\".\n     *\n     * @return true if this device supports Wi-Fi Easy-connect (Device Provisioning Protocol)\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isEasyConnectEnrolleeResponderModeSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this device supports Wi-Fi Easy Connect (DPP) Enrollee Responder mode.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isWapiSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this device supports WAPI.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isWpa3SaePublicKeySupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this device supports WPA3 SAE Public Key.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isPasspointTermsAndConditionsSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this device supports Wi-Fi Passpoint Terms and Conditions feature.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isWpa3SaeH2eSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this device supports WPA3 SAE Hash-to-Element.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isWifiDisplayR2Supported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this device supports Wi-Fi Display R2.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isDecoratedIdentitySupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this device supports RFC 7542 decorated identity.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isTrustOnFirstUseSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this device supports Trust On First Use (TOFU).\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isEasyConnectDppAkmSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Wi-Fi Easy Connect DPP AKM enables provisioning and configuration of Wi-Fi devices without\n     * the need of using the device PSK passphrase.\n     * For more details, visit <a href=\"https://www.wi-fi.org/\">https://www.wi-fi.org/</a> and\n     * search for \"Easy Connect\" or \"Device Provisioning Protocol specification\".\n     *\n     * @return true if this device supports Wi-Fi Easy-connect DPP (Device Provisioning Protocol)\n     * AKM, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isTlsMinimumVersionSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicate that whether or not settings required TLS minimum version is supported.\n     *\n     * If the device doesn't support this capability, the minimum accepted TLS version is 1.0.\n     *\n     * @return true if this device supports setting TLS minimum version.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isTlsV13Supported()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicate that whether or not TLS v1.3 is supported.\n     *\n     * If requested minimum is not supported, it will default to the maximum supported version.\n     *\n     * @return true if this device supports TLS v1.3.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isDualBandSimultaneousSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this device supports Dual Band Simultaneous (DBS) operation.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isTidToLinkMappingNegotiationSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this device supports TID-To-Link Mapping Negotiation.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isWepSupported()",
    "returnType" : "boolean",
    "comment" : "\n    * @return true if this device supports connections to Wi-Fi WEP networks.\n    ",
    "links" : [ ]
  }, {
    "name" : "public boolean isWpaPersonalSupported()",
    "returnType" : "boolean",
    "comment" : "\n    * @return true if this device supports connections to Wi-Fi WPA-Personal networks.\n    *\n    * Note that this is the older and less secure WPA-Personal protocol, not WPA2-Personal\n    * or later protocols.\n    ",
    "links" : [ ]
  }, {
    "name" : "public String[] getFactoryMacAddresses()",
    "returnType" : "String[]",
    "comment" : "\n     * Gets the factory Wi-Fi MAC addresses.\n     * @return Array of String representing Wi-Fi MAC addresses sorted lexically or an empty Array\n     * if failed.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDeviceMobilityState(@DeviceMobilityState int state)",
    "returnType" : "void",
    "comment" : "\n     * Updates the device mobility state. Wifi uses this information to adjust the interval between\n     * Wifi scans in order to balance power consumption with scan accuracy.\n     * The default mobility state when the device boots is {@link #DEVICE_MOBILITY_STATE_UNKNOWN}.\n     * This API should be called whenever there is a change in the mobility state.\n     * @param state the updated device mobility state\n     * @hide\n     ",
    "links" : [ "#DEVICE_MOBILITY_STATE_UNKNOWN" ]
  }, {
    "name" : "public void startEasyConnectAsConfiguratorInitiator(@NonNull String enrolleeUri, int selectedNetworkId, @EasyConnectNetworkRole int enrolleeNetworkRole, @NonNull @CallbackExecutor Executor executor, @NonNull EasyConnectStatusCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Start Easy Connect (DPP) in Configurator-Initiator role. The current device will initiate\n     * Easy Connect bootstrapping with a peer, and configure the peer with the SSID and password of\n     * the specified network using the Easy Connect protocol on an encrypted link.\n     *\n     * @param enrolleeUri         URI of the Enrollee obtained separately (e.g. QR code scanning)\n     * @param selectedNetworkId   Selected network ID to be sent to the peer\n     * @param enrolleeNetworkRole The network role of the enrollee\n     * @param callback            Callback for status updates\n     * @param executor            The Executor on which to run the callback.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startEasyConnectAsEnrolleeInitiator(@NonNull String configuratorUri, @NonNull @CallbackExecutor Executor executor, @NonNull EasyConnectStatusCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Start Easy Connect (DPP) in Enrollee-Initiator role. The current device will initiate Easy\n     * Connect bootstrapping with a peer, and receive the SSID and password from the peer\n     * configurator.\n     *\n     * @param configuratorUri URI of the Configurator obtained separately (e.g. QR code scanning)\n     * @param callback        Callback for status updates\n     * @param executor        The Executor on which to run the callback.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void startEasyConnectAsEnrolleeResponder(@Nullable String deviceInfo, @EasyConnectCryptographyCurve int curve, @NonNull @CallbackExecutor Executor executor, @NonNull EasyConnectStatusCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Start Easy Connect (DPP) in Enrollee-Responder role.\n     * The device will:\n     * 1. Generate a DPP bootstrap URI and return it using the\n     * {@link EasyConnectStatusCallback#onBootstrapUriGenerated(Uri)} method.\n     * 2. Start DPP as a Responder, waiting for an Initiator device to start the DPP\n     * authentication process.\n     * The caller should use the URI provided in step #1, for instance display it as a QR code\n     * or communicate it in some other way to the initiator device.\n     *\n     * @param deviceInfo      Device specific information to add to the DPP URI. This field allows\n     *                        the users of the configurators to identify the device.\n     *                        Optional - if not provided or in case of an empty string,\n     *                        Info field (I:) will be skipped in the generated DPP URI.\n     *                        Allowed Range of ASCII characters in deviceInfo - %x20-7E.\n     *                        semicolon and space are not allowed. Due to the limitation of maximum\n     *                        allowed characters in QR code, framework adds a limit to maximum\n     *                        characters in deviceInfo. Users must call\n     *                        {@link WifiManager#getEasyConnectMaxAllowedResponderDeviceInfoLength()\n     *                        } method to know max allowed length. Violation of these rules will\n     *                        result in an exception.\n     * @param curve           Elliptic curve cryptography used to generate DPP\n     *                        public/private key pair. If application is not interested in a\n     *                        specific curve, use specification mandated NIST P-256 elliptic curve,\n     *                        {@link WifiManager#EASY_CONNECT_CRYPTOGRAPHY_CURVE_PRIME256V1}.\n     * @param callback        Callback for status updates\n     * @param executor        The Executor on which to run the callback.\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getEasyConnectMaxAllowedResponderDeviceInfoLength()", "android.net.wifi.EasyConnectStatusCallback#onBootstrapUriGenerated(Uri)", "android.net.wifi.WifiManager#EASY_CONNECT_CRYPTOGRAPHY_CURVE_PRIME256V1" ]
  }, {
    "name" : "public static int getEasyConnectMaxAllowedResponderDeviceInfoLength()",
    "returnType" : "int",
    "comment" : "\n     * Maximum allowed length of Device specific information that can be added to the URI of\n     * Easy Connect responder device.\n     * @see #startEasyConnectAsEnrolleeResponder(String, int, Executor, EasyConnectStatusCallback)}\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void stopEasyConnectSession()",
    "returnType" : "void",
    "comment" : "\n     * Stop or abort a current Easy Connect (DPP) session. This call, once processed, will\n     * terminate any ongoing transaction, and clean up all associated resources. Caller should not\n     * expect any callbacks once this call is made. However, due to the asynchronous nature of\n     * this call, a callback may be fired if it was already pending in the queue.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addOnWifiUsabilityStatsListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnWifiUsabilityStatsListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Adds a listener for Wi-Fi usability statistics. See {@link OnWifiUsabilityStatsListener}.\n     * Multiple listeners can be added. Callers will be invoked periodically by framework to\n     * inform clients about the current Wi-Fi usability statistics. Callers can remove a previously\n     * added listener using\n     * {@link #removeOnWifiUsabilityStatsListener(OnWifiUsabilityStatsListener)}.\n     *\n     * @param executor The executor on which callback will be invoked.\n     * @param listener Listener for Wifi usability statistics.\n     *\n     * @hide\n     ",
    "links" : [ "#removeOnWifiUsabilityStatsListener(OnWifiUsabilityStatsListener)", "OnWifiUsabilityStatsListener" ]
  }, {
    "name" : "public void removeOnWifiUsabilityStatsListener(@NonNull OnWifiUsabilityStatsListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Allow callers to remove a previously registered listener. After calling this method,\n     * applications will no longer receive Wi-Fi usability statistics.\n     *\n     * @param listener Listener to remove the Wi-Fi usability statistics.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void updateWifiUsabilityScore(int seqNum, int score, int predictionHorizonSec)",
    "returnType" : "void",
    "comment" : "\n     * Provide a Wi-Fi usability score information to be recorded (but not acted upon) by the\n     * framework. The Wi-Fi usability score is derived from {@link OnWifiUsabilityStatsListener}\n     * where a score is matched to Wi-Fi usability statistics using the sequence number. The score\n     * is used to quantify whether Wi-Fi is usable in a future time.\n     *\n     * @param seqNum Sequence number of the Wi-Fi usability score.\n     * @param score The Wi-Fi usability score, expected range: [0, 100].\n     * @param predictionHorizonSec Prediction horizon of the Wi-Fi usability score in second,\n     *                             expected range: [0, 30].\n     *\n     * @hide\n     ",
    "links" : [ "OnWifiUsabilityStatsListener" ]
  }, {
    "name" : "public void registerScanResultsCallback(@NonNull @CallbackExecutor Executor executor, @NonNull ScanResultsCallback callback)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void unregisterScanResultsCallback(@NonNull ScanResultsCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Allow callers to unregister a previously registered callback. After calling this method,\n     * applications will no longer receive Scan Results events.\n     *\n     * @param callback callback to unregister for Scan Results events\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addWifiVerboseLoggingStatusChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull WifiVerboseLoggingStatusChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Add a listener listening to wifi verbose logging changes.\n     * See {@link WifiVerboseLoggingStatusChangedListener}.\n     * Caller can remove a previously registered listener using\n     * {@link WifiManager#removeWifiVerboseLoggingStatusChangedListener(\n     * WifiVerboseLoggingStatusChangedListener)}\n     * Same caller can add multiple listeners to monitor the event.\n     * <p>\n     * Applications should have the\n     * {@link android.Manifest.permission#ACCESS_WIFI_STATE}.\n     * Callers without the permission will trigger a {@link java.lang.SecurityException}.\n     * <p>\n     * @param executor The executor to execute the listener of the {@code listener} object.\n     * @param listener listener for changes in wifi verbose logging.\n     *\n     * @hide\n     ",
    "links" : [ "WifiVerboseLoggingStatusChangedListener", "android.net.wifi.WifiManager#removeWifiVerboseLoggingStatusChangedListener(", "android.Manifest.permission#ACCESS_WIFI_STATE", "java.lang.SecurityException" ]
  }, {
    "name" : "public void removeWifiVerboseLoggingStatusChangedListener(@NonNull WifiVerboseLoggingStatusChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Allow callers to remove a previously registered listener.\n     * <p>\n     * Applications should have the\n     * {@link android.Manifest.permission#ACCESS_WIFI_STATE}.\n     * Callers without the permission will trigger a {@link java.lang.SecurityException}.\n     * <p>\n     * @param listener listener to remove.\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#ACCESS_WIFI_STATE", "java.lang.SecurityException" ]
  }, {
    "name" : "public void addSuggestionConnectionStatusListener(@NonNull @CallbackExecutor Executor executor, @NonNull SuggestionConnectionStatusListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Add a listener for suggestion networks. See {@link SuggestionConnectionStatusListener}.\n     * Caller will receive the event when suggested network have connection failure.\n     * Caller can remove a previously registered listener using\n     * {@link WifiManager#removeSuggestionConnectionStatusListener(\n     * SuggestionConnectionStatusListener)}\n     * Same caller can add multiple listeners to monitor the event.\n     * <p>\n     * Applications should have the\n     * {@link android.Manifest.permission#ACCESS_FINE_LOCATION} and\n     * {@link android.Manifest.permission#ACCESS_WIFI_STATE} permissions.\n     * Callers without the permission will trigger a {@link java.lang.SecurityException}.\n     * <p>\n     *\n     * @param executor The executor to execute the listener of the {@code listener} object.\n     * @param listener listener for suggestion network connection failure.\n     ",
    "links" : [ "android.Manifest.permission#ACCESS_FINE_LOCATION", "SuggestionConnectionStatusListener", "android.Manifest.permission#ACCESS_WIFI_STATE", "java.lang.SecurityException", "android.net.wifi.WifiManager#removeSuggestionConnectionStatusListener(" ]
  }, {
    "name" : "public void removeSuggestionConnectionStatusListener(@NonNull SuggestionConnectionStatusListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Allow callers to remove a previously registered listener. After calling this method,\n     * applications will no longer receive suggestion connection events through that listener.\n     *\n     * @param listener listener to remove.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addLocalOnlyConnectionFailureListener(@NonNull @CallbackExecutor Executor executor, @NonNull LocalOnlyConnectionFailureListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Add a listener for local-only networks. See {@link WifiNetworkSpecifier}.\n     * Specify the caller will only get connection failures for networks they requested.\n     * Caller can remove a previously registered listener using\n     * {@link WifiManager#removeLocalOnlyConnectionFailureListener(LocalOnlyConnectionFailureListener)}\n     * Same caller can add multiple listeners to monitor the event.\n     * <p>\n     * Applications should have the {@link android.Manifest.permission#ACCESS_WIFI_STATE}\n     * permissions.\n     * Callers without the permission will trigger a {@link java.lang.SecurityException}.\n     * <p>\n     *\n     * @param executor The executor to execute the listener of the {@code listener} object.\n     * @param listener listener for local-only network connection failure.\n     ",
    "links" : [ "android.net.wifi.WifiManager#removeLocalOnlyConnectionFailureListener(LocalOnlyConnectionFailureListener)", "android.net.wifi.WifiNetworkSpecifier", "android.Manifest.permission#ACCESS_WIFI_STATE", "java.lang.SecurityException" ]
  }, {
    "name" : "public void removeLocalOnlyConnectionFailureListener(@NonNull LocalOnlyConnectionFailureListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Allow callers to remove a previously registered listener. After calling this method,\n     * applications will no longer receive local-only connection events through that listener.\n     *\n     * @param listener listener to remove.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static SparseArray<int[]> parseDppChannelList(String channelList)",
    "returnType" : "SparseArray<int[]>",
    "comment" : "\n     * Parse the list of channels the DPP enrollee reports when it fails to find an AP.\n     *\n     * @param channelList List of channels in the format defined in the DPP specification.\n     * @return A parsed sparse array, where the operating class is the key.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setExternalPnoScanRequest(@NonNull List<WifiSsid> ssids, @Nullable int[] frequencies, @NonNull @CallbackExecutor Executor executor, @NonNull PnoScanResultsCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * This API allows the caller to program up to 2 SSIDs for PNO scans. PNO scans are offloaded\n     * to the Wi-Fi chip when the device is inactive (typically screen-off).\n     * If the screen is currently off when this API is called, then a PNO scan including the\n     * requested SSIDs will immediately get started. If the screen is on when this API is called,\n     * the requested SSIDs will get included for PNO scans the next time the screen turns off.\n     * <p>\n     * Note, due to PNO being a limited resource, only one external PNO request is supported, and\n     * calling this API will fail if an external PNO scan request is already registered by another\n     * caller. If the caller that has already registered a callback calls this API again, the new\n     * callback will override the previous one.\n     * <p>\n     * After this API is called, {@link PnoScanResultsCallback#onRegisterSuccess()} will be invoked\n     * if the operation is successful, or {@link PnoScanResultsCallback#onRegisterFailed(int)} will\n     * be invoked if the operation failed.\n     * <p>\n     * {@link PnoScanResultsCallback#onRemoved(int)} will be invoked to notify the caller when the\n     * external PNO scan request is removed, which will happen when one of the following events\n     * happen:\n     * </p>\n     * <ul>\n     * <li>Upon finding any of the requested SSIDs through either a connectivity scan or PNO scan,\n     * the matching ScanResults will be returned\n     * via {@link PnoScanResultsCallback#onScanResultsAvailable(List)}, and the registered PNO\n     * scan request will get automatically removed.</li>\n     * <li>The external PNO scan request is removed by a call to\n     * {@link #clearExternalPnoScanRequest()}</li>\n     * </ul>\n     *\n     * @param ssids The list of SSIDs to request for PNO scan.\n     * @param frequencies Provide as hint a list of up to 10 frequencies to be used for PNO scan.\n     *                    Each frequency should be in MHz. For example 2412 and 5180 are valid\n     *                    frequencies. {@link WifiInfo#getFrequency()} is a location where this\n     *                    information could be obtained. If a null or empty array is provided, the\n     *                    Wi-Fi framework will automatically decide the list of frequencies to scan.\n     * @param executor The executor on which callback will be invoked.\n     * @param callback For the calling application to receive results and status updates.\n     *\n     * @throws SecurityException if the caller does not have permission.\n     * @throws IllegalArgumentException if the caller provided invalid inputs.\n     * @throws UnsupportedOperationException if this API is not supported on this SDK version.\n     * @hide\n     ",
    "links" : [ "#onScanResultsAvailable(List)", "#clearExternalPnoScanRequest()", "android.net.wifi.WifiInfo#getFrequency()", "#onRemoved(int)", "#onRegisterSuccess()", "#onRegisterFailed(int)" ]
  }, {
    "name" : "public void setPnoScanState(@PnoScanState int pnoScanState)",
    "returnType" : "void",
    "comment" : "\n     * Wi-Fi Preferred Network Offload (PNO) scanning offloads scanning to the chip to save power\n     * when Wi-Fi is disconnected and the screen is off. See\n     * {@link https://source.android.com/docs/core/connect/wifi-scan} for more details.\n     * <p>\n     * This API can be used to enable or disable PNO scanning. After boot, PNO scanning is enabled\n     * by default. When PNO scanning is disabled, the Wi-Fi framework will not trigger scans at all\n     * when the screen is off. This can be used to save power on devices with small batteries.\n     *\n     * @param enabled True - enable PNO scanning\n     *                False - disable PNO scanning\n     * @param enablePnoScanAfterWifiToggle True - Wifi being enabled by\n     *                                     {@link #setWifiEnabled(boolean)} will re-enable PNO\n     *                                     scanning.\n     *                                     False - Wifi being enabled by\n     *                                     {@link #setWifiEnabled(boolean)} will not re-enable PNO\n     *                                     scanning.\n     *\n     * @throws SecurityException if the caller does not have permission.\n     * @hide\n     ",
    "links" : [ "#setWifiEnabled(boolean)", "https" ]
  }, {
    "name" : "public void setPnoScanEnabled(boolean enabled, boolean enablePnoScanAfterWifiToggle)",
    "returnType" : "void",
    "comment" : "\n     * Wi-Fi Preferred Network Offload (PNO) scanning offloads scanning to the chip to save power\n     * when Wi-Fi is disconnected and the screen is off. See\n     * {@link https://source.android.com/docs/core/connect/wifi-scan} for more details.\n     * <p>\n     * This API can be used to enable or disable PNO scanning. After boot, PNO scanning is enabled\n     * by default. When PNO scanning is disabled, the Wi-Fi framework will not trigger scans at all\n     * when the screen is off. This can be used to save power on devices with small batteries.\n     *\n     * @param enabled True - enable PNO scanning\n     *                False - disable PNO scanning\n     * @param enablePnoScanAfterWifiToggle True - Wifi being enabled by\n     *                                     {@link #setWifiEnabled(boolean)} will re-enable PNO\n     *                                     scanning.\n     *                                     False - Wifi being enabled by\n     *                                     {@link #setWifiEnabled(boolean)} will not re-enable PNO\n     *                                     scanning.\n     *\n     * @throws SecurityException if the caller does not have permission.\n     * @hide\n     ",
    "links" : [ "#setWifiEnabled(boolean)", "https" ]
  }, {
    "name" : "public void clearExternalPnoScanRequest()",
    "returnType" : "void",
    "comment" : "\n     * Clear the current PNO scan request that's been set by the calling UID. Note, the call will\n     * be no-op if the current PNO scan request is set by a different UID.\n     *\n     * @throws UnsupportedOperationException if the API is not supported on this SDK version.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void getLastCallerInfoForApi(@ApiType int apiType, @NonNull @CallbackExecutor Executor executor, @NonNull BiConsumer<String, Boolean> resultsCallback)",
    "returnType" : "void",
    "comment" : "\n     * Returns information about the last caller of an API.\n     *\n     * @param apiType The type of API to request information for the last caller.\n     * @param executor The executor on which callback will be invoked.\n     * @param resultsCallback An asynchronous callback that will return 2 arguments.\n     *                        {@code String} the name of the package that performed the last API\n     *                        call. {@code Boolean} the value associated with the last API call.\n     *\n     * @throws SecurityException if the caller does not have permission.\n     * @throws IllegalArgumentException if the caller provided invalid inputs.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setWifiConnectedNetworkScorer(@NonNull @CallbackExecutor Executor executor, @NonNull WifiConnectedNetworkScorer scorer)",
    "returnType" : "boolean",
    "comment" : "\n     * Set a callback for Wi-Fi connected network scorer.  See {@link WifiConnectedNetworkScorer}.\n     * Only a single scorer can be set. Caller will be invoked periodically by framework to inform\n     * client about start and stop of Wi-Fi connection. Caller can clear a previously set scorer\n     * using {@link clearWifiConnectedNetworkScorer()}.\n     *\n     * @param executor The executor on which callback will be invoked.\n     * @param scorer Scorer for Wi-Fi network implemented by application.\n     * @return true Scorer is set successfully.\n     *\n     * @hide\n     ",
    "links" : [ "WifiConnectedNetworkScorer", "clearWifiConnectedNetworkScorer()" ]
  }, {
    "name" : "public void clearWifiConnectedNetworkScorer()",
    "returnType" : "void",
    "comment" : "\n     * Allow caller to clear a previously set scorer. After calling this method,\n     * client will no longer receive information about start and stop of Wi-Fi connection.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setScanThrottleEnabled(boolean enable)",
    "returnType" : "void",
    "comment" : "\n     * Enable/disable wifi scan throttling from 3rd party apps.\n     *\n     * <p>\n     * The throttling limits for apps are described in\n     * <a href=\"Wi-Fi Scan Throttling\">\n     * https://developer.android.com/guide/topics/connectivity/wifi-scan#wifi-scan-throttling</a>\n     * </p>\n     *\n     * @param enable true to allow scan throttling, false to disallow scan throttling.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isScanThrottleEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Get the persisted Wi-Fi scan throttle state. Defaults to true, unless changed by the user via\n     * Developer options.\n     *\n     * <p>\n     * The throttling limits for apps are described in\n     * <a href=\"Wi-Fi Scan Throttling\">\n     * https://developer.android.com/guide/topics/connectivity/wifi-scan#wifi-scan-throttling</a>\n     * </p>\n     *\n     * @return true to indicate that scan throttling is enabled, false to indicate that scan\n     * throttling is disabled.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setAutoWakeupEnabled(boolean enable)",
    "returnType" : "void",
    "comment" : "\n     * Enable/disable wifi auto wakeup feature.\n     *\n     * <p>\n     * The feature is described in\n     * <a href=\"Wi-Fi Turn on automatically\">\n     * https://source.android.com/devices/tech/connect/wifi-infrastructure\n     * #turn_on_wi-fi_automatically\n     * </a>\n     *\n     * @param enable true to enable, false to disable.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isAutoWakeupEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Get the persisted Wi-Fi auto wakeup feature state. Defaults to false, unless changed by the\n     * user via Settings.\n     *\n     * <p>\n     * The feature is described in\n     * <a href=\"Wi-Fi Turn on automatically\">\n     * https://source.android.com/devices/tech/connect/wifi-infrastructure\n     * #turn_on_wi-fi_automatically\n     * </a>\n     *\n     * @return true to indicate that wakeup feature is enabled, false to indicate that wakeup\n     * feature is disabled.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setCarrierNetworkOffloadEnabled(int subscriptionId, boolean merged, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Sets the state of carrier offload on merged or unmerged networks for specified subscription.\n     *\n     * <p>\n     * When a subscription's carrier network offload is disabled, all network suggestions related to\n     * this subscription will not be considered for auto join.\n     * <p>\n     * If calling app want disable all carrier network offload from a specified subscription, should\n     * call this API twice to disable both merged and unmerged carrier network suggestions.\n     *\n     * @param subscriptionId See {@link SubscriptionInfo#getSubscriptionId()}.\n     * @param merged True for carrier merged network, false otherwise.\n     *               See {@link WifiNetworkSuggestion.Builder#setCarrierMerged(boolean)}\n     * @param enabled True for enable carrier network offload, false otherwise.\n     * @see #isCarrierNetworkOffloadEnabled(int, boolean)\n     * @hide\n     ",
    "links" : [ "android.telephony.SubscriptionInfo#getSubscriptionId()", "WifiNetworkSuggestion.Builder#setCarrierMerged(boolean)" ]
  }, {
    "name" : "public boolean isCarrierNetworkOffloadEnabled(int subscriptionId, boolean merged)",
    "returnType" : "boolean",
    "comment" : "\n     * Get the carrier network offload state for merged or unmerged networks for specified\n     * subscription.\n     * @param subscriptionId subscription ID see {@link SubscriptionInfo#getSubscriptionId()}\n     * @param merged True for carrier merged network, false otherwise.\n     *               See {@link WifiNetworkSuggestion.Builder#setCarrierMerged(boolean)}\n     * @return True to indicate that carrier network offload is enabled, false otherwise.\n     ",
    "links" : [ "android.telephony.SubscriptionInfo#getSubscriptionId()", "WifiNetworkSuggestion.Builder#setCarrierMerged(boolean)" ]
  }, {
    "name" : "public void addSuggestionUserApprovalStatusListener(@NonNull @CallbackExecutor Executor executor, @NonNull SuggestionUserApprovalStatusListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Add a listener for Wi-Fi network suggestion user approval status.\n     * See {@link SuggestionUserApprovalStatusListener}.\n     * Caller will receive a callback immediately after adding a listener and when the user approval\n     * status of the caller has changed.\n     * Caller can remove a previously registered listener using\n     * {@link WifiManager#removeSuggestionUserApprovalStatusListener(\n     * SuggestionUserApprovalStatusListener)}\n     * A caller can add multiple listeners to monitor the event.\n     * @param executor The executor to execute the listener of the {@code listener} object.\n     * @param listener listener for suggestion user approval status changes.\n     ",
    "links" : [ "android.net.wifi.WifiManager#removeSuggestionUserApprovalStatusListener(", "SuggestionUserApprovalStatusListener" ]
  }, {
    "name" : "public void removeSuggestionUserApprovalStatusListener(@NonNull SuggestionUserApprovalStatusListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Allow callers to remove a previously registered listener using\n     * {@link #addSuggestionUserApprovalStatusListener(Executor,\n     * SuggestionUserApprovalStatusListener)}. After calling this method,\n     * applications will no longer receive network suggestion user approval status change through\n     * that listener.\n     ",
    "links" : [ "#addSuggestionUserApprovalStatusListener(Executor" ]
  }, {
    "name" : "public void setEmergencyScanRequestInProgress(boolean inProgress)",
    "returnType" : "void",
    "comment" : "\n     * Indicates the start/end of an emergency scan request being processed by {@link WifiScanner}.\n     * The wifi stack should ensure that the wifi chip remains on for the duration of the scan.\n     * WifiScanner detects emergency scan requests via\n     * {@link WifiScanner.ScanSettings#ignoreLocationSettings} flag.\n     *\n     * If the wifi stack is off (because location & wifi toggles are off) when this indication is\n     * received, the wifi stack will temporarily move to a scan only mode. Since location toggle\n     * is off, only scan with\n     * {@link WifiScanner.ScanSettings#ignoreLocationSettings} flag set will be\n     * allowed to be processed for this duration.\n     *\n     * @hide\n     ",
    "links" : [ "WifiScanner.ScanSettings#ignoreLocationSettings", "android.net.wifi.WifiScanner" ]
  }, {
    "name" : "public boolean setWifiScoringEnabled(boolean enabled)",
    "returnType" : "boolean",
    "comment" : "\n     * Enable or disable Wi-Fi scoring.  Wi-Fi network status is evaluated by Wi-Fi scoring\n     * {@link WifiScoreReport}. This API enables/disables Wi-Fi scoring to take action on network\n     * selection.\n     *\n     * @param enabled {@code true} to enable, {@code false} to disable.\n     * @return true The status of Wifi scoring is set successfully.\n     * @hide\n     ",
    "links" : [ "WifiScoreReport" ]
  }, {
    "name" : "public void flushPasspointAnqpCache()",
    "returnType" : "void",
    "comment" : "\n     * Flush Passpoint ANQP cache, and clear pending ANQP requests. Allows the caller to reset the\n     * Passpoint ANQP state, if required.\n     *\n     * Notes:\n     * 1. Flushing the ANQP cache may cause delays in discovering and connecting to Passpoint\n     * networks.\n     * 2. Intended to be used by Device Owner (DO), Profile Owner (PO), Settings and provisioning\n     * apps.\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<WifiAvailableChannel> getAllowedChannels(int band, @WifiAvailableChannel.OpMode int mode)",
    "returnType" : "List<WifiAvailableChannel>",
    "comment" : "\n     * Returns a list of {@link WifiAvailableChannel} for the specified band and operational\n     * mode(s), that is allowed for the current regulatory domain. An empty list implies that there\n     * are no available channels for use.\n     *\n     * Note: the {@code band} parameter which is specified as a {@code WifiScanner#WIFI_BAND_*}\n     * constant is limited to one of the band values specified below. Specifically, if the 5GHz\n     * band is included then it must include the DFS channels - an exception will be thrown\n     * otherwise. The caller should not make any assumptions about whether DFS channels are allowed.\n     * This API will indicate whether DFS channels are allowed for the specified operation mode(s)\n     * per device policy.\n     *\n     * @param band one of the following band constants defined in {@code WifiScanner#WIFI_BAND_*}\n     *             constants.\n     *             1. {@code WifiScanner#WIFI_BAND_UNSPECIFIED}=0 - no band specified; Looks for the\n     *                channels in all the available bands - 2.4 GHz, 5 GHz, 6 GHz and 60 GHz\n     *             2. {@code WifiScanner#WIFI_BAND_24_GHZ}=1\n     *             3. {@code WifiScanner#WIFI_BAND_5_GHZ_WITH_DFS}=6\n     *             4. {@code WifiScanner#WIFI_BAND_BOTH_WITH_DFS}=7\n     *             5. {@code WifiScanner#WIFI_BAND_6_GHZ}=8\n     *             6. {@code WifiScanner#WIFI_BAND_24_5_WITH_DFS_6_GHZ}=15\n     *             7. {@code WifiScanner#WIFI_BAND_60_GHZ}=16\n     *             8. {@code WifiScanner#WIFI_BAND_24_5_WITH_DFS_6_60_GHZ}=31\n     * @param mode Bitwise OR of {@code WifiAvailableChannel#OP_MODE_*} constants\n     *        e.g. {@link WifiAvailableChannel#OP_MODE_WIFI_AWARE}\n     * @return a list of {@link WifiAvailableChannel}\n     *\n     * @throws UnsupportedOperationException - if this API is not supported on this device\n     *         or IllegalArgumentException - if the band specified is not one among the list\n     *         of bands mentioned above.\n     ",
    "links" : [ "android.net.wifi.WifiAvailableChannel#OP_MODE_WIFI_AWARE", "android.net.wifi.WifiAvailableChannel" ]
  }, {
    "name" : "public List<WifiAvailableChannel> getUsableChannels(int band, @WifiAvailableChannel.OpMode int mode)",
    "returnType" : "List<WifiAvailableChannel>",
    "comment" : "\n     * Returns a list of {@link WifiAvailableChannel} for the specified band and operational\n     * mode(s) per the current regulatory domain and device-specific constraints such as concurrency\n     * state and interference due to other radios. An empty list implies that there are no available\n     * channels for use.\n     *\n     * Note: the {@code band} parameter which is specified as a {@code WifiScanner#WIFI_BAND_*}\n     * constant is limited to one of the band values specified below. Specifically, if the 5GHz\n     * band is included then it must include the DFS channels - an exception will be thrown\n     * otherwise. The caller should not make any assumptions about whether DFS channels are allowed.\n     * This API will indicate whether DFS channels are allowed for the specified operation mode(s)\n     * per device policy.\n     *\n     * @param band one of the following band constants defined in {@code WifiScanner#WIFI_BAND_*}\n     *             constants.\n     *             1. {@code WifiScanner#WIFI_BAND_UNSPECIFIED}=0 - no band specified; Looks for the\n     *                channels in all the available bands - 2.4 GHz, 5 GHz, 6 GHz and 60 GHz\n     *             2. {@code WifiScanner#WIFI_BAND_24_GHZ}=1\n     *             3. {@code WifiScanner#WIFI_BAND_5_GHZ_WITH_DFS}=6\n     *             4. {@code WifiScanner#WIFI_BAND_BOTH_WITH_DFS}=7\n     *             5. {@code WifiScanner#WIFI_BAND_6_GHZ}=8\n     *             6. {@code WifiScanner#WIFI_BAND_24_5_WITH_DFS_6_GHZ}=15\n     *             7. {@code WifiScanner#WIFI_BAND_60_GHZ}=16\n     *             8. {@code WifiScanner#WIFI_BAND_24_5_WITH_DFS_6_60_GHZ}=31\n     * @param mode Bitwise OR of {@code WifiAvailableChannel#OP_MODE_*} constants\n     *        e.g. {@link WifiAvailableChannel#OP_MODE_WIFI_AWARE}\n     * @return a list of {@link WifiAvailableChannel}\n     *\n     * @throws UnsupportedOperationException - if this API is not supported on this device\n     *         or IllegalArgumentException - if the band specified is not one among the list\n     *         of bands mentioned above.\n     ",
    "links" : [ "android.net.wifi.WifiAvailableChannel#OP_MODE_WIFI_AWARE", "android.net.wifi.WifiAvailableChannel" ]
  }, {
    "name" : "public boolean isWifiPasspointEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * If the device supports Wi-Fi Passpoint, the user can explicitly enable or disable it.\n     * That status can be queried using this method.\n     * @return {@code true} if Wi-Fi Passpoint is enabled\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setWifiPasspointEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Explicitly enable or disable Wi-Fi Passpoint as a global switch.\n     * The global Passpoint enabling/disabling overrides individual configuration\n     * enabling/disabling.\n     * Passpoint global status can be queried by {@link WifiManager#isWifiPasspointEnabled }.\n     *\n     * @param enabled {@code true} to enable, {@code false} to disable.\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#isWifiPasspointEnabled" ]
  }, {
    "name" : "public int getStaConcurrencyForMultiInternetMode()",
    "returnType" : "int",
    "comment" : "\n     * The device may support concurrent connections to multiple internet-providing Wi-Fi\n     * networks (APs) - that is indicated by\n     * {@link WifiManager#isStaConcurrencyForMultiInternetSupported()}.\n     * This method indicates whether or not the feature is currently enabled.\n     * A value of {@link WifiManager#WIFI_MULTI_INTERNET_MODE_DISABLED} indicates that the feature\n     * is disabled, a value of {@link WifiManager#WIFI_MULTI_INTERNET_MODE_DBS_AP} or\n     * {@link WifiManager#WIFI_MULTI_INTERNET_MODE_MULTI_AP} indicates that the feature is enabled.\n     *\n     * The app can register to receive the corresponding Wi-Fi networks using the\n     * {@link ConnectivityManager#registerNetworkCallback(NetworkRequest, NetworkCallback)} API with\n     * a {@link WifiNetworkSpecifier} configured using the\n     * {@link WifiNetworkSpecifier.Builder#setBand(int)} method.\n     ",
    "links" : [ "android.net.wifi.WifiManager#WIFI_MULTI_INTERNET_MODE_DISABLED", "android.net.wifi.WifiManager#WIFI_MULTI_INTERNET_MODE_DBS_AP", "android.net.wifi.WifiManager#WIFI_MULTI_INTERNET_MODE_MULTI_AP", "android.net.wifi.WifiNetworkSpecifier", "WifiNetworkSpecifier.Builder#setBand(int)", "android.net.ConnectivityManager#registerNetworkCallback(NetworkRequest", "android.net.wifi.WifiManager#isStaConcurrencyForMultiInternetSupported()" ]
  }, {
    "name" : "public void notifyMinimumRequiredWifiSecurityLevelChanged(int level)",
    "returnType" : "void",
    "comment" : "\n     * Check if the currently connected network meets the minimum required Wi-Fi security level set.\n     * If not, the current network will be disconnected.\n     *\n     * @throws SecurityException if the caller does not have permission.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void notifyWifiSsidPolicyChanged(@NonNull WifiSsidPolicy policy)",
    "returnType" : "void",
    "comment" : "\n     * Check if the currently connected network meets the Wi-Fi SSID policy set.\n     * If not, the current network will be disconnected.\n     *\n     * @throws SecurityException if the caller does not have permission.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setStaConcurrencyForMultiInternetMode(@WifiMultiInternetMode int mode)",
    "returnType" : "boolean",
    "comment" : "\n     * Configure whether or not concurrent multiple connections to internet-providing Wi-Fi\n     * networks (AP) is enabled.\n     * Use {@link WifiManager#WIFI_MULTI_INTERNET_MODE_DISABLED} to disable, and either\n     * {@link WifiManager#WIFI_MULTI_INTERNET_MODE_DBS_AP} or\n     * {@link WifiManager#WIFI_MULTI_INTERNET_MODE_MULTI_AP} to enable in different modes.\n     * The {@link WifiManager#getStaConcurrencyForMultiInternetMode() } can be used to retrieve\n     * the current mode.\n     *\n     * @param mode Multi internet mode.\n     * @return true when the mode is set successfully, false when failed.\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#WIFI_MULTI_INTERNET_MODE_DISABLED", "android.net.wifi.WifiManager#WIFI_MULTI_INTERNET_MODE_DBS_AP", "android.net.wifi.WifiManager#getStaConcurrencyForMultiInternetMode()", "android.net.wifi.WifiManager#WIFI_MULTI_INTERNET_MODE_MULTI_AP" ]
  }, {
    "name" : "public Set<String> getOemPrivilegedWifiAdminPackages()",
    "returnType" : "Set<String>",
    "comment" : "\n     * Returns a set of packages that aren't DO or PO but should be able to manage WiFi networks.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void replyToSimpleDialog(int dialogId, @DialogReply int reply)",
    "returnType" : "void",
    "comment" : "\n     * Method for WifiDialog to notify the framework of a reply to a simple dialog.\n     * @param dialogId id of the replying dialog.\n     * @param reply reply of the dialog.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void replyToP2pInvitationReceivedDialog(int dialogId, boolean accepted, @Nullable String optionalPin)",
    "returnType" : "void",
    "comment" : "\n     * Method for WifiDialog to notify the framework of a reply to a P2P Invitation Received dialog.\n     * @param dialogId id of the replying dialog.\n     * @param accepted Whether the invitation was accepted.\n     * @param optionalPin PIN of the reply, or {@code null} if none was supplied.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addCustomDhcpOptions(@NonNull WifiSsid ssid, @NonNull byte[] oui, @NonNull List<DhcpOption> options)",
    "returnType" : "void",
    "comment" : "\n     * Specify a list of DHCP options to use for any network whose SSID is specified and which\n     * transmits vendor-specific information elements (VSIEs) using the specified Organizationally\n     * Unique Identifier (OUI). If the AP transmits VSIEs for multiple specified OUIs then all\n     * matching DHCP options will be used. The allowlist for DHCP options in\n     * {@link android.net.ip.IpClient} gates whether the DHCP options will actually be used.\n     * When DHCP options are used: if the option value {@link android.net.DhcpOption#getValue()}\n     * is null, the option type {@link android.net.DhcpOption#getType()} will be put in the\n     * Parameter Request List in the DHCP packets; otherwise, the option will be included in the\n     * options section in the DHCP packets. Use {@link #removeCustomDhcpOptions(Object, Object)}\n     * to remove the specified DHCP options.\n     *\n     * @param ssid the network SSID.\n     * @param oui the 3-byte OUI.\n     * @param options the list of {@link android.net.DhcpOption}.\n     *\n     * @hide\n     ",
    "links" : [ "android.net.DhcpOption#getType()", "android.net.DhcpOption", "android.net.DhcpOption#getValue()", "android.net.ip.IpClient", "#removeCustomDhcpOptions(Object" ]
  }, {
    "name" : "public void removeCustomDhcpOptions(@NonNull WifiSsid ssid, @NonNull byte[] oui)",
    "returnType" : "void",
    "comment" : "\n     * Remove custom DHCP options specified by {@link #addCustomDhcpOptions(Object, Object, List)}.\n     *\n     * @param ssid the network SSID.\n     * @param oui the 3-byte OUI.\n     *\n     * @hide\n     ",
    "links" : [ "#addCustomDhcpOptions(Object" ]
  }, {
    "name" : "public void reportCreateInterfaceImpact(@WifiInterfaceType int interfaceType, boolean requireNewInterface, @NonNull @CallbackExecutor Executor executor, @NonNull BiConsumer<Boolean, Set<InterfaceCreationImpact>> resultCallback)",
    "returnType" : "void",
    "comment" : "\n     * Queries the framework to determine whether the specified interface can be created, and if\n     * so - what other interfaces would be torn down by the framework to allow this creation if\n     * it were requested. The result is returned via the specified {@link BiConsumer} callback\n     * which returns two arguments:\n     * <li>First argument: a {@code boolean} - indicating whether or not the interface can be\n     * created.</li>\n     * <li>Second argument: a {@code Set<InterfaceCreationImpact>} - if the interface can be\n     * created (first argument is {@code true} then this is the set of interface types which\n     * will be removed and the packages which requested them. Possibly an empty set. If the\n     * first argument is {@code false}, then an empty set will be returned here.</li>\n     * <p>\n     * Interfaces, input and output, are specified using the {@code WIFI_INTERFACE_*} constants:\n     * {@link #WIFI_INTERFACE_TYPE_STA}, {@link #WIFI_INTERFACE_TYPE_AP},\n     * {@link #WIFI_INTERFACE_TYPE_AWARE}, or {@link #WIFI_INTERFACE_TYPE_DIRECT}.\n     * <p>\n     * This method does not actually create the interface. That operation is handled by the\n     * framework when a particular service method is called. E.g. a Wi-Fi Direct interface may be\n     * created when various methods of {@link android.net.wifi.p2p.WifiP2pManager} are called,\n     * similarly for Wi-Fi Aware and {@link android.net.wifi.aware.WifiAwareManager}.\n     * <p>\n     * Note: the information returned via this method is the current snapshot of the system. It may\n     * change due to actions of the framework or other apps.\n     *\n     * @param interfaceType The interface type whose possible creation is being queried.\n     * @param requireNewInterface Indicates that the query is for a new interface of the specified\n     *                             type - an existing interface won't meet the query. Some\n     *                             operations (such as Wi-Fi Direct and Wi-Fi Aware are a shared\n     *                             resource and so may not need a new interface).\n     * @param executor An {@link Executor} on which to return the result.\n     * @param resultCallback The asynchronous callback which will return two argument: a\n     * {@code boolean} (whether the interface can be created), and a\n     * {@code Set<InterfaceCreationImpact>} (a set of {@link InterfaceCreationImpact}:\n     *                       interfaces which will be destroyed when the interface is created\n     *                       and the packages which requested them and thus may be impacted).\n     ",
    "links" : [ "#WIFI_INTERFACE_TYPE_AP", "#WIFI_INTERFACE_TYPE_DIRECT", "InterfaceCreationImpact", "android.net.wifi.p2p.WifiP2pManager", "java.util.function.BiConsumer", "#WIFI_INTERFACE_TYPE_STA", "android.net.wifi.aware.WifiAwareManager", "android.annotation.CallbackExecutor", "#WIFI_INTERFACE_TYPE_AWARE" ]
  }, {
    "name" : "public int getMaxNumberOfChannelsPerNetworkSpecifierRequest()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void addQosPolicies(@NonNull List<QosPolicyParams> policyParamsList, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<List<Integer>> resultsCallback)",
    "returnType" : "void",
    "comment" : "\n     * Add a list of new application-initiated QoS policies.\n     *\n     * Note: Policies are managed using a policy ID, which can be retrieved using\n     *       {@link QosPolicyParams#getPolicyId()}. This ID can be used when removing a policy via\n     *       {@link #removeQosPolicies(int[])}. The caller is in charge of assigning and managing\n     *       the policy IDs for any requested policies.\n     *\n     * Note: Policies with duplicate IDs are not allowed. To update an existing policy, first\n     *       remove it using {@link #removeQosPolicies(int[])}, and then re-add it using this API.\n     *\n     * Note: All policies in a single request must have the same {@link QosPolicyParams.Direction}.\n     *\n     * Note: Support for the {@link QosPolicyParams#DIRECTION_UPLINK} direction is added in\n     *       {@link android.os.Build.VERSION_CODES#VANILLA_ICE_CREAM}. For earlier releases,\n     *       only the {@link QosPolicyParams#DIRECTION_DOWNLINK} direction is supported.\n     *\n     * @param policyParamsList List of {@link QosPolicyParams} objects describing the requested\n     *                         policies. Must have a maximum length of\n     *                         {@link #getMaxNumberOfPoliciesPerQosRequest()}.\n     * @param executor The executor on which callback will be invoked.\n     * @param resultsCallback An asynchronous callback that will return a list of integer status\n     *                        codes from {@link QosRequestStatus}. Result list will be the same\n     *                        length as the input list, and each status code will correspond to\n     *                        the policy at that index in the input list.\n     *\n     * @throws SecurityException if caller does not have the required permissions.\n     * @throws NullPointerException if the caller provided a null input.\n     * @throws UnsupportedOperationException if the feature is not enabled.\n     * @throws IllegalArgumentException if the input list is invalid.\n     * @hide\n     ",
    "links" : [ "android.net.wifi.QosPolicyParams#getPolicyId()", "android.net.wifi.QosPolicyParams#DIRECTION_UPLINK", "QosPolicyParams.Direction", "#removeQosPolicies(int", "android.os.Build.VERSION_CODES#VANILLA_ICE_CREAM", "android.net.wifi.QosPolicyParams#DIRECTION_DOWNLINK", "QosRequestStatus", "android.net.wifi.QosPolicyParams", "#getMaxNumberOfPoliciesPerQosRequest()" ]
  }, {
    "name" : "public void removeQosPolicies(@NonNull int[] policyIdList)",
    "returnType" : "void",
    "comment" : "\n     * Remove a list of existing application-initiated QoS policies, previously added via\n     * {@link #addQosPolicies(List, Executor, Consumer)}.\n     *\n     * Note: Policies are identified by their policy IDs, which are assigned by the caller. The ID\n     *       for a given policy can be retrieved using {@link QosPolicyParams#getPolicyId()}.\n     *\n     * @param policyIdList List of policy IDs corresponding to the policies to remove. Must have\n     *                     a maximum length of {@link #getMaxNumberOfPoliciesPerQosRequest()}.\n     * @throws SecurityException if caller does not have the required permissions.\n     * @throws NullPointerException if the caller provided a null input.\n     * @throws IllegalArgumentException if the input list is invalid.\n     * @hide\n     ",
    "links" : [ "android.net.wifi.QosPolicyParams#getPolicyId()", "#getMaxNumberOfPoliciesPerQosRequest()", "#addQosPolicies(List" ]
  }, {
    "name" : "public void removeAllQosPolicies()",
    "returnType" : "void",
    "comment" : "\n     * Remove all application-initiated QoS policies requested by this caller,\n     * previously added via {@link #addQosPolicies(List, Executor, Consumer)}.\n     *\n     * @throws SecurityException if caller does not have the required permissions.\n     * @hide\n     ",
    "links" : [ "#addQosPolicies(List" ]
  }, {
    "name" : "public void setLinkLayerStatsPollingInterval(@IntRange(from = 0) int intervalMs)",
    "returnType" : "void",
    "comment" : "\n     * Set the link layer stats polling interval, in milliseconds.\n     *\n     * @param intervalMs a non-negative integer, for the link layer stats polling interval\n     *                   in milliseconds.\n     *                   To set a fixed interval, use a positive value.\n     *                   For automatic handling of the interval, use value 0\n     * @throws UnsupportedOperationException if the API is not supported on this SDK version.\n     * @throws SecurityException if the caller does not have permission.\n     * @throws IllegalArgumentException if input is invalid.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void getLinkLayerStatsPollingInterval(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Integer> resultsCallback)",
    "returnType" : "void",
    "comment" : "\n     * Get the link layer stats polling interval, in milliseconds.\n     *\n     * @param executor The executor on which callback will be invoked.\n     * @param resultsCallback An asynchronous callback that will return current\n     *                        link layer stats polling interval in milliseconds.\n     *\n     * @throws UnsupportedOperationException if the API is not supported on this SDK version.\n     * @throws SecurityException if the caller does not have permission.\n     * @throws NullPointerException if the caller provided invalid inputs.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setMloMode(@MloMode int mode, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Boolean> resultsCallback)",
    "returnType" : "void",
    "comment" : "\n     * This API allows a privileged application to set Multi-Link Operation mode.\n     *\n     * Multi-link operation (MLO) will allow Wi-Fi devices to operate on multiple links at the same\n     * time through a single connection, aiming to support applications that require lower latency,\n     * and higher capacity. Chip vendors have algorithms that run on the chip to use available links\n     * based on incoming traffic and various inputs. This API allows system application to give a\n     * suggestion to such algorithms on its preference using {@link MloMode}.\n     *\n     *\n     * @param mode Refer {@link MloMode} for supported modes.\n     * @param executor The executor on which callback will be invoked.\n     * @param resultsCallback An asynchronous callback that will return {@code Boolean} indicating\n     *                        whether the MLO mode is successfully set or not.\n     * @throws IllegalArgumentException if mode value is not in {@link MloMode}.\n     * @throws NullPointerException if the caller provided a null input.\n     * @throws SecurityException if caller does not have the required permissions.\n     * @throws UnsupportedOperationException if the set operation is not supported on this SDK.\n     * @hide\n     ",
    "links" : [ "MloMode" ]
  }, {
    "name" : "public void getMloMode(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Integer> resultsCallback)",
    "returnType" : "void",
    "comment" : "\n     * This API allows a privileged application to get Multi-Link Operation mode. Refer\n     * {@link WifiManager#setMloMode(int, Executor, Consumer)}  for more details.\n     *\n     * @param executor The executor on which callback will be invoked.\n     * @param resultsCallback An asynchronous callback that will return current MLO mode. Returns\n     *                        {@link MloMode#MLO_MODE_DEFAULT} if information is not available,\n     *                        e.g. if the driver/firmware doesn't provide this information.\n     * @throws NullPointerException if the caller provided a null input.\n     * @throws SecurityException if caller does not have the required permissions.\n     * @throws UnsupportedOperationException if the get operation is not supported on this SDK.\n     * @hide\n     ",
    "links" : [ "#MLO_MODE_DEFAULT", "android.net.wifi.WifiManager#setMloMode(int" ]
  }, {
    "name" : "public void getMaxMloAssociationLinkCount(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Integer> resultsCallback)",
    "returnType" : "void",
    "comment" : "\n     * Get the maximum number of links supported by the chip for MLO association. e.g. if the Wi-Fi\n     * chip supports eMLSR (Enhanced Multi-Link Single Radio) and STR (Simultaneous Transmit and\n     * Receive) with following capabilities,\n     * - Max MLO assoc link count = 3.\n     * - Max MLO STR link count   = 2. See\n     * {@link WifiManager#getMaxMloStrLinkCount(Executor, Consumer)}\n     * One of the possible configuration is - STR (2.4 GHz , eMLSR(5 GHz, 6 GHz)), provided the\n     * radio combination of the chip supports it.\n     *\n     * @param executor        The executor on which callback will be invoked.\n     * @param resultsCallback An asynchronous callback that will return maximum MLO association link\n     *                        count supported by the chip or -1 if error or not available.\n     * @throws NullPointerException          if the caller provided a null input.\n     * @throws SecurityException             if caller does not have the required permissions.\n     * @throws UnsupportedOperationException if the get operation is not supported on this SDK.\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getMaxMloStrLinkCount(Executor" ]
  }, {
    "name" : "public void getMaxMloStrLinkCount(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Integer> resultsCallback)",
    "returnType" : "void",
    "comment" : "\n     * Get the maximum number of STR links used in Multi-Link Operation. The maximum number of STR\n     * links used for MLO can be different from the number of radios supported by the chip. e.g. if\n     * the Wi-Fi chip supports eMLSR (Enhanced Multi-Link Single Radio) and STR (Simultaneous\n     * Transmit and Receive) with following capabilities,\n     * - Max MLO assoc link count = 3. See\n     *   {@link WifiManager#getMaxMloAssociationLinkCount(Executor, Consumer)}.\n     * - Max MLO STR link count   = 2.\n     * One of the possible configuration is - STR (2.4 GHz, eMLSR(5 GHz, 6 GHz)), provided the radio\n     * combination of the chip supports it.\n     *\n     * @param executor The executor on which callback will be invoked.\n     * @param resultsCallback An asynchronous callback that will return maximum STR link count\n     *                       supported by the chip in MLO mode or -1 if error or not available.\n     * @throws NullPointerException if the caller provided a null input.\n     * @throws SecurityException if caller does not have the required permissions.\n     * @throws UnsupportedOperationException if the get operation is not supported on this SDK\n     * @hide\n     ",
    "links" : [ "android.net.wifi.WifiManager#getMaxMloAssociationLinkCount(Executor" ]
  }, {
    "name" : "public void getSupportedSimultaneousBandCombinations(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<List<int[]>> resultsCallback)",
    "returnType" : "void",
    "comment" : "\n     * Get the set of band combinations supported simultaneously by the Wi-Fi Chip.\n     *\n     * Note: This method returns simultaneous band operation combination and not multichannel\n     * concurrent operation (MCC) combination.\n     *\n     * @param executor The executor on which callback will be invoked.\n     * @param resultsCallback An asynchronous callback that will return a list of possible\n     *                        simultaneous band combinations supported by the chip or empty list if\n     *                        not available. Band value is defined in {@link WifiScanner.WifiBand}.\n     * @throws NullPointerException if the caller provided a null input.\n     * @throws SecurityException if caller does not have the required permissions.\n     * @throws UnsupportedOperationException if the get operation is not supported on this SDK.\n     * @hide\n     ",
    "links" : [ "WifiScanner.WifiBand" ]
  }, {
    "name" : "public void setWepAllowed(boolean isAllowed)",
    "returnType" : "void",
    "comment" : "\n     * This API allows a privileged application to set whether or not this device allows\n     * connections to Wi-Fi WEP networks.\n     *\n     * Note: The WEP connections may not work even if caller invokes this method with {@code true}\n     * because device may NOT support connections to Wi-Fi WEP networks.\n     * See: {@link #isWepSupported()}.\n     *\n     * @param isAllowed whether or not the user allow connections to Wi-Fi WEP networks.\n     * @throws SecurityException if the caller does not have permission.\n     * @hide\n     ",
    "links" : [ "#isWepSupported()" ]
  }, {
    "name" : "public void queryWepAllowed(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Boolean> resultsCallback)",
    "returnType" : "void",
    "comment" : "\n     * Query whether or not this device is configured to allow connections to Wi-Fi WEP networks.\n     * @see #setWepAllowed(boolean)\n     *\n     * Note: The WEP connections may not work even if this method returns {@code true} in the\n     * result callback because device may NOT support connections to Wi-Fi WEP networks.\n     * See: {@link #isWepSupported()}.\n     *\n     * @param executor The executor on which callback will be invoked.\n     * @param resultsCallback An asynchronous callback that will return {@code Boolean} indicating\n     *                        whether wep network support is enabled/disabled.\n     *\n     * @throws SecurityException if the caller does not have permission.\n     * @hide\n     ",
    "links" : [ "#isWepSupported()" ]
  }, {
    "name" : "public void enableMscs(@NonNull MscsParams mscsParams)",
    "returnType" : "void",
    "comment" : "\n     * Enable Mirrored Stream Classification Service (MSCS) and configure using\n     * the provided configuration values.\n     *\n     * If MSCS has already been enabled/configured, this will override the\n     * existing configuration.\n     *\n     * Refer to Section 11.25.3 of the IEEE 802.11-2020 standard for more information.\n     *\n     * @param mscsParams {@link MscsParams} object containing the configuration parameters.\n     * @hide\n     ",
    "links" : [ "android.net.wifi.MscsParams" ]
  }, {
    "name" : "public void disableMscs()",
    "returnType" : "void",
    "comment" : "\n     * Disable Mirrored Stream Classification Service (MSCS).\n     *\n     * If MSCS is enabled/configured, this will send a remove request to the AP.\n     *\n     * Refer to Section 11.25.3 of the IEEE 802.11-2020 standard for more information.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSendDhcpHostnameRestriction(@SendDhcpHostnameRestriction int restriction)",
    "returnType" : "void",
    "comment" : "\n     * Sets the global restrictions on which networks to send the device hostname to during DHCP.\n     *\n     * @param restriction Bitmask of {@link SendDhcpHostnameRestriction}, or none to indicate no\n     *                    restriction.\n     * @throws IllegalArgumentException if input is invalid\n     * @throws SecurityException if the calling app is not a Device Owner (DO), or a privileged app\n     *                           that has one of the permissions required by this API.\n     ",
    "links" : [ "SendDhcpHostnameRestriction" ]
  }, {
    "name" : "public void querySendDhcpHostnameRestriction(@NonNull @CallbackExecutor Executor executor, @NonNull IntConsumer resultsCallback)",
    "returnType" : "void",
    "comment" : "\n     * Query the global restriction on which networks to send the device hostname to during DHCP.\n     * @see #setSendDhcpHostnameRestriction(int)\n     *\n     * @param executor The executor on which callback will be invoked.\n     * @param resultsCallback An asynchronous callback that will return a bitmask of\n     *                        {@link SendDhcpHostnameRestriction}.\n     *\n     * @throws SecurityException if the calling app is not a Device Owner (DO), or a privileged app\n     *                           that has one of the permissions required by this API.\n     ",
    "links" : [ "SendDhcpHostnameRestriction" ]
  }, {
    "name" : "public boolean isAggressiveRoamingModeSupported()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if this device supports Aggressive roaming mode\n     * {@link #setPerSsidRoamingMode(WifiSsid, int)}\n     ",
    "links" : [ "#setPerSsidRoamingMode(WifiSsid" ]
  }, {
    "name" : "public void setPerSsidRoamingMode(@NonNull WifiSsid ssid, @RoamingMode int roamingMode)",
    "returnType" : "void",
    "comment" : "\n     * This API allows a privileged application to set roaming mode per SSID.\n     *\n     * Available for DO/COPE apps.\n     * Other apps require {@code android.Manifest.permission#NETWORK_SETTINGS} or\n     * {@code android.Manifest.permission#MANAGE_WIFI_NETWORK_SELECTION} permission.\n     *\n     * @param ssid SSID to be mapped to apply roaming policy\n     * @param roamingMode refer {@link RoamingMode} for supported modes.\n     * @throws IllegalArgumentException if mode value is not in {@link RoamingMode}.\n     * @throws NullPointerException if the caller provided a null input.\n     * @throws SecurityException if caller does not have the required permission.\n     * @throws UnsupportedOperationException if the set operation is not supported on this SDK or\n     *                                       if the feature is not available\n     *                                       {@link #isAggressiveRoamingModeSupported()}.\n     ",
    "links" : [ "#isAggressiveRoamingModeSupported()", "RoamingMode" ]
  }, {
    "name" : "public void removePerSsidRoamingMode(@NonNull WifiSsid ssid)",
    "returnType" : "void",
    "comment" : "\n     * This API allows a privileged application to remove roaming mode policy\n     * configured using the {@link #setPerSsidRoamingMode(WifiSsid, int)}.\n     *\n     * Available for DO/COPE apps.\n     * Other apps require {@code android.Manifest.permission#NETWORK_SETTINGS} or\n     * {@code android.Manifest.permission#MANAGE_WIFI_NETWORK_SELECTION} permission.\n     *\n     * @param ssid SSID to be removed from the roaming mode policy.\n     * @throws NullPointerException if the caller provided a null input.\n     * @throws SecurityException if caller does not have the required permission.\n     * @throws UnsupportedOperationException if the set operation is not supported on this SDK or\n     *                                       if the feature is not available\n     *                                       {@link #isAggressiveRoamingModeSupported()}.\n     ",
    "links" : [ "#setPerSsidRoamingMode(WifiSsid", "#isAggressiveRoamingModeSupported()" ]
  }, {
    "name" : "public void getPerSsidRoamingModes(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Map<String, Integer>> resultsCallback)",
    "returnType" : "void",
    "comment" : "\n     * This API allows a privileged application to get roaming mode policies\n     * configured using the {@link #setPerSsidRoamingMode(WifiSsid, int)}.\n     *\n     * Available for DO/COPE apps.\n     * Other apps require {@code android.Manifest.permission#NETWORK_SETTINGS} or\n     * {@code android.Manifest.permission#MANAGE_WIFI_NETWORK_SELECTION} permission.\n     *\n     * @param executor The executor on which callback will be invoked.\n     * @param resultsCallback An asynchronous callback that will return the corresponding\n     *                        roaming policies for the API caller.\n     * @throws SecurityException if caller does not have the required permission.\n     * @throws UnsupportedOperationException if the get operation is not supported on this SDK or\n     *                                       if the feature is not available\n     *                                       {@link #isAggressiveRoamingModeSupported()}.\n     ",
    "links" : [ "#setPerSsidRoamingMode(WifiSsid", "#isAggressiveRoamingModeSupported()" ]
  }, {
    "name" : "public void getTwtCapabilities(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Bundle> resultCallback)",
    "returnType" : "void",
    "comment" : "\n     * Get target wake time (TWT) capabilities of the primary station interface.\n     *\n     * Note: Target wake time feature is only supported for primary station. If Wi-Fi is off or the\n     * capability is not available the asynchronous callback will be called with the bundle\n     * with values { false, -1, -1, -1, -1 }.\n     *\n     * @param executor Executor to execute listener callback\n     * @param resultCallback An asynchronous callback that will return a bundle for target wake time\n     *                       capabilities. See {@link TwtCapabilities} for the string keys for\n     *                       the bundle.\n     * @throws SecurityException if the caller does not have permission.\n     * @throws NullPointerException if the caller provided null inputs.\n     * @throws UnsupportedOperationException if the API is not supported.\n     * @hide\n     ",
    "links" : [ "TwtCapabilities" ]
  }, {
    "name" : "public void setupTwtSession(@NonNull TwtRequest twtRequest, @NonNull @CallbackExecutor Executor executor, @NonNull TwtSessionCallback callback)",
    "returnType" : "void",
    "comment" : "\n     * Set up a TWT session with a TWT responder capable AP. Only supported for primary connected\n     * station which is a TWT requester. See {@link #getTwtCapabilities(Executor, Consumer)} and\n     * {@link ScanResult#isTwtResponder()} to check station and AP support.\n     *\n     * Following callbacks are invoked,\n     *  - {@link TwtSessionCallback#onFailure(int)} upon error with error code.\n     *  - {@link TwtSessionCallback#onCreate(TwtSession)} upon TWT session creation.\n     *  - {@link TwtSessionCallback#onTeardown(int)} upon TWT session teardown.\n     *\n     * Note: {@link #getTwtCapabilities(Executor, Consumer)} gives {@link TwtCapabilities} which can\n     * be used to fill in the valid TWT wake interval and duration ranges for {@link TwtRequest}.\n     *\n     * @param twtRequest TWT request\n     * @param executor Executor to execute listener callback on\n     * @param callback Callback to register\n     * @throws SecurityException if the caller does not have permission.\n     * @throws NullPointerException if the caller provided null inputs.\n     * @throws UnsupportedOperationException if the API is not supported.\n     * @hide\n     ",
    "links" : [ "TwtCapabilities", "android.net.wifi.twt.TwtRequest", "#getTwtCapabilities(Executor", "android.net.wifi.twt.TwtSessionCallback#onFailure(int)", "android.net.wifi.ScanResult#isTwtResponder()", "android.net.wifi.twt.TwtSessionCallback#onTeardown(int)", "android.net.wifi.twt.TwtSessionCallback#onCreate(TwtSession)" ]
  }, {
    "name" : "public void getStatsTwtSession(@NonNull int sessionId, @NonNull Executor executor, @NonNull Consumer<Bundle> resultCallback)",
    "returnType" : "void",
    "comment" : "\n     * Get stats of the target wake time session.\n     *\n     * Note: For Internal use only. Expected to be called through\n     * {@link TwtSession#getStats(Executor, Consumer)}. If the command fails, -1 will be returned\n     * for all stats values.\n     *\n     * @param sessionId TWT session id\n     * @param executor The executor on which callback will be invoked.\n     * @param resultCallback The asynchronous callback that will return bundle with key string\n     *                       {@link TwtSession.TwtStats}.\n     *\n     * @throws SecurityException if the caller does not have permission.\n     * @throws NullPointerException if the caller provided null inputs.\n     * @throws UnsupportedOperationException if the API is not supported or primary station is\n     * not connected.\n     * @hide\n     ",
    "links" : [ "android.net.wifi.twt.TwtSession#getStats(Executor", "TwtSession.TwtStats" ]
  }, {
    "name" : "public void teardownTwtSession(int sessionId)",
    "returnType" : "void",
    "comment" : "\n     * Teardown the target wake time session. Only owner can teardown the session.\n     *\n     * Note: For internal use only. Expected to be called through\n     * {@link TwtSessionCallback#onTeardown(int)}.\n     *\n     * @param sessionId TWT session id\n     * @throws SecurityException if the caller does not have permission.\n     * @throws UnsupportedOperationException if the API is not supported or primary station is not\n     * connected.\n     * @hide\n     ",
    "links" : [ "android.net.wifi.twt.TwtSessionCallback#onTeardown(int)" ]
  }, {
    "name" : "public void setD2dAllowedWhenInfraStaDisabled(boolean isAllowed)",
    "returnType" : "void",
    "comment" : "\n     * Allows a privileged application to set whether or not this device allows\n     * device-to-device connections when infra STA is disabled. Callers can use\n     * {@link #queryD2dAllowedWhenInfraStaDisabled(Executor, Consumer)} to check the currently\n     * set value.\n     *\n     * Note: This functionality is supported only when the device support device-to-device\n     * when infra STA is disabled. Use {@link #isD2dSupportedWhenInfraStaDisabled()} to\n     * know if device supported device-to-device when infra STA is disabled.\n     *\n     * @param isAllowed whether or not the device allows to device-to-device connectivity when\n     *                  infra STA is disabled.\n     * @throws SecurityException if the caller does not have permission.\n     * @hide\n     ",
    "links" : [ "#queryD2dAllowedWhenInfraStaDisabled(Executor", "#isD2dSupportedWhenInfraStaDisabled()" ]
  }, {
    "name" : "public void queryD2dAllowedWhenInfraStaDisabled(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Boolean> resultsCallback)",
    "returnType" : "void",
    "comment" : "\n     * Query whether or not this device is configured to allow D2d connection when\n     * infra STA is disabled.\n     * see: {@link #setD2dAllowedWhenInfraStaDisabled(boolean)}.\n     *\n     *\n     * @param executor The executor on which callback will be invoked.\n     * @param resultsCallback An asynchronous callback that will return {@code Boolean} indicating\n     *                        whether device-to-device connection is allowed or disallowed\n     *                        when infra STA is disabled.\n     * @hide\n     ",
    "links" : [ "#setD2dAllowedWhenInfraStaDisabled(boolean)" ]
  } ],
  "methodNames" : [ "public static int getMaxNumberOfPoliciesPerQosRequest()", "public List<WifiConfiguration> getConfiguredNetworks()", "public List<WifiConfiguration> getCallerConfiguredNetworks()", "public List<WifiConfiguration> getPrivilegedConfiguredNetworks()", "public WifiConfiguration getPrivilegedConnectedNetwork()", "public List<Pair<WifiConfiguration, Map<Integer, List<ScanResult>>>> getAllMatchingWifiConfigs(@NonNull List<ScanResult> scanResults)", "public void setNetworkSelectionConfig(@NonNull WifiNetworkSelectionConfig nsConfig)", "public void getNetworkSelectionConfig(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<WifiNetworkSelectionConfig> resultsCallback)", "public void setThirdPartyAppEnablingWifiConfirmationDialogEnabled(boolean enable)", "public boolean isThirdPartyAppEnablingWifiConfirmationDialogEnabled()", "public void setScreenOnScanSchedule(@Nullable List<ScreenOnScanSchedule> screenOnScanSchedule)", "public void setOneShotScreenOnConnectivityScanDelayMillis(@IntRange(from = 0) int delayMs)", "public List<WifiConfiguration> getWifiConfigForMatchedNetworkSuggestionsSharedWithUser(@NonNull List<ScanResult> scanResults)", "public void setSsidsAllowlist(@NonNull Set<WifiSsid> ssids)", "public Set<WifiSsid> getSsidsAllowlist()", "public Map<OsuProvider, List<ScanResult>> getMatchingOsuProviders(@Nullable List<ScanResult> scanResults)", "public Map<OsuProvider, PasspointConfiguration> getMatchingPasspointConfigsForOsuProviders(@NonNull Set<OsuProvider> osuProviders)", "public int addNetwork(WifiConfiguration config)", "public AddNetworkResult addNetworkPrivileged(@NonNull WifiConfiguration config)", "public int updateNetwork(WifiConfiguration config)", "private int addOrUpdateNetwork(WifiConfiguration config)", "public void registerNetworkRequestMatchCallback(@NonNull @CallbackExecutor Executor executor, @NonNull NetworkRequestMatchCallback callback)", "public void unregisterNetworkRequestMatchCallback(@NonNull NetworkRequestMatchCallback callback)", "public void removeAppState(int targetAppUid, @NonNull String targetAppPackageName)", "public int addNetworkSuggestions(@NonNull List<WifiNetworkSuggestion> networkSuggestions)", "public int removeNetworkSuggestions(@NonNull List<WifiNetworkSuggestion> networkSuggestions)", "public int removeNetworkSuggestions(@NonNull List<WifiNetworkSuggestion> networkSuggestions, @ActionAfterRemovingSuggestion int action)", "public List<WifiNetworkSuggestion> getNetworkSuggestions()", "public int getMaxNumberOfNetworkSuggestionsPerApp()", "public static int getMaxNumberOfNetworkSuggestionsPerApp(boolean isLowRamDevice)", "public void addOrUpdatePasspointConfiguration(PasspointConfiguration config)", "public void removePasspointConfiguration(String fqdn)", "public List<PasspointConfiguration> getPasspointConfigurations()", "public void queryPasspointIcon(long bssid, String fileName)", "public int matchProviderWithCurrentNetwork(String fqdn)", "public boolean removeNetwork(int netId)", "public boolean removeNonCallerConfiguredNetworks()", "public boolean enableNetwork(int netId, boolean attemptConnect)", "public boolean disableNetwork(int netId)", "public boolean disconnect()", "public boolean reconnect()", "public boolean reassociate()", "public boolean pingSupplicant()", "private long getSupportedFeatures()", "private boolean isFeatureSupported(long feature)", "public boolean isPasspointSupported()", "public boolean isP2pSupported()", "public boolean isPortableHotspotSupported()", "public boolean isWifiScannerSupported()", "public boolean isWifiAwareSupported()", "public boolean isStaApConcurrencySupported()", "public boolean isStaConcurrencyForLocalOnlyConnectionsSupported()", "public boolean isMakeBeforeBreakWifiSwitchingSupported()", "public boolean isStaConcurrencyForMultiInternetSupported()", "public boolean isStaConcurrencyForRestrictedConnectionsSupported()", "public boolean isDeviceToDeviceRttSupported()", "public boolean isDeviceToApRttSupported()", "public boolean isPreferredNetworkOffloadSupported()", "public boolean isTdlsSupported()", "public boolean isOffChannelTdlsSupported()", "public boolean isEnhancedPowerReportingSupported()", "public boolean isConnectedMacRandomizationSupported()", "public boolean isApMacRandomizationSupported()", "public boolean isLowLatencyModeSupported()", "public boolean is24GHzBandSupported()", "public boolean is5GHzBandSupported()", "public boolean is60GHzBandSupported()", "public boolean is6GHzBandSupported()", "public boolean isWifiStandardSupported(@WifiAnnotations.WifiStandard int standard)", "public boolean isStaBridgedApConcurrencySupported()", "public boolean isBridgedApConcurrencySupported()", "public boolean isD2dSupportedWhenInfraStaDisabled()", "public void getWifiActivityEnergyInfoAsync(@NonNull @CallbackExecutor Executor executor, @NonNull OnWifiActivityEnergyInfoListener listener)", "public boolean startScan()", "public boolean startScan(WorkSource workSource)", "public String getCurrentNetworkWpsNfcConfigurationToken()", "public WifiInfo getConnectionInfo()", "public List<ScanResult> getScanResults()", "public Map<WifiNetworkSuggestion, List<ScanResult>> getMatchingScanResults(@NonNull List<WifiNetworkSuggestion> networkSuggestionsToMatch, @Nullable List<ScanResult> scanResults)", "public void setScanAlwaysAvailable(boolean isAvailable)", "public boolean isScanAlwaysAvailable()", "public void getChannelData(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<List<Bundle>> resultsCallback)", "public boolean saveConfiguration()", "public void registerActiveCountryCodeChangedCallback(@NonNull @CallbackExecutor Executor executor, @NonNull ActiveCountryCodeChangedCallback callback)", "public void unregisterActiveCountryCodeChangedCallback(@NonNull ActiveCountryCodeChangedCallback callback)", "public void addWifiNetworkStateChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull WifiNetworkStateChangedListener listener)", "public void removeWifiNetworkStateChangedListener(@NonNull WifiNetworkStateChangedListener listener)", "public String getCountryCode()", "public void setOverrideCountryCode(@NonNull String country)", "public void clearOverrideCountryCode()", "public void setDefaultCountryCode(@NonNull String country)", "public DhcpInfo getDhcpInfo()", "public boolean setWifiEnabled(boolean enabled)", "public void registerSubsystemRestartTrackingCallback(@NonNull @CallbackExecutor Executor executor, @NonNull SubsystemRestartTrackingCallback callback)", "public void unregisterSubsystemRestartTrackingCallback(@NonNull SubsystemRestartTrackingCallback callback)", "public void restartWifiSubsystem()", "public int getWifiState()", "public boolean isWifiEnabled()", "public static int calculateSignalLevel(int rssi, int numLevels)", "public int calculateSignalLevel(int rssi)", "public int getMaxSignalLevel()", "public static int compareSignalLevel(int rssiA, int rssiB)", "public void updateInterfaceIpState(@Nullable String ifaceName, @IfaceIpMode int mode)", "public boolean isDefaultCoexAlgorithmEnabled()", "public void setCoexUnsafeChannels(@NonNull List<CoexUnsafeChannel> unsafeChannels, @CoexRestriction int restrictions)", "public void registerCoexCallback(@NonNull @CallbackExecutor Executor executor, @NonNull CoexCallback callback)", "public void unregisterCoexCallback(@NonNull CoexCallback callback)", "public boolean startSoftAp(@Nullable WifiConfiguration wifiConfig)", "public boolean startTetheredHotspot(@Nullable SoftApConfiguration softApConfig)", "public void startTetheredHotspot(@NonNull TetheringManager.TetheringRequest request, @NonNull @CallbackExecutor Executor executor, @NonNull SoftApCallback callback)", "public boolean stopSoftAp()", "public boolean validateSoftApConfiguration(@NonNull SoftApConfiguration config)", "public void startLocalOnlyHotspot(LocalOnlyHotspotCallback callback, @Nullable Handler handler)", "public void startLocalOnlyHotspot(@NonNull SoftApConfiguration config, @Nullable @CallbackExecutor Executor executor, @Nullable LocalOnlyHotspotCallback callback)", "private void startLocalOnlyHotspotInternal(@Nullable SoftApConfiguration config, @Nullable @CallbackExecutor Executor executor, @Nullable LocalOnlyHotspotCallback callback)", "public void cancelLocalOnlyHotspotRequest()", "private void stopLocalOnlyHotspot()", "public void registerLocalOnlyHotspotSoftApCallback(@NonNull @CallbackExecutor Executor executor, @NonNull SoftApCallback callback)", "public void unregisterLocalOnlyHotspotSoftApCallback(@NonNull SoftApCallback callback)", "public void watchLocalOnlyHotspot(LocalOnlyHotspotObserver observer, @Nullable Handler handler)", "public void unregisterLocalOnlyHotspotObserver()", "public int getWifiApState()", "public boolean isWifiApEnabled()", "public WifiConfiguration getWifiApConfiguration()", "public SoftApConfiguration getSoftApConfiguration()", "public void queryLastConfiguredTetheredApPassphraseSinceBoot(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<String> resultCallback)", "public boolean setWifiApConfiguration(WifiConfiguration wifiConfig)", "public boolean setSoftApConfiguration(@NonNull SoftApConfiguration softApConfig)", "public void setTdlsEnabled(InetAddress remoteIPAddress, boolean enable)", "public void setTdlsEnabled(@NonNull InetAddress remoteIPAddress, boolean enable, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Boolean> resultsCallback)", "public void setTdlsEnabledWithMacAddress(String remoteMacAddress, boolean enable)", "public void setTdlsEnabledWithMacAddress(@NonNull String remoteMacAddress, boolean enable, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Boolean> resultsCallback)", "public void isTdlsOperationCurrentlyAvailable(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Boolean> resultsCallback)", "public void getMaxSupportedConcurrentTdlsSessions(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Integer> resultsCallback)", "public void getNumberOfEnabledTdlsSessions(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Integer> resultsCallback)", "public void registerSoftApCallback(@NonNull @CallbackExecutor Executor executor, @NonNull SoftApCallback callback)", "public void unregisterSoftApCallback(@NonNull SoftApCallback callback)", "private void connectInternal(@Nullable WifiConfiguration config, int networkId, @Nullable ActionListener listener)", "public void connect(@NonNull WifiConfiguration config, @Nullable ActionListener listener)", "public void connect(int networkId, @Nullable ActionListener listener)", "public void startRestrictingAutoJoinToSubscriptionId(int subscriptionId)", "public void stopRestrictingAutoJoinToSubscriptionId()", "public void save(@NonNull WifiConfiguration config, @Nullable ActionListener listener)", "public void forget(int netId, @Nullable ActionListener listener)", "public void disable(int netId, @Nullable ActionListener listener)", "public void allowAutojoinGlobal(boolean allowAutojoin)", "public void queryAutojoinGlobal(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Boolean> resultsCallback)", "public void allowAutojoin(int netId, boolean allowAutojoin)", "public void allowAutojoinPasspoint(@NonNull String fqdn, boolean allowAutojoin)", "public void setMacRandomizationSettingPasspointEnabled(@NonNull String fqdn, boolean enable)", "public void setPasspointMeteredOverride(@NonNull String fqdn, @WifiConfiguration.MeteredOverride int meteredOverride)", "public void disableEphemeralNetwork(@NonNull String network)", "public void startWps(WpsInfo config, WpsCallback listener)", "public void cancelWps(WpsCallback listener)", "public WifiLock createWifiLock(int lockType, String tag)", "public void addWifiLowLatencyLockListener(@NonNull @CallbackExecutor Executor executor, @NonNull WifiLowLatencyLockListener listener)", "public void removeWifiLowLatencyLockListener(@NonNull WifiLowLatencyLockListener listener)", "public WifiLock createWifiLock(String tag)", "public MulticastLock createMulticastLock(String tag)", "public boolean isMulticastEnabled()", "public boolean initializeMulticastFiltering()", "public void setVerboseLoggingEnabled(boolean enable)", "public void setVerboseLoggingLevel(@VerboseLoggingLevel int verbose)", "public void enableVerboseLogging(@VerboseLoggingLevel int verbose)", "public boolean isVerboseLoggingEnabled()", "public int getVerboseLoggingLevel()", "public void factoryReset()", "public Network getCurrentNetwork()", "public boolean setEnableAutoJoinWhenAssociated(boolean enabled)", "public boolean getEnableAutoJoinWhenAssociated()", "public void retrieveWifiBackupData(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<byte[]> resultsCallback)", "public void restoreWifiBackupData(@NonNull byte[] data)", "public byte[] retrieveBackupData()", "public void restoreBackupData(@NonNull byte[] data)", "public byte[] retrieveSoftApBackupData()", "public SoftApConfiguration restoreSoftApBackupData(@NonNull byte[] data)", "public void restoreSupplicantBackupData(@NonNull byte[] supplicantData, @NonNull byte[] ipConfigData)", "public void startSubscriptionProvisioning(@NonNull OsuProvider provider, @NonNull @CallbackExecutor Executor executor, @NonNull ProvisioningCallback callback)", "public void registerTrafficStateCallback(@NonNull @CallbackExecutor Executor executor, @NonNull TrafficStateCallback callback)", "public void unregisterTrafficStateCallback(@NonNull TrafficStateCallback callback)", "private void updateVerboseLoggingEnabledFromService()", "public boolean isWpa3SaeSupported()", "public boolean isWpa3SuiteBSupported()", "public boolean isEnhancedOpenSupported()", "public boolean isEasyConnectSupported()", "public boolean isEasyConnectEnrolleeResponderModeSupported()", "public boolean isWapiSupported()", "public boolean isWpa3SaePublicKeySupported()", "public boolean isPasspointTermsAndConditionsSupported()", "public boolean isWpa3SaeH2eSupported()", "public boolean isWifiDisplayR2Supported()", "public boolean isDecoratedIdentitySupported()", "public boolean isTrustOnFirstUseSupported()", "public boolean isEasyConnectDppAkmSupported()", "public boolean isTlsMinimumVersionSupported()", "public boolean isTlsV13Supported()", "public boolean isDualBandSimultaneousSupported()", "public boolean isTidToLinkMappingNegotiationSupported()", "public boolean isWepSupported()", "public boolean isWpaPersonalSupported()", "public String[] getFactoryMacAddresses()", "public void setDeviceMobilityState(@DeviceMobilityState int state)", "public void startEasyConnectAsConfiguratorInitiator(@NonNull String enrolleeUri, int selectedNetworkId, @EasyConnectNetworkRole int enrolleeNetworkRole, @NonNull @CallbackExecutor Executor executor, @NonNull EasyConnectStatusCallback callback)", "public void startEasyConnectAsEnrolleeInitiator(@NonNull String configuratorUri, @NonNull @CallbackExecutor Executor executor, @NonNull EasyConnectStatusCallback callback)", "public void startEasyConnectAsEnrolleeResponder(@Nullable String deviceInfo, @EasyConnectCryptographyCurve int curve, @NonNull @CallbackExecutor Executor executor, @NonNull EasyConnectStatusCallback callback)", "public static int getEasyConnectMaxAllowedResponderDeviceInfoLength()", "public void stopEasyConnectSession()", "public void addOnWifiUsabilityStatsListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnWifiUsabilityStatsListener listener)", "public void removeOnWifiUsabilityStatsListener(@NonNull OnWifiUsabilityStatsListener listener)", "public void updateWifiUsabilityScore(int seqNum, int score, int predictionHorizonSec)", "public void registerScanResultsCallback(@NonNull @CallbackExecutor Executor executor, @NonNull ScanResultsCallback callback)", "public void unregisterScanResultsCallback(@NonNull ScanResultsCallback callback)", "public void addWifiVerboseLoggingStatusChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull WifiVerboseLoggingStatusChangedListener listener)", "public void removeWifiVerboseLoggingStatusChangedListener(@NonNull WifiVerboseLoggingStatusChangedListener listener)", "public void addSuggestionConnectionStatusListener(@NonNull @CallbackExecutor Executor executor, @NonNull SuggestionConnectionStatusListener listener)", "public void removeSuggestionConnectionStatusListener(@NonNull SuggestionConnectionStatusListener listener)", "public void addLocalOnlyConnectionFailureListener(@NonNull @CallbackExecutor Executor executor, @NonNull LocalOnlyConnectionFailureListener listener)", "public void removeLocalOnlyConnectionFailureListener(@NonNull LocalOnlyConnectionFailureListener listener)", "public static SparseArray<int[]> parseDppChannelList(String channelList)", "public void setExternalPnoScanRequest(@NonNull List<WifiSsid> ssids, @Nullable int[] frequencies, @NonNull @CallbackExecutor Executor executor, @NonNull PnoScanResultsCallback callback)", "public void setPnoScanState(@PnoScanState int pnoScanState)", "public void setPnoScanEnabled(boolean enabled, boolean enablePnoScanAfterWifiToggle)", "public void clearExternalPnoScanRequest()", "public void getLastCallerInfoForApi(@ApiType int apiType, @NonNull @CallbackExecutor Executor executor, @NonNull BiConsumer<String, Boolean> resultsCallback)", "public boolean setWifiConnectedNetworkScorer(@NonNull @CallbackExecutor Executor executor, @NonNull WifiConnectedNetworkScorer scorer)", "public void clearWifiConnectedNetworkScorer()", "public void setScanThrottleEnabled(boolean enable)", "public boolean isScanThrottleEnabled()", "public void setAutoWakeupEnabled(boolean enable)", "public boolean isAutoWakeupEnabled()", "public void setCarrierNetworkOffloadEnabled(int subscriptionId, boolean merged, boolean enabled)", "public boolean isCarrierNetworkOffloadEnabled(int subscriptionId, boolean merged)", "public void addSuggestionUserApprovalStatusListener(@NonNull @CallbackExecutor Executor executor, @NonNull SuggestionUserApprovalStatusListener listener)", "public void removeSuggestionUserApprovalStatusListener(@NonNull SuggestionUserApprovalStatusListener listener)", "public void setEmergencyScanRequestInProgress(boolean inProgress)", "public boolean setWifiScoringEnabled(boolean enabled)", "public void flushPasspointAnqpCache()", "public List<WifiAvailableChannel> getAllowedChannels(int band, @WifiAvailableChannel.OpMode int mode)", "public List<WifiAvailableChannel> getUsableChannels(int band, @WifiAvailableChannel.OpMode int mode)", "public boolean isWifiPasspointEnabled()", "public void setWifiPasspointEnabled(boolean enabled)", "public int getStaConcurrencyForMultiInternetMode()", "public void notifyMinimumRequiredWifiSecurityLevelChanged(int level)", "public void notifyWifiSsidPolicyChanged(@NonNull WifiSsidPolicy policy)", "public boolean setStaConcurrencyForMultiInternetMode(@WifiMultiInternetMode int mode)", "public Set<String> getOemPrivilegedWifiAdminPackages()", "public void replyToSimpleDialog(int dialogId, @DialogReply int reply)", "public void replyToP2pInvitationReceivedDialog(int dialogId, boolean accepted, @Nullable String optionalPin)", "public void addCustomDhcpOptions(@NonNull WifiSsid ssid, @NonNull byte[] oui, @NonNull List<DhcpOption> options)", "public void removeCustomDhcpOptions(@NonNull WifiSsid ssid, @NonNull byte[] oui)", "public void reportCreateInterfaceImpact(@WifiInterfaceType int interfaceType, boolean requireNewInterface, @NonNull @CallbackExecutor Executor executor, @NonNull BiConsumer<Boolean, Set<InterfaceCreationImpact>> resultCallback)", "public int getMaxNumberOfChannelsPerNetworkSpecifierRequest()", "public void addQosPolicies(@NonNull List<QosPolicyParams> policyParamsList, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<List<Integer>> resultsCallback)", "public void removeQosPolicies(@NonNull int[] policyIdList)", "public void removeAllQosPolicies()", "public void setLinkLayerStatsPollingInterval(@IntRange(from = 0) int intervalMs)", "public void getLinkLayerStatsPollingInterval(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Integer> resultsCallback)", "public void setMloMode(@MloMode int mode, @NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Boolean> resultsCallback)", "public void getMloMode(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Integer> resultsCallback)", "public void getMaxMloAssociationLinkCount(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Integer> resultsCallback)", "public void getMaxMloStrLinkCount(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Integer> resultsCallback)", "public void getSupportedSimultaneousBandCombinations(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<List<int[]>> resultsCallback)", "public void setWepAllowed(boolean isAllowed)", "public void queryWepAllowed(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Boolean> resultsCallback)", "public void enableMscs(@NonNull MscsParams mscsParams)", "public void disableMscs()", "public void setSendDhcpHostnameRestriction(@SendDhcpHostnameRestriction int restriction)", "public void querySendDhcpHostnameRestriction(@NonNull @CallbackExecutor Executor executor, @NonNull IntConsumer resultsCallback)", "public boolean isAggressiveRoamingModeSupported()", "public void setPerSsidRoamingMode(@NonNull WifiSsid ssid, @RoamingMode int roamingMode)", "public void removePerSsidRoamingMode(@NonNull WifiSsid ssid)", "public void getPerSsidRoamingModes(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Map<String, Integer>> resultsCallback)", "public void getTwtCapabilities(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Bundle> resultCallback)", "public void setupTwtSession(@NonNull TwtRequest twtRequest, @NonNull @CallbackExecutor Executor executor, @NonNull TwtSessionCallback callback)", "public void getStatsTwtSession(@NonNull int sessionId, @NonNull Executor executor, @NonNull Consumer<Bundle> resultCallback)", "public void teardownTwtSession(int sessionId)", "public void setD2dAllowedWhenInfraStaDisabled(boolean isAllowed)", "public void queryD2dAllowedWhenInfraStaDisabled(@NonNull @CallbackExecutor Executor executor, @NonNull Consumer<Boolean> resultsCallback)" ],
  "variableNames" : [ "TAG", "NOT_OVERRIDE_EXISTING_NETWORKS_ON_RESTORE", "ERROR_AUTHENTICATING", "ERROR_AUTH_FAILURE_NONE", "ERROR_AUTH_FAILURE_TIMEOUT", "ERROR_AUTH_FAILURE_WRONG_PSWD", "ERROR_AUTH_FAILURE_EAP_FAILURE", "NETWORK_SUGGESTIONS_MAX_PER_APP_LOW_RAM", "NETWORK_SUGGESTIONS_MAX_PER_APP_HIGH_RAM", "STATUS_NETWORK_SUGGESTIONS_SUCCESS", "STATUS_NETWORK_SUGGESTIONS_ERROR_INTERNAL", "STATUS_NETWORK_SUGGESTIONS_ERROR_APP_DISALLOWED", "STATUS_NETWORK_SUGGESTIONS_ERROR_ADD_DUPLICATE", "STATUS_NETWORK_SUGGESTIONS_ERROR_ADD_EXCEEDS_MAX_PER_APP", "STATUS_NETWORK_SUGGESTIONS_ERROR_REMOVE_INVALID", "STATUS_NETWORK_SUGGESTIONS_ERROR_ADD_NOT_ALLOWED", "STATUS_NETWORK_SUGGESTIONS_ERROR_ADD_INVALID", "STATUS_NETWORK_SUGGESTIONS_ERROR_RESTRICTED_BY_ADMIN", "STATUS_SUGGESTION_CONNECTION_FAILURE_UNKNOWN", "STATUS_SUGGESTION_CONNECTION_FAILURE_ASSOCIATION", "STATUS_SUGGESTION_CONNECTION_FAILURE_AUTHENTICATION", "STATUS_SUGGESTION_CONNECTION_FAILURE_IP_PROVISIONING", "STATUS_LOCAL_ONLY_CONNECTION_FAILURE_UNKNOWN", "STATUS_LOCAL_ONLY_CONNECTION_FAILURE_ASSOCIATION", "STATUS_LOCAL_ONLY_CONNECTION_FAILURE_AUTHENTICATION", "STATUS_LOCAL_ONLY_CONNECTION_FAILURE_IP_PROVISIONING", "STATUS_LOCAL_ONLY_CONNECTION_FAILURE_NOT_FOUND", "STATUS_LOCAL_ONLY_CONNECTION_FAILURE_NO_RESPONSE", "STATUS_SUGGESTION_APPROVAL_UNKNOWN", "STATUS_SUGGESTION_APPROVAL_PENDING", "STATUS_SUGGESTION_APPROVAL_APPROVED_BY_USER", "STATUS_SUGGESTION_APPROVAL_REJECTED_BY_USER", "STATUS_SUGGESTION_APPROVAL_APPROVED_BY_CARRIER_PRIVILEGE", "PNO_SCAN_STATE_DISABLED_UNTIL_REBOOT", "PNO_SCAN_STATE_DISABLED_UNTIL_WIFI_TOGGLE", "PNO_SCAN_STATE_ENABLED", "ACTION_REMOVE_SUGGESTION_LINGER", "ACTION_REMOVE_SUGGESTION_DISCONNECT", "EXTRA_PARAM_KEY_ATTRIBUTION_SOURCE", "ACTION_WIFI_SCAN_AVAILABILITY_CHANGED", "EXTRA_SCAN_AVAILABLE", "WIFI_CREDENTIAL_CHANGED_ACTION", "EXTRA_WIFI_CREDENTIAL_EVENT_TYPE", "EXTRA_WIFI_CREDENTIAL_SSID", "WIFI_CREDENTIAL_SAVED", "WIFI_CREDENTIAL_FORGOT", "PASSPOINT_HOME_NETWORK", "PASSPOINT_ROAMING_NETWORK", "API_SCANNING_ENABLED", "API_WIFI_ENABLED", "API_SOFT_AP", "API_TETHERED_HOTSPOT", "API_AUTOJOIN_GLOBAL", "API_SET_SCAN_SCHEDULE", "API_SET_ONE_SHOT_SCREEN_ON_CONNECTIVITY_SCAN_DELAY", "API_SET_NETWORK_SELECTION_CONFIG", "API_SET_THIRD_PARTY_APPS_ENABLING_WIFI_CONFIRMATION_DIALOG", "API_ADD_NETWORK", "API_UPDATE_NETWORK", "API_ALLOW_AUTOJOIN", "API_CONNECT_CONFIG", "API_CONNECT_NETWORK_ID", "API_DISABLE_NETWORK", "API_ENABLE_NETWORK", "API_FORGET", "API_SAVE", "API_START_SCAN", "API_START_LOCAL_ONLY_HOTSPOT", "API_P2P_DISCOVER_PEERS", "API_P2P_DISCOVER_PEERS_ON_SOCIAL_CHANNELS", "API_P2P_DISCOVER_PEERS_ON_SPECIFIC_FREQUENCY", "API_P2P_STOP_PEER_DISCOVERY", "API_P2P_CONNECT", "API_P2P_CANCEL_CONNECT", "API_P2P_CREATE_GROUP", "API_P2P_CREATE_GROUP_P2P_CONFIG", "API_P2P_REMOVE_GROUP", "API_P2P_START_LISTENING", "API_P2P_STOP_LISTENING", "API_P2P_SET_CHANNELS", "API_WIFI_SCANNER_START_SCAN", "API_SET_TDLS_ENABLED", "API_SET_TDLS_ENABLED_WITH_MAC_ADDRESS", "API_SET_PNO_SCAN_ENABLED", "API_P2P_DISCOVER_PEERS_WITH_CONFIG_PARAMS", "API_MAX", "ACTION_PASSPOINT_ICON", "EXTRA_BSSID_LONG", "EXTRA_ICON", "EXTRA_FILENAME", "ACTION_PASSPOINT_OSU_PROVIDERS_LIST", "EXTRA_ANQP_ELEMENT_DATA", "ACTION_PASSPOINT_DEAUTH_IMMINENT", "EXTRA_ESS", "EXTRA_DELAY", "ACTION_PASSPOINT_SUBSCRIPTION_REMEDIATION", "EXTRA_SUBSCRIPTION_REMEDIATION_METHOD", "ACTION_PASSPOINT_LAUNCH_OSU_VIEW", "EXTRA_OSU_NETWORK", "EXTRA_URL", "WIFI_STATE_CHANGED_ACTION", "EXTRA_WIFI_STATE", "EXTRA_PREVIOUS_WIFI_STATE", "WIFI_STATE_DISABLING", "WIFI_STATE_DISABLED", "WIFI_STATE_ENABLING", "WIFI_STATE_ENABLED", "WIFI_STATE_UNKNOWN", "WIFI_AP_STATE_CHANGED_ACTION", "EXTRA_WIFI_AP_STATE", "EXTRA_WIFI_AP_FAILURE_REASON", "EXTRA_PREVIOUS_WIFI_AP_STATE", "EXTRA_WIFI_AP_INTERFACE_NAME", "EXTRA_WIFI_AP_MODE", "WIFI_AP_STATE_DISABLING", "WIFI_AP_STATE_DISABLED", "WIFI_AP_STATE_ENABLING", "WIFI_AP_STATE_ENABLED", "WIFI_AP_STATE_FAILED", "SAP_START_FAILURE_GENERAL", "SAP_START_FAILURE_NO_CHANNEL", "SAP_START_FAILURE_UNSUPPORTED_CONFIGURATION", "SAP_START_FAILURE_USER_REJECTED", "SAP_CLIENT_BLOCK_REASON_CODE_BLOCKED_BY_USER", "SAP_CLIENT_BLOCK_REASON_CODE_NO_MORE_STAS", "SAP_CLIENT_DISCONNECT_REASON_CODE_UNSPECIFIED", "IFACE_IP_MODE_UNSPECIFIED", "IFACE_IP_MODE_CONFIGURATION_ERROR", "IFACE_IP_MODE_TETHERED", "IFACE_IP_MODE_LOCAL_ONLY", "ACTION_NETWORK_SETTINGS_RESET", "ACTION_REFRESH_USER_PROVISIONING", "SUPPLICANT_CONNECTION_CHANGE_ACTION", "EXTRA_SUPPLICANT_CONNECTED", "NETWORK_STATE_CHANGED_ACTION", "EXTRA_NETWORK_INFO", "EXTRA_BSSID", "EXTRA_WIFI_INFO", "SUPPLICANT_STATE_CHANGED_ACTION", "EXTRA_NEW_STATE", "EXTRA_SUPPLICANT_ERROR", "EXTRA_SUPPLICANT_ERROR_REASON", "CONFIGURED_NETWORKS_CHANGED_ACTION", "EXTRA_WIFI_CONFIGURATION", "EXTRA_MULTIPLE_NETWORKS_CHANGED", "EXTRA_CHANGE_REASON", "CHANGE_REASON_ADDED", "CHANGE_REASON_REMOVED", "CHANGE_REASON_CONFIG_CHANGE", "SCAN_RESULTS_AVAILABLE_ACTION", "EXTRA_RESULTS_UPDATED", "BATCHED_SCAN_RESULTS_AVAILABLE_ACTION", "RSSI_CHANGED_ACTION", "EXTRA_NEW_RSSI", "LINK_CONFIGURATION_CHANGED_ACTION", "ACTION_LINK_CONFIGURATION_CHANGED", "EXTRA_LINK_PROPERTIES", "EXTRA_NETWORK_CAPABILITIES", "NETWORK_IDS_CHANGED_ACTION", "ACTION_REQUEST_SCAN_ALWAYS_AVAILABLE", "ACTION_PICK_WIFI_NETWORK", "ACTION_REQUEST_ENABLE", "ACTION_REQUEST_DISABLE", "ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION", "EXTRA_NETWORK_SUGGESTION", "WIFI_MODE_NO_LOCKS_HELD", "WIFI_MODE_FULL", "WIFI_MODE_SCAN_ONLY", "WIFI_MODE_FULL_HIGH_PERF", "WIFI_MODE_FULL_LOW_LATENCY", "MIN_RSSI", "MAX_RSSI", "RSSI_LEVELS", "WIFI_FREQUENCY_BAND_AUTO", "WIFI_FREQUENCY_BAND_5GHZ", "WIFI_FREQUENCY_BAND_2GHZ", "DEFAULT_POOR_NETWORK_AVOIDANCE_ENABLED", "MAX_ACTIVE_LOCKS", "UNKNOWN_SSID", "ALL_ZEROS_MAC_ADDRESS", "WIFI_MULTI_INTERNET_MODE_DISABLED", "WIFI_MULTI_INTERNET_MODE_DBS_AP", "WIFI_MULTI_INTERNET_MODE_MULTI_AP", "CHANNEL_DATA_KEY_FREQUENCY_MHZ", "CHANNEL_DATA_KEY_NUM_AP", "QOS_REQUEST_STATUS_TRACKING", "QOS_REQUEST_STATUS_ALREADY_ACTIVE", "QOS_REQUEST_STATUS_INSUFFICIENT_RESOURCES", "QOS_REQUEST_STATUS_INVALID_PARAMETERS", "QOS_REQUEST_STATUS_FAILURE_UNKNOWN", "MAX_POLICIES_PER_QOS_REQUEST", "mActiveLockCount", "mContext", "mService", "mTargetSdkVersion", "mLooper", "mVerboseLoggingEnabled", "mLock", "mLOHSCallbackProxy", "mLOHSObserverProxy", "sOnWifiUsabilityStatsListenerMap", "sSuggestionConnectionStatusListenerMap", "sSuggestionUserApprovalStatusListenerMap", "sWifiVerboseLoggingStatusChangedListenerMap", "sNetworkRequestMatchCallbackMap", "sTrafficStateCallbackMap", "sSoftApCallbackMap", "sActiveCountryCodeChangedCallbackMap", "sLocalOnlyHotspotSoftApCallbackMap", "sLocalOnlyConnectionStatusListenerMap", "sOnWifiNetworkStateChangedListenerMap", "sWifiLowLatencyLockListenerMap", "MLO_MODE_DEFAULT", "MLO_MODE_LOW_LATENCY", "MLO_MODE_HIGH_THROUGHPUT", "MLO_MODE_LOW_POWER", "ROAMING_MODE_NONE", "ROAMING_MODE_NORMAL", "ROAMING_MODE_AGGRESSIVE", "WIFI_FEATURE_INFRA", "WIFI_FEATURE_PASSPOINT", "WIFI_FEATURE_P2P", "WIFI_FEATURE_MOBILE_HOTSPOT", "WIFI_FEATURE_SCANNER", "WIFI_FEATURE_AWARE", "WIFI_FEATURE_D2D_RTT", "WIFI_FEATURE_D2AP_RTT", "WIFI_FEATURE_PNO", "WIFI_FEATURE_TDLS", "WIFI_FEATURE_TDLS_OFFCHANNEL", "WIFI_FEATURE_AP_STA", "WIFI_FEATURE_LINK_LAYER_STATS", "WIFI_FEATURE_LOGGER", "WIFI_FEATURE_RSSI_MONITOR", "WIFI_FEATURE_MKEEP_ALIVE", "WIFI_FEATURE_CONFIG_NDO", "WIFI_FEATURE_CONTROL_ROAMING", "WIFI_FEATURE_IE_WHITELIST", "WIFI_FEATURE_SCAN_RAND", "WIFI_FEATURE_TX_POWER_LIMIT", "WIFI_FEATURE_WPA3_SAE", "WIFI_FEATURE_WPA3_SUITE_B", "WIFI_FEATURE_OWE", "WIFI_FEATURE_LOW_LATENCY", "WIFI_FEATURE_DPP", "WIFI_FEATURE_P2P_RAND_MAC", "WIFI_FEATURE_CONNECTED_RAND_MAC", "WIFI_FEATURE_AP_RAND_MAC", "WIFI_FEATURE_MBO", "WIFI_FEATURE_OCE", "WIFI_FEATURE_WAPI", "WIFI_FEATURE_FILS_SHA256", "WIFI_FEATURE_FILS_SHA384", "WIFI_FEATURE_SAE_PK", "WIFI_FEATURE_STA_BRIDGED_AP", "WIFI_FEATURE_BRIDGED_AP", "WIFI_FEATURE_INFRA_60G", "WIFI_FEATURE_ADDITIONAL_STA_LOCAL_ONLY", "WIFI_FEATURE_ADDITIONAL_STA_MBB", "WIFI_FEATURE_ADDITIONAL_STA_RESTRICTED", "WIFI_FEATURE_DPP_ENROLLEE_RESPONDER", "WIFI_FEATURE_PASSPOINT_TERMS_AND_CONDITIONS", "WIFI_FEATURE_SAE_H2E", "WIFI_FEATURE_WFD_R2", "WIFI_FEATURE_DECORATED_IDENTITY", "WIFI_FEATURE_TRUST_ON_FIRST_USE", "WIFI_FEATURE_ADDITIONAL_STA_MULTI_INTERNET", "WIFI_FEATURE_DPP_AKM", "WIFI_FEATURE_SET_TLS_MINIMUM_VERSION", "WIFI_FEATURE_TLS_V1_3", "WIFI_FEATURE_DUAL_BAND_SIMULTANEOUS", "WIFI_FEATURE_T2LM_NEGOTIATION", "WIFI_FEATURE_WEP", "WIFI_FEATURE_WPA_PERSONAL", "WIFI_FEATURE_AGGRESSIVE_ROAMING_MODE_SUPPORT", "WIFI_FEATURE_D2D_WHEN_INFRA_STA_DISABLED", "COEX_RESTRICTION_WIFI_DIRECT", "COEX_RESTRICTION_SOFTAP", "COEX_RESTRICTION_WIFI_AWARE", "WPS_OVERLAP_ERROR", "WPS_WEP_PROHIBITED", "WPS_TKIP_ONLY_PROHIBITED", "WPS_AUTH_FAILURE", "WPS_TIMED_OUT", "DEVICE_MOBILITY_STATE_UNKNOWN", "DEVICE_MOBILITY_STATE_HIGH_MVMT", "DEVICE_MOBILITY_STATE_LOW_MVMT", "DEVICE_MOBILITY_STATE_STATIONARY", "EASY_CONNECT_NETWORK_ROLE_STA", "EASY_CONNECT_NETWORK_ROLE_AP", "EASY_CONNECT_DEVICE_INFO_MAXIMUM_LENGTH", "EASY_CONNECT_CRYPTOGRAPHY_CURVE_PRIME256V1", "EASY_CONNECT_CRYPTOGRAPHY_CURVE_SECP384R1", "EASY_CONNECT_CRYPTOGRAPHY_CURVE_SECP521R1", "EASY_CONNECT_CRYPTOGRAPHY_CURVE_BRAINPOOLP256R1", "EASY_CONNECT_CRYPTOGRAPHY_CURVE_BRAINPOOLP384R1", "EASY_CONNECT_CRYPTOGRAPHY_CURVE_BRAINPOOLP512R1", "VERBOSE_LOGGING_LEVEL_DISABLED", "VERBOSE_LOGGING_LEVEL_ENABLED", "VERBOSE_LOGGING_LEVEL_ENABLED_SHOW_KEY", "VERBOSE_LOGGING_LEVEL_WIFI_AWARE_ENABLED_ONLY", "ACTION_LAUNCH_DIALOG", "ACTION_DISMISS_DIALOG", "DIALOG_TYPE_UNKNOWN", "DIALOG_TYPE_SIMPLE", "DIALOG_TYPE_P2P_INVITATION_SENT", "DIALOG_TYPE_P2P_INVITATION_RECEIVED", "DIALOG_REPLY_POSITIVE", "DIALOG_REPLY_NEGATIVE", "DIALOG_REPLY_NEUTRAL", "DIALOG_REPLY_CANCELLED", "INVALID_DIALOG_ID", "EXTRA_DIALOG_TYPE", "EXTRA_DIALOG_ID", "EXTRA_DIALOG_TITLE", "EXTRA_DIALOG_MESSAGE", "EXTRA_DIALOG_MESSAGE_URL", "EXTRA_DIALOG_MESSAGE_URL_START", "EXTRA_DIALOG_MESSAGE_URL_END", "EXTRA_DIALOG_POSITIVE_BUTTON_TEXT", "EXTRA_DIALOG_NEGATIVE_BUTTON_TEXT", "EXTRA_DIALOG_NEUTRAL_BUTTON_TEXT", "EXTRA_DIALOG_TIMEOUT_MS", "EXTRA_P2P_DEVICE_NAME", "EXTRA_P2P_PIN_REQUESTED", "EXTRA_P2P_DISPLAY_PIN", "EXTRA_CLOSE_SYSTEM_DIALOGS_EXCEPT_WIFI", "WIFI_INTERFACE_TYPE_STA", "WIFI_INTERFACE_TYPE_AP", "WIFI_INTERFACE_TYPE_AWARE", "WIFI_INTERFACE_TYPE_DIRECT", "FLAG_SEND_DHCP_HOSTNAME_RESTRICTION_OPEN", "FLAG_SEND_DHCP_HOSTNAME_RESTRICTION_SECURE", "TWT_CAPABILITIES_KEY_BOOLEAN_TWT_REQUESTER", "TWT_CAPABILITIES_KEY_INT_MIN_WAKE_DURATION_MICROS", "TWT_CAPABILITIES_KEY_INT_MAX_WAKE_DURATION_MICROS", "TWT_CAPABILITIES_KEY_LONG_MIN_WAKE_INTERVAL_MICROS", "TWT_CAPABILITIES_KEY_LONG_MAX_WAKE_INTERVAL_MICROS" ]
}