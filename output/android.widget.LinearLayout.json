{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/widget/LinearLayout.java",
  "packageName" : "android.widget",
  "className" : "LinearLayout",
  "comment" : "\n * A layout that arranges other views either horizontally in a single column\n * or vertically in a single row.\n *\n * <p>The following snippet shows how to include a linear layout in your layout XML file:</p>\n *\n * <pre>&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n *   android:layout_width=\"match_parent\"\n *   android:layout_height=\"match_parent\"\n *   android:paddingLeft=\"16dp\"\n *   android:paddingRight=\"16dp\"\n *   android:orientation=\"horizontal\"\n *   android:gravity=\"center\"&gt;\n *\n *   &lt;!-- Include other widget or layout tags here. These are considered\n *           \"child views\" or \"children\" of the linear layout --&gt;\n *\n * &lt;/LinearLayout&gt;</pre>\n *\n * <p>Set {@link android.R.styleable#LinearLayout_orientation android:orientation} to specify\n * whether child views are displayed in a row or column.</p>\n *\n * <p>To control how linear layout aligns all the views it contains, set a value for\n * {@link android.R.styleable#LinearLayout_gravity android:gravity}.  For example, the\n * snippet above sets android:gravity to \"center\".  The value you set affects\n * both horizontal and vertical alignment of all child views within the single row or column.</p>\n *\n * <p>You can set\n * {@link android.R.styleable#LinearLayout_Layout_layout_weight android:layout_weight}\n * on individual child views to specify how linear layout divides remaining space amongst\n * the views it contains. See the\n * <a href=\"https://developer.android.com/guide/topics/ui/layout/linear.html\">Linear Layout</a>\n * guide for an example.</p>\n *\n * <p>See\n * {@link android.widget.LinearLayout.LayoutParams LinearLayout.LayoutParams}\n * to learn about other attributes you can set on a child view to affect its\n * position and size in the containing linear layout.</p>\n *\n * @attr ref android.R.styleable#LinearLayout_baselineAligned\n * @attr ref android.R.styleable#LinearLayout_baselineAlignedChildIndex\n * @attr ref android.R.styleable#LinearLayout_gravity\n * @attr ref android.R.styleable#LinearLayout_measureWithLargestChild\n * @attr ref android.R.styleable#LinearLayout_orientation\n * @attr ref android.R.styleable#LinearLayout_weightSum\n ",
  "links" : [ "android.widget.LinearLayout.LayoutParams", "android.R.styleable#LinearLayout_orientation", "android.R.styleable#LinearLayout_gravity", "android.R.styleable#LinearLayout_Layout_layout_weight" ],
  "variables" : [ {
    "name" : "HORIZONTAL",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "VERTICAL",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "SHOW_DIVIDER_NONE",
    "type" : "int",
    "comment" : "\n     * Don't show any dividers.\n     ",
    "links" : [ ]
  }, {
    "name" : "SHOW_DIVIDER_BEGINNING",
    "type" : "int",
    "comment" : "\n     * Show a divider at the beginning of the group.\n     ",
    "links" : [ ]
  }, {
    "name" : "SHOW_DIVIDER_MIDDLE",
    "type" : "int",
    "comment" : "\n     * Show dividers between each item in the group.\n     ",
    "links" : [ ]
  }, {
    "name" : "SHOW_DIVIDER_END",
    "type" : "int",
    "comment" : "\n     * Show a divider at the end of the group.\n     ",
    "links" : [ ]
  }, {
    "name" : "mAllowInconsistentMeasurement",
    "type" : "boolean",
    "comment" : "\n     * Compatibility check. Old versions of the platform would give different\n     * results from measurement passes using EXACTLY and non-EXACTLY modes,\n     * even when the resulting size was the same.\n     ",
    "links" : [ ]
  }, {
    "name" : "mBaselineAligned",
    "type" : "boolean",
    "comment" : "\n     * Whether the children of this layout are baseline aligned.  Only applicable\n     * if {@link #mOrientation} is horizontal.\n     ",
    "links" : [ "#mOrientation" ]
  }, {
    "name" : "mBaselineAlignedChildIndex",
    "type" : "int",
    "comment" : "\n     * If this layout is part of another layout that is baseline aligned,\n     * use the child at this index as the baseline.\n     *\n     * Note: this is orthogonal to {@link #mBaselineAligned}, which is concerned\n     * with whether the children of this layout are baseline aligned.\n     ",
    "links" : [ "#mBaselineAligned" ]
  }, {
    "name" : "mBaselineChildTop",
    "type" : "int",
    "comment" : "\n     * The additional offset to the child's baseline.\n     * We'll calculate the baseline of this layout as we measure vertically; for\n     * horizontal linear layouts, the offset of 0 is appropriate.\n     ",
    "links" : [ ]
  }, {
    "name" : "mOrientation",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mGravity",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTotalLength",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mWeightSum",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mUseLargestChild",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMaxAscent",
    "type" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMaxDescent",
    "type" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "VERTICAL_GRAVITY_COUNT",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "INDEX_CENTER_VERTICAL",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "INDEX_TOP",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "INDEX_BOTTOM",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "INDEX_FILL",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDivider",
    "type" : "Drawable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDividerWidth",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDividerHeight",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mShowDividers",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDividerPadding",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLayoutDirection",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sCompatibilityDone",
    "type" : "boolean",
    "comment" : "\n     * Signals that compatibility booleans have been initialized according to\n     * target SDK versions.\n     ",
    "links" : [ ]
  }, {
    "name" : "sRemeasureWeightedChildren",
    "type" : "boolean",
    "comment" : "\n     * Behavior change in P; always remeasure weighted children, regardless of excess space.\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private boolean isShowingDividers()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns <code>true</code> if this layout is currently configured to show at least one\n     * divider.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setShowDividers(@DividerMode int showDividers)",
    "returnType" : "void",
    "comment" : "\n     * Set how dividers should be shown between items in this layout\n     *\n     * @param showDividers One or more of {@link #SHOW_DIVIDER_BEGINNING},\n     *                     {@link #SHOW_DIVIDER_MIDDLE}, or {@link #SHOW_DIVIDER_END}\n     *                     to show dividers, or {@link #SHOW_DIVIDER_NONE} to show no dividers.\n     ",
    "links" : [ "#SHOW_DIVIDER_MIDDLE", "#SHOW_DIVIDER_BEGINNING", "#SHOW_DIVIDER_NONE", "#SHOW_DIVIDER_END" ]
  }, {
    "name" : "public boolean shouldDelayChildPressedState()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getShowDividers()",
    "returnType" : "int",
    "comment" : "\n     * @return A flag set indicating how dividers should be shown around items.\n     * @see #setShowDividers(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public Drawable getDividerDrawable()",
    "returnType" : "Drawable",
    "comment" : "\n     * @return the divider Drawable that will divide each item.\n     *\n     * @see #setDividerDrawable(Drawable)\n     *\n     * @attr ref android.R.styleable#LinearLayout_divider\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDividerDrawable(Drawable divider)",
    "returnType" : "void",
    "comment" : "\n     * Set a drawable to be used as a divider between items.\n     *\n     * @param divider Drawable that will divide each item.\n     *\n     * @see #setShowDividers(int)\n     *\n     * @attr ref android.R.styleable#LinearLayout_divider\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDividerPadding(int padding)",
    "returnType" : "void",
    "comment" : "\n     * Set padding displayed on both ends of dividers. For a vertical layout, the padding is applied\n     * to left and right end of dividers. For a horizontal layout, the padding is applied to top and\n     * bottom end of dividers.\n     *\n     * @param padding Padding value in pixels that will be applied to each end\n     *\n     * @see #setShowDividers(int)\n     * @see #setDividerDrawable(Drawable)\n     * @see #getDividerPadding()\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getDividerPadding()",
    "returnType" : "int",
    "comment" : "\n     * Get the padding size used to inset dividers in pixels\n     *\n     * @see #setShowDividers(int)\n     * @see #setDividerDrawable(Drawable)\n     * @see #setDividerPadding(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getDividerWidth()",
    "returnType" : "int",
    "comment" : "\n     * Get the width of the current divider drawable.\n     *\n     * @hide Used internally by framework.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void onDraw(Canvas canvas)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void drawDividersVertical(Canvas canvas)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private View getLastNonGoneChild()",
    "returnType" : "View",
    "comment" : "\n     * Finds the last child that is not gone. The last child will be used as the reference for\n     * where the end divider should be drawn.\n     ",
    "links" : [ ]
  }, {
    "name" : " void drawDividersHorizontal(Canvas canvas)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void drawHorizontalDivider(Canvas canvas, int top)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void drawVerticalDivider(Canvas canvas, int left)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isBaselineAligned()",
    "returnType" : "boolean",
    "comment" : "\n     * <p>Indicates whether widgets contained within this layout are aligned\n     * on their baseline or not.</p>\n     *\n     * @return true when widgets are baseline-aligned, false otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setBaselineAligned(boolean baselineAligned)",
    "returnType" : "void",
    "comment" : "\n     * <p>Defines whether widgets contained in this layout are\n     * baseline-aligned or not.</p>\n     *\n     * @param baselineAligned true to align widgets on their baseline,\n     *         false otherwise\n     *\n     * @attr ref android.R.styleable#LinearLayout_baselineAligned\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isMeasureWithLargestChildEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * When true, all children with a weight will be considered having\n     * the minimum size of the largest child. If false, all children are\n     * measured normally.\n     *\n     * @return True to measure children with a weight using the minimum\n     *         size of the largest child, false otherwise.\n     *\n     * @attr ref android.R.styleable#LinearLayout_measureWithLargestChild\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setMeasureWithLargestChildEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * When set to true, all children with a weight will be considered having\n     * the minimum size of the largest child. If false, all children are\n     * measured normally.\n     *\n     * Disabled by default.\n     *\n     * @param enabled True to measure children with a weight using the\n     *        minimum size of the largest child, false otherwise.\n     *\n     * @attr ref android.R.styleable#LinearLayout_measureWithLargestChild\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getBaseline()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getBaselineAlignedChildIndex()",
    "returnType" : "int",
    "comment" : "\n     * @return The index of the child that will be used if this layout is\n     *   part of a larger layout that is baseline aligned, or -1 if none has\n     *   been set.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setBaselineAlignedChildIndex(int i)",
    "returnType" : "void",
    "comment" : "\n     * @param i The index of the child that will be used if this layout is\n     *          part of a larger layout that is baseline aligned.\n     *\n     * @attr ref android.R.styleable#LinearLayout_baselineAlignedChildIndex\n     ",
    "links" : [ ]
  }, {
    "name" : " View getVirtualChildAt(int index)",
    "returnType" : "View",
    "comment" : "\n     * <p>Returns the view at the specified index. This method can be overridden\n     * to take into account virtual children. Refer to\n     * {@link android.widget.TableLayout} and {@link android.widget.TableRow}\n     * for an example.</p>\n     *\n     * @param index the child's index\n     * @return the child at the specified index, may be {@code null}\n     ",
    "links" : [ "android.widget.TableLayout", "android.widget.TableRow" ]
  }, {
    "name" : " int getVirtualChildCount()",
    "returnType" : "int",
    "comment" : "\n     * <p>Returns the virtual number of children. This number might be different\n     * than the actual number of children if the layout can hold virtual\n     * children. Refer to\n     * {@link android.widget.TableLayout} and {@link android.widget.TableRow}\n     * for an example.</p>\n     *\n     * @return the virtual number of children\n     ",
    "links" : [ "android.widget.TableLayout", "android.widget.TableRow" ]
  }, {
    "name" : "public float getWeightSum()",
    "returnType" : "float",
    "comment" : "\n     * Returns the desired weights sum.\n     *\n     * @return A number greater than 0.0f if the weight sum is defined, or\n     *         a number lower than or equals to 0.0f if not weight sum is\n     *         to be used.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setWeightSum(float weightSum)",
    "returnType" : "void",
    "comment" : "\n     * Defines the desired weights sum. If unspecified the weights sum is computed\n     * at layout time by adding the layout_weight of each child.\n     *\n     * This can be used for instance to give a single child 50% of the total\n     * available space by giving it a layout_weight of 0.5 and setting the\n     * weightSum to 1.0.\n     *\n     * @param weightSum a number greater than 0.0f, or a number lower than or equals\n     *        to 0.0f if the weight sum should be computed from the children's\n     *        layout_weight\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected boolean hasDividerBeforeChildAt(int childIndex)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines where to position dividers between children.\n     *\n     * @param childIndex Index of child to check for preceding divider\n     * @return true if there should be a divider before the child at childIndex\n     * @hide Pending API consideration. Currently only used internally by the system.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean hasDividerAfterChildAt(int childIndex)",
    "returnType" : "boolean",
    "comment" : "\n     * Determines whether or not there's a divider after a specified child index.\n     *\n     * @param childIndex Index of child to check for following divider\n     * @return true if there should be a divider after the child at childIndex\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean allViewsAreGoneBefore(int childIndex)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether all (virtual) child views before the given index are gone.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean allViewsAreGoneAfter(int childIndex)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether all (virtual) child views after the given index are gone.\n     ",
    "links" : [ ]
  }, {
    "name" : " void measureVertical(int widthMeasureSpec, int heightMeasureSpec)",
    "returnType" : "void",
    "comment" : "\n     * Measures the children when the orientation of this LinearLayout is set\n     * to {@link #VERTICAL}.\n     *\n     * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.\n     * @param heightMeasureSpec Vertical space requirements as imposed by the parent.\n     *\n     * @see #getOrientation()\n     * @see #setOrientation(int)\n     * @see #onMeasure(int, int)\n     ",
    "links" : [ "#VERTICAL" ]
  }, {
    "name" : "private void forceUniformWidth(int count, int heightMeasureSpec)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void measureHorizontal(int widthMeasureSpec, int heightMeasureSpec)",
    "returnType" : "void",
    "comment" : "\n     * Measures the children when the orientation of this LinearLayout is set\n     * to {@link #HORIZONTAL}.\n     *\n     * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.\n     * @param heightMeasureSpec Vertical space requirements as imposed by the parent.\n     *\n     * @see #getOrientation()\n     * @see #setOrientation(int)\n     * @see #onMeasure(int, int)\n     ",
    "links" : [ "#HORIZONTAL" ]
  }, {
    "name" : "private void forceUniformHeight(int count, int widthMeasureSpec)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " int getChildrenSkipCount(View child, int index)",
    "returnType" : "int",
    "comment" : "\n     * <p>Returns the number of children to skip after measuring/laying out\n     * the specified child.</p>\n     *\n     * @param child the child after which we want to skip children\n     * @param index the index of the child after which we want to skip children\n     * @return the number of children to skip, 0 by default\n     ",
    "links" : [ ]
  }, {
    "name" : " int measureNullChild(int childIndex)",
    "returnType" : "int",
    "comment" : "\n     * <p>Returns the size (width or height) that should be occupied by a null\n     * child.</p>\n     *\n     * @param childIndex the index of the null child\n     * @return the width or height of the child depending on the orientation\n     ",
    "links" : [ ]
  }, {
    "name" : " void measureChildBeforeLayout(View child, int childIndex, int widthMeasureSpec, int totalWidth, int heightMeasureSpec, int totalHeight)",
    "returnType" : "void",
    "comment" : "\n     * <p>Measure the child according to the parent's measure specs. This\n     * method should be overridden by subclasses to force the sizing of\n     * children. This method is called by {@link #measureVertical(int, int)} and\n     * {@link #measureHorizontal(int, int)}.</p>\n     *\n     * @param child the child to measure\n     * @param childIndex the index of the child in this view\n     * @param widthMeasureSpec horizontal space requirements as imposed by the parent\n     * @param totalWidth extra space that has been used up by the parent horizontally\n     * @param heightMeasureSpec vertical space requirements as imposed by the parent\n     * @param totalHeight extra space that has been used up by the parent vertically\n     ",
    "links" : [ "#measureVertical(int", "#measureHorizontal(int" ]
  }, {
    "name" : " int getLocationOffset(View child)",
    "returnType" : "int",
    "comment" : "\n     * <p>Return the location offset of the specified child. This can be used\n     * by subclasses to change the location of a given widget.</p>\n     *\n     * @param child the child for which to obtain the location offset\n     * @return the location offset in pixels\n     ",
    "links" : [ ]
  }, {
    "name" : " int getNextLocationOffset(View child)",
    "returnType" : "int",
    "comment" : "\n     * <p>Return the size offset of the next sibling of the specified child.\n     * This can be used by subclasses to change the location of the widget\n     * following <code>child</code>.</p>\n     *\n     * @param child the child whose next sibling will be moved\n     * @return the location offset of the next child in pixels\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void onLayout(boolean changed, int l, int t, int r, int b)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void layoutVertical(int left, int top, int right, int bottom)",
    "returnType" : "void",
    "comment" : "\n     * Position the children during a layout pass if the orientation of this\n     * LinearLayout is set to {@link #VERTICAL}.\n     *\n     * @see #getOrientation()\n     * @see #setOrientation(int)\n     * @see #onLayout(boolean, int, int, int, int)\n     * @param left\n     * @param top\n     * @param right\n     * @param bottom\n     ",
    "links" : [ "#VERTICAL" ]
  }, {
    "name" : "public void onRtlPropertiesChanged(@ResolvedLayoutDir int layoutDirection)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void layoutHorizontal(int left, int top, int right, int bottom)",
    "returnType" : "void",
    "comment" : "\n     * Position the children during a layout pass if the orientation of this\n     * LinearLayout is set to {@link #HORIZONTAL}.\n     *\n     * @see #getOrientation()\n     * @see #setOrientation(int)\n     * @see #onLayout(boolean, int, int, int, int)\n     * @param left\n     * @param top\n     * @param right\n     * @param bottom\n     ",
    "links" : [ "#HORIZONTAL" ]
  }, {
    "name" : "private void setChildFrame(View child, int left, int top, int width, int height)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setOrientation(@OrientationMode int orientation)",
    "returnType" : "void",
    "comment" : "\n     * Should the layout be a column or a row.\n     * @param orientation Pass {@link #HORIZONTAL} or {@link #VERTICAL}. Default\n     * value is {@link #HORIZONTAL}.\n     *\n     * @attr ref android.R.styleable#LinearLayout_orientation\n     ",
    "links" : [ "#HORIZONTAL", "#VERTICAL" ]
  }, {
    "name" : "public int getOrientation()",
    "returnType" : "int",
    "comment" : "\n     * Returns the current orientation.\n     *\n     * @return either {@link #HORIZONTAL} or {@link #VERTICAL}\n     ",
    "links" : [ "#HORIZONTAL", "#VERTICAL" ]
  }, {
    "name" : "public void setGravity(int gravity)",
    "returnType" : "void",
    "comment" : "\n     * Describes how the child views are positioned. Defaults to GRAVITY_TOP. If\n     * this layout has a VERTICAL orientation, this controls where all the child\n     * views are placed if there is extra vertical space. If this layout has a\n     * HORIZONTAL orientation, this controls the alignment of the children.\n     *\n     * @param gravity See {@link android.view.Gravity}\n     *\n     * @attr ref android.R.styleable#LinearLayout_gravity\n     ",
    "links" : [ "android.view.Gravity" ]
  }, {
    "name" : "public int getGravity()",
    "returnType" : "int",
    "comment" : "\n     * Returns the current gravity. See {@link android.view.Gravity}\n     *\n     * @return the current gravity.\n     * @see #setGravity\n     ",
    "links" : [ "android.view.Gravity" ]
  }, {
    "name" : "public void setHorizontalGravity(int horizontalGravity)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setVerticalGravity(int verticalGravity)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public LayoutParams generateLayoutParams(AttributeSet attrs)",
    "returnType" : "LayoutParams",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected LayoutParams generateDefaultLayoutParams()",
    "returnType" : "LayoutParams",
    "comment" : "\n     * Returns a set of layout parameters with a width of\n     * {@link android.view.ViewGroup.LayoutParams#MATCH_PARENT}\n     * and a height of {@link android.view.ViewGroup.LayoutParams#WRAP_CONTENT}\n     * when the layout's orientation is {@link #VERTICAL}. When the orientation is\n     * {@link #HORIZONTAL}, the width is set to {@link LayoutParams#WRAP_CONTENT}\n     * and the height to {@link LayoutParams#WRAP_CONTENT}.\n     ",
    "links" : [ "android.view.ViewGroup.LayoutParams#MATCH_PARENT", "#WRAP_CONTENT", "#VERTICAL", "#HORIZONTAL", "android.view.ViewGroup.LayoutParams#WRAP_CONTENT" ]
  }, {
    "name" : "protected LayoutParams generateLayoutParams(ViewGroup.LayoutParams lp)",
    "returnType" : "LayoutParams",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected boolean checkLayoutParams(ViewGroup.LayoutParams p)",
    "returnType" : "boolean",
    "comment" : " Override to allow type-checking of LayoutParams.",
    "links" : [ ]
  }, {
    "name" : "public CharSequence getAccessibilityClassName()",
    "returnType" : "CharSequence",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void encodeProperties(@NonNull ViewHierarchyEncoder encoder)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  } ],
  "methodNames" : [ "private boolean isShowingDividers()", "public void setShowDividers(@DividerMode int showDividers)", "public boolean shouldDelayChildPressedState()", "public int getShowDividers()", "public Drawable getDividerDrawable()", "public void setDividerDrawable(Drawable divider)", "public void setDividerPadding(int padding)", "public int getDividerPadding()", "public int getDividerWidth()", "protected void onDraw(Canvas canvas)", " void drawDividersVertical(Canvas canvas)", "private View getLastNonGoneChild()", " void drawDividersHorizontal(Canvas canvas)", " void drawHorizontalDivider(Canvas canvas, int top)", " void drawVerticalDivider(Canvas canvas, int left)", "public boolean isBaselineAligned()", "public void setBaselineAligned(boolean baselineAligned)", "public boolean isMeasureWithLargestChildEnabled()", "public void setMeasureWithLargestChildEnabled(boolean enabled)", "public int getBaseline()", "public int getBaselineAlignedChildIndex()", "public void setBaselineAlignedChildIndex(int i)", " View getVirtualChildAt(int index)", " int getVirtualChildCount()", "public float getWeightSum()", "public void setWeightSum(float weightSum)", "protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)", "protected boolean hasDividerBeforeChildAt(int childIndex)", "private boolean hasDividerAfterChildAt(int childIndex)", "private boolean allViewsAreGoneBefore(int childIndex)", "private boolean allViewsAreGoneAfter(int childIndex)", " void measureVertical(int widthMeasureSpec, int heightMeasureSpec)", "private void forceUniformWidth(int count, int heightMeasureSpec)", " void measureHorizontal(int widthMeasureSpec, int heightMeasureSpec)", "private void forceUniformHeight(int count, int widthMeasureSpec)", " int getChildrenSkipCount(View child, int index)", " int measureNullChild(int childIndex)", " void measureChildBeforeLayout(View child, int childIndex, int widthMeasureSpec, int totalWidth, int heightMeasureSpec, int totalHeight)", " int getLocationOffset(View child)", " int getNextLocationOffset(View child)", "protected void onLayout(boolean changed, int l, int t, int r, int b)", " void layoutVertical(int left, int top, int right, int bottom)", "public void onRtlPropertiesChanged(@ResolvedLayoutDir int layoutDirection)", " void layoutHorizontal(int left, int top, int right, int bottom)", "private void setChildFrame(View child, int left, int top, int width, int height)", "public void setOrientation(@OrientationMode int orientation)", "public int getOrientation()", "public void setGravity(int gravity)", "public int getGravity()", "public void setHorizontalGravity(int horizontalGravity)", "public void setVerticalGravity(int verticalGravity)", "public LayoutParams generateLayoutParams(AttributeSet attrs)", "protected LayoutParams generateDefaultLayoutParams()", "protected LayoutParams generateLayoutParams(ViewGroup.LayoutParams lp)", "protected boolean checkLayoutParams(ViewGroup.LayoutParams p)", "public CharSequence getAccessibilityClassName()", "protected void encodeProperties(@NonNull ViewHierarchyEncoder encoder)" ],
  "variableNames" : [ "HORIZONTAL", "VERTICAL", "SHOW_DIVIDER_NONE", "SHOW_DIVIDER_BEGINNING", "SHOW_DIVIDER_MIDDLE", "SHOW_DIVIDER_END", "mAllowInconsistentMeasurement", "mBaselineAligned", "mBaselineAlignedChildIndex", "mBaselineChildTop", "mOrientation", "mGravity", "mTotalLength", "mWeightSum", "mUseLargestChild", "mMaxAscent", "mMaxDescent", "VERTICAL_GRAVITY_COUNT", "INDEX_CENTER_VERTICAL", "INDEX_TOP", "INDEX_BOTTOM", "INDEX_FILL", "mDivider", "mDividerWidth", "mDividerHeight", "mShowDividers", "mDividerPadding", "mLayoutDirection", "sCompatibilityDone", "sRemeasureWeightedChildren" ]
}