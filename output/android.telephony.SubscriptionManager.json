{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/telephony/SubscriptionManager.java",
  "packageName" : "android.telephony",
  "className" : "SubscriptionManager",
  "comment" : "\n * Subscription manager provides the mobile subscription information.\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "LOG_TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DBG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "VDBG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "INVALID_SUBSCRIPTION_ID",
    "type" : "int",
    "comment" : " An invalid subscription identifier ",
    "links" : [ ]
  }, {
    "name" : "PLACEHOLDER_SUBSCRIPTION_ID_BASE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "INVALID_PHONE_INDEX",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "INVALID_SIM_SLOT_INDEX",
    "type" : "int",
    "comment" : " Indicates invalid sim slot. This can be returned by {@link #getSlotIndex(int)}. ",
    "links" : [ "#getSlotIndex(int)" ]
  }, {
    "name" : "DEFAULT_SUBSCRIPTION_ID",
    "type" : "int",
    "comment" : " Indicates the default subscription ID in Telephony. ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_PHONE_INDEX",
    "type" : "int",
    "comment" : "\n     * Indicates the default phone id.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_SIM_SLOT_INDEX",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MIN_SUBSCRIPTION_ID_VALUE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MAX_SUBSCRIPTION_ID_VALUE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CONTENT_URI",
    "type" : "Uri",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CACHE_KEY_SUBSCRIPTION_MANAGER_SERVICE_PROPERTY",
    "type" : "String",
    "comment" : " The IPC cache key shared by all subscription manager service cacheable properties. ",
    "links" : [ ]
  }, {
    "name" : "GET_SIM_SPECIFIC_SETTINGS_METHOD_NAME",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "RESTORE_SIM_SPECIFIC_SETTINGS_METHOD_NAME",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "RESTORE_SIM_SPECIFIC_SETTINGS_DATABASE_UPDATED",
    "type" : "String",
    "comment" : "\n     * The key of the boolean flag indicating whether restoring subscriptions actually changes\n     * the subscription database or not.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "KEY_SIM_SPECIFIC_SETTINGS_DATA",
    "type" : "String",
    "comment" : "\n     * Key to the backup & restore data byte array in the Bundle that is returned by {@link\n     * #getAllSimSpecificSettingsForBackup()} or to be pass in to {@link\n     * #restoreAllSimSpecificSettingsFromBackup(byte[])}.\n     *\n     * @hide\n     ",
    "links" : [ "#getAllSimSpecificSettingsForBackup()", "#restoreAllSimSpecificSettingsFromBackup(byte" ]
  }, {
    "name" : "MAX_CACHE_SIZE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sGetDefaultSubIdCacheAsUser",
    "type" : "IntegerPropertyInvalidatedCache<Integer>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sGetDefaultDataSubIdCache",
    "type" : "VoidPropertyInvalidatedCache<Integer>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sGetDefaultSmsSubIdCacheAsUser",
    "type" : "IntegerPropertyInvalidatedCache<Integer>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sGetActiveDataSubscriptionIdCache",
    "type" : "VoidPropertyInvalidatedCache<Integer>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sGetSlotIndexCache",
    "type" : "IntegerPropertyInvalidatedCache<Integer>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sGetSubIdCache",
    "type" : "IntegerPropertyInvalidatedCache<Integer>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sGetPhoneIdCache",
    "type" : "IntegerPropertyInvalidatedCache<Integer>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "WFC_ENABLED_CONTENT_URI",
    "type" : "Uri",
    "comment" : "\n     * A content {@link Uri} used to receive updates on wfc enabled user setting.\n     * <p>\n     * Use this {@link Uri} with a {@link ContentObserver} to be notified of changes to the\n     * subscription wfc enabled {@link ImsMmTelManager#isVoWiFiSettingEnabled()}\n     * while your app is running. You can also use a {@link android.app.job.JobService}\n     * to ensure your app\n     * is notified of changes to the {@link Uri} even when it is not running.\n     * Note, however, that using a {@link android.app.job.JobService} does not guarantee timely\n     * delivery of updates to the {@link Uri}.\n     * To be notified of changes to a specific subId, append subId to the URI\n     * {@link Uri#withAppendedPath(Uri, String)}.\n     * @hide\n     ",
    "links" : [ "android.app.job.JobService", "android.net.Uri#withAppendedPath(Uri", "android.net.Uri", "android.telephony.ims.ImsMmTelManager#isVoWiFiSettingEnabled()", "android.database.ContentObserver" ]
  }, {
    "name" : "ADVANCED_CALLING_ENABLED_CONTENT_URI",
    "type" : "Uri",
    "comment" : "\n     * A content {@link Uri} used to receive updates on advanced calling user setting\n     *\n     * <p>\n     * Use this {@link Uri} with a {@link ContentObserver} to be notified of changes to the\n     * subscription advanced calling enabled\n     * {@link ImsMmTelManager#isAdvancedCallingSettingEnabled()} while your app is running.\n     * You can also use a {@link android.app.job.JobService} to ensure your app is notified of\n     * changes to the {@link Uri} even when it is not running.\n     * Note, however, that using a {@link android.app.job.JobService} does not guarantee timely\n     * delivery of updates to the {@link Uri}.\n     * To be notified of changes to a specific subId, append subId to the URI\n     * {@link Uri#withAppendedPath(Uri, String)}.\n     *\n     * @see ImsMmTelManager#isAdvancedCallingSettingEnabled()\n     *\n     * @hide\n     ",
    "links" : [ "android.app.job.JobService", "android.net.Uri#withAppendedPath(Uri", "android.net.Uri", "android.telephony.ims.ImsMmTelManager#isAdvancedCallingSettingEnabled()", "android.database.ContentObserver" ]
  }, {
    "name" : "WFC_MODE_CONTENT_URI",
    "type" : "Uri",
    "comment" : "\n     * A content {@link Uri} used to receive updates on wfc mode setting.\n     * <p>\n     * Use this {@link Uri} with a {@link ContentObserver} to be notified of changes to the\n     * subscription wfc mode {@link ImsMmTelManager#getVoWiFiModeSetting()}\n     * while your app is running. You can also use a {@link android.app.job.JobService} to ensure\n     * your app is notified of changes to the {@link Uri} even when it is not running.\n     * Note, however, that using a {@link android.app.job.JobService} does not guarantee timely\n     * delivery of updates to the {@link Uri}.\n     * To be notified of changes to a specific subId, append subId to the URI\n     * {@link Uri#withAppendedPath(Uri, String)}.\n     * @hide\n     ",
    "links" : [ "android.app.job.JobService", "android.telephony.ims.ImsMmTelManager#getVoWiFiModeSetting()", "android.net.Uri#withAppendedPath(Uri", "android.net.Uri", "android.database.ContentObserver" ]
  }, {
    "name" : "WFC_ROAMING_MODE_CONTENT_URI",
    "type" : "Uri",
    "comment" : "\n     * A content {@link Uri} used to receive updates on wfc roaming mode setting.\n     * <p>\n     * Use this {@link Uri} with a {@link ContentObserver} to be notified of changes to the\n     * subscription wfc roaming mode {@link ImsMmTelManager#getVoWiFiRoamingModeSetting()}\n     * while your app is running. You can also use a {@link android.app.job.JobService}\n     * to ensure your app is notified of changes to the {@link Uri} even when it is not running.\n     * Note, however, that using a {@link android.app.job.JobService} does not guarantee timely\n     * delivery of updates to the {@link Uri}.\n     * To be notified of changes to a specific subId, append subId to the URI\n     * {@link Uri#withAppendedPath(Uri, String)}.\n     * @hide\n     ",
    "links" : [ "android.app.job.JobService", "android.net.Uri#withAppendedPath(Uri", "android.net.Uri", "android.telephony.ims.ImsMmTelManager#getVoWiFiRoamingModeSetting()", "android.database.ContentObserver" ]
  }, {
    "name" : "VT_ENABLED_CONTENT_URI",
    "type" : "Uri",
    "comment" : "\n     * A content {@link Uri} used to receive updates on vt(video telephony over IMS) enabled\n     * setting.\n     * <p>\n     * Use this {@link Uri} with a {@link ContentObserver} to be notified of changes to the\n     * subscription vt enabled {@link ImsMmTelManager#isVtSettingEnabled()}\n     * while your app is running. You can also use a {@link android.app.job.JobService} to ensure\n     * your app is notified of changes to the {@link Uri} even when it is not running.\n     * Note, however, that using a {@link android.app.job.JobService} does not guarantee timely\n     * delivery of updates to the {@link Uri}.\n     * To be notified of changes to a specific subId, append subId to the URI\n     * {@link Uri#withAppendedPath(Uri, String)}.\n     * @hide\n     ",
    "links" : [ "android.app.job.JobService", "android.net.Uri#withAppendedPath(Uri", "android.net.Uri", "android.telephony.ims.ImsMmTelManager#isVtSettingEnabled()", "android.database.ContentObserver" ]
  }, {
    "name" : "WFC_ROAMING_ENABLED_CONTENT_URI",
    "type" : "Uri",
    "comment" : "\n     * A content {@link Uri} used to receive updates on wfc roaming enabled setting.\n     * <p>\n     * Use this {@link Uri} with a {@link ContentObserver} to be notified of changes to the\n     * subscription wfc roaming enabled {@link ImsMmTelManager#isVoWiFiRoamingSettingEnabled()}\n     * while your app is running. You can also use a {@link android.app.job.JobService} to ensure\n     * your app is notified of changes to the {@link Uri} even when it is not running.\n     * Note, however, that using a {@link android.app.job.JobService} does not guarantee timely\n     * delivery of updates to the {@link Uri}.\n     * To be notified of changes to a specific subId, append subId to the URI\n     * {@link Uri#withAppendedPath(Uri, String)}.\n     * @hide\n     ",
    "links" : [ "android.app.job.JobService", "android.net.Uri#withAppendedPath(Uri", "android.telephony.ims.ImsMmTelManager#isVoWiFiRoamingSettingEnabled()", "android.net.Uri", "android.database.ContentObserver" ]
  }, {
    "name" : "SIM_INFO_BACKUP_AND_RESTORE_CONTENT_URI",
    "type" : "Uri",
    "comment" : "\n     * A content {@link uri} used to call the appropriate backup or restore method for sim-specific\n     * settings\n     * <p>\n     * See {@link #GET_SIM_SPECIFIC_SETTINGS_METHOD_NAME} and {@link\n     * #RESTORE_SIM_SPECIFIC_SETTINGS_METHOD_NAME} for information on what method to call.\n     * @hide\n     ",
    "links" : [ "#GET_SIM_SPECIFIC_SETTINGS_METHOD_NAME", "#RESTORE_SIM_SPECIFIC_SETTINGS_METHOD_NAME", "uri" ]
  }, {
    "name" : "SIM_INFO_SUW_RESTORE_CONTENT_URI",
    "type" : "Uri",
    "comment" : "\n     * A content {@link uri} used to notify contentobservers listening to siminfo restore during\n     * SuW.\n     * @hide\n     ",
    "links" : [ "uri" ]
  }, {
    "name" : "CROSS_SIM_ENABLED_CONTENT_URI",
    "type" : "Uri",
    "comment" : "\n     * A content {@link Uri} used to receive updates on cross sim enabled user setting.\n     * <p>\n     * Use this {@link Uri} with a {@link ContentObserver} to be notified of changes to the\n     * subscription cross sim calling enabled\n     * {@link ImsMmTelManager#isCrossSimCallingEnabled()}\n     * while your app is running. You can also use a {@link android.app.job.JobService}\n     * to ensure your app\n     * is notified of changes to the {@link Uri} even when it is not running.\n     * Note, however, that using a {@link android.app.job.JobService} does not guarantee timely\n     * delivery of updates to the {@link Uri}.\n     * To be notified of changes to a specific subId, append subId to the URI\n     * {@link Uri#withAppendedPath(Uri, String)}.\n     * @hide\n     ",
    "links" : [ "android.app.job.JobService", "android.net.Uri#withAppendedPath(Uri", "android.net.Uri", "android.telephony.ims.ImsMmTelManager#isCrossSimCallingEnabled()", "android.database.ContentObserver" ]
  }, {
    "name" : "UNIQUE_KEY_SUBSCRIPTION_ID",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ICC_ID",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SIM_SLOT_INDEX",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SIM_NOT_INSERTED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SLOT_INDEX_FOR_REMOTE_SIM_SUB",
    "type" : "int",
    "comment" : "\n     * The slot-index for Bluetooth Remote-SIM subscriptions\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SUBSCRIPTION_TYPE",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "TP_MESSAGE_REF",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for last used TP - message Reference\n     * <P>Type: INTEGER (int)</P> with -1 as default value\n     * TP - Message Reference valid range [0 - 255]\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ENABLED_MOBILE_DATA_POLICIES",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name enabled_mobile_data_policies.\n     * A list of mobile data policies, each of which represented by an integer and joint by \",\".\n     *\n     * Default value is empty string.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SUBSCRIPTION_TYPE_LOCAL_SIM",
    "type" : "int",
    "comment" : "\n     * This constant is to designate a subscription as a Local-SIM Subscription.\n     * <p> A Local-SIM can be a physical SIM inserted into a sim-slot in the device, or eSIM on the\n     * device.\n     * </p>\n     ",
    "links" : [ ]
  }, {
    "name" : "SUBSCRIPTION_TYPE_REMOTE_SIM",
    "type" : "int",
    "comment" : "\n     * This constant is to designate a subscription as a Remote-SIM Subscription.\n     * <p>\n     * A Remote-SIM subscription is for a SIM on a phone connected to this device via some\n     * connectivity mechanism, for example bluetooth. Similar to Local SIM, this subscription can\n     * be used for SMS, Voice and data by proxying data through the connected device.\n     * Certain data of the SIM, such as IMEI, are not accessible for Remote SIMs.\n     * </p>\n     *\n     * <p>\n     * A Remote-SIM is available only as long the phone stays connected to this device.\n     * When the phone disconnects, Remote-SIM subscription is removed from this device and is\n     * no longer known. All data associated with the subscription, such as stored SMS, call logs,\n     * contacts etc, are removed from this device.\n     * </p>\n     *\n     * <p>\n     * If the phone re-connects to this device, a new Remote-SIM subscription is created for\n     * the phone. The Subscription Id associated with the new subscription is different from\n     * the Subscription Id of the previous Remote-SIM subscription created (and removed) for the\n     * phone; i.e., new Remote-SIM subscription treats the reconnected phone as a Remote-SIM that\n     * was never seen before.\n     * </p>\n     ",
    "links" : [ ]
  }, {
    "name" : "DISPLAY_NAME",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CARRIER_NAME",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_NAME_RES",
    "type" : "int",
    "comment" : "\n     * Default name resource\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NAME_SOURCE",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for source of the user displayed name.\n     * <P>Type: INT (int)</P> with one of the NAME_SOURCE_XXXX values below\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NAME_SOURCE_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * The name_source is unknown. (for initialization)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NAME_SOURCE_CARRIER_ID",
    "type" : "int",
    "comment" : "\n     * The name_source is from the carrier id.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NAME_SOURCE_SIM_SPN",
    "type" : "int",
    "comment" : "\n     * The name_source is from SIM EF_SPN.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NAME_SOURCE_USER_INPUT",
    "type" : "int",
    "comment" : "\n     * The name_source is from user input\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NAME_SOURCE_CARRIER",
    "type" : "int",
    "comment" : "\n     * The name_source is carrier (carrier app, carrier config, etc.)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NAME_SOURCE_SIM_PNN",
    "type" : "int",
    "comment" : "\n     * The name_source is from SIM EF_PNN.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "D2D_SHARING_DISABLED",
    "type" : "int",
    "comment" : "\n     * Device status is not shared to a remote party.\n     ",
    "links" : [ ]
  }, {
    "name" : "D2D_SHARING_ALL_CONTACTS",
    "type" : "int",
    "comment" : "\n     * Device status is shared with all numbers in the user's contacts.\n     ",
    "links" : [ ]
  }, {
    "name" : "D2D_SHARING_SELECTED_CONTACTS",
    "type" : "int",
    "comment" : "\n     * Device status is shared with all selected contacts.\n     ",
    "links" : [ ]
  }, {
    "name" : "D2D_SHARING_ALL",
    "type" : "int",
    "comment" : "\n     * Device status is shared whenever possible.\n     ",
    "links" : [ ]
  }, {
    "name" : "D2D_STATUS_SHARING",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for device to device sharing status.\n     * <P>Type: INTEGER (int)</P>\n     ",
    "links" : [ ]
  }, {
    "name" : "D2D_STATUS_SHARING_SELECTED_CONTACTS",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for contacts information that allow device to device sharing.\n     * <P>Type: TEXT (String)</P>\n     ",
    "links" : [ ]
  }, {
    "name" : "HUE",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "NUMBER",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DATA_ROAMING",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DATA_ROAMING_ENABLE",
    "type" : "int",
    "comment" : " Indicates that data roaming is enabled for a subscription ",
    "links" : [ ]
  }, {
    "name" : "DATA_ROAMING_DISABLE",
    "type" : "int",
    "comment" : " Indicates that data roaming is disabled for a subscription ",
    "links" : [ ]
  }, {
    "name" : "CARRIER_ID",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for subscription carrier id.\n     * @see TelephonyManager#getSimCarrierId()\n     * <p>Type: INTEGER (int) </p>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EHPLMNS",
    "type" : "String",
    "comment" : "\n     * @hide A comma-separated list of EHPLMNs associated with the subscription\n     * <P>Type: TEXT (String)</P>\n     ",
    "links" : [ ]
  }, {
    "name" : "HPLMNS",
    "type" : "String",
    "comment" : "\n     * @hide A comma-separated list of HPLMNs associated with the subscription\n     * <P>Type: TEXT (String)</P>\n     ",
    "links" : [ ]
  }, {
    "name" : "MCC_STRING",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for the MCC associated with a SIM, stored as a string.\n     * <P>Type: TEXT (String)</P>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "MNC_STRING",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for the MNC associated with a SIM, stored as a string.\n     * <P>Type: TEXT (String)</P>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "MCC",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for the MCC associated with a SIM.\n     * <P>Type: INTEGER (int)</P>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "MNC",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for the MNC associated with a SIM.\n     * <P>Type: INTEGER (int)</P>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ISO_COUNTRY_CODE",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for the iso country code associated with a SIM.\n     * <P>Type: TEXT (String)</P>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "IS_EMBEDDED",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for whether a subscription is embedded (that is, present on an\n     * eSIM).\n     * <p>Type: INTEGER (int), 1 for embedded or 0 for non-embedded.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CARD_ID",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for SIM card identifier. For UICC card it is the ICCID of the\n     * current enabled profile on the card, while for eUICC card it is the EID of the card.\n     * <P>Type: TEXT (String)</P>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACCESS_RULES",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for the encoded {@link UiccAccessRule}s from\n     * {@link UiccAccessRule#encodeRules}. Only present if {@link #IS_EMBEDDED} is 1.\n     * <p>TYPE: BLOB\n     * @hide\n     ",
    "links" : [ "android.telephony.UiccAccessRule", "android.telephony.UiccAccessRule#encodeRules", "#IS_EMBEDDED" ]
  }, {
    "name" : "ACCESS_RULES_FROM_CARRIER_CONFIGS",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for the encoded {@link UiccAccessRule}s from\n     * {@link UiccAccessRule#encodeRules} but for the rules that come from CarrierConfigs.\n     * Only present if there are access rules in CarrierConfigs\n     * <p>TYPE: BLOB\n     * @hide\n     ",
    "links" : [ "android.telephony.UiccAccessRule", "android.telephony.UiccAccessRule#encodeRules" ]
  }, {
    "name" : "IS_REMOVABLE",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name identifying whether an embedded subscription is on a removable\n     * card. Such subscriptions are marked inaccessible as soon as the current card is removed.\n     * Otherwise, they will remain accessible unless explicitly deleted. Only present if\n     * {@link #IS_EMBEDDED} is 1.\n     * <p>TYPE: INTEGER (int), 1 for removable or 0 for non-removable.\n     * @hide\n     ",
    "links" : [ "#IS_EMBEDDED" ]
  }, {
    "name" : "CB_EXTREME_THREAT_ALERT",
    "type" : "String",
    "comment" : "\n     *  TelephonyProvider column name for extreme threat in CB settings\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CB_SEVERE_THREAT_ALERT",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for severe threat in CB settings\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CB_AMBER_ALERT",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for amber alert in CB settings\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CB_EMERGENCY_ALERT",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for emergency alert in CB settings\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CB_ALERT_SOUND_DURATION",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for alert sound duration in CB settings\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CB_ALERT_REMINDER_INTERVAL",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for alert reminder interval in CB settings\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CB_ALERT_VIBRATE",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for enabling vibrate in CB settings\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CB_ALERT_SPEECH",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for enabling alert speech in CB settings\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CB_ETWS_TEST_ALERT",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for ETWS test alert in CB settings\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CB_CHANNEL_50_ALERT",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for enable channel50 alert in CB settings\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CB_CMAS_TEST_ALERT",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for CMAS test alert in CB settings\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CB_OPT_OUT_DIALOG",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for Opt out dialog in CB settings\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ENHANCED_4G_MODE_ENABLED",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for enable Volte.\n     *\n     * If this setting is not initialized (set to -1)  then we use the Carrier Config value\n     * {@link CarrierConfigManager#KEY_ENHANCED_4G_LTE_ON_BY_DEFAULT_BOOL}.\n     *@hide\n     ",
    "links" : [ "android.telephony.CarrierConfigManager#KEY_ENHANCED_4G_LTE_ON_BY_DEFAULT_BOOL" ]
  }, {
    "name" : "VT_IMS_ENABLED",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for enable VT (Video Telephony over IMS)\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WFC_IMS_ENABLED",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for enable Wifi calling\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WFC_IMS_MODE",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for Wifi calling mode\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WFC_IMS_ROAMING_MODE",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for Wifi calling mode in roaming\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WFC_IMS_ROAMING_ENABLED",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for enable Wifi calling in roaming\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "IMS_RCS_UCE_ENABLED",
    "type" : "String",
    "comment" : "\n     * Determines if the user has enabled IMS RCS User Capability Exchange (UCE) for this\n     * subscription.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CROSS_SIM_CALLING_ENABLED",
    "type" : "String",
    "comment" : "\n     * Determines if the user has enabled cross SIM calling for this subscription.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "IS_OPPORTUNISTIC",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for whether a subscription is opportunistic, that is,\n     * whether the network it connects to is limited in functionality or coverage.\n     * For example, CBRS.\n     * <p>Type: INTEGER (int), 1 for opportunistic or 0 for non-opportunistic.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "GROUP_UUID",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for group ID. Subscriptions with same group ID\n     * are considered bundled together, and should behave as a single subscription at\n     * certain scenarios.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "GROUP_OWNER",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for group owner. It's the package name who created\n     * the subscription group.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PROFILE_CLASS",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for the profile class of a subscription\n     * Only present if {@link #IS_EMBEDDED} is 1.\n     * <P>Type: INTEGER (int)</P>\n     * @hide\n     ",
    "links" : [ "#IS_EMBEDDED" ]
  }, {
    "name" : "PORT_INDEX",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for the port index of the active UICC port.\n     * <P>Type: INTEGER (int)</P>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "VOIMS_OPT_IN_STATUS",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for VoIMS opt-in status.\n     *\n     * <P>Type: INTEGER (int)</P>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NR_ADVANCED_CALLING_ENABLED",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for NR Advanced calling\n     * Determines if the user has enabled VoNR settings for this subscription.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PROFILE_CLASS_TESTING",
    "type" : "int",
    "comment" : "\n     * A testing profile can be pre-loaded or downloaded onto\n     * the eUICC and provides connectivity to test equipment\n     * for the purpose of testing the device and the eUICC. It\n     * is not intended to store any operator credentials.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PROFILE_CLASS_PROVISIONING",
    "type" : "int",
    "comment" : "\n     * A provisioning profile is pre-loaded onto the eUICC and\n     * provides connectivity to a mobile network solely for the\n     * purpose of provisioning profiles.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PROFILE_CLASS_OPERATIONAL",
    "type" : "int",
    "comment" : "\n     * An operational profile can be pre-loaded or downloaded\n     * onto the eUICC and provides services provided by the\n     * operator.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PROFILE_CLASS_UNSET",
    "type" : "int",
    "comment" : "\n     * The profile class is unset. This occurs when profile class\n     * info is not available. The subscription either has no profile\n     * metadata or the profile metadata did not encode profile class.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PROFILE_CLASS_DEFAULT",
    "type" : "int",
    "comment" : "\n     * Default profile class\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "IMSI",
    "type" : "String",
    "comment" : "TODO: add @SystemApi",
    "links" : [ ]
  }, {
    "name" : "UICC_APPLICATIONS_ENABLED",
    "type" : "String",
    "comment" : "\n     * Whether uicc applications is set to be enabled or disabled. By default it's enabled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ALLOWED_NETWORK_TYPES",
    "type" : "String",
    "comment" : "\n     * Indicate which network type is allowed.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "USER_HANDLE",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for user handle associated with a sim.\n     * <P>Type: INTEGER (int)</P>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SATELLITE_ENABLED",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for satellite enabled.\n     * By default, it's disabled.\n     * <P>Type: INTEGER (int)</P>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SATELLITE_ATTACH_ENABLED_FOR_CARRIER",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for satellite attach enabled for carrier. The value of this\n     * column is set based on user settings.\n     * By default, it's enabled.\n     * <P>Type: INTEGER (int)</P>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "IS_NTN",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name to identify eSIM profile of a non-terrestrial network.\n     * By default, it's disabled.\n     * <P>Type: INTEGER (int)</P>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SERVICE_CAPABILITIES",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name to identify service capabilities.\n     * Disabled by default.\n     * <P>Type: INTEGER (int)</P>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSFER_STATUS",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name to identify eSIM's transfer status.\n     * By default, it's disabled.\n     * <P>Type: INTEGER (int)</P>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SATELLITE_ENTITLEMENT_STATUS",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for satellite entitlement status. The value of this column is\n     * set based on entitlement query result for satellite configuration.\n     * By default, it's disabled.\n     * <P>Type: INTEGER (int)</P>\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SATELLITE_ENTITLEMENT_PLMNS",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for satellite entitlement plmns. The value of this column is\n     * set based on entitlement query result for satellite configuration.\n     * By default, it's empty.\n     * <P>Type: TEXT </P>\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "USAGE_SETTING_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * The usage setting is unknown.\n     *\n     * This will be the usage setting returned on devices that do not support querying the\n     * or setting the usage setting.\n     *\n     * It may also be provided by a carrier that wishes to provide a value to avoid making any\n     * settings changes.\n     ",
    "links" : [ ]
  }, {
    "name" : "USAGE_SETTING_DEFAULT",
    "type" : "int",
    "comment" : "\n     * Subscription uses the default setting.\n     *\n     * The value is based upon device capability and the other properties of the subscription.\n     *\n     * Most subscriptions will default to voice-centric when in a phone.\n     *\n     * An opportunistic subscription will default to data-centric.\n     *\n     * @see SubscriptionInfo#isOpportunistic\n     ",
    "links" : [ ]
  }, {
    "name" : "USAGE_SETTING_VOICE_CENTRIC",
    "type" : "int",
    "comment" : "\n     * This subscription is forced to voice-centric mode\n     *\n     * <p>Refer to voice-centric mode in 3gpp 24.301 sec 4.3 and 3gpp 24.501 sec 4.3.\n     * Also refer to \"UE's usage setting\" as defined in 3gpp 24.301 section 3.1 and 3gpp 23.221\n     * Annex A.\n     *\n     * <p>Devices that support {@link PackageManager#FEATURE_TELEPHONY_CALLING} and support usage\n     * setting configuration must support setting this value via\n     * {@link CarrierConfigManager#KEY_CELLULAR_USAGE_SETTING_INT}.\n     ",
    "links" : [ "android.telephony.CarrierConfigManager#KEY_CELLULAR_USAGE_SETTING_INT", "android.content.pm.PackageManager#FEATURE_TELEPHONY_CALLING" ]
  }, {
    "name" : "USAGE_SETTING_DATA_CENTRIC",
    "type" : "int",
    "comment" : "\n     * This subscription is forced to data-centric mode\n     *\n     * <p>Refer to data-centric mode in 3gpp 24.301 sec 4.3 and 3gpp 24.501 sec 4.3.\n     * Also refer to \"UE's usage setting\" as defined in 3gpp 24.301 section 3.1 and 3gpp 23.221\n     * Annex A.\n     *\n     * <p>Devices that support {@link PackageManager#FEATURE_TELEPHONY_DATA} and support usage\n     * setting configuration must support setting this value via.\n     * {@link CarrierConfigManager#KEY_CELLULAR_USAGE_SETTING_INT}.\n     ",
    "links" : [ "android.telephony.CarrierConfigManager#KEY_CELLULAR_USAGE_SETTING_INT", "android.content.pm.PackageManager#FEATURE_TELEPHONY_DATA" ]
  }, {
    "name" : "USAGE_SETTING",
    "type" : "String",
    "comment" : "\n     * Indicate the preferred usage setting for the subscription.\n     *\n     * 0 - Default - If the value has not been explicitly set, it will be \"default\"\n     * 1 - Voice-centric\n     * 2 - Data-centric\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SUB_DEFAULT_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: The user has changed one of the default subs related to\n     * data, phone calls, or sms</p>\n     *\n     * TODO: Change to a listener\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_DEFAULT_SUBSCRIPTION_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: The default subscription has changed.  This has the following\n     * extra values:</p>\n     * The {@link #EXTRA_SUBSCRIPTION_INDEX} extra indicates the current default subscription index\n     ",
    "links" : [ "#EXTRA_SUBSCRIPTION_INDEX" ]
  }, {
    "name" : "ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: The default sms subscription has changed.  This has the following\n     * extra values:</p>\n     * {@link #EXTRA_SUBSCRIPTION_INDEX} extra indicates the current default sms\n     * subscription index\n     ",
    "links" : [ "#EXTRA_SUBSCRIPTION_INDEX" ]
  }, {
    "name" : "ACTION_MANAGE_SUBSCRIPTION_PLANS",
    "type" : "String",
    "comment" : "\n     * Activity Action: Display UI for managing the billing relationship plans\n     * between a carrier and a specific subscriber.\n     * <p>\n     * Carrier apps are encouraged to implement this activity, and the OS will\n     * provide an affordance to quickly enter this activity, typically via\n     * Settings. This affordance will only be shown when the carrier app is\n     * actively providing subscription plan information via\n     * {@link #setSubscriptionPlans(int, List)}.\n     * <p>\n     * Contains {@link #EXTRA_SUBSCRIPTION_INDEX} to indicate which subscription\n     * the user is interested in.\n     ",
    "links" : [ "#setSubscriptionPlans(int", "#EXTRA_SUBSCRIPTION_INDEX" ]
  }, {
    "name" : "ACTION_REFRESH_SUBSCRIPTION_PLANS",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Request a refresh of the billing relationship plans\n     * between a carrier and a specific subscriber.\n     * <p>\n     * Carrier apps are encouraged to implement this receiver, and the OS will\n     * provide an affordance to request a refresh. This affordance will only be\n     * shown when the carrier app is actively providing subscription plan\n     * information via {@link #setSubscriptionPlans(int, List)}.\n     * <p>\n     * Contains {@link #EXTRA_SUBSCRIPTION_INDEX} to indicate which subscription\n     * the user is interested in.\n     * <p>\n     * Receivers should protect themselves by checking that the sender holds the\n     * {@code android.permission.MANAGE_SUBSCRIPTION_PLANS} permission.\n     ",
    "links" : [ "#setSubscriptionPlans(int", "#EXTRA_SUBSCRIPTION_INDEX" ]
  }, {
    "name" : "ACTION_SUBSCRIPTION_PLANS_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: The billing relationship plans between a carrier and a\n     * specific subscriber has changed.\n     * <p>\n     * Contains {@link #EXTRA_SUBSCRIPTION_INDEX} to indicate which subscription\n     * changed.\n     * @hide\n     ",
    "links" : [ "#EXTRA_SUBSCRIPTION_INDEX" ]
  }, {
    "name" : "EXTRA_SUBSCRIPTION_INDEX",
    "type" : "String",
    "comment" : "\n     * Integer extra used with {@link #ACTION_DEFAULT_SUBSCRIPTION_CHANGED} and\n     * {@link #ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED} to indicate the subscription\n     * which has changed.\n     ",
    "links" : [ "#ACTION_DEFAULT_SUBSCRIPTION_CHANGED", "#ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED" ]
  }, {
    "name" : "EXTRA_SLOT_INDEX",
    "type" : "String",
    "comment" : "\n     * Integer extra to specify SIM slot index.\n     ",
    "links" : [ ]
  }, {
    "name" : "PHONE_NUMBER_SOURCE_UICC",
    "type" : "int",
    "comment" : "\n     * A source of phone number: the EF-MSISDN (see 3GPP TS 31.102),\n     * or EF-MDN for CDMA (see 3GPP2 C.P0065-B), from UICC application.\n     *\n     * <p>The availability and accuracy of the number depends on the carrier.\n     * The number may be updated by over-the-air update to UICC applications\n     * from the carrier, or by other means with physical access to the SIM.\n     ",
    "links" : [ ]
  }, {
    "name" : "PHONE_NUMBER_SOURCE_CARRIER",
    "type" : "int",
    "comment" : "\n     * A source of phone number: provided by an app that has carrier privilege.\n     *\n     * <p>The number is intended to be set by a carrier app knowing the correct number\n     * which is, for example, different from the number in {@link #PHONE_NUMBER_SOURCE_UICC UICC}\n     * for some reason.\n     * The number is not available until a carrier app sets one via\n     * {@link #setCarrierPhoneNumber(int, String)}.\n     * The app can update the number with the same API should the number change.\n     ",
    "links" : [ "#PHONE_NUMBER_SOURCE_UICC", "#setCarrierPhoneNumber(int" ]
  }, {
    "name" : "PHONE_NUMBER_SOURCE_IMS",
    "type" : "int",
    "comment" : "\n     * A source of phone number: provided by IMS (IP Multimedia Subsystem) implementation.\n     * When IMS service is registered (as indicated by\n     * {@link android.telephony.ims.RegistrationManager.RegistrationCallback#onRegistered(int)})\n     * the IMS implementation may return P-Associated-Uri SIP headers (RFC 3455). The URIs\n     * are the user’s public user identities known to the network (see 3GPP TS 24.229 5.4.1.2),\n     * and the phone number is typically one of them (see “global number” in 3GPP TS 23.003 13.4).\n     *\n     * <p>This source provides the phone number from the last IMS registration.\n     * IMS registration may happen on every device reboot or other network condition changes.\n     * The number will be updated should the associated URI change after an IMS registration.\n     ",
    "links" : [ "android.telephony.ims.RegistrationManager.RegistrationCallback#onRegistered(int)" ]
  }, {
    "name" : "SERVICE_CAPABILITY_VOICE",
    "type" : "int",
    "comment" : "\n     * Represents a value indicating the voice calling capabilities of a subscription.\n     *\n     * <p>This value identifies whether the subscription supports various voice calling services.\n     * These services can include circuit-switched (CS) calling, packet-switched (PS) IMS (IP\n     * Multimedia Subsystem) calling, and over-the-top (OTT) calling options.\n     *\n     * <p>Note: The availability of emergency calling services is not solely dependent on this\n     * voice capability. Emergency services may be accessible even if the subscription lacks\n     * standard voice capabilities. However, the device's ability to support emergency calls\n     * can be influenced by its inherent voice capabilities, as determined by\n     * {@link TelephonyManager#isDeviceVoiceCapable()}.\n     *\n     * @see TelephonyManager#isDeviceVoiceCapable()\n     ",
    "links" : [ "android.telephony.TelephonyManager#isDeviceVoiceCapable()" ]
  }, {
    "name" : "SERVICE_CAPABILITY_SMS",
    "type" : "int",
    "comment" : "\n     * Represents a value indicating the SMS capabilities of a subscription.\n     *\n     * <p>This value identifies whether the subscription supports various sms services.\n     * These services can include circuit-switched (CS) SMS, packet-switched (PS) IMS (IP\n     * Multimedia Subsystem) SMS, and over-the-top (OTT) SMS options.\n     *\n     * <p>Note: The availability of emergency SMS services is not solely dependent on this\n     * sms capability. Emergency services may be accessible even if the subscription lacks\n     * standard sms capabilities. However, the device's ability to support emergency sms\n     * can be influenced by its inherent sms capabilities, as determined by\n     * {@link TelephonyManager#isDeviceSmsCapable()}.\n     *\n     * @see TelephonyManager#isDeviceSmsCapable()\n     ",
    "links" : [ "android.telephony.TelephonyManager#isDeviceSmsCapable()" ]
  }, {
    "name" : "SERVICE_CAPABILITY_DATA",
    "type" : "int",
    "comment" : "\n     * Represents a value indicating the data calling capabilities of a subscription.\n     ",
    "links" : [ ]
  }, {
    "name" : "SERVICE_CAPABILITY_MAX",
    "type" : "int",
    "comment" : "\n     * Maximum value of service capabilities supported so far.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SERVICE_CAPABILITY_VOICE_BITMASK",
    "type" : "int",
    "comment" : "\n     * Bitmask for {@code SERVICE_CAPABILITY_VOICE}.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SERVICE_CAPABILITY_SMS_BITMASK",
    "type" : "int",
    "comment" : "\n     * Bitmask for {@code SERVICE_CAPABILITY_SMS}.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SERVICE_CAPABILITY_DATA_BITMASK",
    "type" : "int",
    "comment" : "\n     * Bitmask for {@code SERVICE_CAPABILITY_DATA}.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MAX_RESOURCE_CACHE_ENTRY_COUNT",
    "type" : "int",
    "comment" : "\n     * In order to prevent the overflow of the heap size due to an indiscriminate increase in the\n     * cache, the heap size of the resource cache is set sufficiently large.\n     ",
    "links" : [ ]
  }, {
    "name" : "sResourcesCache",
    "type" : "LruCache<Pair<String, Configuration>, Resources>",
    "comment" : "\n     * Cache of Resources that has been created in getResourcesForSubId. Key contains package name,\n     * and Configuration of Resources. If more than the maximum number of resources are stored in\n     * this cache, the least recently used Resources will be removed to maintain the maximum size.\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSFER_STATUS_NONE",
    "type" : "int",
    "comment" : "\n     * The profile has not been transferred or converted to an eSIM.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSFER_STATUS_TRANSFERRED_OUT",
    "type" : "int",
    "comment" : "\n     * The existing profile of the old device has been transferred to an eSIM of the new device.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSFER_STATUS_CONVERTED",
    "type" : "int",
    "comment" : "\n     * The existing profile of the same device has been converted to an eSIM of the same device\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "mIsForAllUserProfiles",
    "type" : "boolean",
    "comment" : "\n     * {@code true} if the SubscriptionManager instance should see all subscriptions regardless its\n     * association with particular user profile.\n     *\n     * <p> It only applies to Android SDK 35(V) and above. For Android SDK 34(U) and below, the\n     * caller can see all subscription across user profiles as it does today today even if it's\n     * {@code false}.\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static Uri getUriForSubscriptionId(int subscriptionId)",
    "returnType" : "Uri",
    "comment" : "\n     * Generates a content {@link Uri} used to receive updates on simInfo change\n     * on the given subscriptionId\n     * @param subscriptionId the subscriptionId to receive updates on\n     * @return the Uri used to observe carrier identity changes\n     * @hide\n     ",
    "links" : [ "android.net.Uri" ]
  }, {
    "name" : "private NetworkPolicyManager getNetworkPolicyManager()",
    "returnType" : "NetworkPolicyManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static SubscriptionManager from(Context context)",
    "returnType" : "SubscriptionManager",
    "comment" : "\n     * @deprecated developers should always obtain references directly from\n     *             {@link Context#getSystemService(Class)}.\n     ",
    "links" : [ "android.content.Context#getSystemService(Class)" ]
  }, {
    "name" : "public void addOnSubscriptionsChangedListener(OnSubscriptionsChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register for changes to the list of active {@link SubscriptionInfo} records or to the\n     * individual records themselves. When a change occurs the onSubscriptionsChanged method of\n     * the listener will be invoked immediately if there has been a notification. The\n     * onSubscriptionChanged method will also be triggered once initially when calling this\n     * function. The callback will be invoked on the looper specified in the listener's constructor.\n     *\n     * @param listener an instance of {@link OnSubscriptionsChangedListener} with\n     *                 onSubscriptionsChanged overridden.\n     *\n     * @deprecated Will get exception if the parameter listener is not initialized with a Looper.\n     * Use {@link #addOnSubscriptionsChangedListener(Executor, OnSubscriptionsChangedListener)}.\n     ",
    "links" : [ "#addOnSubscriptionsChangedListener(Executor", "OnSubscriptionsChangedListener", "android.telephony.SubscriptionInfo" ]
  }, {
    "name" : "public void addOnSubscriptionsChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnSubscriptionsChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register for changes to the list of {@link SubscriptionInfo} records or to the\n     * individual records (active or inactive) themselves. When a change occurs, the\n     * {@link OnSubscriptionsChangedListener#onSubscriptionsChanged()} method of\n     * the listener will be invoked immediately. The\n     * {@link OnSubscriptionsChangedListener#onSubscriptionsChanged()} method will also be invoked\n     * once initially when calling this method.\n     *\n     * @param listener an instance of {@link OnSubscriptionsChangedListener} with\n     * {@link OnSubscriptionsChangedListener#onSubscriptionsChanged()} overridden.\n     * @param executor the executor that will execute callbacks.\n     ",
    "links" : [ "#onSubscriptionsChanged()", "OnSubscriptionsChangedListener", "android.telephony.SubscriptionInfo" ]
  }, {
    "name" : "public void removeOnSubscriptionsChangedListener(OnSubscriptionsChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Unregister the {@link OnSubscriptionsChangedListener}. This is not strictly necessary\n     * as the listener will automatically be unregistered if an attempt to invoke the listener\n     * fails.\n     *\n     * @param listener that is to be unregistered.\n     ",
    "links" : [ "OnSubscriptionsChangedListener" ]
  }, {
    "name" : "public void addOnOpportunisticSubscriptionsChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnOpportunisticSubscriptionsChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register for changes to the list of opportunistic subscription records or to the\n     * individual records themselves. When a change occurs the onOpportunisticSubscriptionsChanged\n     * method of the listener will be invoked immediately if there has been a notification.\n     *\n     * @param listener an instance of {@link OnOpportunisticSubscriptionsChangedListener} with\n     *                 onOpportunisticSubscriptionsChanged overridden.\n     ",
    "links" : [ "OnOpportunisticSubscriptionsChangedListener" ]
  }, {
    "name" : "public void removeOnOpportunisticSubscriptionsChangedListener(@NonNull OnOpportunisticSubscriptionsChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Unregister the {@link OnOpportunisticSubscriptionsChangedListener} that is currently\n     * listening opportunistic subscriptions change. This is not strictly necessary\n     * as the listener will automatically be unregistered if an attempt to invoke the listener\n     * fails.\n     *\n     * @param listener that is to be unregistered.\n     ",
    "links" : [ "OnOpportunisticSubscriptionsChangedListener" ]
  }, {
    "name" : "public SubscriptionInfo getActiveSubscriptionInfo(int subId)",
    "returnType" : "SubscriptionInfo",
    "comment" : "\n     * Get the active SubscriptionInfo with the input subId.\n     *\n     * <p>Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     * or that the calling app has carrier privileges (see\n     * {@link TelephonyManager#hasCarrierPrivileges}).\n     *\n     * @param subId The unique SubscriptionInfo key in database.\n     * @return SubscriptionInfo, maybe null if its not active.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "android.telephony.TelephonyManager#hasCarrierPrivileges", "android.Manifest.permission#READ_PHONE_STATE" ]
  }, {
    "name" : "public SubscriptionInfo getActiveSubscriptionInfoForIcc(@NonNull String iccId)",
    "returnType" : "SubscriptionInfo",
    "comment" : "\n     * Gets an active SubscriptionInfo {@link SubscriptionInfo} associated with the Sim IccId.\n     *\n     * @param iccId the IccId of SIM card\n     * @return SubscriptionInfo, maybe null if its not active\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "android.telephony.SubscriptionInfo" ]
  }, {
    "name" : "public SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int slotIndex)",
    "returnType" : "SubscriptionInfo",
    "comment" : "\n     * Get the active SubscriptionInfo associated with the slotIndex\n     *\n     * <p>Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     * or that the calling app has carrier privileges (see\n     * {@link TelephonyManager#hasCarrierPrivileges}).\n     *\n     * @param slotIndex the slot which the subscription is inserted\n     * @return SubscriptionInfo, maybe null if its not active\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "android.telephony.TelephonyManager#hasCarrierPrivileges", "android.Manifest.permission#READ_PHONE_STATE" ]
  }, {
    "name" : "public List<SubscriptionInfo> getAllSubscriptionInfoList()",
    "returnType" : "List<SubscriptionInfo>",
    "comment" : "\n     * Get all subscription info records from SIMs that are inserted now or previously inserted.\n     *\n     * <p>\n     * If the caller does not have {@link Manifest.permission#READ_PHONE_NUMBERS} permission,\n     * {@link SubscriptionInfo#getNumber()} will return empty string.\n     * If the caller does not have {@link Manifest.permission#USE_ICC_AUTH_WITH_DEVICE_IDENTIFIER},\n     * {@link SubscriptionInfo#getIccId()} will return an empty string, and\n     * {@link SubscriptionInfo#getGroupUuid()} will return {@code null}.\n     *\n     * <p>\n     * The carrier app will only get the list of subscriptions that it has carrier privilege on,\n     * but will have non-stripped {@link SubscriptionInfo} in the list.\n     *\n     * @return List of all {@link SubscriptionInfo} records from SIMs that are inserted or\n     * previously inserted. Sorted by {@link SubscriptionInfo#getSimSlotIndex()}, then\n     * {@link SubscriptionInfo#getSubscriptionId()}.\n     *\n     * @throws SecurityException if callers do not hold the required permission.\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "android.telephony.SubscriptionInfo#getIccId()", "android.telephony.SubscriptionInfo#getNumber()", "Manifest.permission#READ_PHONE_NUMBERS", "android.telephony.SubscriptionInfo#getGroupUuid()", "Manifest.permission#USE_ICC_AUTH_WITH_DEVICE_IDENTIFIER", "android.telephony.SubscriptionInfo", "android.telephony.SubscriptionInfo#getSimSlotIndex()", "android.telephony.SubscriptionInfo#getSubscriptionId()" ]
  }, {
    "name" : "public List<SubscriptionInfo> getActiveSubscriptionInfoList()",
    "returnType" : "List<SubscriptionInfo>",
    "comment" : "\n     * Get the SubscriptionInfo(s) of the currently active SIM(s).\n     *\n     * <p> Returned records will be sorted by {@link SubscriptionInfo#getSimSlotIndex} then by\n     * {@link SubscriptionInfo#getSubscriptionId}. Beginning with Android SDK 35, this method will\n     * never return null.\n     *\n     * <p>Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     * or that the calling app has carrier privileges (see\n     * {@link TelephonyManager#hasCarrierPrivileges}).\n     *\n     * @return a list of the active {@link SubscriptionInfo} that is visible to the caller. If\n     *         an empty list or null is returned, then there are no active subscriptions that\n     *         are visible to the caller. If the number of active subscriptions available to\n     *         any caller changes, then this change will be indicated by\n     *         {@link OnSubscriptionsChangedListener#onSubscriptionsChanged}.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *         {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "android.telephony.SubscriptionInfo#getSubscriptionId", "android.telephony.TelephonyManager#hasCarrierPrivileges", "android.telephony.SubscriptionInfo#getSimSlotIndex", "#onSubscriptionsChanged", "android.Manifest.permission#READ_PHONE_STATE", "android.telephony.SubscriptionInfo" ]
  }, {
    "name" : "public List<SubscriptionInfo> getCompleteActiveSubscriptionInfoList()",
    "returnType" : "List<SubscriptionInfo>",
    "comment" : "\n     * Get both hidden and visible SubscriptionInfo(s) of the currently active SIM(s).\n     * The records will be sorted by {@link SubscriptionInfo#getSimSlotIndex}\n     * then by {@link SubscriptionInfo#getSubscriptionId}.\n     *\n     * Hidden subscriptions refer to those are not meant visible to the users.\n     * For example, an opportunistic subscription that is grouped with other\n     * subscriptions should remain invisible to users as they are only functionally\n     * supplementary to primary ones.\n     *\n     * <p>Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     * or that the calling app has carrier privileges (see\n     * {@link TelephonyManager#hasCarrierPrivileges}). In the latter case, only records accessible\n     * to the calling app are returned.\n     *\n     * @return Sorted list of the currently available {@link SubscriptionInfo}\n     * records on the device.\n     * This is similar to {@link #getActiveSubscriptionInfoList} except that it will return\n     * both active and hidden SubscriptionInfos.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "android.telephony.SubscriptionInfo#getSubscriptionId", "android.telephony.TelephonyManager#hasCarrierPrivileges", "android.telephony.SubscriptionInfo#getSimSlotIndex", "#getActiveSubscriptionInfoList", "android.Manifest.permission#READ_PHONE_STATE", "android.telephony.SubscriptionInfo" ]
  }, {
    "name" : "public SubscriptionManager createForAllUserProfiles()",
    "returnType" : "SubscriptionManager",
    "comment" : "\n     * Create a new subscription manager instance that can see all subscriptions across\n     * user profiles.\n     *\n     * The permission check for accessing all subscriptions will be enforced upon calling the\n     * individual APIs linked below.\n     *\n     * @return a SubscriptionManager that can see all subscriptions regardless its user profile\n     * association.\n     *\n     * @see #getActiveSubscriptionInfoList\n     * @see #getActiveSubscriptionInfoCount\n     * @see UserHandle\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<SubscriptionInfo> getActiveSubscriptionInfoList(boolean userVisibleOnly)",
    "returnType" : "List<SubscriptionInfo>",
    "comment" : "\n    * This is similar to {@link #getActiveSubscriptionInfoList()}, but if userVisibleOnly\n    * is true, it will filter out the hidden subscriptions.\n    *\n    * @hide\n    ",
    "links" : [ "#getActiveSubscriptionInfoList()" ]
  }, {
    "name" : "public List<SubscriptionInfo> getAvailableSubscriptionInfoList()",
    "returnType" : "List<SubscriptionInfo>",
    "comment" : "\n     * Gets the SubscriptionInfo(s) of all available subscriptions, if any.\n     *\n     * <p>Available subscriptions include active ones (those with a non-negative\n     * {@link SubscriptionInfo#getSimSlotIndex()}) as well as inactive but installed embedded\n     * subscriptions.\n     *\n     * <p>The records will be sorted by {@link SubscriptionInfo#getSimSlotIndex} then by\n     * {@link SubscriptionInfo#getSubscriptionId}.\n     *\n     * @return Sorted list of the current {@link SubscriptionInfo} records available on the\n     * device.\n     * <ul>\n     * <li>\n     * If null is returned the current state is unknown but if a\n     * {@link OnSubscriptionsChangedListener} has been registered\n     * {@link OnSubscriptionsChangedListener#onSubscriptionsChanged} will be invoked in the future.\n     * <li>\n     * If the list is empty then there are no {@link SubscriptionInfo} records currently available.\n     * <li>\n     * if the list is non-empty the list is sorted by {@link SubscriptionInfo#getSimSlotIndex}\n     * then by {@link SubscriptionInfo#getSubscriptionId}.\n     * </ul>\n     *\n     * <p>\n     * Permissions android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE is required\n     * for #getAvailableSubscriptionInfoList to be invoked.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "android.telephony.SubscriptionInfo#getSubscriptionId", "OnSubscriptionsChangedListener", "android.telephony.SubscriptionInfo#getSimSlotIndex", "#onSubscriptionsChanged", "android.telephony.SubscriptionInfo", "android.telephony.SubscriptionInfo#getSimSlotIndex()" ]
  }, {
    "name" : "public List<SubscriptionInfo> getAccessibleSubscriptionInfoList()",
    "returnType" : "List<SubscriptionInfo>",
    "comment" : "\n     * Gets the SubscriptionInfo(s) of all embedded subscriptions accessible to the calling app, if\n     * any.\n     *\n     * <p>Only those subscriptions for which the calling app has carrier privileges per the\n     * subscription metadata, if any, will be included in the returned list.\n     *\n     * <p>The records will be sorted by {@link SubscriptionInfo#getSimSlotIndex} then by\n     * {@link SubscriptionInfo#getSubscriptionId}.\n     *\n     * @return Sorted list of the current embedded {@link SubscriptionInfo} records available on the\n     * device which are accessible to the caller.\n     * <ul>\n     * <li>\n     * If null is returned the current state is unknown but if a\n     * {@link OnSubscriptionsChangedListener} has been registered\n     * {@link OnSubscriptionsChangedListener#onSubscriptionsChanged} will be invoked in the future.\n     * <li>\n     * If the list is empty then there are no {@link SubscriptionInfo} records currently available.\n     * <li>\n     * if the list is non-empty the list is sorted by {@link SubscriptionInfo#getSimSlotIndex}\n     * then by {@link SubscriptionInfo#getSubscriptionId}.\n     * </ul>\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     ",
    "links" : [ "android.telephony.SubscriptionInfo#getSubscriptionId", "OnSubscriptionsChangedListener", "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC", "android.telephony.SubscriptionInfo#getSimSlotIndex", "#onSubscriptionsChanged", "android.telephony.SubscriptionInfo" ]
  }, {
    "name" : "public void requestEmbeddedSubscriptionInfoListRefresh()",
    "returnType" : "void",
    "comment" : "\n     * Request a refresh of the platform cache of profile information for the eUICC which\n     * corresponds to the card ID returned by {@link TelephonyManager#getCardIdForDefaultEuicc()}.\n     *\n     * <p>Should be called by the EuiccService implementation whenever this information changes due\n     * to an operation done outside the scope of a request initiated by the platform to the\n     * EuiccService. There is no need to refresh for downloads, deletes, or other operations that\n     * were made through the EuiccService.\n     *\n     * <p>Requires the {@link android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission.\n     *\n     * @see TelephonyManager#getCardIdForDefaultEuicc() for more information on the card ID.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS", "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC", "android.telephony.TelephonyManager#getCardIdForDefaultEuicc()" ]
  }, {
    "name" : "public void requestEmbeddedSubscriptionInfoListRefresh(int cardId)",
    "returnType" : "void",
    "comment" : "\n     * Request a refresh of the platform cache of profile information for the eUICC with the given\n     * {@code cardId}.\n     *\n     * <p>Should be called by the EuiccService implementation whenever this information changes due\n     * to an operation done outside the scope of a request initiated by the platform to the\n     * EuiccService. There is no need to refresh for downloads, deletes, or other operations that\n     * were made through the EuiccService.\n     *\n     * <p>Requires the {@link android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission.\n     *\n     * @param cardId the card ID of the eUICC.\n     *\n     * @see TelephonyManager#getCardIdForDefaultEuicc() for more information on the card ID.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS", "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC" ]
  }, {
    "name" : "public int getActiveSubscriptionInfoCount()",
    "returnType" : "int",
    "comment" : "\n     * Get the active subscription count.\n     *\n     * @return The current number of active subscriptions.\n     *\n     * @see #getActiveSubscriptionInfoList()\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION" ]
  }, {
    "name" : "public int getActiveSubscriptionInfoCountMax()",
    "returnType" : "int",
    "comment" : "\n     * @return the maximum number of active subscriptions that will be returned by\n     * {@link #getActiveSubscriptionInfoList} and the value returned by\n     * {@link #getActiveSubscriptionInfoCount}.\n     ",
    "links" : [ "#getActiveSubscriptionInfoCount", "#getActiveSubscriptionInfoList" ]
  }, {
    "name" : "public Uri addSubscriptionInfoRecord(String iccId, int slotIndex)",
    "returnType" : "Uri",
    "comment" : "\n     * Add a new SubscriptionInfo to SubscriptionInfo database if needed\n     * @param iccId the IccId of the SIM card\n     * @param slotIndex the slot which the SIM is inserted\n     * @return the URL of the newly created row or the updated row\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addSubscriptionInfoRecord(@NonNull String uniqueId, @Nullable String displayName, int slotIndex, @SubscriptionType int subscriptionType)",
    "returnType" : "void",
    "comment" : "\n     * Add a new SubscriptionInfo to SubscriptionInfo database if needed\n     * @param uniqueId This is the unique identifier for the subscription within the\n     *                 specific subscription type.\n     * @param displayName human-readable name of the device the subscription corresponds to.\n     * @param slotIndex the slot assigned to this subscription. It is ignored for subscriptionType\n     *                  of {@link #SUBSCRIPTION_TYPE_REMOTE_SIM}.\n     * @param subscriptionType the {@link #SUBSCRIPTION_TYPE}\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "#SUBSCRIPTION_TYPE", "#SUBSCRIPTION_TYPE_REMOTE_SIM" ]
  }, {
    "name" : "public void removeSubscriptionInfoRecord(@NonNull String uniqueId, @SubscriptionType int subscriptionType)",
    "returnType" : "void",
    "comment" : "\n     * Remove subscription info record from the subscription database.\n     *\n     * @param uniqueId This is the unique identifier for the subscription within the specific\n     * subscription type.\n     * @param subscriptionType the type of subscription to be removed.\n     *\n     * @throws NullPointerException if {@code uniqueId} is {@code null}.\n     * @throws SecurityException if callers do not hold the required permission.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION" ]
  }, {
    "name" : "public int setIconTint(@ColorInt int tint, int subId)",
    "returnType" : "int",
    "comment" : "\n     * Set SIM icon tint color for subscription ID\n     * @param tint the RGB value of icon tint color of the SIM\n     * @param subId the unique subscription ID in database\n     * @return the number of records updated\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int setDisplayName(@Nullable String displayName, int subId, @SimDisplayNameSource int nameSource)",
    "returnType" : "int",
    "comment" : "\n     * Set the display name for a subscription ID\n     * @param displayName the display name of SIM card\n     * @param subId the unique Subscritpion ID in database\n     * @param nameSource SIM display name source\n     * @return the number of records updated or < 0 if invalid subId\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int setDisplayNumber(String number, int subId)",
    "returnType" : "int",
    "comment" : "\n     * Set phone number by subId\n     * @param number the phone number of the SIM\n     * @param subId the unique SubscriptionInfo index in database\n     * @return the number of records updated\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int setDataRoaming(int roaming, int subId)",
    "returnType" : "int",
    "comment" : "\n     * Set data roaming by simInfo index\n     * @param roaming 0:Don't allow data when roaming, 1:Allow data when roaming\n     * @param subId the unique SubscriptionInfo index in database\n     * @return the number of records updated\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getSlotIndex(int subscriptionId)",
    "returnType" : "int",
    "comment" : "\n     * Get slotIndex associated with the subscription.\n     *\n     * @param subscriptionId the unique SubscriptionInfo index in database\n     * @return slotIndex as a positive integer or {@link #INVALID_SIM_SLOT_INDEX} if the supplied\n     * subscriptionId doesn't have an associated slot index.\n     ",
    "links" : [ "#INVALID_SIM_SLOT_INDEX" ]
  }, {
    "name" : "public int[] getSubscriptionIds(int slotIndex)",
    "returnType" : "int[]",
    "comment" : "\n     * Get an array of subscription ids for the specified logical SIM slot Index. The maximum size\n     * of the array is 1. This API was mistakenly designed to return multiple subscription ids,\n     * which is not possible in the current Android telephony architecture.\n     *\n     * @param slotIndex The logical SIM slot index.\n     *\n     * @return Subscription id of the active subscription on the specified logical SIM slot index.\n     * If SIM is absent on the slot, a single element array of {@link #INVALID_SUBSCRIPTION_ID} will\n     * be returned. {@code null} if the provided {@code slotIndex} is not valid.\n     *\n     * @deprecated Use {@link #getSubscriptionId(int)} instead.\n     ",
    "links" : [ "#getSubscriptionId(int)", "#INVALID_SUBSCRIPTION_ID" ]
  }, {
    "name" : "public static int[] getSubId(int slotIndex)",
    "returnType" : "int[]",
    "comment" : "\n     * Get an array of subscription ids for the specified logical SIM slot Index. The maximum size\n     * of the array is 1. This API was mistakenly designed to return multiple subscription ids,\n     * which is not possible in the current Android telephony architecture.\n     *\n     * @param slotIndex The logical SIM slot index.\n     *\n     * @return Subscription id of the active subscription on the specified logical SIM slot index.\n     * If SIM is absent on the slot, a single element array of {@link #INVALID_SUBSCRIPTION_ID} will\n     * be returned. {@code null} if the provided {@code slotIndex} is not valid.\n     *\n     * @deprecated Use {@link #getSubscriptionId(int)} instead.\n     * @hide\n     ",
    "links" : [ "#getSubscriptionId(int)", "#INVALID_SUBSCRIPTION_ID" ]
  }, {
    "name" : "public static int getSubscriptionId(int slotIndex)",
    "returnType" : "int",
    "comment" : "\n     * Get the subscription id for specified logical SIM slot index.\n     *\n     * @param slotIndex The logical SIM slot index.\n     * @return The subscription id. {@link #INVALID_SUBSCRIPTION_ID} if SIM is absent.\n     ",
    "links" : [ "#INVALID_SUBSCRIPTION_ID" ]
  }, {
    "name" : "public static int getPhoneId(int subId)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private static void logd(String msg)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void loge(String msg)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static int getDefaultSubscriptionId()",
    "returnType" : "int",
    "comment" : "\n     * Returns the system's default subscription id.\n     *\n     * For a voice capable device, it will return getDefaultVoiceSubscriptionId.\n     * For a data only device, it will return the getDefaultDataSubscriptionId.\n     * May return an INVALID_SUBSCRIPTION_ID on error.\n     *\n     * @return the \"system\" default subscription id.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getDefaultVoiceSubscriptionId()",
    "returnType" : "int",
    "comment" : "\n     * Returns the system's default voice subscription id.\n     *\n     * On a data only device or on error, will return INVALID_SUBSCRIPTION_ID.\n     *\n     * @return the default voice subscription Id.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION" ]
  }, {
    "name" : "public void setDefaultVoiceSubscriptionId(int subscriptionId)",
    "returnType" : "void",
    "comment" : "\n     * Sets the system's default voice subscription id.\n     *\n     * On a data-only device, this is a no-op.\n     *\n     * May throw a {@link RuntimeException} if the provided subscription id is equal to\n     * {@link SubscriptionManager#DEFAULT_SUBSCRIPTION_ID}\n     *\n     * @param subscriptionId A valid subscription ID to set as the system default, or\n     *                       {@link SubscriptionManager#INVALID_SUBSCRIPTION_ID}\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "RuntimeException", "android.telephony.SubscriptionManager#DEFAULT_SUBSCRIPTION_ID", "android.telephony.SubscriptionManager#INVALID_SUBSCRIPTION_ID" ]
  }, {
    "name" : "public void setDefaultVoiceSubId(int subId)",
    "returnType" : "void",
    "comment" : "\n     * Same as {@link #setDefaultVoiceSubscriptionId(int)}, but preserved for backwards\n     * compatibility.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "#setDefaultVoiceSubscriptionId(int)" ]
  }, {
    "name" : "public SubscriptionInfo getDefaultVoiceSubscriptionInfo()",
    "returnType" : "SubscriptionInfo",
    "comment" : "\n     * Return the SubscriptionInfo for default voice subscription.\n     *\n     * Will return null on data only devices, or on error.\n     *\n     * @return the SubscriptionInfo for the default voice subscription.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getDefaultVoicePhoneId()",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static int getDefaultSmsSubscriptionId()",
    "returnType" : "int",
    "comment" : "\n     * Returns the system's default SMS subscription id.\n     *\n     * On a data only device or on error, will return INVALID_SUBSCRIPTION_ID.\n     *\n     * @return the default SMS subscription Id.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDefaultSmsSubId(int subscriptionId)",
    "returnType" : "void",
    "comment" : "\n     * Set the subscription which will be used by default for SMS, with the subscription which\n     * the supplied subscription ID corresponds to; or throw a RuntimeException if the supplied\n     * subscription ID is not usable (check with {@link #isUsableSubscriptionId(int)}).\n     *\n     * @param subscriptionId the supplied subscription ID\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "#isUsableSubscriptionId(int)" ]
  }, {
    "name" : "public static int getDefaultDataSubscriptionId()",
    "returnType" : "int",
    "comment" : "\n     * Returns the system's default data subscription id.\n     *\n     * On a voice only device or on error, will return INVALID_SUBSCRIPTION_ID.\n     *\n     * @return the default data subscription Id.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDefaultDataSubId(int subscriptionId)",
    "returnType" : "void",
    "comment" : "\n     * Set the subscription which will be used by default for data, with the subscription which\n     * the supplied subscription ID corresponds to; or throw a RuntimeException if the supplied\n     * subscription ID is not usable (check with {@link #isUsableSubscriptionId(int)}).\n     *\n     * @param subscriptionId the supplied subscription ID\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "#isUsableSubscriptionId(int)" ]
  }, {
    "name" : "public SubscriptionInfo getDefaultDataSubscriptionInfo()",
    "returnType" : "SubscriptionInfo",
    "comment" : "\n     * Return the SubscriptionInfo for default data subscription.\n     *\n     * Will return null on voice only devices, or on error.\n     *\n     * @return the SubscriptionInfo for the default data subscription.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION" ]
  }, {
    "name" : "public static boolean isValidSubscriptionId(int subscriptionId)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the supplied subscription ID is valid.\n     *\n     * <p>A valid subscription ID is not necessarily an active subscription ID\n     * (see {@link #isActiveSubscriptionId(int)}) or an usable subscription ID\n     * (see {@link #isUsableSubscriptionId(int)}). Unless specifically noted, subscription\n     * APIs work with a valid subscription ID.\n     *\n     * @param subscriptionId The subscription ID.\n     * @return {@code true} if the supplied subscriptionId is valid; {@code false} otherwise.\n     ",
    "links" : [ "#isUsableSubscriptionId(int)", "#isActiveSubscriptionId(int)" ]
  }, {
    "name" : "public static boolean isUsableSubscriptionId(int subscriptionId)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the supplied subscription ID is usable.\n     *\n     * <p>A usable subscription ID is a valid subscription ID, but not necessarily an active\n     * subscription ID (see {@link #isActiveSubscriptionId(int)}). Some subscription APIs\n     * require a usable subscription ID, and this is noted in their documentation; otherwise, a\n     * subscription ID does not need to be usable for subscription functions, only valid.\n     *\n     * @param subscriptionId the subscription ID\n     * @return {@code true} if the subscription ID is usable; {@code false} otherwise.\n     ",
    "links" : [ "#isActiveSubscriptionId(int)" ]
  }, {
    "name" : "public static boolean isUsableSubIdValue(int subId)",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if subId is an usable subId value else false. A\n     * usable subId means its neither a INVALID_SUBSCRIPTION_ID nor a DEFAULT_SUB_ID.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isValidSlotIndex(int slotIndex)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isValidPhoneId(int phoneId)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void putPhoneIdAndSubIdExtra(Intent intent, int phoneId)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void putPhoneIdAndSubIdExtra(Intent intent, int phoneId, int subId)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int[] getActiveSubscriptionIdList()",
    "returnType" : "int[]",
    "comment" : "\n     * Get visible subscription Id(s) of the currently active SIM(s).\n     *\n     * @return the list of subId's that are active,\n     *         is never null but the length may be 0.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION" ]
  }, {
    "name" : "public int[] getCompleteActiveSubscriptionIdList()",
    "returnType" : "int[]",
    "comment" : "\n     * Get both hidden and visible subscription Id(s) of the currently active SIM(s).\n     *\n     * Hidden subscriptions refer to those are not meant visible to the users.\n     * For example, an opportunistic subscription that is grouped with other\n     * subscriptions should remain invisible to users as they are only functionally\n     * supplementary to primary ones.\n     *\n     * @return the list of subId's that are active,\n     *         is never null but the length may be 0.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION" ]
  }, {
    "name" : "public int[] getActiveSubscriptionIdList(boolean visibleOnly)",
    "returnType" : "int[]",
    "comment" : "\n     * @return a non-null list of subId's that are active.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isNetworkRoaming(int subId)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the device is considered roaming on the current\n     * network for a subscription.\n     * <p>\n     * Availability: Only when user registered to a network.\n     *\n     * @param subId The subscription ID\n     * @return true if the network for the subscription is roaming, false otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void setSubscriptionProperty(int subscriptionId, @NonNull String columnName, @NonNull String value)",
    "returnType" : "void",
    "comment" : "\n     * Set a field in the subscription database. Note not all fields are supported.\n     *\n     * @param subscriptionId Subscription Id of Subscription.\n     * @param columnName Column name in the database. Note not all fields are supported.\n     * @param value Value to store in the database.\n     *\n     * @throws IllegalArgumentException if {@code subscriptionId} is invalid, or the field is not\n     * exposed.\n     * @throws SecurityException if callers do not hold the required permission.\n     *\n     * @see android.provider.Telephony.SimInfo for all the columns.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String serializeUriLists(List<Uri> uris)",
    "returnType" : "String",
    "comment" : "\n     * Serialize list of contacts uri to string\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static String getStringSubscriptionProperty(@NonNull Context context, int subscriptionId, @NonNull String columnName)",
    "returnType" : "String",
    "comment" : "\n     * Get specific field in string format from the subscription info database.\n     *\n     * @param context The calling context.\n     * @param subscriptionId Subscription id of the subscription.\n     * @param columnName Column name in subscription database.\n     *\n     * @return Value in string format associated with {@code subscriptionId} and {@code columnName}\n     * from the database. Empty string if the {@code subscriptionId} is invalid (for backward\n     * compatible).\n     *\n     * @throws IllegalArgumentException if the field is not exposed.\n     *\n     * @see android.provider.Telephony.SimInfo for all the columns.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean getBooleanSubscriptionProperty(int subscriptionId, @NonNull String columnName, boolean defaultValue, @NonNull Context context)",
    "returnType" : "boolean",
    "comment" : "\n     * Get specific field in {@code boolean} format from the subscription info database.\n     *\n     * @param subscriptionId Subscription id of the subscription.\n     * @param columnName Column name in subscription database.\n     * @param defaultValue Default value in case not found or error.\n     * @param context The calling context.\n     *\n     * @return Value in {@code boolean} format associated with {@code subscriptionId} and\n     * {@code columnName} from the database, or {@code defaultValue} if not found or error.\n     *\n     * @throws IllegalArgumentException if {@code subscriptionId} is invalid, or the field is not\n     * exposed.\n     *\n     * @see android.provider.Telephony.SimInfo for all the columns.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getIntegerSubscriptionProperty(int subscriptionId, @NonNull String columnName, int defaultValue, @NonNull Context context)",
    "returnType" : "int",
    "comment" : "\n     * Get specific field in {@code integer} format from the subscription info database.\n     *\n     * @param subscriptionId Subscription id of the subscription.\n     * @param columnName Column name in subscription database.\n     * @param defaultValue Default value in case not found or error.\n     * @param context The calling context.\n     *\n     * @return Value in {@code integer} format associated with {@code subscriptionId} and\n     * {@code columnName} from the database, or {@code defaultValue} if not found or error.\n     *\n     * @throws IllegalArgumentException if {@code subscriptionId} is invalid, or the field is not\n     * exposed.\n     *\n     * @see android.provider.Telephony.SimInfo for all the columns.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static long getLongSubscriptionProperty(int subscriptionId, @NonNull String columnName, long defaultValue, @NonNull Context context)",
    "returnType" : "long",
    "comment" : "\n     * Get specific field in {@code long} format from the subscription info database.\n     *\n     * @param subscriptionId Subscription id of the subscription.\n     * @param columnName Column name in subscription database.\n     * @param defaultValue Default value in case not found or error.\n     * @param context The calling context.\n     *\n     * @return Value in {@code long} format associated with {@code subscriptionId} and\n     * {@code columnName} from the database, or {@code defaultValue} if not found or error.\n     *\n     * @throws IllegalArgumentException if {@code subscriptionId} is invalid, or the field is not\n     * exposed.\n     *\n     * @see android.provider.Telephony.SimInfo for all the columns.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Resources getResourcesForSubId(@NonNull Context context, int subId)",
    "returnType" : "Resources",
    "comment" : "\n     * Returns the {@link Resources} from the given {@link Context} for the MCC/MNC associated with\n     * the subscription. If the subscription ID is invalid, the base resources are returned instead.\n     *\n     * Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     *\n     * @param context Context object\n     * @param subId Subscription Id of Subscription whose resources are required\n     * @return Resources associated with Subscription.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "android.content.Context", "android.Manifest.permission#READ_PHONE_STATE", "android.content.res.Resources" ]
  }, {
    "name" : "public static Resources getResourcesForSubId(Context context, int subId, boolean useRootLocale)",
    "returnType" : "Resources",
    "comment" : "\n     * Returns the resources associated with Subscription.\n     * @param context Context object\n     * @param subId Subscription Id of Subscription who's resources are required\n     * @param useRootLocale if root locale should be used. Localized locale is used if false.\n     * @return Resources associated with Subscription.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isActiveSubscriptionId(int subscriptionId)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the supplied subscription ID corresponds to a subscription which is actively in\n     * use on the device. An active subscription ID is a valid and usable subscription ID.\n     *\n     * @param subscriptionId the subscription ID.\n     * @return {@code true} if the supplied subscription ID corresponds to an active subscription;\n     * {@code false} if it does not correspond to an active subscription; or throw a\n     * SecurityException if the caller hasn't got the right permission.\n     *i\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION" ]
  }, {
    "name" : "public boolean isActiveSubId(int subId)",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if the sub ID is active. i.e. The sub ID corresponds to a known subscription\n     * and the SIM providing the subscription is present in a slot and in \"LOADED\" state.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<SubscriptionPlan> getSubscriptionPlans(int subId)",
    "returnType" : "List<SubscriptionPlan>",
    "comment" : "\n     * Get the description of the billing relationship plan between a carrier\n     * and a specific subscriber.\n     * <p>\n     * This method is only accessible to the following narrow set of apps:\n     * <ul>\n     * <li>The carrier app for this subscriberId, as determined by\n     * {@link TelephonyManager#hasCarrierPrivileges()}.\n     * <li>The carrier app explicitly delegated access through\n     * {@link CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING}.\n     * </ul>\n     *\n     * @param subId the subscriber this relationship applies to\n     * @throws SecurityException if the caller doesn't meet the requirements\n     *             outlined above.\n     ",
    "links" : [ "android.telephony.CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "public void setSubscriptionPlans(int subId, @NonNull List<SubscriptionPlan> plans)",
    "returnType" : "void",
    "comment" : "\n     * Set the description of the billing relationship plan between a carrier\n     * and a specific subscriber.\n     * <p>\n     * This method is only accessible to the following narrow set of apps:\n     * <ul>\n     * <li>The carrier app for this subscriberId, as determined by\n     * {@link TelephonyManager#hasCarrierPrivileges()}.\n     * <li>The carrier app explicitly delegated access through\n     * {@link CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING}.\n     * </ul>\n     *\n     * @param subId the subscriber this relationship applies to. An empty list\n     *            may be sent to clear any existing plans.\n     * @param plans the list of plans. The first plan is always the primary and\n     *            most important plan. Any additional plans are secondary and\n     *            may not be displayed or used by decision making logic.\n     * @throws SecurityException if the caller doesn't meet the requirements\n     *             outlined above.\n     * @throws IllegalArgumentException if plans don't meet the requirements\n     *             defined in {@link SubscriptionPlan}.\n     * @deprecated use {@link #setSubscriptionPlans(int, List, long)} instead.\n     ",
    "links" : [ "#setSubscriptionPlans(int", "android.telephony.CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING", "android.telephony.SubscriptionPlan", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "public void setSubscriptionPlans(int subId, @NonNull List<SubscriptionPlan> plans, @DurationMillisLong long expirationDurationMillis)",
    "returnType" : "void",
    "comment" : "\n     * Set the description of the billing relationship plan between a carrier\n     * and a specific subscriber.\n     * <p>\n     * This method is only accessible to the following narrow set of apps:\n     * <ul>\n     * <li>The carrier app for this subscriberId, as determined by\n     * {@link TelephonyManager#hasCarrierPrivileges()}.\n     * <li>The carrier app explicitly delegated access through\n     * {@link CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING}.\n     * </ul>\n     *\n     * @param subId the subscriber this relationship applies to. An empty list\n     *            may be sent to clear any existing plans.\n     * @param plans the list of plans. The first plan is always the primary and\n     *            most important plan. Any additional plans are secondary and\n     *            may not be displayed or used by decision making logic.\n     * @param expirationDurationMillis the duration after which the subscription plans\n     *            will be automatically cleared, or {@code 0} to leave the plans until\n     *            explicitly cleared, or the next reboot, whichever happens first.\n     * @throws SecurityException if the caller doesn't meet the requirements\n     *             outlined above.\n     * @throws IllegalArgumentException if plans don't meet the requirements\n     *             defined in {@link SubscriptionPlan}.\n     ",
    "links" : [ "android.telephony.CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING", "android.telephony.SubscriptionPlan", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "public void setSubscriptionOverrideUnmetered(int subId, boolean overrideUnmetered, @DurationMillisLong long expirationDurationMillis)",
    "returnType" : "void",
    "comment" : "\n     * Temporarily override the billing relationship plan between a carrier and\n     * a specific subscriber to be considered unmetered. This will be reflected\n     * to apps via {@link NetworkCapabilities#NET_CAPABILITY_NOT_METERED}.\n     * <p>\n     * This method is only accessible to the following narrow set of apps:\n     * <ul>\n     * <li>The carrier app for this subscriberId, as determined by\n     * {@link TelephonyManager#hasCarrierPrivileges()}.\n     * <li>The carrier app explicitly delegated access through\n     * {@link CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING}.\n     * </ul>\n     *\n     * @param subId the subscriber this override applies to.\n     * @param overrideUnmetered set if the billing relationship should be\n     *            considered unmetered.\n     * @param expirationDurationMillis the duration after which the requested override\n     *            will be automatically cleared, or {@code 0} to leave in the\n     *            requested state until explicitly cleared, or the next reboot,\n     *            whichever happens first.\n     * @throws SecurityException if the caller doesn't meet the requirements\n     *            outlined above.\n     ",
    "links" : [ "android.net.NetworkCapabilities#NET_CAPABILITY_NOT_METERED", "android.telephony.CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "public void setSubscriptionOverrideUnmetered(int subId, boolean overrideUnmetered, @NonNull @Annotation.NetworkType int[] networkTypes, @DurationMillisLong long expirationDurationMillis)",
    "returnType" : "void",
    "comment" : "\n     * Temporarily override the billing relationship plan between a carrier and\n     * a specific subscriber to be considered unmetered. This will be reflected\n     * to apps via {@link NetworkCapabilities#NET_CAPABILITY_NOT_METERED}.\n     * <p>\n     * This method is only accessible to the following narrow set of apps:\n     * <ul>\n     * <li>The carrier app for this subscriberId, as determined by\n     * {@link TelephonyManager#hasCarrierPrivileges()}.\n     * <li>The carrier app explicitly delegated access through\n     * {@link CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING}.\n     * </ul>\n     *\n     * @param subId the subscriber this override applies to.\n     * @param overrideUnmetered set if the billing relationship should be\n     *            considered unmetered.\n     * @param networkTypes the network types this override applies to. If no\n     *            network types are specified, override values will be ignored.\n     * @param expirationDurationMillis the duration after which the requested override\n     *            will be automatically cleared, or {@code 0} to leave in the\n     *            requested state until explicitly cleared, or the next reboot,\n     *            whichever happens first.\n     * @throws SecurityException if the caller doesn't meet the requirements\n     *            outlined above.\n     ",
    "links" : [ "android.net.NetworkCapabilities#NET_CAPABILITY_NOT_METERED", "android.telephony.CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "public void setSubscriptionOverrideCongested(int subId, boolean overrideCongested, @DurationMillisLong long expirationDurationMillis)",
    "returnType" : "void",
    "comment" : "\n     * Temporarily override the billing relationship plan between a carrier and\n     * a specific subscriber to be considered congested. This will cause the\n     * device to delay certain network requests when possible, such as developer\n     * jobs that are willing to run in a flexible time window.\n     * <p>\n     * This method is only accessible to the following narrow set of apps:\n     * <ul>\n     * <li>The carrier app for this subscriberId, as determined by\n     * {@link TelephonyManager#hasCarrierPrivileges()}.\n     * <li>The carrier app explicitly delegated access through\n     * {@link CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING}.\n     * </ul>\n     *\n     * @param subId the subscriber this override applies to.\n     * @param overrideCongested set if the subscription should be considered\n     *            congested.\n     * @param expirationDurationMillis the duration after which the requested override\n     *            will be automatically cleared, or {@code 0} to leave in the\n     *            requested state until explicitly cleared, or the next reboot,\n     *            whichever happens first.\n     * @throws SecurityException if the caller doesn't meet the requirements\n     *            outlined above.\n     ",
    "links" : [ "android.telephony.CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "public void setSubscriptionOverrideCongested(int subId, boolean overrideCongested, @NonNull @Annotation.NetworkType int[] networkTypes, @DurationMillisLong long expirationDurationMillis)",
    "returnType" : "void",
    "comment" : "\n     * Temporarily override the billing relationship plan between a carrier and\n     * a specific subscriber to be considered congested. This will cause the\n     * device to delay certain network requests when possible, such as developer\n     * jobs that are willing to run in a flexible time window.\n     * <p>\n     * This method is only accessible to the following narrow set of apps:\n     * <ul>\n     * <li>The carrier app for this subscriberId, as determined by\n     * {@link TelephonyManager#hasCarrierPrivileges()}.\n     * <li>The carrier app explicitly delegated access through\n     * {@link CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING}.\n     * </ul>\n     *\n     * @param subId the subscriber this override applies to.\n     * @param overrideCongested set if the subscription should be considered congested.\n     * @param networkTypes the network types this override applies to. If no network types are\n     * specified, override values will be ignored.\n     * @param expirationDurationMillis the duration after which the requested override\n     * will be automatically cleared, or {@code 0} to leave in the requested state until explicitly\n     * cleared, or the next reboot, whichever happens first.\n     *\n     * @throws SecurityException if the caller doesn't meet the requirements outlined above.\n     ",
    "links" : [ "android.telephony.CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "public boolean canManageSubscription(SubscriptionInfo info)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether the app with the given context is authorized to manage the given subscription\n     * according to its metadata.\n     *\n     * Only supported for embedded subscriptions (if {@link SubscriptionInfo#isEmbedded} returns\n     * true). To check for permissions for non-embedded subscription as well,\n     * see {@link android.telephony.TelephonyManager#hasCarrierPrivileges}.\n     *\n     * @param info The subscription to check.\n     * @return whether the app is authorized to manage this subscription per its metadata.\n     * @see android.telephony.TelephonyManager#hasCarrierPrivileges\n     ",
    "links" : [ "android.telephony.SubscriptionInfo#isEmbedded", "android.telephony.TelephonyManager#hasCarrierPrivileges" ]
  }, {
    "name" : "public boolean canManageSubscription(@NonNull SubscriptionInfo info, @NonNull String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether the given app is authorized to manage the given subscription. An app can only\n     * be authorized if it is included in the {@link android.telephony.UiccAccessRule} of the\n     * {@link android.telephony.SubscriptionInfo} with the access status.\n     *\n     * Only supported for embedded subscriptions (if {@link SubscriptionInfo#isEmbedded} returns\n     * true). To check for permissions for non-embedded subscription as well,\n     * see {@link android.telephony.TelephonyManager#hasCarrierPrivileges}.\n     *\n     * @param info The subscription to check.\n     * @param packageName Package name of the app to check.\n     *\n     * @return whether the app is authorized to manage this subscription per its access rules.\n     * @see android.telephony.TelephonyManager#hasCarrierPrivileges\n     * @hide\n     ",
    "links" : [ "android.telephony.UiccAccessRule", "android.telephony.SubscriptionInfo#isEmbedded", "android.telephony.TelephonyManager#hasCarrierPrivileges", "android.telephony.SubscriptionInfo" ]
  }, {
    "name" : "public void setPreferredDataSubscriptionId(int subId, boolean needValidation, @Nullable @CallbackExecutor Executor executor, @Nullable @TelephonyManager.SetOpportunisticSubscriptionResult Consumer<Integer> callback)",
    "returnType" : "void",
    "comment" : "\n     * Set which subscription is preferred for cellular data.\n     * It's also usually the subscription we set up internet connection on.\n     *\n     * PreferredData overwrites user setting of default data subscription. And it's used\n     * by AlternativeNetworkService or carrier apps to switch primary and CBRS\n     * subscription dynamically in multi-SIM devices.\n     *\n     * @param subId which subscription is preferred to for cellular data. If it's\n     *              {@link SubscriptionManager#DEFAULT_SUBSCRIPTION_ID}, it means\n     *              it's unset and {@link SubscriptionManager#getDefaultDataSubscriptionId()}\n     *              is used to determine which modem is preferred.\n     * @param needValidation whether Telephony will wait until the network is validated by\n     *              connectivity service before switching data to it. More details see\n     *              {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED}.\n     * @param executor The executor of where the callback will execute.\n     * @param callback Callback will be triggered once it succeeds or failed.\n     *                 Pass null if don't care about the result.\n     *\n     * @throws IllegalStateException when subscription manager service is not available.\n     * @throws SecurityException when clients do not have MODIFY_PHONE_STATE permission.\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "android.telephony.SubscriptionManager#DEFAULT_SUBSCRIPTION_ID", "android.telephony.SubscriptionManager#getDefaultDataSubscriptionId()", "android.net.NetworkCapabilities#NET_CAPABILITY_VALIDATED" ]
  }, {
    "name" : "public int getPreferredDataSubscriptionId()",
    "returnType" : "int",
    "comment" : "\n     * Get which subscription is preferred for cellular data.\n     * It's also usually the subscription we set up internet connection on.\n     *\n     * PreferredData overwrites user setting of default data subscription. And it's used\n     * by AlternativeNetworkService or carrier apps to switch primary and CBRS\n     * subscription dynamically in multi-SIM devices.\n     *\n     * @return preferred subscription id for cellular data. {@link DEFAULT_SUBSCRIPTION_ID} if\n     * there's no prefered subscription.\n     *\n     * @hide\n     *\n     ",
    "links" : [ "DEFAULT_SUBSCRIPTION_ID" ]
  }, {
    "name" : "public List<SubscriptionInfo> getOpportunisticSubscriptions()",
    "returnType" : "List<SubscriptionInfo>",
    "comment" : "\n     * Return opportunistic subscriptions that can be visible to the caller.\n     * Opportunistic subscriptions are for opportunistic networks, which are cellular\n     * networks with limited capabilities and coverage, for example, CBRS.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     * or that the calling app has carrier privileges (see\n     * {@link TelephonyManager#hasCarrierPrivileges}).\n     *\n     * @return the list of opportunistic subscription info. If none exists, an empty list.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "android.telephony.TelephonyManager#hasCarrierPrivileges", "android.Manifest.permission#READ_PHONE_STATE" ]
  }, {
    "name" : "public void switchToSubscription(int subId, @NonNull PendingIntent callbackIntent)",
    "returnType" : "void",
    "comment" : "\n     * Switch to a certain subscription\n     *\n     *  @param subId sub id\n     *  @param callbackIntent pending intent that will be sent after operation is done.\n     *\n     *  @deprecated this API is a duplicate of {@link EuiccManager#switchToSubscription(int,\n     *  PendingIntent)} and does not support Multiple Enabled Profile(MEP). Apps should use\n     *  {@link EuiccManager#switchToSubscription(int, PendingIntent)} or\n     *  {@link EuiccManager#switchToSubscription(int, int, PendingIntent)} instead.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_EUICC}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_EUICC", "android.telephony.euicc.EuiccManager#switchToSubscription(int" ]
  }, {
    "name" : "public boolean setOpportunistic(boolean opportunistic, int subId)",
    "returnType" : "boolean",
    "comment" : "\n     * Set whether a subscription is opportunistic, that is, whether the network it connects\n     * to has limited coverage. For example, CBRS. Setting a subscription opportunistic has\n     * following impacts:\n     *  1) Even if it's active, it will be dormant most of the time. The modem will not try\n     *     to scan or camp until it knows an available network is nearby to save power.\n     *  2) Telephony relies on system app or carrier input to notify nearby available networks.\n     *     See {@link TelephonyManager#updateAvailableNetworks(List, Executor, Consumer)}\n     *     for more information.\n     *  3) In multi-SIM devices, when the network is nearby and camped, system may automatically\n     *     switch internet data between it and default data subscription, based on carrier\n     *     recommendation and its signal strength and metered-ness, etc.\n     *\n     *\n     * Caller will either have {@link android.Manifest.permission#MODIFY_PHONE_STATE} or carrier\n     * privilege permission of the subscription.\n     *\n     * @param opportunistic whether it’s opportunistic subscription.\n     * @param subId the unique SubscriptionInfo index in database\n     * @return {@code true} if the operation is succeed, {@code false} otherwise.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.telephony.TelephonyManager#updateAvailableNetworks(List" ]
  }, {
    "name" : "public ParcelUuid createSubscriptionGroup(@NonNull List<Integer> subIdList)",
    "returnType" : "ParcelUuid",
    "comment" : "\n     * Inform SubscriptionManager that subscriptions in the list are bundled\n     * as a group. It can be multiple primary (non-opportunistic) subscriptions,\n     * or one or more primary plus one or more opportunistic subscriptions.\n     *\n     * This API will always create a new immutable group and assign group UUID to all the\n     * subscriptions, regardless whether they are in a group already or not.\n     *\n     * Grouped subscriptions will have below behaviors:\n     * 1) They will share the same user settings.\n     * 2) The opportunistic subscriptions in the group is considered invisible and will not\n     *    return from {@link #getActiveSubscriptionInfoList()}, unless caller has carrier\n     *    privilege permission of the subscriptions.\n     * 3) The opportunistic subscriptions in the group can't be active by itself. If all other\n     *    non-opportunistic ones are deactivated (unplugged or disabled in Settings),\n     *    the opportunistic ones will be deactivated automatically.\n     *\n     * Caller will either have {@link android.Manifest.permission#MODIFY_PHONE_STATE}\n     * permission or had carrier privilege permission on the subscriptions:\n     * {@link TelephonyManager#hasCarrierPrivileges()} or\n     * {@link #canManageSubscription(SubscriptionInfo)}\n     *\n     * @throws SecurityException if the caller doesn't meet the requirements\n     *             outlined above.\n     * @throws IllegalArgumentException if any of the subscriptions in the list doesn't exist.\n     * @throws IllegalStateException if Telephony service is in bad state.\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     *\n     * @param subIdList list of subId that will be in the same group\n     * @return groupUUID a UUID assigned to the subscription group.\n     *\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "#getActiveSubscriptionInfoList()", "#canManageSubscription(SubscriptionInfo)", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "public void addSubscriptionsIntoGroup(@NonNull List<Integer> subIdList, @NonNull ParcelUuid groupUuid)",
    "returnType" : "void",
    "comment" : "\n     * Add a list of subscriptions into a group.\n     * See {@link #createSubscriptionGroup(List)} for more details.\n     *\n     * Caller will either have {@link android.Manifest.permission#MODIFY_PHONE_STATE}\n     * permission or had carrier privilege permission on the subscriptions:\n     * {@link TelephonyManager#hasCarrierPrivileges()} or\n     * {@link #canManageSubscription(SubscriptionInfo)}\n     *\n     * @throws SecurityException if the caller doesn't meet the requirements\n     *             outlined above.\n     * @throws IllegalArgumentException if the some subscriptions in the list doesn't exist.\n     * @throws IllegalStateException if Telephony service is in bad state.\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     *\n     * @param subIdList list of subId that need adding into the group\n     * @param groupUuid the groupUuid the subscriptions are being added to.\n     *\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "#createSubscriptionGroup(List)", "#canManageSubscription(SubscriptionInfo)", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "private boolean isSystemProcess()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void removeSubscriptionsFromGroup(@NonNull List<Integer> subIdList, @NonNull ParcelUuid groupUuid)",
    "returnType" : "void",
    "comment" : "\n     * Remove a list of subscriptions from their subscription group.\n     *\n     * Caller will either have {@link android.Manifest.permission#MODIFY_PHONE_STATE}\n     * permission or has carrier privilege permission on all of the subscriptions provided in\n     * {@code subIdList}.\n     *\n     * @param subIdList list of subId that need removing from their groups.\n     * @param groupUuid The UUID of the subscription group.\n     *\n     * @throws SecurityException if the caller doesn't meet the requirements outlined above.\n     * @throws IllegalArgumentException if the some subscriptions in the list doesn't belong the\n     * specified group.\n     * @throws IllegalStateException if Telephony service is in bad state.\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     *\n     * @see #createSubscriptionGroup(List)\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public List<SubscriptionInfo> getSubscriptionsInGroup(@NonNull ParcelUuid groupUuid)",
    "returnType" : "List<SubscriptionInfo>",
    "comment" : "\n     * Get subscriptionInfo list of subscriptions that are in the same group of given subId.\n     *\n     * Caller must have {@link android.Manifest.permission#READ_PHONE_STATE}\n     * or carrier privilege permission on the subscription.\n     * {@link TelephonyManager#hasCarrierPrivileges()}\n     *\n     * <p>Starting with API level 33, the caller also needs permission to access device identifiers\n     * to get the list of subscriptions associated with a group UUID.\n     * This method can be invoked if one of the following requirements is met:\n     * <ul>\n     *     <li>If the app has carrier privilege permission.\n     *     {@link TelephonyManager#hasCarrierPrivileges()}\n     *     <li>If the app has {@link android.Manifest.permission#READ_PHONE_STATE} permission and\n     *     access to device identifiers.\n     * </ul>\n     *\n     * @throws IllegalStateException if Telephony service is in bad state.\n     * @throws SecurityException if the caller doesn't meet the requirements\n     *             outlined above.\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     *\n     * @param groupUuid of which list of subInfo will be returned.\n     * @return list of subscriptionInfo that belong to the same group, including the given\n     * subscription itself. It will return an empty list if no subscription belongs to the group.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "android.Manifest.permission#READ_PHONE_STATE", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "public boolean isSubscriptionVisible(SubscriptionInfo info)",
    "returnType" : "boolean",
    "comment" : "\n     * Whether a subscription is visible to API caller. If it's a bundled opportunistic\n     * subscription, it should be hidden anywhere in Settings, dialer, status bar etc.\n     * Exception is if caller owns carrier privilege, in which case they will\n     * want to see their own hidden subscriptions.\n     *\n     * @param info the subscriptionInfo to check against.\n     *\n     * @return {@code true} if this subscription should be visible to the API caller.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<SubscriptionInfo> getSelectableSubscriptionInfoList()",
    "returnType" : "List<SubscriptionInfo>",
    "comment" : "\n     * Return a list of subscriptions that are available and visible to the user.\n     * Used by Settings app to show a list of subscriptions for user to pick.\n     *\n     * <p>\n     * Permissions android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE is required\n     * for getSelectableSubscriptionInfoList to be invoked.\n     * @return list of user selectable subscriptions.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setSubscriptionEnabled(int subscriptionId, boolean enable)",
    "returnType" : "boolean",
    "comment" : "\n     * Enable or disable a subscription. This method is same as\n     * {@link #setUiccApplicationsEnabled(int, boolean)}.\n     *\n     * @param subscriptionId Subscription to be enabled or disabled.\n     * @param enable whether user is turning it on or off.\n     *\n     * @return whether the operation is successful.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "#setUiccApplicationsEnabled(int" ]
  }, {
    "name" : "public void setUiccApplicationsEnabled(int subscriptionId, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Set uicc applications being enabled or disabled.\n     * The value will be remembered on the subscription and will be applied whenever it's present.\n     * If the subscription in currently present, it will also apply the setting to modem\n     * immediately (the setting in the modem will not change until the modem receives and responds\n     * to the request, but typically this should only take a few seconds. The user visible setting\n     * available from SubscriptionInfo.areUiccApplicationsEnabled() will be updated\n     * immediately.)\n     *\n     * @param subscriptionId which subscription to operate on.\n     * @param enabled whether uicc applications are enabled or disabled.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION" ]
  }, {
    "name" : "public boolean canDisablePhysicalSubscription()",
    "returnType" : "boolean",
    "comment" : "\n     * Whether it's supported to disable / re-enable a subscription on a physical (non-euicc) SIM.\n     *\n     * Physical SIM refers non-euicc, or aka non-programmable SIM.\n     *\n     * It provides whether a physical SIM card can be disabled without taking it out, which is done\n     * via {@link #setSubscriptionEnabled(int, boolean)} API.\n     *\n     * @return whether can disable subscriptions on physical SIMs.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "#setSubscriptionEnabled(int" ]
  }, {
    "name" : "public boolean isSubscriptionEnabled(int subscriptionId)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the subscription is currently active in any slot.\n     *\n     * @param subscriptionId The subscription id.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION" ]
  }, {
    "name" : "public void setDeviceToDeviceStatusSharingPreference(int subscriptionId, @DeviceToDeviceStatusSharingPreference int sharing)",
    "returnType" : "void",
    "comment" : "\n     * Set the device to device status sharing user preference for a subscription id. The setting\n     * app uses this method to indicate with whom they wish to share device to device status\n     * information.\n     *\n     * @param subscriptionId The subscription id.\n     * @param sharing The status sharing preference.\n     *\n     * @throws SecurityException if the caller doesn't have permissions required.\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION" ]
  }, {
    "name" : "public int getDeviceToDeviceStatusSharingPreference(int subscriptionId)",
    "returnType" : "int",
    "comment" : "\n     * Returns the user-chosen device to device status sharing preference\n     * @param subscriptionId Subscription id of subscription\n     * @return The device to device status sharing preference\n     *\n     * @throws SecurityException if the caller doesn't have permissions required.\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION" ]
  }, {
    "name" : "public void setDeviceToDeviceStatusSharingContacts(int subscriptionId, @NonNull List<Uri> contacts)",
    "returnType" : "void",
    "comment" : "\n     * Set the list of contacts that allow device to device status sharing for a subscription id.\n     * The setting app uses this method to indicate with whom they wish to share device to device\n     * status information.\n     *\n     * @param subscriptionId The subscription id.\n     * @param contacts The list of contacts that allow device to device status sharing.\n     *\n     * @throws SecurityException if the caller doesn't have permissions required.\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION" ]
  }, {
    "name" : "public List<Uri> getDeviceToDeviceStatusSharingContacts(int subscriptionId)",
    "returnType" : "List<Uri>",
    "comment" : "\n     * Get the list of contacts that allow device to device status sharing.\n     *\n     * @param subscriptionId Subscription id.\n     *\n     * @return The list of contacts that allow device to device status sharing.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION" ]
  }, {
    "name" : "public int getEnabledSubscriptionId(int slotIndex)",
    "returnType" : "int",
    "comment" : "\n     * Get the active subscription id by logical SIM slot index.\n     *\n     * @param slotIndex The logical SIM slot index.\n     * @return The active subscription id.\n     *\n     * @throws IllegalArgumentException if the provided slot index is invalid.\n     * @throws SecurityException if callers do not hold the required permission.\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     *\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION" ]
  }, {
    "name" : "private int setSubscriptionPropertyHelper(int subId, String methodName, CallISubMethodHelper helper)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static int getActiveDataSubscriptionId()",
    "returnType" : "int",
    "comment" : "\n     * Get active data subscription id. Active data subscription refers to the subscription\n     * currently chosen to provide cellular internet connection to the user. This may be\n     * different from {@link #getDefaultDataSubscriptionId()}.\n     *\n     * @return Active data subscription id if any is chosen, or {@link #INVALID_SUBSCRIPTION_ID} if\n     * not.\n     *\n     * @see TelephonyCallback.ActiveDataSubscriptionIdListener\n     ",
    "links" : [ "#INVALID_SUBSCRIPTION_ID", "#getDefaultDataSubscriptionId()" ]
  }, {
    "name" : "public static void putSubscriptionIdExtra(Intent intent, int subId)",
    "returnType" : "void",
    "comment" : "\n     * Helper method that puts a subscription id on an intent with the constants:\n     * PhoneConstant.SUBSCRIPTION_KEY and SubscriptionManager.EXTRA_SUBSCRIPTION_INDEX.\n     * Both constants are used to support backwards compatibility.  Once we know we got all places,\n     * we can remove PhoneConstants.SUBSCRIPTION_KEY.\n     * @param intent Intent to put sub id on.\n     * @param subId SubscriptionId to put on intent.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void invalidateSubscriptionManagerServiceCaches()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void disableCaching()",
    "returnType" : "void",
    "comment" : "\n     * Allows a test process to disable client-side caching operations.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void clearCaches()",
    "returnType" : "void",
    "comment" : "\n     * Clears all process-local binder caches.\n     *\n     * @hide ",
    "links" : [ ]
  }, {
    "name" : "public byte[] getAllSimSpecificSettingsForBackup()",
    "returnType" : "byte[]",
    "comment" : "\n     * Called to retrieve SIM-specific settings data to be backed up.\n     *\n     * @return data in byte[] to be backed up.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void restoreAllSimSpecificSettingsFromBackup(@NonNull byte[] data)",
    "returnType" : "void",
    "comment" : "\n     * Called during setup wizard restore flow to attempt to restore the backed up sim-specific\n     * configs to device for all existing SIMs in the subscription database {@link SimInfo}.\n     * Internally, it will store the backup data in an internal file. This file will persist on\n     * device for device's lifetime and will be used later on when a SIM is inserted to restore that\n     * specific SIM's settings. End result is subscription database is modified to match any backed\n     * up configs for the appropriate inserted SIMs.\n     *\n     * <p>\n     * The {@link Uri} {@link #SIM_INFO_BACKUP_AND_RESTORE_CONTENT_URI} is notified if any\n     * {@link SimInfo} entry is updated as the result of this method call.\n     *\n     * @param data with the sim specific configs to be backed up.\n     *\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     * @hide\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "android.provider.Telephony.SimInfo", "android.net.Uri", "#SIM_INFO_BACKUP_AND_RESTORE_CONTENT_URI" ]
  }, {
    "name" : "public String getPhoneNumber(int subscriptionId, @PhoneNumberSource int source)",
    "returnType" : "String",
    "comment" : "\n     * Returns the phone number for the given {@code subscriptionId} and {@code source},\n     * or an empty string if not available.\n     *\n     * <p>General apps that need to know the phone number should use {@link #getPhoneNumber(int)}\n     * instead. This API may be suitable specific apps that needs to know the phone number from\n     * a specific source. For example, a carrier app needs to know exactly what's on\n     * {@link #PHONE_NUMBER_SOURCE_UICC UICC} and decide if the previously set phone number\n     * of source {@link #PHONE_NUMBER_SOURCE_CARRIER carrier} should be updated.\n     *\n     * <p>The API provides no guarantees of what format the number is in: the format can vary\n     * depending on the {@code source} and the network etc. Programmatic parsing should be done\n     * cautiously, for example, after formatting the number to a consistent format with\n     * {@link android.telephony.PhoneNumberUtils#formatNumberToE164(String, String)}.\n     *\n     * <p>Note the assumption is that one subscription (which usually means one SIM) has\n     * only one phone number. The multiple sources backup each other so hopefully at least one\n     * is available. For example, for a carrier that doesn't typically set phone numbers\n     * on {@link #PHONE_NUMBER_SOURCE_UICC UICC}, the source {@link #PHONE_NUMBER_SOURCE_IMS IMS}\n     * may provide one. Or, a carrier may decide to provide the phone number via source\n     * {@link #PHONE_NUMBER_SOURCE_CARRIER carrier} if neither source UICC nor IMS is available.\n     *\n     * <p>The availability and correctness of the phone number depends on the underlying source\n     * and the network etc. Additional verification is needed to use this number for\n     * security-related or other sensitive scenarios.\n     *\n     * @param subscriptionId the subscription ID, or {@link #DEFAULT_SUBSCRIPTION_ID}\n     * for the default one.\n     * @param source the source of the phone number, one of the PHONE_NUMBER_SOURCE_* constants.\n     *\n     * @return the phone number, or an empty string if not available.\n     *\n     * @throws IllegalArgumentException if {@code source} is invalid.\n     * @throws IllegalStateException if the telephony process is not currently available.\n     * @throws SecurityException if the caller doesn't have permissions required.\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     *\n     * @see #PHONE_NUMBER_SOURCE_UICC\n     * @see #PHONE_NUMBER_SOURCE_CARRIER\n     * @see #PHONE_NUMBER_SOURCE_IMS\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "#PHONE_NUMBER_SOURCE_UICC", "#DEFAULT_SUBSCRIPTION_ID", "android.telephony.PhoneNumberUtils#formatNumberToE164(String", "#PHONE_NUMBER_SOURCE_CARRIER", "#PHONE_NUMBER_SOURCE_IMS", "#getPhoneNumber(int)" ]
  }, {
    "name" : "public String getPhoneNumber(int subscriptionId)",
    "returnType" : "String",
    "comment" : "\n     * Returns the phone number for the given {@code subId}, or an empty string if\n     * not available.\n     *\n     * <p>This API is suitable for general apps that needs to know the phone number.\n     * For specific apps that needs to know the phone number provided by a specific source,\n     * {@link #getPhoneNumber(int, int)} may be suitable.\n     *\n     * <p>This API is built up on {@link #getPhoneNumber(int, int)}, but picks\n     * from available sources in the following order: {@link #PHONE_NUMBER_SOURCE_CARRIER}\n     * > {@link #PHONE_NUMBER_SOURCE_UICC} > {@link #PHONE_NUMBER_SOURCE_IMS}.\n     *\n     * <p>The API provides no guarantees of what format the number is in: the format can vary\n     * depending on the underlying source and the network etc. Programmatic parsing should be done\n     * cautiously, for example, after formatting the number to a consistent format with\n     * {@link android.telephony.PhoneNumberUtils#formatNumberToE164(String, String)}.\n     *\n     * <p>The availability and correctness of the phone number depends on the underlying source\n     * and the network etc. Additional verification is needed to use this number for\n     * security-related or other sensitive scenarios.\n     *\n     * @param subscriptionId the subscription ID, or {@link #DEFAULT_SUBSCRIPTION_ID}\n     *                       for the default one.\n     * @return the phone number, or an empty string if not available.\n     *\n     * @throws IllegalStateException if the telephony process is not currently available.\n     * @throws SecurityException if the caller doesn't have permissions required.\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     *\n     * @see #getPhoneNumber(int, int)\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "#PHONE_NUMBER_SOURCE_UICC", "#DEFAULT_SUBSCRIPTION_ID", "android.telephony.PhoneNumberUtils#formatNumberToE164(String", "#PHONE_NUMBER_SOURCE_CARRIER", "#getPhoneNumber(int", "#PHONE_NUMBER_SOURCE_IMS" ]
  }, {
    "name" : "public void setCarrierPhoneNumber(int subscriptionId, @NonNull String number)",
    "returnType" : "void",
    "comment" : "\n     * Sets the phone number for the given {@code subId} for source\n     * {@link #PHONE_NUMBER_SOURCE_CARRIER carrier}.\n     * Sets an empty string to remove the previously set phone number.\n     *\n     * <p>The API is suitable for carrier apps to provide a phone number, for example when\n     * it's not possible to update {@link #PHONE_NUMBER_SOURCE_UICC UICC} directly.\n     *\n     * <p>It's recommended that the phone number is formatted to well-known formats,\n     * for example, by {@link PhoneNumberUtils} {@code formatNumber*} methods.\n     *\n     * @param subscriptionId the subscription ID, or {@link #DEFAULT_SUBSCRIPTION_ID}\n     *                       for the default one.\n     * @param number the phone number, or an empty string to remove the previously set number.\n     * @throws IllegalStateException if the telephony process is not currently available.\n     * @throws NullPointerException if {@code number} is {@code null}.\n     * @throws SecurityException if the caller doesn't have permissions required.\n     * @throws UnsupportedOperationException If the device does not have\n     *          {@link PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION}.\n     ",
    "links" : [ "android.content.pm.PackageManager#FEATURE_TELEPHONY_SUBSCRIPTION", "#PHONE_NUMBER_SOURCE_UICC", "#DEFAULT_SUBSCRIPTION_ID", "android.telephony.PhoneNumberUtils", "#PHONE_NUMBER_SOURCE_CARRIER" ]
  }, {
    "name" : " void setUsageSetting(int subscriptionId, @UsageSetting int usageSetting)",
    "returnType" : "void",
    "comment" : "\n     * Set the preferred usage setting.\n     *\n     * The cellular usage setting is a switch which controls the mode of operation for the cellular\n     * radio to either require or not require voice service. It is not managed via Android’s\n     * Settings.\n     *\n     * @param subscriptionId the subId of the subscription.\n     * @param usageSetting the requested usage setting.\n     *\n     * @throws IllegalStateException if a specific mode or setting the mode is not supported on a\n     * particular device.\n     *\n     * <p>Requires {@link android.Manifest.permission#MODIFY_PHONE_STATE}\n     * or that the calling app has CarrierPrivileges for the given subscription.\n     *\n     * Note: This method will not allow the setting of USAGE_SETTING_UNKNOWN.\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#MODIFY_PHONE_STATE" ]
  }, {
    "name" : "public static String phoneNumberSourceToString(@PhoneNumberSource int source)",
    "returnType" : "String",
    "comment" : "\n     * Convert phone number source to string.\n     *\n     * @param source The phone name source.\n     *\n     * @return The phone name source in string format.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String displayNameSourceToString(@SubscriptionManager.SimDisplayNameSource int source)",
    "returnType" : "String",
    "comment" : "\n     * Convert display name source to string.\n     *\n     * @param source The display name source.\n     * @return The display name source in string format.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String subscriptionTypeToString(@SubscriptionManager.SubscriptionType int type)",
    "returnType" : "String",
    "comment" : "\n     * Convert subscription type to string.\n     *\n     * @param type The subscription type.\n     * @return The subscription type in string format.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String usageSettingToString(@SubscriptionManager.UsageSetting int usageSetting)",
    "returnType" : "String",
    "comment" : "\n     * Convert usage setting to string.\n     *\n     * @param usageSetting Usage setting.\n     * @return The usage setting in string format.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setGroupOwner(int subscriptionId, @NonNull String groupOwner)",
    "returnType" : "void",
    "comment" : "\n     * Set owner for this subscription.\n     *\n     * @param subscriptionId the subId of the subscription.\n     * @param groupOwner The group owner to assign to the subscription\n     *\n     * @throws SecurityException if caller is not authorized.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSubscriptionUserHandle(int subscriptionId, @Nullable UserHandle userHandle)",
    "returnType" : "void",
    "comment" : "\n     * Set userHandle for a subscription.\n     *\n     * Used to set an association between a subscription and a user on the device so that voice\n     * calling and SMS from that subscription can be associated with that user.\n     * Data services are always shared between users on the device.\n     *\n     * @param subscriptionId the subId of the subscription.\n     * @param userHandle the userHandle associated with the subscription.\n     * Pass {@code null} user handle to clear the association.\n     *\n     * @throws IllegalArgumentException if subscription is invalid.\n     * @throws SecurityException if the caller doesn't have permissions required.\n     * @throws IllegalStateException if subscription service is not available.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public UserHandle getSubscriptionUserHandle(int subscriptionId)",
    "returnType" : "UserHandle",
    "comment" : "\n     * Get UserHandle of this subscription.\n     *\n     * Used to get user handle associated with this subscription.\n     *\n     * @param subscriptionId the subId of the subscription.\n     * @return userHandle associated with this subscription\n     * or {@code null} if subscription is not associated with any user.\n     *\n     * @throws IllegalArgumentException if subscription is invalid.\n     * @throws SecurityException if the caller doesn't have permissions required.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isSubscriptionAssociatedWithUser(int subscriptionId, @NonNull UserHandle userHandle)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if subscription and user are associated with each other.\n     *\n     * @param subscriptionId the subId of the subscription\n     * @param userHandle user handle of the user\n     * @return {@code true} if subscription is associated with user\n     * else {@code false} if subscription is not associated with user.\n     *\n     * @throws IllegalArgumentException if subscription doesn't exist.\n     * @throws SecurityException if the caller doesn't have permissions required.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isSubscriptionAssociatedWithUser(int subscriptionId)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the given subscription is associated with the calling user.\n     *\n     * @param subscriptionId the subscription ID of the subscription\n     * @return {@code true} if the subscription is associated with the user that the current process\n     *         is running in; {@code false} otherwise.\n     *\n     * @throws IllegalArgumentException if subscription doesn't exist.\n     * @throws SecurityException if the caller doesn't have permissions required.\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<SubscriptionInfo> getSubscriptionInfoListAssociatedWithUser(@NonNull UserHandle userHandle)",
    "returnType" : "List<SubscriptionInfo>",
    "comment" : "\n     * Get list of subscriptions associated with user.\n     *\n     * @param userHandle user handle of the user\n     * @return list of subscriptionInfo associated with the user.\n     *\n     * @throws SecurityException if the caller doesn't have permissions required.\n     * @throws IllegalStateException if subscription service is not available.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getAllServiceCapabilityBitmasks()",
    "returnType" : "int",
    "comment" : "\n     * @return the bitmasks combination of all service capabilities.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Set<Integer> getServiceCapabilitiesSet(int combinedServiceCapabilities)",
    "returnType" : "Set<Integer>",
    "comment" : "\n     * @return The set of service capability from a bitmask combined one.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int serviceCapabilityToBitmask(@ServiceCapability int capability)",
    "returnType" : "int",
    "comment" : "\n     * @return The service capability bitmask from a {@link ServiceCapability} value.\n     * @hide\n     ",
    "links" : [ "ServiceCapability" ]
  }, {
    "name" : "public void setTransferStatus(int subscriptionId, @TransferStatus int status)",
    "returnType" : "void",
    "comment" : "\n     * Set the transfer status of the subscriptionInfo of the subId.\n     * @param subscriptionId The unique SubscriptionInfo key in database.\n     * @param status The transfer status to change.\n     *\n     *\n     * @hide\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "public static Uri getUriForSubscriptionId(int subscriptionId)", "private NetworkPolicyManager getNetworkPolicyManager()", "public static SubscriptionManager from(Context context)", "public void addOnSubscriptionsChangedListener(OnSubscriptionsChangedListener listener)", "public void addOnSubscriptionsChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnSubscriptionsChangedListener listener)", "public void removeOnSubscriptionsChangedListener(OnSubscriptionsChangedListener listener)", "public void addOnOpportunisticSubscriptionsChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnOpportunisticSubscriptionsChangedListener listener)", "public void removeOnOpportunisticSubscriptionsChangedListener(@NonNull OnOpportunisticSubscriptionsChangedListener listener)", "public SubscriptionInfo getActiveSubscriptionInfo(int subId)", "public SubscriptionInfo getActiveSubscriptionInfoForIcc(@NonNull String iccId)", "public SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int slotIndex)", "public List<SubscriptionInfo> getAllSubscriptionInfoList()", "public List<SubscriptionInfo> getActiveSubscriptionInfoList()", "public List<SubscriptionInfo> getCompleteActiveSubscriptionInfoList()", "public SubscriptionManager createForAllUserProfiles()", "public List<SubscriptionInfo> getActiveSubscriptionInfoList(boolean userVisibleOnly)", "public List<SubscriptionInfo> getAvailableSubscriptionInfoList()", "public List<SubscriptionInfo> getAccessibleSubscriptionInfoList()", "public void requestEmbeddedSubscriptionInfoListRefresh()", "public void requestEmbeddedSubscriptionInfoListRefresh(int cardId)", "public int getActiveSubscriptionInfoCount()", "public int getActiveSubscriptionInfoCountMax()", "public Uri addSubscriptionInfoRecord(String iccId, int slotIndex)", "public void addSubscriptionInfoRecord(@NonNull String uniqueId, @Nullable String displayName, int slotIndex, @SubscriptionType int subscriptionType)", "public void removeSubscriptionInfoRecord(@NonNull String uniqueId, @SubscriptionType int subscriptionType)", "public int setIconTint(@ColorInt int tint, int subId)", "public int setDisplayName(@Nullable String displayName, int subId, @SimDisplayNameSource int nameSource)", "public int setDisplayNumber(String number, int subId)", "public int setDataRoaming(int roaming, int subId)", "public static int getSlotIndex(int subscriptionId)", "public int[] getSubscriptionIds(int slotIndex)", "public static int[] getSubId(int slotIndex)", "public static int getSubscriptionId(int slotIndex)", "public static int getPhoneId(int subId)", "private static void logd(String msg)", "private static void loge(String msg)", "public static int getDefaultSubscriptionId()", "public static int getDefaultVoiceSubscriptionId()", "public void setDefaultVoiceSubscriptionId(int subscriptionId)", "public void setDefaultVoiceSubId(int subId)", "public SubscriptionInfo getDefaultVoiceSubscriptionInfo()", "public static int getDefaultVoicePhoneId()", "public static int getDefaultSmsSubscriptionId()", "public void setDefaultSmsSubId(int subscriptionId)", "public static int getDefaultDataSubscriptionId()", "public void setDefaultDataSubId(int subscriptionId)", "public SubscriptionInfo getDefaultDataSubscriptionInfo()", "public static boolean isValidSubscriptionId(int subscriptionId)", "public static boolean isUsableSubscriptionId(int subscriptionId)", "public static boolean isUsableSubIdValue(int subId)", "public static boolean isValidSlotIndex(int slotIndex)", "public static boolean isValidPhoneId(int phoneId)", "public static void putPhoneIdAndSubIdExtra(Intent intent, int phoneId)", "public static void putPhoneIdAndSubIdExtra(Intent intent, int phoneId, int subId)", "public int[] getActiveSubscriptionIdList()", "public int[] getCompleteActiveSubscriptionIdList()", "public int[] getActiveSubscriptionIdList(boolean visibleOnly)", "public boolean isNetworkRoaming(int subId)", "public static void setSubscriptionProperty(int subscriptionId, @NonNull String columnName, @NonNull String value)", "public static String serializeUriLists(List<Uri> uris)", "private static String getStringSubscriptionProperty(@NonNull Context context, int subscriptionId, @NonNull String columnName)", "public static boolean getBooleanSubscriptionProperty(int subscriptionId, @NonNull String columnName, boolean defaultValue, @NonNull Context context)", "public static int getIntegerSubscriptionProperty(int subscriptionId, @NonNull String columnName, int defaultValue, @NonNull Context context)", "public static long getLongSubscriptionProperty(int subscriptionId, @NonNull String columnName, long defaultValue, @NonNull Context context)", "public static Resources getResourcesForSubId(@NonNull Context context, int subId)", "public static Resources getResourcesForSubId(Context context, int subId, boolean useRootLocale)", "public boolean isActiveSubscriptionId(int subscriptionId)", "public boolean isActiveSubId(int subId)", "public List<SubscriptionPlan> getSubscriptionPlans(int subId)", "public void setSubscriptionPlans(int subId, @NonNull List<SubscriptionPlan> plans)", "public void setSubscriptionPlans(int subId, @NonNull List<SubscriptionPlan> plans, @DurationMillisLong long expirationDurationMillis)", "public void setSubscriptionOverrideUnmetered(int subId, boolean overrideUnmetered, @DurationMillisLong long expirationDurationMillis)", "public void setSubscriptionOverrideUnmetered(int subId, boolean overrideUnmetered, @NonNull @Annotation.NetworkType int[] networkTypes, @DurationMillisLong long expirationDurationMillis)", "public void setSubscriptionOverrideCongested(int subId, boolean overrideCongested, @DurationMillisLong long expirationDurationMillis)", "public void setSubscriptionOverrideCongested(int subId, boolean overrideCongested, @NonNull @Annotation.NetworkType int[] networkTypes, @DurationMillisLong long expirationDurationMillis)", "public boolean canManageSubscription(SubscriptionInfo info)", "public boolean canManageSubscription(@NonNull SubscriptionInfo info, @NonNull String packageName)", "public void setPreferredDataSubscriptionId(int subId, boolean needValidation, @Nullable @CallbackExecutor Executor executor, @Nullable @TelephonyManager.SetOpportunisticSubscriptionResult Consumer<Integer> callback)", "public int getPreferredDataSubscriptionId()", "public List<SubscriptionInfo> getOpportunisticSubscriptions()", "public void switchToSubscription(int subId, @NonNull PendingIntent callbackIntent)", "public boolean setOpportunistic(boolean opportunistic, int subId)", "public ParcelUuid createSubscriptionGroup(@NonNull List<Integer> subIdList)", "public void addSubscriptionsIntoGroup(@NonNull List<Integer> subIdList, @NonNull ParcelUuid groupUuid)", "private boolean isSystemProcess()", "public void removeSubscriptionsFromGroup(@NonNull List<Integer> subIdList, @NonNull ParcelUuid groupUuid)", "public List<SubscriptionInfo> getSubscriptionsInGroup(@NonNull ParcelUuid groupUuid)", "public boolean isSubscriptionVisible(SubscriptionInfo info)", "public List<SubscriptionInfo> getSelectableSubscriptionInfoList()", "public boolean setSubscriptionEnabled(int subscriptionId, boolean enable)", "public void setUiccApplicationsEnabled(int subscriptionId, boolean enabled)", "public boolean canDisablePhysicalSubscription()", "public boolean isSubscriptionEnabled(int subscriptionId)", "public void setDeviceToDeviceStatusSharingPreference(int subscriptionId, @DeviceToDeviceStatusSharingPreference int sharing)", "public int getDeviceToDeviceStatusSharingPreference(int subscriptionId)", "public void setDeviceToDeviceStatusSharingContacts(int subscriptionId, @NonNull List<Uri> contacts)", "public List<Uri> getDeviceToDeviceStatusSharingContacts(int subscriptionId)", "public int getEnabledSubscriptionId(int slotIndex)", "private int setSubscriptionPropertyHelper(int subId, String methodName, CallISubMethodHelper helper)", "public static int getActiveDataSubscriptionId()", "public static void putSubscriptionIdExtra(Intent intent, int subId)", "public static void invalidateSubscriptionManagerServiceCaches()", "public static void disableCaching()", "public static void clearCaches()", "public byte[] getAllSimSpecificSettingsForBackup()", "public void restoreAllSimSpecificSettingsFromBackup(@NonNull byte[] data)", "public String getPhoneNumber(int subscriptionId, @PhoneNumberSource int source)", "public String getPhoneNumber(int subscriptionId)", "public void setCarrierPhoneNumber(int subscriptionId, @NonNull String number)", " void setUsageSetting(int subscriptionId, @UsageSetting int usageSetting)", "public static String phoneNumberSourceToString(@PhoneNumberSource int source)", "public static String displayNameSourceToString(@SubscriptionManager.SimDisplayNameSource int source)", "public static String subscriptionTypeToString(@SubscriptionManager.SubscriptionType int type)", "public static String usageSettingToString(@SubscriptionManager.UsageSetting int usageSetting)", "public void setGroupOwner(int subscriptionId, @NonNull String groupOwner)", "public void setSubscriptionUserHandle(int subscriptionId, @Nullable UserHandle userHandle)", "public UserHandle getSubscriptionUserHandle(int subscriptionId)", "public boolean isSubscriptionAssociatedWithUser(int subscriptionId, @NonNull UserHandle userHandle)", "public boolean isSubscriptionAssociatedWithUser(int subscriptionId)", "public List<SubscriptionInfo> getSubscriptionInfoListAssociatedWithUser(@NonNull UserHandle userHandle)", "public static int getAllServiceCapabilityBitmasks()", "public static Set<Integer> getServiceCapabilitiesSet(int combinedServiceCapabilities)", "public static int serviceCapabilityToBitmask(@ServiceCapability int capability)", "public void setTransferStatus(int subscriptionId, @TransferStatus int status)" ],
  "variableNames" : [ "LOG_TAG", "DBG", "VDBG", "INVALID_SUBSCRIPTION_ID", "PLACEHOLDER_SUBSCRIPTION_ID_BASE", "INVALID_PHONE_INDEX", "INVALID_SIM_SLOT_INDEX", "DEFAULT_SUBSCRIPTION_ID", "DEFAULT_PHONE_INDEX", "DEFAULT_SIM_SLOT_INDEX", "MIN_SUBSCRIPTION_ID_VALUE", "MAX_SUBSCRIPTION_ID_VALUE", "CONTENT_URI", "CACHE_KEY_SUBSCRIPTION_MANAGER_SERVICE_PROPERTY", "GET_SIM_SPECIFIC_SETTINGS_METHOD_NAME", "RESTORE_SIM_SPECIFIC_SETTINGS_METHOD_NAME", "RESTORE_SIM_SPECIFIC_SETTINGS_DATABASE_UPDATED", "KEY_SIM_SPECIFIC_SETTINGS_DATA", "MAX_CACHE_SIZE", "sGetDefaultSubIdCacheAsUser", "sGetDefaultDataSubIdCache", "sGetDefaultSmsSubIdCacheAsUser", "sGetActiveDataSubscriptionIdCache", "sGetSlotIndexCache", "sGetSubIdCache", "sGetPhoneIdCache", "WFC_ENABLED_CONTENT_URI", "ADVANCED_CALLING_ENABLED_CONTENT_URI", "WFC_MODE_CONTENT_URI", "WFC_ROAMING_MODE_CONTENT_URI", "VT_ENABLED_CONTENT_URI", "WFC_ROAMING_ENABLED_CONTENT_URI", "SIM_INFO_BACKUP_AND_RESTORE_CONTENT_URI", "SIM_INFO_SUW_RESTORE_CONTENT_URI", "CROSS_SIM_ENABLED_CONTENT_URI", "UNIQUE_KEY_SUBSCRIPTION_ID", "ICC_ID", "SIM_SLOT_INDEX", "SIM_NOT_INSERTED", "SLOT_INDEX_FOR_REMOTE_SIM_SUB", "SUBSCRIPTION_TYPE", "TP_MESSAGE_REF", "ENABLED_MOBILE_DATA_POLICIES", "SUBSCRIPTION_TYPE_LOCAL_SIM", "SUBSCRIPTION_TYPE_REMOTE_SIM", "DISPLAY_NAME", "CARRIER_NAME", "DEFAULT_NAME_RES", "NAME_SOURCE", "NAME_SOURCE_UNKNOWN", "NAME_SOURCE_CARRIER_ID", "NAME_SOURCE_SIM_SPN", "NAME_SOURCE_USER_INPUT", "NAME_SOURCE_CARRIER", "NAME_SOURCE_SIM_PNN", "D2D_SHARING_DISABLED", "D2D_SHARING_ALL_CONTACTS", "D2D_SHARING_SELECTED_CONTACTS", "D2D_SHARING_ALL", "D2D_STATUS_SHARING", "D2D_STATUS_SHARING_SELECTED_CONTACTS", "HUE", "NUMBER", "DATA_ROAMING", "DATA_ROAMING_ENABLE", "DATA_ROAMING_DISABLE", "CARRIER_ID", "EHPLMNS", "HPLMNS", "MCC_STRING", "MNC_STRING", "MCC", "MNC", "ISO_COUNTRY_CODE", "IS_EMBEDDED", "CARD_ID", "ACCESS_RULES", "ACCESS_RULES_FROM_CARRIER_CONFIGS", "IS_REMOVABLE", "CB_EXTREME_THREAT_ALERT", "CB_SEVERE_THREAT_ALERT", "CB_AMBER_ALERT", "CB_EMERGENCY_ALERT", "CB_ALERT_SOUND_DURATION", "CB_ALERT_REMINDER_INTERVAL", "CB_ALERT_VIBRATE", "CB_ALERT_SPEECH", "CB_ETWS_TEST_ALERT", "CB_CHANNEL_50_ALERT", "CB_CMAS_TEST_ALERT", "CB_OPT_OUT_DIALOG", "ENHANCED_4G_MODE_ENABLED", "VT_IMS_ENABLED", "WFC_IMS_ENABLED", "WFC_IMS_MODE", "WFC_IMS_ROAMING_MODE", "WFC_IMS_ROAMING_ENABLED", "IMS_RCS_UCE_ENABLED", "CROSS_SIM_CALLING_ENABLED", "IS_OPPORTUNISTIC", "GROUP_UUID", "GROUP_OWNER", "PROFILE_CLASS", "PORT_INDEX", "VOIMS_OPT_IN_STATUS", "NR_ADVANCED_CALLING_ENABLED", "PROFILE_CLASS_TESTING", "PROFILE_CLASS_PROVISIONING", "PROFILE_CLASS_OPERATIONAL", "PROFILE_CLASS_UNSET", "PROFILE_CLASS_DEFAULT", "IMSI", "UICC_APPLICATIONS_ENABLED", "ALLOWED_NETWORK_TYPES", "USER_HANDLE", "SATELLITE_ENABLED", "SATELLITE_ATTACH_ENABLED_FOR_CARRIER", "IS_NTN", "SERVICE_CAPABILITIES", "TRANSFER_STATUS", "SATELLITE_ENTITLEMENT_STATUS", "SATELLITE_ENTITLEMENT_PLMNS", "USAGE_SETTING_UNKNOWN", "USAGE_SETTING_DEFAULT", "USAGE_SETTING_VOICE_CENTRIC", "USAGE_SETTING_DATA_CENTRIC", "USAGE_SETTING", "SUB_DEFAULT_CHANGED_ACTION", "ACTION_DEFAULT_SUBSCRIPTION_CHANGED", "ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED", "ACTION_MANAGE_SUBSCRIPTION_PLANS", "ACTION_REFRESH_SUBSCRIPTION_PLANS", "ACTION_SUBSCRIPTION_PLANS_CHANGED", "EXTRA_SUBSCRIPTION_INDEX", "EXTRA_SLOT_INDEX", "PHONE_NUMBER_SOURCE_UICC", "PHONE_NUMBER_SOURCE_CARRIER", "PHONE_NUMBER_SOURCE_IMS", "SERVICE_CAPABILITY_VOICE", "SERVICE_CAPABILITY_SMS", "SERVICE_CAPABILITY_DATA", "SERVICE_CAPABILITY_MAX", "SERVICE_CAPABILITY_VOICE_BITMASK", "SERVICE_CAPABILITY_SMS_BITMASK", "SERVICE_CAPABILITY_DATA_BITMASK", "mContext", "MAX_RESOURCE_CACHE_ENTRY_COUNT", "sResourcesCache", "TRANSFER_STATUS_NONE", "TRANSFER_STATUS_TRANSFERRED_OUT", "TRANSFER_STATUS_CONVERTED", "mIsForAllUserProfiles" ]
}