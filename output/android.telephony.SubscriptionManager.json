{
  "filePath" : "/home/maryam/clearblue/files/android-source-30/android/telephony/SubscriptionManager.java",
  "packageName" : "android.telephony",
  "className" : "SubscriptionManager",
  "comment" : "\n * SubscriptionManager is the application interface to SubscriptionController\n * and provides information about the current Telephony Subscriptions.\n ",
  "variables" : [ {
    "name" : "LOG_TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DBG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "VDBG",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "INVALID_SUBSCRIPTION_ID",
    "type" : "int",
    "comment" : " An invalid subscription identifier ",
    "links" : [ ]
  }, {
    "name" : "DUMMY_SUBSCRIPTION_ID_BASE",
    "type" : "int",
    "comment" : " FIXME: Remove DummySubId's, but for now have them map just below INVALID_SUBSCRIPTION_ID\n     /** @hide ",
    "links" : [ ]
  }, {
    "name" : "INVALID_PHONE_INDEX",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "INVALID_SIM_SLOT_INDEX",
    "type" : "int",
    "comment" : " Indicates invalid sim slot. This can be returned by {@link #getSlotIndex(int)}. ",
    "links" : [ "#getSlotIndex(int)" ]
  }, {
    "name" : "DEFAULT_SUBSCRIPTION_ID",
    "type" : "int",
    "comment" : " Indicates the default subscription ID in Telephony. ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_PHONE_INDEX",
    "type" : "int",
    "comment" : "\n     * Indicates the caller wants the default phone id.\n     * Used in SubscriptionController and Phone but do we really need it???\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_SIM_SLOT_INDEX",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MIN_SUBSCRIPTION_ID_VALUE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MAX_SUBSCRIPTION_ID_VALUE",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CONTENT_URI",
    "type" : "Uri",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CACHE_KEY_DEFAULT_SUB_ID_PROPERTY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CACHE_KEY_DEFAULT_DATA_SUB_ID_PROPERTY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CACHE_KEY_DEFAULT_SMS_SUB_ID_PROPERTY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CACHE_KEY_ACTIVE_DATA_SUB_ID_PROPERTY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CACHE_KEY_SLOT_INDEX_PROPERTY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "MAX_CACHE_SIZE",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sDefaultSubIdCache",
    "type" : "VoidPropertyInvalidatedCache<Integer>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sDefaultDataSubIdCache",
    "type" : "VoidPropertyInvalidatedCache<Integer>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sDefaultSmsSubIdCache",
    "type" : "VoidPropertyInvalidatedCache<Integer>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sActiveDataSubIdCache",
    "type" : "VoidPropertyInvalidatedCache<Integer>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sSlotIndexCache",
    "type" : "IntegerPropertyInvalidatedCache<Integer>",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sPhoneIdCache",
    "type" : "IntegerPropertyInvalidatedCache<Integer>",
    "comment" : " Cache depends on getDefaultSubId, so we use the defaultSubId cache key ",
    "links" : [ ]
  }, {
    "name" : "WFC_ENABLED_CONTENT_URI",
    "type" : "Uri",
    "comment" : "\n     * A content {@link Uri} used to receive updates on wfc enabled user setting.\n     * <p>\n     * Use this {@link Uri} with a {@link ContentObserver} to be notified of changes to the\n     * subscription wfc enabled {@link ImsMmTelManager#isVoWiFiSettingEnabled()}\n     * while your app is running. You can also use a {@link android.app.job.JobService}\n     * to ensure your app\n     * is notified of changes to the {@link Uri} even when it is not running.\n     * Note, however, that using a {@link android.app.job.JobService} does not guarantee timely\n     * delivery of updates to the {@link Uri}.\n     * To be notified of changes to a specific subId, append subId to the URI\n     * {@link Uri#withAppendedPath(Uri, String)}.\n     * @hide\n     ",
    "links" : [ "android.app.job.JobService", "android.net.Uri#withAppendedPath(Uri", "android.net.Uri", "android.telephony.ims.ImsMmTelManager#isVoWiFiSettingEnabled()", "android.database.ContentObserver" ]
  }, {
    "name" : "ADVANCED_CALLING_ENABLED_CONTENT_URI",
    "type" : "Uri",
    "comment" : "\n     * A content {@link Uri} used to receive updates on advanced calling user setting\n     * @see ImsMmTelManager#isAdvancedCallingSettingEnabled().\n     * <p>\n     * Use this {@link Uri} with a {@link ContentObserver} to be notified of changes to the\n     * subscription advanced calling enabled\n     * {@link ImsMmTelManager#isAdvancedCallingSettingEnabled()} while your app is running.\n     * You can also use a {@link android.app.job.JobService} to ensure your app is notified of\n     * changes to the {@link Uri} even when it is not running.\n     * Note, however, that using a {@link android.app.job.JobService} does not guarantee timely\n     * delivery of updates to the {@link Uri}.\n     * To be notified of changes to a specific subId, append subId to the URI\n     * {@link Uri#withAppendedPath(Uri, String)}.\n     * @hide\n     ",
    "links" : [ "android.app.job.JobService", "android.net.Uri#withAppendedPath(Uri", "android.net.Uri", "android.telephony.ims.ImsMmTelManager#isAdvancedCallingSettingEnabled()", "android.database.ContentObserver" ]
  }, {
    "name" : "WFC_MODE_CONTENT_URI",
    "type" : "Uri",
    "comment" : "\n     * A content {@link Uri} used to receive updates on wfc mode setting.\n     * <p>\n     * Use this {@link Uri} with a {@link ContentObserver} to be notified of changes to the\n     * subscription wfc mode {@link ImsMmTelManager#getVoWiFiModeSetting()}\n     * while your app is running. You can also use a {@link android.app.job.JobService} to ensure\n     * your app is notified of changes to the {@link Uri} even when it is not running.\n     * Note, however, that using a {@link android.app.job.JobService} does not guarantee timely\n     * delivery of updates to the {@link Uri}.\n     * To be notified of changes to a specific subId, append subId to the URI\n     * {@link Uri#withAppendedPath(Uri, String)}.\n     * @hide\n     ",
    "links" : [ "android.app.job.JobService", "android.telephony.ims.ImsMmTelManager#getVoWiFiModeSetting()", "android.net.Uri#withAppendedPath(Uri", "android.net.Uri", "android.database.ContentObserver" ]
  }, {
    "name" : "WFC_ROAMING_MODE_CONTENT_URI",
    "type" : "Uri",
    "comment" : "\n     * A content {@link Uri} used to receive updates on wfc roaming mode setting.\n     * <p>\n     * Use this {@link Uri} with a {@link ContentObserver} to be notified of changes to the\n     * subscription wfc roaming mode {@link ImsMmTelManager#getVoWiFiRoamingModeSetting()}\n     * while your app is running. You can also use a {@link android.app.job.JobService}\n     * to ensure your app is notified of changes to the {@link Uri} even when it is not running.\n     * Note, however, that using a {@link android.app.job.JobService} does not guarantee timely\n     * delivery of updates to the {@link Uri}.\n     * To be notified of changes to a specific subId, append subId to the URI\n     * {@link Uri#withAppendedPath(Uri, String)}.\n     * @hide\n     ",
    "links" : [ "android.app.job.JobService", "android.net.Uri#withAppendedPath(Uri", "android.net.Uri", "android.telephony.ims.ImsMmTelManager#getVoWiFiRoamingModeSetting()", "android.database.ContentObserver" ]
  }, {
    "name" : "VT_ENABLED_CONTENT_URI",
    "type" : "Uri",
    "comment" : "\n     * A content {@link Uri} used to receive updates on vt(video telephony over IMS) enabled\n     * setting.\n     * <p>\n     * Use this {@link Uri} with a {@link ContentObserver} to be notified of changes to the\n     * subscription vt enabled {@link ImsMmTelManager#isVtSettingEnabled()}\n     * while your app is running. You can also use a {@link android.app.job.JobService} to ensure\n     * your app is notified of changes to the {@link Uri} even when it is not running.\n     * Note, however, that using a {@link android.app.job.JobService} does not guarantee timely\n     * delivery of updates to the {@link Uri}.\n     * To be notified of changes to a specific subId, append subId to the URI\n     * {@link Uri#withAppendedPath(Uri, String)}.\n     * @hide\n     ",
    "links" : [ "android.app.job.JobService", "android.net.Uri#withAppendedPath(Uri", "android.net.Uri", "android.telephony.ims.ImsMmTelManager#isVtSettingEnabled()", "android.database.ContentObserver" ]
  }, {
    "name" : "WFC_ROAMING_ENABLED_CONTENT_URI",
    "type" : "Uri",
    "comment" : "\n     * A content {@link Uri} used to receive updates on wfc roaming enabled setting.\n     * <p>\n     * Use this {@link Uri} with a {@link ContentObserver} to be notified of changes to the\n     * subscription wfc roaming enabled {@link ImsMmTelManager#isVoWiFiRoamingSettingEnabled()}\n     * while your app is running. You can also use a {@link android.app.job.JobService} to ensure\n     * your app is notified of changes to the {@link Uri} even when it is not running.\n     * Note, however, that using a {@link android.app.job.JobService} does not guarantee timely\n     * delivery of updates to the {@link Uri}.\n     * To be notified of changes to a specific subId, append subId to the URI\n     * {@link Uri#withAppendedPath(Uri, String)}.\n     * @hide\n     ",
    "links" : [ "android.app.job.JobService", "android.net.Uri#withAppendedPath(Uri", "android.telephony.ims.ImsMmTelManager#isVoWiFiRoamingSettingEnabled()", "android.net.Uri", "android.database.ContentObserver" ]
  }, {
    "name" : "UNIQUE_KEY_SUBSCRIPTION_ID",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "ICC_ID",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SIM_SLOT_INDEX",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SIM_NOT_INSERTED",
    "type" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "SLOT_INDEX_FOR_REMOTE_SIM_SUB",
    "type" : "int",
    "comment" : "\n     * The slot-index for Bluetooth Remote-SIM subscriptions\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SUBSCRIPTION_TYPE",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DATA_ENABLED_OVERRIDE_RULES",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name data_enabled_override_rules.\n     * It's a list of rules for overriding data enabled settings. The syntax is\n     * For example, \"mms=nonDefault\" indicates enabling data for mms in non-default subscription.\n     * \"default=nonDefault&inVoiceCall\" indicates enabling data for internet in non-default\n     * subscription and while is in voice call.\n     *\n     * Default value is empty string.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SUBSCRIPTION_TYPE_LOCAL_SIM",
    "type" : "int",
    "comment" : "\n     * This constant is to designate a subscription as a Local-SIM Subscription.\n     * <p> A Local-SIM can be a physical SIM inserted into a sim-slot in the device, or eSIM on the\n     * device.\n     * </p>\n     ",
    "links" : [ ]
  }, {
    "name" : "SUBSCRIPTION_TYPE_REMOTE_SIM",
    "type" : "int",
    "comment" : "\n     * This constant is to designate a subscription as a Remote-SIM Subscription.\n     * <p>\n     * A Remote-SIM subscription is for a SIM on a phone connected to this device via some\n     * connectivity mechanism, for example bluetooth. Similar to Local SIM, this subscription can\n     * be used for SMS, Voice and data by proxying data through the connected device.\n     * Certain data of the SIM, such as IMEI, are not accessible for Remote SIMs.\n     * </p>\n     *\n     * <p>\n     * A Remote-SIM is available only as long the phone stays connected to this device.\n     * When the phone disconnects, Remote-SIM subscription is removed from this device and is\n     * no longer known. All data associated with the subscription, such as stored SMS, call logs,\n     * contacts etc, are removed from this device.\n     * </p>\n     *\n     * <p>\n     * If the phone re-connects to this device, a new Remote-SIM subscription is created for\n     * the phone. The Subscription Id associated with the new subscription is different from\n     * the Subscription Id of the previous Remote-SIM subscription created (and removed) for the\n     * phone; i.e., new Remote-SIM subscription treats the reconnected phone as a Remote-SIM that\n     * was never seen before.\n     * </p>\n     ",
    "links" : [ ]
  }, {
    "name" : "DISPLAY_NAME",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "CARRIER_NAME",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_NAME_RES",
    "type" : "int",
    "comment" : "\n     * Default name resource\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NAME_SOURCE",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for source of the user displayed name.\n     * <P>Type: INT (int)</P> with one of the NAME_SOURCE_XXXX values below\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NAME_SOURCE_CARRIER_ID",
    "type" : "int",
    "comment" : "\n     * The name_source is from the carrier id.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NAME_SOURCE_SIM_SPN",
    "type" : "int",
    "comment" : "\n     * The name_source is from SIM EF_SPN.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NAME_SOURCE_USER_INPUT",
    "type" : "int",
    "comment" : "\n     * The name_source is from user input\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NAME_SOURCE_CARRIER",
    "type" : "int",
    "comment" : "\n     * The name_source is carrier (carrier app, carrier config, etc.)\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "NAME_SOURCE_SIM_PNN",
    "type" : "int",
    "comment" : "\n     * The name_source is from SIM EF_PNN.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "HUE",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "NUMBER",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DATA_ROAMING",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "DATA_ROAMING_ENABLE",
    "type" : "int",
    "comment" : " Indicates that data roaming is enabled for a subscription ",
    "links" : [ ]
  }, {
    "name" : "DATA_ROAMING_DISABLE",
    "type" : "int",
    "comment" : " Indicates that data roaming is disabled for a subscription ",
    "links" : [ ]
  }, {
    "name" : "CARRIER_ID",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for subscription carrier id.\n     * @see TelephonyManager#getSimCarrierId()\n     * <p>Type: INTEGER (int) </p>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "EHPLMNS",
    "type" : "String",
    "comment" : "\n     * @hide A comma-separated list of EHPLMNs associated with the subscription\n     * <P>Type: TEXT (String)</P>\n     ",
    "links" : [ ]
  }, {
    "name" : "HPLMNS",
    "type" : "String",
    "comment" : "\n     * @hide A comma-separated list of HPLMNs associated with the subscription\n     * <P>Type: TEXT (String)</P>\n     ",
    "links" : [ ]
  }, {
    "name" : "MCC_STRING",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for the MCC associated with a SIM, stored as a string.\n     * <P>Type: TEXT (String)</P>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "MNC_STRING",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for the MNC associated with a SIM, stored as a string.\n     * <P>Type: TEXT (String)</P>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "MCC",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for the MCC associated with a SIM.\n     * <P>Type: INTEGER (int)</P>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "MNC",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for the MNC associated with a SIM.\n     * <P>Type: INTEGER (int)</P>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ISO_COUNTRY_CODE",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for the iso country code associated with a SIM.\n     * <P>Type: TEXT (String)</P>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "IS_EMBEDDED",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for whether a subscription is embedded (that is, present on an\n     * eSIM).\n     * <p>Type: INTEGER (int), 1 for embedded or 0 for non-embedded.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CARD_ID",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for SIM card identifier. For UICC card it is the ICCID of the\n     * current enabled profile on the card, while for eUICC card it is the EID of the card.\n     * <P>Type: TEXT (String)</P>\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACCESS_RULES",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for the encoded {@link UiccAccessRule}s from\n     * {@link UiccAccessRule#encodeRules}. Only present if {@link #IS_EMBEDDED} is 1.\n     * <p>TYPE: BLOB\n     * @hide\n     ",
    "links" : [ "android.telephony.UiccAccessRule", "android.telephony.UiccAccessRule#encodeRules", "#IS_EMBEDDED" ]
  }, {
    "name" : "ACCESS_RULES_FROM_CARRIER_CONFIGS",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for the encoded {@link UiccAccessRule}s from\n     * {@link UiccAccessRule#encodeRules} but for the rules that come from CarrierConfigs.\n     * Only present if there are access rules in CarrierConfigs\n     * <p>TYPE: BLOB\n     * @hide\n     ",
    "links" : [ "android.telephony.UiccAccessRule", "android.telephony.UiccAccessRule#encodeRules" ]
  }, {
    "name" : "IS_REMOVABLE",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name identifying whether an embedded subscription is on a removable\n     * card. Such subscriptions are marked inaccessible as soon as the current card is removed.\n     * Otherwise, they will remain accessible unless explicitly deleted. Only present if\n     * {@link #IS_EMBEDDED} is 1.\n     * <p>TYPE: INTEGER (int), 1 for removable or 0 for non-removable.\n     * @hide\n     ",
    "links" : [ "#IS_EMBEDDED" ]
  }, {
    "name" : "CB_EXTREME_THREAT_ALERT",
    "type" : "String",
    "comment" : "\n     *  TelephonyProvider column name for extreme threat in CB settings\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CB_SEVERE_THREAT_ALERT",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for severe threat in CB settings\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CB_AMBER_ALERT",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for amber alert in CB settings\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CB_EMERGENCY_ALERT",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for emergency alert in CB settings\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CB_ALERT_SOUND_DURATION",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for alert sound duration in CB settings\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CB_ALERT_REMINDER_INTERVAL",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for alert reminder interval in CB settings\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CB_ALERT_VIBRATE",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for enabling vibrate in CB settings\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CB_ALERT_SPEECH",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for enabling alert speech in CB settings\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CB_ETWS_TEST_ALERT",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for ETWS test alert in CB settings\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CB_CHANNEL_50_ALERT",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for enable channel50 alert in CB settings\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CB_CMAS_TEST_ALERT",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for CMAS test alert in CB settings\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "CB_OPT_OUT_DIALOG",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for Opt out dialog in CB settings\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ENHANCED_4G_MODE_ENABLED",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for enable Volte.\n     *\n     * If this setting is not initialized (set to -1)  then we use the Carrier Config value\n     * {@link CarrierConfigManager#KEY_ENHANCED_4G_LTE_ON_BY_DEFAULT_BOOL}.\n     *@hide\n     ",
    "links" : [ "android.telephony.CarrierConfigManager#KEY_ENHANCED_4G_LTE_ON_BY_DEFAULT_BOOL" ]
  }, {
    "name" : "VT_IMS_ENABLED",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for enable VT (Video Telephony over IMS)\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WFC_IMS_ENABLED",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for enable Wifi calling\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WFC_IMS_MODE",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for Wifi calling mode\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WFC_IMS_ROAMING_MODE",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for Wifi calling mode in roaming\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "WFC_IMS_ROAMING_ENABLED",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for enable Wifi calling in roaming\n     *@hide\n     ",
    "links" : [ ]
  }, {
    "name" : "IMS_RCS_UCE_ENABLED",
    "type" : "String",
    "comment" : "\n     * Determines if the user has enabled IMS RCS User Capability Exchange (UCE) for this\n     * subscription.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "IS_OPPORTUNISTIC",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for whether a subscription is opportunistic, that is,\n     * whether the network it connects to is limited in functionality or coverage.\n     * For example, CBRS.\n     * <p>Type: INTEGER (int), 1 for opportunistic or 0 for non-opportunistic.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "GROUP_UUID",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for group ID. Subscriptions with same group ID\n     * are considered bundled together, and should behave as a single subscription at\n     * certain scenarios.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "GROUP_OWNER",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for group owner. It's the package name who created\n     * the subscription group.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PROFILE_CLASS",
    "type" : "String",
    "comment" : "\n     * TelephonyProvider column name for the profile class of a subscription\n     * Only present if {@link #IS_EMBEDDED} is 1.\n     * <P>Type: INTEGER (int)</P>\n     * @hide\n     ",
    "links" : [ "#IS_EMBEDDED" ]
  }, {
    "name" : "PROFILE_CLASS_TESTING",
    "type" : "int",
    "comment" : "\n     * A testing profile can be pre-loaded or downloaded onto\n     * the eUICC and provides connectivity to test equipment\n     * for the purpose of testing the device and the eUICC. It\n     * is not intended to store any operator credentials.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PROFILE_CLASS_PROVISIONING",
    "type" : "int",
    "comment" : "\n     * A provisioning profile is pre-loaded onto the eUICC and\n     * provides connectivity to a mobile network solely for the\n     * purpose of provisioning profiles.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PROFILE_CLASS_OPERATIONAL",
    "type" : "int",
    "comment" : "\n     * An operational profile can be pre-loaded or downloaded\n     * onto the eUICC and provides services provided by the\n     * operator.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PROFILE_CLASS_UNSET",
    "type" : "int",
    "comment" : "\n     * The profile class is unset. This occurs when profile class\n     * info is not available. The subscription either has no profile\n     * metadata or the profile metadata did not encode profile class.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "PROFILE_CLASS_DEFAULT",
    "type" : "int",
    "comment" : "\n     * Default profile class\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "IMSI",
    "type" : "String",
    "comment" : "TODO: add @SystemApi",
    "links" : [ ]
  }, {
    "name" : "UICC_APPLICATIONS_ENABLED",
    "type" : "String",
    "comment" : "\n     * Whether uicc applications is set to be enabled or disabled. By default it's enabled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ALLOWED_NETWORK_TYPES",
    "type" : "String",
    "comment" : "\n     * Indicate which network type is allowed. By default it's enabled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "SUB_DEFAULT_CHANGED_ACTION",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: The user has changed one of the default subs related to\n     * data, phone calls, or sms</p>\n     *\n     * TODO: Change to a listener\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "ACTION_DEFAULT_SUBSCRIPTION_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: The default subscription has changed.  This has the following\n     * extra values:</p>\n     * The {@link #EXTRA_SUBSCRIPTION_INDEX} extra indicates the current default subscription index\n     ",
    "links" : [ "#EXTRA_SUBSCRIPTION_INDEX" ]
  }, {
    "name" : "ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: The default sms subscription has changed.  This has the following\n     * extra values:</p>\n     * {@link #EXTRA_SUBSCRIPTION_INDEX} extra indicates the current default sms\n     * subscription index\n     ",
    "links" : [ "#EXTRA_SUBSCRIPTION_INDEX" ]
  }, {
    "name" : "ACTION_MANAGE_SUBSCRIPTION_PLANS",
    "type" : "String",
    "comment" : "\n     * Activity Action: Display UI for managing the billing relationship plans\n     * between a carrier and a specific subscriber.\n     * <p>\n     * Carrier apps are encouraged to implement this activity, and the OS will\n     * provide an affordance to quickly enter this activity, typically via\n     * Settings. This affordance will only be shown when the carrier app is\n     * actively providing subscription plan information via\n     * {@link #setSubscriptionPlans(int, List)}.\n     * <p>\n     * Contains {@link #EXTRA_SUBSCRIPTION_INDEX} to indicate which subscription\n     * the user is interested in.\n     ",
    "links" : [ "#setSubscriptionPlans(int", "#EXTRA_SUBSCRIPTION_INDEX" ]
  }, {
    "name" : "ACTION_REFRESH_SUBSCRIPTION_PLANS",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: Request a refresh of the billing relationship plans\n     * between a carrier and a specific subscriber.\n     * <p>\n     * Carrier apps are encouraged to implement this receiver, and the OS will\n     * provide an affordance to request a refresh. This affordance will only be\n     * shown when the carrier app is actively providing subscription plan\n     * information via {@link #setSubscriptionPlans(int, List)}.\n     * <p>\n     * Contains {@link #EXTRA_SUBSCRIPTION_INDEX} to indicate which subscription\n     * the user is interested in.\n     * <p>\n     * Receivers should protect themselves by checking that the sender holds the\n     * {@code android.permission.MANAGE_SUBSCRIPTION_PLANS} permission.\n     ",
    "links" : [ "#setSubscriptionPlans(int", "#EXTRA_SUBSCRIPTION_INDEX" ]
  }, {
    "name" : "ACTION_SUBSCRIPTION_PLANS_CHANGED",
    "type" : "String",
    "comment" : "\n     * Broadcast Action: The billing relationship plans between a carrier and a\n     * specific subscriber has changed.\n     * <p>\n     * Contains {@link #EXTRA_SUBSCRIPTION_INDEX} to indicate which subscription\n     * changed.\n     * @hide\n     ",
    "links" : [ "#EXTRA_SUBSCRIPTION_INDEX" ]
  }, {
    "name" : "EXTRA_SUBSCRIPTION_INDEX",
    "type" : "String",
    "comment" : "\n     * Integer extra used with {@link #ACTION_DEFAULT_SUBSCRIPTION_CHANGED} and\n     * {@link #ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED} to indicate the subscription\n     * which has changed.\n     ",
    "links" : [ "#ACTION_DEFAULT_SUBSCRIPTION_CHANGED", "#ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED" ]
  }, {
    "name" : "EXTRA_SLOT_INDEX",
    "type" : "String",
    "comment" : "\n     * Integer extra to specify SIM slot index.\n     ",
    "links" : [ ]
  }, {
    "name" : "mContext",
    "type" : "Context",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "sResourcesCache",
    "type" : "Map<Pair<Context, Integer>, Resources>",
    "comment" : " the Context and subId.",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public static Uri getUriForSubscriptionId(int subscriptionId)",
    "returnType" : "Uri",
    "comment" : "\n     * Generates a content {@link Uri} used to receive updates on simInfo change\n     * on the given subscriptionId\n     * @param subscriptionId the subscriptionId to receive updates on\n     * @return the Uri used to observe carrier identity changes\n     * @hide\n     ",
    "links" : [ "android.net.Uri" ]
  }, {
    "name" : "private NetworkPolicyManager getNetworkPolicyManager()",
    "returnType" : "NetworkPolicyManager",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static SubscriptionManager from(Context context)",
    "returnType" : "SubscriptionManager",
    "comment" : "\n     * @deprecated developers should always obtain references directly from\n     *             {@link Context#getSystemService(Class)}.\n     ",
    "links" : [ "android.content.Context#getSystemService(Class)" ]
  }, {
    "name" : "public void addOnSubscriptionsChangedListener(OnSubscriptionsChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register for changes to the list of active {@link SubscriptionInfo} records or to the\n     * individual records themselves. When a change occurs the onSubscriptionsChanged method of\n     * the listener will be invoked immediately if there has been a notification. The\n     * onSubscriptionChanged method will also be triggered once initially when calling this\n     * function.\n     *\n     * @param listener an instance of {@link OnSubscriptionsChangedListener} with\n     *                 onSubscriptionsChanged overridden.\n     ",
    "links" : [ "OnSubscriptionsChangedListener", "android.telephony.SubscriptionInfo" ]
  }, {
    "name" : "public void addOnSubscriptionsChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnSubscriptionsChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register for changes to the list of active {@link SubscriptionInfo} records or to the\n     * individual records themselves. When a change occurs the onSubscriptionsChanged method of\n     * the listener will be invoked immediately if there has been a notification. The\n     * onSubscriptionChanged method will also be triggered once initially when calling this\n     * function.\n     *\n     * @param listener an instance of {@link OnSubscriptionsChangedListener} with\n     *                 onSubscriptionsChanged overridden.\n     * @param executor the executor that will execute callbacks.\n     ",
    "links" : [ "OnSubscriptionsChangedListener", "android.telephony.SubscriptionInfo" ]
  }, {
    "name" : "public void removeOnSubscriptionsChangedListener(OnSubscriptionsChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Unregister the {@link OnSubscriptionsChangedListener}. This is not strictly necessary\n     * as the listener will automatically be unregistered if an attempt to invoke the listener\n     * fails.\n     *\n     * @param listener that is to be unregistered.\n     ",
    "links" : [ "OnSubscriptionsChangedListener" ]
  }, {
    "name" : "public void addOnOpportunisticSubscriptionsChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnOpportunisticSubscriptionsChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Register for changes to the list of opportunistic subscription records or to the\n     * individual records themselves. When a change occurs the onOpportunisticSubscriptionsChanged\n     * method of the listener will be invoked immediately if there has been a notification.\n     *\n     * @param listener an instance of {@link OnOpportunisticSubscriptionsChangedListener} with\n     *                 onOpportunisticSubscriptionsChanged overridden.\n     ",
    "links" : [ "OnOpportunisticSubscriptionsChangedListener" ]
  }, {
    "name" : "public void removeOnOpportunisticSubscriptionsChangedListener(@NonNull OnOpportunisticSubscriptionsChangedListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Unregister the {@link OnOpportunisticSubscriptionsChangedListener} that is currently\n     * listening opportunistic subscriptions change. This is not strictly necessary\n     * as the listener will automatically be unregistered if an attempt to invoke the listener\n     * fails.\n     *\n     * @param listener that is to be unregistered.\n     ",
    "links" : [ "OnOpportunisticSubscriptionsChangedListener" ]
  }, {
    "name" : "public SubscriptionInfo getActiveSubscriptionInfo(int subId)",
    "returnType" : "SubscriptionInfo",
    "comment" : "\n     * Get the active SubscriptionInfo with the input subId.\n     *\n     * <p>Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     * or that the calling app has carrier privileges (see\n     * {@link TelephonyManager#hasCarrierPrivileges}).\n     *\n     * @param subId The unique SubscriptionInfo key in database.\n     * @return SubscriptionInfo, maybe null if its not active.\n     ",
    "links" : [ "android.telephony.TelephonyManager#hasCarrierPrivileges", "android.Manifest.permission#READ_PHONE_STATE" ]
  }, {
    "name" : "public SubscriptionInfo getActiveSubscriptionInfoForIcc(@NonNull String iccId)",
    "returnType" : "SubscriptionInfo",
    "comment" : "\n     * Gets an active SubscriptionInfo {@link SubscriptionInfo} associated with the Sim IccId.\n     *\n     * @param iccId the IccId of SIM card\n     * @return SubscriptionInfo, maybe null if its not active\n     *\n     * @hide\n     ",
    "links" : [ "android.telephony.SubscriptionInfo" ]
  }, {
    "name" : "public SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int slotIndex)",
    "returnType" : "SubscriptionInfo",
    "comment" : "\n     * Get the active SubscriptionInfo associated with the slotIndex\n     *\n     * <p>Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     * or that the calling app has carrier privileges (see\n     * {@link TelephonyManager#hasCarrierPrivileges}).\n     *\n     * @param slotIndex the slot which the subscription is inserted\n     * @return SubscriptionInfo, maybe null if its not active\n     ",
    "links" : [ "android.telephony.TelephonyManager#hasCarrierPrivileges", "android.Manifest.permission#READ_PHONE_STATE" ]
  }, {
    "name" : "public List<SubscriptionInfo> getAllSubscriptionInfoList()",
    "returnType" : "List<SubscriptionInfo>",
    "comment" : "\n     * @return List of all SubscriptionInfo records in database,\n     * include those that were inserted before, maybe empty but not null.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<SubscriptionInfo> getActiveSubscriptionInfoList()",
    "returnType" : "List<SubscriptionInfo>",
    "comment" : "\n     * Get the SubscriptionInfo(s) of the currently active SIM(s). The records will be sorted\n     * by {@link SubscriptionInfo#getSimSlotIndex} then by {@link SubscriptionInfo#getSubscriptionId}.\n     *\n     * <p>Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     * or that the calling app has carrier privileges (see\n     * {@link TelephonyManager#hasCarrierPrivileges}). In the latter case, only records accessible\n     * to the calling app are returned.\n     *\n     * @return Sorted list of the currently {@link SubscriptionInfo} records available on the device.\n     * <ul>\n     * <li>\n     * If null is returned the current state is unknown but if a {@link OnSubscriptionsChangedListener}\n     * has been registered {@link OnSubscriptionsChangedListener#onSubscriptionsChanged} will be\n     * invoked in the future.\n     * </li>\n     * <li>\n     * If the list is empty then there are no {@link SubscriptionInfo} records currently available.\n     * </li>\n     * <li>\n     * if the list is non-empty the list is sorted by {@link SubscriptionInfo#getSimSlotIndex}\n     * then by {@link SubscriptionInfo#getSubscriptionId}.\n     * </li>\n     * </ul>\n     ",
    "links" : [ "android.telephony.SubscriptionInfo#getSubscriptionId", "OnSubscriptionsChangedListener", "android.telephony.TelephonyManager#hasCarrierPrivileges", "android.telephony.SubscriptionInfo#getSimSlotIndex", "#onSubscriptionsChanged", "android.Manifest.permission#READ_PHONE_STATE", "android.telephony.SubscriptionInfo" ]
  }, {
    "name" : "public List<SubscriptionInfo> getCompleteActiveSubscriptionInfoList()",
    "returnType" : "List<SubscriptionInfo>",
    "comment" : "\n     * Get both hidden and visible SubscriptionInfo(s) of the currently active SIM(s).\n     * The records will be sorted by {@link SubscriptionInfo#getSimSlotIndex}\n     * then by {@link SubscriptionInfo#getSubscriptionId}.\n     *\n     * Hidden subscriptions refer to those are not meant visible to the users.\n     * For example, an opportunistic subscription that is grouped with other\n     * subscriptions should remain invisible to users as they are only functionally\n     * supplementary to primary ones.\n     *\n     * <p>Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     * or that the calling app has carrier privileges (see\n     * {@link TelephonyManager#hasCarrierPrivileges}). In the latter case, only records accessible\n     * to the calling app are returned.\n     *\n     * @return Sorted list of the currently available {@link SubscriptionInfo}\n     * records on the device.\n     * This is similar to {@link #getActiveSubscriptionInfoList} except that it will return\n     * both active and hidden SubscriptionInfos.\n     *\n     ",
    "links" : [ "android.telephony.SubscriptionInfo#getSubscriptionId", "android.telephony.TelephonyManager#hasCarrierPrivileges", "android.telephony.SubscriptionInfo#getSimSlotIndex", "#getActiveSubscriptionInfoList", "android.Manifest.permission#READ_PHONE_STATE", "android.telephony.SubscriptionInfo" ]
  }, {
    "name" : "public List<SubscriptionInfo> getActiveSubscriptionInfoList(boolean userVisibleOnly)",
    "returnType" : "List<SubscriptionInfo>",
    "comment" : "\n    * This is similar to {@link #getActiveSubscriptionInfoList()}, but if userVisibleOnly\n    * is true, it will filter out the hidden subscriptions.\n    *\n    * @hide\n    ",
    "links" : [ "#getActiveSubscriptionInfoList()" ]
  }, {
    "name" : "public List<SubscriptionInfo> getAvailableSubscriptionInfoList()",
    "returnType" : "List<SubscriptionInfo>",
    "comment" : "\n     * Gets the SubscriptionInfo(s) of all available subscriptions, if any.\n     *\n     * <p>Available subscriptions include active ones (those with a non-negative\n     * {@link SubscriptionInfo#getSimSlotIndex()}) as well as inactive but installed embedded\n     * subscriptions.\n     *\n     * <p>The records will be sorted by {@link SubscriptionInfo#getSimSlotIndex} then by\n     * {@link SubscriptionInfo#getSubscriptionId}.\n     *\n     * @return Sorted list of the current {@link SubscriptionInfo} records available on the\n     * device.\n     * <ul>\n     * <li>\n     * If null is returned the current state is unknown but if a\n     * {@link OnSubscriptionsChangedListener} has been registered\n     * {@link OnSubscriptionsChangedListener#onSubscriptionsChanged} will be invoked in the future.\n     * <li>\n     * If the list is empty then there are no {@link SubscriptionInfo} records currently available.\n     * <li>\n     * if the list is non-empty the list is sorted by {@link SubscriptionInfo#getSimSlotIndex}\n     * then by {@link SubscriptionInfo#getSubscriptionId}.\n     * </ul>\n     *\n     * <p>\n     * Permissions android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE is required\n     * for #getAvailableSubscriptionInfoList to be invoked.\n     * @hide\n     ",
    "links" : [ "android.telephony.SubscriptionInfo#getSubscriptionId", "OnSubscriptionsChangedListener", "android.telephony.SubscriptionInfo#getSimSlotIndex", "#onSubscriptionsChanged", "android.telephony.SubscriptionInfo", "android.telephony.SubscriptionInfo#getSimSlotIndex()" ]
  }, {
    "name" : "public List<SubscriptionInfo> getAccessibleSubscriptionInfoList()",
    "returnType" : "List<SubscriptionInfo>",
    "comment" : "\n     * Gets the SubscriptionInfo(s) of all embedded subscriptions accessible to the calling app, if\n     * any.\n     *\n     * <p>Only those subscriptions for which the calling app has carrier privileges per the\n     * subscription metadata, if any, will be included in the returned list.\n     *\n     * <p>The records will be sorted by {@link SubscriptionInfo#getSimSlotIndex} then by\n     * {@link SubscriptionInfo#getSubscriptionId}.\n     *\n     * @return Sorted list of the current embedded {@link SubscriptionInfo} records available on the\n     * device which are accessible to the caller.\n     * <ul>\n     * <li>\n     * If null is returned the current state is unknown but if a\n     * {@link OnSubscriptionsChangedListener} has been registered\n     * {@link OnSubscriptionsChangedListener#onSubscriptionsChanged} will be invoked in the future.\n     * <li>\n     * If the list is empty then there are no {@link SubscriptionInfo} records currently available.\n     * <li>\n     * if the list is non-empty the list is sorted by {@link SubscriptionInfo#getSimSlotIndex}\n     * then by {@link SubscriptionInfo#getSubscriptionId}.\n     * </ul>\n     ",
    "links" : [ "android.telephony.SubscriptionInfo#getSubscriptionId", "OnSubscriptionsChangedListener", "android.telephony.SubscriptionInfo#getSimSlotIndex", "#onSubscriptionsChanged", "android.telephony.SubscriptionInfo" ]
  }, {
    "name" : "public void requestEmbeddedSubscriptionInfoListRefresh()",
    "returnType" : "void",
    "comment" : "\n     * Request a refresh of the platform cache of profile information for the eUICC which\n     * corresponds to the card ID returned by {@link TelephonyManager#getCardIdForDefaultEuicc()}.\n     *\n     * <p>Should be called by the EuiccService implementation whenever this information changes due\n     * to an operation done outside the scope of a request initiated by the platform to the\n     * EuiccService. There is no need to refresh for downloads, deletes, or other operations that\n     * were made through the EuiccService.\n     *\n     * <p>Requires the {@link android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission.\n     *\n     * @see {@link TelephonyManager#getCardIdForDefaultEuicc()} for more information on the card ID.\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS", "android.telephony.TelephonyManager#getCardIdForDefaultEuicc()" ]
  }, {
    "name" : "public void requestEmbeddedSubscriptionInfoListRefresh(int cardId)",
    "returnType" : "void",
    "comment" : "\n     * Request a refresh of the platform cache of profile information for the eUICC with the given\n     * {@code cardId}.\n     *\n     * <p>Should be called by the EuiccService implementation whenever this information changes due\n     * to an operation done outside the scope of a request initiated by the platform to the\n     * EuiccService. There is no need to refresh for downloads, deletes, or other operations that\n     * were made through the EuiccService.\n     *\n     * <p>Requires the {@link android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission.\n     *\n     * @param cardId the card ID of the eUICC.\n     *\n     * @see {@link TelephonyManager#getCardIdForDefaultEuicc()} for more information on the card ID.\n     *\n     * @hide\n     ",
    "links" : [ "android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS", "android.telephony.TelephonyManager#getCardIdForDefaultEuicc()" ]
  }, {
    "name" : "public int getAllSubscriptionInfoCount()",
    "returnType" : "int",
    "comment" : "\n     * @return the count of all subscriptions in the database, this includes\n     * all subscriptions that have been seen.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getActiveSubscriptionInfoCount()",
    "returnType" : "int",
    "comment" : "\n     *\n     * Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     * or that the calling app has carrier privileges (see\n     * {@link TelephonyManager#hasCarrierPrivileges}). In the latter case, the count will include\n     * only those subscriptions accessible to the caller.\n     *\n     * @return the current number of active subscriptions. There is no guarantee the value\n     * returned by this method will be the same as the length of the list returned by\n     * {@link #getActiveSubscriptionInfoList}.\n     ",
    "links" : [ "android.telephony.TelephonyManager#hasCarrierPrivileges", "#getActiveSubscriptionInfoList", "android.Manifest.permission#READ_PHONE_STATE" ]
  }, {
    "name" : "public int getActiveSubscriptionInfoCountMax()",
    "returnType" : "int",
    "comment" : "\n     * @return the maximum number of active subscriptions that will be returned by\n     * {@link #getActiveSubscriptionInfoList} and the value returned by\n     * {@link #getActiveSubscriptionInfoCount}.\n     ",
    "links" : [ "#getActiveSubscriptionInfoCount", "#getActiveSubscriptionInfoList" ]
  }, {
    "name" : "public Uri addSubscriptionInfoRecord(String iccId, int slotIndex)",
    "returnType" : "Uri",
    "comment" : "\n     * Add a new SubscriptionInfo to SubscriptionInfo database if needed\n     * @param iccId the IccId of the SIM card\n     * @param slotIndex the slot which the SIM is inserted\n     * @return the URL of the newly created row or the updated row\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void addSubscriptionInfoRecord(String uniqueId, String displayName, int slotIndex, int subscriptionType)",
    "returnType" : "void",
    "comment" : "\n     * Add a new SubscriptionInfo to SubscriptionInfo database if needed\n     * @param uniqueId This is the unique identifier for the subscription within the\n     *                 specific subscription type.\n     * @param displayName human-readable name of the device the subscription corresponds to.\n     * @param slotIndex the slot assigned to this subscription. It is ignored for subscriptionType\n     *                  of {@link #SUBSCRIPTION_TYPE_REMOTE_SIM}.\n     * @param subscriptionType the {@link #SUBSCRIPTION_TYPE}\n     * @hide\n     ",
    "links" : [ "#SUBSCRIPTION_TYPE", "#SUBSCRIPTION_TYPE_REMOTE_SIM" ]
  }, {
    "name" : "public void removeSubscriptionInfoRecord(String uniqueId, int subscriptionType)",
    "returnType" : "void",
    "comment" : "\n     * Remove SubscriptionInfo record from the SubscriptionInfo database\n     * @param uniqueId This is the unique identifier for the subscription within the specific\n     *                 subscription type.\n     * @param subscriptionType the {@link #SUBSCRIPTION_TYPE}\n     * @hide\n     ",
    "links" : [ "#SUBSCRIPTION_TYPE" ]
  }, {
    "name" : "public int setIconTint(@ColorInt int tint, int subId)",
    "returnType" : "int",
    "comment" : "\n     * Set SIM icon tint color for subscription ID\n     * @param tint the RGB value of icon tint color of the SIM\n     * @param subId the unique Subscritpion ID in database\n     * @return the number of records updated\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int setDisplayName(@Nullable String displayName, int subId, @SimDisplayNameSource int nameSource)",
    "returnType" : "int",
    "comment" : "\n     * Set the display name for a subscription ID\n     * @param displayName the display name of SIM card\n     * @param subId the unique Subscritpion ID in database\n     * @param nameSource SIM display name source\n     * @return the number of records updated or < 0 if invalid subId\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int setDisplayNumber(String number, int subId)",
    "returnType" : "int",
    "comment" : "\n     * Set phone number by subId\n     * @param number the phone number of the SIM\n     * @param subId the unique SubscriptionInfo index in database\n     * @return the number of records updated\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int setDataRoaming(int roaming, int subId)",
    "returnType" : "int",
    "comment" : "\n     * Set data roaming by simInfo index\n     * @param roaming 0:Don't allow data when roaming, 1:Allow data when roaming\n     * @param subId the unique SubscriptionInfo index in database\n     * @return the number of records updated\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getSlotIndex(int subscriptionId)",
    "returnType" : "int",
    "comment" : "\n     * Get slotIndex associated with the subscription.\n     *\n     * @param subscriptionId the unique SubscriptionInfo index in database\n     * @return slotIndex as a positive integer or {@link #INVALID_SIM_SLOT_INDEX} if the supplied\n     * subscriptionId doesn't have an associated slot index.\n     ",
    "links" : [ "#INVALID_SIM_SLOT_INDEX" ]
  }, {
    "name" : "public int[] getSubscriptionIds(int slotIndex)",
    "returnType" : "int[]",
    "comment" : "\n     * Get an array of Subscription Ids for specified slot Index.\n     * @param slotIndex the slot index.\n     * @return subscription Ids or null if the given slot Index is not valid or there are no active\n     * subscriptions in the slot.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int[] getSubId(int slotIndex)",
    "returnType" : "int[]",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static int getPhoneId(int subId)",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "private static void logd(String msg)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static void loge(String msg)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static int getDefaultSubscriptionId()",
    "returnType" : "int",
    "comment" : "\n     * Returns the system's default subscription id.\n     *\n     * For a voice capable device, it will return getDefaultVoiceSubscriptionId.\n     * For a data only device, it will return the getDefaultDataSubscriptionId.\n     * May return an INVALID_SUBSCRIPTION_ID on error.\n     *\n     * @return the \"system\" default subscription id.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getDefaultVoiceSubscriptionId()",
    "returnType" : "int",
    "comment" : "\n     * Returns the system's default voice subscription id.\n     *\n     * On a data only device or on error, will return INVALID_SUBSCRIPTION_ID.\n     *\n     * @return the default voice subscription Id.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDefaultVoiceSubscriptionId(int subscriptionId)",
    "returnType" : "void",
    "comment" : "\n     * Sets the system's default voice subscription id.\n     *\n     * On a data-only device, this is a no-op.\n     *\n     * May throw a {@link RuntimeException} if the provided subscription id is equal to\n     * {@link SubscriptionManager#DEFAULT_SUBSCRIPTION_ID}\n     *\n     * @param subscriptionId A valid subscription ID to set as the system default, or\n     *                       {@link SubscriptionManager#INVALID_SUBSCRIPTION_ID}\n     * @hide\n     ",
    "links" : [ "RuntimeException", "android.telephony.SubscriptionManager#DEFAULT_SUBSCRIPTION_ID", "android.telephony.SubscriptionManager#INVALID_SUBSCRIPTION_ID" ]
  }, {
    "name" : "public void setDefaultVoiceSubId(int subId)",
    "returnType" : "void",
    "comment" : "\n     * Same as {@link #setDefaultVoiceSubscriptionId(int)}, but preserved for backwards\n     * compatibility.\n     * @hide\n     ",
    "links" : [ "#setDefaultVoiceSubscriptionId(int)" ]
  }, {
    "name" : "public SubscriptionInfo getDefaultVoiceSubscriptionInfo()",
    "returnType" : "SubscriptionInfo",
    "comment" : "\n     * Return the SubscriptionInfo for default voice subscription.\n     *\n     * Will return null on data only devices, or on error.\n     *\n     * @return the SubscriptionInfo for the default voice subscription.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getDefaultVoicePhoneId()",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static int getDefaultSmsSubscriptionId()",
    "returnType" : "int",
    "comment" : "\n     * Returns the system's default SMS subscription id.\n     *\n     * On a data only device or on error, will return INVALID_SUBSCRIPTION_ID.\n     *\n     * @return the default SMS subscription Id.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDefaultSmsSubId(int subscriptionId)",
    "returnType" : "void",
    "comment" : "\n     * Set the subscription which will be used by default for SMS, with the subscription which\n     * the supplied subscription ID corresponds to; or throw a RuntimeException if the supplied\n     * subscription ID is not usable (check with {@link #isUsableSubscriptionId(int)}).\n     *\n     * @param subscriptionId the supplied subscription ID\n     *\n     * @hide\n     ",
    "links" : [ "#isUsableSubscriptionId(int)" ]
  }, {
    "name" : "public SubscriptionInfo getDefaultSmsSubscriptionInfo()",
    "returnType" : "SubscriptionInfo",
    "comment" : "\n     * Return the SubscriptionInfo for default voice subscription.\n     *\n     * Will return null on data only devices, or on error.\n     *\n     * @return the SubscriptionInfo for the default SMS subscription.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getDefaultSmsPhoneId()",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static int getDefaultDataSubscriptionId()",
    "returnType" : "int",
    "comment" : "\n     * Returns the system's default data subscription id.\n     *\n     * On a voice only device or on error, will return INVALID_SUBSCRIPTION_ID.\n     *\n     * @return the default data subscription Id.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDefaultDataSubId(int subscriptionId)",
    "returnType" : "void",
    "comment" : "\n     * Set the subscription which will be used by default for data, with the subscription which\n     * the supplied subscription ID corresponds to; or throw a RuntimeException if the supplied\n     * subscription ID is not usable (check with {@link #isUsableSubscriptionId(int)}).\n     *\n     * @param subscriptionId the supplied subscription ID\n     *\n     * @hide\n     ",
    "links" : [ "#isUsableSubscriptionId(int)" ]
  }, {
    "name" : "public SubscriptionInfo getDefaultDataSubscriptionInfo()",
    "returnType" : "SubscriptionInfo",
    "comment" : "\n     * Return the SubscriptionInfo for default data subscription.\n     *\n     * Will return null on voice only devices, or on error.\n     *\n     * @return the SubscriptionInfo for the default data subscription.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getDefaultDataPhoneId()",
    "returnType" : "int",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public void clearSubscriptionInfo()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean allDefaultsSelected()",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isValidSubscriptionId(int subscriptionId)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the supplied subscription ID is valid.\n     *\n     * <p>A valid subscription ID is not necessarily an active subscription ID\n     * (see {@link #isActiveSubscriptionId(int)}) or an usable subscription ID\n     * (see {@link #isUsableSubscriptionId(int)}). Unless specifically noted, subscription\n     * APIs work with a valid subscription ID.\n     *\n     * @param subscriptionId The subscription ID.\n     * @return {@code true} if the supplied subscriptionId is valid; {@code false} otherwise.\n     ",
    "links" : [ "#isUsableSubscriptionId(int)", "#isActiveSubscriptionId(int)" ]
  }, {
    "name" : "public static boolean isUsableSubscriptionId(int subscriptionId)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the supplied subscription ID is usable.\n     *\n     * <p>A usable subscription ID is a valid subscription ID, but not necessarily an active\n     * subscription ID (see {@link #isActiveSubscriptionId(int)}). Some subscription APIs\n     * require a usable subscription ID, and this is noted in their documentation; otherwise, a\n     * subscription ID does not need to be usable for subscription functions, only valid.\n     *\n     * @param subscriptionId the subscription ID\n     * @return {@code true} if the subscription ID is usable; {@code false} otherwise.\n     ",
    "links" : [ "#isActiveSubscriptionId(int)" ]
  }, {
    "name" : "public static boolean isUsableSubIdValue(int subId)",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if subId is an usable subId value else false. A\n     * usable subId means its neither a INVALID_SUBSCRIPTION_ID nor a DEFAULT_SUB_ID.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isValidSlotIndex(int slotIndex)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static boolean isValidPhoneId(int phoneId)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void putPhoneIdAndSubIdExtra(Intent intent, int phoneId)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void putPhoneIdAndSubIdExtra(Intent intent, int phoneId, int subId)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public int[] getActiveSubscriptionIdList()",
    "returnType" : "int[]",
    "comment" : "\n     * Get visible subscription Id(s) of the currently active SIM(s).\n     *\n     * @return the list of subId's that are active,\n     *         is never null but the length may be 0.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int[] getCompleteActiveSubscriptionIdList()",
    "returnType" : "int[]",
    "comment" : "\n     * Get both hidden and visible subscription Id(s) of the currently active SIM(s).\n     *\n     * Hidden subscriptions refer to those are not meant visible to the users.\n     * For example, an opportunistic subscription that is grouped with other\n     * subscriptions should remain invisible to users as they are only functionally\n     * supplementary to primary ones.\n     *\n     * @return the list of subId's that are active,\n     *         is never null but the length may be 0.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public int[] getActiveSubscriptionIdList(boolean visibleOnly)",
    "returnType" : "int[]",
    "comment" : "\n     * @return a non-null list of subId's that are active.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isNetworkRoaming(int subId)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the device is considered roaming on the current\n     * network for a subscription.\n     * <p>\n     * Availability: Only when user registered to a network.\n     *\n     * @param subId The subscription ID\n     * @return true if the network for the subscription is roaming, false otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getSimStateForSlotIndex(int slotIndex)",
    "returnType" : "int",
    "comment" : "\n     * Returns a constant indicating the state of sim for the slot index.\n     *\n     * @param slotIndex\n     *\n     * {@See TelephonyManager#SIM_STATE_UNKNOWN}\n     * {@See TelephonyManager#SIM_STATE_ABSENT}\n     * {@See TelephonyManager#SIM_STATE_PIN_REQUIRED}\n     * {@See TelephonyManager#SIM_STATE_PUK_REQUIRED}\n     * {@See TelephonyManager#SIM_STATE_NETWORK_LOCKED}\n     * {@See TelephonyManager#SIM_STATE_READY}\n     * {@See TelephonyManager#SIM_STATE_NOT_READY}\n     * {@See TelephonyManager#SIM_STATE_PERM_DISABLED}\n     * {@See TelephonyManager#SIM_STATE_CARD_IO_ERROR}\n     *\n     * {@hide}\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void setSubscriptionProperty(int subId, String propKey, String propValue)",
    "returnType" : "void",
    "comment" : "\n     * Store properties associated with SubscriptionInfo in database\n     * @param subId Subscription Id of Subscription\n     * @param propKey Column name in database associated with SubscriptionInfo\n     * @param propValue Value to store in DB for particular subId & column name\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static String getSubscriptionProperty(int subId, String propKey, Context context)",
    "returnType" : "String",
    "comment" : "\n     * Store properties associated with SubscriptionInfo in database\n     * @param subId Subscription Id of Subscription\n     * @param propKey Column name in SubscriptionInfo database\n     * @return Value associated with subId and propKey column in database\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static boolean getBooleanSubscriptionProperty(int subId, String propKey, boolean defValue, Context context)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns boolean value corresponding to query result.\n     * @param subId Subscription Id of Subscription\n     * @param propKey Column name in SubscriptionInfo database\n     * @param defValue Default boolean value to be returned\n     * @return boolean result value to be returned\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int getIntegerSubscriptionProperty(int subId, String propKey, int defValue, Context context)",
    "returnType" : "int",
    "comment" : "\n     * Returns integer value corresponding to query result.\n     * @param subId Subscription Id of Subscription\n     * @param propKey Column name in SubscriptionInfo database\n     * @param defValue Default integer value to be returned\n     * @return integer result value to be returned\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static long getLongSubscriptionProperty(int subId, String propKey, long defValue, Context context)",
    "returnType" : "long",
    "comment" : "\n     * Returns long value corresponding to query result.\n     * @param subId Subscription Id of Subscription\n     * @param propKey Column name in SubscriptionInfo database\n     * @param defValue Default long value to be returned\n     * @return long result value to be returned\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static Resources getResourcesForSubId(@NonNull Context context, int subId)",
    "returnType" : "Resources",
    "comment" : "\n     * Returns the {@link Resources} from the given {@link Context} for the MCC/MNC associated with\n     * the subscription. If the subscription ID is invalid, the base resources are returned instead.\n     *\n     * Requires Permission: {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     *\n     * @param context Context object\n     * @param subId Subscription Id of Subscription whose resources are required\n     * @return Resources associated with Subscription.\n     * @hide\n     ",
    "links" : [ "android.content.Context", "android.Manifest.permission#READ_PHONE_STATE", "android.content.res.Resources" ]
  }, {
    "name" : "public static Resources getResourcesForSubId(Context context, int subId, boolean useRootLocale)",
    "returnType" : "Resources",
    "comment" : "\n     * Returns the resources associated with Subscription.\n     * @param context Context object\n     * @param subId Subscription Id of Subscription who's resources are required\n     * @param useRootLocale if root locale should be used. Localized locale is used if false.\n     * @return Resources associated with Subscription.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isActiveSubscriptionId(int subscriptionId)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks if the supplied subscription ID corresponds to a subscription which is actively in\n     * use on the device. An active subscription ID is a valid and usable subscription ID.\n     *\n     * @param subscriptionId the subscription ID.\n     * @return {@code true} if the supplied subscription ID corresponds to an active subscription;\n     * {@code false} if it does not correspond to an active subscription; or throw a\n     * SecurityException if the caller hasn't got the right permission.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isActiveSubId(int subId)",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if the sub ID is active. i.e. The sub ID corresponds to a known subscription\n     * and the SIM providing the subscription is present in a slot and in \"LOADED\" state.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<SubscriptionPlan> getSubscriptionPlans(int subId)",
    "returnType" : "List<SubscriptionPlan>",
    "comment" : "\n     * Get the description of the billing relationship plan between a carrier\n     * and a specific subscriber.\n     * <p>\n     * This method is only accessible to the following narrow set of apps:\n     * <ul>\n     * <li>The carrier app for this subscriberId, as determined by\n     * {@link TelephonyManager#hasCarrierPrivileges()}.\n     * <li>The carrier app explicitly delegated access through\n     * {@link CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING}.\n     * </ul>\n     *\n     * @param subId the subscriber this relationship applies to\n     * @throws SecurityException if the caller doesn't meet the requirements\n     *             outlined above.\n     ",
    "links" : [ "android.telephony.CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "public void setSubscriptionPlans(int subId, @NonNull List<SubscriptionPlan> plans)",
    "returnType" : "void",
    "comment" : "\n     * Set the description of the billing relationship plan between a carrier\n     * and a specific subscriber.\n     * <p>\n     * This method is only accessible to the following narrow set of apps:\n     * <ul>\n     * <li>The carrier app for this subscriberId, as determined by\n     * {@link TelephonyManager#hasCarrierPrivileges()}.\n     * <li>The carrier app explicitly delegated access through\n     * {@link CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING}.\n     * </ul>\n     *\n     * @param subId the subscriber this relationship applies to. An empty list\n     *            may be sent to clear any existing plans.\n     * @param plans the list of plans. The first plan is always the primary and\n     *            most important plan. Any additional plans are secondary and\n     *            may not be displayed or used by decision making logic.\n     * @throws SecurityException if the caller doesn't meet the requirements\n     *             outlined above.\n     * @throws IllegalArgumentException if plans don't meet the requirements\n     *             defined in {@link SubscriptionPlan}.\n     ",
    "links" : [ "android.telephony.CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING", "android.telephony.SubscriptionPlan", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "public void setSubscriptionOverrideUnmetered(int subId, boolean overrideUnmetered, @DurationMillisLong long timeoutMillis)",
    "returnType" : "void",
    "comment" : "\n     * Temporarily override the billing relationship plan between a carrier and\n     * a specific subscriber to be considered unmetered. This will be reflected\n     * to apps via {@link NetworkCapabilities#NET_CAPABILITY_NOT_METERED}.\n     * <p>\n     * This method is only accessible to the following narrow set of apps:\n     * <ul>\n     * <li>The carrier app for this subscriberId, as determined by\n     * {@link TelephonyManager#hasCarrierPrivileges()}.\n     * <li>The carrier app explicitly delegated access through\n     * {@link CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING}.\n     * </ul>\n     *\n     * @param subId the subscriber this override applies to.\n     * @param overrideUnmetered set if the billing relationship should be\n     *            considered unmetered.\n     * @param timeoutMillis the timeout after which the requested override will\n     *            be automatically cleared, or {@code 0} to leave in the\n     *            requested state until explicitly cleared, or the next reboot,\n     *            whichever happens first.\n     * @throws SecurityException if the caller doesn't meet the requirements\n     *             outlined above.\n     ",
    "links" : [ "android.net.NetworkCapabilities#NET_CAPABILITY_NOT_METERED", "android.telephony.CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "public void setSubscriptionOverrideCongested(int subId, boolean overrideCongested, @DurationMillisLong long timeoutMillis)",
    "returnType" : "void",
    "comment" : "\n     * Temporarily override the billing relationship plan between a carrier and\n     * a specific subscriber to be considered congested. This will cause the\n     * device to delay certain network requests when possible, such as developer\n     * jobs that are willing to run in a flexible time window.\n     * <p>\n     * This method is only accessible to the following narrow set of apps:\n     * <ul>\n     * <li>The carrier app for this subscriberId, as determined by\n     * {@link TelephonyManager#hasCarrierPrivileges()}.\n     * <li>The carrier app explicitly delegated access through\n     * {@link CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING}.\n     * </ul>\n     *\n     * @param subId the subscriber this override applies to.\n     * @param overrideCongested set if the subscription should be considered\n     *            congested.\n     * @param timeoutMillis the timeout after which the requested override will\n     *            be automatically cleared, or {@code 0} to leave in the\n     *            requested state until explicitly cleared, or the next reboot,\n     *            whichever happens first.\n     * @throws SecurityException if the caller doesn't meet the requirements\n     *             outlined above.\n     ",
    "links" : [ "android.telephony.CarrierConfigManager#KEY_CONFIG_PLANS_PACKAGE_OVERRIDE_STRING", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "public boolean canManageSubscription(SubscriptionInfo info)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether the app with the given context is authorized to manage the given subscription\n     * according to its metadata.\n     *\n     * @param info The subscription to check.\n     * @return whether the app is authorized to manage this subscription per its metadata.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean canManageSubscription(@NonNull SubscriptionInfo info, @NonNull String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Checks whether the given app is authorized to manage the given subscription. An app can only\n     * be authorized if it is included in the {@link android.telephony.UiccAccessRule} of the\n     * {@link android.telephony.SubscriptionInfo} with the access status.\n     *\n     * @param info The subscription to check.\n     * @param packageName Package name of the app to check.\n     * @return whether the app is authorized to manage this subscription per its access rules.\n     * @hide\n     ",
    "links" : [ "android.telephony.UiccAccessRule", "android.telephony.SubscriptionInfo" ]
  }, {
    "name" : "public void setPreferredDataSubscriptionId(int subId, boolean needValidation, @Nullable @CallbackExecutor Executor executor, @Nullable @TelephonyManager.SetOpportunisticSubscriptionResult Consumer<Integer> callback)",
    "returnType" : "void",
    "comment" : "\n     * Set which subscription is preferred for cellular data.\n     * It's also usually the subscription we set up internet connection on.\n     *\n     * PreferredData overwrites user setting of default data subscription. And it's used\n     * by AlternativeNetworkService or carrier apps to switch primary and CBRS\n     * subscription dynamically in multi-SIM devices.\n     *\n     * @param subId which subscription is preferred to for cellular data. If it's\n     *              {@link SubscriptionManager#DEFAULT_SUBSCRIPTION_ID}, it means\n     *              it's unset and {@link SubscriptionManager#getDefaultDataSubscriptionId()}\n     *              is used to determine which modem is preferred.\n     * @param needValidation whether Telephony will wait until the network is validated by\n     *              connectivity service before switching data to it. More details see\n     *              {@link NetworkCapabilities#NET_CAPABILITY_VALIDATED}.\n     * @param executor The executor of where the callback will execute.\n     * @param callback Callback will be triggered once it succeeds or failed.\n     *                 Pass null if don't care about the result.\n     *\n     * @hide\n     *\n     ",
    "links" : [ "android.telephony.SubscriptionManager#DEFAULT_SUBSCRIPTION_ID", "android.telephony.SubscriptionManager#getDefaultDataSubscriptionId()", "android.net.NetworkCapabilities#NET_CAPABILITY_VALIDATED" ]
  }, {
    "name" : "public int getPreferredDataSubscriptionId()",
    "returnType" : "int",
    "comment" : "\n     * Get which subscription is preferred for cellular data.\n     * It's also usually the subscription we set up internet connection on.\n     *\n     * PreferredData overwrites user setting of default data subscription. And it's used\n     * by AlternativeNetworkService or carrier apps to switch primary and CBRS\n     * subscription dynamically in multi-SIM devices.\n     *\n     * @return preferred subscription id for cellular data. {@link DEFAULT_SUBSCRIPTION_ID} if\n     * there's no prefered subscription.\n     *\n     * @hide\n     *\n     ",
    "links" : [ "DEFAULT_SUBSCRIPTION_ID" ]
  }, {
    "name" : "public List<SubscriptionInfo> getOpportunisticSubscriptions()",
    "returnType" : "List<SubscriptionInfo>",
    "comment" : "\n     * Return opportunistic subscriptions that can be visible to the caller.\n     * Opportunistic subscriptions are for opportunistic networks, which are cellular\n     * networks with limited capabilities and coverage, for example, CBRS.\n     *\n     * <p>Requires Permission:\n     * {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}\n     * or that the calling app has carrier privileges (see\n     * {@link TelephonyManager#hasCarrierPrivileges}).\n     *\n     * @return the list of opportunistic subscription info. If none exists, an empty list.\n     ",
    "links" : [ "android.telephony.TelephonyManager#hasCarrierPrivileges", "android.Manifest.permission#READ_PHONE_STATE" ]
  }, {
    "name" : "public void switchToSubscription(int subId, @NonNull PendingIntent callbackIntent)",
    "returnType" : "void",
    "comment" : "\n     * Switch to a certain subscription\n     *\n     *  @param subId sub id\n     *  @param callbackIntent pending intent that will be sent after operation is done.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setOpportunistic(boolean opportunistic, int subId)",
    "returnType" : "boolean",
    "comment" : "\n     * Set whether a subscription is opportunistic, that is, whether the network it connects\n     * to has limited coverage. For example, CBRS. Setting a subscription opportunistic has\n     * following impacts:\n     *  1) Even if it's active, it will be dormant most of the time. The modem will not try\n     *     to scan or camp until it knows an available network is nearby to save power.\n     *  2) Telephony relies on system app or carrier input to notify nearby available networks.\n     *     See {@link TelephonyManager#updateAvailableNetworks(List, Executor, Consumer)}\n     *     for more information.\n     *  3) In multi-SIM devices, when the network is nearby and camped, system may automatically\n     *     switch internet data between it and default data subscription, based on carrier\n     *     recommendation and its signal strength and metered-ness, etc.\n     *\n     *\n     * Caller will either have {@link android.Manifest.permission#MODIFY_PHONE_STATE} or carrier\n     * privilege permission of the subscription.\n     *\n     * @param opportunistic whether it’s opportunistic subscription.\n     * @param subId the unique SubscriptionInfo index in database\n     * @return {@code true} if the operation is succeed, {@code false} otherwise.\n     ",
    "links" : [ "android.Manifest.permission#MODIFY_PHONE_STATE", "android.telephony.TelephonyManager#updateAvailableNetworks(List" ]
  }, {
    "name" : "public ParcelUuid createSubscriptionGroup(@NonNull List<Integer> subIdList)",
    "returnType" : "ParcelUuid",
    "comment" : "\n     * Inform SubscriptionManager that subscriptions in the list are bundled\n     * as a group. It can be multiple primary (non-opportunistic) subscriptions,\n     * or one or more primary plus one or more opportunistic subscriptions.\n     *\n     * This API will always create a new immutable group and assign group UUID to all the\n     * subscriptions, regardless whether they are in a group already or not.\n     *\n     * Grouped subscriptions will have below behaviors:\n     * 1) They will share the same user settings.\n     * 2) The opportunistic subscriptions in the group is considered invisible and will not\n     *    return from {@link #getActiveSubscriptionInfoList()}, unless caller has carrier\n     *    privilege permission of the subscriptions.\n     * 3) The opportunistic subscriptions in the group can't be active by itself. If all other\n     *    non-opportunistic ones are deactivated (unplugged or disabled in Settings),\n     *    the opportunistic ones will be deactivated automatically.\n     *\n     * Caller will either have {@link android.Manifest.permission#MODIFY_PHONE_STATE}\n     * permission or had carrier privilege permission on the subscriptions:\n     * {@link TelephonyManager#hasCarrierPrivileges()} or\n     * {@link #canManageSubscription(SubscriptionInfo)}\n     *\n     * @throws SecurityException if the caller doesn't meet the requirements\n     *             outlined above.\n     * @throws IllegalArgumentException if any of the subscriptions in the list doesn't exist.\n     * @throws IllegalStateException if Telephony service is in bad state.\n     *\n     * @param subIdList list of subId that will be in the same group\n     * @return groupUUID a UUID assigned to the subscription group.\n     *\n     ",
    "links" : [ "#getActiveSubscriptionInfoList()", "#canManageSubscription(SubscriptionInfo)", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "public void addSubscriptionsIntoGroup(@NonNull List<Integer> subIdList, @NonNull ParcelUuid groupUuid)",
    "returnType" : "void",
    "comment" : "\n     * Add a list of subscriptions into a group.\n     * See {@link #createSubscriptionGroup(List)} for more details.\n     *\n     * Caller will either have {@link android.Manifest.permission#MODIFY_PHONE_STATE}\n     * permission or had carrier privilege permission on the subscriptions:\n     * {@link TelephonyManager#hasCarrierPrivileges()} or\n     * {@link #canManageSubscription(SubscriptionInfo)}\n     *\n     * @throws SecurityException if the caller doesn't meet the requirements\n     *             outlined above.\n     * @throws IllegalArgumentException if the some subscriptions in the list doesn't exist.\n     * @throws IllegalStateException if Telephony service is in bad state.\n     *\n     * @param subIdList list of subId that need adding into the group\n     * @param groupUuid the groupUuid the subscriptions are being added to.\n     *\n     ",
    "links" : [ "#createSubscriptionGroup(List)", "#canManageSubscription(SubscriptionInfo)", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "private boolean isSystemProcess()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void removeSubscriptionsFromGroup(@NonNull List<Integer> subIdList, @NonNull ParcelUuid groupUuid)",
    "returnType" : "void",
    "comment" : "\n     * Remove a list of subscriptions from their subscription group.\n     * See {@link #createSubscriptionGroup(List)} for more details.\n     *\n     * Caller will either have {@link android.Manifest.permission#MODIFY_PHONE_STATE}\n     * permission or had carrier privilege permission on the subscriptions:\n     * {@link TelephonyManager#hasCarrierPrivileges()} or\n     * {@link #canManageSubscription(SubscriptionInfo)}\n     *\n     * @throws SecurityException if the caller doesn't meet the requirements\n     *             outlined above.\n     * @throws IllegalArgumentException if the some subscriptions in the list doesn't belong\n     *             the specified group.\n     * @throws IllegalStateException if Telephony service is in bad state.\n     *\n     * @param subIdList list of subId that need removing from their groups.\n     *\n     ",
    "links" : [ "#createSubscriptionGroup(List)", "#canManageSubscription(SubscriptionInfo)", "android.Manifest.permission#MODIFY_PHONE_STATE", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "public List<SubscriptionInfo> getSubscriptionsInGroup(@NonNull ParcelUuid groupUuid)",
    "returnType" : "List<SubscriptionInfo>",
    "comment" : "\n     * Get subscriptionInfo list of subscriptions that are in the same group of given subId.\n     * See {@link #createSubscriptionGroup(List)} for more details.\n     *\n     * Caller will either have {@link android.Manifest.permission#READ_PHONE_STATE}\n     * permission or had carrier privilege permission on the subscription.\n     * {@link TelephonyManager#hasCarrierPrivileges()}\n     *\n     * @throws IllegalStateException if Telephony service is in bad state.\n     * @throws SecurityException if the caller doesn't meet the requirements\n     *             outlined above.\n     *\n     * @param groupUuid of which list of subInfo will be returned.\n     * @return list of subscriptionInfo that belong to the same group, including the given\n     * subscription itself. It will return an empty list if no subscription belongs to the group.\n     *\n     ",
    "links" : [ "#createSubscriptionGroup(List)", "android.Manifest.permission#READ_PHONE_STATE", "android.telephony.TelephonyManager#hasCarrierPrivileges()" ]
  }, {
    "name" : "public boolean isSubscriptionVisible(SubscriptionInfo info)",
    "returnType" : "boolean",
    "comment" : "\n     * Whether a subscription is visible to API caller. If it's a bundled opportunistic\n     * subscription, it should be hidden anywhere in Settings, dialer, status bar etc.\n     * Exception is if caller owns carrier privilege, in which case they will\n     * want to see their own hidden subscriptions.\n     *\n     * @param info the subscriptionInfo to check against.\n     * @return true if this subscription should be visible to the API caller.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public List<SubscriptionInfo> getSelectableSubscriptionInfoList()",
    "returnType" : "List<SubscriptionInfo>",
    "comment" : "\n     * Return a list of subscriptions that are available and visible to the user.\n     * Used by Settings app to show a list of subscriptions for user to pick.\n     *\n     * <p>\n     * Permissions android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE is required\n     * for getSelectableSubscriptionInfoList to be invoked.\n     * @return list of user selectable subscriptions.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean setSubscriptionEnabled(int subscriptionId, boolean enable)",
    "returnType" : "boolean",
    "comment" : "\n     * Enables or disables a subscription. This is currently used in the settings page. It will\n     * fail and return false if operation is not supported or failed.\n     *\n     * To disable an active subscription on a physical (non-Euicc) SIM,\n     * {@link #canDisablePhysicalSubscription} needs to be true.\n     *\n     * <p>\n     * Permissions android.Manifest.permission.MODIFY_PHONE_STATE is required\n     *\n     * @param enable whether user is turning it on or off.\n     * @param subscriptionId Subscription to be enabled or disabled.\n     *                       It could be a eSIM or pSIM subscription.\n     *\n     * @return whether the operation is successful.\n     *\n     * @hide\n     ",
    "links" : [ "#canDisablePhysicalSubscription" ]
  }, {
    "name" : "public void setUiccApplicationsEnabled(int subscriptionId, boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Set uicc applications being enabled or disabled.\n     * The value will be remembered on the subscription and will be applied whenever it's present.\n     * If the subscription in currently present, it will also apply the setting to modem\n     * immediately.\n     *\n     * Permissions android.Manifest.permission.MODIFY_PHONE_STATE is required\n     *\n     * @param subscriptionId which subscription to operate on.\n     * @param enabled whether uicc applications are enabled or disabled.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean canDisablePhysicalSubscription()",
    "returnType" : "boolean",
    "comment" : "\n     * Whether it's supported to disable / re-enable a subscription on a physical (non-euicc) SIM.\n     *\n     * Physical SIM refers non-euicc, or aka non-programmable SIM.\n     *\n     * It provides whether a physical SIM card can be disabled without taking it out, which is done\n     * via {@link #setSubscriptionEnabled(int, boolean)} API.\n     *\n     * Requires Permission: READ_PRIVILEGED_PHONE_STATE.\n     *\n     * @return whether can disable subscriptions on physical SIMs.\n     *\n     * @hide\n     ",
    "links" : [ "#setSubscriptionEnabled(int" ]
  }, {
    "name" : "public boolean isSubscriptionEnabled(int subscriptionId)",
    "returnType" : "boolean",
    "comment" : "\n     * DO NOT USE.\n     * This API is designed for features that are not finished at this point. Do not call this API.\n     * @hide\n     * TODO b/135547512: further clean up\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getEnabledSubscriptionId(int slotIndex)",
    "returnType" : "int",
    "comment" : "\n     * DO NOT USE.\n     * This API is designed for features that are not finished at this point. Do not call this API.\n     * @hide\n     * TODO b/135547512: further clean up\n     ",
    "links" : [ ]
  }, {
    "name" : "private int setSubscriptionPropertyHelper(int subId, String methodName, CallISubMethodHelper helper)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static int getActiveDataSubscriptionId()",
    "returnType" : "int",
    "comment" : "\n     * Get active data subscription id. Active data subscription refers to the subscription\n     * currently chosen to provide cellular internet connection to the user. This may be\n     * different from getDefaultDataSubscriptionId(). Eg. Opportunistics data\n     *\n     * See {@link PhoneStateListener#onActiveDataSubscriptionIdChanged(int)} for the details.\n     *\n     * @return Active data subscription id if any is chosen, or\n     * SubscriptionManager.INVALID_SUBSCRIPTION_ID if not.\n     ",
    "links" : [ "android.telephony.PhoneStateListener#onActiveDataSubscriptionIdChanged(int)" ]
  }, {
    "name" : "public static void putSubscriptionIdExtra(Intent intent, int subId)",
    "returnType" : "void",
    "comment" : "\n     * Helper method that puts a subscription id on an intent with the constants:\n     * PhoneConstant.SUBSCRIPTION_KEY and SubscriptionManager.EXTRA_SUBSCRIPTION_INDEX.\n     * Both constants are used to support backwards compatibility.  Once we know we got all places,\n     * we can remove PhoneConstants.SUBSCRIPTION_KEY.\n     * @param intent Intent to put sub id on.\n     * @param subId SubscriptionId to put on intent.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void invalidateDefaultSubIdCaches()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void invalidateDefaultDataSubIdCaches()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void invalidateDefaultSmsSubIdCaches()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void invalidateActiveDataSubIdCaches()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void invalidateSlotIndexCaches()",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public static void disableCaching()",
    "returnType" : "void",
    "comment" : "\n     * Allows a test process to disable client-side caching operations.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void clearCaches()",
    "returnType" : "void",
    "comment" : "\n     * Clears all process-local binder caches.\n     *\n     * @hide ",
    "links" : [ ]
  } ],
  "variableNames" : [ "LOG_TAG", "DBG", "VDBG", "INVALID_SUBSCRIPTION_ID", "DUMMY_SUBSCRIPTION_ID_BASE", "INVALID_PHONE_INDEX", "INVALID_SIM_SLOT_INDEX", "DEFAULT_SUBSCRIPTION_ID", "DEFAULT_PHONE_INDEX", "DEFAULT_SIM_SLOT_INDEX", "MIN_SUBSCRIPTION_ID_VALUE", "MAX_SUBSCRIPTION_ID_VALUE", "CONTENT_URI", "CACHE_KEY_DEFAULT_SUB_ID_PROPERTY", "CACHE_KEY_DEFAULT_DATA_SUB_ID_PROPERTY", "CACHE_KEY_DEFAULT_SMS_SUB_ID_PROPERTY", "CACHE_KEY_ACTIVE_DATA_SUB_ID_PROPERTY", "CACHE_KEY_SLOT_INDEX_PROPERTY", "MAX_CACHE_SIZE", "sDefaultSubIdCache", "sDefaultDataSubIdCache", "sDefaultSmsSubIdCache", "sActiveDataSubIdCache", "sSlotIndexCache", "sPhoneIdCache", "WFC_ENABLED_CONTENT_URI", "ADVANCED_CALLING_ENABLED_CONTENT_URI", "WFC_MODE_CONTENT_URI", "WFC_ROAMING_MODE_CONTENT_URI", "VT_ENABLED_CONTENT_URI", "WFC_ROAMING_ENABLED_CONTENT_URI", "UNIQUE_KEY_SUBSCRIPTION_ID", "ICC_ID", "SIM_SLOT_INDEX", "SIM_NOT_INSERTED", "SLOT_INDEX_FOR_REMOTE_SIM_SUB", "SUBSCRIPTION_TYPE", "DATA_ENABLED_OVERRIDE_RULES", "SUBSCRIPTION_TYPE_LOCAL_SIM", "SUBSCRIPTION_TYPE_REMOTE_SIM", "DISPLAY_NAME", "CARRIER_NAME", "DEFAULT_NAME_RES", "NAME_SOURCE", "NAME_SOURCE_CARRIER_ID", "NAME_SOURCE_SIM_SPN", "NAME_SOURCE_USER_INPUT", "NAME_SOURCE_CARRIER", "NAME_SOURCE_SIM_PNN", "HUE", "NUMBER", "DATA_ROAMING", "DATA_ROAMING_ENABLE", "DATA_ROAMING_DISABLE", "CARRIER_ID", "EHPLMNS", "HPLMNS", "MCC_STRING", "MNC_STRING", "MCC", "MNC", "ISO_COUNTRY_CODE", "IS_EMBEDDED", "CARD_ID", "ACCESS_RULES", "ACCESS_RULES_FROM_CARRIER_CONFIGS", "IS_REMOVABLE", "CB_EXTREME_THREAT_ALERT", "CB_SEVERE_THREAT_ALERT", "CB_AMBER_ALERT", "CB_EMERGENCY_ALERT", "CB_ALERT_SOUND_DURATION", "CB_ALERT_REMINDER_INTERVAL", "CB_ALERT_VIBRATE", "CB_ALERT_SPEECH", "CB_ETWS_TEST_ALERT", "CB_CHANNEL_50_ALERT", "CB_CMAS_TEST_ALERT", "CB_OPT_OUT_DIALOG", "ENHANCED_4G_MODE_ENABLED", "VT_IMS_ENABLED", "WFC_IMS_ENABLED", "WFC_IMS_MODE", "WFC_IMS_ROAMING_MODE", "WFC_IMS_ROAMING_ENABLED", "IMS_RCS_UCE_ENABLED", "IS_OPPORTUNISTIC", "GROUP_UUID", "GROUP_OWNER", "PROFILE_CLASS", "PROFILE_CLASS_TESTING", "PROFILE_CLASS_PROVISIONING", "PROFILE_CLASS_OPERATIONAL", "PROFILE_CLASS_UNSET", "PROFILE_CLASS_DEFAULT", "IMSI", "UICC_APPLICATIONS_ENABLED", "ALLOWED_NETWORK_TYPES", "SUB_DEFAULT_CHANGED_ACTION", "ACTION_DEFAULT_SUBSCRIPTION_CHANGED", "ACTION_DEFAULT_SMS_SUBSCRIPTION_CHANGED", "ACTION_MANAGE_SUBSCRIPTION_PLANS", "ACTION_REFRESH_SUBSCRIPTION_PLANS", "ACTION_SUBSCRIPTION_PLANS_CHANGED", "EXTRA_SUBSCRIPTION_INDEX", "EXTRA_SLOT_INDEX", "mContext", "sResourcesCache" ],
  "methodNames" : [ "public static Uri getUriForSubscriptionId(int subscriptionId)", "private NetworkPolicyManager getNetworkPolicyManager()", "public static SubscriptionManager from(Context context)", "public void addOnSubscriptionsChangedListener(OnSubscriptionsChangedListener listener)", "public void addOnSubscriptionsChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnSubscriptionsChangedListener listener)", "public void removeOnSubscriptionsChangedListener(OnSubscriptionsChangedListener listener)", "public void addOnOpportunisticSubscriptionsChangedListener(@NonNull @CallbackExecutor Executor executor, @NonNull OnOpportunisticSubscriptionsChangedListener listener)", "public void removeOnOpportunisticSubscriptionsChangedListener(@NonNull OnOpportunisticSubscriptionsChangedListener listener)", "public SubscriptionInfo getActiveSubscriptionInfo(int subId)", "public SubscriptionInfo getActiveSubscriptionInfoForIcc(@NonNull String iccId)", "public SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int slotIndex)", "public List<SubscriptionInfo> getAllSubscriptionInfoList()", "public List<SubscriptionInfo> getActiveSubscriptionInfoList()", "public List<SubscriptionInfo> getCompleteActiveSubscriptionInfoList()", "public List<SubscriptionInfo> getActiveSubscriptionInfoList(boolean userVisibleOnly)", "public List<SubscriptionInfo> getAvailableSubscriptionInfoList()", "public List<SubscriptionInfo> getAccessibleSubscriptionInfoList()", "public void requestEmbeddedSubscriptionInfoListRefresh()", "public void requestEmbeddedSubscriptionInfoListRefresh(int cardId)", "public int getAllSubscriptionInfoCount()", "public int getActiveSubscriptionInfoCount()", "public int getActiveSubscriptionInfoCountMax()", "public Uri addSubscriptionInfoRecord(String iccId, int slotIndex)", "public void addSubscriptionInfoRecord(String uniqueId, String displayName, int slotIndex, int subscriptionType)", "public void removeSubscriptionInfoRecord(String uniqueId, int subscriptionType)", "public int setIconTint(@ColorInt int tint, int subId)", "public int setDisplayName(@Nullable String displayName, int subId, @SimDisplayNameSource int nameSource)", "public int setDisplayNumber(String number, int subId)", "public int setDataRoaming(int roaming, int subId)", "public static int getSlotIndex(int subscriptionId)", "public int[] getSubscriptionIds(int slotIndex)", "public static int[] getSubId(int slotIndex)", "public static int getPhoneId(int subId)", "private static void logd(String msg)", "private static void loge(String msg)", "public static int getDefaultSubscriptionId()", "public static int getDefaultVoiceSubscriptionId()", "public void setDefaultVoiceSubscriptionId(int subscriptionId)", "public void setDefaultVoiceSubId(int subId)", "public SubscriptionInfo getDefaultVoiceSubscriptionInfo()", "public static int getDefaultVoicePhoneId()", "public static int getDefaultSmsSubscriptionId()", "public void setDefaultSmsSubId(int subscriptionId)", "public SubscriptionInfo getDefaultSmsSubscriptionInfo()", "public int getDefaultSmsPhoneId()", "public static int getDefaultDataSubscriptionId()", "public void setDefaultDataSubId(int subscriptionId)", "public SubscriptionInfo getDefaultDataSubscriptionInfo()", "public int getDefaultDataPhoneId()", "public void clearSubscriptionInfo()", "public boolean allDefaultsSelected()", "public static boolean isValidSubscriptionId(int subscriptionId)", "public static boolean isUsableSubscriptionId(int subscriptionId)", "public static boolean isUsableSubIdValue(int subId)", "public static boolean isValidSlotIndex(int slotIndex)", "public static boolean isValidPhoneId(int phoneId)", "public static void putPhoneIdAndSubIdExtra(Intent intent, int phoneId)", "public static void putPhoneIdAndSubIdExtra(Intent intent, int phoneId, int subId)", "public int[] getActiveSubscriptionIdList()", "public int[] getCompleteActiveSubscriptionIdList()", "public int[] getActiveSubscriptionIdList(boolean visibleOnly)", "public boolean isNetworkRoaming(int subId)", "public static int getSimStateForSlotIndex(int slotIndex)", "public static void setSubscriptionProperty(int subId, String propKey, String propValue)", "private static String getSubscriptionProperty(int subId, String propKey, Context context)", "public static boolean getBooleanSubscriptionProperty(int subId, String propKey, boolean defValue, Context context)", "public static int getIntegerSubscriptionProperty(int subId, String propKey, int defValue, Context context)", "public static long getLongSubscriptionProperty(int subId, String propKey, long defValue, Context context)", "public static Resources getResourcesForSubId(@NonNull Context context, int subId)", "public static Resources getResourcesForSubId(Context context, int subId, boolean useRootLocale)", "public boolean isActiveSubscriptionId(int subscriptionId)", "public boolean isActiveSubId(int subId)", "public List<SubscriptionPlan> getSubscriptionPlans(int subId)", "public void setSubscriptionPlans(int subId, @NonNull List<SubscriptionPlan> plans)", "public void setSubscriptionOverrideUnmetered(int subId, boolean overrideUnmetered, @DurationMillisLong long timeoutMillis)", "public void setSubscriptionOverrideCongested(int subId, boolean overrideCongested, @DurationMillisLong long timeoutMillis)", "public boolean canManageSubscription(SubscriptionInfo info)", "public boolean canManageSubscription(@NonNull SubscriptionInfo info, @NonNull String packageName)", "public void setPreferredDataSubscriptionId(int subId, boolean needValidation, @Nullable @CallbackExecutor Executor executor, @Nullable @TelephonyManager.SetOpportunisticSubscriptionResult Consumer<Integer> callback)", "public int getPreferredDataSubscriptionId()", "public List<SubscriptionInfo> getOpportunisticSubscriptions()", "public void switchToSubscription(int subId, @NonNull PendingIntent callbackIntent)", "public boolean setOpportunistic(boolean opportunistic, int subId)", "public ParcelUuid createSubscriptionGroup(@NonNull List<Integer> subIdList)", "public void addSubscriptionsIntoGroup(@NonNull List<Integer> subIdList, @NonNull ParcelUuid groupUuid)", "private boolean isSystemProcess()", "public void removeSubscriptionsFromGroup(@NonNull List<Integer> subIdList, @NonNull ParcelUuid groupUuid)", "public List<SubscriptionInfo> getSubscriptionsInGroup(@NonNull ParcelUuid groupUuid)", "public boolean isSubscriptionVisible(SubscriptionInfo info)", "public List<SubscriptionInfo> getSelectableSubscriptionInfoList()", "public boolean setSubscriptionEnabled(int subscriptionId, boolean enable)", "public void setUiccApplicationsEnabled(int subscriptionId, boolean enabled)", "public boolean canDisablePhysicalSubscription()", "public boolean isSubscriptionEnabled(int subscriptionId)", "public int getEnabledSubscriptionId(int slotIndex)", "private int setSubscriptionPropertyHelper(int subId, String methodName, CallISubMethodHelper helper)", "public static int getActiveDataSubscriptionId()", "public static void putSubscriptionIdExtra(Intent intent, int subId)", "public static void invalidateDefaultSubIdCaches()", "public static void invalidateDefaultDataSubIdCaches()", "public static void invalidateDefaultSmsSubIdCaches()", "public static void invalidateActiveDataSubIdCaches()", "public static void invalidateSlotIndexCaches()", "public static void disableCaching()", "public static void clearCaches()" ]
}