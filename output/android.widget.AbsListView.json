{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/widget/AbsListView.java",
  "packageName" : "android.widget",
  "className" : "AbsListView",
  "comment" : "\n * Base class that can be used to implement virtualized lists of items. A list does\n * not have a spatial definition here. For instance, subclasses of this class can\n * display the content of the list in a grid, in a carousel, as stack, etc.\n *\n * @attr ref android.R.styleable#AbsListView_listSelector\n * @attr ref android.R.styleable#AbsListView_drawSelectorOnTop\n * @attr ref android.R.styleable#AbsListView_stackFromBottom\n * @attr ref android.R.styleable#AbsListView_scrollingCache\n * @attr ref android.R.styleable#AbsListView_textFilterEnabled\n * @attr ref android.R.styleable#AbsListView_transcriptMode\n * @attr ref android.R.styleable#AbsListView_cacheColorHint\n * @attr ref android.R.styleable#AbsListView_fastScrollEnabled\n * @attr ref android.R.styleable#AbsListView_smoothScrollbar\n * @attr ref android.R.styleable#AbsListView_choiceMode\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TRANSCRIPT_MODE_DISABLED",
    "type" : "int",
    "comment" : "\n     * Disables the transcript mode.\n     *\n     * @see #setTranscriptMode(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSCRIPT_MODE_NORMAL",
    "type" : "int",
    "comment" : "\n     * The list will automatically scroll to the bottom when a data set change\n     * notification is received and only if the last item is already visible\n     * on screen.\n     *\n     * @see #setTranscriptMode(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "TRANSCRIPT_MODE_ALWAYS_SCROLL",
    "type" : "int",
    "comment" : "\n     * The list will automatically scroll to the bottom, no matter what items\n     * are currently visible.\n     *\n     * @see #setTranscriptMode(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "TOUCH_MODE_REST",
    "type" : "int",
    "comment" : "\n     * Indicates that we are not in the middle of a touch gesture\n     ",
    "links" : [ ]
  }, {
    "name" : "TOUCH_MODE_DOWN",
    "type" : "int",
    "comment" : "\n     * Indicates we just received the touch event and we are waiting to see if the it is a tap or a\n     * scroll gesture.\n     ",
    "links" : [ ]
  }, {
    "name" : "TOUCH_MODE_TAP",
    "type" : "int",
    "comment" : "\n     * Indicates the touch has been recognized as a tap and we are now waiting to see if the touch\n     * is a longpress\n     ",
    "links" : [ ]
  }, {
    "name" : "TOUCH_MODE_DONE_WAITING",
    "type" : "int",
    "comment" : "\n     * Indicates we have waited for everything we can wait for, but the user's finger is still down\n     ",
    "links" : [ ]
  }, {
    "name" : "TOUCH_MODE_SCROLL",
    "type" : "int",
    "comment" : "\n     * Indicates the touch gesture is a scroll\n     ",
    "links" : [ ]
  }, {
    "name" : "TOUCH_MODE_FLING",
    "type" : "int",
    "comment" : "\n     * Indicates the view is in the process of being flung\n     ",
    "links" : [ ]
  }, {
    "name" : "TOUCH_MODE_OVERSCROLL",
    "type" : "int",
    "comment" : "\n     * Indicates the touch gesture is an overscroll - a scroll beyond the beginning or end.\n     ",
    "links" : [ ]
  }, {
    "name" : "TOUCH_MODE_OVERFLING",
    "type" : "int",
    "comment" : "\n     * Indicates the view is being flung outside of normal content bounds\n     * and will spring back.\n     ",
    "links" : [ ]
  }, {
    "name" : "LAYOUT_NORMAL",
    "type" : "int",
    "comment" : "\n     * Regular layout - usually an unsolicited layout from the view system\n     ",
    "links" : [ ]
  }, {
    "name" : "LAYOUT_FORCE_TOP",
    "type" : "int",
    "comment" : "\n     * Show the first item\n     ",
    "links" : [ ]
  }, {
    "name" : "LAYOUT_SET_SELECTION",
    "type" : "int",
    "comment" : "\n     * Force the selected item to be on somewhere on the screen\n     ",
    "links" : [ ]
  }, {
    "name" : "LAYOUT_FORCE_BOTTOM",
    "type" : "int",
    "comment" : "\n     * Show the last item\n     ",
    "links" : [ ]
  }, {
    "name" : "LAYOUT_SPECIFIC",
    "type" : "int",
    "comment" : "\n     * Make a mSelectedItem appear in a specific location and build the rest of\n     * the views from there. The top is specified by mSpecificTop.\n     ",
    "links" : [ ]
  }, {
    "name" : "LAYOUT_SYNC",
    "type" : "int",
    "comment" : "\n     * Layout to sync as a result of a data change. Restore mSyncPosition to have its top\n     * at mSpecificTop\n     ",
    "links" : [ ]
  }, {
    "name" : "LAYOUT_MOVE_SELECTION",
    "type" : "int",
    "comment" : "\n     * Layout as a result of using the navigation keys\n     ",
    "links" : [ ]
  }, {
    "name" : "CHOICE_MODE_NONE",
    "type" : "int",
    "comment" : "\n     * Normal list that does not indicate choices\n     ",
    "links" : [ ]
  }, {
    "name" : "CHOICE_MODE_SINGLE",
    "type" : "int",
    "comment" : "\n     * The list allows up to one choice\n     ",
    "links" : [ ]
  }, {
    "name" : "CHOICE_MODE_MULTIPLE",
    "type" : "int",
    "comment" : "\n     * The list allows multiple choices\n     ",
    "links" : [ ]
  }, {
    "name" : "CHOICE_MODE_MULTIPLE_MODAL",
    "type" : "int",
    "comment" : "\n     * The list allows multiple choices in a modal selection mode\n     ",
    "links" : [ ]
  }, {
    "name" : "FLING_DESTRETCH_FACTOR",
    "type" : "float",
    "comment" : "\n     * When flinging the stretch towards scrolling content, it should destretch quicker than the\n     * fling would normally do. The visual effect of flinging the stretch looks strange as little\n     * appears to happen at first and then when the stretch disappears, the content starts\n     * scrolling quickly.\n     ",
    "links" : [ ]
  }, {
    "name" : "mOwnerThread",
    "type" : "Thread",
    "comment" : "\n     * The thread that created this view.\n     ",
    "links" : [ ]
  }, {
    "name" : "mChoiceMode",
    "type" : "int",
    "comment" : "\n     * Controls if/how the user may choose/check items in the list\n     ",
    "links" : [ ]
  }, {
    "name" : "mChoiceActionMode",
    "type" : "ActionMode",
    "comment" : "\n     * Controls CHOICE_MODE_MULTIPLE_MODAL. null when inactive.\n     ",
    "links" : [ ]
  }, {
    "name" : "mMultiChoiceModeCallback",
    "type" : "MultiChoiceModeWrapper",
    "comment" : "\n     * Wrapper for the multiple choice mode callback; AbsListView needs to perform\n     * a few extra actions around what application code does.\n     ",
    "links" : [ ]
  }, {
    "name" : "mCheckedItemCount",
    "type" : "int",
    "comment" : "\n     * Running count of how many items are currently checked\n     ",
    "links" : [ ]
  }, {
    "name" : "mCheckStates",
    "type" : "SparseBooleanArray",
    "comment" : "\n     * Running state of which positions are currently checked\n     ",
    "links" : [ ]
  }, {
    "name" : "mCheckedIdStates",
    "type" : "LongSparseArray<Integer>",
    "comment" : "\n     * Running state of which IDs are currently checked.\n     * If there is a value for a given key, the checked state for that ID is true\n     * and the value holds the last known position in the adapter for that id.\n     ",
    "links" : [ ]
  }, {
    "name" : "mLayoutMode",
    "type" : "int",
    "comment" : "\n     * Controls how the next layout will happen\n     ",
    "links" : [ ]
  }, {
    "name" : "mDataSetObserver",
    "type" : "AdapterDataSetObserver",
    "comment" : "\n     * Should be used by subclasses to listen to changes in the dataset\n     ",
    "links" : [ ]
  }, {
    "name" : "mAdapter",
    "type" : "ListAdapter",
    "comment" : "\n     * The adapter containing the data to be displayed by this view\n     ",
    "links" : [ ]
  }, {
    "name" : "mRemoteAdapter",
    "type" : "RemoteViewsAdapter",
    "comment" : "\n     * The remote adapter containing the data to be displayed by this view to be set\n     ",
    "links" : [ ]
  }, {
    "name" : "mAdapterHasStableIds",
    "type" : "boolean",
    "comment" : "\n     * If mAdapter != null, whenever this is true the adapter has stable IDs.\n     ",
    "links" : [ ]
  }, {
    "name" : "mDeferNotifyDataSetChanged",
    "type" : "boolean",
    "comment" : "\n     * This flag indicates the a full notify is required when the RemoteViewsAdapter connects\n     ",
    "links" : [ ]
  }, {
    "name" : "mDrawSelectorOnTop",
    "type" : "boolean",
    "comment" : "\n     * Indicates whether the list selector should be drawn on top of the children or behind\n     ",
    "links" : [ ]
  }, {
    "name" : "mSelector",
    "type" : "Drawable",
    "comment" : "\n     * The drawable used to draw the selector\n     ",
    "links" : [ ]
  }, {
    "name" : "mSelectorPosition",
    "type" : "int",
    "comment" : "\n     * The current position of the selector in the list.\n     ",
    "links" : [ ]
  }, {
    "name" : "mSelectorRect",
    "type" : "Rect",
    "comment" : "\n     * Defines the selector's location and dimension at drawing time\n     ",
    "links" : [ ]
  }, {
    "name" : "mRecycler",
    "type" : "RecycleBin",
    "comment" : "\n     * The data set used to store unused views that should be reused during the next layout\n     * to avoid creating new ones\n     ",
    "links" : [ ]
  }, {
    "name" : "mSelectionLeftPadding",
    "type" : "int",
    "comment" : "\n     * The selection's left padding\n     ",
    "links" : [ ]
  }, {
    "name" : "mSelectionTopPadding",
    "type" : "int",
    "comment" : "\n     * The selection's top padding\n     ",
    "links" : [ ]
  }, {
    "name" : "mSelectionRightPadding",
    "type" : "int",
    "comment" : "\n     * The selection's right padding\n     ",
    "links" : [ ]
  }, {
    "name" : "mSelectionBottomPadding",
    "type" : "int",
    "comment" : "\n     * The selection's bottom padding\n     ",
    "links" : [ ]
  }, {
    "name" : "mListPadding",
    "type" : "Rect",
    "comment" : "\n     * This view's padding\n     ",
    "links" : [ ]
  }, {
    "name" : "mWidthMeasureSpec",
    "type" : "int",
    "comment" : "\n     * Subclasses must retain their measure spec from onMeasure() into this member\n     ",
    "links" : [ ]
  }, {
    "name" : "mScrollUp",
    "type" : "View",
    "comment" : "\n     * The top scroll indicator\n     ",
    "links" : [ ]
  }, {
    "name" : "mScrollDown",
    "type" : "View",
    "comment" : "\n     * The down scroll indicator\n     ",
    "links" : [ ]
  }, {
    "name" : "mCachingStarted",
    "type" : "boolean",
    "comment" : "\n     * When the view is scrolling, this flag is set to true to indicate subclasses that\n     * the drawing cache was enabled on the children\n     ",
    "links" : [ ]
  }, {
    "name" : "mCachingActive",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMotionPosition",
    "type" : "int",
    "comment" : "\n     * The position of the view that received the down motion event\n     ",
    "links" : [ ]
  }, {
    "name" : "mMotionViewOriginalTop",
    "type" : "int",
    "comment" : "\n     * The offset to the top of the mMotionPosition view when the down motion event was received\n     ",
    "links" : [ ]
  }, {
    "name" : "mMotionViewNewTop",
    "type" : "int",
    "comment" : "\n     * The desired offset to the top of the mMotionPosition view after a scroll\n     ",
    "links" : [ ]
  }, {
    "name" : "mMotionX",
    "type" : "int",
    "comment" : "\n     * The X value associated with the down motion event\n     ",
    "links" : [ ]
  }, {
    "name" : "mMotionY",
    "type" : "int",
    "comment" : "\n     * The Y value associated with the down motion event\n     ",
    "links" : [ ]
  }, {
    "name" : "mTouchMode",
    "type" : "int",
    "comment" : "\n     * One of TOUCH_MODE_REST, TOUCH_MODE_DOWN, TOUCH_MODE_TAP, TOUCH_MODE_SCROLL, or\n     * TOUCH_MODE_DONE_WAITING\n     ",
    "links" : [ ]
  }, {
    "name" : "mLastY",
    "type" : "int",
    "comment" : "\n     * Y value from on the previous motion event (if any)\n     ",
    "links" : [ ]
  }, {
    "name" : "mMotionCorrection",
    "type" : "int",
    "comment" : "\n     * How far the finger moved before we started scrolling\n     ",
    "links" : [ ]
  }, {
    "name" : "mVelocityTracker",
    "type" : "VelocityTracker",
    "comment" : "\n     * Determines speed during touch scrolling\n     ",
    "links" : [ ]
  }, {
    "name" : "mFlingRunnable",
    "type" : "FlingRunnable",
    "comment" : "\n     * Handles one frame of a fling\n     *\n     * To interrupt a fling early you should use smoothScrollBy(0,0) instead\n     ",
    "links" : [ ]
  }, {
    "name" : "mPositionScroller",
    "type" : "AbsPositionScroller",
    "comment" : "\n     * Handles scrolling between positions within the list.\n     ",
    "links" : [ ]
  }, {
    "name" : "mSelectedTop",
    "type" : "int",
    "comment" : "\n     * The offset in pixels from the top of the AdapterView to the top\n     * of the currently selected view. Used to save and restore state.\n     ",
    "links" : [ ]
  }, {
    "name" : "mStackFromBottom",
    "type" : "boolean",
    "comment" : "\n     * Indicates whether the list is stacked from the bottom edge or\n     * the top edge.\n     ",
    "links" : [ ]
  }, {
    "name" : "mScrollingCacheEnabled",
    "type" : "boolean",
    "comment" : "\n     * When set to true, the list automatically discards the children's\n     * bitmap cache after scrolling.\n     ",
    "links" : [ ]
  }, {
    "name" : "mFastScrollEnabled",
    "type" : "boolean",
    "comment" : "\n     * Whether or not to enable the fast scroll feature on this list\n     ",
    "links" : [ ]
  }, {
    "name" : "mFastScrollAlwaysVisible",
    "type" : "boolean",
    "comment" : "\n     * Whether or not to always show the fast scroll feature on this list\n     ",
    "links" : [ ]
  }, {
    "name" : "mOnScrollListener",
    "type" : "OnScrollListener",
    "comment" : "\n     * Optional callback to notify client when scroll position has changed\n     ",
    "links" : [ ]
  }, {
    "name" : "mPopup",
    "type" : "PopupWindow",
    "comment" : "\n     * Keeps track of our accessory window\n     ",
    "links" : [ ]
  }, {
    "name" : "mTextFilter",
    "type" : "EditText",
    "comment" : "\n     * Used with type filter window\n     ",
    "links" : [ ]
  }, {
    "name" : "mSmoothScrollbarEnabled",
    "type" : "boolean",
    "comment" : "\n     * Indicates whether to use pixels-based or position-based scrollbar\n     * properties.\n     ",
    "links" : [ ]
  }, {
    "name" : "mTextFilterEnabled",
    "type" : "boolean",
    "comment" : "\n     * Indicates that this view supports filtering\n     ",
    "links" : [ ]
  }, {
    "name" : "mFiltered",
    "type" : "boolean",
    "comment" : "\n     * Indicates that this view is currently displaying a filtered view of the data\n     ",
    "links" : [ ]
  }, {
    "name" : "mTouchFrame",
    "type" : "Rect",
    "comment" : "\n     * Rectangle used for hit testing children\n     ",
    "links" : [ ]
  }, {
    "name" : "mResurrectToPosition",
    "type" : "int",
    "comment" : "\n     * The position to resurrect the selected position to.\n     ",
    "links" : [ ]
  }, {
    "name" : "mContextMenuInfo",
    "type" : "ContextMenuInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mOverscrollMax",
    "type" : "int",
    "comment" : "\n     * Maximum distance to record overscroll\n     ",
    "links" : [ ]
  }, {
    "name" : "OVERSCROLL_LIMIT_DIVISOR",
    "type" : "int",
    "comment" : "\n     * Content height divided by this is the overscroll limit.\n     ",
    "links" : [ ]
  }, {
    "name" : "CHECK_POSITION_SEARCH_DISTANCE",
    "type" : "int",
    "comment" : "\n     * How many positions in either direction we will search to try to\n     * find a checked item with a stable ID that moved position across\n     * a data set change. If the item isn't found it will be unselected.\n     ",
    "links" : [ ]
  }, {
    "name" : "TOUCH_MODE_UNKNOWN",
    "type" : "int",
    "comment" : "\n     * Used to request a layout when we changed touch mode\n     ",
    "links" : [ ]
  }, {
    "name" : "TOUCH_MODE_ON",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "TOUCH_MODE_OFF",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mLastTouchMode",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PROFILE_SCROLLING",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mScrollProfilingStarted",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PROFILE_FLINGING",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mFlingProfilingStarted",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mScrollStrictSpan",
    "type" : "StrictMode.Span",
    "comment" : "\n     * The StrictMode \"critical time span\" objects to catch animation\n     * stutters.  Non-null when a time-sensitive animation is\n     * in-flight.  Must call finish() on them when done animating.\n     * These are no-ops on user builds.\n     ",
    "links" : [ ]
  }, {
    "name" : "mFlingStrictSpan",
    "type" : "StrictMode.Span",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPendingCheckForLongPress",
    "type" : "CheckForLongPress",
    "comment" : "\n     * The last CheckForLongPress runnable we posted, if any\n     ",
    "links" : [ ]
  }, {
    "name" : "mPendingCheckForTap",
    "type" : "CheckForTap",
    "comment" : "\n     * The last CheckForTap runnable we posted, if any\n     ",
    "links" : [ ]
  }, {
    "name" : "mPendingCheckForKeyLongPress",
    "type" : "CheckForKeyLongPress",
    "comment" : "\n     * The last CheckForKeyLongPress runnable we posted, if any\n     ",
    "links" : [ ]
  }, {
    "name" : "mPerformClick",
    "type" : "AbsListView.PerformClick",
    "comment" : "\n     * Acts upon click\n     ",
    "links" : [ ]
  }, {
    "name" : "mTouchModeReset",
    "type" : "Runnable",
    "comment" : "\n     * Delayed action for touch mode.\n     ",
    "links" : [ ]
  }, {
    "name" : "mHasPerformedLongPress",
    "type" : "boolean",
    "comment" : "\n     * Whether the most recent touch event stream resulted in a successful\n     * long-press action. This is reset on TOUCH_DOWN.\n     ",
    "links" : [ ]
  }, {
    "name" : "mTranscriptMode",
    "type" : "int",
    "comment" : "\n     * This view is in transcript mode -- it shows the bottom of the list when the data\n     * changes\n     ",
    "links" : [ ]
  }, {
    "name" : "mCacheColorHint",
    "type" : "int",
    "comment" : "\n     * Indicates that this list is always drawn on top of a solid, single-color, opaque\n     * background\n     ",
    "links" : [ ]
  }, {
    "name" : "mIsChildViewEnabled",
    "type" : "boolean",
    "comment" : "\n     * The select child's view (from the adapter's getView) is enabled.\n     ",
    "links" : [ ]
  }, {
    "name" : "mSelectorState",
    "type" : "int[]",
    "comment" : "\n     * The cached drawable state for the selector. Accounts for child enabled\n     * state, but otherwise identical to the view's own drawable state.\n     ",
    "links" : [ ]
  }, {
    "name" : "mLastScrollState",
    "type" : "int",
    "comment" : "\n     * The last scroll state reported to clients through {@link OnScrollListener}.\n     ",
    "links" : [ "OnScrollListener" ]
  }, {
    "name" : "sContentCaptureReportingEnabledByDeviceConfig",
    "type" : "boolean",
    "comment" : "\n     * Indicates that reporting positions of child views to content capture is enabled via\n     * DeviceConfig.\n     ",
    "links" : [ ]
  }, {
    "name" : "sDeviceConfigChangeListener",
    "type" : "DeviceConfig.OnPropertiesChangedListener",
    "comment" : "\n     * Listens for changes to DeviceConfig properties and updates stored values accordingly.\n     ",
    "links" : [ ]
  }, {
    "name" : "mReportChildrenToContentCaptureOnNextUpdate",
    "type" : "boolean",
    "comment" : "\n     * Indicates that child positions of views should be reported to Content Capture the next time\n     * that active views are refreshed.\n     ",
    "links" : [ ]
  }, {
    "name" : "mFastScroll",
    "type" : "FastScroller",
    "comment" : "\n     * Helper object that renders and controls the fast scroll thumb.\n     ",
    "links" : [ ]
  }, {
    "name" : "mFastScrollStyle",
    "type" : "int",
    "comment" : "\n     * Temporary holder for fast scroller style until a FastScroller object\n     * is created.\n     ",
    "links" : [ ]
  }, {
    "name" : "mGlobalLayoutListenerAddedFilter",
    "type" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTouchSlop",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDensityScale",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mVerticalScrollFactor",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mDefInputConnection",
    "type" : "InputConnection",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPublicInputConnection",
    "type" : "InputConnectionWrapper",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mClearScrollingCache",
    "type" : "Runnable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mPositionScrollAfterLayout",
    "type" : "Runnable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMinimumVelocity",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mMaximumVelocity",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mVelocityScale",
    "type" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mIsScrap",
    "type" : "boolean[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mScrollOffset",
    "type" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mScrollConsumed",
    "type" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mTmpPoint",
    "type" : "float[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mNestedYOffset",
    "type" : "int",
    "comment" : " reads the raw screen-coordinate x/y values.",
    "links" : [ ]
  }, {
    "name" : "mPopupHidden",
    "type" : "boolean",
    "comment" : " dispatchDisplayHint()",
    "links" : [ ]
  }, {
    "name" : "mActivePointerId",
    "type" : "int",
    "comment" : "\n     * ID of the active pointer. This is used to retain consistency during\n     * drags/flings if multiple pointers are used.\n     ",
    "links" : [ ]
  }, {
    "name" : "INVALID_POINTER",
    "type" : "int",
    "comment" : "\n     * Sentinel value for no current active pointer.\n     * Used by {@link #mActivePointerId}.\n     ",
    "links" : [ "#mActivePointerId" ]
  }, {
    "name" : "mOverscrollDistance",
    "type" : "int",
    "comment" : "\n     * Maximum distance to overscroll by during edge effects\n     ",
    "links" : [ ]
  }, {
    "name" : "mOverflingDistance",
    "type" : "int",
    "comment" : "\n     * Maximum distance to overfling during edge effects\n     ",
    "links" : [ ]
  }, {
    "name" : "mEdgeGlowTop",
    "type" : "EdgeEffect",
    "comment" : "\n     * Tracks the state of the top edge glow.\n     *\n     * Even though this field is practically final, we cannot make it final because there are apps\n     * setting it via reflection and they need to keep working until they target Q.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "mEdgeGlowBottom",
    "type" : "EdgeEffect",
    "comment" : "\n     * Tracks the state of the bottom edge glow.\n     *\n     * Even though this field is practically final, we cannot make it final because there are apps\n     * setting it via reflection and they need to keep working until they target Q.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "mFirstPositionDistanceGuess",
    "type" : "int",
    "comment" : "\n     * An estimate of how many pixels are between the top of the list and\n     * the top of the first position in the adapter, based on the last time\n     * we saw it. Used to hint where to draw edge glows.\n     ",
    "links" : [ ]
  }, {
    "name" : "mLastPositionDistanceGuess",
    "type" : "int",
    "comment" : "\n     * An estimate of how many pixels are between the bottom of the list and\n     * the bottom of the last position in the adapter, based on the last time\n     * we saw it. Used to hint where to draw edge glows.\n     ",
    "links" : [ ]
  }, {
    "name" : "mDirection",
    "type" : "int",
    "comment" : "\n     * Used for determining when to cancel out of overscroll.\n     ",
    "links" : [ ]
  }, {
    "name" : "mForceTranscriptScroll",
    "type" : "boolean",
    "comment" : "\n     * Tracked on measurement in transcript mode. Makes sure that we can still pin to\n     * the bottom correctly on resizes.\n     ",
    "links" : [ ]
  }, {
    "name" : "mAccessibilityDelegate",
    "type" : "ListItemAccessibilityDelegate",
    "comment" : "\n     * Used for interacting with list items from an accessibility service.\n     ",
    "links" : [ ]
  }, {
    "name" : "mLastHandledItemCount",
    "type" : "int",
    "comment" : "\n     * Track the item count from the last time we handled a data change.\n     ",
    "links" : [ ]
  }, {
    "name" : "sLinearInterpolator",
    "type" : "Interpolator",
    "comment" : "\n     * Used for smooth scrolling at a consistent rate\n     ",
    "links" : [ ]
  }, {
    "name" : "mPendingSync",
    "type" : "SavedState",
    "comment" : "\n     * The saved state that we will be restoring from when we next sync.\n     * Kept here so that if we happen to be asked to save our state before\n     * the sync happens, we can return this existing data rather than losing\n     * it.\n     ",
    "links" : [ ]
  }, {
    "name" : "mIsDetaching",
    "type" : "boolean",
    "comment" : "\n     * Whether the view is in the process of detaching from its window.\n     ",
    "links" : [ ]
  }, {
    "name" : "mDifferentialMotionFlingHelper",
    "type" : "DifferentialMotionFlingHelper",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "mHapticScrollFeedbackProvider",
    "type" : "HapticScrollFeedbackProvider",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private static void setupDeviceConfigProperties()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void initAbsListView()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setAdapter(ListAdapter adapter)",
    "returnType" : "void",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getCheckedItemCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of items currently selected. This will only be valid\n     * if the choice mode is not {@link #CHOICE_MODE_NONE} (default).\n     *\n     * <p>To determine the specific items that are currently selected, use one of\n     * the <code>getChecked*</code> methods.\n     *\n     * @return The number of items currently selected\n     *\n     * @see #getCheckedItemPosition()\n     * @see #getCheckedItemPositions()\n     * @see #getCheckedItemIds()\n     ",
    "links" : [ "#CHOICE_MODE_NONE" ]
  }, {
    "name" : "public boolean isItemChecked(int position)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns the checked state of the specified position. The result is only\n     * valid if the choice mode has been set to {@link #CHOICE_MODE_SINGLE}\n     * or {@link #CHOICE_MODE_MULTIPLE}.\n     *\n     * @param position The item whose checked state to return\n     * @return The item's checked state or <code>false</code> if choice mode\n     *         is invalid\n     *\n     * @see #setChoiceMode(int)\n     ",
    "links" : [ "#CHOICE_MODE_SINGLE", "#CHOICE_MODE_MULTIPLE" ]
  }, {
    "name" : "public int getCheckedItemPosition()",
    "returnType" : "int",
    "comment" : "\n     * Returns the currently checked item. The result is only valid if the choice\n     * mode has been set to {@link #CHOICE_MODE_SINGLE}.\n     *\n     * @return The position of the currently checked item or\n     *         {@link #INVALID_POSITION} if nothing is selected\n     *\n     * @see #setChoiceMode(int)\n     ",
    "links" : [ "#CHOICE_MODE_SINGLE", "#INVALID_POSITION" ]
  }, {
    "name" : "public SparseBooleanArray getCheckedItemPositions()",
    "returnType" : "SparseBooleanArray",
    "comment" : "\n     * Returns the set of checked items in the list. The result is only valid if\n     * the choice mode has not been set to {@link #CHOICE_MODE_NONE}.\n     *\n     * @return  A SparseBooleanArray which will return true for each call to\n     *          get(int position) where position is a checked position in the\n     *          list and false otherwise, or <code>null</code> if the choice\n     *          mode is set to {@link #CHOICE_MODE_NONE}.\n     ",
    "links" : [ "#CHOICE_MODE_NONE" ]
  }, {
    "name" : "public long[] getCheckedItemIds()",
    "returnType" : "long[]",
    "comment" : "\n     * Returns the set of checked items ids. The result is only valid if the\n     * choice mode has not been set to {@link #CHOICE_MODE_NONE} and the adapter\n     * has stable IDs. ({@link ListAdapter#hasStableIds()} == {@code true})\n     *\n     * @return A new array which contains the id of each checked item in the\n     *         list.\n     ",
    "links" : [ "android.widget.ListAdapter#hasStableIds()", "#CHOICE_MODE_NONE" ]
  }, {
    "name" : "public void clearChoices()",
    "returnType" : "void",
    "comment" : "\n     * Clear any choices previously set\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setItemChecked(int position, boolean value)",
    "returnType" : "void",
    "comment" : "\n     * Sets the checked state of the specified position. The is only valid if\n     * the choice mode has been set to {@link #CHOICE_MODE_SINGLE} or\n     * {@link #CHOICE_MODE_MULTIPLE}.\n     *\n     * @param position The item whose checked state is to be checked\n     * @param value The new checked state for the item\n     ",
    "links" : [ "#CHOICE_MODE_SINGLE", "#CHOICE_MODE_MULTIPLE" ]
  }, {
    "name" : "public boolean performItemClick(View view, int position, long id)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void updateOnScreenCheckedViews()",
    "returnType" : "void",
    "comment" : "\n     * Perform a quick, in-place update of the checked or activated state\n     * on all visible item views. This should only be called when a valid\n     * choice mode is active.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getChoiceMode()",
    "returnType" : "int",
    "comment" : "\n     * @see #setChoiceMode(int)\n     *\n     * @return The current choice mode\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setChoiceMode(int choiceMode)",
    "returnType" : "void",
    "comment" : "\n     * Defines the choice behavior for the List. By default, Lists do not have any choice behavior\n     * ({@link #CHOICE_MODE_NONE}). By setting the choiceMode to {@link #CHOICE_MODE_SINGLE}, the\n     * List allows up to one item to  be in a chosen state. By setting the choiceMode to\n     * {@link #CHOICE_MODE_MULTIPLE}, the list allows any number of items to be chosen.\n     *\n     * @param choiceMode One of {@link #CHOICE_MODE_NONE}, {@link #CHOICE_MODE_SINGLE}, or\n     * {@link #CHOICE_MODE_MULTIPLE}\n     ",
    "links" : [ "#CHOICE_MODE_SINGLE", "#CHOICE_MODE_NONE", "#CHOICE_MODE_MULTIPLE" ]
  }, {
    "name" : "public void setMultiChoiceModeListener(MultiChoiceModeListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Set a {@link MultiChoiceModeListener} that will manage the lifecycle of the\n     * selection {@link ActionMode}. Only used when the choice mode is set to\n     * {@link #CHOICE_MODE_MULTIPLE_MODAL}.\n     *\n     * @param listener Listener that will manage the selection mode\n     *\n     * @see #setChoiceMode(int)\n     ",
    "links" : [ "android.view.ActionMode", "#CHOICE_MODE_MULTIPLE_MODAL", "MultiChoiceModeListener" ]
  }, {
    "name" : "private boolean contentFits()",
    "returnType" : "boolean",
    "comment" : "\n     * @return true if all list content currently fits within the view boundaries\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setFastScrollEnabled(final boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Specifies whether fast scrolling is enabled or disabled.\n     * <p>\n     * When fast scrolling is enabled, the user can quickly scroll through lists\n     * by dragging the fast scroll thumb.\n     * <p>\n     * If the adapter backing this list implements {@link SectionIndexer}, the\n     * fast scroller will display section header previews as the user scrolls.\n     * Additionally, the user will be able to quickly jump between sections by\n     * tapping along the length of the scroll bar.\n     *\n     * @see SectionIndexer\n     * @see #isFastScrollEnabled()\n     * @param enabled true to enable fast scrolling, false otherwise\n     ",
    "links" : [ "android.widget.SectionIndexer" ]
  }, {
    "name" : "private void setFastScrollerEnabledUiThread(boolean enabled)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setFastScrollStyle(int styleResId)",
    "returnType" : "void",
    "comment" : "\n     * Specifies the style of the fast scroller decorations.\n     *\n     * @param styleResId style resource containing fast scroller properties\n     * @see android.R.styleable#FastScroll\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setFastScrollAlwaysVisible(final boolean alwaysShow)",
    "returnType" : "void",
    "comment" : "\n     * Set whether or not the fast scroller should always be shown in place of\n     * the standard scroll bars. This will enable fast scrolling if it is not\n     * already enabled.\n     * <p>\n     * Fast scrollers shown in this way will not fade out and will be a\n     * permanent fixture within the list. This is best combined with an inset\n     * scroll bar style to ensure the scroll bar does not overlap content.\n     *\n     * @param alwaysShow true if the fast scroller should always be displayed,\n     *            false otherwise\n     * @see #setScrollBarStyle(int)\n     * @see #setFastScrollEnabled(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setFastScrollerAlwaysVisibleUiThread(boolean alwaysShow)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean isOwnerThread()",
    "returnType" : "boolean",
    "comment" : "\n     * @return whether the current thread is the one that created the view\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isFastScrollAlwaysVisible()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the fast scroller is set to always show on this view.\n     *\n     * @return true if the fast scroller will always show\n     * @see #setFastScrollAlwaysVisible(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getVerticalScrollbarWidth()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isFastScrollEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the fast scroller is enabled.\n     *\n     * @see #setFastScrollEnabled(boolean)\n     * @return true if fast scroll is enabled, false otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setVerticalScrollbarPosition(int position)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setScrollBarStyle(int style)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected boolean isVerticalScrollBarHidden()",
    "returnType" : "boolean",
    "comment" : "\n     * If fast scroll is enabled, then don't draw the vertical scrollbar.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSmoothScrollbarEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * When smooth scrollbar is enabled, the position and size of the scrollbar thumb\n     * is computed based on the number of visible pixels in the visible items. This\n     * however assumes that all list items have the same height. If you use a list in\n     * which items have different heights, the scrollbar will change appearance as the\n     * user scrolls through the list. To avoid this issue, you need to disable this\n     * property.\n     *\n     * When smooth scrollbar is disabled, the position and size of the scrollbar thumb\n     * is based solely on the number of items in the adapter and the position of the\n     * visible items inside the adapter. This provides a stable scrollbar as the user\n     * navigates through a list of items with varying heights.\n     *\n     * @param enabled Whether or not to enable smooth scrollbar.\n     *\n     * @see #setSmoothScrollbarEnabled(boolean)\n     * @attr ref android.R.styleable#AbsListView_smoothScrollbar\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isSmoothScrollbarEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns the current state of the fast scroll feature.\n     *\n     * @return True if smooth scrollbar is enabled is enabled, false otherwise.\n     *\n     * @see #setSmoothScrollbarEnabled(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setOnScrollListener(OnScrollListener l)",
    "returnType" : "void",
    "comment" : "\n     * Set the listener that will receive notifications every time the list scrolls.\n     *\n     * @param l the scroll listener\n     ",
    "links" : [ ]
  }, {
    "name" : " void invokeOnItemScrollListener()",
    "returnType" : "void",
    "comment" : "\n     * Notify our scroll listener (if there is one) of a change in scroll state\n     ",
    "links" : [ ]
  }, {
    "name" : "public CharSequence getAccessibilityClassName()",
    "returnType" : "CharSequence",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo info)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : " int getSelectionModeForAccessibility()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean performAccessibilityActionInternal(int action, Bundle arguments)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean isScrollingCacheEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates whether the children's drawing cache is used during a scroll.\n     * By default, the drawing cache is enabled but this will consume more memory.\n     *\n     * @return true if the scrolling cache is enabled, false otherwise\n     *\n     * @see #setScrollingCacheEnabled(boolean)\n     * @see View#setDrawingCacheEnabled(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setScrollingCacheEnabled(boolean enabled)",
    "returnType" : "void",
    "comment" : "\n     * Enables or disables the children's drawing cache during a scroll.\n     * By default, the drawing cache is enabled but this will use more memory.\n     *\n     * When the scrolling cache is enabled, the caches are kept after the\n     * first scrolling. You can manually clear the cache by calling\n     * {@link android.view.ViewGroup#setChildrenDrawingCacheEnabled(boolean)}.\n     *\n     * @param enabled true to enable the scroll cache, false otherwise\n     *\n     * @see #isScrollingCacheEnabled()\n     * @see View#setDrawingCacheEnabled(boolean)\n     ",
    "links" : [ "android.view.ViewGroup#setChildrenDrawingCacheEnabled(boolean)" ]
  }, {
    "name" : "public void setTextFilterEnabled(boolean textFilterEnabled)",
    "returnType" : "void",
    "comment" : "\n     * Enables or disables the type filter window. If enabled, typing when\n     * this view has focus will filter the children to match the users input.\n     * Note that the {@link Adapter} used by this view must implement the\n     * {@link Filterable} interface.\n     *\n     * @param textFilterEnabled true to enable type filtering, false otherwise\n     *\n     * @see Filterable\n     ",
    "links" : [ "android.widget.Adapter", "android.widget.Filterable" ]
  }, {
    "name" : "public boolean isTextFilterEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates whether type filtering is enabled for this view\n     *\n     * @return true if type filtering is enabled, false otherwise\n     *\n     * @see #setTextFilterEnabled(boolean)\n     * @see Filterable\n     ",
    "links" : [ ]
  }, {
    "name" : "public void getFocusedRect(Rect r)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void useDefaultSelector()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isStackFromBottom()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates whether the content of this view is pinned to, or stacked from,\n     * the bottom edge.\n     *\n     * @return true if the content is stacked from the bottom edge, false otherwise\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setStackFromBottom(boolean stackFromBottom)",
    "returnType" : "void",
    "comment" : "\n     * When stack from bottom is set to true, the list fills its content starting from\n     * the bottom of the view.\n     *\n     * @param stackFromBottom true to pin the view's content to the bottom edge,\n     *        false to pin the view's content to the top edge\n     ",
    "links" : [ ]
  }, {
    "name" : " void requestLayoutIfNecessary()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Parcelable onSaveInstanceState()",
    "returnType" : "Parcelable",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onRestoreInstanceState(Parcelable state)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean acceptFilter()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setFilterText(String filterText)",
    "returnType" : "void",
    "comment" : "\n     * Sets the initial value for the text filter.\n     * @param filterText The text to use for the filter.\n     *\n     * @see #setTextFilterEnabled\n     ",
    "links" : [ ]
  }, {
    "name" : "public CharSequence getTextFilter()",
    "returnType" : "CharSequence",
    "comment" : "\n     * Returns the list's text filter, if available.\n     * @return the list's text filter or null if filtering isn't enabled\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void onFocusChanged(boolean gainFocus, int direction, Rect previouslyFocusedRect)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void requestLayout()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void resetList()",
    "returnType" : "void",
    "comment" : "\n     * The list is empty. Clear everything out.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected int computeVerticalScrollExtent()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected int computeVerticalScrollOffset()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected int computeVerticalScrollRange()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected float getTopFadingEdgeStrength()",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected float getBottomFadingEdgeStrength()",
    "returnType" : "float",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void onLayout(boolean changed, int l, int t, int r, int b)",
    "returnType" : "void",
    "comment" : "\n     * Subclasses should NOT override this method but\n     *  {@link #layoutChildren()} instead.\n     ",
    "links" : [ "#layoutChildren()" ]
  }, {
    "name" : "protected boolean setFrame(int left, int top, int right, int bottom)",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void layoutChildren()",
    "returnType" : "void",
    "comment" : "\n     * Subclasses must override this method to layout their children.\n     ",
    "links" : [ ]
  }, {
    "name" : " View getAccessibilityFocusedChild(View focusedView)",
    "returnType" : "View",
    "comment" : "\n     * @param focusedView view that holds accessibility focus\n     * @return direct child that contains accessibility focus, or null if no\n     *         child contains accessibility focus\n     ",
    "links" : [ ]
  }, {
    "name" : " void updateScrollIndicators()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean canScrollUp()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean canScrollDown()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public View getSelectedView()",
    "returnType" : "View",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int getListPaddingTop()",
    "returnType" : "int",
    "comment" : "\n     * List padding is the maximum of the normal view's padding and the padding of the selector.\n     *\n     * @see android.view.View#getPaddingTop()\n     * @see #getSelector()\n     *\n     * @return The top list padding.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getListPaddingBottom()",
    "returnType" : "int",
    "comment" : "\n     * List padding is the maximum of the normal view's padding and the padding of the selector.\n     *\n     * @see android.view.View#getPaddingBottom()\n     * @see #getSelector()\n     *\n     * @return The bottom list padding.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getListPaddingLeft()",
    "returnType" : "int",
    "comment" : "\n     * List padding is the maximum of the normal view's padding and the padding of the selector.\n     *\n     * @see android.view.View#getPaddingLeft()\n     * @see #getSelector()\n     *\n     * @return The left list padding.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getListPaddingRight()",
    "returnType" : "int",
    "comment" : "\n     * List padding is the maximum of the normal view's padding and the padding of the selector.\n     *\n     * @see android.view.View#getPaddingRight()\n     * @see #getSelector()\n     *\n     * @return The right list padding.\n     ",
    "links" : [ ]
  }, {
    "name" : " View obtainView(int position, boolean[] outMetadata)",
    "returnType" : "View",
    "comment" : "\n     * Gets a view and have it show the data associated with the specified\n     * position. This is called when we have already discovered that the view\n     * is not available for reuse in the recycle bin. The only choices left are\n     * converting an old view or making a new one.\n     *\n     * @param position the position to display\n     * @param outMetadata an array of at least 1 boolean where the first entry\n     *                    will be set {@code true} if the view is currently\n     *                    attached to the window, {@code false} otherwise (e.g.\n     *                    newly-inflated or remained scrap for multiple layout\n     *                    passes)\n     *\n     * @return A view displaying the data associated with the specified position\n     ",
    "links" : [ ]
  }, {
    "name" : "private void setItemViewLayoutParams(View child, int position)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onInitializeAccessibilityNodeInfoForItem(View view, int position, AccessibilityNodeInfo info)",
    "returnType" : "void",
    "comment" : "\n     * Initializes an {@link AccessibilityNodeInfo} with information about a\n     * particular item in the list.\n     *\n     * @param view View representing the list item.\n     * @param position Position of the list item within the adapter.\n     * @param info Node info to populate.\n     ",
    "links" : [ "android.view.accessibility.AccessibilityNodeInfo" ]
  }, {
    "name" : "private void addAccessibilityActionIfEnabled(AccessibilityNodeInfo info, boolean enabled, AccessibilityAction action)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean isItemClickable(View view)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void positionSelectorLikeTouch(int position, View sel, float x, float y)",
    "returnType" : "void",
    "comment" : "\n     * Positions the selector in a way that mimics touch.\n     ",
    "links" : [ ]
  }, {
    "name" : " void positionSelectorLikeFocus(int position, View sel)",
    "returnType" : "void",
    "comment" : "\n     * Positions the selector in a way that mimics keyboard focus.\n     ",
    "links" : [ ]
  }, {
    "name" : " void positionSelector(int position, View sel)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void positionSelector(int position, View sel, boolean manageHotspot, float x, float y)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean isSelectedChildViewEnabled()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the selected child view (from the adapter's getView) is enabled.\n     *\n     * @return true if enabled\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSelectedChildViewEnabled(boolean selectedChildViewEnabled)",
    "returnType" : "void",
    "comment" : "\n     * Set whether the selected child view (from the adapter's getView) is enabled.\n     *\n     * When refreshDrawableState is called, AbsListView will control the \"enabled\" state\n     * of the selector based on this.\n     *\n     * @param selectedChildViewEnabled true if enabled\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void dispatchDraw(Canvas canvas)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected boolean isPaddingOffsetRequired()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected int getLeftPaddingOffset()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected int getTopPaddingOffset()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected int getRightPaddingOffset()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected int getBottomPaddingOffset()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void internalSetPadding(int left, int top, int right, int bottom)",
    "returnType" : "void",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void onSizeChanged(int w, int h, int oldw, int oldh)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void handleBoundsChange()",
    "returnType" : "void",
    "comment" : "\n     * Called when bounds of the AbsListView are changed. AbsListView marks data set as changed\n     * and force layouts all children that don't have exact measure specs.\n     * <p>\n     * This invalidation is necessary, otherwise, AbsListView may think the children are valid and\n     * fail to relayout them properly to accommodate for new bounds.\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean touchModeDrawsInPressedState()",
    "returnType" : "boolean",
    "comment" : "\n     * @return True if the current touch mode requires that we draw the selector in the pressed\n     *         state.\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean shouldShowSelector()",
    "returnType" : "boolean",
    "comment" : "\n     * Indicates whether this view is in a state where the selector should be drawn. This will\n     * happen if we have focus but are not in touch mode, or we are in the middle of displaying\n     * the pressed state for an item.\n     *\n     * @return True if the selector should be shown\n     ",
    "links" : [ ]
  }, {
    "name" : "private void drawSelector(Canvas canvas)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public final boolean shouldDrawSelector()",
    "returnType" : "boolean",
    "comment" : "\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setDrawSelectorOnTop(boolean onTop)",
    "returnType" : "void",
    "comment" : "\n     * Controls whether the selection highlight drawable should be drawn on top of the item or\n     * behind it.\n     *\n     * @param onTop If true, the selector will be drawn on the item it is highlighting. The default\n     *        is false.\n     *\n     * @attr ref android.R.styleable#AbsListView_drawSelectorOnTop\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isDrawSelectorOnTop()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether the selection highlight drawable should be drawn on top of the item or\n     * behind it.\n     *\n     * @return true if selector is drawn on top, false otherwise\n     * @attr ref android.R.styleable#AbsListView_drawSelectorOnTop\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSelector(@DrawableRes int resID)",
    "returnType" : "void",
    "comment" : "\n     * Set a Drawable that should be used to highlight the currently selected item.\n     *\n     * @param resID A Drawable resource to use as the selection highlight.\n     *\n     * @attr ref android.R.styleable#AbsListView_listSelector\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSelector(Drawable sel)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public Drawable getSelector()",
    "returnType" : "Drawable",
    "comment" : "\n     * Returns the selector {@link android.graphics.drawable.Drawable} that is used to draw the\n     * selection in the list.\n     *\n     * @return the drawable used to display the selector\n     ",
    "links" : [ "android.graphics.drawable.Drawable" ]
  }, {
    "name" : " void keyPressed()",
    "returnType" : "void",
    "comment" : "\n     * Sets the selector state to \"pressed\" and posts a CheckForKeyLongPress to see if\n     * this is a long press.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setScrollIndicators(View up, View down)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void updateSelectorState()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void drawableStateChanged()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int[] getDrawableStateForSelector()",
    "returnType" : "int[]",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean verifyDrawable(@NonNull Drawable dr)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void jumpDrawablesToCurrentState()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void onAttachedToWindow()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void onDetachedFromWindow()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onWindowFocusChanged(boolean hasWindowFocus)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onRtlPropertiesChanged(int layoutDirection)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " ContextMenuInfo createContextMenuInfo(View view, int position, long id)",
    "returnType" : "ContextMenuInfo",
    "comment" : "\n     * Creates the ContextMenuInfo returned from {@link #getContextMenuInfo()}. This\n     * methods knows the view, position and ID of the item that received the\n     * long press.\n     *\n     * @param view The view that received the long press.\n     * @param position The position of the item that received the long press.\n     * @param id The ID of the item that received the long press.\n     * @return The extra information that should be returned by\n     *         {@link #getContextMenuInfo()}.\n     ",
    "links" : [ "#getContextMenuInfo()" ]
  }, {
    "name" : "public void onCancelPendingInputEvents()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean performStylusButtonPressAction(MotionEvent ev)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean performLongPress(final View child, final int longPressPosition, final long longPressId)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean performLongPress(final View child, final int longPressPosition, final long longPressId, float x, float y)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected ContextMenuInfo getContextMenuInfo()",
    "returnType" : "ContextMenuInfo",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean showContextMenu()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean showContextMenu(float x, float y)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean showContextMenuInternal(float x, float y, boolean useOffsets)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean showContextMenuForChild(View originalView)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean showContextMenuForChild(View originalView, float x, float y)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean showContextMenuForChildInternal(View originalView, float x, float y, boolean useOffsets)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean onKeyDown(int keyCode, KeyEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean onKeyUp(int keyCode, KeyEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void dispatchSetPressed(boolean pressed)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void dispatchDrawableHotspotChanged(float x, float y)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public int pointToPosition(int x, int y)",
    "returnType" : "int",
    "comment" : "\n     * Maps a point to a position in the list.\n     *\n     * @param x X in local coordinate\n     * @param y Y in local coordinate\n     * @return The position of the item which contains the specified point, or\n     *         {@link #INVALID_POSITION} if the point does not intersect an item.\n     ",
    "links" : [ "#INVALID_POSITION" ]
  }, {
    "name" : "public long pointToRowId(int x, int y)",
    "returnType" : "long",
    "comment" : "\n     * Maps a point to a the rowId of the item which intersects that point.\n     *\n     * @param x X in local coordinate\n     * @param y Y in local coordinate\n     * @return The rowId of the item which contains the specified point, or {@link #INVALID_ROW_ID}\n     *         if the point does not intersect an item.\n     ",
    "links" : [ "#INVALID_ROW_ID" ]
  }, {
    "name" : "private boolean startScrollIfNeeded(int x, int y, MotionEvent vtev)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void scrollIfNeeded(int x, int y, MotionEvent vtev)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int releaseGlow(int deltaY, int x)",
    "returnType" : "int",
    "comment" : "\n     * If the edge glow is currently active, this consumes part or all of deltaY\n     * on the edge glow.\n     *\n     * @param deltaY The pointer motion, in pixels, in the vertical direction, positive\n     *                         for moving down and negative for moving up.\n     * @param x The horizontal position of the pointer.\n     * @return The remainder of <code>deltaY</code> that has not been consumed by the\n     * edge glow.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean doesTouchStopStretch()",
    "returnType" : "boolean",
    "comment" : "\n     * @return <code>true</code> if either the top or bottom edge glow is currently active or\n     * <code>false</code> if it has no value to release.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void invalidateEdgeEffects()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onTouchModeChanged(boolean isInTouchMode)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected boolean handleScrollBarDragging(MotionEvent event)",
    "returnType" : "boolean",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "public boolean onTouchEvent(MotionEvent ev)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void onTouchDown(MotionEvent ev)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void stopEdgeGlowRecede(float x)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void onTouchMove(MotionEvent ev, MotionEvent vtev)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void onTouchUp(MotionEvent ev)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private boolean shouldAbsorb(EdgeEffect edgeEffect, int velocity)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if edgeEffect should call onAbsorb() with veclocity or false if it should\n     * animate with a fling. It will animate with a fling if the velocity will remove the\n     * EdgeEffect through its normal operation.\n     *\n     * @param edgeEffect The EdgeEffect that might absorb the velocity.\n     * @param velocity The velocity of the fling motion\n     * @return true if the velocity should be absorbed or false if it should be flung.\n     ",
    "links" : [ ]
  }, {
    "name" : "private int consumeFlingInStretch(int unconsumed)",
    "returnType" : "int",
    "comment" : "\n     * Used by consumeFlingInHorizontalStretch() and consumeFlinInVerticalStretch() for\n     * consuming deltas from EdgeEffects\n     * @param unconsumed The unconsumed delta that the EdgeEffets may consume\n     * @return The unconsumed delta after the EdgeEffects have had an opportunity to consume.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean shouldDisplayEdgeEffects()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void onTouchCancel()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void onOverScrolled(int scrollX, int scrollY, boolean clampedX, boolean clampedY)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean onGenericMotionEvent(MotionEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void fling(int velocityY)",
    "returnType" : "void",
    "comment" : "\n     * Initiate a fling with the given velocity.\n     *\n     * <p>Applications can use this method to manually initiate a fling as if the user\n     * initiated it via touch interaction.</p>\n     *\n     * @param velocityY Vertical velocity in pixels per second. Note that this is velocity of\n     *                  content, not velocity of a touch that initiated the fling.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onNestedScrollAccepted(View child, View target, int axes)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void draw(Canvas canvas)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void initOrResetVelocityTracker()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void initVelocityTrackerIfNotExists()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void initDifferentialFlingHelperIfNotExists()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void initHapticScrollFeedbackProviderIfNotExists()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void recycleVelocityTracker()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void requestDisallowInterceptTouchEvent(boolean disallowIntercept)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean onInterceptHoverEvent(MotionEvent event)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public PointerIcon onResolvePointerIcon(MotionEvent event, int pointerIndex)",
    "returnType" : "PointerIcon",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean onInterceptTouchEvent(MotionEvent ev)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void onSecondaryPointerUp(MotionEvent ev)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void addTouchables(ArrayList<View> views)",
    "returnType" : "void",
    "comment" : "\n     * {@inheritDoc}\n     ",
    "links" : [ ]
  }, {
    "name" : " void reportScrollStateChange(int newState)",
    "returnType" : "void",
    "comment" : "\n     * Fires an \"on scroll state changed\" event to the registered\n     * {@link android.widget.AbsListView.OnScrollListener}, if any. The state change\n     * is fired only if the specified state is different from the previously known state.\n     *\n     * @param newState The new scroll state.\n     ",
    "links" : [ "android.widget.AbsListView.OnScrollListener" ]
  }, {
    "name" : "public void setFriction(float friction)",
    "returnType" : "void",
    "comment" : "\n     * The amount of friction applied to flings. The default value\n     * is {@link ViewConfiguration#getScrollFriction}.\n     ",
    "links" : [ "android.view.ViewConfiguration#getScrollFriction" ]
  }, {
    "name" : "public void setVelocityScale(float scale)",
    "returnType" : "void",
    "comment" : "\n     * Sets a scale factor for the fling velocity. The initial scale\n     * factor is 1.0.\n     *\n     * @param scale The scale factor to multiply the velocity by.\n     ",
    "links" : [ ]
  }, {
    "name" : " AbsPositionScroller createPositionScroller()",
    "returnType" : "AbsPositionScroller",
    "comment" : "\n     * Override this for better control over position scrolling.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void smoothScrollToPosition(int position)",
    "returnType" : "void",
    "comment" : "\n     * Smoothly scroll to the specified adapter position. The view will\n     * scroll such that the indicated position is displayed.\n     * @param position Scroll to this adapter position.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void smoothScrollToPositionFromTop(int position, int offset, int duration)",
    "returnType" : "void",
    "comment" : "\n     * Smoothly scroll to the specified adapter position. The view will scroll\n     * such that the indicated position is displayed <code>offset</code> pixels below\n     * the top edge of the view. If this is impossible, (e.g. the offset would scroll\n     * the first or last item beyond the boundaries of the list) it will get as close\n     * as possible. The scroll will take <code>duration</code> milliseconds to complete.\n     *\n     * @param position Position to scroll to\n     * @param offset Desired distance in pixels of <code>position</code> from the top\n     *               of the view when scrolling is finished\n     * @param duration Number of milliseconds to use for the scroll\n     ",
    "links" : [ ]
  }, {
    "name" : "public void smoothScrollToPositionFromTop(int position, int offset)",
    "returnType" : "void",
    "comment" : "\n     * Smoothly scroll to the specified adapter position. The view will scroll\n     * such that the indicated position is displayed <code>offset</code> pixels below\n     * the top edge of the view. If this is impossible, (e.g. the offset would scroll\n     * the first or last item beyond the boundaries of the list) it will get as close\n     * as possible.\n     *\n     * @param position Position to scroll to\n     * @param offset Desired distance in pixels of <code>position</code> from the top\n     *               of the view when scrolling is finished\n     ",
    "links" : [ ]
  }, {
    "name" : "public void smoothScrollToPosition(int position, int boundPosition)",
    "returnType" : "void",
    "comment" : "\n     * Smoothly scroll to the specified adapter position. The view will\n     * scroll such that the indicated position is displayed, but it will\n     * stop early if scrolling further would scroll boundPosition out of\n     * view.\n     *\n     * @param position Scroll to this adapter position.\n     * @param boundPosition Do not scroll if it would move this adapter\n     *          position out of view.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void smoothScrollBy(int distance, int duration)",
    "returnType" : "void",
    "comment" : "\n     * Smoothly scroll by distance pixels over duration milliseconds.\n     * @param distance Distance to scroll in pixels.\n     * @param duration Duration of the scroll animation in milliseconds.\n     ",
    "links" : [ ]
  }, {
    "name" : " void smoothScrollBy(int distance, int duration, boolean linear, boolean suppressEndFlingStateChangeCall)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void smoothScrollByOffset(int position)",
    "returnType" : "void",
    "comment" : "\n     * Allows RemoteViews to scroll relatively to a position.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void createScrollingCache()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void clearScrollingCache()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void scrollListBy(int y)",
    "returnType" : "void",
    "comment" : "\n     * Scrolls the list items within the view by a specified number of pixels.\n     *\n     * <p>The actual amount of scroll is capped by the list content viewport height\n     * which is the list height minus top and bottom paddings minus one pixel.</p>\n     *\n     * @param y the amount of pixels to scroll by vertically\n     * @see #canScrollList(int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean canScrollList(int direction)",
    "returnType" : "boolean",
    "comment" : "\n     * Check if the items in the list can be scrolled in a certain direction.\n     *\n     * @param direction Negative to check scrolling up, positive to check\n     *            scrolling down.\n     * @return true if the list can be scrolled in the specified direction,\n     *         false otherwise.\n     * @see #scrollListBy(int)\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean trackMotionScroll(int deltaY, int incrementalDeltaY)",
    "returnType" : "boolean",
    "comment" : "\n     * Track a motion scroll\n     *\n     * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motion\n     *        began. Positive numbers mean the user's finger is moving down the screen.\n     * @param incrementalDeltaY Change in deltaY from the previous event.\n     * @return true if we're already at the beginning/end of the list and have nothing to do.\n     ",
    "links" : [ ]
  }, {
    "name" : " int getHeaderViewsCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of header views in the list. Header views are special views\n     * at the top of the list that should not be recycled during a layout.\n     *\n     * @return The number of header views, 0 in the default implementation.\n     ",
    "links" : [ ]
  }, {
    "name" : " int getFooterViewsCount()",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of footer views in the list. Footer views are special views\n     * at the bottom of the list that should not be recycled during a layout.\n     *\n     * @return The number of footer views, 0 in the default implementation.\n     ",
    "links" : [ ]
  }, {
    "name" : " abstract void fillGap(boolean down)",
    "returnType" : "void",
    "comment" : "\n     * Fills the gap left open by a touch-scroll. During a touch scroll, children that\n     * remain on screen are shifted and the other ones are discarded. The role of this\n     * method is to fill the gap thus created by performing a partial layout in the\n     * empty space.\n     *\n     * @param down true if the scroll is going down, false if it is going up\n     ",
    "links" : [ ]
  }, {
    "name" : " void hideSelector()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " int reconcileSelectedPosition()",
    "returnType" : "int",
    "comment" : "\n     * @return A position to select. First we try mSelectedPosition. If that has been clobbered by\n     * entering touch mode, we then try mResurrectToPosition. Values are pinned to the range\n     * of items available in the adapter\n     ",
    "links" : [ ]
  }, {
    "name" : " abstract int findMotionRow(int y)",
    "returnType" : "int",
    "comment" : "\n     * Find the row closest to y. This row will be used as the motion row when scrolling\n     *\n     * @param y Where the user touched\n     * @return The position of the first (or only) item in the row containing y\n     ",
    "links" : [ ]
  }, {
    "name" : " int findClosestMotionRow(int y)",
    "returnType" : "int",
    "comment" : "\n     * Find the row closest to y. This row will be used as the motion row when scrolling.\n     *\n     * @param y Where the user touched\n     * @return The position of the first (or only) item in the row closest to y\n     ",
    "links" : [ ]
  }, {
    "name" : "public void invalidateViews()",
    "returnType" : "void",
    "comment" : "\n     * Causes all the views to be rebuilt and redrawn.\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean resurrectSelectionIfNeeded()",
    "returnType" : "boolean",
    "comment" : "\n     * If there is a selection returns false.\n     * Otherwise resurrects the selection and returns true if resurrected.\n     ",
    "links" : [ ]
  }, {
    "name" : " abstract void setSelectionInt(int position)",
    "returnType" : "void",
    "comment" : "\n     * Makes the item at the supplied position selected.\n     *\n     * @param position the position of the new selection\n     ",
    "links" : [ ]
  }, {
    "name" : " boolean resurrectSelection()",
    "returnType" : "boolean",
    "comment" : "\n     * Attempt to bring the selection back if the user is switching from touch\n     * to trackball mode\n     * @return Whether selection was set to something.\n     ",
    "links" : [ ]
  }, {
    "name" : " void confirmCheckedPositionsById()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void handleDataChanged()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected void onDisplayHint(int hint)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private void dismissPopup()",
    "returnType" : "void",
    "comment" : "\n     * Removes the filter window\n     ",
    "links" : [ ]
  }, {
    "name" : "private void showPopup()",
    "returnType" : "void",
    "comment" : "\n     * Shows the filter window\n     ",
    "links" : [ ]
  }, {
    "name" : "private void positionPopup()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " static int getDistance(Rect source, Rect dest, int direction)",
    "returnType" : "int",
    "comment" : "\n     * What is the distance between the source and destination rectangles given the direction of\n     * focus navigation between them? The direction basically helps figure out more quickly what is\n     * self evident by the relationship between the rects...\n     *\n     * @param source the source rectangle\n     * @param dest the destination rectangle\n     * @param direction the direction\n     * @return the distance between the rectangles\n     ",
    "links" : [ ]
  }, {
    "name" : "protected boolean isInFilterMode()",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " boolean sendToTextFilter(int keyCode, int count, KeyEvent event)",
    "returnType" : "boolean",
    "comment" : "\n     * Sends a key to the text filter window\n     *\n     * @param keyCode The keycode for the event\n     * @param event The actual key event\n     *\n     * @return True if the text filter handled the event, false otherwise.\n     ",
    "links" : [ ]
  }, {
    "name" : "public InputConnection onCreateInputConnection(EditorInfo outAttrs)",
    "returnType" : "InputConnection",
    "comment" : "\n     * Return an InputConnection for editing of the filter text.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean checkInputConnectionProxy(View view)",
    "returnType" : "boolean",
    "comment" : "\n     * For filtering we proxy an input connection to an internal text editor,\n     * and this allows the proxying to happen.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void createTextFilter(boolean animateEntrance)",
    "returnType" : "void",
    "comment" : "\n     * Creates the window for the text filter and populates it with an EditText field;\n     *\n     * @param animateEntrance true if the window should appear with an animation\n     ",
    "links" : [ ]
  }, {
    "name" : "private EditText getTextFilterInput()",
    "returnType" : "EditText",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void clearTextFilter()",
    "returnType" : "void",
    "comment" : "\n     * Clear the text filter.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean hasTextFilter()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns if the ListView currently has a text filter.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onGlobalLayout()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void beforeTextChanged(CharSequence s, int start, int count, int after)",
    "returnType" : "void",
    "comment" : "\n     * For our text watcher that is associated with the text filter.  Does\n     * nothing.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onTextChanged(CharSequence s, int start, int before, int count)",
    "returnType" : "void",
    "comment" : "\n     * For our text watcher that is associated with the text filter. Performs\n     * the actual filtering as the text changes, and takes care of hiding and\n     * showing the popup displaying the currently entered filter text.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void afterTextChanged(Editable s)",
    "returnType" : "void",
    "comment" : "\n     * For our text watcher that is associated with the text filter.  Does\n     * nothing.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onFilterComplete(int count)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected ViewGroup.LayoutParams generateDefaultLayoutParams()",
    "returnType" : "ViewGroup.LayoutParams",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p)",
    "returnType" : "ViewGroup.LayoutParams",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public LayoutParams generateLayoutParams(AttributeSet attrs)",
    "returnType" : "LayoutParams",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "protected boolean checkLayoutParams(ViewGroup.LayoutParams p)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setTranscriptMode(int mode)",
    "returnType" : "void",
    "comment" : "\n     * Puts the list or grid into transcript mode. In this mode the list or grid will always scroll\n     * to the bottom to show new items.\n     *\n     * @param mode the transcript mode to set\n     *\n     * @see #TRANSCRIPT_MODE_DISABLED\n     * @see #TRANSCRIPT_MODE_NORMAL\n     * @see #TRANSCRIPT_MODE_ALWAYS_SCROLL\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getTranscriptMode()",
    "returnType" : "int",
    "comment" : "\n     * Returns the current transcript mode.\n     *\n     * @return {@link #TRANSCRIPT_MODE_DISABLED}, {@link #TRANSCRIPT_MODE_NORMAL} or\n     *         {@link #TRANSCRIPT_MODE_ALWAYS_SCROLL}\n     ",
    "links" : [ "#TRANSCRIPT_MODE_DISABLED", "#TRANSCRIPT_MODE_NORMAL", "#TRANSCRIPT_MODE_ALWAYS_SCROLL" ]
  }, {
    "name" : "public int getSolidColor()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setCacheColorHint(@ColorInt int color)",
    "returnType" : "void",
    "comment" : "\n     * When set to a non-zero value, the cache color hint indicates that this list is always drawn\n     * on top of a solid, single-color, opaque background.\n     *\n     * Zero means that what's behind this object is translucent (non solid) or is not made of a\n     * single color. This hint will not affect any existing background drawable set on this view (\n     * typically set via {@link #setBackgroundDrawable(Drawable)}).\n     *\n     * @param color The background color\n     ",
    "links" : [ "#setBackgroundDrawable(Drawable)" ]
  }, {
    "name" : "public int getCacheColorHint()",
    "returnType" : "int",
    "comment" : "\n     * When set to a non-zero value, the cache color hint indicates that this list is always drawn\n     * on top of a solid, single-color, opaque background\n     *\n     * @return The cache color hint\n     ",
    "links" : [ ]
  }, {
    "name" : "public void reclaimViews(List<View> views)",
    "returnType" : "void",
    "comment" : "\n     * Move all views (excluding headers and footers) held by this AbsListView into the supplied\n     * List. This includes views displayed on the screen as well as views stored in AbsListView's\n     * internal view recycler.\n     *\n     * @param views A list into which to put the reclaimed views\n     ",
    "links" : [ ]
  }, {
    "name" : "private void finishGlows()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public void setRemoteViewsAdapter(Intent intent)",
    "returnType" : "void",
    "comment" : "\n     * Sets up this AbsListView to use a remote views adapter which connects to a RemoteViewsService\n     * through the specified intent.\n     * @param intent the intent used to identify the RemoteViewsService for the adapter to connect to.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Runnable setRemoteViewsAdapterAsync(final Intent intent)",
    "returnType" : "Runnable",
    "comment" : " @hide *",
    "links" : [ ]
  }, {
    "name" : "public void setRemoteViewsAdapter(Intent intent, boolean isAsync)",
    "returnType" : "void",
    "comment" : " @hide *",
    "links" : [ ]
  }, {
    "name" : "public void setRemoteViewsInteractionHandler(InteractionHandler handler)",
    "returnType" : "void",
    "comment" : "\n     * Sets up the onClickHandler to be used by the RemoteViewsAdapter when inflating RemoteViews\n     *\n     * @param handler The OnClickHandler to use when inflating RemoteViews.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void deferNotifyDataSetChanged()",
    "returnType" : "void",
    "comment" : "\n     * This defers a notifyDataSetChanged on the pending RemoteViewsAdapter if it has not\n     * connected yet.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean onRemoteAdapterConnected()",
    "returnType" : "boolean",
    "comment" : "\n     * Called back when the adapter connects to the RemoteViewsService.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onRemoteAdapterDisconnected()",
    "returnType" : "void",
    "comment" : "\n     * Called back when the adapter disconnects from the RemoteViewsService.\n     ",
    "links" : [ ]
  }, {
    "name" : " void setVisibleRangeHint(int start, int end)",
    "returnType" : "void",
    "comment" : "\n     * Hints the RemoteViewsAdapter, if it exists, about which views are currently\n     * being displayed by the AbsListView.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setEdgeEffectColor(@ColorInt int color)",
    "returnType" : "void",
    "comment" : "\n     * Sets the edge effect color for both top and bottom edge effects.\n     *\n     * @param color The color for the edge effects.\n     * @see #setTopEdgeEffectColor(int)\n     * @see #setBottomEdgeEffectColor(int)\n     * @see #getTopEdgeEffectColor()\n     * @see #getBottomEdgeEffectColor()\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setBottomEdgeEffectColor(@ColorInt int color)",
    "returnType" : "void",
    "comment" : "\n     * Sets the bottom edge effect color.\n     *\n     * @param color The color for the bottom edge effect.\n     * @see #setTopEdgeEffectColor(int)\n     * @see #setEdgeEffectColor(int)\n     * @see #getTopEdgeEffectColor()\n     * @see #getBottomEdgeEffectColor()\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setTopEdgeEffectColor(@ColorInt int color)",
    "returnType" : "void",
    "comment" : "\n     * Sets the top edge effect color.\n     *\n     * @param color The color for the top edge effect.\n     * @see #setBottomEdgeEffectColor(int)\n     * @see #setEdgeEffectColor(int)\n     * @see #getTopEdgeEffectColor()\n     * @see #getBottomEdgeEffectColor()\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getTopEdgeEffectColor()",
    "returnType" : "int",
    "comment" : "\n     * Returns the top edge effect color.\n     *\n     * @return The top edge effect color.\n     * @see #setEdgeEffectColor(int)\n     * @see #setTopEdgeEffectColor(int)\n     * @see #setBottomEdgeEffectColor(int)\n     * @see #getBottomEdgeEffectColor()\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getBottomEdgeEffectColor()",
    "returnType" : "int",
    "comment" : "\n     * Returns the bottom edge effect color.\n     *\n     * @return The bottom edge effect color.\n     * @see #setEdgeEffectColor(int)\n     * @see #setTopEdgeEffectColor(int)\n     * @see #setBottomEdgeEffectColor(int)\n     * @see #getTopEdgeEffectColor()\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setRecyclerListener(RecyclerListener listener)",
    "returnType" : "void",
    "comment" : "\n     * Sets the recycler listener to be notified whenever a View is set aside in\n     * the recycler for later reuse. This listener can be used to free resources\n     * associated to the View.\n     *\n     * @param listener The recycler listener to be notified of views set aside\n     *        in the recycler.\n     *\n     * @see android.widget.AbsListView.RecyclerListener\n     ",
    "links" : [ ]
  }, {
    "name" : "public void onProvideContentCaptureStructure(@NonNull ViewStructure structure, int flags)",
    "returnType" : "void",
    "comment" : "\n     * {@inheritDoc}\n     *\n     * This method will initialize the fields of the {@link ViewStructure}\n     * using the base implementation in {@link View}. On API level 33 and higher, it may also\n     * write information about the positions of active views to the extras bundle provided by the\n     * {@link ViewStructure}.\n     *\n     * NOTE: When overriding this method on API level 33, if not calling super() or if changing the\n     * logic for child views, be sure to provide values for the first active child view position and\n     * the list of active child views in the {@link ViewStructure}'s extras {@link Bundle} using the\n     * \"android.view.ViewStructure.extra.ACTIVE_CHILDREN_IDS\" and\n     * \"android.view.ViewStructure.extra.FIRST_ACTIVE_POSITION\" keys.\n     *\n     * @param structure {@link ViewStructure} to be filled in with structured view data.\n     * @param flags optional flags.\n     *\n     * @see View#AUTOFILL_FLAG_INCLUDE_NOT_IMPORTANT_VIEWS\n     ",
    "links" : [ "android.view.ViewStructure", "android.os.Bundle", "android.view.View" ]
  }, {
    "name" : "private void reportActiveViewsToContentCapture()",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " int getHeightForPosition(int position)",
    "returnType" : "int",
    "comment" : "\n     * Returns the height of the view for the specified position.\n     *\n     * @param position the item position\n     * @return view height in pixels\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSelectionFromTop(int position, int y)",
    "returnType" : "void",
    "comment" : "\n     * Sets the selected item and positions the selection y pixels from the top edge\n     * of the ListView. (If in touch mode, the item will not be selected but it will\n     * still be positioned appropriately.)\n     *\n     * @param position Index (starting at 0) of the data item to be selected.\n     * @param y The distance from the top edge of the ListView (plus padding) that the\n     *        item will be positioned.\n     ",
    "links" : [ ]
  }, {
    "name" : "protected void encodeProperties(@NonNull ViewHierarchyEncoder encoder)",
    "returnType" : "void",
    "comment" : " @hide ",
    "links" : [ ]
  } ],
  "methodNames" : [ "private static void setupDeviceConfigProperties()", "private void initAbsListView()", "public void setAdapter(ListAdapter adapter)", "public int getCheckedItemCount()", "public boolean isItemChecked(int position)", "public int getCheckedItemPosition()", "public SparseBooleanArray getCheckedItemPositions()", "public long[] getCheckedItemIds()", "public void clearChoices()", "public void setItemChecked(int position, boolean value)", "public boolean performItemClick(View view, int position, long id)", "private void updateOnScreenCheckedViews()", "public int getChoiceMode()", "public void setChoiceMode(int choiceMode)", "public void setMultiChoiceModeListener(MultiChoiceModeListener listener)", "private boolean contentFits()", "public void setFastScrollEnabled(final boolean enabled)", "private void setFastScrollerEnabledUiThread(boolean enabled)", "public void setFastScrollStyle(int styleResId)", "public void setFastScrollAlwaysVisible(final boolean alwaysShow)", "private void setFastScrollerAlwaysVisibleUiThread(boolean alwaysShow)", "private boolean isOwnerThread()", "public boolean isFastScrollAlwaysVisible()", "public int getVerticalScrollbarWidth()", "public boolean isFastScrollEnabled()", "public void setVerticalScrollbarPosition(int position)", "public void setScrollBarStyle(int style)", "protected boolean isVerticalScrollBarHidden()", "public void setSmoothScrollbarEnabled(boolean enabled)", "public boolean isSmoothScrollbarEnabled()", "public void setOnScrollListener(OnScrollListener l)", " void invokeOnItemScrollListener()", "public CharSequence getAccessibilityClassName()", "public void onInitializeAccessibilityNodeInfoInternal(AccessibilityNodeInfo info)", " int getSelectionModeForAccessibility()", "public boolean performAccessibilityActionInternal(int action, Bundle arguments)", "public boolean isScrollingCacheEnabled()", "public void setScrollingCacheEnabled(boolean enabled)", "public void setTextFilterEnabled(boolean textFilterEnabled)", "public boolean isTextFilterEnabled()", "public void getFocusedRect(Rect r)", "private void useDefaultSelector()", "public boolean isStackFromBottom()", "public void setStackFromBottom(boolean stackFromBottom)", " void requestLayoutIfNecessary()", "public Parcelable onSaveInstanceState()", "public void onRestoreInstanceState(Parcelable state)", "private boolean acceptFilter()", "public void setFilterText(String filterText)", "public CharSequence getTextFilter()", "protected void onFocusChanged(boolean gainFocus, int direction, Rect previouslyFocusedRect)", "public void requestLayout()", " void resetList()", "protected int computeVerticalScrollExtent()", "protected int computeVerticalScrollOffset()", "protected int computeVerticalScrollRange()", "protected float getTopFadingEdgeStrength()", "protected float getBottomFadingEdgeStrength()", "protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)", "protected void onLayout(boolean changed, int l, int t, int r, int b)", "protected boolean setFrame(int left, int top, int right, int bottom)", "protected void layoutChildren()", " View getAccessibilityFocusedChild(View focusedView)", " void updateScrollIndicators()", "private boolean canScrollUp()", "private boolean canScrollDown()", "public View getSelectedView()", "public int getListPaddingTop()", "public int getListPaddingBottom()", "public int getListPaddingLeft()", "public int getListPaddingRight()", " View obtainView(int position, boolean[] outMetadata)", "private void setItemViewLayoutParams(View child, int position)", "public void onInitializeAccessibilityNodeInfoForItem(View view, int position, AccessibilityNodeInfo info)", "private void addAccessibilityActionIfEnabled(AccessibilityNodeInfo info, boolean enabled, AccessibilityAction action)", "private boolean isItemClickable(View view)", " void positionSelectorLikeTouch(int position, View sel, float x, float y)", " void positionSelectorLikeFocus(int position, View sel)", " void positionSelector(int position, View sel)", "private void positionSelector(int position, View sel, boolean manageHotspot, float x, float y)", "public boolean isSelectedChildViewEnabled()", "public void setSelectedChildViewEnabled(boolean selectedChildViewEnabled)", "protected void dispatchDraw(Canvas canvas)", "protected boolean isPaddingOffsetRequired()", "protected int getLeftPaddingOffset()", "protected int getTopPaddingOffset()", "protected int getRightPaddingOffset()", "protected int getBottomPaddingOffset()", "protected void internalSetPadding(int left, int top, int right, int bottom)", "protected void onSizeChanged(int w, int h, int oldw, int oldh)", " void handleBoundsChange()", " boolean touchModeDrawsInPressedState()", " boolean shouldShowSelector()", "private void drawSelector(Canvas canvas)", "public final boolean shouldDrawSelector()", "public void setDrawSelectorOnTop(boolean onTop)", "public boolean isDrawSelectorOnTop()", "public void setSelector(@DrawableRes int resID)", "public void setSelector(Drawable sel)", "public Drawable getSelector()", " void keyPressed()", "public void setScrollIndicators(View up, View down)", " void updateSelectorState()", "protected void drawableStateChanged()", "private int[] getDrawableStateForSelector()", "public boolean verifyDrawable(@NonNull Drawable dr)", "public void jumpDrawablesToCurrentState()", "protected void onAttachedToWindow()", "protected void onDetachedFromWindow()", "public void onWindowFocusChanged(boolean hasWindowFocus)", "public void onRtlPropertiesChanged(int layoutDirection)", " ContextMenuInfo createContextMenuInfo(View view, int position, long id)", "public void onCancelPendingInputEvents()", "private boolean performStylusButtonPressAction(MotionEvent ev)", " boolean performLongPress(final View child, final int longPressPosition, final long longPressId)", " boolean performLongPress(final View child, final int longPressPosition, final long longPressId, float x, float y)", "protected ContextMenuInfo getContextMenuInfo()", "public boolean showContextMenu()", "public boolean showContextMenu(float x, float y)", "private boolean showContextMenuInternal(float x, float y, boolean useOffsets)", "public boolean showContextMenuForChild(View originalView)", "public boolean showContextMenuForChild(View originalView, float x, float y)", "private boolean showContextMenuForChildInternal(View originalView, float x, float y, boolean useOffsets)", "public boolean onKeyDown(int keyCode, KeyEvent event)", "public boolean onKeyUp(int keyCode, KeyEvent event)", "protected void dispatchSetPressed(boolean pressed)", "public void dispatchDrawableHotspotChanged(float x, float y)", "public int pointToPosition(int x, int y)", "public long pointToRowId(int x, int y)", "private boolean startScrollIfNeeded(int x, int y, MotionEvent vtev)", "private void scrollIfNeeded(int x, int y, MotionEvent vtev)", "private int releaseGlow(int deltaY, int x)", "private boolean doesTouchStopStretch()", "private void invalidateEdgeEffects()", "public void onTouchModeChanged(boolean isInTouchMode)", "protected boolean handleScrollBarDragging(MotionEvent event)", "public boolean onTouchEvent(MotionEvent ev)", "private void onTouchDown(MotionEvent ev)", "private void stopEdgeGlowRecede(float x)", "private void onTouchMove(MotionEvent ev, MotionEvent vtev)", "private void onTouchUp(MotionEvent ev)", "private boolean shouldAbsorb(EdgeEffect edgeEffect, int velocity)", "private int consumeFlingInStretch(int unconsumed)", "private boolean shouldDisplayEdgeEffects()", "private void onTouchCancel()", "protected void onOverScrolled(int scrollX, int scrollY, boolean clampedX, boolean clampedY)", "public boolean onGenericMotionEvent(MotionEvent event)", "public void fling(int velocityY)", "public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes)", "public void onNestedScrollAccepted(View child, View target, int axes)", "public void onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed)", "public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed)", "public void draw(Canvas canvas)", "private void initOrResetVelocityTracker()", "private void initVelocityTrackerIfNotExists()", "private void initDifferentialFlingHelperIfNotExists()", "private void initHapticScrollFeedbackProviderIfNotExists()", "private void recycleVelocityTracker()", "public void requestDisallowInterceptTouchEvent(boolean disallowIntercept)", "public boolean onInterceptHoverEvent(MotionEvent event)", "public PointerIcon onResolvePointerIcon(MotionEvent event, int pointerIndex)", "public boolean onInterceptTouchEvent(MotionEvent ev)", "private void onSecondaryPointerUp(MotionEvent ev)", "public void addTouchables(ArrayList<View> views)", " void reportScrollStateChange(int newState)", "public void setFriction(float friction)", "public void setVelocityScale(float scale)", " AbsPositionScroller createPositionScroller()", "public void smoothScrollToPosition(int position)", "public void smoothScrollToPositionFromTop(int position, int offset, int duration)", "public void smoothScrollToPositionFromTop(int position, int offset)", "public void smoothScrollToPosition(int position, int boundPosition)", "public void smoothScrollBy(int distance, int duration)", " void smoothScrollBy(int distance, int duration, boolean linear, boolean suppressEndFlingStateChangeCall)", " void smoothScrollByOffset(int position)", "private void createScrollingCache()", "private void clearScrollingCache()", "public void scrollListBy(int y)", "public boolean canScrollList(int direction)", " boolean trackMotionScroll(int deltaY, int incrementalDeltaY)", " int getHeaderViewsCount()", " int getFooterViewsCount()", " abstract void fillGap(boolean down)", " void hideSelector()", " int reconcileSelectedPosition()", " abstract int findMotionRow(int y)", " int findClosestMotionRow(int y)", "public void invalidateViews()", " boolean resurrectSelectionIfNeeded()", " abstract void setSelectionInt(int position)", " boolean resurrectSelection()", " void confirmCheckedPositionsById()", "protected void handleDataChanged()", "protected void onDisplayHint(int hint)", "private void dismissPopup()", "private void showPopup()", "private void positionPopup()", " static int getDistance(Rect source, Rect dest, int direction)", "protected boolean isInFilterMode()", " boolean sendToTextFilter(int keyCode, int count, KeyEvent event)", "public InputConnection onCreateInputConnection(EditorInfo outAttrs)", "public boolean checkInputConnectionProxy(View view)", "private void createTextFilter(boolean animateEntrance)", "private EditText getTextFilterInput()", "public void clearTextFilter()", "public boolean hasTextFilter()", "public void onGlobalLayout()", "public void beforeTextChanged(CharSequence s, int start, int count, int after)", "public void onTextChanged(CharSequence s, int start, int before, int count)", "public void afterTextChanged(Editable s)", "public void onFilterComplete(int count)", "protected ViewGroup.LayoutParams generateDefaultLayoutParams()", "protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p)", "public LayoutParams generateLayoutParams(AttributeSet attrs)", "protected boolean checkLayoutParams(ViewGroup.LayoutParams p)", "public void setTranscriptMode(int mode)", "public int getTranscriptMode()", "public int getSolidColor()", "public void setCacheColorHint(@ColorInt int color)", "public int getCacheColorHint()", "public void reclaimViews(List<View> views)", "private void finishGlows()", "public void setRemoteViewsAdapter(Intent intent)", "public Runnable setRemoteViewsAdapterAsync(final Intent intent)", "public void setRemoteViewsAdapter(Intent intent, boolean isAsync)", "public void setRemoteViewsInteractionHandler(InteractionHandler handler)", "public void deferNotifyDataSetChanged()", "public boolean onRemoteAdapterConnected()", "public void onRemoteAdapterDisconnected()", " void setVisibleRangeHint(int start, int end)", "public void setEdgeEffectColor(@ColorInt int color)", "public void setBottomEdgeEffectColor(@ColorInt int color)", "public void setTopEdgeEffectColor(@ColorInt int color)", "public int getTopEdgeEffectColor()", "public int getBottomEdgeEffectColor()", "public void setRecyclerListener(RecyclerListener listener)", "public void onProvideContentCaptureStructure(@NonNull ViewStructure structure, int flags)", "private void reportActiveViewsToContentCapture()", " int getHeightForPosition(int position)", "public void setSelectionFromTop(int position, int y)", "protected void encodeProperties(@NonNull ViewHierarchyEncoder encoder)" ],
  "variableNames" : [ "TAG", "TRANSCRIPT_MODE_DISABLED", "TRANSCRIPT_MODE_NORMAL", "TRANSCRIPT_MODE_ALWAYS_SCROLL", "TOUCH_MODE_REST", "TOUCH_MODE_DOWN", "TOUCH_MODE_TAP", "TOUCH_MODE_DONE_WAITING", "TOUCH_MODE_SCROLL", "TOUCH_MODE_FLING", "TOUCH_MODE_OVERSCROLL", "TOUCH_MODE_OVERFLING", "LAYOUT_NORMAL", "LAYOUT_FORCE_TOP", "LAYOUT_SET_SELECTION", "LAYOUT_FORCE_BOTTOM", "LAYOUT_SPECIFIC", "LAYOUT_SYNC", "LAYOUT_MOVE_SELECTION", "CHOICE_MODE_NONE", "CHOICE_MODE_SINGLE", "CHOICE_MODE_MULTIPLE", "CHOICE_MODE_MULTIPLE_MODAL", "FLING_DESTRETCH_FACTOR", "mOwnerThread", "mChoiceMode", "mChoiceActionMode", "mMultiChoiceModeCallback", "mCheckedItemCount", "mCheckStates", "mCheckedIdStates", "mLayoutMode", "mDataSetObserver", "mAdapter", "mRemoteAdapter", "mAdapterHasStableIds", "mDeferNotifyDataSetChanged", "mDrawSelectorOnTop", "mSelector", "mSelectorPosition", "mSelectorRect", "mRecycler", "mSelectionLeftPadding", "mSelectionTopPadding", "mSelectionRightPadding", "mSelectionBottomPadding", "mListPadding", "mWidthMeasureSpec", "mScrollUp", "mScrollDown", "mCachingStarted", "mCachingActive", "mMotionPosition", "mMotionViewOriginalTop", "mMotionViewNewTop", "mMotionX", "mMotionY", "mTouchMode", "mLastY", "mMotionCorrection", "mVelocityTracker", "mFlingRunnable", "mPositionScroller", "mSelectedTop", "mStackFromBottom", "mScrollingCacheEnabled", "mFastScrollEnabled", "mFastScrollAlwaysVisible", "mOnScrollListener", "mPopup", "mTextFilter", "mSmoothScrollbarEnabled", "mTextFilterEnabled", "mFiltered", "mTouchFrame", "mResurrectToPosition", "mContextMenuInfo", "mOverscrollMax", "OVERSCROLL_LIMIT_DIVISOR", "CHECK_POSITION_SEARCH_DISTANCE", "TOUCH_MODE_UNKNOWN", "TOUCH_MODE_ON", "TOUCH_MODE_OFF", "mLastTouchMode", "PROFILE_SCROLLING", "mScrollProfilingStarted", "PROFILE_FLINGING", "mFlingProfilingStarted", "mScrollStrictSpan", "mFlingStrictSpan", "mPendingCheckForLongPress", "mPendingCheckForTap", "mPendingCheckForKeyLongPress", "mPerformClick", "mTouchModeReset", "mHasPerformedLongPress", "mTranscriptMode", "mCacheColorHint", "mIsChildViewEnabled", "mSelectorState", "mLastScrollState", "sContentCaptureReportingEnabledByDeviceConfig", "sDeviceConfigChangeListener", "mReportChildrenToContentCaptureOnNextUpdate", "mFastScroll", "mFastScrollStyle", "mGlobalLayoutListenerAddedFilter", "mTouchSlop", "mDensityScale", "mVerticalScrollFactor", "mDefInputConnection", "mPublicInputConnection", "mClearScrollingCache", "mPositionScrollAfterLayout", "mMinimumVelocity", "mMaximumVelocity", "mVelocityScale", "mIsScrap", "mScrollOffset", "mScrollConsumed", "mTmpPoint", "mNestedYOffset", "mPopupHidden", "mActivePointerId", "INVALID_POINTER", "mOverscrollDistance", "mOverflingDistance", "mEdgeGlowTop", "mEdgeGlowBottom", "mFirstPositionDistanceGuess", "mLastPositionDistanceGuess", "mDirection", "mForceTranscriptScroll", "mAccessibilityDelegate", "mLastHandledItemCount", "sLinearInterpolator", "mPendingSync", "mIsDetaching", "mDifferentialMotionFlingHelper", "mHapticScrollFeedbackProvider" ]
}