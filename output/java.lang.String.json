{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/lang/String.java",
  "packageName" : "java.lang",
  "className" : "String",
  "comment" : "",
  "links" : [ ],
  "variables" : [ {
    "name" : "count",
    "type" : "int",
    "comment" : "\n    We only keep track of the length here and compression here. This has several consequences\n    throughout this class:\n     - References to value[i] are replaced by charAt(i).\n     - References to value.length are replaced by calls to length().\n     - Sometimes the result of length() is assigned to a local variable to avoid repeated calls.\n     - We skip several attempts at optimization where the values field was assigned to a local\n       variable to avoid the getfield opcode.\n    These changes are not all marked individually.\n\n    If STRING_COMPRESSION_ENABLED, count stores the length shifted one bit to the left with the\n    lowest bit used to indicate whether or not the bytes are compressed (see GetFlaggedCount in\n    the native code).\n    /**\n     * The value is used for character storage.\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     *\n     * Additionally, it is marked with {@link Stable} to trust the contents\n     * of the array. No other facility in JDK provides this functionality (yet).\n     * {@link Stable} is safe here, because value is never null.\n     *\n    @Stable\n    private final byte[] value;\n    ",
    "links" : [ "java.lang.Stable" ]
  }, {
    "name" : "hash",
    "type" : "int",
    "comment" : " Default to 0",
    "links" : [ ]
  }, {
    "name" : "serialVersionUID",
    "type" : "long",
    "comment" : " use serialVersionUID from JDK 1.0.2 for interoperability ",
    "links" : [ ]
  }, {
    "name" : "COMPACT_STRINGS",
    "type" : "boolean",
    "comment" : " Android-changed: Inline the constant on ART.",
    "links" : [ ]
  }, {
    "name" : "EMPTY",
    "type" : "String",
    "comment" : " @hide ",
    "links" : [ ]
  }, {
    "name" : "LATIN1",
    "type" : "byte",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "UTF16",
    "type" : "byte",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "serialPersistentFields",
    "type" : "ObjectStreamField[]",
    "comment" : "\n     * Class String is special cased within the Serialization Stream Protocol.\n     *\n     * A String instance is written into an ObjectOutputStream according to\n     * <a href=\"{@docRoot}/../specs/serialization/protocol.html#stream-elements\">\n     * Object Serialization Specification, Section 6.2, \"Stream Elements\"</a>\n     ",
    "links" : [ ]
  }, {
    "name" : "CASE_INSENSITIVE_ORDER",
    "type" : "Comparator<String>",
    "comment" : "\n     * A Comparator that orders {@code String} objects as by\n     * {@code compareToIgnoreCase}. This comparator is serializable.\n     * <p>\n     * Note that this Comparator does <em>not</em> take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @see     java.text.Collator\n     * @since   1.2\n     ",
    "links" : [ "java.text.Collator" ]
  } ],
  "methods" : [ {
    "name" : "public int length()",
    "returnType" : "int",
    "comment" : "\n     * Returns the length of this string.\n     * The length is equal to the number of <a href=\"Character.html#unicode\">Unicode\n     * code units</a> in the string.\n     *\n     * @return  the length of the sequence of characters represented by this\n     *          object.\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean isEmpty()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if, and only if, {@link #length()} is {@code 0}.\n     *\n     * @return {@code true} if {@link #length()} is {@code 0}, otherwise\n     * {@code false}\n     *\n     * @since 1.6\n     ",
    "links" : [ "#length()" ]
  }, {
    "name" : "public native char charAt(int index)",
    "returnType" : "char",
    "comment" : "\n    public char charAt(int index) {\n        if (isLatin1()) {\n            return StringLatin1.charAt(value, index);\n        } else {\n            return StringUTF16.charAt(value, index);\n        }\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : "public int codePointAt(int index)",
    "returnType" : "int",
    "comment" : "\n     * Returns the character (Unicode code point) at the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 0} to\n     * {@link #length()}{@code  - 1}.\n     *\n     * <p> If the {@code char} value specified at the given index\n     * is in the high-surrogate range, the following index is less\n     * than the length of this {@code String}, and the\n     * {@code char} value at the following index is in the\n     * low-surrogate range, then the supplementary code point\n     * corresponding to this surrogate pair is returned. Otherwise,\n     * the {@code char} value at the given index is returned.\n     *\n     * @param      index the index to the {@code char} values\n     * @return     the code point value of the character at the\n     *             {@code index}\n     * @exception  IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     * @since      1.5\n     ",
    "links" : [ "#length()" ]
  }, {
    "name" : "public int codePointBefore(int index)",
    "returnType" : "int",
    "comment" : "\n     * Returns the character (Unicode code point) before the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 1} to {@link\n     * CharSequence#length() length}.\n     *\n     * <p> If the {@code char} value at {@code (index - 1)}\n     * is in the low-surrogate range, {@code (index - 2)} is not\n     * negative, and the {@code char} value at {@code (index -\n     * 2)} is in the high-surrogate range, then the\n     * supplementary code point value of the surrogate pair is\n     * returned. If the {@code char} value at {@code index -\n     * 1} is an unpaired low-surrogate or a high-surrogate, the\n     * surrogate value is returned.\n     *\n     * @param     index the index following the code point that should be returned\n     * @return    the Unicode code point value before the given index.\n     * @exception IndexOutOfBoundsException if the {@code index}\n     *            argument is less than 1 or greater than the length\n     *            of this string.\n     * @since     1.5\n     ",
    "links" : [ "java.lang.CharSequence#length()" ]
  }, {
    "name" : "public int codePointCount(int beginIndex, int endIndex)",
    "returnType" : "int",
    "comment" : "\n     * Returns the number of Unicode code points in the specified text\n     * range of this {@code String}. The text range begins at the\n     * specified {@code beginIndex} and extends to the\n     * {@code char} at index {@code endIndex - 1}. Thus the\n     * length (in {@code char}s) of the text range is\n     * {@code endIndex-beginIndex}. Unpaired surrogates within\n     * the text range count as one code point each.\n     *\n     * @param beginIndex the index to the first {@code char} of\n     * the text range.\n     * @param endIndex the index after the last {@code char} of\n     * the text range.\n     * @return the number of Unicode code points in the specified text\n     * range\n     * @exception IndexOutOfBoundsException if the\n     * {@code beginIndex} is negative, or {@code endIndex}\n     * is larger than the length of this {@code String}, or\n     * {@code beginIndex} is larger than {@code endIndex}.\n     * @since  1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public int offsetByCodePoints(int index, int codePointOffset)",
    "returnType" : "int",
    "comment" : "\n     * Returns the index within this {@code String} that is\n     * offset from the given {@code index} by\n     * {@code codePointOffset} code points. Unpaired surrogates\n     * within the text range given by {@code index} and\n     * {@code codePointOffset} count as one code point each.\n     *\n     * @param index the index to be offset\n     * @param codePointOffset the offset in code points\n     * @return the index within this {@code String}\n     * @exception IndexOutOfBoundsException if {@code index}\n     *   is negative or larger then the length of this\n     *   {@code String}, or if {@code codePointOffset} is positive\n     *   and the substring starting with {@code index} has fewer\n     *   than {@code codePointOffset} code points,\n     *   or if {@code codePointOffset} is negative and the substring\n     *   before {@code index} has fewer than the absolute value\n     *   of {@code codePointOffset} code points.\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : " void getChars(char[] dst, int dstBegin)",
    "returnType" : "void",
    "comment" : "\n     * Copy characters from this string into dst starting at dstBegin.\n     * This method doesn't perform any range checking.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)",
    "returnType" : "void",
    "comment" : "\n     * Copies characters from this string into the destination character\n     * array.\n     * <p>\n     * The first character to be copied is at index {@code srcBegin};\n     * the last character to be copied is at index {@code srcEnd-1}\n     * (thus the total number of characters to be copied is\n     * {@code srcEnd-srcBegin}). The characters are copied into the\n     * subarray of {@code dst} starting at index {@code dstBegin}\n     * and ending at index:\n     * <blockquote><pre>\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * </pre></blockquote>\n     *\n     * @param      srcBegin   index of the first character in the string\n     *                        to copy.\n     * @param      srcEnd     index after the last character in the string\n     *                        to copy.\n     * @param      dst        the destination array.\n     * @param      dstBegin   the start offset in the destination array.\n     * @exception IndexOutOfBoundsException If any of the following\n     *            is true:\n     *            <ul><li>{@code srcBegin} is negative.\n     *            <li>{@code srcBegin} is greater than {@code srcEnd}\n     *            <li>{@code srcEnd} is greater than the length of this\n     *                string\n     *            <li>{@code dstBegin} is negative\n     *            <li>{@code dstBegin+(srcEnd-srcBegin)} is larger than\n     *                {@code dst.length}</ul>\n     ",
    "links" : [ ]
  }, {
    "name" : " native void getCharsNoCheck(int start, int end, char[] buffer, int index)",
    "returnType" : "void",
    "comment" : "\n     * getChars without bounds checks, for use by other classes\n     * within the java.lang package only.  The caller is responsible for\n     * ensuring that start >= 0 && start <= end && end <= count.\n     ",
    "links" : [ ]
  }, {
    "name" : "public void getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin)",
    "returnType" : "void",
    "comment" : "\n     * Copies characters from this string into the destination byte array. Each\n     * byte receives the 8 low-order bits of the corresponding character. The\n     * eight high-order bits of each character are not copied and do not\n     * participate in the transfer in any way.\n     *\n     * <p> The first character to be copied is at index {@code srcBegin}; the\n     * last character to be copied is at index {@code srcEnd-1}.  The total\n     * number of characters to be copied is {@code srcEnd-srcBegin}. The\n     * characters, converted to bytes, are copied into the subarray of {@code\n     * dst} starting at index {@code dstBegin} and ending at index:\n     *\n     * <blockquote><pre>\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * </pre></blockquote>\n     *\n     * @deprecated  This method does not properly convert characters into\n     * bytes.  As of JDK&nbsp;1.1, the preferred way to do this is via the\n     * {@link #getBytes()} method, which uses the platform's default charset.\n     *\n     * @param  srcBegin\n     *         Index of the first character in the string to copy\n     *\n     * @param  srcEnd\n     *         Index after the last character in the string to copy\n     *\n     * @param  dst\n     *         The destination array\n     *\n     * @param  dstBegin\n     *         The start offset in the destination array\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If any of the following is true:\n     *          <ul>\n     *            <li> {@code srcBegin} is negative\n     *            <li> {@code srcBegin} is greater than {@code srcEnd}\n     *            <li> {@code srcEnd} is greater than the length of this String\n     *            <li> {@code dstBegin} is negative\n     *            <li> {@code dstBegin+(srcEnd-srcBegin)} is larger than {@code\n     *                 dst.length}\n     *          </ul>\n     ",
    "links" : [ "#getBytes()" ]
  }, {
    "name" : "public byte[] getBytes(String charsetName) throws UnsupportedEncodingException",
    "returnType" : "byte[]",
    "comment" : "\n     * Encodes this {@code String} into a sequence of bytes using the named\n     * charset, storing the result into a new byte array.\n     *\n     * <p> The behavior of this method when this string cannot be encoded in\n     * the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @return  The resultant byte array\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     ",
    "links" : [ "java.nio.charset.CharsetEncoder" ]
  }, {
    "name" : "public byte[] getBytes(Charset charset)",
    "returnType" : "byte[]",
    "comment" : "\n     * Encodes this {@code String} into a sequence of bytes using the given\n     * {@linkplain java.nio.charset.Charset charset}, storing the result into a\n     * new byte array.\n     *\n     * <p> This method always replaces malformed-input and unmappable-character\n     * sequences with this charset's default replacement byte array.  The\n     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n     * control over the encoding process is required.\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset} to be used to encode\n     *         the {@code String}\n     *\n     * @return  The resultant byte array\n     *\n     * @since  1.6\n     ",
    "links" : [ "java.nio.charset.CharsetEncoder" ]
  }, {
    "name" : "public byte[] getBytes()",
    "returnType" : "byte[]",
    "comment" : "\n     * Encodes this {@code String} into a sequence of bytes using the\n     * platform's default charset, storing the result into a new byte array.\n     *\n     * <p> The behavior of this method when this string cannot be encoded in\n     * the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @return  The resultant byte array\n     *\n     * @since      1.1\n     ",
    "links" : [ "java.nio.charset.CharsetEncoder" ]
  }, {
    "name" : "public boolean equals(Object anObject)",
    "returnType" : "boolean",
    "comment" : "\n     * Compares this string to the specified object.  The result is {@code\n     * true} if and only if the argument is not {@code null} and is a {@code\n     * String} object that represents the same sequence of characters as this\n     * object.\n     *\n     * <p>For finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  anObject\n     *         The object to compare this {@code String} against\n     *\n     * @return  {@code true} if the given object represents a {@code String}\n     *          equivalent to this string, {@code false} otherwise\n     *\n     * @see  #compareTo(String)\n     * @see  #equalsIgnoreCase(String)\n     ",
    "links" : [ "java.text.Collator" ]
  }, {
    "name" : "public boolean contentEquals(StringBuffer sb)",
    "returnType" : "boolean",
    "comment" : "\n     * Compares this string to the specified {@code StringBuffer}.  The result\n     * is {@code true} if and only if this {@code String} represents the same\n     * sequence of characters as the specified {@code StringBuffer}. This method\n     * synchronizes on the {@code StringBuffer}.\n     *\n     * <p>For finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  sb\n     *         The {@code StringBuffer} to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of characters as the specified {@code StringBuffer},\n     *          {@code false} otherwise\n     *\n     * @since  1.4\n     ",
    "links" : [ "java.text.Collator" ]
  }, {
    "name" : "private boolean nonSyncContentEquals(AbstractStringBuilder sb)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public boolean contentEquals(CharSequence cs)",
    "returnType" : "boolean",
    "comment" : "\n     * Compares this string to the specified {@code CharSequence}.  The\n     * result is {@code true} if and only if this {@code String} represents the\n     * same sequence of char values as the specified sequence. Note that if the\n     * {@code CharSequence} is a {@code StringBuffer} then the method\n     * synchronizes on it.\n     *\n     * <p>For finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  cs\n     *         The sequence to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of char values as the specified sequence, {@code\n     *          false} otherwise\n     *\n     * @since  1.5\n     ",
    "links" : [ "java.text.Collator" ]
  }, {
    "name" : "public boolean equalsIgnoreCase(String anotherString)",
    "returnType" : "boolean",
    "comment" : "\n     * Compares this {@code String} to another {@code String}, ignoring case\n     * considerations.  Two strings are considered equal ignoring case if they\n     * are of the same length and corresponding characters in the two strings\n     * are equal ignoring case.\n     *\n     * <p> Two characters {@code c1} and {@code c2} are considered the same\n     * ignoring case if at least one of the following is true:\n     * <ul>\n     *   <li> The two characters are the same (as compared by the\n     *        {@code ==} operator)\n     *   <li> Calling {@code Character.toLowerCase(Character.toUpperCase(char))}\n     *        on each character produces the same result\n     * </ul>\n     *\n     * <p>Note that this method does <em>not</em> take locale into account, and\n     * will result in unsatisfactory results for certain locales.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param  anotherString\n     *         The {@code String} to compare this {@code String} against\n     *\n     * @return  {@code true} if the argument is not {@code null} and it\n     *          represents an equivalent {@code String} ignoring case; {@code\n     *          false} otherwise\n     *\n     * @see  #equals(Object)\n     ",
    "links" : [ "java.text.Collator" ]
  }, {
    "name" : "public native int compareTo(String anotherString)",
    "returnType" : "int",
    "comment" : "\n    public int compareTo(String anotherString) {\n        byte v1[] = value;\n        byte v2[] = anotherString.value;\n        if (coder() == anotherString.coder()) {\n            return isLatin1() ? StringLatin1.compareTo(v1, v2)\n                              : StringUTF16.compareTo(v1, v2);\n        }\n        return isLatin1() ? StringLatin1.compareToUTF16(v1, v2)\n                          : StringUTF16.compareToLatin1(v1, v2);\n     }\n    ",
    "links" : [ ]
  }, {
    "name" : "public int compareToIgnoreCase(String str)",
    "returnType" : "int",
    "comment" : "\n     * Compares two strings lexicographically, ignoring case\n     * differences. This method returns an integer whose sign is that of\n     * calling {@code compareTo} with normalized versions of the strings\n     * where case differences have been eliminated by calling\n     * {@code Character.toLowerCase(Character.toUpperCase(character))} on\n     * each character.\n     * <p>\n     * Note that this method does <em>not</em> take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   str   the {@code String} to be compared.\n     * @return  a negative integer, zero, or a positive integer as the\n     *          specified String is greater than, equal to, or less\n     *          than this String, ignoring case considerations.\n     * @see     java.text.Collator\n     * @since   1.2\n     ",
    "links" : [ "java.text.Collator" ]
  }, {
    "name" : "public boolean regionMatches(int toffset, String other, int ooffset, int len)",
    "returnType" : "boolean",
    "comment" : "\n     * Tests if two string regions are equal.\n     * <p>\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument other. The result is true if these substrings\n     * represent identical character sequences. The substring of this\n     * {@code String} object to be compared begins at index {@code toffset}\n     * and has length {@code len}. The substring of other to be compared\n     * begins at index {@code ooffset} and has length {@code len}. The\n     * result is {@code false} if and only if at least one of the following\n     * is true:\n     * <ul><li>{@code toffset} is negative.\n     * <li>{@code ooffset} is negative.\n     * <li>{@code toffset+len} is greater than the length of this\n     * {@code String} object.\n     * <li>{@code ooffset+len} is greater than the length of the other\n     * argument.\n     * <li>There is some nonnegative integer <i>k</i> less than {@code len}\n     * such that:\n     * {@code this.charAt(toffset + }<i>k</i>{@code ) != other.charAt(ooffset + }\n     * <i>k</i>{@code )}\n     * </ul>\n     *\n     * <p>Note that this method does <em>not</em> take locale into account.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   toffset   the starting offset of the subregion in this string.\n     * @param   other     the string argument.\n     * @param   ooffset   the starting offset of the subregion in the string\n     *                    argument.\n     * @param   len       the number of characters to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          exactly matches the specified subregion of the string argument;\n     *          {@code false} otherwise.\n     ",
    "links" : [ "java.text.Collator" ]
  }, {
    "name" : "public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)",
    "returnType" : "boolean",
    "comment" : "\n     * Tests if two string regions are equal.\n     * <p>\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument {@code other}. The result is {@code true} if these\n     * substrings represent character sequences that are the same, ignoring\n     * case if and only if {@code ignoreCase} is true. The substring of\n     * this {@code String} object to be compared begins at index\n     * {@code toffset} and has length {@code len}. The substring of\n     * {@code other} to be compared begins at index {@code ooffset} and\n     * has length {@code len}. The result is {@code false} if and only if\n     * at least one of the following is true:\n     * <ul><li>{@code toffset} is negative.\n     * <li>{@code ooffset} is negative.\n     * <li>{@code toffset+len} is greater than the length of this\n     * {@code String} object.\n     * <li>{@code ooffset+len} is greater than the length of the other\n     * argument.\n     * <li>{@code ignoreCase} is {@code false} and there is some nonnegative\n     * integer <i>k</i> less than {@code len} such that:\n     * <blockquote><pre>\n     * this.charAt(toffset+k) != other.charAt(ooffset+k)\n     * </pre></blockquote>\n     * <li>{@code ignoreCase} is {@code true} and there is some nonnegative\n     * integer <i>k</i> less than {@code len} such that:\n     * <blockquote><pre>\n     * Character.toLowerCase(Character.toUpperCase(this.charAt(toffset+k))) !=\n     Character.toLowerCase(Character.toUpperCase(other.charAt(ooffset+k)))\n     * </pre></blockquote>\n     * </ul>\n     *\n     * <p>Note that this method does <em>not</em> take locale into account,\n     * and will result in unsatisfactory results for certain locales when\n     * {@code ignoreCase} is {@code true}.  The {@link java.text.Collator} class\n     * provides locale-sensitive comparison.\n     *\n     * @param   ignoreCase   if {@code true}, ignore case when comparing\n     *                       characters.\n     * @param   toffset      the starting offset of the subregion in this\n     *                       string.\n     * @param   other        the string argument.\n     * @param   ooffset      the starting offset of the subregion in the string\n     *                       argument.\n     * @param   len          the number of characters to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          matches the specified subregion of the string argument;\n     *          {@code false} otherwise. Whether the matching is exact\n     *          or case insensitive depends on the {@code ignoreCase}\n     *          argument.\n     ",
    "links" : [ "java.text.Collator" ]
  }, {
    "name" : "public boolean startsWith(String prefix, int toffset)",
    "returnType" : "boolean",
    "comment" : "\n     * Tests if the substring of this string beginning at the\n     * specified index starts with the specified prefix.\n     *\n     * @param   prefix    the prefix.\n     * @param   toffset   where to begin looking in this string.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the substring of this object starting\n     *          at index {@code toffset}; {@code false} otherwise.\n     *          The result is {@code false} if {@code toffset} is\n     *          negative or greater than the length of this\n     *          {@code String} object; otherwise the result is the same\n     *          as the result of the expression\n     *          <pre>\n     *          this.substring(toffset).startsWith(prefix)\n     *          </pre>\n     ",
    "links" : [ ]
  }, {
    "name" : "public boolean startsWith(String prefix)",
    "returnType" : "boolean",
    "comment" : "\n     * Tests if this string starts with the specified prefix.\n     *\n     * @param   prefix   the prefix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the character sequence represented by\n     *          this string; {@code false} otherwise.\n     *          Note also that {@code true} will be returned if the\n     *          argument is an empty string or is equal to this\n     *          {@code String} object as determined by the\n     *          {@link #equals(Object)} method.\n     * @since   1.0\n     ",
    "links" : [ "#equals(Object)" ]
  }, {
    "name" : "public boolean endsWith(String suffix)",
    "returnType" : "boolean",
    "comment" : "\n     * Tests if this string ends with the specified suffix.\n     *\n     * @param   suffix   the suffix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a suffix of the character sequence represented by\n     *          this object; {@code false} otherwise. Note that the\n     *          result will be {@code true} if the argument is the\n     *          empty string or is equal to this {@code String} object\n     *          as determined by the {@link #equals(Object)} method.\n     ",
    "links" : [ "#equals(Object)" ]
  }, {
    "name" : "public int hashCode()",
    "returnType" : "int",
    "comment" : "\n     * Returns a hash code for this string. The hash code for a\n     * {@code String} object is computed as\n     * <blockquote><pre>\n     * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n     * </pre></blockquote>\n     * using {@code int} arithmetic, where {@code s[i]} is the\n     * <i>i</i>th character of the string, {@code n} is the length of\n     * the string, and {@code ^} indicates exponentiation.\n     * (The hash value of the empty string is zero.)\n     *\n     * @return  a hash code value for this object.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int indexOf(int ch)",
    "returnType" : "int",
    "comment" : "\n     * Returns the index within this string of the first occurrence of\n     * the specified character. If a character with value\n     * {@code ch} occurs in the character sequence represented by\n     * this {@code String} object, then the index (in Unicode\n     * code units) of the first such occurrence is returned. For\n     * values of {@code ch} in the range from 0 to 0xFFFF\n     * (inclusive), this is the smallest value <i>k</i> such that:\n     * <blockquote><pre>\n     * this.charAt(<i>k</i>) == ch\n     * </pre></blockquote>\n     * is true. For other values of {@code ch}, it is the\n     * smallest value <i>k</i> such that:\n     * <blockquote><pre>\n     * this.codePointAt(<i>k</i>) == ch\n     * </pre></blockquote>\n     * is true. In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int indexOf(int ch, int fromIndex)",
    "returnType" : "int",
    "comment" : "\n     * Returns the index within this string of the first occurrence of the\n     * specified character, starting the search at the specified index.\n     * <p>\n     * If a character with value {@code ch} occurs in the\n     * character sequence represented by this {@code String}\n     * object at an index no smaller than {@code fromIndex}, then\n     * the index of the first such occurrence is returned. For values\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n     * this is the smallest value <i>k</i> such that:\n     * <blockquote><pre>\n     * (this.charAt(<i>k</i>) == ch) {@code &&} (<i>k</i> &gt;= fromIndex)\n     * </pre></blockquote>\n     * is true. For other values of {@code ch}, it is the\n     * smallest value <i>k</i> such that:\n     * <blockquote><pre>\n     * (this.codePointAt(<i>k</i>) == ch) {@code &&} (<i>k</i> &gt;= fromIndex)\n     * </pre></blockquote>\n     * is true. In either case, if no such character occurs in this\n     * string at or after position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * <p>\n     * There is no restriction on the value of {@code fromIndex}. If it\n     * is negative, it has the same effect as if it were zero: this entire\n     * string may be searched. If it is greater than the length of this\n     * string, it has the same effect as if it were equal to the length of\n     * this string: {@code -1} is returned.\n     *\n     * <p>All indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object that is greater\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur.\n     ",
    "links" : [ ]
  }, {
    "name" : "private int indexOfSupplementary(int ch, int fromIndex)",
    "returnType" : "int",
    "comment" : "\n     * Handles (rare) calls of indexOf with a supplementary character.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int lastIndexOf(int ch)",
    "returnType" : "int",
    "comment" : "\n     * Returns the index within this string of the last occurrence of\n     * the specified character. For values of {@code ch} in the\n     * range from 0 to 0xFFFF (inclusive), the index (in Unicode code\n     * units) returned is the largest value <i>k</i> such that:\n     * <blockquote><pre>\n     * this.charAt(<i>k</i>) == ch\n     * </pre></blockquote>\n     * is true. For other values of {@code ch}, it is the\n     * largest value <i>k</i> such that:\n     * <blockquote><pre>\n     * this.codePointAt(<i>k</i>) == ch\n     * </pre></blockquote>\n     * is true.  In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.  The\n     * {@code String} is searched backwards starting at the last\n     * character.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int lastIndexOf(int ch, int fromIndex)",
    "returnType" : "int",
    "comment" : "\n     * Returns the index within this string of the last occurrence of\n     * the specified character, searching backward starting at the\n     * specified index. For values of {@code ch} in the range\n     * from 0 to 0xFFFF (inclusive), the index returned is the largest\n     * value <i>k</i> such that:\n     * <blockquote><pre>\n     * (this.charAt(<i>k</i>) == ch) {@code &&} (<i>k</i> &lt;= fromIndex)\n     * </pre></blockquote>\n     * is true. For other values of {@code ch}, it is the\n     * largest value <i>k</i> such that:\n     * <blockquote><pre>\n     * (this.codePointAt(<i>k</i>) == ch) {@code &&} (<i>k</i> &lt;= fromIndex)\n     * </pre></blockquote>\n     * is true. In either case, if no such character occurs in this\n     * string at or before position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * <p>All indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from. There is no\n     *          restriction on the value of {@code fromIndex}. If it is\n     *          greater than or equal to the length of this string, it has\n     *          the same effect as if it were equal to one less than the\n     *          length of this string: this entire string may be searched.\n     *          If it is negative, it has the same effect as if it were -1:\n     *          -1 is returned.\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object that is less\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur before that point.\n     ",
    "links" : [ ]
  }, {
    "name" : "private int lastIndexOfSupplementary(int ch, int fromIndex)",
    "returnType" : "int",
    "comment" : "\n     * Handles (rare) calls of lastIndexOf with a supplementary character.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int indexOf(String str)",
    "returnType" : "int",
    "comment" : "\n     * Returns the index within this string of the first occurrence of the\n     * specified substring.\n     *\n     * <p>The returned index is the smallest value {@code k} for which:\n     * <pre>{@code\n     * this.startsWith(str, k)\n     * }</pre>\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the first occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int indexOf(String str, int fromIndex)",
    "returnType" : "int",
    "comment" : "\n     * Returns the index within this string of the first occurrence of the\n     * specified substring, starting at the specified index.\n     *\n     * <p>The returned index is the smallest value {@code k} for which:\n     * <pre>{@code\n     *     k >= Math.min(fromIndex, this.length()) &&\n     *                   this.startsWith(str, k)\n     * }</pre>\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index from which to start the search.\n     * @return  the index of the first occurrence of the specified substring,\n     *          starting at the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static int indexOf(String source, String target, int fromIndex)",
    "returnType" : "int",
    "comment" : "\n     * The source is the string being searched, and the target is the string being searched for.\n     *\n     * @param   source       the characters being searched.\n     * @param   target       the characters being searched for.\n     * @param   fromIndex    the index to begin searching from.\n     ",
    "links" : [ ]
  }, {
    "name" : " static int indexOf(byte[] src, byte srcCoder, int srcCount, String tgtStr, int fromIndex)",
    "returnType" : "int",
    "comment" : "\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src       the characters being searched.\n     * @param   srcCoder  the coder of the source string.\n     * @param   srcCount  length of the source string.\n     * @param   tgtStr    the characters being searched for.\n     * @param   fromIndex the index to begin searching from.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int lastIndexOf(String str)",
    "returnType" : "int",
    "comment" : "\n     * Returns the index within this string of the last occurrence of the\n     * specified substring.  The last occurrence of the empty string \"\"\n     * is considered to occur at the index value {@code this.length()}.\n     *\n     * <p>The returned index is the largest value {@code k} for which:\n     * <pre>{@code\n     * this.startsWith(str, k)\n     * }</pre>\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the last occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int lastIndexOf(String str, int fromIndex)",
    "returnType" : "int",
    "comment" : "\n     * Returns the index within this string of the last occurrence of the\n     * specified substring, searching backward starting at the specified index.\n     *\n     * <p>The returned index is the largest value {@code k} for which:\n     * <pre>{@code\n     *     k <= Math.min(fromIndex, this.length()) &&\n     *                   this.startsWith(str, k)\n     * }</pre>\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the last occurrence of the specified substring,\n     *          searching backward from the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     ",
    "links" : [ ]
  }, {
    "name" : "private static int lastIndexOf(String source, String target, int fromIndex)",
    "returnType" : "int",
    "comment" : "\n     * The source is the string being searched, and the target is the string being searched for.\n     *\n     * @param   source       the characters being searched.\n     * @param   target       the characters being searched for.\n     * @param   fromIndex    the index to begin searching from.\n     ",
    "links" : [ ]
  }, {
    "name" : " static int lastIndexOf(byte[] src, byte srcCoder, int srcCount, String tgtStr, int fromIndex)",
    "returnType" : "int",
    "comment" : "\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src         the characters being searched.\n     * @param   srcCoder    coder handles the mapping between bytes/chars\n     * @param   srcCount    count of the source string.\n     * @param   tgtStr      the characters being searched for.\n     * @param   fromIndex   the index to begin searching from.\n     ",
    "links" : [ ]
  }, {
    "name" : " static int lastIndexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex)",
    "returnType" : "int",
    "comment" : "\n     * Code shared by String and StringBuffer to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   source       the characters being searched.\n     * @param   sourceOffset offset of the source string.\n     * @param   sourceCount  count of the source string.\n     * @param   target       the characters being searched for.\n     * @param   targetOffset offset of the target string.\n     * @param   targetCount  count of the target string.\n     * @param   fromIndex    the index to begin searching from.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String substring(int beginIndex)",
    "returnType" : "String",
    "comment" : "\n     * Returns a string that is a substring of this string. The\n     * substring begins with the character at the specified index and\n     * extends to the end of this string. <p>\n     * Examples:\n     * <blockquote><pre>\n     * \"unhappy\".substring(2) returns \"happy\"\n     * \"Harbison\".substring(3) returns \"bison\"\n     * \"emptiness\".substring(9) returns \"\" (an empty string)\n     * </pre></blockquote>\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @return     the specified substring.\n     * @exception  IndexOutOfBoundsException  if\n     *             {@code beginIndex} is negative or larger than the\n     *             length of this {@code String} object.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String substring(int beginIndex, int endIndex)",
    "returnType" : "String",
    "comment" : "\n     * Returns a string that is a substring of this string. The\n     * substring begins at the specified {@code beginIndex} and\n     * extends to the character at index {@code endIndex - 1}.\n     * Thus the length of the substring is {@code endIndex-beginIndex}.\n     * <p>\n     * Examples:\n     * <blockquote><pre>\n     * \"hamburger\".substring(4, 8) returns \"urge\"\n     * \"smiles\".substring(1, 5) returns \"mile\"\n     * </pre></blockquote>\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @return     the specified substring.\n     * @exception  IndexOutOfBoundsException  if the\n     *             {@code beginIndex} is negative, or\n     *             {@code endIndex} is larger than the length of\n     *             this {@code String} object, or\n     *             {@code beginIndex} is larger than\n     *             {@code endIndex}.\n     ",
    "links" : [ ]
  }, {
    "name" : "private native String fastSubstring(int start, int length)",
    "returnType" : "String",
    "comment" : " BEGIN Android-added: Native method to access char storage managed by runtime.",
    "links" : [ ]
  }, {
    "name" : "public CharSequence subSequence(int beginIndex, int endIndex)",
    "returnType" : "CharSequence",
    "comment" : "\n     * Returns a character sequence that is a subsequence of this sequence.\n     *\n     * <p> An invocation of this method of the form\n     *\n     * <blockquote><pre>\n     * str.subSequence(begin,&nbsp;end)</pre></blockquote>\n     *\n     * behaves in exactly the same way as the invocation\n     *\n     * <blockquote><pre>\n     * str.substring(begin,&nbsp;end)</pre></blockquote>\n     *\n     * @apiNote\n     * This method is defined so that the {@code String} class can implement\n     * the {@link CharSequence} interface.\n     *\n     * @param   beginIndex   the begin index, inclusive.\n     * @param   endIndex     the end index, exclusive.\n     * @return  the specified subsequence.\n     *\n     * @throws  IndexOutOfBoundsException\n     *          if {@code beginIndex} or {@code endIndex} is negative,\n     *          if {@code endIndex} is greater than {@code length()},\n     *          or if {@code beginIndex} is greater than {@code endIndex}\n     *\n     * @since 1.4\n     * @spec JSR-51\n     ",
    "links" : [ "java.lang.CharSequence" ]
  }, {
    "name" : "public native String concat(String str)",
    "returnType" : "String",
    "comment" : "\n    public String concat(String str) {\n        if (str.isEmpty()) {\n            return this;\n        }\n        if (coder() == str.coder()) {\n            byte[] val = this.value;\n            byte[] oval = str.value;\n            int len = val.length + oval.length;\n            byte[] buf = Arrays.copyOf(val, len);\n            System.arraycopy(oval, 0, buf, val.length, oval.length);\n            return new String(buf, coder);\n        }\n        int len = length();\n        int olen = str.length();\n        byte[] buf = StringUTF16.newBytesFor(len + olen);\n        getBytes(buf, 0, UTF16);\n        str.getBytes(buf, len, UTF16);\n        return new String(buf, UTF16);\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : "public String replace(char oldChar, char newChar)",
    "returnType" : "String",
    "comment" : "\n     * Returns a string resulting from replacing all occurrences of\n     * {@code oldChar} in this string with {@code newChar}.\n     * <p>\n     * If the character {@code oldChar} does not occur in the\n     * character sequence represented by this {@code String} object,\n     * then a reference to this {@code String} object is returned.\n     * Otherwise, a {@code String} object is returned that\n     * represents a character sequence identical to the character sequence\n     * represented by this {@code String} object, except that every\n     * occurrence of {@code oldChar} is replaced by an occurrence\n     * of {@code newChar}.\n     * <p>\n     * Examples:\n     * <blockquote><pre>\n     * \"mesquite in your cellar\".replace('e', 'o')\n     *         returns \"mosquito in your collar\"\n     * \"the war of baronets\".replace('r', 'y')\n     *         returns \"the way of bayonets\"\n     * \"sparring with a purple porpoise\".replace('p', 't')\n     *         returns \"starring with a turtle tortoise\"\n     * \"JonL\".replace('q', 'x') returns \"JonL\" (no change)\n     * </pre></blockquote>\n     *\n     * @param   oldChar   the old character.\n     * @param   newChar   the new character.\n     * @return  a string derived from this string by replacing every\n     *          occurrence of {@code oldChar} with {@code newChar}.\n     ",
    "links" : [ ]
  }, {
    "name" : "private native String doReplace(char oldChar, char newChar)",
    "returnType" : "String",
    "comment" : " Implementation of replace(char oldChar, char newChar) called when we found a match.",
    "links" : [ ]
  }, {
    "name" : "public boolean matches(String regex)",
    "returnType" : "boolean",
    "comment" : "\n     * Tells whether or not this string matches the given <a\n     * href=\"../util/regex/Pattern.html#sum\">regular expression</a>.\n     *\n     * <p> An invocation of this method of the form\n     * <i>str</i>{@code .matches(}<i>regex</i>{@code )} yields exactly the\n     * same result as the expression\n     *\n     * <blockquote>\n     * {@link java.util.regex.Pattern}.{@link java.util.regex.Pattern#matches(String,CharSequence)\n     * matches(<i>regex</i>, <i>str</i>)}\n     * </blockquote>\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     *\n     * @return  {@code true} if, and only if, this string matches the\n     *          given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression's syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     * @spec JSR-51\n     ",
    "links" : [ "java.util.regex.Pattern", "java.util.regex.Pattern#matches(String" ]
  }, {
    "name" : "public boolean contains(CharSequence s)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if and only if this string contains the specified\n     * sequence of char values.\n     *\n     * @param s the sequence to search for\n     * @return true if this string contains {@code s}, false otherwise\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public String replaceFirst(String regex, String replacement)",
    "returnType" : "String",
    "comment" : "\n     * Replaces the first substring of this string that matches the given <a\n     * href=\"../util/regex/Pattern.html#sum\">regular expression</a> with the\n     * given replacement.\n     *\n     * <p> An invocation of this method of the form\n     * <i>str</i>{@code .replaceFirst(}<i>regex</i>{@code ,} <i>repl</i>{@code )}\n     * yields exactly the same result as the expression\n     *\n     * <blockquote>\n     * <code>\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile compile}(<i>regex</i>).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(<i>str</i>).{@link\n     * java.util.regex.Matcher#replaceFirst replaceFirst}(<i>repl</i>)\n     * </code>\n     * </blockquote>\n     *\n     *<p>\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceFirst}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for the first match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression's syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     * @spec JSR-51\n     ",
    "links" : [ "java.util.regex.Matcher#replaceFirst", "java.util.regex.Pattern#matcher(java.lang.CharSequence)", "java.util.regex.Pattern#compile", "java.util.regex.Pattern", "java.util.regex.Matcher#quoteReplacement" ]
  }, {
    "name" : "public String replaceAll(String regex, String replacement)",
    "returnType" : "String",
    "comment" : "\n     * Replaces each substring of this string that matches the given <a\n     * href=\"../util/regex/Pattern.html#sum\">regular expression</a> with the\n     * given replacement.\n     *\n     * <p> An invocation of this method of the form\n     * <i>str</i>{@code .replaceAll(}<i>regex</i>{@code ,} <i>repl</i>{@code )}\n     * yields exactly the same result as the expression\n     *\n     * <blockquote>\n     * <code>\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile compile}(<i>regex</i>).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(<i>str</i>).{@link\n     * java.util.regex.Matcher#replaceAll replaceAll}(<i>repl</i>)\n     * </code>\n     * </blockquote>\n     *\n     *<p>\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceAll Matcher.replaceAll}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for each match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression's syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     * @spec JSR-51\n     ",
    "links" : [ "java.util.regex.Pattern#matcher(java.lang.CharSequence)", "java.util.regex.Matcher#replaceAll", "java.util.regex.Pattern#compile", "java.util.regex.Pattern", "java.util.regex.Matcher#quoteReplacement" ]
  }, {
    "name" : "public String replace(CharSequence target, CharSequence replacement)",
    "returnType" : "String",
    "comment" : "\n     * Replaces each substring of this string that matches the literal target\n     * sequence with the specified literal replacement sequence. The\n     * replacement proceeds from the beginning of the string to the end, for\n     * example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in\n     * \"ba\" rather than \"ab\".\n     *\n     * @param  target The sequence of char values to be replaced\n     * @param  replacement The replacement sequence of char values\n     * @return  The resulting string\n     * @since 1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public String[] split(String regex, int limit)",
    "returnType" : "String[]",
    "comment" : "\n     * Splits this string around matches of the given\n     * <a href=\"../util/regex/Pattern.html#sum\">regular expression</a>.\n     *\n     * <p> The array returned by this method contains each substring of this\n     * string that is terminated by another substring that matches the given\n     * expression or is terminated by the end of the string.  The substrings in\n     * the array are in the order in which they occur in this string.  If the\n     * expression does not match any part of the input then the resulting array\n     * has just one element, namely this string.\n     *\n     * <p> When there is a positive-width match at the beginning of this\n     * string then an empty leading substring is included at the beginning\n     * of the resulting array. A zero-width match at the beginning however\n     * never produces such empty leading substring.\n     *\n     * <p> The {@code limit} parameter controls the number of times the\n     * pattern is applied and therefore affects the length of the resulting\n     * array.\n     * <ul>\n     *    <li><p>\n     *    If the <i>limit</i> is positive then the pattern will be applied\n     *    at most <i>limit</i>&nbsp;-&nbsp;1 times, the array's length will be\n     *    no greater than <i>limit</i>, and the array's last entry will contain\n     *    all input beyond the last matched delimiter.</p></li>\n     *\n     *    <li><p>\n     *    If the <i>limit</i> is zero then the pattern will be applied as\n     *    many times as possible, the array can have any length, and trailing\n     *    empty strings will be discarded.</p></li>\n     *\n     *    <li><p>\n     *    If the <i>limit</i> is negative then the pattern will be applied\n     *    as many times as possible and the array can have any length.</p></li>\n     * </ul>\n     *\n     * <p> The string {@code \"boo:and:foo\"}, for example, yields the\n     * following results with these parameters:\n     *\n     * <blockquote><table class=\"plain\">\n     * <caption style=\"display:none\">Split example showing regex, limit, and result</caption>\n     * <thead>\n     * <tr>\n     *     <th scope=\"col\">Regex</th>\n     *     <th scope=\"col\">Limit</th>\n     *     <th scope=\"col\">Result</th>\n     * </tr>\n     * </thead>\n     * <tbody>\n     * <tr><th scope=\"row\" rowspan=\"3\" style=\"font-weight:normal\">:</th>\n     *     <th scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\">2</th>\n     *     <td>{@code { \"boo\", \"and:foo\" }}</td></tr>\n     * <tr><!-- : -->\n     *     <th scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\">5</th>\n     *     <td>{@code { \"boo\", \"and\", \"foo\" }}</td></tr>\n     * <tr><!-- : -->\n     *     <th scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\">-2</th>\n     *     <td>{@code { \"boo\", \"and\", \"foo\" }}</td></tr>\n     * <tr><th scope=\"row\" rowspan=\"3\" style=\"font-weight:normal\">o</th>\n     *     <th scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\">5</th>\n     *     <td>{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}</td></tr>\n     * <tr><!-- o -->\n     *     <th scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\">-2</th>\n     *     <td>{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}</td></tr>\n     * <tr><!-- o -->\n     *     <th scope=\"row\" style=\"font-weight:normal; text-align:right; padding-right:1em\">0</th>\n     *     <td>{@code { \"b\", \"\", \":and:f\" }}</td></tr>\n     * </tbody>\n     * </table></blockquote>\n     *\n     * <p> An invocation of this method of the form\n     * <i>str.</i>{@code split(}<i>regex</i>{@code ,}&nbsp;<i>n</i>{@code )}\n     * yields the same result as the expression\n     *\n     * <blockquote>\n     * <code>\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile compile}(<i>regex</i>).{@link\n     * java.util.regex.Pattern#split(java.lang.CharSequence,int) split}(<i>str</i>,&nbsp;<i>n</i>)\n     * </code>\n     * </blockquote>\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @param  limit\n     *         the result threshold, as described above\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression's syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     * @spec JSR-51\n     ",
    "links" : [ "java.util.regex.Pattern#compile", "java.util.regex.Pattern", "java.util.regex.Pattern#split(java.lang.CharSequence" ]
  }, {
    "name" : "public String[] split(String regex)",
    "returnType" : "String[]",
    "comment" : "\n     * Splits this string around matches of the given <a\n     * href=\"../util/regex/Pattern.html#sum\">regular expression</a>.\n     *\n     * <p> This method works as if by invoking the two-argument {@link\n     * #split(String, int) split} method with the given expression and a limit\n     * argument of zero.  Trailing empty strings are therefore not included in\n     * the resulting array.\n     *\n     * <p> The string {@code \"boo:and:foo\"}, for example, yields the following\n     * results with these expressions:\n     *\n     * <blockquote><table class=\"plain\">\n     * <caption style=\"display:none\">Split examples showing regex and result</caption>\n     * <thead>\n     * <tr>\n     *  <th scope=\"col\">Regex</th>\n     *  <th scope=\"col\">Result</th>\n     * </tr>\n     * </thead>\n     * <tbody>\n     * <tr><th scope=\"row\" style=\"text-weight:normal\">:</th>\n     *     <td>{@code { \"boo\", \"and\", \"foo\" }}</td></tr>\n     * <tr><th scope=\"row\" style=\"text-weight:normal\">o</th>\n     *     <td>{@code { \"b\", \"\", \":and:f\" }}</td></tr>\n     * </tbody>\n     * </table></blockquote>\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression's syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     * @spec JSR-51\n     ",
    "links" : [ "#split(String" ]
  }, {
    "name" : "public static String join(CharSequence delimiter, CharSequence... elements)",
    "returnType" : "String",
    "comment" : "\n     * Returns a new String composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of\n     * the specified {@code delimiter}.\n     *\n     * <blockquote>For example,\n     * <pre>{@code\n     *     String message = String.join(\"-\", \"Java\", \"is\", \"cool\");\n     *     // message returned is: \"Java-is-cool\"\n     * }</pre></blockquote>\n     *\n     * Note that if an element is null, then {@code \"null\"} is added.\n     *\n     * @param  delimiter the delimiter that separates each element\n     * @param  elements the elements to join together.\n     *\n     * @return a new {@code String} that is composed of the {@code elements}\n     *         separated by the {@code delimiter}\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see java.util.StringJoiner\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String join(CharSequence delimiter, Iterable<? extends CharSequence> elements)",
    "returnType" : "String",
    "comment" : "\n     * Returns a new {@code String} composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of the\n     * specified {@code delimiter}.\n     *\n     * <blockquote>For example,\n     * <pre>{@code\n     *     List<String> strings = List.of(\"Java\", \"is\", \"cool\");\n     *     String message = String.join(\" \", strings);\n     *     //message returned is: \"Java is cool\"\n     *\n     *     Set<String> strings =\n     *         new LinkedHashSet<>(List.of(\"Java\", \"is\", \"very\", \"cool\"));\n     *     String message = String.join(\"-\", strings);\n     *     //message returned is: \"Java-is-very-cool\"\n     * }</pre></blockquote>\n     *\n     * Note that if an individual element is {@code null}, then {@code \"null\"} is added.\n     *\n     * @param  delimiter a sequence of characters that is used to separate each\n     *         of the {@code elements} in the resulting {@code String}\n     * @param  elements an {@code Iterable} that will have its {@code elements}\n     *         joined together.\n     *\n     * @return a new {@code String} that is composed from the {@code elements}\n     *         argument\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see    #join(CharSequence,CharSequence...)\n     * @see    java.util.StringJoiner\n     * @since 1.8\n     ",
    "links" : [ ]
  }, {
    "name" : "public String toLowerCase(Locale locale)",
    "returnType" : "String",
    "comment" : "\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the given {@code Locale}.  Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting\n     * {@code String} may be a different length than the original {@code String}.\n     * <p>\n     * Examples of lowercase  mappings are in the following table:\n     * <table class=\"plain\">\n     * <caption style=\"display:none\">Lowercase mapping examples showing language code of locale, upper case, lower case, and description</caption>\n     * <thead>\n     * <tr>\n     *   <th scope=\"col\">Language Code of Locale</th>\n     *   <th scope=\"col\">Upper Case</th>\n     *   <th scope=\"col\">Lower Case</th>\n     *   <th scope=\"col\">Description</th>\n     * </tr>\n     * </thead>\n     * <tbody>\n     * <tr>\n     *   <td>tr (Turkish)</td>\n     *   <th scope=\"row\" style=\"font-weight:normal; text-align:left\">&#92;u0130</th>\n     *   <td>&#92;u0069</td>\n     *   <td>capital letter I with dot above -&gt; small letter i</td>\n     * </tr>\n     * <tr>\n     *   <td>tr (Turkish)</td>\n     *   <th scope=\"row\" style=\"font-weight:normal; text-align:left\">&#92;u0049</th>\n     *   <td>&#92;u0131</td>\n     *   <td>capital letter I -&gt; small letter dotless i </td>\n     * </tr>\n     * <tr>\n     *   <td>(all)</td>\n     *   <th scope=\"row\" style=\"font-weight:normal; text-align:left\">French Fries</th>\n     *   <td>french fries</td>\n     *   <td>lowercased all chars in String</td>\n     * </tr>\n     * <tr>\n     *   <td>(all)</td>\n     *   <th scope=\"row\" style=\"font-weight:normal; text-align:left\">\n     *       &Iota;&Chi;&Theta;&Upsilon;&Sigma;</th>\n     *   <td>&iota;&chi;&theta;&upsilon;&sigma;</td>\n     *   <td>lowercased all chars in String</td>\n     * </tr>\n     * </tbody>\n     * </table>\n     *\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toUpperCase(Locale)\n     * @since   1.1\n     ",
    "links" : [ "java.lang.Character" ]
  }, {
    "name" : "public String toLowerCase()",
    "returnType" : "String",
    "comment" : "\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the default locale. This is equivalent to calling\n     * {@code toLowerCase(Locale.getDefault())}.\n     * <p>\n     * <b>Note:</b> This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"TITLE\".toLowerCase()} in a Turkish locale\n     * returns {@code \"t\\u005Cu0131tle\"}, where '\\u005Cu0131' is the\n     * LATIN SMALL LETTER DOTLESS I character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toLowerCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase(Locale)\n     ",
    "links" : [ ]
  }, {
    "name" : "public String toUpperCase(Locale locale)",
    "returnType" : "String",
    "comment" : "\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the given {@code Locale}. Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting\n     * {@code String} may be a different length than the original {@code String}.\n     * <p>\n     * Examples of locale-sensitive and 1:M case mappings are in the following table.\n     *\n     * <table class=\"plain\">\n     * <caption style=\"display:none\">Examples of locale-sensitive and 1:M case mappings. Shows Language code of locale, lower case, upper case, and description.</caption>\n     * <thead>\n     * <tr>\n     *   <th scope=\"col\">Language Code of Locale</th>\n     *   <th scope=\"col\">Lower Case</th>\n     *   <th scope=\"col\">Upper Case</th>\n     *   <th scope=\"col\">Description</th>\n     * </tr>\n     * </thead>\n     * <tbody>\n     * <tr>\n     *   <td>tr (Turkish)</td>\n     *   <th scope=\"row\" style=\"font-weight:normal; text-align:left\">&#92;u0069</th>\n     *   <td>&#92;u0130</td>\n     *   <td>small letter i -&gt; capital letter I with dot above</td>\n     * </tr>\n     * <tr>\n     *   <td>tr (Turkish)</td>\n     *   <th scope=\"row\" style=\"font-weight:normal; text-align:left\">&#92;u0131</th>\n     *   <td>&#92;u0049</td>\n     *   <td>small letter dotless i -&gt; capital letter I</td>\n     * </tr>\n     * <tr>\n     *   <td>(all)</td>\n     *   <th scope=\"row\" style=\"font-weight:normal; text-align:left\">&#92;u00df</th>\n     *   <td>&#92;u0053 &#92;u0053</td>\n     *   <td>small letter sharp s -&gt; two letters: SS</td>\n     * </tr>\n     * <tr>\n     *   <td>(all)</td>\n     *   <th scope=\"row\" style=\"font-weight:normal; text-align:left\">Fahrvergn&uuml;gen</th>\n     *   <td>FAHRVERGN&Uuml;GEN</td>\n     *   <td></td>\n     * </tr>\n     * </tbody>\n     * </table>\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toLowerCase(Locale)\n     * @since   1.1\n     ",
    "links" : [ "java.lang.Character" ]
  }, {
    "name" : "public String toUpperCase()",
    "returnType" : "String",
    "comment" : "\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toUpperCase(Locale.getDefault())}.\n     * <p>\n     * <b>Note:</b> This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"title\".toUpperCase()} in a Turkish locale\n     * returns {@code \"T\\u005Cu0130TLE\"}, where '\\u005Cu0130' is the\n     * LATIN CAPITAL LETTER I WITH DOT ABOVE character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toUpperCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase(Locale)\n     ",
    "links" : [ ]
  }, {
    "name" : "public String trim()",
    "returnType" : "String",
    "comment" : "\n     * Returns a string whose value is this string, with all leading\n     * and trailing space removed, where space is defined\n     * as any character whose codepoint is less than or equal to\n     * {@code 'U+0020'} (the space character).\n     * <p>\n     * If this {@code String} object represents an empty character\n     * sequence, or the first and last characters of character sequence\n     * represented by this {@code String} object both have codes\n     * that are not space (as defined above), then a\n     * reference to this {@code String} object is returned.\n     * <p>\n     * Otherwise, if all characters in this string are space (as\n     * defined above), then a  {@code String} object representing an\n     * empty string is returned.\n     * <p>\n     * Otherwise, let <i>k</i> be the index of the first character in the\n     * string whose code is not a space (as defined above) and let\n     * <i>m</i> be the index of the last character in the string whose code\n     * is not a space (as defined above). A {@code String}\n     * object is returned, representing the substring of this string that\n     * begins with the character at index <i>k</i> and ends with the\n     * character at index <i>m</i>-that is, the result of\n     * {@code this.substring(k, m + 1)}.\n     * <p>\n     * This method may be used to trim space (as defined above) from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing space removed, or this string if it\n     *          has no leading or trailing space.\n     ",
    "links" : [ ]
  }, {
    "name" : "public String strip()",
    "returnType" : "String",
    "comment" : "\n     * Returns a string whose value is this string, with all leading\n     * and trailing {@link Character#isWhitespace(int) white space}\n     * removed.\n     * <p>\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@link Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * <p>\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@link Character#isWhitespace(int) white space}\n     * up to and including the last code point that is not a\n     * {@link Character#isWhitespace(int) white space}.\n     * <p>\n     * This method may be used to strip\n     * {@link Character#isWhitespace(int) white space} from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing white space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     ",
    "links" : [ "java.lang.Character#isWhitespace(int)" ]
  }, {
    "name" : "public String stripLeading()",
    "returnType" : "String",
    "comment" : "\n     * Returns a string whose value is this string, with all leading\n     * {@link Character#isWhitespace(int) white space} removed.\n     * <p>\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@link Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * <p>\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@link Character#isWhitespace(int) white space}\n     * up to to and including the last code point of this string.\n     * <p>\n     * This method may be used to trim\n     * {@link Character#isWhitespace(int) white space} from\n     * the beginning of a string.\n     *\n     * @return  a string whose value is this string, with all leading white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     ",
    "links" : [ "java.lang.Character#isWhitespace(int)" ]
  }, {
    "name" : "public String stripTrailing()",
    "returnType" : "String",
    "comment" : "\n     * Returns a string whose value is this string, with all trailing\n     * {@link Character#isWhitespace(int) white space} removed.\n     * <p>\n     * If this {@code String} object represents an empty string,\n     * or if all characters in this string are\n     * {@link Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * <p>\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point of this string up to and including the last code point\n     * that is not a {@link Character#isWhitespace(int) white space}.\n     * <p>\n     * This method may be used to trim\n     * {@link Character#isWhitespace(int) white space} from\n     * the end of a string.\n     *\n     * @return  a string whose value is this string, with all trailing white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     ",
    "links" : [ "java.lang.Character#isWhitespace(int)" ]
  }, {
    "name" : "public boolean isBlank()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns {@code true} if the string is empty or contains only\n     * {@link Character#isWhitespace(int) white space} codepoints,\n     * otherwise {@code false}.\n     *\n     * @return {@code true} if the string is empty or contains only\n     *         {@link Character#isWhitespace(int) white space} codepoints,\n     *         otherwise {@code false}\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     ",
    "links" : [ "java.lang.Character#isWhitespace(int)" ]
  }, {
    "name" : "public Stream<String> lines()",
    "returnType" : "Stream<String>",
    "comment" : "\n     * Returns a stream of lines extracted from this string,\n     * separated by line terminators.\n     * <p>\n     * A <i>line terminator</i> is one of the following:\n     * a line feed character {@code \"\\n\"} (U+000A),\n     * a carriage return character {@code \"\\r\"} (U+000D),\n     * or a carriage return followed immediately by a line feed\n     * {@code \"\\r\\n\"} (U+000D U+000A).\n     * <p>\n     * A <i>line</i> is either a sequence of zero or more characters\n     * followed by a line terminator, or it is a sequence of one or\n     * more characters followed by the end of the string. A\n     * line does not include the line terminator.\n     * <p>\n     * The stream returned by this method contains the lines from\n     * this string in the order in which they occur.\n     *\n     * @apiNote This definition of <i>line</i> implies that an empty\n     *          string has zero lines and that there is no empty line\n     *          following a line terminator at the end of a string.\n     *\n     * @implNote This method provides better performance than\n     *           split(\"\\R\") by supplying elements lazily and\n     *           by faster search of new line terminators.\n     *\n     * @return  the stream of lines extracted from this string\n     *\n     * @since 11\n     ",
    "links" : [ ]
  }, {
    "name" : "public String indent(int n)",
    "returnType" : "String",
    "comment" : "\n     * Adjusts the indentation of each line of this string based on the value of\n     * {@code n}, and normalizes line termination characters.\n     * <p>\n     * This string is conceptually separated into lines using\n     * {@link String#lines()}. Each line is then adjusted as described below\n     * and then suffixed with a line feed {@code \"\\n\"} (U+000A). The resulting\n     * lines are then concatenated and returned.\n     * <p>\n     * If {@code n > 0} then {@code n} spaces (U+0020) are inserted at the\n     * beginning of each line.\n     * <p>\n     * If {@code n < 0} then up to {@code n}\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed\n     * from the beginning of each line. If a given line does not contain\n     * sufficient white space then all leading\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed.\n     * Each white space character is treated as a single character. In\n     * particular, the tab character {@code \"\\t\"} (U+0009) is considered a\n     * single character; it is not expanded.\n     * <p>\n     * If {@code n == 0} then the line remains unchanged. However, line\n     * terminators are still normalized.\n     *\n     * @param n  number of leading\n     *           {@linkplain Character#isWhitespace(int) white space characters}\n     *           to add or remove\n     *\n     * @return string with indentation adjusted and line endings normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see Character#isWhitespace(int)\n     *\n     * @since 12\n     ",
    "links" : [ "java.lang.String#lines()" ]
  }, {
    "name" : "private int indexOfNonWhitespace()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private int lastIndexOfNonWhitespace()",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public String stripIndent()",
    "returnType" : "String",
    "comment" : "\n     * Returns a string whose value is this string, with incidental\n     * {@linkplain Character#isWhitespace(int) white space} removed from\n     * the beginning and end of every line.\n     * <p>\n     * Incidental {@linkplain Character#isWhitespace(int) white space}\n     * is often present in a text block to align the content with the opening\n     * delimiter. For example, in the following code, dots represent incidental\n     * {@linkplain Character#isWhitespace(int) white space}:\n     * <blockquote><pre>\n     * String html = \"\"\"\n     * ..............&lt;html&gt;\n     * ..............    &lt;body&gt;\n     * ..............        &lt;p&gt;Hello, world&lt;/p&gt;\n     * ..............    &lt;/body&gt;\n     * ..............&lt;/html&gt;\n     * ..............\"\"\";\n     * </pre></blockquote>\n     * This method treats the incidental\n     * {@linkplain Character#isWhitespace(int) white space} as indentation to be\n     * stripped, producing a string that preserves the relative indentation of\n     * the content. Using | to visualize the start of each line of the string:\n     * <blockquote><pre>\n     * |&lt;html&gt;\n     * |    &lt;body&gt;\n     * |        &lt;p&gt;Hello, world&lt;/p&gt;\n     * |    &lt;/body&gt;\n     * |&lt;/html&gt;\n     * </pre></blockquote>\n     * First, the individual lines of this string are extracted. A <i>line</i>\n     * is a sequence of zero or more characters followed by either a line\n     * terminator or the end of the string.\n     * If the string has at least one line terminator, the last line consists\n     * of the characters between the last terminator and the end of the string.\n     * Otherwise, if the string has no terminators, the last line is the start\n     * of the string to the end of the string, in other words, the entire\n     * string.\n     * A line does not include the line terminator.\n     * <p>\n     * Then, the <i>minimum indentation</i> (min) is determined as follows:\n     * <ul>\n     *   <li><p>For each non-blank line (as defined by {@link String#isBlank()}),\n     *   the leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters are counted.</p>\n     *   </li>\n     *   <li><p>The leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters on the last line are also counted even if\n     *   {@linkplain String#isBlank() blank}.</p>\n     *   </li>\n     * </ul>\n     * <p>The <i>min</i> value is the smallest of these counts.\n     * <p>\n     * For each {@linkplain String#isBlank() non-blank} line, <i>min</i> leading\n     * {@linkplain Character#isWhitespace(int) white space} characters are\n     * removed, and any trailing {@linkplain Character#isWhitespace(int) white\n     * space} characters are removed. {@linkplain String#isBlank() Blank} lines\n     * are replaced with the empty string.\n     *\n     * <p>\n     * Finally, the lines are joined into a new string, using the LF character\n     * {@code \"\\n\"} (U+000A) to separate lines.\n     *\n     * @apiNote\n     * This method's primary purpose is to shift a block of lines as far as\n     * possible to the left, while preserving relative indentation. Lines\n     * that were indented the least will thus have no leading\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * The result will have the same number of line terminators as this string.\n     * If this string ends with a line terminator then the result will end\n     * with a line terminator.\n     *\n     * @implSpec\n     * This method treats all {@linkplain Character#isWhitespace(int) white space}\n     * characters as having equal width. As long as the indentation on every\n     * line is consistently composed of the same character sequences, then the\n     * result will be as described above.\n     *\n     * @return string with incidental indentation removed and line\n     *         terminators normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see String#indent(int)\n     * @see Character#isWhitespace(int)\n     *\n     * @since 15\n     *\n     ",
    "links" : [ "java.lang.String#isBlank()" ]
  }, {
    "name" : "private static int outdent(List<String> lines)",
    "returnType" : "int",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public String translateEscapes()",
    "returnType" : "String",
    "comment" : "\n     * Returns a string whose value is this string, with escape sequences\n     * translated as if in a string literal.\n     * <p>\n     * Escape sequences are translated as follows;\n     * <table class=\"striped\">\n     *   <caption style=\"display:none\">Translation</caption>\n     *   <thead>\n     *   <tr>\n     *     <th scope=\"col\">Escape</th>\n     *     <th scope=\"col\">Name</th>\n     *     <th scope=\"col\">Translation</th>\n     *   </tr>\n     *   </thead>\n     *   <tbody>\n     *   <tr>\n     *     <th scope=\"row\">{@code \\u005Cb}</th>\n     *     <td>backspace</td>\n     *     <td>{@code U+0008}</td>\n     *   </tr>\n     *   <tr>\n     *     <th scope=\"row\">{@code \\u005Ct}</th>\n     *     <td>horizontal tab</td>\n     *     <td>{@code U+0009}</td>\n     *   </tr>\n     *   <tr>\n     *     <th scope=\"row\">{@code \\u005Cn}</th>\n     *     <td>line feed</td>\n     *     <td>{@code U+000A}</td>\n     *   </tr>\n     *   <tr>\n     *     <th scope=\"row\">{@code \\u005Cf}</th>\n     *     <td>form feed</td>\n     *     <td>{@code U+000C}</td>\n     *   </tr>\n     *   <tr>\n     *     <th scope=\"row\">{@code \\u005Cr}</th>\n     *     <td>carriage return</td>\n     *     <td>{@code U+000D}</td>\n     *   </tr>\n     *   <tr>\n     *     <th scope=\"row\">{@code \\u005Cs}</th>\n     *     <td>space</td>\n     *     <td>{@code U+0020}</td>\n     *   </tr>\n     *   <tr>\n     *     <th scope=\"row\">{@code \\u005C\"}</th>\n     *     <td>double quote</td>\n     *     <td>{@code U+0022}</td>\n     *   </tr>\n     *   <tr>\n     *     <th scope=\"row\">{@code \\u005C'}</th>\n     *     <td>single quote</td>\n     *     <td>{@code U+0027}</td>\n     *   </tr>\n     *   <tr>\n     *     <th scope=\"row\">{@code \\u005C\\u005C}</th>\n     *     <td>backslash</td>\n     *     <td>{@code U+005C}</td>\n     *   </tr>\n     *   <tr>\n     *     <th scope=\"row\">{@code \\u005C0 - \\u005C377}</th>\n     *     <td>octal escape</td>\n     *     <td>code point equivalents</td>\n     *   </tr>\n     *   <tr>\n     *     <th scope=\"row\">{@code \\u005C<line-terminator>}</th>\n     *     <td>continuation</td>\n     *     <td>discard</td>\n     *   </tr>\n     *   </tbody>\n     * </table>\n     *\n     * @implNote\n     * This method does <em>not</em> translate Unicode escapes such as \"{@code \\u005cu2022}\".\n     * Unicode escapes are translated by the Java compiler when reading input characters and\n     * are not part of the string literal specification.\n     *\n     * @throws IllegalArgumentException when an escape sequence is malformed.\n     *\n     * @return String with escape sequences translated.\n     *\n     * @jls 3.10.7 Escape Sequences\n     *\n     * @since 15\n     ",
    "links" : [ ]
  }, {
    "name" : "public R transform(Function<? super String, ? extends R> f)",
    "returnType" : "R",
    "comment" : "\n     * This method allows the application of a function to {@code this}\n     * string. The function should expect a single String argument\n     * and produce an {@code R} result.\n     * <p>\n     * Any exception thrown by {@code f.apply()} will be propagated to the\n     * caller.\n     *\n     * @param f    a function to apply\n     *\n     * @param <R>  the type of the result\n     *\n     * @return     the result of applying the function to this string\n     *\n     * @see java.util.function.Function\n     *\n     * @since 12\n     ",
    "links" : [ ]
  }, {
    "name" : "public String toString()",
    "returnType" : "String",
    "comment" : "\n     * This object (which is already a string!) is itself returned.\n     *\n     * @return  the string itself.\n     ",
    "links" : [ ]
  }, {
    "name" : "public IntStream chars()",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns a stream of {@code int} zero-extending the {@code char} values\n     * from this sequence.  Any char which maps to a <a\n     * href=\"{@docRoot}/java.base/java/lang/Character.html#unicode\">surrogate code\n     * point</a> is passed through uninterpreted.\n     *\n     * @return an IntStream of char values from this sequence\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public IntStream codePoints()",
    "returnType" : "IntStream",
    "comment" : "\n     * Returns a stream of code point values from this sequence.  Any surrogate\n     * pairs encountered in the sequence are combined as if by {@linkplain\n     * Character#toCodePoint Character.toCodePoint} and the result is passed\n     * to the stream. Any other code units, including ordinary BMP characters,\n     * unpaired surrogates, and undefined code units, are zero-extended to\n     * {@code int} values which are then passed to the stream.\n     *\n     * @return an IntStream of Unicode code points from this sequence\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public native char[] toCharArray()",
    "returnType" : "char[]",
    "comment" : "\n    public char[] toCharArray() {\n        return isLatin1() ? StringLatin1.toChars(value)\n                          : StringUTF16.toChars(value);\n    }\n    ",
    "links" : [ ]
  }, {
    "name" : "public static String format(String format, Object... args)",
    "returnType" : "String",
    "comment" : "\n     * Returns a formatted string using the specified format string and\n     * arguments.\n     *\n     * <p> The locale always used is the one returned by {@link\n     * java.util.Locale#getDefault(java.util.Locale.Category)\n     * Locale.getDefault(Locale.Category)} with\n     * {@link java.util.Locale.Category#FORMAT FORMAT} category specified.\n     *\n     * @param  format\n     *         A <a href=\"../util/Formatter.html#syntax\">format string</a>\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         <cite>The Java&trade; Virtual Machine Specification</cite>.\n     *         The behaviour on a\n     *         {@code null} argument depends on the <a\n     *         href=\"../util/Formatter.html#syntax\">conversion</a>.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the <a\n     *          href=\"../util/Formatter.html#detail\">Details</a> section of the\n     *          formatter class specification.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     ",
    "links" : [ "java.util.Locale#getDefault(java.util.Locale.Category)", "java.util.Locale.Category#FORMAT" ]
  }, {
    "name" : "public static String format(Locale l, String format, Object... args)",
    "returnType" : "String",
    "comment" : "\n     * Returns a formatted string using the specified locale, format string,\n     * and arguments.\n     *\n     * @param  l\n     *         The {@linkplain java.util.Locale locale} to apply during\n     *         formatting.  If {@code l} is {@code null} then no localization\n     *         is applied.\n     *\n     * @param  format\n     *         A <a href=\"../util/Formatter.html#syntax\">format string</a>\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         <cite>The Java&trade; Virtual Machine Specification</cite>.\n     *         The behaviour on a\n     *         {@code null} argument depends on the\n     *         <a href=\"../util/Formatter.html#syntax\">conversion</a>.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the <a\n     *          href=\"../util/Formatter.html#detail\">Details</a> section of the\n     *          formatter class specification\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     ",
    "links" : [ ]
  }, {
    "name" : "public String formatted(Object... args)",
    "returnType" : "String",
    "comment" : "\n     * Formats using this string as the format string, and the supplied\n     * arguments.\n     *\n     * @implSpec This method is equivalent to {@code String.format(this, args)}.\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in this string.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.lang.String#format(String,Object...)\n     * @see  java.util.Formatter\n     *\n     * @since 15\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String valueOf(Object obj)",
    "returnType" : "String",
    "comment" : "\n     * Returns the string representation of the {@code Object} argument.\n     *\n     * @param   obj   an {@code Object}.\n     * @return  if the argument is {@code null}, then a string equal to\n     *          {@code \"null\"}; otherwise, the value of\n     *          {@code obj.toString()} is returned.\n     * @see     java.lang.Object#toString()\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String valueOf(char[] data)",
    "returnType" : "String",
    "comment" : "\n     * Returns the string representation of the {@code char} array\n     * argument. The contents of the character array are copied; subsequent\n     * modification of the character array does not affect the returned\n     * string.\n     *\n     * @param   data     the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String valueOf(char[] data, int offset, int count)",
    "returnType" : "String",
    "comment" : "\n     * Returns the string representation of a specific subarray of the\n     * {@code char} array argument.\n     * <p>\n     * The {@code offset} argument is the index of the first\n     * character of the subarray. The {@code count} argument\n     * specifies the length of the subarray. The contents of the subarray\n     * are copied; subsequent modification of the character array does not\n     * affect the returned string.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @exception IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String copyValueOf(char[] data, int offset, int count)",
    "returnType" : "String",
    "comment" : "\n     * Equivalent to {@link #valueOf(char[], int, int)}.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @exception IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     ",
    "links" : [ "#valueOf(char" ]
  }, {
    "name" : "public static String copyValueOf(char[] data)",
    "returnType" : "String",
    "comment" : "\n     * Equivalent to {@link #valueOf(char[])}.\n     *\n     * @param   data   the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     ",
    "links" : [ "#valueOf(char" ]
  }, {
    "name" : "public static String valueOf(boolean b)",
    "returnType" : "String",
    "comment" : "\n     * Returns the string representation of the {@code boolean} argument.\n     *\n     * @param   b   a {@code boolean}.\n     * @return  if the argument is {@code true}, a string equal to\n     *          {@code \"true\"} is returned; otherwise, a string equal to\n     *          {@code \"false\"} is returned.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String valueOf(char c)",
    "returnType" : "String",
    "comment" : "\n     * Returns the string representation of the {@code char}\n     * argument.\n     *\n     * @param   c   a {@code char}.\n     * @return  a string of length {@code 1} containing\n     *          as its single character the argument {@code c}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String valueOf(int i)",
    "returnType" : "String",
    "comment" : "\n     * Returns the string representation of the {@code int} argument.\n     * <p>\n     * The representation is exactly the one returned by the\n     * {@code Integer.toString} method of one argument.\n     *\n     * @param   i   an {@code int}.\n     * @return  a string representation of the {@code int} argument.\n     * @see     java.lang.Integer#toString(int, int)\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String valueOf(long l)",
    "returnType" : "String",
    "comment" : "\n     * Returns the string representation of the {@code long} argument.\n     * <p>\n     * The representation is exactly the one returned by the\n     * {@code Long.toString} method of one argument.\n     *\n     * @param   l   a {@code long}.\n     * @return  a string representation of the {@code long} argument.\n     * @see     java.lang.Long#toString(long)\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String valueOf(float f)",
    "returnType" : "String",
    "comment" : "\n     * Returns the string representation of the {@code float} argument.\n     * <p>\n     * The representation is exactly the one returned by the\n     * {@code Float.toString} method of one argument.\n     *\n     * @param   f   a {@code float}.\n     * @return  a string representation of the {@code float} argument.\n     * @see     java.lang.Float#toString(float)\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String valueOf(double d)",
    "returnType" : "String",
    "comment" : "\n     * Returns the string representation of the {@code double} argument.\n     * <p>\n     * The representation is exactly the one returned by the\n     * {@code Double.toString} method of one argument.\n     *\n     * @param   d   a {@code double}.\n     * @return  a  string representation of the {@code double} argument.\n     * @see     java.lang.Double#toString(double)\n     ",
    "links" : [ ]
  }, {
    "name" : "public native String intern()",
    "returnType" : "String",
    "comment" : " Android-added: Annotate native method as @FastNative.",
    "links" : [ ]
  }, {
    "name" : "public String repeat(int count)",
    "returnType" : "String",
    "comment" : "\n     * Returns a string whose value is the concatenation of this\n     * string repeated {@code count} times.\n     * <p>\n     * If this string is empty or count is zero then the empty\n     * string is returned.\n     *\n     * @param   count number of times to repeat\n     *\n     * @return  A string composed of this string repeated\n     *          {@code count} times or the empty string if this\n     *          string is empty or count is zero\n     *\n     * @throws  IllegalArgumentException if the {@code count} is\n     *          negative.\n     *\n     * @since 11\n     ",
    "links" : [ ]
  }, {
    "name" : "private native String doRepeat(int count)",
    "returnType" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : " void getBytes(byte[] dst, int dstBegin, byte coder)",
    "returnType" : "void",
    "comment" : "\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn't perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param dstBegin  the char index, not offset of byte[]\n     * @param coder     the coder of dst[]\n     ",
    "links" : [ ]
  }, {
    "name" : "private native void fillBytesLatin1(byte[] dst, int byteIndex)",
    "returnType" : "void",
    "comment" : "\n     * Fill the underlying characters into the byte buffer. No range check.\n     * The caller should guarantee that dst is big enough for this operation.\n     ",
    "links" : [ ]
  }, {
    "name" : "private native void fillBytesUTF16(byte[] dst, int byteIndex)",
    "returnType" : "void",
    "comment" : "\n     * Fill the underlying characters into the byte buffer. No range check.\n     * The caller should guarantee that dst is big enough for this operation.\n     ",
    "links" : [ ]
  }, {
    "name" : " byte coder()",
    "returnType" : "byte",
    "comment" : "\n     * Android note: It returns UTF16 if the string has any 0x00 char.\n     * See the difference between {@link StringLatin1#canEncode(int)} and\n     * art::mirror::String::IsASCII(uint16_t) in string.h.\n     ",
    "links" : [ "java.lang.StringLatin1#canEncode(int)" ]
  }, {
    "name" : " static void checkIndex(int index, int length)",
    "returnType" : "void",
    "comment" : "\n     * StringIndexOutOfBoundsException  if {@code index} is\n     * negative or greater than or equal to {@code length}.\n     ",
    "links" : [ ]
  }, {
    "name" : " static void checkOffset(int offset, int length)",
    "returnType" : "void",
    "comment" : "\n     * StringIndexOutOfBoundsException  if {@code offset}\n     * is negative or greater than {@code length}.\n     ",
    "links" : [ ]
  }, {
    "name" : " static void checkBoundsOffCount(int offset, int count, int length)",
    "returnType" : "void",
    "comment" : "\n     * Check {@code offset}, {@code count} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative,\n     *          or {@code offset} is greater than {@code length - count}\n     ",
    "links" : [ ]
  }, {
    "name" : " static String valueOfCodePoint(int codePoint)",
    "returnType" : "String",
    "comment" : "\n     * Returns the string representation of the {@code codePoint}\n     * argument.\n     *\n     * @param   codePoint a {@code codePoint}.\n     * @return  a string of length {@code 1} or {@code 2} containing\n     *          as its single character the argument {@code codePoint}.\n     * @throws IllegalArgumentException if the specified\n     *          {@code codePoint} is not a {@linkplain Character#isValidCodePoint\n     *          valid Unicode code point}.\n     ",
    "links" : [ ]
  }, {
    "name" : " static void checkBoundsBeginEnd(int begin, int end, int length)",
    "returnType" : "void",
    "comment" : "\n     * Check {@code begin}, {@code end} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code begin} is negative, {@code begin} is greater than\n     *          {@code end}, or {@code end} is greater than {@code length}.\n     ",
    "links" : [ ]
  }, {
    "name" : "public Optional<String> describeConstable()",
    "returnType" : "Optional<String>",
    "comment" : "\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain String} instance\n     * @since 12\n     * @hide\n     ",
    "links" : [ "java.util.Optional" ]
  }, {
    "name" : "public String resolveConstantDesc(MethodHandles.Lookup lookup)",
    "returnType" : "String",
    "comment" : "\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain String} instance\n     * @since 12\n     * @hide\n     ",
    "links" : [ "java.lang.constant.ConstantDesc" ]
  } ],
  "methodNames" : [ "public int length()", "public boolean isEmpty()", "public native char charAt(int index)", "public int codePointAt(int index)", "public int codePointBefore(int index)", "public int codePointCount(int beginIndex, int endIndex)", "public int offsetByCodePoints(int index, int codePointOffset)", " void getChars(char[] dst, int dstBegin)", "public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)", " native void getCharsNoCheck(int start, int end, char[] buffer, int index)", "public void getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin)", "public byte[] getBytes(String charsetName) throws UnsupportedEncodingException", "public byte[] getBytes(Charset charset)", "public byte[] getBytes()", "public boolean equals(Object anObject)", "public boolean contentEquals(StringBuffer sb)", "private boolean nonSyncContentEquals(AbstractStringBuilder sb)", "public boolean contentEquals(CharSequence cs)", "public boolean equalsIgnoreCase(String anotherString)", "public native int compareTo(String anotherString)", "public int compareToIgnoreCase(String str)", "public boolean regionMatches(int toffset, String other, int ooffset, int len)", "public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)", "public boolean startsWith(String prefix, int toffset)", "public boolean startsWith(String prefix)", "public boolean endsWith(String suffix)", "public int hashCode()", "public int indexOf(int ch)", "public int indexOf(int ch, int fromIndex)", "private int indexOfSupplementary(int ch, int fromIndex)", "public int lastIndexOf(int ch)", "public int lastIndexOf(int ch, int fromIndex)", "private int lastIndexOfSupplementary(int ch, int fromIndex)", "public int indexOf(String str)", "public int indexOf(String str, int fromIndex)", "private static int indexOf(String source, String target, int fromIndex)", " static int indexOf(byte[] src, byte srcCoder, int srcCount, String tgtStr, int fromIndex)", "public int lastIndexOf(String str)", "public int lastIndexOf(String str, int fromIndex)", "private static int lastIndexOf(String source, String target, int fromIndex)", " static int lastIndexOf(byte[] src, byte srcCoder, int srcCount, String tgtStr, int fromIndex)", " static int lastIndexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex)", "public String substring(int beginIndex)", "public String substring(int beginIndex, int endIndex)", "private native String fastSubstring(int start, int length)", "public CharSequence subSequence(int beginIndex, int endIndex)", "public native String concat(String str)", "public String replace(char oldChar, char newChar)", "private native String doReplace(char oldChar, char newChar)", "public boolean matches(String regex)", "public boolean contains(CharSequence s)", "public String replaceFirst(String regex, String replacement)", "public String replaceAll(String regex, String replacement)", "public String replace(CharSequence target, CharSequence replacement)", "public String[] split(String regex, int limit)", "public String[] split(String regex)", "public static String join(CharSequence delimiter, CharSequence... elements)", "public static String join(CharSequence delimiter, Iterable<? extends CharSequence> elements)", "public String toLowerCase(Locale locale)", "public String toLowerCase()", "public String toUpperCase(Locale locale)", "public String toUpperCase()", "public String trim()", "public String strip()", "public String stripLeading()", "public String stripTrailing()", "public boolean isBlank()", "public Stream<String> lines()", "public String indent(int n)", "private int indexOfNonWhitespace()", "private int lastIndexOfNonWhitespace()", "public String stripIndent()", "private static int outdent(List<String> lines)", "public String translateEscapes()", "public R transform(Function<? super String, ? extends R> f)", "public String toString()", "public IntStream chars()", "public IntStream codePoints()", "public native char[] toCharArray()", "public static String format(String format, Object... args)", "public static String format(Locale l, String format, Object... args)", "public String formatted(Object... args)", "public static String valueOf(Object obj)", "public static String valueOf(char[] data)", "public static String valueOf(char[] data, int offset, int count)", "public static String copyValueOf(char[] data, int offset, int count)", "public static String copyValueOf(char[] data)", "public static String valueOf(boolean b)", "public static String valueOf(char c)", "public static String valueOf(int i)", "public static String valueOf(long l)", "public static String valueOf(float f)", "public static String valueOf(double d)", "public native String intern()", "public String repeat(int count)", "private native String doRepeat(int count)", " void getBytes(byte[] dst, int dstBegin, byte coder)", "private native void fillBytesLatin1(byte[] dst, int byteIndex)", "private native void fillBytesUTF16(byte[] dst, int byteIndex)", " byte coder()", " static void checkIndex(int index, int length)", " static void checkOffset(int offset, int length)", " static void checkBoundsOffCount(int offset, int count, int length)", " static String valueOfCodePoint(int codePoint)", " static void checkBoundsBeginEnd(int begin, int end, int length)", "public Optional<String> describeConstable()", "public String resolveConstantDesc(MethodHandles.Lookup lookup)" ],
  "variableNames" : [ "count", "hash", "serialVersionUID", "COMPACT_STRINGS", "EMPTY", "LATIN1", "UTF16", "serialPersistentFields", "CASE_INSENSITIVE_ORDER" ]
}