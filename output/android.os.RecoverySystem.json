{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/android/os/RecoverySystem.java",
  "packageName" : "android.os",
  "className" : "RecoverySystem",
  "comment" : "\n * RecoverySystem contains methods for interacting with the Android\n * recovery system (the separate partition that can be used to install\n * system updates, wipe user data, etc.)\n ",
  "links" : [ ],
  "variables" : [ {
    "name" : "TAG",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_KEYSTORE",
    "type" : "File",
    "comment" : "\n     * Default location of zip file containing public keys (X509\n     * certs) authorized to sign OTA updates.\n     ",
    "links" : [ ]
  }, {
    "name" : "PUBLISH_PROGRESS_INTERVAL_MS",
    "type" : "long",
    "comment" : " Send progress to listeners no more often than this (in ms). ",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_EUICC_FACTORY_RESET_TIMEOUT_MILLIS",
    "type" : "long",
    "comment" : " 30 s",
    "links" : [ ]
  }, {
    "name" : "MIN_EUICC_FACTORY_RESET_TIMEOUT_MILLIS",
    "type" : "long",
    "comment" : " 5 s",
    "links" : [ ]
  }, {
    "name" : "MAX_EUICC_FACTORY_RESET_TIMEOUT_MILLIS",
    "type" : "long",
    "comment" : " 60 s",
    "links" : [ ]
  }, {
    "name" : "DEFAULT_EUICC_REMOVING_INVISIBLE_PROFILES_TIMEOUT_MILLIS",
    "type" : "long",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "MIN_EUICC_REMOVING_INVISIBLE_PROFILES_TIMEOUT_MILLIS",
    "type" : "long",
    "comment" : " 15 s",
    "links" : [ ]
  }, {
    "name" : "MAX_EUICC_REMOVING_INVISIBLE_PROFILES_TIMEOUT_MILLIS",
    "type" : "long",
    "comment" : " 90 s",
    "links" : [ ]
  }, {
    "name" : "RECOVERY_DIR",
    "type" : "File",
    "comment" : " Used to communicate with recovery.  See bootable/recovery/recovery.cpp. ",
    "links" : [ ]
  }, {
    "name" : "LOG_FILE",
    "type" : "File",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LAST_INSTALL_PATH",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "LAST_PREFIX",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_EUICC_FACTORY_RESET",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "ACTION_EUICC_REMOVE_INVISIBLE_SUBSCRIPTIONS",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "PACKAGE_NAME_EUICC_DATA_MANAGEMENT_CALLBACK",
    "type" : "String",
    "comment" : "\n     * Used in {@link #wipeEuiccData} & {@link #removeEuiccInvisibleSubs} as package name of\n     * callback intent.\n     ",
    "links" : [ "#wipeEuiccData", "#removeEuiccInvisibleSubs" ]
  }, {
    "name" : "BLOCK_MAP_FILE",
    "type" : "File",
    "comment" : "\n     * The recovery image uses this file to identify the location (i.e. blocks)\n     * of an OTA package on the /data partition. The block map file is\n     * generated by uncrypt.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "UNCRYPT_PACKAGE_FILE",
    "type" : "File",
    "comment" : "\n     * UNCRYPT_PACKAGE_FILE stores the filename to be uncrypt'd, which will be\n     * read by uncrypt.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "UNCRYPT_STATUS_FILE",
    "type" : "File",
    "comment" : "\n     * UNCRYPT_STATUS_FILE stores the time cost (and error code in the case of a failure)\n     * of uncrypt.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "LOG_FILE_MAX_LENGTH",
    "type" : "int",
    "comment" : " Length limits for reading files.",
    "links" : [ ]
  }, {
    "name" : "sRequestLock",
    "type" : "Object",
    "comment" : " Prevent concurrent execution of requests.",
    "links" : [ ]
  }, {
    "name" : "mService",
    "type" : "IRecoverySystem",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "RESUME_ON_REBOOT_REBOOT_ERROR_NONE",
    "type" : "int",
    "comment" : "\n     * The preparation of resume on reboot succeeds.\n     *\n     * <p> Don't expose it because a successful reboot should just reboot the device.\n     *  @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RESUME_ON_REBOOT_REBOOT_ERROR_UNSPECIFIED",
    "type" : "int",
    "comment" : "\n     * The resume on reboot fails due to an unknown reason.\n     *  @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RESUME_ON_REBOOT_REBOOT_ERROR_INVALID_PACKAGE_NAME",
    "type" : "int",
    "comment" : "\n     * The resume on reboot fails because the package name of the client is invalid, e.g. null\n     * packageName, name contains invalid characters, etc.\n     *  @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RESUME_ON_REBOOT_REBOOT_ERROR_LSKF_NOT_CAPTURED",
    "type" : "int",
    "comment" : "\n     * The resume on reboot fails because the Lock Screen Knowledge Factor hasn't been captured.\n     * This error is also reported if the client attempts to reboot without preparing RoR.\n     *  @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RESUME_ON_REBOOT_REBOOT_ERROR_SLOT_MISMATCH",
    "type" : "int",
    "comment" : "\n     * The resume on reboot fails because the client expects a different boot slot for the next boot\n     * on A/B devices.\n     *  @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "RESUME_ON_REBOOT_REBOOT_ERROR_PROVIDER_PREPARATION_FAILURE",
    "type" : "int",
    "comment" : "\n     * The resume on reboot fails because the resume on reboot provider, e.g. HAL / server based,\n     * fails to arm/store the escrow key.\n     *  @hide\n     ",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "private static HashSet<X509Certificate> getTrustedCerts(File keystore) throws IOException, GeneralSecurityException",
    "returnType" : "HashSet<X509Certificate>",
    "comment" : " @return the set of certs that can be used to sign an OTA package. ",
    "links" : [ ]
  }, {
    "name" : "public static void verifyPackage(File packageFile, ProgressListener listener, File deviceCertsZipFile) throws IOException, GeneralSecurityException",
    "returnType" : "void",
    "comment" : "\n     * Verify the cryptographic signature of a system update package\n     * before installing it.  Note that the package is also verified\n     * separately by the installer once the device is rebooted into\n     * the recovery system.  This function will return only if the\n     * package was successfully verified; otherwise it will throw an\n     * exception.\n     *\n     * Verification of a package can take significant time, so this\n     * function should not be called from a UI thread.  Interrupting\n     * the thread while this function is in progress will result in a\n     * SecurityException being thrown (and the thread's interrupt flag\n     * will be cleared).\n     *\n     * @param packageFile  the package to be verified\n     * @param listener     an object to receive periodic progress\n     * updates as verification proceeds.  May be null.\n     * @param deviceCertsZipFile  the zip file of certificates whose\n     * public keys we will accept.  Verification succeeds if the\n     * package is signed by the private key corresponding to any\n     * public key in this file.  May be null to use the system default\n     * file (currently \"/system/etc/security/otacerts.zip\").\n     *\n     * @throws IOException if there were any errors reading the\n     * package or certs files.\n     * @throws GeneralSecurityException if verification failed\n     ",
    "links" : [ ]
  }, {
    "name" : "private static boolean verifyPackageCompatibility(InputStream inputStream) throws IOException",
    "returnType" : "boolean",
    "comment" : "\n     * Verifies the compatibility entry from an {@link InputStream}.\n     *\n     * @param inputStream The stream that contains the package compatibility info.\n     * @throws IOException Never.\n     * @return {@code true}.\n     * @deprecated This function no longer checks {@code inputStream} and\n     *   unconditionally returns true. Instead, check compatibility when the\n     *   OTA package is generated.\n     ",
    "links" : [ "java.io.ByteArrayInputStream" ]
  }, {
    "name" : "public static boolean verifyPackageCompatibility(File compatibilityFile) throws IOException",
    "returnType" : "boolean",
    "comment" : "\n     * Verifies the package compatibility info against the current system.\n     *\n     * @param compatibilityFile the {@link File} that contains the package compatibility info.\n     * @throws IOException Never.\n     * @return {@code true}\n     * @deprecated This function no longer checks {@code compatibilityFile} and\n     *   unconditionally returns true. Instead, check compatibility when the\n     *   OTA package is generated.\n     *\n     * {@hide}\n     ",
    "links" : [ "java.io.File" ]
  }, {
    "name" : "public static void processPackage(Context context, File packageFile, final ProgressListener listener, final Handler handler) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Process a given package with uncrypt. No-op if the package is not on the\n     * /data partition.\n     *\n     * @param Context      the Context to use\n     * @param packageFile  the package to be processed\n     * @param listener     an object to receive periodic progress updates as\n     *                     processing proceeds.  May be null.\n     * @param handler      the Handler upon which the callbacks will be\n     *                     executed.\n     *\n     * @throws IOException if there were any errors processing the package file.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void processPackage(Context context, File packageFile, final ProgressListener listener) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Process a given package with uncrypt. No-op if the package is not on the\n     * /data partition.\n     *\n     * @param Context      the Context to use\n     * @param packageFile  the package to be processed\n     * @param listener     an object to receive periodic progress updates as\n     *                     processing proceeds.  May be null.\n     *\n     * @throws IOException if there were any errors processing the package file.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void installPackage(Context context, File packageFile) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Reboots the device in order to install the given update\n     * package.\n     * Requires the {@link android.Manifest.permission#REBOOT} permission.\n     *\n     * @param context      the Context to use\n     * @param packageFile  the update package to install.  Must be on\n     * a partition mountable by recovery.  (The set of partitions\n     * known to recovery may vary from device to device.  Generally,\n     * /cache and /data are safe.)\n     *\n     * @throws IOException  if writing the recovery command file\n     * fails, or if the reboot itself fails.\n     ",
    "links" : [ "android.Manifest.permission#REBOOT" ]
  }, {
    "name" : "public static void installPackage(Context context, File packageFile, boolean processed) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * If the package hasn't been processed (i.e. uncrypt'd), set up\n     * UNCRYPT_PACKAGE_FILE and delete BLOCK_MAP_FILE to trigger uncrypt during the\n     * reboot.\n     *\n     * @param context      the Context to use\n     * @param packageFile  the update package to install.  Must be on a\n     * partition mountable by recovery.\n     * @param processed    if the package has been processed (uncrypt'd).\n     *\n     * @throws IOException if writing the recovery command file fails, or if\n     * the reboot itself fails.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void prepareForUnattendedUpdate(@NonNull Context context, @NonNull String updateToken, @Nullable IntentSender intentSender) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Prepare to apply an unattended update by asking the user for their Lock Screen Knowledge\n     * Factor (LSKF). If supplied, the {@code intentSender} will be called when the system is setup\n     * and ready to apply the OTA. <p>\n     *\n     * <p> If the device doesn't setup a lock screen, i.e. by checking\n     * {@link KeyguardManager#isKeyguardSecure()}, this API call will fail and throw an exception.\n     * Callers are expected to use {@link PowerManager#reboot(String)} directly without going\n     * through the RoR flow. <p>\n     *\n     * <p>  This API is expected to handle requests from multiple clients simultaneously, e.g.\n     * from ota and mainline. The behavior of multi-client Resume on Reboot works as follows\n     * <li> Each client should call this function to prepare for Resume on Reboot before calling\n     *      {@link #rebootAndApply(Context, String, boolean)} </li>\n     * <li> One client cannot clear the Resume on Reboot preparation of another client. </li>\n     * <li> If multiple clients have prepared for Resume on Reboot, the subsequent reboot will be\n     *      first come, first served. </li>\n     *\n     * @param context the Context to use.\n     * @param updateToken this parameter is deprecated and won't be used. Callers can supply with\n     *                    an empty string. See details in\n     *                    <a href=\"http://go/multi-client-ror\">http://go/multi-client-ror</a>\n     *                    TODO(xunchang) update the link of document with the public doc.\n     * @param intentSender the intent to call when the update is prepared; may be {@code null}\n     * @throws IOException if there were any errors setting up unattended update\n     * @hide\n     ",
    "links" : [ "android.os.PowerManager#reboot(String)", "#rebootAndApply(Context", "android.app.KeyguardManager#isKeyguardSecure()" ]
  }, {
    "name" : "public static void clearPrepareForUnattendedUpdate(@NonNull Context context) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Request that any previously requested Lock Screen Knowledge Factor (LSKF) is cleared and\n     * the preparation for unattended update is reset.\n     *\n     * <p> Note that the API won't clear the underlying Resume on Reboot preparation state if\n     * another client has requested. So the reboot call from the other client can still succeed.\n     *\n     * @param context the Context to use.\n     * @throws IOException if there were any errors clearing the unattended update state\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void rebootAndApply(@NonNull Context context, @NonNull String updateToken, @NonNull String reason) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Request that the device reboot and apply the update that has been prepared. This API is\n     * deprecated, and is expected to be used by OTA only on devices running Android 11.\n     *\n     * @param context the Context to use.\n     * @param updateToken this parameter is deprecated and won't be used. See details in\n     *                    <a href=\"http://go/multi-client-ror\">http://go/multi-client-ror</a>\n     *                    TODO(xunchang) update the link of document with the public doc.\n     * @param reason the reboot reason to give to the {@link PowerManager}\n     * @throws IOException if the reboot couldn't proceed because the device wasn't ready for an\n     *               unattended reboot or if the {@code updateToken} did not match the previously\n     *               given token\n     * @hide\n     * @deprecated Use {@link #rebootAndApply(Context, String, boolean)} instead\n     ",
    "links" : [ "android.os.PowerManager", "#rebootAndApply(Context" ]
  }, {
    "name" : "public static boolean isPreparedForUnattendedUpdate(@NonNull Context context) throws IOException",
    "returnType" : "boolean",
    "comment" : "\n     * Query if Resume on Reboot has been prepared for a given caller.\n     *\n     * @param context the Context to use.\n     * @throws IOException if there were any errors connecting to the service or querying the state.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static int rebootAndApply(@NonNull Context context, @NonNull String reason, boolean slotSwitch) throws IOException",
    "returnType" : "int",
    "comment" : "\n     * Request that the device reboot and apply the update that has been prepared.\n     * {@link #prepareForUnattendedUpdate} must be called before for the given client,\n     * otherwise the function call will fail.\n     *\n     * @param context the Context to use.\n     * @param reason the reboot reason to give to the {@link PowerManager}\n     * @param slotSwitch true if the caller expects the slot to be switched on A/B devices.\n     *\n     * @return 0 on success, and a non-zero error code if the reboot couldn't proceed because the\n     *         device wasn't ready for an unattended reboot.\n     * @throws IOException on remote exceptions from the RecoverySystemService\n     * @hide\n     ",
    "links" : [ "android.os.PowerManager", "#prepareForUnattendedUpdate" ]
  }, {
    "name" : "public static void scheduleUpdateOnBoot(Context context, File packageFile) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Schedule to install the given package on next boot. The caller needs to ensure that the\n     * package must have been processed (uncrypt'd) if needed. It sets up the command in BCB\n     * (bootloader control block), which will be read by the bootloader and the recovery image.\n     *\n     * @param context the Context to use.\n     * @param packageFile the package to be installed.\n     * @throws IOException if there were any errors setting up the BCB.\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void cancelScheduledUpdate(Context context) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Cancel any scheduled update by clearing up the BCB (bootloader control\n     * block).\n     *\n     * @param Context      the Context to use.\n     *\n     * @throws IOException if there were any errors clearing up the BCB.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void rebootWipeUserData(Context context) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Reboots the device and wipes the user data and cache\n     * partitions.  This is sometimes called a \"factory reset\", which\n     * is something of a misnomer because the system partition is not\n     * restored to its factory state.  Requires the\n     * {@link android.Manifest.permission#REBOOT} permission.\n     *\n     * @param context  the Context to use\n     *\n     * @throws IOException  if writing the recovery command file\n     * fails, or if the reboot itself fails.\n     * @throws SecurityException if the current user is not allowed to wipe data.\n     ",
    "links" : [ "android.Manifest.permission#REBOOT" ]
  }, {
    "name" : "public static void rebootWipeUserData(Context context, String reason) throws IOException",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static void rebootWipeUserData(Context context, boolean shutdown) throws IOException",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static void rebootWipeUserData(Context context, boolean shutdown, String reason, boolean force) throws IOException",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static void rebootWipeUserData(Context context, boolean shutdown, String reason, boolean force, boolean wipeEuicc) throws IOException",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static void rebootWipeUserData(Context context, boolean shutdown, String reason, boolean force, boolean wipeEuicc, boolean keepMemtagMode) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Reboots the device and wipes the user data and cache\n     * partitions.  This is sometimes called a \"factory reset\", which\n     * is something of a misnomer because the system partition is not\n     * restored to its factory state.  Requires the\n     * {@link android.Manifest.permission#REBOOT} permission.\n     *\n     * @param context   the Context to use\n     * @param shutdown  if true, the device will be powered down after\n     *                  the wipe completes, rather than being rebooted\n     *                  back to the regular system.\n     * @param reason    the reason for the wipe that is visible in the logs\n     * @param force     whether the {@link UserManager.DISALLOW_FACTORY_RESET} user restriction\n     *                  should be ignored\n     * @param wipeEuicc whether wipe the euicc data\n     * @param keepMemtagMode whether to tell recovery to keep currently configured memtag mode\n     *\n     * @throws IOException  if writing the recovery command file\n     * fails, or if the reboot itself fails.\n     * @throws SecurityException if the current user is not allowed to wipe data.\n     *\n     * @hide\n     ",
    "links" : [ "UserManager.DISALLOW_FACTORY_RESET", "android.Manifest.permission#REBOOT" ]
  }, {
    "name" : "public static boolean wipeEuiccData(Context context, final String packageName)",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether wipe Euicc data successfully or not.\n     *\n     * @param packageName the package name of the caller app.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void removeEuiccInvisibleSubs(Context context, EuiccManager euiccManager)",
    "returnType" : "void",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "private static boolean removeEuiccInvisibleSubs(Context context, List<SubscriptionInfo> subscriptionInfos, EuiccManager euiccManager)",
    "returnType" : "boolean",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "public static void rebootPromptAndWipeUserData(Context context, String reason) throws IOException",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static void rebootWipeCache(Context context) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Reboot into the recovery system to wipe the /cache partition.\n     * @throws IOException if something goes wrong.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static void rebootWipeCache(Context context, String reason) throws IOException",
    "returnType" : "void",
    "comment" : " {@hide} ",
    "links" : [ ]
  }, {
    "name" : "public static void rebootWipeAb(Context context, File packageFile, String reason) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Reboot into recovery and wipe the A/B device.\n     *\n     * @param Context      the Context to use.\n     * @param packageFile  the wipe package to be applied.\n     * @param reason       the reason to wipe.\n     *\n     * @throws IOException if something goes wrong.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "public void wipePartitionToExt4() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Reboot into recovery and wipe the data partition with ext4\n     *\n     * @throws IOException if something goes wrong.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void bootCommand(Context context, String... args) throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Reboot into the recovery system with the supplied argument.\n     * @param args to pass to the recovery utility.\n     * @throws IOException if something goes wrong.\n     ",
    "links" : [ ]
  }, {
    "name" : "public static String handleAftermath(Context context)",
    "returnType" : "String",
    "comment" : "\n     * Called after booting to process and remove recovery-related files.\n     * @return the log file from recovery, or null if none was found.\n     *\n     * @hide\n     ",
    "links" : [ ]
  }, {
    "name" : "private static void recursiveDelete(File name)",
    "returnType" : "void",
    "comment" : "\n     * Internally, delete a given file or directory recursively.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean uncrypt(String packageFile, IRecoverySystemProgressListener listener)",
    "returnType" : "boolean",
    "comment" : "\n     * Talks to RecoverySystemService via Binder to trigger uncrypt.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean setupBcb(String command)",
    "returnType" : "boolean",
    "comment" : "\n     * Talks to RecoverySystemService via Binder to set up the BCB.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean allocateSpaceForUpdate(File packageFile) throws RemoteException",
    "returnType" : "boolean",
    "comment" : "\n     * Talks to RecoverySystemService via Binder to allocate space\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean clearBcb()",
    "returnType" : "boolean",
    "comment" : "\n     * Talks to RecoverySystemService via Binder to clear up the BCB.\n     ",
    "links" : [ ]
  }, {
    "name" : "private void rebootRecoveryWithCommand(String command)",
    "returnType" : "void",
    "comment" : "\n     * Talks to RecoverySystemService via Binder to set up the BCB command and\n     * reboot into recovery accordingly.\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean requestLskf(String packageName, IntentSender sender) throws IOException",
    "returnType" : "boolean",
    "comment" : "\n     * Begins the process of asking the user for the Lock Screen Knowledge Factor.\n     *\n     * @param packageName the package name of the caller who requests Resume on Reboot\n     * @return true if the request was correct\n     * @throws IOException if the recovery system service could not be contacted\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean clearLskf(String packageName) throws IOException",
    "returnType" : "boolean",
    "comment" : "\n     * Calls the recovery system service and clears the setup for the OTA.\n     *\n     * @return true if the setup for OTA was cleared\n     * @throws IOException if the recovery system service could not be contacted\n     ",
    "links" : [ ]
  }, {
    "name" : "private boolean isLskfCaptured(String packageName) throws IOException",
    "returnType" : "boolean",
    "comment" : "\n     * Queries if the Resume on Reboot has been prepared for a given caller.\n     *\n     * @param packageName the identifier of the caller who requests Resume on Reboot\n     * @return true if Resume on Reboot is prepared.\n     * @throws IOException if the recovery system service could not be contacted\n     ",
    "links" : [ ]
  }, {
    "name" : "private int rebootWithLskf(String packageName, String reason, boolean slotSwitch) throws IOException",
    "returnType" : "int",
    "comment" : "\n     * Calls the recovery system service to reboot and apply update.\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "private int rebootWithLskfAssumeSlotSwitch(String packageName, String reason) throws IOException",
    "returnType" : "int",
    "comment" : "\n     * Calls the recovery system service to reboot and apply update. This is the legacy API and\n     * expects a slot switch for A/B devices.\n     *\n     ",
    "links" : [ ]
  }, {
    "name" : "private static String sanitizeArg(String arg)",
    "returnType" : "String",
    "comment" : "\n     * Internally, recovery treats each line of the command file as a separate\n     * argv, so we only need to protect against newlines and nulls.\n     ",
    "links" : [ ]
  } ],
  "methodNames" : [ "private static HashSet<X509Certificate> getTrustedCerts(File keystore) throws IOException, GeneralSecurityException", "public static void verifyPackage(File packageFile, ProgressListener listener, File deviceCertsZipFile) throws IOException, GeneralSecurityException", "private static boolean verifyPackageCompatibility(InputStream inputStream) throws IOException", "public static boolean verifyPackageCompatibility(File compatibilityFile) throws IOException", "public static void processPackage(Context context, File packageFile, final ProgressListener listener, final Handler handler) throws IOException", "public static void processPackage(Context context, File packageFile, final ProgressListener listener) throws IOException", "public static void installPackage(Context context, File packageFile) throws IOException", "public static void installPackage(Context context, File packageFile, boolean processed) throws IOException", "public static void prepareForUnattendedUpdate(@NonNull Context context, @NonNull String updateToken, @Nullable IntentSender intentSender) throws IOException", "public static void clearPrepareForUnattendedUpdate(@NonNull Context context) throws IOException", "public static void rebootAndApply(@NonNull Context context, @NonNull String updateToken, @NonNull String reason) throws IOException", "public static boolean isPreparedForUnattendedUpdate(@NonNull Context context) throws IOException", "public static int rebootAndApply(@NonNull Context context, @NonNull String reason, boolean slotSwitch) throws IOException", "public static void scheduleUpdateOnBoot(Context context, File packageFile) throws IOException", "public static void cancelScheduledUpdate(Context context) throws IOException", "public static void rebootWipeUserData(Context context) throws IOException", "public static void rebootWipeUserData(Context context, String reason) throws IOException", "public static void rebootWipeUserData(Context context, boolean shutdown) throws IOException", "public static void rebootWipeUserData(Context context, boolean shutdown, String reason, boolean force) throws IOException", "public static void rebootWipeUserData(Context context, boolean shutdown, String reason, boolean force, boolean wipeEuicc) throws IOException", "public static void rebootWipeUserData(Context context, boolean shutdown, String reason, boolean force, boolean wipeEuicc, boolean keepMemtagMode) throws IOException", "public static boolean wipeEuiccData(Context context, final String packageName)", "private static void removeEuiccInvisibleSubs(Context context, EuiccManager euiccManager)", "private static boolean removeEuiccInvisibleSubs(Context context, List<SubscriptionInfo> subscriptionInfos, EuiccManager euiccManager)", "public static void rebootPromptAndWipeUserData(Context context, String reason) throws IOException", "public static void rebootWipeCache(Context context) throws IOException", "public static void rebootWipeCache(Context context, String reason) throws IOException", "public static void rebootWipeAb(Context context, File packageFile, String reason) throws IOException", "public void wipePartitionToExt4() throws IOException", "private static void bootCommand(Context context, String... args) throws IOException", "public static String handleAftermath(Context context)", "private static void recursiveDelete(File name)", "private boolean uncrypt(String packageFile, IRecoverySystemProgressListener listener)", "private boolean setupBcb(String command)", "private boolean allocateSpaceForUpdate(File packageFile) throws RemoteException", "private boolean clearBcb()", "private void rebootRecoveryWithCommand(String command)", "private boolean requestLskf(String packageName, IntentSender sender) throws IOException", "private boolean clearLskf(String packageName) throws IOException", "private boolean isLskfCaptured(String packageName) throws IOException", "private int rebootWithLskf(String packageName, String reason, boolean slotSwitch) throws IOException", "private int rebootWithLskfAssumeSlotSwitch(String packageName, String reason) throws IOException", "private static String sanitizeArg(String arg)" ],
  "variableNames" : [ "TAG", "DEFAULT_KEYSTORE", "PUBLISH_PROGRESS_INTERVAL_MS", "DEFAULT_EUICC_FACTORY_RESET_TIMEOUT_MILLIS", "MIN_EUICC_FACTORY_RESET_TIMEOUT_MILLIS", "MAX_EUICC_FACTORY_RESET_TIMEOUT_MILLIS", "DEFAULT_EUICC_REMOVING_INVISIBLE_PROFILES_TIMEOUT_MILLIS", "MIN_EUICC_REMOVING_INVISIBLE_PROFILES_TIMEOUT_MILLIS", "MAX_EUICC_REMOVING_INVISIBLE_PROFILES_TIMEOUT_MILLIS", "RECOVERY_DIR", "LOG_FILE", "LAST_INSTALL_PATH", "LAST_PREFIX", "ACTION_EUICC_FACTORY_RESET", "ACTION_EUICC_REMOVE_INVISIBLE_SUBSCRIPTIONS", "PACKAGE_NAME_EUICC_DATA_MANAGEMENT_CALLBACK", "BLOCK_MAP_FILE", "UNCRYPT_PACKAGE_FILE", "UNCRYPT_STATUS_FILE", "LOG_FILE_MAX_LENGTH", "sRequestLock", "mService", "RESUME_ON_REBOOT_REBOOT_ERROR_NONE", "RESUME_ON_REBOOT_REBOOT_ERROR_UNSPECIFIED", "RESUME_ON_REBOOT_REBOOT_ERROR_INVALID_PACKAGE_NAME", "RESUME_ON_REBOOT_REBOOT_ERROR_LSKF_NOT_CAPTURED", "RESUME_ON_REBOOT_REBOOT_ERROR_SLOT_MISMATCH", "RESUME_ON_REBOOT_REBOOT_ERROR_PROVIDER_PREPARATION_FAILURE" ]
}