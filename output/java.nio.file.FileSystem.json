{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/java/nio/file/FileSystem.java",
  "packageName" : "java.nio.file",
  "className" : "FileSystem",
  "comment" : "",
  "links" : [ ],
  "variables" : [ ],
  "methods" : [ {
    "name" : "public abstract FileSystemProvider provider()",
    "returnType" : "FileSystemProvider",
    "comment" : "\n     * Returns the provider that created this file system.\n     *\n     * @return  The provider that created this file system.\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract void close() throws IOException",
    "returnType" : "void",
    "comment" : "\n     * Closes this file system.\n     *\n     * <p> After a file system is closed then all subsequent access to the file\n     * system, either by methods defined by this class or on objects associated\n     * with this file system, throw {@link ClosedFileSystemException}. If the\n     * file system is already closed then invoking this method has no effect.\n     *\n     * <p> Closing a file system will close all open {@link\n     * java.nio.channels.Channel channels}, {@link DirectoryStream directory-streams},\n     * {@link WatchService watch-service}, and other closeable objects associated\n     * with this file system. The {@link FileSystems#getDefault default} file\n     * system cannot be closed.\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     * @throws  UnsupportedOperationException\n     *          Thrown in the case of the default file system\n     ",
    "links" : [ "java.nio.file.FileSystems#getDefault", "java.nio.file.DirectoryStream", "java.nio.file.WatchService", "java.nio.file.ClosedFileSystemException", "java.nio.channels.Channel" ]
  }, {
    "name" : "public abstract boolean isOpen()",
    "returnType" : "boolean",
    "comment" : "\n     * Tells whether or not this file system is open.\n     *\n     * <p> File systems created by the default provider are always open.\n     *\n     * @return  {@code true} if, and only if, this file system is open\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract boolean isReadOnly()",
    "returnType" : "boolean",
    "comment" : "\n     * Tells whether or not this file system allows only read-only access to\n     * its file stores.\n     *\n     * @return  {@code true} if, and only if, this file system provides\n     *          read-only access\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract String getSeparator()",
    "returnType" : "String",
    "comment" : "\n     * Returns the name separator, represented as a string.\n     *\n     * <p> The name separator is used to separate names in a path string. An\n     * implementation may support multiple name separators in which case this\n     * method returns an implementation specific <em>default</em> name separator.\n     * This separator is used when creating path strings by invoking the {@link\n     * Path#toString() toString()} method.\n     *\n     * <p> In the case of the default provider, this method returns the same\n     * separator as {@link java.io.File#separator}.\n     *\n     * @return  The name separator\n     ",
    "links" : [ "java.nio.file.Path#toString()", "java.io.File#separator" ]
  }, {
    "name" : "public abstract Iterable<Path> getRootDirectories()",
    "returnType" : "Iterable<Path>",
    "comment" : "\n     * Returns an object to iterate over the paths of the root directories.\n     *\n     * <p> A file system provides access to a file store that may be composed\n     * of a number of distinct file hierarchies, each with its own top-level\n     * root directory. Unless denied by the security manager, each element in\n     * the returned iterator corresponds to the root directory of a distinct\n     * file hierarchy. The order of the elements is not defined. The file\n     * hierarchies may change during the lifetime of the Java virtual machine.\n     * For example, in some implementations, the insertion of removable media\n     * may result in the creation of a new file hierarchy with its own\n     * top-level directory.\n     *\n     * <p> When a security manager is installed, it is invoked to check access\n     * to the each root directory. If denied, the root directory is not returned\n     * by the iterator. In the case of the default provider, the {@link\n     * SecurityManager#checkRead(String)} method is invoked to check read access\n     * to each root directory. It is system dependent if the permission checks\n     * are done when the iterator is obtained or during iteration.\n     *\n     * @return  An object to iterate over the root directories\n     ",
    "links" : [ "#checkRead(String)" ]
  }, {
    "name" : "public abstract Iterable<FileStore> getFileStores()",
    "returnType" : "Iterable<FileStore>",
    "comment" : "\n     * Returns an object to iterate over the underlying file stores.\n     *\n     * <p> The elements of the returned iterator are the {@link\n     * FileStore FileStores} for this file system. The order of the elements is\n     * not defined and the file stores may change during the lifetime of the\n     * Java virtual machine. When an I/O error occurs, perhaps because a file\n     * store is not accessible, then it is not returned by the iterator.\n     *\n     * <p> In the case of the default provider, and a security manager is\n     * installed, the security manager is invoked to check {@link\n     * RuntimePermission}{@code (\"getFileStoreAttributes\")}. If denied, then\n     * no file stores are returned by the iterator. In addition, the security\n     * manager's {@link SecurityManager#checkRead(String)} method is invoked to\n     * check read access to the file store's <em>top-most</em> directory. If\n     * denied, the file store is not returned by the iterator. It is system\n     * dependent if the permission checks are done when the iterator is obtained\n     * or during iteration.\n     *\n     * <p> <b>Usage Example:</b>\n     * Suppose we want to print the space usage for all file stores:\n     * <pre>\n     *     for (FileStore store: FileSystems.getDefault().getFileStores()) {\n     *         long total = store.getTotalSpace() / 1024;\n     *         long used = (store.getTotalSpace() - store.getUnallocatedSpace()) / 1024;\n     *         long avail = store.getUsableSpace() / 1024;\n     *         System.out.format(\"%-20s %12d %12d %12d%n\", store, total, used, avail);\n     *     }\n     * </pre>\n     *\n     * @return  An object to iterate over the backing file stores\n     ",
    "links" : [ "java.nio.file.FileStore", "#checkRead(String)", "RuntimePermission" ]
  }, {
    "name" : "public abstract Set<String> supportedFileAttributeViews()",
    "returnType" : "Set<String>",
    "comment" : "\n     * Returns the set of the {@link FileAttributeView#name names} of the file\n     * attribute views supported by this {@code FileSystem}.\n     *\n     * <p> The {@link BasicFileAttributeView} is required to be supported and\n     * therefore the set contains at least one element, \"basic\".\n     *\n     * <p> The {@link FileStore#supportsFileAttributeView(String)\n     * supportsFileAttributeView(String)} method may be used to test if an\n     * underlying {@link FileStore} supports the file attributes identified by a\n     * file attribute view.\n     *\n     * @return  An unmodifiable set of the names of the supported file attribute\n     *          views\n     ",
    "links" : [ "java.nio.file.FileAttributeView#name", "java.nio.file.BasicFileAttributeView", "java.nio.file.FileStore", "java.nio.file.FileStore#supportsFileAttributeView(String)" ]
  }, {
    "name" : "public abstract Path getPath(String first, String... more)",
    "returnType" : "Path",
    "comment" : "\n     * Converts a path string, or a sequence of strings that when joined form\n     * a path string, to a {@code Path}. If {@code more} does not specify any\n     * elements then the value of the {@code first} parameter is the path string\n     * to convert. If {@code more} specifies one or more elements then each\n     * non-empty string, including {@code first}, is considered to be a sequence\n     * of name elements (see {@link Path}) and is joined to form a path string.\n     * The details as to how the Strings are joined is provider specific but\n     * typically they will be joined using the {@link #getSeparator\n     * name-separator} as the separator. For example, if the name separator is\n     * \"{@code /}\" and {@code getPath(\"/foo\",\"bar\",\"gus\")} is invoked, then the\n     * path string {@code \"/foo/bar/gus\"} is converted to a {@code Path}.\n     * A {@code Path} representing an empty path is returned if {@code first}\n     * is the empty string and {@code more} does not contain any non-empty\n     * strings.\n     *\n     * <p> The parsing and conversion to a path object is inherently\n     * implementation dependent. In the simplest case, the path string is rejected,\n     * and {@link InvalidPathException} thrown, if the path string contains\n     * characters that cannot be converted to characters that are <em>legal</em>\n     * to the file store. For example, on UNIX systems, the NUL (&#92;u0000)\n     * character is not allowed to be present in a path. An implementation may\n     * choose to reject path strings that contain names that are longer than those\n     * allowed by any file store, and where an implementation supports a complex\n     * path syntax, it may choose to reject path strings that are <em>badly\n     * formed</em>.\n     *\n     * <p> In the case of the default provider, path strings are parsed based\n     * on the definition of paths at the platform or virtual file system level.\n     * For example, an operating system may not allow specific characters to be\n     * present in a file name, but a specific underlying file store may impose\n     * different or additional restrictions on the set of legal\n     * characters.\n     *\n     * <p> This method throws {@link InvalidPathException} when the path string\n     * cannot be converted to a path. Where possible, and where applicable,\n     * the exception is created with an {@link InvalidPathException#getIndex\n     * index} value indicating the first position in the {@code path} parameter\n     * that caused the path string to be rejected.\n     *\n     * @param   first\n     *          the path string or initial part of the path string\n     * @param   more\n     *          additional strings to be joined to form the path string\n     *\n     * @return  the resulting {@code Path}\n     *\n     * @throws  InvalidPathException\n     *          If the path string cannot be converted\n     ",
    "links" : [ "#getSeparatorname", "java.nio.file.InvalidPathException", "java.nio.file.Path", "java.nio.file.InvalidPathException#getIndexindex" ]
  }, {
    "name" : "public abstract PathMatcher getPathMatcher(String syntaxAndPattern)",
    "returnType" : "PathMatcher",
    "comment" : "\n     * Returns a {@code PathMatcher} that performs match operations on the\n     * {@code String} representation of {@link Path} objects by interpreting a\n     * given pattern.\n     *\n     * The {@code syntaxAndPattern} parameter identifies the syntax and the\n     * pattern and takes the form:\n     * <blockquote><pre>\n     * <i>syntax</i><b>:</b><i>pattern</i>\n     * </pre></blockquote>\n     * where {@code ':'} stands for itself.\n     *\n     * <p> A {@code FileSystem} implementation supports the \"{@code glob}\" and\n     * \"{@code regex}\" syntaxes, and may support others. The value of the syntax\n     * component is compared without regard to case.\n     *\n     * <p> When the syntax is \"{@code glob}\" then the {@code String}\n     * representation of the path is matched using a limited pattern language\n     * that resembles regular expressions but with a simpler syntax. For example:\n     *\n     * <table class=\"striped\" style=\"text-align:left; margin-left:2em\">\n     * <caption style=\"display:none\">Pattern Language</caption>\n     * <thead>\n     * <tr>\n     *   <th scope=\"col\">Example\n     *   <th scope=\"col\">Description\n     * </tr>\n     * </thead>\n     * <tbody>\n     * <tr>\n     *   <th scope=\"row\">{@code *.java}</th>\n     *   <td>Matches a path that represents a file name ending in {@code .java}</td>\n     * </tr>\n     * <tr>\n     *   <th scope=\"row\">{@code *.*}</th>\n     *   <td>Matches file names containing a dot</td>\n     * </tr>\n     * <tr>\n     *   <th scope=\"row\">{@code *.{java,class}}</th>\n     *   <td>Matches file names ending with {@code .java} or {@code .class}</td>\n     * </tr>\n     * <tr>\n     *   <th scope=\"row\">{@code foo.?}</th>\n     *   <td>Matches file names starting with {@code foo.} and a single\n     *   character extension</td>\n     * </tr>\n     * <tr>\n     *   <th scope=\"row\"><code>&#47;home&#47;*&#47;*</code>\n     *   <td>Matches <code>&#47;home&#47;gus&#47;data</code></td>\n     * </tr>\n     * <tr>\n     *   <th scope=\"row\"><code>&#47;home&#47;**</code>\n     *   <td>Matches <code>&#47;home&#47;gus</code> and\n     *   <code>&#47;home&#47;gus&#47;data</code></td>\n     * </tr>\n     * </tbody>\n     * </table>\n     *\n     * <p> The following rules are used to interpret glob patterns:\n     *\n     * <ul>\n     *   <li><p> The {@code *} character matches zero or more {@link Character\n     *   characters} of a {@link Path#getName(int) name} component without\n     *   crossing directory boundaries. </p></li>\n     *\n     *   <li><p> The {@code **} characters matches zero or more {@link Character\n     *   characters} crossing directory boundaries. </p></li>\n     *\n     *   <li><p> The {@code ?} character matches exactly one character of a\n     *   name component.</p></li>\n     *\n     *   <li><p> The backslash character ({@code \\}) is used to escape characters\n     *   that would otherwise be interpreted as special characters. The expression\n     *   {@code \\\\} matches a single backslash and \"\\{\" matches a left brace\n     *   for example.  </p></li>\n     *\n     *   <li><p> The {@code [ ]} characters are a <i>bracket expression</i> that\n     *   match a single character of a name component out of a set of characters.\n     *   For example, {@code [abc]} matches {@code \"a\"}, {@code \"b\"}, or {@code \"c\"}.\n     *   The hyphen ({@code -}) may be used to specify a range so {@code [a-z]}\n     *   specifies a range that matches from {@code \"a\"} to {@code \"z\"} (inclusive).\n     *   These forms can be mixed so [abce-g] matches {@code \"a\"}, {@code \"b\"},\n     *   {@code \"c\"}, {@code \"e\"}, {@code \"f\"} or {@code \"g\"}. If the character\n     *   after the {@code [} is a {@code !} then it is used for negation so {@code\n     *   [!a-c]} matches any character except {@code \"a\"}, {@code \"b\"}, or {@code\n     *   \"c\"}.\n     *   <p> Within a bracket expression the {@code *}, {@code ?} and {@code \\}\n     *   characters match themselves. The ({@code -}) character matches itself if\n     *   it is the first character within the brackets, or the first character\n     *   after the {@code !} if negating.</p></li>\n     *\n     *   <li><p> The {@code { }} characters are a group of subpatterns, where\n     *   the group matches if any subpattern in the group matches. The {@code \",\"}\n     *   character is used to separate the subpatterns. Groups cannot be nested.\n     *   </p></li>\n     *\n     *   <li><p> Leading period<code>&#47;</code>dot characters in file name are\n     *   treated as regular characters in match operations. For example,\n     *   the {@code \"*\"} glob pattern matches file name {@code \".login\"}.\n     *   The {@link Files#isHidden} method may be used to test whether a file\n     *   is considered hidden.\n     *   </p></li>\n     *\n     *   <li><p> All other characters match themselves in an implementation\n     *   dependent manner. This includes characters representing any {@link\n     *   FileSystem#getSeparator name-separators}. </p></li>\n     *\n     *   <li><p> The matching of {@link Path#getRoot root} components is highly\n     *   implementation-dependent and is not specified. </p></li>\n     *\n     * </ul>\n     *\n     * <p> When the syntax is \"{@code regex}\" then the pattern component is a\n     * regular expression as defined by the {@link java.util.regex.Pattern}\n     * class.\n     *\n     * <p>  For both the glob and regex syntaxes, the matching details, such as\n     * whether the matching is case sensitive, are implementation-dependent\n     * and therefore not specified.\n     *\n     * @param   syntaxAndPattern\n     *          The syntax and pattern\n     *\n     * @return  A path matcher that may be used to match paths against the pattern\n     *\n     * @throws  IllegalArgumentException\n     *          If the parameter does not take the form: {@code syntax:pattern}\n     * @throws  java.util.regex.PatternSyntaxException\n     *          If the pattern is invalid\n     * @throws  UnsupportedOperationException\n     *          If the pattern syntax is not known to the implementation\n     *\n     * @see Files#newDirectoryStream(Path,String)\n     ",
    "links" : [ "java.nio.file.Path#getName(int)", "java.nio.file.Path#getRoot", "java.nio.file.Files#isHidden", "java.util.regex.Pattern", "java.nio.file.FileSystem#getSeparator", "java.nio.file.Path", "Charactercharacters" ]
  }, {
    "name" : "public abstract UserPrincipalLookupService getUserPrincipalLookupService()",
    "returnType" : "UserPrincipalLookupService",
    "comment" : "\n     * Returns the {@code UserPrincipalLookupService} for this file system\n     * <i>(optional operation)</i>. The resulting lookup service may be used to\n     * lookup user or group names.\n     *\n     * <p> <b>Usage Example:</b>\n     * Suppose we want to make \"joe\" the owner of a file:\n     * <pre>\n     *     UserPrincipalLookupService lookupService = FileSystems.getDefault().getUserPrincipalLookupService();\n     *     Files.setOwner(path, lookupService.lookupPrincipalByName(\"joe\"));\n     * </pre>\n     *\n     * @throws  UnsupportedOperationException\n     *          If this {@code FileSystem} does not does have a lookup service\n     *\n     * @return  The {@code UserPrincipalLookupService} for this file system\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract WatchService newWatchService() throws IOException",
    "returnType" : "WatchService",
    "comment" : "\n     * Constructs a new {@link WatchService} <i>(optional operation)</i>.\n     *\n     * <p> This method constructs a new watch service that may be used to watch\n     * registered objects for changes and events.\n     *\n     * @return  a new watch service\n     *\n     * @throws  UnsupportedOperationException\n     *          If this {@code FileSystem} does not support watching file system\n     *          objects for changes and events. This exception is not thrown\n     *          by {@code FileSystems} created by the default provider.\n     * @throws  IOException\n     *          If an I/O error occurs\n     ",
    "links" : [ "java.nio.file.WatchService" ]
  } ],
  "methodNames" : [ "public abstract FileSystemProvider provider()", "public abstract void close() throws IOException", "public abstract boolean isOpen()", "public abstract boolean isReadOnly()", "public abstract String getSeparator()", "public abstract Iterable<Path> getRootDirectories()", "public abstract Iterable<FileStore> getFileStores()", "public abstract Set<String> supportedFileAttributeViews()", "public abstract Path getPath(String first, String... more)", "public abstract PathMatcher getPathMatcher(String syntaxAndPattern)", "public abstract UserPrincipalLookupService getUserPrincipalLookupService()", "public abstract WatchService newWatchService() throws IOException" ],
  "variableNames" : [ ]
}