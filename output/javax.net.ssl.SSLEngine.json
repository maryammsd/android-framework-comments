{
  "filePath" : "/home/maryam/clearblue/files/android-source-35/javax/net/ssl/SSLEngine.java",
  "packageName" : "javax.net.ssl",
  "className" : "SSLEngine",
  "comment" : "",
  "links" : [ ],
  "variables" : [ {
    "name" : "peerHost",
    "type" : "String",
    "comment" : "",
    "links" : [ ]
  }, {
    "name" : "peerPort",
    "type" : "int",
    "comment" : "",
    "links" : [ ]
  } ],
  "methods" : [ {
    "name" : "public String getPeerHost()",
    "returnType" : "String",
    "comment" : "\n     * Returns the host name of the peer.\n     * <P>\n     * Note that the value is not authenticated, and should not be\n     * relied upon.\n     *\n     * @return  the host name of the peer, or null if nothing is\n     *          available.\n     ",
    "links" : [ ]
  }, {
    "name" : "public int getPeerPort()",
    "returnType" : "int",
    "comment" : "\n     * Returns the port number of the peer.\n     * <P>\n     * Note that the value is not authenticated, and should not be\n     * relied upon.\n     *\n     * @return  the port number of the peer, or -1 if nothing is\n     *          available.\n     ",
    "links" : [ ]
  }, {
    "name" : "public SSLEngineResult wrap(ByteBuffer src, ByteBuffer dst) throws SSLException",
    "returnType" : "SSLEngineResult",
    "comment" : "\n     * Attempts to encode a buffer of plaintext application data into\n     * SSL/TLS network data.\n     * <P>\n     * An invocation of this method behaves in exactly the same manner\n     * as the invocation:\n     * <blockquote><pre>\n     * {@link #wrap(ByteBuffer [], int, int, ByteBuffer)\n     *     engine.wrap(new ByteBuffer [] { src }, 0, 1, dst);}\n     * </pre></blockquote>\n     *\n     * @param   src\n     *          a <code>ByteBuffer</code> containing outbound application data\n     * @param   dst\n     *          a <code>ByteBuffer</code> to hold outbound network data\n     * @return  an <code>SSLEngineResult</code> describing the result\n     *          of this operation.\n     * @throws  SSLException\n     *          A problem was encountered while processing the\n     *          data that caused the <code>SSLEngine</code> to abort.\n     *          See the class description for more information on\n     *          engine closure.\n     * @throws  ReadOnlyBufferException\n     *          if the <code>dst</code> buffer is read-only.\n     * @throws  IllegalArgumentException\n     *          if either <code>src</code> or <code>dst</code>\n     *          is null.\n     * @throws  IllegalStateException if the client/server mode\n     *          has not yet been set.\n     * @see     #wrap(ByteBuffer [], int, int, ByteBuffer)\n     ",
    "links" : [ "#wrap(ByteBuffer" ]
  }, {
    "name" : "public SSLEngineResult wrap(ByteBuffer[] srcs, ByteBuffer dst) throws SSLException",
    "returnType" : "SSLEngineResult",
    "comment" : "\n     * Attempts to encode plaintext bytes from a sequence of data\n     * buffers into SSL/TLS network data.\n     * <P>\n     * An invocation of this method behaves in exactly the same manner\n     * as the invocation:\n     * <blockquote><pre>\n     * {@link #wrap(ByteBuffer [], int, int, ByteBuffer)\n     *     engine.wrap(srcs, 0, srcs.length, dst);}\n     * </pre></blockquote>\n     *\n     * @param   srcs\n     *          an array of <code>ByteBuffers</code> containing the\n     *          outbound application data\n     * @param   dst\n     *          a <code>ByteBuffer</code> to hold outbound network data\n     * @return  an <code>SSLEngineResult</code> describing the result\n     *          of this operation.\n     * @throws  SSLException\n     *          A problem was encountered while processing the\n     *          data that caused the <code>SSLEngine</code> to abort.\n     *          See the class description for more information on\n     *          engine closure.\n     * @throws  ReadOnlyBufferException\n     *          if the <code>dst</code> buffer is read-only.\n     * @throws  IllegalArgumentException\n     *          if either <code>srcs</code> or <code>dst</code>\n     *          is null, or if any element in <code>srcs</code> is null.\n     * @throws  IllegalStateException if the client/server mode\n     *          has not yet been set.\n     * @see     #wrap(ByteBuffer [], int, int, ByteBuffer)\n     ",
    "links" : [ "#wrap(ByteBuffer" ]
  }, {
    "name" : "public abstract SSLEngineResult wrap(ByteBuffer[] srcs, int offset, int length, ByteBuffer dst) throws SSLException",
    "returnType" : "SSLEngineResult",
    "comment" : "\n     * Attempts to encode plaintext bytes from a subsequence of data\n     * buffers into SSL/TLS network data.  This <i>\"gathering\"</i>\n     * operation encodes, in a single invocation, a sequence of bytes\n     * from one or more of a given sequence of buffers.  Gathering\n     * wraps are often useful when implementing network protocols or\n     * file formats that, for example, group data into segments\n     * consisting of one or more fixed-length headers followed by a\n     * variable-length body.  See\n     * {@link java.nio.channels.GatheringByteChannel} for more\n     * information on gathering, and {@link\n     * java.nio.channels.GatheringByteChannel#write(ByteBuffer[],\n     * int, int)} for more information on the subsequence\n     * behavior.\n     * <P>\n     * Depending on the state of the SSLEngine, this method may produce\n     * network data without consuming any application data (for example,\n     * it may generate handshake data.)\n     * <P>\n     * The application is responsible for reliably transporting the\n     * network data to the peer, and for ensuring that data created by\n     * multiple calls to wrap() is transported in the same order in which\n     * it was generated.  The application must properly synchronize\n     * multiple calls to this method.\n     * <P>\n     * If this <code>SSLEngine</code> has not yet started its initial\n     * handshake, this method will automatically start the handshake.\n     * <P>\n     * This method will attempt to produce SSL/TLS records, and will\n     * consume as much source data as possible, but will never consume\n     * more than the sum of the bytes remaining in each buffer.  Each\n     * <code>ByteBuffer</code>'s position is updated to reflect the\n     * amount of data consumed or produced.  The limits remain the\n     * same.\n     * <P>\n     * The underlying memory used by the <code>srcs</code> and\n     * <code>dst ByteBuffer</code>s must not be the same.\n     * <P>\n     * See the class description for more information on engine closure.\n     *\n     * @param   srcs\n     *          an array of <code>ByteBuffers</code> containing the\n     *          outbound application data\n     * @param   offset\n     *          The offset within the buffer array of the first buffer from\n     *          which bytes are to be retrieved; it must be non-negative\n     *          and no larger than <code>srcs.length</code>\n     * @param   length\n     *          The maximum number of buffers to be accessed; it must be\n     *          non-negative and no larger than\n     *          <code>srcs.length</code>&nbsp;-&nbsp;<code>offset</code>\n     * @param   dst\n     *          a <code>ByteBuffer</code> to hold outbound network data\n     * @return  an <code>SSLEngineResult</code> describing the result\n     *          of this operation.\n     * @throws  SSLException\n     *          A problem was encountered while processing the\n     *          data that caused the <code>SSLEngine</code> to abort.\n     *          See the class description for more information on\n     *          engine closure.\n     * @throws  IndexOutOfBoundsException\n     *          if the preconditions on the <code>offset</code> and\n     *          <code>length</code> parameters do not hold.\n     * @throws  ReadOnlyBufferException\n     *          if the <code>dst</code> buffer is read-only.\n     * @throws  IllegalArgumentException\n     *          if either <code>srcs</code> or <code>dst</code>\n     *          is null, or if any element in the <code>srcs</code>\n     *          subsequence specified is null.\n     * @throws  IllegalStateException if the client/server mode\n     *          has not yet been set.\n     * @see     java.nio.channels.GatheringByteChannel\n     * @see     java.nio.channels.GatheringByteChannel#write(\n     *              ByteBuffer[], int, int)\n     ",
    "links" : [ "java.nio.channels.GatheringByteChannel#write(ByteBuffer", "java.nio.channels.GatheringByteChannel" ]
  }, {
    "name" : "public SSLEngineResult unwrap(ByteBuffer src, ByteBuffer dst) throws SSLException",
    "returnType" : "SSLEngineResult",
    "comment" : "\n     * Attempts to decode SSL/TLS network data into a plaintext\n     * application data buffer.\n     * <P>\n     * An invocation of this method behaves in exactly the same manner\n     * as the invocation:\n     * <blockquote><pre>\n     * {@link #unwrap(ByteBuffer, ByteBuffer [], int, int)\n     *     engine.unwrap(src, new ByteBuffer [] { dst }, 0, 1);}\n     * </pre></blockquote>\n     *\n     * @param   src\n     *          a <code>ByteBuffer</code> containing inbound network data.\n     * @param   dst\n     *          a <code>ByteBuffer</code> to hold inbound application data.\n     * @return  an <code>SSLEngineResult</code> describing the result\n     *          of this operation.\n     * @throws  SSLException\n     *          A problem was encountered while processing the\n     *          data that caused the <code>SSLEngine</code> to abort.\n     *          See the class description for more information on\n     *          engine closure.\n     * @throws  ReadOnlyBufferException\n     *          if the <code>dst</code> buffer is read-only.\n     * @throws  IllegalArgumentException\n     *          if either <code>src</code> or <code>dst</code>\n     *          is null.\n     * @throws  IllegalStateException if the client/server mode\n     *          has not yet been set.\n     * @see     #unwrap(ByteBuffer, ByteBuffer [], int, int)\n     ",
    "links" : [ "#unwrap(ByteBuffer" ]
  }, {
    "name" : "public SSLEngineResult unwrap(ByteBuffer src, ByteBuffer[] dsts) throws SSLException",
    "returnType" : "SSLEngineResult",
    "comment" : "\n     * Attempts to decode SSL/TLS network data into a sequence of plaintext\n     * application data buffers.\n     * <P>\n     * An invocation of this method behaves in exactly the same manner\n     * as the invocation:\n     * <blockquote><pre>\n     * {@link #unwrap(ByteBuffer, ByteBuffer [], int, int)\n     *     engine.unwrap(src, dsts, 0, dsts.length);}\n     * </pre></blockquote>\n     *\n     * @param   src\n     *          a <code>ByteBuffer</code> containing inbound network data.\n     * @param   dsts\n     *          an array of <code>ByteBuffer</code>s to hold inbound\n     *          application data.\n     * @return  an <code>SSLEngineResult</code> describing the result\n     *          of this operation.\n     * @throws  SSLException\n     *          A problem was encountered while processing the\n     *          data that caused the <code>SSLEngine</code> to abort.\n     *          See the class description for more information on\n     *          engine closure.\n     * @throws  ReadOnlyBufferException\n     *          if any of the <code>dst</code> buffers are read-only.\n     * @throws  IllegalArgumentException\n     *          if either <code>src</code> or <code>dsts</code>\n     *          is null, or if any element in <code>dsts</code> is null.\n     * @throws  IllegalStateException if the client/server mode\n     *          has not yet been set.\n     * @see     #unwrap(ByteBuffer, ByteBuffer [], int, int)\n     ",
    "links" : [ "#unwrap(ByteBuffer" ]
  }, {
    "name" : "public abstract SSLEngineResult unwrap(ByteBuffer src, ByteBuffer[] dsts, int offset, int length) throws SSLException",
    "returnType" : "SSLEngineResult",
    "comment" : "\n     * Attempts to decode SSL/TLS network data into a subsequence of\n     * plaintext application data buffers.  This <i>\"scattering\"</i>\n     * operation decodes, in a single invocation, a sequence of bytes\n     * into one or more of a given sequence of buffers.  Scattering\n     * unwraps are often useful when implementing network protocols or\n     * file formats that, for example, group data into segments\n     * consisting of one or more fixed-length headers followed by a\n     * variable-length body.  See\n     * {@link java.nio.channels.ScatteringByteChannel} for more\n     * information on scattering, and {@link\n     * java.nio.channels.ScatteringByteChannel#read(ByteBuffer[],\n     * int, int)} for more information on the subsequence\n     * behavior.\n     * <P>\n     * Depending on the state of the SSLEngine, this method may consume\n     * network data without producing any application data (for example,\n     * it may consume handshake data.)\n     * <P>\n     * The application is responsible for reliably obtaining the network\n     * data from the peer, and for invoking unwrap() on the data in the\n     * order it was received.  The application must properly synchronize\n     * multiple calls to this method.\n     * <P>\n     * If this <code>SSLEngine</code> has not yet started its initial\n     * handshake, this method will automatically start the handshake.\n     * <P>\n     * This method will attempt to consume one complete SSL/TLS network\n     * packet, but will never consume more than the sum of the bytes\n     * remaining in the buffers.  Each <code>ByteBuffer</code>'s\n     * position is updated to reflect the amount of data consumed or\n     * produced.  The limits remain the same.\n     * <P>\n     * The underlying memory used by the <code>src</code> and\n     * <code>dsts ByteBuffer</code>s must not be the same.\n     * <P>\n     * The inbound network buffer may be modified as a result of this\n     * call:  therefore if the network data packet is required for some\n     * secondary purpose, the data should be duplicated before calling this\n     * method.  Note:  the network data will not be useful to a second\n     * SSLEngine, as each SSLEngine contains unique random state which\n     * influences the SSL/TLS messages.\n     * <P>\n     * See the class description for more information on engine closure.\n     *\n     * @param   src\n     *          a <code>ByteBuffer</code> containing inbound network data.\n     * @param   dsts\n     *          an array of <code>ByteBuffer</code>s to hold inbound\n     *          application data.\n     * @param   offset\n     *          The offset within the buffer array of the first buffer from\n     *          which bytes are to be transferred; it must be non-negative\n     *          and no larger than <code>dsts.length</code>.\n     * @param   length\n     *          The maximum number of buffers to be accessed; it must be\n     *          non-negative and no larger than\n     *          <code>dsts.length</code>&nbsp;-&nbsp;<code>offset</code>.\n     * @return  an <code>SSLEngineResult</code> describing the result\n     *          of this operation.\n     * @throws  SSLException\n     *          A problem was encountered while processing the\n     *          data that caused the <code>SSLEngine</code> to abort.\n     *          See the class description for more information on\n     *          engine closure.\n     * @throws  IndexOutOfBoundsException\n     *          If the preconditions on the <code>offset</code> and\n     *          <code>length</code> parameters do not hold.\n     * @throws  ReadOnlyBufferException\n     *          if any of the <code>dst</code> buffers are read-only.\n     * @throws  IllegalArgumentException\n     *          if either <code>src</code> or <code>dsts</code>\n     *          is null, or if any element in the <code>dsts</code>\n     *          subsequence specified is null.\n     * @throws  IllegalStateException if the client/server mode\n     *          has not yet been set.\n     * @see     java.nio.channels.ScatteringByteChannel\n     * @see     java.nio.channels.ScatteringByteChannel#read(\n     *              ByteBuffer[], int, int)\n     ",
    "links" : [ "java.nio.channels.ScatteringByteChannel", "java.nio.channels.ScatteringByteChannel#read(ByteBuffer" ]
  }, {
    "name" : "public abstract Runnable getDelegatedTask()",
    "returnType" : "Runnable",
    "comment" : "\n     * Returns a delegated <code>Runnable</code> task for\n     * this <code>SSLEngine</code>.\n     * <P>\n     * <code>SSLEngine</code> operations may require the results of\n     * operations that block, or may take an extended period of time to\n     * complete.  This method is used to obtain an outstanding {@link\n     * java.lang.Runnable} operation (task).  Each task must be assigned\n     * a thread (possibly the current) to perform the {@link\n     * java.lang.Runnable#run() run} operation.  Once the\n     * <code>run</code> method returns, the <code>Runnable</code> object\n     * is no longer needed and may be discarded.\n     * <P>\n     * Delegated tasks run in the <code>AccessControlContext</code>\n     * in place when this object was created.\n     * <P>\n     * A call to this method will return each outstanding task\n     * exactly once.\n     * <P>\n     * Multiple delegated tasks can be run in parallel.\n     *\n     * @return  a delegated <code>Runnable</code> task, or null\n     *          if none are available.\n     ",
    "links" : [ "java.lang.Runnable#run()", "java.lang.Runnable" ]
  }, {
    "name" : "public abstract void closeInbound() throws SSLException",
    "returnType" : "void",
    "comment" : "\n     * Signals that no more inbound network data will be sent\n     * to this <code>SSLEngine</code>.\n     * <P>\n     * If the application initiated the closing process by calling\n     * {@link #closeOutbound()}, under some circumstances it is not\n     * required that the initiator wait for the peer's corresponding\n     * close message.  (See section 7.2.1 of the TLS specification (<A\n     * HREF=\"http://www.ietf.org/rfc/rfc2246.txt\">RFC 2246</A>) for more\n     * information on waiting for closure alerts.)  In such cases, this\n     * method need not be called.\n     * <P>\n     * But if the application did not initiate the closure process, or\n     * if the circumstances above do not apply, this method should be\n     * called whenever the end of the SSL/TLS data stream is reached.\n     * This ensures closure of the inbound side, and checks that the\n     * peer followed the SSL/TLS close procedure properly, thus\n     * detecting possible truncation attacks.\n     * <P>\n     * This method is idempotent:  if the inbound side has already\n     * been closed, this method does not do anything.\n     * <P>\n     * {@link #wrap(ByteBuffer, ByteBuffer) wrap()} should be\n     * called to flush any remaining handshake data.\n     *\n     * @throws  SSLException\n     *          if this engine has not received the proper SSL/TLS close\n     *          notification message from the peer.\n     *\n     * @see     #isInboundDone()\n     * @see     #isOutboundDone()\n     ",
    "links" : [ "#wrap(ByteBuffer", "#closeOutbound()" ]
  }, {
    "name" : "public abstract boolean isInboundDone()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether {@link #unwrap(ByteBuffer, ByteBuffer)} will\n     * accept any more inbound data messages.\n     *\n     * @return  true if the <code>SSLEngine</code> will not\n     *          consume anymore network data (and by implication,\n     *          will not produce any more application data.)\n     * @see     #closeInbound()\n     ",
    "links" : [ "#unwrap(ByteBuffer" ]
  }, {
    "name" : "public abstract void closeOutbound()",
    "returnType" : "void",
    "comment" : "\n     * Signals that no more outbound application data will be sent\n     * on this <code>SSLEngine</code>.\n     * <P>\n     * This method is idempotent:  if the outbound side has already\n     * been closed, this method does not do anything.\n     * <P>\n     * {@link #wrap(ByteBuffer, ByteBuffer)} should be\n     * called to flush any remaining handshake data.\n     *\n     * @see     #isOutboundDone()\n     ",
    "links" : [ "#wrap(ByteBuffer" ]
  }, {
    "name" : "public abstract boolean isOutboundDone()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns whether {@link #wrap(ByteBuffer, ByteBuffer)} will\n     * produce any more outbound data messages.\n     * <P>\n     * Note that during the closure phase, a <code>SSLEngine</code> may\n     * generate handshake closure data that must be sent to the peer.\n     * <code>wrap()</code> must be called to generate this data.  When\n     * this method returns true, no more outbound data will be created.\n     *\n     * @return  true if the <code>SSLEngine</code> will not produce\n     *          any more network data\n     *\n     * @see     #closeOutbound()\n     * @see     #closeInbound()\n     ",
    "links" : [ "#wrap(ByteBuffer" ]
  }, {
    "name" : "public abstract String[] getSupportedCipherSuites()",
    "returnType" : "String[]",
    "comment" : "\n     * Returns the names of the cipher suites which could be enabled for use\n     * on this engine.  Normally, only a subset of these will actually\n     * be enabled by default, since this list may include cipher suites which\n     * do not meet quality of service requirements for those defaults.  Such\n     * cipher suites might be useful in specialized applications.\n     *\n     * <p class=\"caution\">Applications should not blindly enable all supported\n     * cipher suites.  The supported cipher suites can include signaling cipher suite\n     * values that can cause connection problems if enabled inappropriately.\n     *\n     * <p>The proper way to use this method is to either check if a specific cipher\n     * suite is supported via {@code Arrays.asList(getSupportedCipherSuites()).contains(...)}\n     * or to filter a desired list of cipher suites to only the supported ones via\n     * {@code desiredSuiteSet.retainAll(Arrays.asList(getSupportedCipherSuites()))}.\n     *\n     * @return  an array of cipher suite names\n     * @see     #getEnabledCipherSuites()\n     * @see     #setEnabledCipherSuites(String [])\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract String[] getEnabledCipherSuites()",
    "returnType" : "String[]",
    "comment" : "\n     * Returns the names of the SSL cipher suites which are currently\n     * enabled for use on this engine.  When an SSLEngine is first\n     * created, all enabled cipher suites support a minimum quality of\n     * service.  Thus, in some environments this value might be empty.\n     * <P>\n     * Even if a suite has been enabled, it might never be used.  (For\n     * example, the peer does not support it, the requisite\n     * certificates/private keys for the suite are not available, or an\n     * anonymous suite is enabled but authentication is required.)\n     *\n     * @return  an array of cipher suite names\n     * @see     #getSupportedCipherSuites()\n     * @see     #setEnabledCipherSuites(String [])\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract void setEnabledCipherSuites(String[] suites)",
    "returnType" : "void",
    "comment" : "\n     * Sets the cipher suites enabled for use on this engine.\n     * <P>\n     * Each cipher suite in the <code>suites</code> parameter must have\n     * been listed by getSupportedCipherSuites(), or the method will\n     * fail.  Following a successful call to this method, only suites\n     * listed in the <code>suites</code> parameter are enabled for use.\n     * <P>\n     * See {@link #getEnabledCipherSuites()} for more information\n     * on why a specific cipher suite may never be used on a engine.\n     *\n     * @param   suites Names of all the cipher suites to enable\n     * @throws  IllegalArgumentException when one or more of the ciphers\n     *          named by the parameter is not supported, or when the\n     *          parameter is null.\n     * @see     #getSupportedCipherSuites()\n     * @see     #getEnabledCipherSuites()\n     ",
    "links" : [ "#getEnabledCipherSuites()" ]
  }, {
    "name" : "public abstract String[] getSupportedProtocols()",
    "returnType" : "String[]",
    "comment" : "\n     * Returns the names of the protocols which could be enabled for use\n     * with this <code>SSLEngine</code>.\n     *\n     * @return  an array of protocols supported\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract String[] getEnabledProtocols()",
    "returnType" : "String[]",
    "comment" : "\n     * Returns the names of the protocol versions which are currently\n     * enabled for use with this <code>SSLEngine</code>.\n     *\n     * @return  an array of protocols\n     * @see     #setEnabledProtocols(String [])\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract void setEnabledProtocols(String[] protocols)",
    "returnType" : "void",
    "comment" : "\n     * Set the protocol versions enabled for use on this engine.\n     * <P>\n     * The protocols must have been listed by getSupportedProtocols()\n     * as being supported.  Following a successful call to this method,\n     * only protocols listed in the <code>protocols</code> parameter\n     * are enabled for use.\n     * <p>\n     * Because of the way the protocol version is negotiated, connections\n     * will only be able to use a member of the lowest set of contiguous\n     * enabled protocol versions.  For example, enabling TLSv1.2 and TLSv1\n     * will result in connections only being able to use TLSv1.\n     *\n     * @param   protocols Names of all the protocols to enable.\n     * @throws  IllegalArgumentException when one or more of\n     *          the protocols named by the parameter is not supported or\n     *          when the protocols parameter is null.\n     * @see     #getEnabledProtocols()\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract SSLSession getSession()",
    "returnType" : "SSLSession",
    "comment" : "\n     * Returns the <code>SSLSession</code> in use in this\n     * <code>SSLEngine</code>.\n     * <P>\n     * These can be long lived, and frequently correspond to an entire\n     * login session for some user.  The session specifies a particular\n     * cipher suite which is being actively used by all connections in\n     * that session, as well as the identities of the session's client\n     * and server.\n     * <P>\n     * Unlike {@link SSLSocket#getSession()}\n     * this method does not block until handshaking is complete.\n     * <P>\n     * Until the initial handshake has completed, this method returns\n     * a session object which reports an invalid cipher suite of\n     * \"SSL_NULL_WITH_NULL_NULL\".\n     *\n     * @return  the <code>SSLSession</code> for this <code>SSLEngine</code>\n     * @see     SSLSession\n     ",
    "links" : [ "javax.net.ssl.SSLSocket#getSession()" ]
  }, {
    "name" : "public SSLSession getHandshakeSession()",
    "returnType" : "SSLSession",
    "comment" : "\n     * Returns the {@code SSLSession} being constructed during a SSL/TLS\n     * handshake.\n     * <p>\n     * TLS protocols may negotiate parameters that are needed when using\n     * an instance of this class, but before the {@code SSLSession} has\n     * been completely initialized and made available via {@code getSession}.\n     * For example, the list of valid signature algorithms may restrict\n     * the type of certificates that can used during TrustManager\n     * decisions, or the maximum TLS fragment packet sizes can be\n     * resized to better support the network environment.\n     * <p>\n     * This method provides early access to the {@code SSLSession} being\n     * constructed.  Depending on how far the handshake has progressed,\n     * some data may not yet be available for use.  For example, if a\n     * remote server will be sending a Certificate chain, but that chain\n     * has yet not been processed, the {@code getPeerCertificates}\n     * method of {@code SSLSession} will throw a\n     * SSLPeerUnverifiedException.  Once that chain has been processed,\n     * {@code getPeerCertificates} will return the proper value.\n     *\n     * @see SSLSocket\n     * @see SSLSession\n     * @see ExtendedSSLSession\n     * @see X509ExtendedKeyManager\n     * @see X509ExtendedTrustManager\n     *\n     * @return null if this instance is not currently handshaking, or\n     *         if the current handshake has not progressed far enough to\n     *         create a basic SSLSession.  Otherwise, this method returns the\n     *         {@code SSLSession} currently being negotiated.\n     * @throws UnsupportedOperationException if the underlying provider\n     *         does not implement the operation.\n     *\n     * @since 1.7\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract void beginHandshake() throws SSLException",
    "returnType" : "void",
    "comment" : "\n     * Initiates handshaking (initial or renegotiation) on this SSLEngine.\n     * <P>\n     * This method is not needed for the initial handshake, as the\n     * <code>wrap()</code> and <code>unwrap()</code> methods will\n     * implicitly call this method if handshaking has not already begun.\n     * <P>\n     * Note that the peer may also request a session renegotiation with\n     * this <code>SSLEngine</code> by sending the appropriate\n     * session renegotiate handshake message.\n     * <P>\n     * Unlike the {@link SSLSocket#startHandshake()\n     * SSLSocket#startHandshake()} method, this method does not block\n     * until handshaking is completed.\n     * <P>\n     * To force a complete SSL/TLS session renegotiation, the current\n     * session should be invalidated prior to calling this method.\n     * <P>\n     * Some protocols may not support multiple handshakes on an existing\n     * engine and may throw an <code>SSLException</code>.\n     *\n     * @throws  SSLException\n     *          if a problem was encountered while signaling the\n     *          <code>SSLEngine</code> to begin a new handshake.\n     *          See the class description for more information on\n     *          engine closure.\n     * @throws  IllegalStateException if the client/server mode\n     *          has not yet been set.\n     * @see     SSLSession#invalidate()\n     ",
    "links" : [ "javax.net.ssl.SSLSocket#startHandshake()" ]
  }, {
    "name" : "public abstract SSLEngineResult.HandshakeStatus getHandshakeStatus()",
    "returnType" : "SSLEngineResult.HandshakeStatus",
    "comment" : "\n     * Returns the current handshake status for this <code>SSLEngine</code>.\n     *\n     * @return  the current <code>SSLEngineResult.HandshakeStatus</code>.\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract void setUseClientMode(boolean mode)",
    "returnType" : "void",
    "comment" : "\n     * Configures the engine to use client (or server) mode when\n     * handshaking.\n     * <P>\n     * This method must be called before any handshaking occurs.\n     * Once handshaking has begun, the mode can not be reset for the\n     * life of this engine.\n     * <P>\n     * Servers normally authenticate themselves, and clients\n     * are not required to do so.\n     *\n     * @param   mode true if the engine should start its handshaking\n     *          in \"client\" mode\n     * @throws  IllegalArgumentException if a mode change is attempted\n     *          after the initial handshake has begun.\n     * @see     #getUseClientMode()\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract boolean getUseClientMode()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the engine is set to use client mode when\n     * handshaking.\n     *\n     * @return  true if the engine should do handshaking\n     *          in \"client\" mode\n     * @see     #setUseClientMode(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract void setNeedClientAuth(boolean need)",
    "returnType" : "void",
    "comment" : "\n     * Configures the engine to <i>require</i> client authentication.  This\n     * option is only useful for engines in the server mode.\n     * <P>\n     * An engine's client authentication setting is one of the following:\n     * <ul>\n     * <li> client authentication required\n     * <li> client authentication requested\n     * <li> no client authentication desired\n     * </ul>\n     * <P>\n     * Unlike {@link #setWantClientAuth(boolean)}, if this option is set and\n     * the client chooses not to provide authentication information\n     * about itself, <i>the negotiations will stop and the engine will\n     * begin its closure procedure</i>.\n     * <P>\n     * Calling this method overrides any previous setting made by\n     * this method or {@link #setWantClientAuth(boolean)}.\n     *\n     * @param   need set to true if client authentication is required,\n     *          or false if no client authentication is desired.\n     * @see     #getNeedClientAuth()\n     * @see     #setWantClientAuth(boolean)\n     * @see     #getWantClientAuth()\n     * @see     #setUseClientMode(boolean)\n     ",
    "links" : [ "#setWantClientAuth(boolean)" ]
  }, {
    "name" : "public abstract boolean getNeedClientAuth()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the engine will <i>require</i> client authentication.\n     * This option is only useful to engines in the server mode.\n     *\n     * @return  true if client authentication is required,\n     *          or false if no client authentication is desired.\n     * @see     #setNeedClientAuth(boolean)\n     * @see     #setWantClientAuth(boolean)\n     * @see     #getWantClientAuth()\n     * @see     #setUseClientMode(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract void setWantClientAuth(boolean want)",
    "returnType" : "void",
    "comment" : "\n     * Configures the engine to <i>request</i> client authentication.\n     * This option is only useful for engines in the server mode.\n     * <P>\n     * An engine's client authentication setting is one of the following:\n     * <ul>\n     * <li> client authentication required\n     * <li> client authentication requested\n     * <li> no client authentication desired\n     * </ul>\n     * <P>\n     * Unlike {@link #setNeedClientAuth(boolean)}, if this option is set and\n     * the client chooses not to provide authentication information\n     * about itself, <i>the negotiations will continue</i>.\n     * <P>\n     * Calling this method overrides any previous setting made by\n     * this method or {@link #setNeedClientAuth(boolean)}.\n     *\n     * @param   want set to true if client authentication is requested,\n     *          or false if no client authentication is desired.\n     * @see     #getWantClientAuth()\n     * @see     #setNeedClientAuth(boolean)\n     * @see     #getNeedClientAuth()\n     * @see     #setUseClientMode(boolean)\n     ",
    "links" : [ "#setNeedClientAuth(boolean)" ]
  }, {
    "name" : "public abstract boolean getWantClientAuth()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if the engine will <i>request</i> client authentication.\n     * This option is only useful for engines in the server mode.\n     *\n     * @return  true if client authentication is requested,\n     *          or false if no client authentication is desired.\n     * @see     #setNeedClientAuth(boolean)\n     * @see     #getNeedClientAuth()\n     * @see     #setWantClientAuth(boolean)\n     * @see     #setUseClientMode(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract void setEnableSessionCreation(boolean flag)",
    "returnType" : "void",
    "comment" : "\n     * Controls whether new SSL sessions may be established by this engine.\n     * If session creations are not allowed, and there are no\n     * existing sessions to resume, there will be no successful\n     * handshaking.\n     *\n     * @param   flag true indicates that sessions may be created; this\n     *          is the default.  false indicates that an existing session\n     *          must be resumed\n     * @see     #getEnableSessionCreation()\n     ",
    "links" : [ ]
  }, {
    "name" : "public abstract boolean getEnableSessionCreation()",
    "returnType" : "boolean",
    "comment" : "\n     * Returns true if new SSL sessions may be established by this engine.\n     *\n     * @return  true indicates that sessions may be created; this\n     *          is the default.  false indicates that an existing session\n     *          must be resumed\n     * @see     #setEnableSessionCreation(boolean)\n     ",
    "links" : [ ]
  }, {
    "name" : "public SSLParameters getSSLParameters()",
    "returnType" : "SSLParameters",
    "comment" : "\n     * Returns the SSLParameters in effect for this SSLEngine.\n     * The ciphersuites and protocols of the returned SSLParameters\n     * are always non-null.\n     *\n     * @return the SSLParameters in effect for this SSLEngine.\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "public void setSSLParameters(SSLParameters params)",
    "returnType" : "void",
    "comment" : "\n     * Applies SSLParameters to this engine.\n     *\n     * <p>This means:\n     * <ul>\n     * <li>If {@code params.getCipherSuites()} is non-null,\n     *   {@code setEnabledCipherSuites()} is called with that value.</li>\n     * <li>If {@code params.getProtocols()} is non-null,\n     *   {@code setEnabledProtocols()} is called with that value.</li>\n     * <li>If {@code params.getNeedClientAuth()} or\n     *   {@code params.getWantClientAuth()} return {@code true},\n     *   {@code setNeedClientAuth(true)} and\n     *   {@code setWantClientAuth(true)} are called, respectively;\n     *   otherwise {@code setWantClientAuth(false)} is called.</li>\n     * <li>If {@code params.getServerNames()} is non-null, the engine will\n     *   configure its server names with that value.</li>\n     * <li>If {@code params.getSNIMatchers()} is non-null, the engine will\n     *   configure its SNI matchers with that value.</li>\n     * </ul>\n     *\n     * @param params the parameters\n     * @throws IllegalArgumentException if the setEnabledCipherSuites() or\n     *    the setEnabledProtocols() call fails\n     * @since 1.6\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getApplicationProtocol()",
    "returnType" : "String",
    "comment" : "\n     * Returns the most recent application protocol value negotiated for this\n     * connection.\n     * <p>\n     * If supported by the underlying SSL/TLS implementation,\n     * application name negotiation mechanisms such as <a\n     * href=\"http://www.ietf.org/rfc/rfc7301.txt\"> RFC 7301 </a>, the\n     * Application-Layer Protocol Negotiation (ALPN), can negotiate\n     * application-level values between peers.\n     * <p>\n     * @implSpec\n     * The implementation in this class throws\n     * {@code UnsupportedOperationException} and performs no other action.\n     *\n     * @return null if it has not yet been determined if application\n     *         protocols might be used for this connection, an empty\n     *         {@code String} if application protocols values will not\n     *         be used, or a non-empty application protocol {@code String}\n     *         if a value was successfully negotiated.\n     * @throws UnsupportedOperationException if the underlying provider\n     *         does not implement the operation.\n     * @since 9\n     ",
    "links" : [ ]
  }, {
    "name" : "public String getHandshakeApplicationProtocol()",
    "returnType" : "String",
    "comment" : "\n     * Returns the application protocol value negotiated on a SSL/TLS\n     * handshake currently in progress.\n     * <p>\n     * Like {@link #getHandshakeSession()},\n     * a connection may be in the middle of a handshake. The\n     * application protocol may or may not yet be available.\n     * <p>\n     * @implSpec\n     * The implementation in this class throws\n     * {@code UnsupportedOperationException} and performs no other action.\n     *\n     * @return null if it has not yet been determined if application\n     *         protocols might be used for this handshake, an empty\n     *         {@code String} if application protocols values will not\n     *         be used, or a non-empty application protocol {@code String}\n     *         if a value was successfully negotiated.\n     * @throws UnsupportedOperationException if the underlying provider\n     *         does not implement the operation.\n     * @since 9\n     ",
    "links" : [ "#getHandshakeSession()" ]
  }, {
    "name" : "public void setHandshakeApplicationProtocolSelector(BiFunction<SSLEngine, List<String>, String> selector)",
    "returnType" : "void",
    "comment" : "\n     * Registers a callback function that selects an application protocol\n     * value for a SSL/TLS handshake.\n     * The function overrides any values supplied using\n     * {@link SSLParameters#setApplicationProtocols\n     * SSLParameters.setApplicationProtocols} and it supports the following\n     * type parameters:\n     * <blockquote>\n     * <dl>\n     * <dt> {@code SSLEngine}\n     * <dd> The function's first argument allows the current {@code SSLEngine}\n     *      to be inspected, including the handshake session and configuration\n     *      settings.\n     * <dt> {@code List<String>}\n     * <dd> The function's second argument lists the application protocol names\n     *      advertised by the TLS peer.\n     * <dt> {@code String}\n     * <dd> The function's result is an application protocol name, or null to\n     *      indicate that none of the advertised names are acceptable.\n     *      If the return value is an empty {@code String} then application\n     *      protocol indications will not be used.\n     *      If the return value is null (no value chosen) or is a value that\n     *      was not advertised by the peer, the underlying protocol will\n     *      determine what action to take. (For example, ALPN will send a\n     *      \"no_application_protocol\" alert and terminate the connection.)\n     * </dl>\n     * </blockquote>\n     *\n     * For example, the following call registers a callback function that\n     * examines the TLS handshake parameters and selects an application protocol\n     * name:\n     * <pre>{@code\n     *     serverEngine.setHandshakeApplicationProtocolSelector(\n     *         (serverEngine, clientProtocols) -> {\n     *             SSLSession session = serverEngine.getHandshakeSession();\n     *             return chooseApplicationProtocol(\n     *                 serverEngine,\n     *                 clientProtocols,\n     *                 session.getProtocol(),\n     *                 session.getCipherSuite());\n     *         });\n     * }</pre>\n     *\n     * @apiNote\n     * This method should be called by TLS server applications before the TLS\n     * handshake begins. Also, this {@code SSLEngine} should be configured with\n     * parameters that are compatible with the application protocol selected by\n     * the callback function. For example, enabling a poor choice of cipher\n     * suites could result in no suitable application protocol.\n     * See {@link SSLParameters}.\n     *\n     * @implSpec\n     * The implementation in this class throws\n     * {@code UnsupportedOperationException} and performs no other action.\n     *\n     * @param selector the callback function, or null to disable the callback\n     *         functionality.\n     * @throws UnsupportedOperationException if the underlying provider\n     *         does not implement the operation.\n     * @since 9\n     ",
    "links" : [ "javax.net.ssl.SSLParameters", "javax.net.ssl.SSLParameters#setApplicationProtocolsSSLParameters.setApplicationProtocols" ]
  }, {
    "name" : "public BiFunction<SSLEngine, List<String>, String> getHandshakeApplicationProtocolSelector()",
    "returnType" : "BiFunction<SSLEngine, List<String>, String>",
    "comment" : "\n     * Retrieves the callback function that selects an application protocol\n     * value during a SSL/TLS handshake.\n     * See {@link #setHandshakeApplicationProtocolSelector\n     * setHandshakeApplicationProtocolSelector}\n     * for the function's type parameters.\n     *\n     * @implSpec\n     * The implementation in this class throws\n     * {@code UnsupportedOperationException} and performs no other action.\n     *\n     * @return the callback function, or null if none has been set.\n     * @throws UnsupportedOperationException if the underlying provider\n     *         does not implement the operation.\n     * @since 9\n     ",
    "links" : [ "#setHandshakeApplicationProtocolSelectorsetHandshakeApplicationProtocolSelector" ]
  } ],
  "methodNames" : [ "public String getPeerHost()", "public int getPeerPort()", "public SSLEngineResult wrap(ByteBuffer src, ByteBuffer dst) throws SSLException", "public SSLEngineResult wrap(ByteBuffer[] srcs, ByteBuffer dst) throws SSLException", "public abstract SSLEngineResult wrap(ByteBuffer[] srcs, int offset, int length, ByteBuffer dst) throws SSLException", "public SSLEngineResult unwrap(ByteBuffer src, ByteBuffer dst) throws SSLException", "public SSLEngineResult unwrap(ByteBuffer src, ByteBuffer[] dsts) throws SSLException", "public abstract SSLEngineResult unwrap(ByteBuffer src, ByteBuffer[] dsts, int offset, int length) throws SSLException", "public abstract Runnable getDelegatedTask()", "public abstract void closeInbound() throws SSLException", "public abstract boolean isInboundDone()", "public abstract void closeOutbound()", "public abstract boolean isOutboundDone()", "public abstract String[] getSupportedCipherSuites()", "public abstract String[] getEnabledCipherSuites()", "public abstract void setEnabledCipherSuites(String[] suites)", "public abstract String[] getSupportedProtocols()", "public abstract String[] getEnabledProtocols()", "public abstract void setEnabledProtocols(String[] protocols)", "public abstract SSLSession getSession()", "public SSLSession getHandshakeSession()", "public abstract void beginHandshake() throws SSLException", "public abstract SSLEngineResult.HandshakeStatus getHandshakeStatus()", "public abstract void setUseClientMode(boolean mode)", "public abstract boolean getUseClientMode()", "public abstract void setNeedClientAuth(boolean need)", "public abstract boolean getNeedClientAuth()", "public abstract void setWantClientAuth(boolean want)", "public abstract boolean getWantClientAuth()", "public abstract void setEnableSessionCreation(boolean flag)", "public abstract boolean getEnableSessionCreation()", "public SSLParameters getSSLParameters()", "public void setSSLParameters(SSLParameters params)", "public String getApplicationProtocol()", "public String getHandshakeApplicationProtocol()", "public void setHandshakeApplicationProtocolSelector(BiFunction<SSLEngine, List<String>, String> selector)", "public BiFunction<SSLEngine, List<String>, String> getHandshakeApplicationProtocolSelector()" ],
  "variableNames" : [ "peerHost", "peerPort" ]
}